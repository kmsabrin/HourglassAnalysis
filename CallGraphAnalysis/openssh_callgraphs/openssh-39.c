/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 302 "/usr/include/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_51 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_52 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_53 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_54 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_55 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_56 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_50 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_51 _kill ;
   struct __anonstruct__timer_52 _timer ;
   struct __anonstruct__rt_53 _rt ;
   struct __anonstruct__sigchld_54 _sigchld ;
   struct __anonstruct__sigfault_55 _sigfault ;
   struct __anonstruct__sigpoll_56 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_50 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_65 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_65 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 141 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 49 "./openbsd-compat/glob.h"
struct dirent;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 20 "./openbsd-compat/port-tun.h"
struct Channel;
#line 19 "./buffer.h"
struct __anonstruct_Buffer_48 {
   u_char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "./buffer.h"
typedef struct __anonstruct_Buffer_48 Buffer;
#line 108 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 61 "./channels.h"
typedef void channel_callback_fn(int  , void * );
#line 62 "./channels.h"
typedef int channel_infilter_fn(struct Channel * , char * , int  );
#line 63 "./channels.h"
typedef void channel_filter_cleanup_fn(int  , void * );
#line 64 "./channels.h"
typedef u_char *channel_outfilter_fn(struct Channel * , u_char ** , u_int * );
#line 67 "./channels.h"
typedef void channel_confirm_cb(int  , struct Channel * , void * );
#line 68 "./channels.h"
typedef void channel_confirm_abandon_cb(struct Channel * , void * );
#line 69 "./channels.h"
struct __anonstruct_entry_55 {
   struct channel_confirm *tqe_next ;
   struct channel_confirm **tqe_prev ;
};
#line 69 "./channels.h"
struct channel_confirm {
   struct __anonstruct_entry_55 entry ;
   channel_confirm_cb *cb ;
   channel_confirm_abandon_cb *abandon_cb ;
   void *ctx ;
};
#line 75 "./channels.h"
struct channel_confirms {
   struct channel_confirm *tqh_first ;
   struct channel_confirm **tqh_last ;
};
#line 78 "./channels.h"
struct channel_connect {
   char *host ;
   int port ;
   struct addrinfo *ai ;
   struct addrinfo *aitop ;
};
#line 84 "./channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   u_int istate ;
   u_int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int ctl_fd ;
   int isatty ;
   int wfd_isatty ;
   int client_tty ;
   int force_drain ;
   int delayed ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char *path ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   u_int remote_window ;
   u_int remote_maxpacket ;
   u_int local_window ;
   u_int local_window_max ;
   u_int local_consumed ;
   u_int local_maxpacket ;
   int extended_usage ;
   int single_connection ;
   char *ctype ;
   channel_callback_fn *open_confirm ;
   void *open_confirm_ctx ;
   channel_callback_fn *detach_user ;
   int detach_close ;
   struct channel_confirms status_confirms ;
   channel_infilter_fn *input_filter ;
   channel_outfilter_fn *output_filter ;
   void *filter_ctx ;
   channel_filter_cleanup_fn *filter_cleanup ;
   int datagram ;
   struct channel_connect connect_ctx ;
};
#line 4 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_58 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 4 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_58 sync_serial_settings;
#line 10 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_59 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 10 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_59 te1_settings;
#line 17 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_60 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 17 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_60 raw_hdlc_proto;
#line 22 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_61 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 22 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_61 fr_proto;
#line 32 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_62 {
   unsigned int dlci ;
};
#line 32 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_62 fr_proto_pvc;
#line 36 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_63 {
   unsigned int dlci ;
   char master[16] ;
};
#line 36 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_63 fr_proto_pvc_info;
#line 41 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_64 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 41 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_64 cisco_proto;
#line 118 "/usr/include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 129 "/usr/include/linux/if.h"
union __anonunion_ifs_ifsu_67 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 129 "/usr/include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_67 ifs_ifsu ;
};
#line 154 "/usr/include/linux/if.h"
union __anonunion_ifr_ifrn_68 {
   char ifrn_name[16] ;
};
#line 154 "/usr/include/linux/if.h"
union __anonunion_ifr_ifru_69 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 154 "/usr/include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_68 ifr_ifrn ;
   union __anonunion_ifr_ifru_69 ifr_ifru ;
};
#line 40 "openbsd-compat/strtonum.c"
struct errval {
   char const   *errstr ;
   int err ;
};
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 87
struct sockaddr_in6;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_23 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_23 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_31 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_31 HEADER;
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_44 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_44 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_45 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_47 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_46 {
   char pad[52] ;
   struct __anonstruct__ext_47 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   char unused[3] ;
   struct __anonstruct_sort_list_45 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *ns , u_char const   **query ,
                            int *querylen , u_char *ans , int anssiz , int *resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *ns , u_char const   *query ,
                            int querylen , u_char *ans , int anssiz , int *resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_46 _u ;
};
#line 88 "./openbsd-compat/getrrsetbyname.h"
struct rdatainfo {
   unsigned int rdi_length ;
   unsigned char *rdi_data ;
};
#line 93 "./openbsd-compat/getrrsetbyname.h"
struct rrsetinfo {
   unsigned int rri_flags ;
   unsigned int rri_rdclass ;
   unsigned int rri_rdtype ;
   unsigned int rri_ttl ;
   unsigned int rri_nrdatas ;
   unsigned int rri_nsigs ;
   char *rri_name ;
   struct rdatainfo *rri_rdatas ;
   struct rdatainfo *rri_sigs ;
};
#line 148 "openbsd-compat/getrrsetbyname.c"
struct dns_query {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   struct dns_query *next ;
};
#line 155 "openbsd-compat/getrrsetbyname.c"
struct dns_rr {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   u_int16_t ttl ;
   u_int16_t size ;
   void *rdata ;
   struct dns_rr *next ;
};
#line 165 "openbsd-compat/getrrsetbyname.c"
struct dns_response {
   HEADER header ;
   struct dns_query *query ;
   struct dns_rr *answer ;
   struct dns_rr *authority ;
   struct dns_rr *additional ;
};
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 173 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 49 "./openbsd-compat/glob.h"
struct __anonstruct_glob_t_30 {
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 49 "./openbsd-compat/glob.h"
typedef struct __anonstruct_glob_t_30 glob_t;
#line 118 "openbsd-compat/glob.c"
typedef u_short Char;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 30 "acss.h"
struct acss_key_st {
   unsigned int lfsr17 ;
   unsigned int lfsr25 ;
   unsigned int lfsrsum ;
   unsigned char seed[5] ;
   unsigned char data[5] ;
   unsigned char subkey[5] ;
   int encrypt ;
   int mode ;
   int seeded ;
   int subkey_avilable ;
};
#line 30 "acss.h"
typedef struct acss_key_st ACSS_KEY;
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_un;
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_49 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_49 cb ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 52 "key.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 63 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 63 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_51 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_51 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_52 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_52 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 61 "cipher.h"
struct Cipher;
#line 61 "cipher.h"
typedef struct Cipher Cipher;
#line 62
struct CipherContext;
#line 62 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct CipherContext {
   int plaintext ;
   EVP_CIPHER_CTX evp ;
   Cipher *cipher ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 59 "channels.h"
typedef struct Channel Channel;
#line 109 "channels.c"
struct __anonstruct_ForwardPermission_59 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 109 "channels.c"
typedef struct __anonstruct_ForwardPermission_59 ForwardPermission;
#line 773 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 990 "channels.c"
struct __anonstruct_s4_req_60 {
   u_int8_t version ;
   u_int8_t command ;
   u_int16_t dest_port ;
   struct in_addr dest_addr ;
};
#line 1099 "channels.c"
struct __anonstruct_s5_req_61 {
   u_int8_t version ;
   u_int8_t command ;
   u_int8_t reserved ;
   u_int8_t atyp ;
};
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 60 "cipher.c"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   u_int discard_len ;
   u_int cbc_mode ;
   EVP_CIPHER const   *(*evptype)(void) ;
};
#line 29 "cipher-acss.c"
struct __anonstruct_EVP_ACSS_KEY_53 {
   ACSS_KEY ks ;
};
#line 29 "cipher-acss.c"
typedef struct __anonstruct_EVP_ACSS_KEY_53 EVP_ACSS_KEY;
#line 74 "/usr/include/openssl/aes.h"
struct aes_key_st {
   unsigned int rd_key[60] ;
   int rounds ;
};
#line 82 "/usr/include/openssl/aes.h"
typedef struct aes_key_st AES_KEY;
#line 39 "cipher-ctr.c"
struct ssh_aes_ctr_ctx {
   AES_KEY aes_ctx ;
   u_char aes_counter[16] ;
};
#line 54 "cipher-3des1.c"
struct ssh1_3des_ctx {
   EVP_CIPHER_CTX k1 ;
   EVP_CIPHER_CTX k2 ;
   EVP_CIPHER_CTX k3 ;
};
#line 62 "compat.c"
struct __anonstruct_check_52 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 37 "log.h"
enum __anonenum_LogLevel_51 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
#line 37 "log.h"
typedef enum __anonenum_LogLevel_51 LogLevel;
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 17 "hostfile.h"
enum __anonenum_HostStatus_54 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2,
    HOST_FOUND = 3
} ;
#line 17 "hostfile.h"
typedef enum __anonenum_HostStatus_54 HostStatus;
#line 19 "log.h"
typedef int SyslogFacility;
#line 67 "log.c"
struct __anonstruct_log_facilities_55 {
   char const   *name ;
   SyslogFacility val ;
};
#line 88 "log.c"
struct __anonstruct_log_levels_56 {
   char const   *name ;
   LogLevel val ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 73 "kex.h"
struct Mac;
#line 73 "kex.h"
typedef struct Mac Mac;
#line 74
struct Comp;
#line 74 "kex.h"
typedef struct Comp Comp;
#line 75
struct Enc;
#line 75 "kex.h"
typedef struct Enc Enc;
#line 76
struct Newkeys;
#line 76 "kex.h"
typedef struct Newkeys Newkeys;
#line 78 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_int key_len ;
   u_int block_size ;
   u_char *key ;
   u_char *iv ;
};
#line 87
struct umac_ctx;
#line 87 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   u_int mac_len ;
   u_char *key ;
   u_int key_len ;
   int type ;
   EVP_MD const   *evp_md ;
   HMAC_CTX evp_ctx ;
   struct umac_ctx *umac_ctx ;
};
#line 98 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 103 "kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 148 "packet.c"
struct packet_state {
   u_int32_t seqnr ;
   u_int32_t packets ;
   u_int64_t blocks ;
   u_int64_t bytes ;
};
#line 169 "packet.c"
struct __anonstruct_next_78 {
   struct packet *tqe_next ;
   struct packet **tqe_prev ;
};
#line 169 "packet.c"
struct packet {
   struct __anonstruct_next_78 next ;
   u_char type ;
   Buffer payload ;
};
#line 174 "packet.c"
struct __anonstruct_outgoing_79 {
   struct packet *tqh_first ;
   struct packet **tqh_last ;
};
#line 96 "readpass.c"
union __anonunion___u_75 {
   int __in ;
   int __i ;
};
#line 96 "readpass.c"
union __anonunion___u_76 {
   int __in ;
   int __i ;
};
#line 36 "addrmatch.c"
union __anonunion_xa_52 {
   struct in_addr v4 ;
   struct in6_addr v6 ;
   u_int8_t addr8[16] ;
   u_int32_t addr32[4] ;
};
#line 36 "addrmatch.c"
struct xaddr {
   sa_family_t af ;
   union __anonunion_xa_52 xa ;
   u_int32_t scope_id ;
};
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 37 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 40 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 39 "key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1,
    SSH_FP_RANDOMART = 2
} ;
#line 34 "dispatch.h"
typedef void dispatch_fn(int  , u_int32_t  , void * );
#line 72 "kex.h"
struct Kex;
#line 72 "kex.h"
typedef struct Kex Kex;
#line 108 "kex.h"
struct Kex {
   u_char *session_id ;
   u_int session_id_len ;
   Newkeys *newkeys[2] ;
   u_int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   sig_atomic_t done ;
   int flags ;
   EVP_MD const   *evp_md ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
   int (*host_key_index)(Key * ) ;
   void (*kex[4])(Kex * ) ;
};
#line 50 "mac.c"
struct __anonstruct_macs_74 {
   char *name ;
   int type ;
   EVP_MD const   *(*mdfunc)(void) ;
   int truncatebits ;
   int key_len ;
   int len ;
};
#line 42 "misc.h"
struct arglist;
#line 42 "misc.h"
typedef struct arglist arglist;
#line 43 "misc.h"
struct arglist {
   char **list ;
   u_int num ;
   u_int nalloc ;
};
#line 563 "misc.c"
struct __anonstruct_keys_56 {
   char const   *key ;
   char const   *repl ;
};
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 233 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 49 "monitor_fdpass.c"
union __anonunion_cmsgbuf_52 {
   struct cmsghdr hdr ;
   char buf[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
};
#line 105 "monitor_fdpass.c"
union __anonunion_cmsgbuf_53 {
   struct cmsghdr hdr ;
   char buf[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
};
#line 35 "rijndael.h"
typedef unsigned char u8;
#line 37 "rijndael.h"
typedef unsigned int u32;
#line 40 "rijndael.h"
struct __anonstruct_rijndael_ctx_50 {
   int decrypt ;
   int Nr ;
   u32 ek[60] ;
   u32 dk[60] ;
};
#line 40 "rijndael.h"
typedef struct __anonstruct_rijndael_ctx_50 rijndael_ctx;
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 80 "umac.c"
typedef u_int8_t UINT8;
#line 82 "umac.c"
typedef u_int32_t UINT32;
#line 83 "umac.c"
typedef u_int64_t UINT64;
#line 84 "umac.c"
typedef unsigned int UWORD;
#line 175 "umac.c"
typedef AES_KEY aes_int_key[1];
#line 217 "umac.c"
struct __anonstruct_pdf_ctx_53 {
   UINT8 cache[16] ;
   UINT8 nonce[16] ;
   aes_int_key prf_key ;
};
#line 217 "umac.c"
typedef struct __anonstruct_pdf_ctx_53 pdf_ctx;
#line 317 "umac.c"
struct __anonstruct_nh_ctx_54 {
   UINT8 nh_key[1040] ;
   UINT8 data[64] ;
   int next_data_empty ;
   int bytes_hashed ;
   UINT64 state[2] ;
};
#line 317 "umac.c"
typedef struct __anonstruct_nh_ctx_54 nh_ctx;
#line 772 "umac.c"
struct uhash_ctx {
   nh_ctx hash ;
   UINT64 poly_key_8[2] ;
   UINT64 poly_accum[2] ;
   UINT64 ip_keys[8] ;
   UINT32 ip_trans[2] ;
   UINT32 msg_len ;
};
#line 772 "umac.c"
typedef struct uhash_ctx uhash_ctx;
#line 781 "umac.c"
typedef struct uhash_ctx *uhash_ctx_t;
#line 1179 "umac.c"
struct umac_ctx {
   uhash_ctx hash ;
   pdf_ctx pdf ;
   void *free_ptr ;
};
#line 36 "jpake.h"
struct jpake_group {
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
};
#line 42 "jpake.h"
struct jpake_ctx {
   struct jpake_group *grp ;
   BIGNUM *s ;
   BIGNUM *k ;
   BIGNUM *x1 ;
   BIGNUM *x2 ;
   BIGNUM *x3 ;
   BIGNUM *x4 ;
   u_char *client_id ;
   u_int client_id_len ;
   BIGNUM *g_x1 ;
   BIGNUM *g_x2 ;
   u_char *server_id ;
   u_int server_id_len ;
   BIGNUM *g_x3 ;
   BIGNUM *g_x4 ;
   BIGNUM *a ;
   BIGNUM *b ;
   u_char *h_k_cid_sessid ;
   u_int h_k_cid_sessid_len ;
   u_char *h_k_sid_sessid ;
   u_int h_k_sid_sessid_len ;
};
#line 43 "servconf.h"
struct __anonstruct_ServerOptions_78 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   int ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   int address_family ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   int x11_use_localhost ;
   char *xauth_location ;
   int strict_modes ;
   int tcp_keep_alive ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int kerberos_authentication ;
   int kerberos_or_local_passwd ;
   int kerberos_ticket_cleanup ;
   int kerberos_get_afs_token ;
   int gss_authentication ;
   int gss_cleanup_creds ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int zero_knowledge_password_authentication ;
   int permit_empty_passwd ;
   int permit_user_env ;
   int use_login ;
   int compression ;
   int allow_tcp_forwarding ;
   int allow_agent_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   char *subsystem_args[256] ;
   u_int num_accept_env ;
   char *accept_env[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   int max_authtries ;
   int max_sessions ;
   char *banner ;
   int use_dns ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   char *adm_forced_command ;
   int use_pam ;
   int permit_tun ;
   int num_permitted_opens ;
   char *chroot_directory ;
};
#line 43 "servconf.h"
typedef struct __anonstruct_ServerOptions_78 ServerOptions;
#line 45 "auth.h"
struct Authctxt;
#line 45 "auth.h"
typedef struct Authctxt Authctxt;
#line 49 "auth.h"
struct Authctxt {
   sig_atomic_t success ;
   int authenticated ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   int force_pwchange ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
   void *jpake_ctx ;
   Buffer *loginmsg ;
   void *methoddata ;
};
#line 31 "monitor_mm.h"
struct __anonstruct_next_83 {
   struct mm_share *rbe_left ;
   struct mm_share *rbe_right ;
   struct mm_share *rbe_parent ;
   int rbe_color ;
};
#line 31 "monitor_mm.h"
struct mm_share {
   struct __anonstruct_next_83 next ;
   void *address ;
   size_t size ;
};
#line 37 "monitor_mm.h"
struct mmtree {
   struct mm_share *rbh_root ;
};
#line 37 "monitor_mm.h"
struct mm_master {
   struct mmtree rb_free ;
   struct mmtree rb_allocated ;
   void *address ;
   size_t size ;
   struct mm_master *mmalloc ;
};
#line 72 "monitor.h"
struct monitor {
   int m_recvfd ;
   int m_sendfd ;
   struct mm_master *m_zback ;
   struct mm_master *m_zlib ;
   struct Kex **m_pkex ;
   pid_t m_pid ;
};
#line 203 "sshd.c"
struct __anonstruct_sensitive_data_84 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 42 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 62 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[128] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 281 "servconf.c"
enum __anonenum_ServerOpCodes_79 {
    sBadOption = 0,
    sUsePAM = 1,
    sPort = 2,
    sHostKeyFile = 3,
    sServerKeyBits = 4,
    sLoginGraceTime = 5,
    sKeyRegenerationTime = 6,
    sPermitRootLogin = 7,
    sLogFacility = 8,
    sLogLevel = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sKerberosAuthentication = 12,
    sKerberosOrLocalPasswd = 13,
    sKerberosTicketCleanup = 14,
    sKerberosGetAFSToken = 15,
    sKerberosTgtPassing = 16,
    sChallengeResponseAuthentication = 17,
    sPasswordAuthentication = 18,
    sKbdInteractiveAuthentication = 19,
    sListenAddress = 20,
    sAddressFamily = 21,
    sPrintMotd = 22,
    sPrintLastLog = 23,
    sIgnoreRhosts = 24,
    sX11Forwarding = 25,
    sX11DisplayOffset = 26,
    sX11UseLocalhost = 27,
    sStrictModes = 28,
    sEmptyPasswd = 29,
    sTCPKeepAlive = 30,
    sPermitUserEnvironment = 31,
    sUseLogin = 32,
    sAllowTcpForwarding = 33,
    sCompression = 34,
    sAllowUsers = 35,
    sDenyUsers = 36,
    sAllowGroups = 37,
    sDenyGroups = 38,
    sIgnoreUserKnownHosts = 39,
    sCiphers = 40,
    sMacs = 41,
    sProtocol = 42,
    sPidFile = 43,
    sGatewayPorts = 44,
    sPubkeyAuthentication = 45,
    sXAuthLocation = 46,
    sSubsystem = 47,
    sMaxStartups = 48,
    sMaxAuthTries = 49,
    sMaxSessions = 50,
    sBanner = 51,
    sUseDNS = 52,
    sHostbasedAuthentication = 53,
    sHostbasedUsesNameFromPacketOnly = 54,
    sClientAliveInterval = 55,
    sClientAliveCountMax = 56,
    sAuthorizedKeysFile = 57,
    sAuthorizedKeysFile2 = 58,
    sGssAuthentication = 59,
    sGssCleanupCreds = 60,
    sAcceptEnv = 61,
    sPermitTunnel = 62,
    sMatch = 63,
    sPermitOpen = 64,
    sForceCommand = 65,
    sChrootDirectory = 66,
    sUsePrivilegeSeparation = 67,
    sAllowAgentForwarding = 68,
    sZeroKnowledgePasswordAuthentication = 69,
    sDeprecated = 70,
    sUnsupported = 71
} ;
#line 281 "servconf.c"
typedef enum __anonenum_ServerOpCodes_79 ServerOpCodes;
#line 317 "servconf.c"
struct __anonstruct_keywords_80 {
   char const   *name ;
   ServerOpCodes opcode ;
   u_int flags ;
};
#line 430 "servconf.c"
struct __anonstruct_tunmode_desc_81 {
   int val ;
   char *text ;
};
#line 30 "session.h"
struct Session;
#line 30 "session.h"
typedef struct Session Session;
#line 31 "session.h"
struct __anonstruct_env_81 {
   char *name ;
   char *val ;
};
#line 31 "session.h"
struct Session {
   int used ;
   int self ;
   int next_unused ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   u_int row ;
   u_int col ;
   u_int xpixel ;
   u_int ypixel ;
   char tty[64] ;
   u_int display_number ;
   char *display ;
   u_int screen ;
   char *auth_display ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int *x11_chanids ;
   int is_subsystem ;
   u_int num_env ;
   struct __anonstruct_env_81 *env ;
};
#line 761 "serverloop.c"
union __anonunion___u_83 {
   int __in ;
   int __i ;
};
#line 763 "serverloop.c"
union __anonunion___u_84 {
   int __in ;
   int __i ;
};
#line 759 "serverloop.c"
union __anonunion___u_85 {
   int __in ;
   int __i ;
};
#line 785 "serverloop.c"
union __anonunion___u_86 {
   int __in ;
   int __i ;
};
#line 783 "serverloop.c"
union __anonunion___u_87 {
   int __in ;
   int __i ;
};
#line 56 "auth1.c"
struct AuthMethod1 {
   int type ;
   char *name ;
   int *enabled ;
   int (*method)(Authctxt * , char * , size_t  ) ;
};
#line 46 "auth.h"
struct Authmethod;
#line 46 "auth.h"
typedef struct Authmethod Authmethod;
#line 83 "auth.h"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 19 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 2443 "session.c"
union __anonunion___u_82 {
   int __in ;
   int __i ;
};
#line 2447 "session.c"
union __anonunion___u_83___0 {
   int __in ;
   int __i ;
};
#line 2449 "session.c"
union __anonunion___u_84___0 {
   int __in ;
   int __i ;
};
#line 2449 "session.c"
union __anonunion___u_85___0 {
   int __in ;
   int __i ;
};
#line 2445 "session.c"
union __anonunion___u_86___0 {
   int __in ;
   int __i ;
};
#line 2441 "session.c"
union __anonunion___u_87___0 {
   int __in ;
   int __i ;
};
#line 47 "auth.h"
struct KbdintDevice;
#line 47 "auth.h"
typedef struct KbdintDevice KbdintDevice;
#line 96 "auth.h"
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
#line 78 "auth2-chall.c"
struct KbdintAuthctxt;
#line 78 "auth2-chall.c"
typedef struct KbdintAuthctxt KbdintAuthctxt;
#line 79 "auth2-chall.c"
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
   u_int nreq ;
};
#line 31 "monitor.h"
enum monitor_reqtype {
    MONITOR_REQ_MODULI = 0,
    MONITOR_ANS_MODULI = 1,
    MONITOR_REQ_FREE = 2,
    MONITOR_REQ_AUTHSERV = 3,
    MONITOR_REQ_SIGN = 4,
    MONITOR_ANS_SIGN = 5,
    MONITOR_REQ_PWNAM = 6,
    MONITOR_ANS_PWNAM = 7,
    MONITOR_REQ_AUTH2_READ_BANNER = 8,
    MONITOR_ANS_AUTH2_READ_BANNER = 9,
    MONITOR_REQ_AUTHPASSWORD = 10,
    MONITOR_ANS_AUTHPASSWORD = 11,
    MONITOR_REQ_BSDAUTHQUERY = 12,
    MONITOR_ANS_BSDAUTHQUERY = 13,
    MONITOR_REQ_BSDAUTHRESPOND = 14,
    MONITOR_ANS_BSDAUTHRESPOND = 15,
    MONITOR_REQ_SKEYQUERY = 16,
    MONITOR_ANS_SKEYQUERY = 17,
    MONITOR_REQ_SKEYRESPOND = 18,
    MONITOR_ANS_SKEYRESPOND = 19,
    MONITOR_REQ_KEYALLOWED = 20,
    MONITOR_ANS_KEYALLOWED = 21,
    MONITOR_REQ_KEYVERIFY = 22,
    MONITOR_ANS_KEYVERIFY = 23,
    MONITOR_REQ_KEYEXPORT = 24,
    MONITOR_REQ_PTY = 25,
    MONITOR_ANS_PTY = 26,
    MONITOR_REQ_PTYCLEANUP = 27,
    MONITOR_REQ_SESSKEY = 28,
    MONITOR_ANS_SESSKEY = 29,
    MONITOR_REQ_SESSID = 30,
    MONITOR_REQ_RSAKEYALLOWED = 31,
    MONITOR_ANS_RSAKEYALLOWED = 32,
    MONITOR_REQ_RSACHALLENGE = 33,
    MONITOR_ANS_RSACHALLENGE = 34,
    MONITOR_REQ_RSARESPONSE = 35,
    MONITOR_ANS_RSARESPONSE = 36,
    MONITOR_REQ_GSSSETUP = 37,
    MONITOR_ANS_GSSSETUP = 38,
    MONITOR_REQ_GSSSTEP = 39,
    MONITOR_ANS_GSSSTEP = 40,
    MONITOR_REQ_GSSUSEROK = 41,
    MONITOR_ANS_GSSUSEROK = 42,
    MONITOR_REQ_GSSCHECKMIC = 43,
    MONITOR_ANS_GSSCHECKMIC = 44,
    MONITOR_REQ_PAM_START = 45,
    MONITOR_REQ_PAM_ACCOUNT = 46,
    MONITOR_ANS_PAM_ACCOUNT = 47,
    MONITOR_REQ_PAM_INIT_CTX = 48,
    MONITOR_ANS_PAM_INIT_CTX = 49,
    MONITOR_REQ_PAM_QUERY = 50,
    MONITOR_ANS_PAM_QUERY = 51,
    MONITOR_REQ_PAM_RESPOND = 52,
    MONITOR_ANS_PAM_RESPOND = 53,
    MONITOR_REQ_PAM_FREE_CTX = 54,
    MONITOR_ANS_PAM_FREE_CTX = 55,
    MONITOR_REQ_AUDIT_EVENT = 56,
    MONITOR_REQ_AUDIT_COMMAND = 57,
    MONITOR_REQ_TERM = 58,
    MONITOR_REQ_JPAKE_STEP1 = 59,
    MONITOR_ANS_JPAKE_STEP1 = 60,
    MONITOR_REQ_JPAKE_GET_PWDATA = 61,
    MONITOR_ANS_JPAKE_GET_PWDATA = 62,
    MONITOR_REQ_JPAKE_STEP2 = 63,
    MONITOR_ANS_JPAKE_STEP2 = 64,
    MONITOR_REQ_JPAKE_KEY_CONFIRM = 65,
    MONITOR_ANS_JPAKE_KEY_CONFIRM = 66,
    MONITOR_REQ_JPAKE_CHECK_CONFIRM = 67,
    MONITOR_ANS_JPAKE_CHECK_CONFIRM = 68
} ;
#line 89
struct mon_table;
#line 34 "monitor_wrap.h"
enum mm_keytype {
    MM_NOKEY = 0,
    MM_HOSTKEY = 1,
    MM_USERKEY = 2,
    MM_RSAHOSTKEY = 3,
    MM_RSAUSERKEY = 4
} ;
#line 110 "monitor.c"
struct __anonstruct_child_state_83 {
   z_stream incoming ;
   z_stream outgoing ;
   u_char *keyin ;
   u_int keyinlen ;
   u_char *keyout ;
   u_int keyoutlen ;
   u_char *ivin ;
   u_int ivinlen ;
   u_char *ivout ;
   u_int ivoutlen ;
   u_char *ssh1key ;
   u_int ssh1keylen ;
   int ssh1cipher ;
   int ssh1protoflags ;
   u_char *input ;
   u_int ilen ;
   u_char *output ;
   u_int olen ;
};
#line 194 "monitor.c"
struct mon_table {
   enum monitor_reqtype type ;
   int flags ;
   int (*f)(int  , Buffer * ) ;
};
#line 1588 "monitor.c"
union __anonunion___u_84___1 {
   int __in ;
   int __i ;
};
#line 1588 "monitor.c"
union __anonunion___u_85___1 {
   int __in ;
   int __i ;
};
#line 1588 "monitor.c"
union __anonunion___u_86___1 {
   int __in ;
   int __i ;
};
#line 1588 "monitor.c"
union __anonunion___u_87___1 {
   int __in ;
   int __i ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 177 "/usr/include/bits/types.h"
typedef __u_quad_t __fsblkcnt64_t;
#line 181 "/usr/include/bits/types.h"
typedef __u_quad_t __fsfilcnt64_t;
#line 29 "/usr/include/bits/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   int __f_unused ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 31 "sftp-common.h"
struct Attrib;
#line 31 "sftp-common.h"
typedef struct Attrib Attrib;
#line 34 "sftp-common.h"
struct Attrib {
   u_int32_t flags ;
   u_int64_t size ;
   u_int32_t uid ;
   u_int32_t gid ;
   u_int32_t perm ;
   u_int32_t atime ;
   u_int32_t mtime ;
};
#line 75 "sftp-server.c"
struct Stat;
#line 75 "sftp-server.c"
typedef struct Stat Stat;
#line 77 "sftp-server.c"
struct Stat {
   char *name ;
   char *long_name ;
   Attrib attrib ;
};
#line 174
struct Handle;
#line 174 "sftp-server.c"
typedef struct Handle Handle;
#line 175 "sftp-server.c"
struct Handle {
   int use ;
   DIR *dirp ;
   int fd ;
   char *name ;
   u_int64_t bytes_read ;
   u_int64_t bytes_write ;
   int next_unused ;
};
#line 1 "port-irix.o"
#pragma merger(0,"./port-irix.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "port-aix.o"
#pragma merger(0,"./port-aix.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-arc4random.o"
#pragma merger(0,"./bsd-arc4random.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 156 "./openbsd-compat/openbsd-compat.h"
unsigned int arc4random(void) ;
#line 157
void arc4random_stir(void) ;
#line 161
void arc4random_buf(void *_buf , size_t n___0 ) ;
#line 165
u_int32_t arc4random_uniform(u_int32_t upper_bound ) ;
#line 32 "./entropy.h"
void seed_rng(void) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 56 "./log.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 39 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 40 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 46 "openbsd-compat/bsd-arc4random.c"
static int first_time  =    1;
#line 42 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 45
  r = 0U;
#line 48
  if (rc4_ready <= 0) {
#line 49
    if (first_time) {
#line 50
      seed_rng();
    }
#line 51
    first_time = 0;
#line 52
    arc4random_stir();
  }
#line 55
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 57
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 59
  return (r);
}
}
#line 62 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;
  int i ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 68
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 69
  tmp___0 = RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 69
  if (tmp___0 <= 0) {
#line 70
    tmp = ERR_get_error();
#line 70
    fatal("Couldn\'t obtain random bytes (error %ld)", tmp);
  }
#line 72
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 78
  i = 0;
#line 78
  while (i <= 256) {
#line 79
    RC4(& rc4, (unsigned long )sizeof(rand_buf), (unsigned char const   *)(rand_buf),
        rand_buf);
#line 78
    i = (int )((unsigned int )i + sizeof(rand_buf));
  }
#line 81
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 83
  rc4_ready = 1 << 24;
#line 84
  return;
}
}
#line 88 "openbsd-compat/bsd-arc4random.c"
void arc4random_buf(void *_buf , size_t n___0 ) 
{ size_t i ;
  u_int32_t r ;
  char *buf___1 ;

  {
#line 92
  r = (u_int32_t )0;
#line 93
  buf___1 = (char *)_buf;
#line 95
  i = 0U;
#line 95
  while (i < n___0) {
#line 96
    if (i % 4U == 0U) {
#line 97
      r = arc4random();
    }
#line 98
    *(buf___1 + i) = (char )(r & 255U);
#line 99
    r >>= 8;
#line 95
    i ++;
  }
#line 101
  r = 0U;
#line 101
  i = r;
#line 102
  return;
}
}
#line 116 "openbsd-compat/bsd-arc4random.c"
u_int32_t arc4random_uniform(u_int32_t upper_bound ) 
{ u_int32_t r ;
  u_int32_t min ;

  {
#line 121
  if (upper_bound < 2U) {
#line 122
    return (0U);
  }
#line 128
  if (upper_bound > 2147483648U) {
#line 129
    min = 1U + ~ upper_bound;
  } else {
#line 132
    min = ((4294967295U - upper_bound * 2U) + 1U) % upper_bound;
  }
#line 142
  while (1) {
#line 143
    r = arc4random();
#line 144
    if (r >= min) {
#line 145
      break;
    }
  }
#line 148
  return (r % upper_bound);
}
}
#line 1 "bsd-cray.o"
#pragma merger(0,"./bsd-cray.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-cygwin_util.o"
#pragma merger(0,"./bsd-cygwin_util.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-getpeereid.o"
#pragma merger(0,"./bsd-getpeereid.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 185 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 152 "./openbsd-compat/openbsd-compat.h"
int getpeereid(int s , uid_t *euid , gid_t *gid ) ;
#line 27 "openbsd-compat/bsd-getpeereid.c"
int getpeereid(int s , uid_t *euid , gid_t *gid ) 
{ struct ucred cred ;
  socklen_t len ;
  int tmp ;

  {
#line 31
  len = sizeof(cred);
#line 33
  tmp = getsockopt(s, 1, 17, (void * __restrict  )(& cred), (socklen_t * __restrict  )(& len));
#line 33
  if (tmp < 0) {
#line 34
    return (-1);
  }
#line 35
  *euid = cred.uid;
#line 36
  *gid = cred.gid;
#line 38
  return (0);
}
}
#line 1 "bsd-misc.o"
#pragma merger(0,"./bsd-misc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 24 "./openbsd-compat/bsd-misc.h"
char *ssh_get_progname(char *argv0___0 ) ;
#line 35
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 94
 __attribute__((__nothrow__)) void (*mysignal(int sig , void (*act)(int  ) ))(int  ) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 23 "./xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 46 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 43 "openbsd-compat/bsd-misc.c"
char *ssh_get_progname(char *argv0___0 ) 
{ char *tmp ;

  {
#line 48
  tmp = xstrdup((char const   *)__progname);
#line 48
  return (tmp);
}
}
#line 65
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 65 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 67
  return (0);
}
}
#line 202
 __attribute__((__nothrow__)) void (*mysignal(int sig , void (*act)(int  ) ))(int  ) ;
#line 202 "openbsd-compat/bsd-misc.c"
void (*mysignal(int sig , void (*act)(int  ) ))(int  ) 
{ struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;
  int tmp___0 ;

  {
#line 208
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa));
#line 208
  if (tmp == -1) {
#line 209
    return ((void (*)(int  ))-1);
  }
#line 210
  if ((unsigned int )osa.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 211
    memset((void *)(& sa), 0, sizeof(sa));
#line 212
    sigemptyset(& sa.sa_mask);
#line 213
    sa.sa_flags = 0;
#line 215
    if (sig == 14) {
#line 216
      sa.sa_flags |= 536870912;
    }
#line 218
    sa.__sigaction_handler.sa_handler = act;
#line 219
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 219
    if (tmp___0 == -1) {
#line 220
      return ((void (*)(int  ))-1);
    }
  }
#line 222
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 1 "bsd-nextstep.o"
#pragma merger(0,"./bsd-nextstep.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-openpty.o"
#pragma merger(0,"./bsd-openpty.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-snprintf.o"
#pragma merger(0,"./bsd-snprintf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-waitpid.o"
#pragma merger(0,"./bsd-waitpid.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-closefrom.o"
#pragma merger(0,"./bsd-closefrom.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 57 "./openbsd-compat/openbsd-compat.h"
void closefrom(int lowfd ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 564
extern  __attribute__((__nothrow__)) long sysconf(int __name )  __attribute__((__const__)) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 166
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64") __attribute__((__nonnull__(1))) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 68 "openbsd-compat/bsd-closefrom.c"
void closefrom(int lowfd ) 
{ long fd ;
  long maxfd ;
  char fdpath[4096] ;
  char *endp ;
  struct dirent *dent ;
  DIR *dirp ;
  int len ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 79
  tmp = getpid();
#line 79
  len = snprintf((char * __restrict  )(fdpath), sizeof(fdpath), (char const   * __restrict  )"/proc/%ld/fd",
                 (long )tmp);
#line 80
  if (len > 0) {
#line 80
    if ((unsigned int )len <= sizeof(fdpath)) {
#line 80
      dirp = opendir((char const   *)(fdpath));
#line 80
      if (dirp) {
#line 81
        while (1) {
#line 81
          dent = readdir(dirp);
#line 81
          if (! ((unsigned int )dent != (unsigned int )((void *)0))) {
#line 81
            break;
          }
#line 82
          fd = strtol((char const   * __restrict  )(dent->d_name), (char ** __restrict  )(& endp),
                      10);
#line 83
          if ((unsigned int )(dent->d_name) != (unsigned int )endp) {
#line 83
            if ((int )*endp == 0) {
#line 83
              if (fd >= 0L) {
#line 83
                if (fd < 2147483647L) {
#line 83
                  if (fd >= (long )lowfd) {
#line 83
                    tmp___0 = dirfd(dirp);
#line 83
                    if (fd != (long )tmp___0) {
#line 85
                      close((int )fd);
                    }
                  }
                }
              }
            }
          }
        }
#line 87
        closedir(dirp);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 97
    maxfd = sysconf(4);
#line 101
    if (maxfd < 0L) {
#line 102
      maxfd = 256L;
    }
#line 104
    fd = (long )lowfd;
#line 104
    while (fd < maxfd) {
#line 105
      close((int )fd);
#line 104
      fd ++;
    }
  }
#line 107
  return;
}
}
#line 1 "fake-rfc2553.o"
#pragma merger(0,"./fake-rfc2553.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "xmmap.o"
#pragma merger(0,"./xmmap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 307 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 712 "/usr/include/stdlib.h"
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 203 "./openbsd-compat/openbsd-compat.h"
void *xmmap(size_t size ) ;
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 792 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 973
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 47 "openbsd-compat/xmmap.c"
void *xmmap(size_t size ) 
{ void *address ;
  char tmpname[sizeof("/var/run/sshd.mm.XXXXXXXX")] ;
  int tmpfd ;
  mode_t old_umask ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 54
  address = mmap((void *)0, size, 3, 33, -1, 0LL);
#line 62
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 63
    tmpname[0] = (char )'/';
#line 63
    tmpname[1] = (char )'v';
#line 63
    tmpname[2] = (char )'a';
#line 63
    tmpname[3] = (char )'r';
#line 63
    tmpname[4] = (char )'/';
#line 63
    tmpname[5] = (char )'r';
#line 63
    tmpname[6] = (char )'u';
#line 63
    tmpname[7] = (char )'n';
#line 63
    tmpname[8] = (char )'/';
#line 63
    tmpname[9] = (char )'s';
#line 63
    tmpname[10] = (char )'s';
#line 63
    tmpname[11] = (char )'h';
#line 63
    tmpname[12] = (char )'d';
#line 63
    tmpname[13] = (char )'.';
#line 63
    tmpname[14] = (char )'m';
#line 63
    tmpname[15] = (char )'m';
#line 63
    tmpname[16] = (char )'.';
#line 63
    tmpname[17] = (char )'X';
#line 63
    tmpname[18] = (char )'X';
#line 63
    tmpname[19] = (char )'X';
#line 63
    tmpname[20] = (char )'X';
#line 63
    tmpname[21] = (char )'X';
#line 63
    tmpname[22] = (char )'X';
#line 63
    tmpname[23] = (char )'X';
#line 63
    tmpname[24] = (char )'X';
#line 63
    tmpname[25] = (char )'\000';
#line 67
    old_umask = umask(127U);
#line 68
    tmpfd = mkstemp(tmpname);
#line 69
    umask(old_umask);
#line 70
    if (tmpfd == -1) {
#line 71
      tmp = __errno_location();
#line 71
      tmp___0 = strerror(*tmp);
#line 71
      fatal("mkstemp(\"%s\"): %s", "/var/run/sshd.mm.XXXXXXXX", tmp___0);
    }
#line 73
    unlink((char const   *)(tmpname));
#line 74
    tmp___3 = ftruncate(tmpfd, (long long )size);
#line 74
    if (tmp___3 != 0) {
#line 75
      tmp___1 = __errno_location();
#line 75
      tmp___2 = strerror(*tmp___1);
#line 75
      fatal("%s: ftruncate: %s", "xmmap", tmp___2);
    }
#line 76
    address = mmap((void *)0, size, 3, 1, tmpfd, 0LL);
#line 78
    close(tmpfd);
  }
#line 81
  return (address);
}
}
#line 1 "xcrypt.o"
#pragma merger(0,"./xcrypt.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 204 "./openbsd-compat/openbsd-compat.h"
char *xcrypt(char const   *password , char const   *salt ) ;
#line 205
char *shadow_pw(struct passwd *pw___0 ) ;
#line 1073 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 60 "openbsd-compat/xcrypt.c"
char *xcrypt(char const   *password , char const   *salt ) 
{ char *crypted ;

  {
#line 78
  crypted = crypt(password, salt);
#line 81
  return (crypted);
}
}
#line 89 "openbsd-compat/xcrypt.c"
char *shadow_pw(struct passwd *pw___0 ) 
{ char *pw_password ;
  struct spwd *spw ;
  struct spwd *tmp ;

  {
#line 92
  pw_password = pw___0->pw_passwd;
#line 95
  tmp = getspnam((char const   *)pw___0->pw_name);
#line 95
  spw = tmp;
#line 97
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 98
    pw_password = spw->sp_pwdp;
  }
#line 116
  return (pw_password);
}
}
#line 1 "port-tun.o"
#pragma merger(0,"./port-tun.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 38 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 41
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 24 "./openbsd-compat/port-tun.h"
int sys_tun_open(int tun , int mode ) ;
#line 29
int sys_tun_infilter(struct Channel *c , char *buf___1 , int len ) ;
#line 30
u_char *sys_tun_outfilter(struct Channel *c , u_char **data , u_int *dlen ) ;
#line 68 "./buffer.h"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 70
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) ;
#line 51 "/usr/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 88 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
#line 63 "./log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 57 "openbsd-compat/port-tun.c"
int sys_tun_open(int tun , int mode ) 
{ struct ifreq ifr ;
  int fd ;
  char const   *name ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 61
  fd = -1;
#line 62
  name = (char const   *)((void *)0);
#line 64
  fd = open("/dev/net/tun", 2);
#line 64
  if (fd == -1) {
#line 65
    tmp = __errno_location();
#line 65
    tmp___0 = strerror(*tmp);
#line 65
    debug("%s: failed to open tunnel control interface: %s", "sys_tun_open", tmp___0);
#line 67
    return (-1);
  }
#line 70
  bzero((void *)(& ifr), sizeof(ifr));
#line 72
  if (mode == 2) {
#line 73
    ifr.ifr_ifru.ifru_flags = (short)2;
#line 74
    name = "tap%d";
  } else {
#line 76
    ifr.ifr_ifru.ifru_flags = (short)1;
#line 77
    name = "tun%d";
  }
#line 79
  ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags | 4096);
#line 81
  if (tun != 2147483647) {
#line 82
    if (tun > 2147483645) {
#line 83
      tmp___1 = __errno_location();
#line 83
      tmp___2 = strerror(*tmp___1);
#line 83
      debug("%s: invalid tunnel id %x: %s", "sys_tun_open", tun, tmp___2);
      goto failed;
    }
#line 87
    snprintf((char * __restrict  )(ifr.ifr_ifrn.ifrn_name), sizeof(ifr.ifr_ifrn.ifrn_name),
             (char const   * __restrict  )name, tun);
  }
#line 90
  if (sizeof(int ) == sizeof(int [1])) {
#line 90
    if (sizeof(int ) < (unsigned int )(1 << 14)) {
#line 90
      tmp___5 = sizeof(int );
    } else {
#line 90
      tmp___5 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 90
    tmp___5 = __invalid_size_argument_for_IOC;
  }
#line 90
  tmp___6 = ioctl(fd, (unsigned long )((((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (tmp___5 << 16)),
                  & ifr);
#line 90
  if (tmp___6 == -1) {
#line 91
    tmp___3 = __errno_location();
#line 91
    tmp___4 = strerror(*tmp___3);
#line 91
    debug("%s: failed to configure tunnel (mode %d): %s", "sys_tun_open", mode, tmp___4);
    goto failed;
  }
#line 96
  if (tun == 2147483647) {
#line 97
    debug("%s: tunnel mode %d fd %d", "sys_tun_open", mode, fd);
  } else {
#line 99
    debug("%s: %s mode %d fd %d", "sys_tun_open", ifr.ifr_ifrn.ifrn_name, mode, fd);
  }
#line 101
  return (fd);
  failed: 
#line 104
  close(fd);
#line 105
  return (-1);
}
}
#line 202 "openbsd-compat/port-tun.c"
int sys_tun_infilter(struct Channel *c , char *buf___1 , int len ) 
{ char rbuf[16384] ;
  struct ip *iph ;
  u_int32_t *af ;
  char *ptr ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  register unsigned int __v___1 ;
  register unsigned int __x___1 ;

  {
#line 210
  ptr = buf___1;
#line 213
  if (len <= 0) {
#line 214
    return (-1);
  } else {
#line 213
    if (len > (int )(sizeof(rbuf) - sizeof(*af))) {
#line 214
      return (-1);
    }
  }
#line 215
  ptr = rbuf;
#line 216
  bcopy((void const   *)buf___1, (void *)(ptr + sizeof(u_int32_t )), (unsigned int )len);
#line 217
  len = (int )((unsigned int )len + sizeof(u_int32_t ));
#line 218
  af = (u_int32_t *)ptr;
#line 220
  iph = (struct ip *)(ptr + sizeof(u_int32_t ));
#line 221
  switch ((int )iph->ip_v) {
  case 6: 
#line 223
  *af = 10U;
#line 224
  break;
  case 4: 
  default: 
#line 227
  *af = 2U;
#line 228
  break;
  }
#line 233
  if (len < (int )sizeof(u_int32_t )) {
#line 234
    return (-1);
  }
#line 236
  af = (u_int32_t *)ptr;
#line 237
  __x___1 = 10U;
#line 237
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 237
  if (*af == __v___1) {
#line 238
    __x = 24U;
#line 238
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 238
    *af = __v;
  } else {
#line 240
    __x___0 = 2U;
#line 240
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 240
    *af = __v___0;
  }
#line 243
  buffer_put_string(& c->input, (void const   *)ptr, (unsigned int )len);
#line 244
  return (0);
}
}
#line 247 "openbsd-compat/port-tun.c"
u_char *sys_tun_outfilter(struct Channel *c , u_char **data , u_int *dlen ) 
{ u_char *buf___1 ;
  u_int32_t *af ;
  void *tmp ;

  {
#line 253
  tmp = buffer_get_string(& c->output, dlen);
#line 253
  *data = (u_char *)tmp;
#line 254
  if (*dlen < sizeof(*af)) {
#line 255
    return ((u_char *)((void *)0));
  }
#line 256
  buf___1 = *data;
#line 259
  *dlen -= sizeof(u_int32_t );
#line 260
  buf___1 = *data + sizeof(u_int32_t );
#line 269
  return (buf___1);
}
}
#line 1 "strtonum.o"
#pragma merger(0,"./strtonum.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 210 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 306
extern  __attribute__((__nothrow__)) long long __strtoll_internal(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr ,
                                                                  int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 380
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 380 "/usr/include/stdlib.h"
__inline static long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) 
{ long long tmp ;

  {
#line 384
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
#line 384
  return (tmp);
}
}
#line 188 "./openbsd-compat/openbsd-compat.h"
long long strtonum(char const   *numstr , long long minval , long long maxval , char const   **errstrp ) ;
#line 33 "openbsd-compat/strtonum.c"
long long strtonum(char const   *numstr , long long minval , long long maxval , char const   **errstrp ) 
{ long long ll ;
  char *ep ;
  int error___0 ;
  struct errval ev[4] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 37
  ll = 0LL;
#line 39
  error___0 = 0;
#line 40
  ev[0].errstr = (char const   *)((void *)0);
#line 40
  ev[0].err = 0;
#line 40
  ev[1].errstr = "invalid";
#line 40
  ev[1].err = 22;
#line 40
  ev[2].errstr = "too small";
#line 40
  ev[2].err = 34;
#line 40
  ev[3].errstr = "too large";
#line 40
  ev[3].err = 34;
#line 50
  tmp = __errno_location();
#line 50
  ev[0].err = *tmp;
#line 51
  tmp___0 = __errno_location();
#line 51
  *tmp___0 = 0;
#line 52
  if (minval > maxval) {
#line 53
    error___0 = 1;
  } else {
#line 55
    ll = strtoll((char const   * __restrict  )numstr, (char ** __restrict  )(& ep),
                 10);
#line 56
    if ((unsigned int )numstr == (unsigned int )ep) {
#line 57
      error___0 = 1;
    } else {
#line 56
      if ((int )*ep != 0) {
#line 57
        error___0 = 1;
      } else {
#line 58
        if (ll == (-0x7FFFFFFFFFFFFFFF-1)) {
#line 58
          tmp___2 = __errno_location();
#line 58
          if (*tmp___2 == 34) {
#line 59
            error___0 = 2;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 58
          if (ll < minval) {
#line 59
            error___0 = 2;
          } else {
#line 60
            if (ll == 9223372036854775807LL) {
#line 60
              tmp___1 = __errno_location();
#line 60
              if (*tmp___1 == 34) {
#line 61
                error___0 = 3;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 60
              if (ll > maxval) {
#line 61
                error___0 = 3;
              }
            }
          }
        }
      }
    }
  }
#line 63
  if ((unsigned int )errstrp != (unsigned int )((void *)0)) {
#line 64
    *errstrp = ev[error___0].errstr;
  }
#line 65
  tmp___3 = __errno_location();
#line 65
  *tmp___3 = ev[error___0].err;
#line 66
  if (error___0) {
#line 67
    ll = 0LL;
  }
#line 69
  return (ll);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#pragma merger(0,"./base64.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 323 "/usr/include/resolv.h"
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 324
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 65 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 65 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 133
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 133 "openbsd-compat/base64.c"
int __b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  u_int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 136
  datalength = (size_t )0;
#line 141
  while (2U < srclength) {
#line 142
    tmp = src;
#line 142
    src ++;
#line 142
    input___0[0] = (unsigned char )*tmp;
#line 143
    tmp___0 = src;
#line 143
    src ++;
#line 143
    input___0[1] = (unsigned char )*tmp___0;
#line 144
    tmp___1 = src;
#line 144
    src ++;
#line 144
    input___0[2] = (unsigned char )*tmp___1;
#line 145
    srclength -= 3U;
#line 147
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 148
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 149
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 150
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 152
    if (datalength + 4U > targsize) {
#line 153
      return (-1);
    }
#line 154
    tmp___2 = datalength;
#line 154
    datalength ++;
#line 154
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 155
    tmp___3 = datalength;
#line 155
    datalength ++;
#line 155
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 156
    tmp___4 = datalength;
#line 156
    datalength ++;
#line 156
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 157
    tmp___5 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 161
  if (0U != srclength) {
#line 163
    input___0[2] = (unsigned char )'\000';
#line 163
    input___0[1] = input___0[2];
#line 163
    input___0[0] = input___0[1];
#line 164
    i = 0U;
#line 164
    while (i < srclength) {
#line 165
      tmp___6 = src;
#line 165
      src ++;
#line 165
      input___0[i] = (unsigned char )*tmp___6;
#line 164
      i ++;
    }
#line 167
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 168
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 169
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 171
    if (datalength + 4U > targsize) {
#line 172
      return (-1);
    }
#line 173
    tmp___7 = datalength;
#line 173
    datalength ++;
#line 173
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 174
    tmp___8 = datalength;
#line 174
    datalength ++;
#line 174
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 175
    if (srclength == 1U) {
#line 176
      tmp___9 = datalength;
#line 176
      datalength ++;
#line 176
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 178
      tmp___10 = datalength;
#line 178
      datalength ++;
#line 178
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 179
    tmp___11 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___11) = (char )Pad64;
  }
#line 181
  if (datalength >= targsize) {
#line 182
    return (-1);
  }
#line 183
  *(target + datalength) = (char )'\000';
#line 184
  return ((int )datalength);
}
}
#line 196
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 196 "openbsd-compat/base64.c"
int __b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ u_int tarindex ;
  u_int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 203
  state = 0U;
#line 204
  tarindex = 0U;
#line 206
  while (1) {
#line 206
    tmp___2 = src;
#line 206
    src ++;
#line 206
    ch = (int )*tmp___2;
#line 206
    if (! (ch != 0)) {
#line 206
      break;
    }
#line 207
    tmp = __ctype_b_loc();
#line 207
    if ((int const   )*(*tmp + ch) & 8192) {
#line 208
      continue;
    }
#line 210
    if (ch == (int )Pad64) {
#line 211
      break;
    }
#line 213
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 213
    pos = tmp___1;
#line 214
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 215
      return (-1);
    }
#line 217
    switch ((int )state) {
    case 0: 
#line 219
    if (target) {
#line 220
      if (tarindex >= targsize) {
#line 221
        return (-1);
      }
#line 222
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 224
    state = 1U;
#line 225
    break;
    case 1: 
#line 227
    if (target) {
#line 228
      if (tarindex + 1U >= targsize) {
#line 229
        return (-1);
      }
#line 230
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 231
      *(target + (tarindex + 1U)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 234
    tarindex ++;
#line 235
    state = 2U;
#line 236
    break;
    case 2: 
#line 238
    if (target) {
#line 239
      if (tarindex + 1U >= targsize) {
#line 240
        return (-1);
      }
#line 241
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 242
      *(target + (tarindex + 1U)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 245
    tarindex ++;
#line 246
    state = 3U;
#line 247
    break;
    case 3: 
#line 249
    if (target) {
#line 250
      if (tarindex >= targsize) {
#line 251
        return (-1);
      }
#line 252
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 254
    tarindex ++;
#line 255
    state = 0U;
#line 256
    break;
    }
  }
#line 265
  if (ch == (int )Pad64) {
#line 266
    tmp___3 = src;
#line 266
    src ++;
#line 266
    ch = (int )*tmp___3;
#line 267
    switch ((int )state) {
    case 0: 
    case 1: 
#line 270
    return (-1);
    case 2: 
#line 274
    while (ch != 0) {
#line 275
      tmp___5 = __ctype_b_loc();
#line 275
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 276
        break;
      }
#line 274
      tmp___4 = src;
#line 274
      src ++;
#line 274
      ch = (int )*tmp___4;
    }
#line 278
    if (ch != (int )Pad64) {
#line 279
      return (-1);
    }
#line 280
    tmp___6 = src;
#line 280
    src ++;
#line 280
    ch = (int )*tmp___6;
    case 3: 
#line 289
    while (ch != 0) {
#line 290
      tmp___8 = __ctype_b_loc();
#line 290
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 291
        return (-1);
      }
#line 289
      tmp___7 = src;
#line 289
      src ++;
#line 289
      ch = (int )*tmp___7;
    }
#line 299
    if (target) {
#line 299
      if ((int )*(target + tarindex) != 0) {
#line 300
        return (-1);
      }
    }
    }
  } else {
#line 307
    if (state != 0U) {
#line 308
      return (-1);
    }
  }
#line 311
  return ((int )tarindex);
}
}
#line 1 "basename.o"
#pragma merger(0,"./basename.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bindresvport.o"
#pragma merger(0,"./bindresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 53 "./openbsd-compat/openbsd-compat.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 52 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *in ;
  struct sockaddr_in6 *in6 ;
  u_int16_t *portp ;
  u_int16_t port___0 ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 64
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 65
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 66
    sa = (struct sockaddr *)(& myaddr);
#line 68
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 68
    if (tmp == -1) {
#line 69
      return (-1);
    }
#line 71
    af = (int )sa->sa_family;
#line 72
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 74
    af = (int )sa->sa_family;
  }
#line 76
  if (af == 2) {
#line 77
    in = (struct sockaddr_in *)sa;
#line 78
    salen = sizeof(struct sockaddr_in );
#line 79
    portp = & in->sin_port;
  } else {
#line 80
    if (af == 10) {
#line 81
      in6 = (struct sockaddr_in6 *)sa;
#line 82
      salen = sizeof(struct sockaddr_in6 );
#line 83
      portp = & in6->sin6_port;
    } else {
#line 85
      tmp___0 = __errno_location();
#line 85
      *tmp___0 = 96;
#line 86
      return (-1);
    }
  }
#line 88
  sa->sa_family = (unsigned short )af;
#line 90
  __x = *portp;
#line 90
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 90
  port___0 = __v;
#line 91
  if ((int )port___0 == 0) {
#line 92
    tmp___1 = arc4random();
#line 92
    port___0 = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 95
  error___0 = -1;
#line 97
  i = 0;
#line 97
  while (i < 424) {
#line 98
    __x___0 = port___0;
#line 98
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 98
    *portp = __v___0;
#line 100
    error___0 = bind(sd, (struct sockaddr  const  * __restrict  )sa, salen);
#line 103
    if (error___0 == 0) {
#line 104
      break;
    }
#line 107
    if (error___0 < 0) {
#line 107
      tmp___2 = __errno_location();
#line 107
      if (! (*tmp___2 == 98)) {
#line 107
        tmp___3 = __errno_location();
#line 107
        if (! (*tmp___3 == 22)) {
#line 108
          break;
        }
      }
    }
#line 110
    port___0 = (u_int16_t )((int )port___0 + 1);
#line 111
    if ((int )port___0 > 1023) {
#line 112
      port___0 = (unsigned short)600;
    }
#line 97
    i ++;
  }
#line 115
  return (error___0);
}
}
#line 1 "daemon.o"
#pragma merger(0,"./daemon.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "dirname.o"
#pragma merger(0,"./dirname.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "getcwd.o"
#pragma merger(0,"./getcwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "getgrouplist.o"
#pragma merger(0,"./getgrouplist.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "getopt.o"
#pragma merger(0,"./getopt.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 136 "./openbsd-compat/openbsd-compat.h"
 __attribute__((__nothrow__)) int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 43 "openbsd-compat/getopt.c"
int BSDopterr  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptind  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptopt  ;
#line 43 "openbsd-compat/getopt.c"
int BSDoptreset  ;
#line 47 "openbsd-compat/getopt.c"
char *BSDoptarg  ;
#line 64 "openbsd-compat/getopt.c"
static char *place  =    (char *)"";
#line 57
 __attribute__((__nothrow__)) int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 57 "openbsd-compat/getopt.c"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ char *oli ;
  char *tmp ;
  char *tmp___1 ;

  {
#line 67
  if ((unsigned int )ostr == (unsigned int )((void *)0)) {
#line 68
    return (-1);
  }
#line 70
  if (BSDoptreset) {
    goto _L;
  } else {
#line 70
    if (! *place) {
      _L: /* CIL Label */ 
#line 71
      BSDoptreset = 0;
#line 72
      if (BSDoptind >= nargc) {
#line 73
        place = (char *)"";
#line 74
        return (-1);
      } else {
#line 72
        place = (char *)*(nargv + BSDoptind);
#line 72
        if ((int )*place != 45) {
#line 73
          place = (char *)"";
#line 74
          return (-1);
        }
      }
#line 76
      if (*(place + 1)) {
#line 76
        place ++;
#line 76
        if ((int )*place == 45) {
#line 77
          BSDoptind ++;
#line 78
          place = (char *)"";
#line 79
          return (-1);
        }
      }
    }
  }
#line 82
  tmp = place;
#line 82
  place ++;
#line 82
  BSDoptopt = (int )*tmp;
#line 82
  if (BSDoptopt == 58) {
    goto _L___0;
  } else {
#line 82
    tmp___1 = __builtin_strchr((char *)ostr, BSDoptopt);
#line 82
    oli = tmp___1;
#line 82
    if (! oli) {
      _L___0: /* CIL Label */ 
#line 88
      if (BSDoptopt == 45) {
#line 89
        return (-1);
      }
#line 90
      if (! *place) {
#line 91
        BSDoptind ++;
      }
#line 92
      if (BSDopterr) {
#line 92
        if ((int const   )*ostr != 58) {
#line 93
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- %c\n",
                  __progname, BSDoptopt);
        }
      }
#line 95
      return ('?');
    }
  }
#line 97
  oli ++;
#line 97
  if ((int )*oli != 58) {
#line 98
    BSDoptarg = (char *)((void *)0);
#line 99
    if (! *place) {
#line 100
      BSDoptind ++;
    }
  } else {
#line 103
    if (*place) {
#line 104
      BSDoptarg = place;
    } else {
#line 105
      BSDoptind ++;
#line 105
      if (nargc <= BSDoptind) {
#line 106
        place = (char *)"";
#line 107
        if ((int const   )*ostr == 58) {
#line 108
          return (':');
        }
#line 109
        if (BSDopterr) {
#line 110
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  __progname, BSDoptopt);
        }
#line 113
        return ('?');
      } else {
#line 116
        BSDoptarg = (char *)*(nargv + BSDoptind);
      }
    }
#line 117
    place = (char *)"";
#line 118
    BSDoptind ++;
  }
#line 120
  return (BSDoptopt);
}
}
#line 1 "getrrsetbyname.o"
#pragma merger(0,"./getrrsetbyname.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 591
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 237 "/usr/include/resolv.h"
extern struct __res_state *__res_state(void)  __attribute__((__const__)) ;
#line 261
extern  __attribute__((__nothrow__)) int __res_init(void) ;
#line 265
extern  __attribute__((__nothrow__)) int __res_query(char const   * , int  , int  ,
                                                     u_char * , int  ) ;
#line 345
extern  __attribute__((__nothrow__)) int __dn_expand(u_char const   * , u_char const   * ,
                                                     u_char const   * , char * , int  ) ;
#line 105 "./openbsd-compat/getrrsetbyname.h"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) ;
#line 106
void freerrset(struct rrsetinfo *rrset ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 127 "openbsd-compat/getrrsetbyname.c"
extern u_int16_t _getshort(u_char const   * ) ;
#line 141
extern u_int32_t _getlong(u_char const   * ) ;
#line 173
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) ;
#line 174
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) ;
#line 176
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) ;
#line 179
static void free_dns_query(struct dns_query *p ) ;
#line 180
static void free_dns_rr(struct dns_rr *p ) ;
#line 181
static void free_dns_response(struct dns_response *p ) ;
#line 183
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) ;
#line 185 "openbsd-compat/getrrsetbyname.c"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) 
{ struct __res_state *_resp ;
  struct __res_state *tmp ;
  int result ;
  struct rrsetinfo *rrset ;
  struct dns_response *response ;
  struct dns_rr *rr ;
  struct rdatainfo *rdata ;
  int length ;
  unsigned int index_ans ;
  unsigned int index_sig ;
  u_char answer[65536] ;
  int tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  void *tmp___19 ;

  {
#line 190
  tmp = __res_state();
#line 190
  _resp = tmp;
#line 192
  rrset = (struct rrsetinfo *)((void *)0);
#line 193
  response = (struct dns_response *)((void *)0);
#line 201
  if (rdclass > 65535U) {
#line 202
    result = 3;
    goto fail;
  } else {
#line 201
    if (rdtype > 65535U) {
#line 202
      result = 3;
      goto fail;
    }
  }
#line 207
  if (rdclass == 255U) {
#line 208
    result = 3;
    goto fail;
  } else {
#line 207
    if (rdtype == 255U) {
#line 208
      result = 3;
      goto fail;
    }
  }
#line 213
  if (flags) {
#line 214
    result = 3;
    goto fail;
  }
#line 219
  if ((_resp->options & 1UL) == 0UL) {
#line 219
    tmp___0 = __res_init();
#line 219
    if (tmp___0 == -1) {
#line 220
      result = 2;
      goto fail;
    }
  }
#line 235
  length = __res_query(hostname, (int )rdclass, (int )rdtype, answer, (int )sizeof(answer));
#line 237
  if (length < 0) {
#line 238
    tmp___1 = __h_errno_location();
#line 238
    switch (*tmp___1) {
    case 1: 
#line 240
    result = 4;
    goto fail;
    case 4: 
#line 243
    result = 5;
    goto fail;
    default: 
#line 246
    result = 2;
    goto fail;
    }
  }
#line 252
  response = parse_dns_response((u_char const   *)(answer), length);
#line 253
  if ((unsigned int )response == (unsigned int )((void *)0)) {
#line 254
    result = 2;
    goto fail;
  }
#line 258
  if (response->header.qdcount != 1U) {
#line 259
    result = 2;
    goto fail;
  }
#line 264
  tmp___2 = calloc(1U, sizeof(struct rrsetinfo ));
#line 264
  rrset = (struct rrsetinfo *)tmp___2;
#line 265
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 266
    result = 1;
    goto fail;
  }
#line 269
  rrset->rri_rdclass = (unsigned int )(response->query)->class;
#line 270
  rrset->rri_rdtype = (unsigned int )(response->query)->type;
#line 271
  rrset->rri_ttl = (unsigned int )(response->answer)->ttl;
#line 272
  rrset->rri_nrdatas = response->header.ancount;
#line 276
  if (response->header.ad == 1U) {
#line 277
    rrset->rri_flags |= 1U;
  }
#line 281
  tmp___12 = __strdup((char const   *)(response->answer)->name);
#line 281
  rrset->rri_name = tmp___12;
#line 282
  if ((unsigned int )rrset->rri_name == (unsigned int )((void *)0)) {
#line 283
    result = 1;
    goto fail;
  }
#line 288
  tmp___13 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short )rrset->rri_rdtype);
#line 288
  rrset->rri_nrdatas = (unsigned int )tmp___13;
#line 290
  tmp___14 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short)46);
#line 290
  rrset->rri_nsigs = (unsigned int )tmp___14;
#line 294
  tmp___15 = calloc(rrset->rri_nrdatas, sizeof(struct rdatainfo ));
#line 294
  rrset->rri_rdatas = (struct rdatainfo *)tmp___15;
#line 296
  if ((unsigned int )rrset->rri_rdatas == (unsigned int )((void *)0)) {
#line 297
    result = 1;
    goto fail;
  }
#line 302
  if (rrset->rri_nsigs > 0U) {
#line 303
    tmp___16 = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo ));
#line 303
    rrset->rri_sigs = (struct rdatainfo *)tmp___16;
#line 304
    if ((unsigned int )rrset->rri_sigs == (unsigned int )((void *)0)) {
#line 305
      result = 1;
      goto fail;
    }
  }
#line 311
  rr = response->answer;
#line 311
  index_ans = 0U;
#line 311
  index_sig = 0U;
#line 311
  while (rr) {
#line 314
    rdata = (struct rdatainfo *)((void *)0);
#line 316
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 316
      if ((unsigned int )rr->type == rrset->rri_rdtype) {
#line 318
        tmp___17 = index_ans;
#line 318
        index_ans ++;
#line 318
        rdata = rrset->rri_rdatas + tmp___17;
      }
    }
#line 320
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 320
      if ((int )rr->type == 46) {
#line 322
        tmp___18 = index_sig;
#line 322
        index_sig ++;
#line 322
        rdata = rrset->rri_sigs + tmp___18;
      }
    }
#line 324
    if (rdata) {
#line 325
      rdata->rdi_length = (unsigned int )rr->size;
#line 326
      tmp___19 = malloc((unsigned int )rr->size);
#line 326
      rdata->rdi_data = (unsigned char *)tmp___19;
#line 328
      if ((unsigned int )rdata->rdi_data == (unsigned int )((void *)0)) {
#line 329
        result = 1;
        goto fail;
      }
#line 332
      memcpy((void * __restrict  )rdata->rdi_data, (void const   * __restrict  )rr->rdata,
             (unsigned int )rr->size);
    }
#line 311
    rr = rr->next;
  }
#line 335
  free_dns_response(response);
#line 337
  *res = rrset;
#line 338
  return (0);
  fail: 
#line 341
  if ((unsigned int )rrset != (unsigned int )((void *)0)) {
#line 342
    freerrset(rrset);
  }
#line 343
  if ((unsigned int )response != (unsigned int )((void *)0)) {
#line 344
    free_dns_response(response);
  }
#line 345
  return (result);
}
}
#line 348 "openbsd-compat/getrrsetbyname.c"
void freerrset(struct rrsetinfo *rrset ) 
{ u_int16_t i ;

  {
#line 353
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 354
    return;
  }
#line 356
  if (rrset->rri_rdatas) {
#line 357
    i = (unsigned short)0;
#line 357
    while ((unsigned int )i < rrset->rri_nrdatas) {
#line 358
      if ((unsigned int )(rrset->rri_rdatas + i)->rdi_data == (unsigned int )((void *)0)) {
#line 359
        break;
      }
#line 360
      free((void *)(rrset->rri_rdatas + i)->rdi_data);
#line 357
      i = (u_int16_t )((int )i + 1);
    }
#line 362
    free((void *)rrset->rri_rdatas);
  }
#line 365
  if (rrset->rri_sigs) {
#line 366
    i = (unsigned short)0;
#line 366
    while ((unsigned int )i < rrset->rri_nsigs) {
#line 367
      if ((unsigned int )(rrset->rri_sigs + i)->rdi_data == (unsigned int )((void *)0)) {
#line 368
        break;
      }
#line 369
      free((void *)(rrset->rri_sigs + i)->rdi_data);
#line 366
      i = (u_int16_t )((int )i + 1);
    }
#line 371
    free((void *)rrset->rri_sigs);
  }
#line 374
  if (rrset->rri_name) {
#line 375
    free((void *)rrset->rri_name);
  }
#line 376
  free((void *)rrset);
#line 377
  return;
}
}
#line 382 "openbsd-compat/getrrsetbyname.c"
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) 
{ struct dns_response *resp ;
  u_char const   *cp ;
  void *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  register unsigned short __v___2 ;
  register unsigned short __x___2 ;

  {
#line 389
  tmp = calloc(1U, sizeof(*resp));
#line 389
  resp = (struct dns_response *)tmp;
#line 390
  if ((unsigned int )resp == (unsigned int )((void *)0)) {
#line 391
    return ((struct dns_response *)((void *)0));
  }
#line 394
  cp = answer;
#line 397
  memcpy((void * __restrict  )(& resp->header), (void const   * __restrict  )cp, 12U);
#line 398
  cp += 12;
#line 401
  __x = (unsigned short )resp->header.qdcount;
#line 401
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 401
  resp->header.qdcount = (unsigned int )__v;
#line 402
  __x___0 = (unsigned short )resp->header.ancount;
#line 402
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 402
  resp->header.ancount = (unsigned int )__v___0;
#line 403
  __x___1 = (unsigned short )resp->header.nscount;
#line 403
  __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 403
  resp->header.nscount = (unsigned int )__v___1;
#line 404
  __x___2 = (unsigned short )resp->header.arcount;
#line 404
  __asm__  ("rorw $8, %w0": "=r" (__v___2): "0" (__x___2): "cc");
#line 404
  resp->header.arcount = (unsigned int )__v___2;
#line 407
  if (resp->header.qdcount < 1U) {
#line 408
    free_dns_response(resp);
#line 409
    return ((struct dns_response *)((void *)0));
  }
#line 413
  resp->query = parse_dns_qsection(answer, size, & cp, (int )resp->header.qdcount);
#line 415
  if (resp->header.qdcount) {
#line 415
    if ((unsigned int )resp->query == (unsigned int )((void *)0)) {
#line 416
      free_dns_response(resp);
#line 417
      return ((struct dns_response *)((void *)0));
    }
  }
#line 421
  resp->answer = parse_dns_rrsection(answer, size, & cp, (int )resp->header.ancount);
#line 423
  if (resp->header.ancount) {
#line 423
    if ((unsigned int )resp->answer == (unsigned int )((void *)0)) {
#line 424
      free_dns_response(resp);
#line 425
      return ((struct dns_response *)((void *)0));
    }
  }
#line 429
  resp->authority = parse_dns_rrsection(answer, size, & cp, (int )resp->header.nscount);
#line 431
  if (resp->header.nscount) {
#line 431
    if ((unsigned int )resp->authority == (unsigned int )((void *)0)) {
#line 432
      free_dns_response(resp);
#line 433
      return ((struct dns_response *)((void *)0));
    }
  }
#line 437
  resp->additional = parse_dns_rrsection(answer, size, & cp, (int )resp->header.arcount);
#line 439
  if (resp->header.arcount) {
#line 439
    if ((unsigned int )resp->additional == (unsigned int )((void *)0)) {
#line 440
      free_dns_response(resp);
#line 441
      return ((struct dns_response *)((void *)0));
    }
  }
#line 444
  return (resp);
}
}
#line 447 "openbsd-compat/getrrsetbyname.c"
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) 
{ struct dns_query *head ;
  struct dns_query *curr ;
  struct dns_query *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;

  {
#line 454
  i = 1;
#line 454
  head = (struct dns_query *)((void *)0);
#line 454
  prev = (struct dns_query *)((void *)0);
#line 454
  while (i <= count) {
#line 457
    tmp = calloc(1U, sizeof(struct dns_query ));
#line 457
    curr = (struct dns_query *)tmp;
#line 458
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 459
      free_dns_query(head);
#line 460
      return ((struct dns_query *)((void *)0));
    }
#line 462
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 463
      head = curr;
    }
#line 464
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 465
      prev->next = curr;
    }
#line 468
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 470
    if (length < 0) {
#line 471
      free_dns_query(head);
#line 472
      return ((struct dns_query *)((void *)0));
    }
#line 474
    tmp___9 = __strdup((char const   *)(name));
#line 474
    curr->name = tmp___9;
#line 475
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 476
      free_dns_query(head);
#line 477
      return ((struct dns_query *)((void *)0));
    }
#line 479
    *cp += length;
#line 482
    curr->type = _getshort(*cp);
#line 483
    *cp += 2;
#line 486
    curr->class = _getshort(*cp);
#line 487
    *cp += 2;
#line 454
    i ++;
#line 454
    prev = curr;
  }
#line 490
  return (head);
}
}
#line 493 "openbsd-compat/getrrsetbyname.c"
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) 
{ struct dns_rr *head ;
  struct dns_rr *curr ;
  struct dns_rr *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;
  u_int32_t tmp___10 ;

  {
#line 501
  i = 1;
#line 501
  head = (struct dns_rr *)((void *)0);
#line 501
  prev = (struct dns_rr *)((void *)0);
#line 501
  while (i <= count) {
#line 504
    tmp = calloc(1U, sizeof(struct dns_rr ));
#line 504
    curr = (struct dns_rr *)tmp;
#line 505
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 506
      free_dns_rr(head);
#line 507
      return ((struct dns_rr *)((void *)0));
    }
#line 509
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 510
      head = curr;
    }
#line 511
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 512
      prev->next = curr;
    }
#line 515
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 517
    if (length < 0) {
#line 518
      free_dns_rr(head);
#line 519
      return ((struct dns_rr *)((void *)0));
    }
#line 521
    tmp___9 = __strdup((char const   *)(name));
#line 521
    curr->name = tmp___9;
#line 522
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 523
      free_dns_rr(head);
#line 524
      return ((struct dns_rr *)((void *)0));
    }
#line 526
    *cp += length;
#line 529
    curr->type = _getshort(*cp);
#line 530
    *cp += 2;
#line 533
    curr->class = _getshort(*cp);
#line 534
    *cp += 2;
#line 537
    tmp___10 = _getlong(*cp);
#line 537
    curr->ttl = (unsigned short )tmp___10;
#line 538
    *cp += 4;
#line 541
    curr->size = _getshort(*cp);
#line 542
    *cp += 2;
#line 545
    curr->rdata = malloc((unsigned int )curr->size);
#line 546
    if ((unsigned int )curr->rdata == (unsigned int )((void *)0)) {
#line 547
      free_dns_rr(head);
#line 548
      return ((struct dns_rr *)((void *)0));
    }
#line 550
    memcpy((void * __restrict  )curr->rdata, (void const   * __restrict  )*cp, (unsigned int )curr->size);
#line 551
    *cp += (int )curr->size;
#line 501
    i ++;
#line 501
    prev = curr;
  }
#line 554
  return (head);
}
}
#line 557 "openbsd-compat/getrrsetbyname.c"
static void free_dns_query(struct dns_query *p ) 
{ 

  {
#line 560
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 561
    return;
  }
#line 563
  if (p->name) {
#line 564
    free((void *)p->name);
  }
#line 565
  free_dns_query(p->next);
#line 566
  free((void *)p);
#line 567
  return;
}
}
#line 569 "openbsd-compat/getrrsetbyname.c"
static void free_dns_rr(struct dns_rr *p ) 
{ 

  {
#line 572
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 573
    return;
  }
#line 575
  if (p->name) {
#line 576
    free((void *)p->name);
  }
#line 577
  if (p->rdata) {
#line 578
    free(p->rdata);
  }
#line 579
  free_dns_rr(p->next);
#line 580
  free((void *)p);
#line 581
  return;
}
}
#line 583 "openbsd-compat/getrrsetbyname.c"
static void free_dns_response(struct dns_response *p ) 
{ 

  {
#line 586
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 587
    return;
  }
#line 589
  free_dns_query(p->query);
#line 590
  free_dns_rr(p->answer);
#line 591
  free_dns_rr(p->authority);
#line 592
  free_dns_rr(p->additional);
#line 593
  free((void *)p);
#line 594
  return;
}
}
#line 596 "openbsd-compat/getrrsetbyname.c"
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) 
{ int n___0 ;

  {
#line 599
  n___0 = 0;
#line 601
  while (p) {
#line 602
    if ((int )p->class == (int )class) {
#line 602
      if ((int )p->type == (int )type) {
#line 603
        n___0 ++;
      }
    }
#line 604
    p = p->next;
  }
#line 607
  return (n___0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "glob.o"
#pragma merger(0,"./glob.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 394
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __asm__("__xstat64") __attribute__((__nonnull__(2,3))) ;
#line 397
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __asm__("__lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 443
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 443
  return (tmp);
}
}
#line 600 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 93 "./openbsd-compat/glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 94
void globfree(glob_t *pglob ) ;
#line 74 "./openbsd-compat/openbsd-compat.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 54 "openbsd-compat/glob.c"
static long get_arg_max(void) 
{ 

  {
#line 58
  return (131072L);
}
}
#line 143
static int compare(void const   *p , void const   *q ) ;
#line 144
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) ;
#line 145
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 146
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 147
static Char *g_strchr(Char *str , int ch ) ;
#line 148
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 149
static int glob0(Char const   *pattern , glob_t *pglob ) ;
#line 150
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 151
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 153
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *restpattern , Char *restpattern_last , glob_t *pglob ,
                 size_t *limitp ) ;
#line 155
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) ;
#line 156
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) ;
#line 158
static int globexp1(Char const   *pattern , glob_t *pglob ) ;
#line 159
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) ;
#line 160
static int match(Char *name , Char *pat , Char *patend ) ;
#line 165 "openbsd-compat/glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ u_char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  Char *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  u_char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 173
  patnext = (u_char const   *)((u_char *)pattern);
#line 174
  if (! (flags & 1)) {
#line 175
    pglob->gl_pathc = 0;
#line 176
    pglob->gl_pathv = (char **)((void *)0);
#line 177
    if (! (flags & 2)) {
#line 178
      pglob->gl_offs = 0;
    }
  }
#line 180
  pglob->gl_flags = flags & -257;
#line 181
  pglob->gl_errfunc = errfunc;
#line 182
  pglob->gl_matchc = 0;
#line 184
  bufnext = patbuf;
#line 185
  bufend = (bufnext + 4096) - 1;
#line 186
  if (flags & 4096) {
#line 187
    while (1) {
#line 187
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 187
        tmp___0 = patnext;
#line 187
        patnext ++;
#line 187
        c = (int )*tmp___0;
#line 187
        if (! (c != 0)) {
#line 187
          break;
        }
      } else {
#line 187
        break;
      }
#line 188
      tmp = bufnext;
#line 188
      bufnext ++;
#line 188
      *tmp = (unsigned short )c;
    }
  } else {
#line 191
    while (1) {
#line 191
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 191
        tmp___4 = patnext;
#line 191
        patnext ++;
#line 191
        c = (int )*tmp___4;
#line 191
        if (! (c != 0)) {
#line 191
          break;
        }
      } else {
#line 191
        break;
      }
#line 192
      if (c == 92) {
#line 193
        tmp___1 = patnext;
#line 193
        patnext ++;
#line 193
        c = (int )*tmp___1;
#line 193
        if (c == 0) {
#line 194
          c = '\\';
#line 195
          patnext --;
        }
#line 197
        tmp___2 = bufnext;
#line 197
        bufnext ++;
#line 197
        *tmp___2 = (unsigned short )(c | 16384);
      } else {
#line 199
        tmp___3 = bufnext;
#line 199
        bufnext ++;
#line 199
        *tmp___3 = (unsigned short )c;
      }
    }
  }
#line 201
  *bufnext = (unsigned short )'\000';
#line 203
  if (flags & 128) {
#line 204
    tmp___5 = globexp1((Char const   *)(patbuf), pglob);
#line 204
    return (tmp___5);
  } else {
#line 206
    tmp___6 = glob0((Char const   *)(patbuf), pglob);
#line 206
    return (tmp___6);
  }
}
}
#line 214 "openbsd-compat/glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob ) 
{ Char const   *ptr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  int tmp___2 ;

  {
#line 217
  ptr = pattern;
#line 221
  if ((int const   )*(pattern + 0) == 123) {
#line 221
    if ((int const   )*(pattern + 1) == 125) {
#line 221
      if ((int const   )*(pattern + 2) == 0) {
#line 222
        tmp = glob0(pattern, pglob);
#line 222
        return (tmp);
      }
    }
  }
#line 224
  while (1) {
#line 224
    tmp___1 = g_strchr((Char *)ptr, '{');
#line 224
    ptr = (Char const   *)tmp___1;
#line 224
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 224
      break;
    }
#line 225
    tmp___0 = globexp2(ptr, pattern, pglob, & rv);
#line 225
    if (! tmp___0) {
#line 226
      return (rv);
    }
  }
#line 228
  tmp___2 = glob0(pattern, pglob);
#line 228
  return (tmp___2);
}
}
#line 237 "openbsd-compat/glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) 
{ int i ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  Char const   *tmp___2 ;
  Char *tmp___3 ;
  Char const   *tmp___4 ;
  Char *tmp___5 ;
  Char const   *tmp___6 ;

  {
#line 246
  lm = patbuf;
#line 246
  pm = pattern;
#line 246
  while ((unsigned int )pm != (unsigned int )ptr) {
#line 246
    tmp = lm;
#line 246
    lm ++;
#line 246
    tmp___0 = pm;
#line 246
    pm ++;
#line 246
    *tmp = (unsigned short )*tmp___0;
  }
#line 248
  *lm = (unsigned short )'\000';
#line 249
  ls = lm;
#line 252
  i = 0;
#line 252
  ptr ++;
#line 252
  pe = ptr;
#line 252
  while (*pe) {
#line 253
    if ((int const   )*pe == 91) {
#line 255
      tmp___1 = pe;
#line 255
      pe ++;
#line 255
      pm = tmp___1;
#line 255
      while (1) {
#line 255
        if ((int const   )*pe != 93) {
#line 255
          if (! ((int const   )*pe != 0)) {
#line 255
            break;
          }
        } else {
#line 255
          break;
        }
#line 255
        pe ++;
      }
#line 257
      if ((int const   )*pe == 0) {
#line 262
        pe = pm;
      }
    } else {
#line 264
      if ((int const   )*pe == 123) {
#line 265
        i ++;
      } else {
#line 266
        if ((int const   )*pe == 125) {
#line 267
          if (i == 0) {
#line 268
            break;
          }
#line 269
          i --;
        }
      }
    }
#line 252
    pe ++;
  }
#line 273
  if (i != 0) {
#line 274
    *rv = glob0((Char const   *)(patbuf), pglob);
#line 275
    return (0);
  } else {
#line 273
    if ((int const   )*pe == 0) {
#line 274
      *rv = glob0((Char const   *)(patbuf), pglob);
#line 275
      return (0);
    }
  }
#line 278
  i = 0;
#line 278
  pm = ptr;
#line 278
  pl = pm;
#line 278
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 279
    switch ((int )*pm) {
    case 91: 
#line 282
    tmp___2 = pm;
#line 282
    pm ++;
#line 282
    pl = tmp___2;
#line 282
    while (1) {
#line 282
      if ((int const   )*pm != 93) {
#line 282
        if (! ((int const   )*pm != 0)) {
#line 282
          break;
        }
      } else {
#line 282
        break;
      }
#line 282
      pm ++;
    }
#line 284
    if ((int const   )*pm == 0) {
#line 289
      pm = pl;
    }
#line 291
    break;
    case 123: 
#line 294
    i ++;
#line 295
    break;
    case 125: 
#line 298
    if (i) {
#line 299
      i --;
#line 300
      break;
    }
    case 44: 
#line 304
    if (i) {
#line 304
      if ((int const   )*pm == 44) {
#line 305
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 308
      lm = ls;
#line 308
      while ((unsigned int )pl < (unsigned int )pm) {
#line 308
        tmp___3 = lm;
#line 308
        lm ++;
#line 308
        tmp___4 = pl;
#line 308
        pl ++;
#line 308
        *tmp___3 = (unsigned short )*tmp___4;
      }
#line 315
      pl = pe + 1;
#line 315
      while (1) {
#line 315
        tmp___5 = lm;
#line 315
        lm ++;
#line 315
        tmp___6 = pl;
#line 315
        pl ++;
#line 315
        *tmp___5 = (unsigned short )*tmp___6;
#line 315
        if (! ((int )*tmp___5 != 0)) {
#line 315
          break;
        }
      }
#line 322
      *rv = globexp1((Char const   *)(patbuf), pglob);
#line 325
      pl = pm + 1;
    }
#line 327
    break;
    default: ;
#line 330
    break;
    }
#line 278
    pm ++;
  }
#line 333
  *rv = 0;
#line 334
  return (0);
}
}
#line 342 "openbsd-compat/glob.c"
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) 
{ struct passwd *pwd ;
  char *h___0 ;
  Char const   *p ;
  Char *b ;
  Char *eb ;
  char *tmp ;
  Char const   *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  Char *tmp___4 ;
  char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;

  {
#line 350
  if ((int const   )*pattern != 126) {
#line 351
    return (pattern);
  } else {
#line 350
    if (! (pglob->gl_flags & 2048)) {
#line 351
      return (pattern);
    }
  }
#line 354
  eb = patbuf + (patbuf_len - 1U);
#line 355
  p = pattern + 1;
#line 355
  h___0 = (char *)patbuf;
#line 355
  while (1) {
#line 355
    if ((unsigned int )h___0 < (unsigned int )((char *)eb)) {
#line 355
      if (*p) {
#line 355
        if (! ((int const   )*p != 47)) {
#line 355
          break;
        }
      } else {
#line 355
        break;
      }
    } else {
#line 355
      break;
    }
#line 355
    tmp = h___0;
#line 355
    h___0 ++;
#line 355
    tmp___0 = p;
#line 355
    p ++;
#line 355
    *tmp = (char )*tmp___0;
  }
#line 359
  *h___0 = (char )'\000';
#line 366
  if ((int )*((char *)patbuf + 0) == 0) {
#line 374
    tmp___2 = getuid();
#line 374
    tmp___3 = geteuid();
#line 374
    if (tmp___2 != tmp___3) {
      goto _L;
    } else {
#line 374
      h___0 = getenv("HOME");
#line 374
      if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 375
        tmp___1 = getuid();
#line 375
        pwd = getpwuid(tmp___1);
#line 375
        if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 376
          return (pattern);
        } else {
#line 378
          h___0 = pwd->pw_dir;
        }
      }
    }
  } else {
#line 384
    pwd = getpwnam((char const   *)((char *)patbuf));
#line 384
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 385
      return (pattern);
    } else {
#line 387
      h___0 = pwd->pw_dir;
    }
  }
#line 391
  b = patbuf;
#line 391
  while (1) {
#line 391
    if ((unsigned int )b < (unsigned int )eb) {
#line 391
      if (! *h___0) {
#line 391
        break;
      }
    } else {
#line 391
      break;
    }
#line 391
    tmp___4 = b;
#line 391
    b ++;
#line 391
    tmp___5 = h___0;
#line 391
    h___0 ++;
#line 391
    *tmp___4 = (unsigned short )*tmp___5;
  }
#line 395
  while (1) {
#line 395
    if ((unsigned int )b < (unsigned int )eb) {
#line 395
      tmp___6 = b;
#line 395
      b ++;
#line 395
      tmp___7 = p;
#line 395
      p ++;
#line 395
      *tmp___6 = (unsigned short )*tmp___7;
#line 395
      if (! ((int )*tmp___6 != 0)) {
#line 395
        break;
      }
    } else {
#line 395
      break;
    }
  }
#line 397
  *b = (unsigned short )'\000';
#line 399
  return ((Char const   *)patbuf);
}
}
#line 410 "openbsd-compat/glob.c"
static int glob0(Char const   *pattern , glob_t *pglob ) 
{ Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  size_t limit ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 416
  limit = (size_t )0;
#line 418
  qpatnext = globtilde(pattern, patbuf, 4096U, pglob);
#line 419
  oldpathc = pglob->gl_pathc;
#line 420
  bufnext = patbuf;
#line 423
  while (1) {
#line 423
    tmp___12 = qpatnext;
#line 423
    qpatnext ++;
#line 423
    c = (int )*tmp___12;
#line 423
    if (! (c != 0)) {
#line 423
      break;
    }
#line 424
    switch (c) {
    case 91: 
#line 426
    c = (int )*qpatnext;
#line 427
    if (c == 33) {
#line 428
      qpatnext ++;
    }
#line 429
    if ((int const   )*qpatnext == 0) {
      goto _L;
    } else {
#line 429
      tmp___0 = g_strchr((Char *)qpatnext + 1, ']');
#line 429
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 431
        tmp = bufnext;
#line 431
        bufnext ++;
#line 431
        *tmp = (unsigned short )'[';
#line 432
        if (c == 33) {
#line 433
          qpatnext --;
        }
#line 434
        break;
      }
    }
#line 436
    tmp___1 = bufnext;
#line 436
    bufnext ++;
#line 436
    *tmp___1 = (unsigned short)32859;
#line 437
    if (c == 33) {
#line 438
      tmp___2 = bufnext;
#line 438
      bufnext ++;
#line 438
      *tmp___2 = (unsigned short)32801;
    }
#line 439
    tmp___3 = qpatnext;
#line 439
    qpatnext ++;
#line 439
    c = (int )*tmp___3;
#line 440
    while (1) {
#line 441
      tmp___4 = bufnext;
#line 441
      bufnext ++;
#line 441
      *tmp___4 = (unsigned short )(c & 255);
#line 442
      if ((int const   )*qpatnext == 45) {
#line 442
        c = (int )*(qpatnext + 1);
#line 442
        if (c != 93) {
#line 444
          tmp___5 = bufnext;
#line 444
          bufnext ++;
#line 444
          *tmp___5 = (unsigned short)32813;
#line 445
          tmp___6 = bufnext;
#line 445
          bufnext ++;
#line 445
          *tmp___6 = (unsigned short )(c & 255);
#line 446
          qpatnext += 2;
        }
      }
#line 440
      tmp___7 = qpatnext;
#line 440
      qpatnext ++;
#line 440
      c = (int )*tmp___7;
#line 440
      if (! (c != 93)) {
#line 440
        break;
      }
    }
#line 449
    pglob->gl_flags |= 256;
#line 450
    tmp___8 = bufnext;
#line 450
    bufnext ++;
#line 450
    *tmp___8 = (unsigned short)32861;
#line 451
    break;
    case 63: 
#line 453
    pglob->gl_flags |= 256;
#line 454
    tmp___9 = bufnext;
#line 454
    bufnext ++;
#line 454
    *tmp___9 = (unsigned short)32831;
#line 455
    break;
    case 42: 
#line 457
    pglob->gl_flags |= 256;
#line 461
    if ((unsigned int )bufnext == (unsigned int )(patbuf)) {
#line 462
      tmp___10 = bufnext;
#line 462
      bufnext ++;
#line 462
      *tmp___10 = (unsigned short)32810;
    } else {
#line 461
      if ((int )*(bufnext + -1) != 32810) {
#line 462
        tmp___10 = bufnext;
#line 462
        bufnext ++;
#line 462
        *tmp___10 = (unsigned short)32810;
      }
    }
#line 463
    break;
    default: 
#line 465
    tmp___11 = bufnext;
#line 465
    bufnext ++;
#line 465
    *tmp___11 = (unsigned short )(c & 255);
#line 466
    break;
    }
  }
#line 469
  *bufnext = (unsigned short )'\000';
#line 474
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, & limit);
#line 474
  if (err != 0) {
#line 475
    return (err);
  }
#line 483
  if (pglob->gl_pathc == oldpathc) {
#line 484
    if (pglob->gl_flags & 16) {
#line 487
      tmp___13 = globextend(pattern, pglob, & limit);
#line 487
      return (tmp___13);
    } else {
#line 484
      if (pglob->gl_flags & 512) {
#line 484
        if (! (pglob->gl_flags & 256)) {
#line 487
          tmp___13 = globextend(pattern, pglob, & limit);
#line 487
          return (tmp___13);
        } else {
#line 489
          return (-3);
        }
      } else {
#line 489
        return (-3);
      }
    }
  }
#line 491
  if (! (pglob->gl_flags & 32)) {
#line 492
    qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (unsigned int )(pglob->gl_pathc - oldpathc),
          sizeof(char *), & compare);
  }
#line 494
  return (0);
}
}
#line 497 "openbsd-compat/glob.c"
static int compare(void const   *p , void const   *q ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 500
  if (0) {
#line 500
    __s1_len = strlen((char const   *)*((char **)p));
#line 500
    __s2_len = strlen((char const   *)*((char **)q));
#line 500
    if (! ((unsigned int )((void const   *)(*((char **)p) + 1)) - (unsigned int )((void const   *)*((char **)p)) == 1U)) {
      goto _L___0;
    } else {
#line 500
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 500
        if (! ((unsigned int )((void const   *)(*((char **)q) + 1)) - (unsigned int )((void const   *)*((char **)q)) == 1U)) {
#line 500
          tmp___8 = 1;
        } else {
#line 500
          if (__s2_len >= 4U) {
#line 500
            tmp___8 = 1;
          } else {
#line 500
            tmp___8 = 0;
          }
        }
      } else {
#line 500
        tmp___8 = 0;
      }
    }
#line 500
    if (tmp___8) {
#line 500
      tmp___4 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
    } else {
#line 500
      tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 500
      tmp___4 = tmp___7;
    }
  } else {
#line 500
    tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 500
    tmp___4 = tmp___7;
  }
#line 500
  return (tmp___4);
}
}
#line 503 "openbsd-compat/glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ Char pathbuf[4096] ;
  int tmp ;

  {
#line 509
  if ((int )*pattern == 0) {
#line 510
    return (0);
  }
#line 511
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp);
#line 511
  return (tmp);
}
}
#line 521 "openbsd-compat/glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  int tmp___7 ;

  {
#line 533
  anymeta = 0;
#line 533
  while (1) {
#line 534
    if ((int )*pattern == 0) {
#line 535
      *pathend = (unsigned short )'\000';
#line 536
      tmp = g_lstat(pathbuf, & sb, pglob);
#line 536
      if (tmp) {
#line 537
        return (0);
      }
#line 539
      if (pglob->gl_flags & 8) {
#line 539
        if ((int )*(pathend + -1) != 47) {
#line 539
          if ((sb.st_mode & 61440U) == 16384U) {
            goto _L;
          } else {
#line 539
            if ((sb.st_mode & 61440U) == 40960U) {
#line 539
              tmp___1 = g_stat(pathbuf, & sb, pglob);
#line 539
              if (tmp___1 == 0) {
#line 539
                if ((sb.st_mode & 61440U) == 16384U) {
                  _L: /* CIL Label */ 
#line 544
                  if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 545
                    return (1);
                  }
#line 546
                  tmp___0 = pathend;
#line 546
                  pathend ++;
#line 546
                  *tmp___0 = (unsigned short )'/';
#line 547
                  *pathend = (unsigned short )'\000';
                }
              }
            }
          }
        }
      }
#line 549
      (pglob->gl_matchc) ++;
#line 550
      tmp___2 = globextend((Char const   *)pathbuf, pglob, limitp);
#line 550
      return (tmp___2);
    }
#line 554
    q = pathend;
#line 555
    p = pattern;
#line 556
    while (1) {
#line 556
      if ((int )*p != 0) {
#line 556
        if (! ((int )*p != 47)) {
#line 556
          break;
        }
      } else {
#line 556
        break;
      }
#line 557
      if (((int )*p & 32768) != 0) {
#line 558
        anymeta = 1;
      }
#line 559
      if ((unsigned int )(q + 1) > (unsigned int )pathend_last) {
#line 560
        return (1);
      }
#line 561
      tmp___3 = q;
#line 561
      q ++;
#line 561
      tmp___4 = p;
#line 561
      p ++;
#line 561
      *tmp___3 = *tmp___4;
    }
#line 564
    if (! anymeta) {
#line 565
      pathend = q;
#line 566
      pattern = p;
#line 567
      while ((int )*pattern == 47) {
#line 568
        if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 569
          return (1);
        }
#line 570
        tmp___5 = pathend;
#line 570
        pathend ++;
#line 570
        tmp___6 = pattern;
#line 570
        pattern ++;
#line 570
        *tmp___5 = *tmp___6;
      }
    } else {
#line 574
      tmp___7 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, p, pattern_last,
                      pglob, limitp);
#line 574
      return (tmp___7);
    }
  }
}
}
#line 581 "openbsd-compat/glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *restpattern , Char *restpattern_last , glob_t *pglob ,
                 size_t *limitp ) 
{ struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___1[4096] ;
  struct dirent *(*readdirfunc)(void * ) ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  u_char *sc ;
  Char *dc ;
  Char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 599
  if ((unsigned int )pathend > (unsigned int )pathend_last) {
#line 600
    return (1);
  }
#line 601
  *pathend = (unsigned short )'\000';
#line 602
  tmp = __errno_location();
#line 602
  *tmp = 0;
#line 604
  dirp = g_opendir(pathbuf, pglob);
#line 604
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 606
    if (pglob->gl_errfunc) {
#line 607
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___1, sizeof(buf___1));
#line 607
      if (tmp___0) {
#line 608
        return (-2);
      }
#line 609
      tmp___1 = __errno_location();
#line 609
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___1), *tmp___1);
#line 609
      if (tmp___2) {
#line 611
        return (-2);
      } else {
#line 609
        if (pglob->gl_flags & 4) {
#line 611
          return (-2);
        }
      }
    }
#line 613
    return (0);
  }
#line 616
  err = 0;
#line 619
  if (pglob->gl_flags & 64) {
#line 620
    readdirfunc = pglob->gl_readdir;
  } else {
#line 622
    readdirfunc = (struct dirent *(*)(void * ))(& readdir);
  }
#line 623
  while (1) {
#line 623
    dp = (*readdirfunc)((void *)dirp);
#line 623
    if (! dp) {
#line 623
      break;
    }
#line 628
    if ((int )dp->d_name[0] == 46) {
#line 628
      if ((int )*pattern != 46) {
#line 629
        continue;
      }
    }
#line 630
    dc = pathend;
#line 631
    sc = (u_char *)(dp->d_name);
#line 632
    while (1) {
#line 632
      if ((unsigned int )dc < (unsigned int )pathend_last) {
#line 632
        tmp___3 = dc;
#line 632
        dc ++;
#line 632
        tmp___4 = sc;
#line 632
        sc ++;
#line 632
        *tmp___3 = (unsigned short )*tmp___4;
#line 632
        if (! ((int )*tmp___3 != 0)) {
#line 632
          break;
        }
      } else {
#line 632
        break;
      }
    }
#line 634
    if ((unsigned int )dc >= (unsigned int )pathend_last) {
#line 635
      *dc = (unsigned short )'\000';
#line 636
      err = 1;
#line 637
      break;
    }
#line 640
    tmp___5 = match(pathend, pattern, restpattern);
#line 640
    if (! tmp___5) {
#line 641
      *pathend = (unsigned short )'\000';
#line 642
      continue;
    }
#line 644
    dc --;
#line 644
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp);
#line 646
    if (err) {
#line 647
      break;
    }
  }
#line 650
  if (pglob->gl_flags & 64) {
#line 651
    (*(pglob->gl_closedir))((void *)dirp);
  } else {
#line 653
    closedir(dirp);
  }
#line 654
  return (err);
}
}
#line 672 "openbsd-compat/glob.c"
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) 
{ char **pathv ;
  int i ;
  u_int newsize ;
  u_int len ;
  char *copy ;
  Char const   *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  Char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 681
  newsize = sizeof(*pathv) * (unsigned int )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 682
  if (pglob->gl_pathv) {
#line 682
    tmp___1 = realloc((void *)((char *)pglob->gl_pathv), newsize);
#line 682
    pathv = (char **)tmp___1;
  } else {
#line 682
    tmp___2 = malloc(newsize);
#line 682
    pathv = (char **)tmp___2;
  }
#line 684
  if ((unsigned int )pathv == (unsigned int )((void *)0)) {
#line 685
    if (pglob->gl_pathv) {
#line 686
      free((void *)pglob->gl_pathv);
#line 687
      pglob->gl_pathv = (char **)((void *)0);
    }
#line 689
    return (-1);
  }
#line 692
  if ((unsigned int )pglob->gl_pathv == (unsigned int )((void *)0)) {
#line 692
    if (pglob->gl_offs > 0) {
#line 694
      pathv += pglob->gl_offs;
#line 695
      i = pglob->gl_offs;
#line 695
      while (1) {
#line 695
        i --;
#line 695
        if (! (i >= 0)) {
#line 695
          break;
        }
#line 696
        pathv --;
#line 696
        *pathv = (char *)((void *)0);
      }
    }
  }
#line 698
  pglob->gl_pathv = pathv;
#line 700
  p = path;
#line 700
  while (1) {
#line 700
    tmp___3 = p;
#line 700
    p ++;
#line 700
    if (! *tmp___3) {
#line 700
      break;
    }
  }
#line 702
  len = (unsigned int )(p - path);
#line 703
  *limitp += len;
#line 704
  tmp___6 = malloc(len);
#line 704
  copy = (char *)tmp___6;
#line 704
  if ((unsigned int )copy != (unsigned int )((void *)0)) {
#line 705
    tmp___4 = g_Ctoc(path, copy, len);
#line 705
    if (tmp___4) {
#line 706
      free((void *)copy);
#line 707
      return (-1);
    }
#line 709
    tmp___5 = pglob->gl_pathc;
#line 709
    (pglob->gl_pathc) ++;
#line 709
    *(pathv + (pglob->gl_offs + tmp___5)) = copy;
  }
#line 711
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 713
  if (pglob->gl_flags & 8192) {
#line 713
    tmp___8 = get_arg_max();
#line 713
    if (newsize + *limitp >= (unsigned int )tmp___8) {
#line 715
      tmp___7 = __errno_location();
#line 715
      *tmp___7 = 0;
#line 716
      return (-1);
    }
  }
#line 719
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 719
    tmp___9 = -1;
  } else {
#line 719
    tmp___9 = 0;
  }
#line 719
  return (tmp___9);
}
}
#line 727 "openbsd-compat/glob.c"
static int match(Char *name , Char *pat , Char *patend ) 
{ int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  Char *tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;

  {
#line 733
  while ((unsigned int )pat < (unsigned int )patend) {
#line 734
    tmp = pat;
#line 734
    pat ++;
#line 734
    c = *tmp;
#line 735
    switch ((int )c & 65535) {
    case (unsigned short)32810: 
#line 737
    if ((unsigned int )pat == (unsigned int )patend) {
#line 738
      return (1);
    }
#line 739
    while (1) {
#line 740
      tmp___0 = match(name, pat, patend);
#line 740
      if (tmp___0) {
#line 741
        return (1);
      }
#line 739
      tmp___1 = name;
#line 739
      name ++;
#line 739
      if (! ((int )*tmp___1 != 0)) {
#line 739
        break;
      }
    }
#line 743
    return (0);
    case (unsigned short)32831: 
#line 745
    tmp___2 = name;
#line 745
    name ++;
#line 745
    if ((int )*tmp___2 == 0) {
#line 746
      return (0);
    }
#line 747
    break;
    case (unsigned short)32859: 
#line 749
    ok = 0;
#line 750
    tmp___3 = name;
#line 750
    name ++;
#line 750
    k = *tmp___3;
#line 750
    if ((int )k == 0) {
#line 751
      return (0);
    }
#line 752
    negate_range = ((int )*pat & 65535) == 32801;
#line 752
    if (negate_range != 0) {
#line 753
      pat ++;
    }
#line 754
    while (1) {
#line 754
      tmp___4 = pat;
#line 754
      pat ++;
#line 754
      c = *tmp___4;
#line 754
      if (! (((int )c & 65535) != 32861)) {
#line 754
        break;
      }
#line 755
      if (((int )*pat & 65535) == 32813) {
#line 756
        if ((int )c <= (int )k) {
#line 756
          if ((int )k <= (int )*(pat + 1)) {
#line 757
            ok = 1;
          }
        }
#line 758
        pat += 2;
      } else {
#line 759
        if ((int )c == (int )k) {
#line 760
          ok = 1;
        }
      }
    }
#line 761
    if (ok == negate_range) {
#line 762
      return (0);
    }
#line 763
    break;
    default: 
#line 765
    tmp___5 = name;
#line 765
    name ++;
#line 765
    if ((int )*tmp___5 != (int )c) {
#line 766
      return (0);
    }
#line 767
    break;
    }
  }
#line 770
  return ((int )*name == 0);
}
}
#line 774 "openbsd-compat/glob.c"
void globfree(glob_t *pglob ) 
{ int i ;
  char **pp ;
  int tmp ;

  {
#line 780
  if ((unsigned int )pglob->gl_pathv != (unsigned int )((void *)0)) {
#line 781
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 782
    i = pglob->gl_pathc;
#line 782
    while (1) {
#line 782
      tmp = i;
#line 782
      i --;
#line 782
      if (! tmp) {
#line 782
        break;
      }
#line 783
      if (*pp) {
#line 784
        free((void *)*pp);
      }
#line 782
      pp ++;
    }
#line 785
    free((void *)pglob->gl_pathv);
#line 786
    pglob->gl_pathv = (char **)((void *)0);
  }
#line 788
  return;
}
}
#line 790 "openbsd-compat/glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 795
  if (! *str) {
#line 796
    strlcpy(buf___1, ".", sizeof(buf___1));
  } else {
#line 798
    tmp = g_Ctoc((Char const   *)str, buf___1, sizeof(buf___1));
#line 798
    if (tmp) {
#line 799
      return ((DIR *)((void *)0));
    }
  }
#line 802
  if (pglob->gl_flags & 64) {
#line 803
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___1));
#line 803
    return ((DIR *)tmp___0);
  }
#line 805
  tmp___1 = opendir((char const   *)(buf___1));
#line 805
  return (tmp___1);
}
}
#line 808 "openbsd-compat/glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 813
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 813
  if (tmp) {
#line 814
    return (-1);
  }
#line 815
  if (pglob->gl_flags & 64) {
#line 816
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___1), sb);
#line 816
    return (tmp___0);
  }
#line 817
  tmp___1 = lstat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 817
  return (tmp___1);
}
}
#line 820 "openbsd-compat/glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 825
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 825
  if (tmp) {
#line 826
    return (-1);
  }
#line 827
  if (pglob->gl_flags & 64) {
#line 828
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___1), sb);
#line 828
    return (tmp___0);
  }
#line 829
  tmp___1 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 829
  return (tmp___1);
}
}
#line 832 "openbsd-compat/glob.c"
static Char *g_strchr(Char *str , int ch ) 
{ Char *tmp ;

  {
#line 835
  while (1) {
#line 836
    if ((int )*str == ch) {
#line 837
      return (str);
    }
#line 835
    tmp = str;
#line 835
    str ++;
#line 835
    if (! *tmp) {
#line 835
      break;
    }
  }
#line 839
  return ((Char *)((void *)0));
}
}
#line 842 "openbsd-compat/glob.c"
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) 
{ char *tmp ;
  Char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 846
  while (1) {
#line 846
    tmp___1 = len;
#line 846
    len --;
#line 846
    if (! tmp___1) {
#line 846
      break;
    }
#line 847
    tmp = buf___1;
#line 847
    buf___1 ++;
#line 847
    tmp___0 = str;
#line 847
    str ++;
#line 847
    *tmp = (char )*tmp___0;
#line 847
    if ((int )*tmp == 0) {
#line 848
      return (0);
    }
  }
#line 850
  return (1);
}
}
#line 1 "inet_aton.o"
#pragma merger(0,"./inet_aton.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "inet_ntoa.o"
#pragma merger(0,"./inet_ntoa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "inet_ntop.o"
#pragma merger(0,"./inet_ntop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "mktemp.o"
#pragma merger(0,"./mktemp.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 316
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 729 "/usr/include/stdlib.h"
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 91 "./openbsd-compat/openbsd-compat.h"
int mkstemps(char *path , int slen ) ;
#line 48 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) ;
#line 50 "openbsd-compat/mktemp.c"
int mkstemps(char *path , int slen ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 55
  tmp___1 = _gettemp(path, & fd, 0, slen);
#line 55
  if (tmp___1) {
#line 55
    tmp___0 = fd;
  } else {
#line 55
    tmp___0 = -1;
  }
#line 55
  return (tmp___0);
}
}
#line 58
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 58 "openbsd-compat/mktemp.c"
int mkstemp(char *path ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 63
  tmp___1 = _gettemp(path, & fd, 0, 0);
#line 63
  if (tmp___1) {
#line 63
    tmp___0 = fd;
  } else {
#line 63
    tmp___0 = -1;
  }
#line 63
  return (tmp___0);
}
}
#line 66
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 66 "openbsd-compat/mktemp.c"
char *mkdtemp(char *path ) 
{ char *tmp___0 ;
  int tmp___1 ;

  {
#line 69
  tmp___1 = _gettemp(path, (int *)((void *)0), 1, 0);
#line 69
  if (tmp___1) {
#line 69
    tmp___0 = path;
  } else {
#line 69
    tmp___0 = (char *)((void *)0);
  }
#line 69
  return (tmp___0);
}
}
#line 72 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) 
{ register char *start___0 ;
  register char *trv ;
  register char *suffp ;
  struct stat sbuf ;
  int rval ;
  pid_t pid ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char c ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
#line 84
  if (doopen) {
#line 84
    if (domkdir) {
#line 85
      tmp = __errno_location();
#line 85
      *tmp = 22;
#line 86
      return (0);
    }
  }
#line 89
  trv = path;
#line 89
  while (*trv) {
#line 89
    trv ++;
  }
#line 91
  trv -= slen;
#line 92
  suffp = trv;
#line 93
  trv --;
#line 94
  if ((unsigned int )trv < (unsigned int )path) {
#line 95
    tmp___0 = __errno_location();
#line 95
    *tmp___0 = 22;
#line 96
    return (0);
  }
#line 98
  pid = getpid();
#line 99
  while (1) {
#line 99
    if ((unsigned int )trv >= (unsigned int )path) {
#line 99
      if ((int )*trv == 88) {
#line 99
        if (! (pid != 0)) {
#line 99
          break;
        }
      } else {
#line 99
        break;
      }
    } else {
#line 99
      break;
    }
#line 100
    tmp___1 = trv;
#line 100
    trv --;
#line 100
    *tmp___1 = (char )(pid % 10 + 48);
#line 101
    pid /= 10;
  }
#line 103
  while (1) {
#line 103
    if ((unsigned int )trv >= (unsigned int )path) {
#line 103
      if (! ((int )*trv == 88)) {
#line 103
        break;
      }
    } else {
#line 103
      break;
    }
#line 106
    tmp___2 = arc4random();
#line 106
    pid = (int )((tmp___2 & 65535U) % 52U);
#line 107
    if (pid < 26) {
#line 108
      c = (char )(pid + 65);
    } else {
#line 110
      c = (char )((pid - 26) + 97);
    }
#line 111
    tmp___3 = trv;
#line 111
    trv --;
#line 111
    *tmp___3 = c;
  }
#line 113
  start___0 = trv + 1;
#line 119
  if (doopen) {
    goto _L;
  } else {
#line 119
    if (domkdir) {
      _L: /* CIL Label */ 
#line 120
      while (! ((unsigned int )trv <= (unsigned int )path)) {
#line 123
        if ((int )*trv == 47) {
#line 124
          *trv = (char )'\000';
#line 125
          rval = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 126
          *trv = (char )'/';
#line 127
          if (rval != 0) {
#line 128
            return (0);
          }
#line 129
          if (! ((sbuf.st_mode & 61440U) == 16384U)) {
#line 130
            tmp___4 = __errno_location();
#line 130
            *tmp___4 = 20;
#line 131
            return (0);
          }
#line 133
          break;
        }
#line 120
        trv --;
      }
    }
  }
#line 138
  while (1) {
#line 139
    if (doopen) {
#line 140
      *doopen = open((char const   *)path, 194, 384);
#line 140
      if (*doopen >= 0) {
#line 142
        return (1);
      }
#line 143
      tmp___5 = __errno_location();
#line 143
      if (*tmp___5 != 17) {
#line 144
        return (0);
      }
    } else {
#line 145
      if (domkdir) {
#line 146
        tmp___6 = mkdir((char const   *)path, 448U);
#line 146
        if (tmp___6 == 0) {
#line 147
          return (1);
        }
#line 148
        tmp___7 = __errno_location();
#line 148
        if (*tmp___7 != 17) {
#line 149
          return (0);
        }
      } else {
#line 150
        tmp___11 = lstat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 150
        if (tmp___11) {
#line 151
          tmp___10 = __errno_location();
#line 151
          if (*tmp___10 == 2) {
#line 151
            tmp___9 = 1;
          } else {
#line 151
            tmp___9 = 0;
          }
#line 151
          return (tmp___9);
        }
      }
    }
#line 154
    trv = start___0;
#line 154
    while (1) {
#line 155
      if (! *trv) {
#line 156
        return (0);
      }
#line 157
      if ((int )*trv == 90) {
#line 158
        if ((unsigned int )trv == (unsigned int )suffp) {
#line 159
          return (0);
        }
#line 160
        tmp___12 = trv;
#line 160
        trv ++;
#line 160
        *tmp___12 = (char )'a';
      } else {
#line 162
        tmp___13 = __ctype_b_loc();
#line 162
        if ((int const   )*(*tmp___13 + (int )*trv) & 2048) {
#line 163
          *trv = (char )'a';
        } else {
#line 164
          if ((int )*trv == 122) {
#line 165
            *trv = (char )'A';
          } else {
#line 167
            if ((unsigned int )trv == (unsigned int )suffp) {
#line 168
              return (0);
            }
#line 169
            *trv = (char )((int )*trv + 1);
          }
        }
#line 171
        break;
      }
    }
  }
}
}
#line 1 "readpassphrase.o"
#pragma merger(0,"./readpassphrase.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 40 "./openbsd-compat/readpassphrase.h"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 327 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 49 "openbsd-compat/readpassphrase.c"
static sig_atomic_t volatile   signo  ;
#line 51
static void handler(int s ) ;
#line 53 "openbsd-compat/readpassphrase.c"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) 
{ ssize_t nr ;
  int input___0 ;
  int output___0 ;
  int save_errno ;
  char ch ;
  char *p ;
  char *end ;
  struct termios term ;
  struct termios oterm ;
  struct sigaction sa ;
  struct sigaction savealrm ;
  struct sigaction saveint ;
  struct sigaction savehup ;
  struct sigaction savequit ;
  struct sigaction saveterm ;
  struct sigaction savetstp ;
  struct sigaction savettin ;
  struct sigaction savettou ;
  struct sigaction savepipe ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  int __res___0 ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  __pid_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;

  {
#line 64
  if (bufsiz == 0U) {
#line 65
    tmp = __errno_location();
#line 65
    *tmp = 22;
#line 66
    return ((char *)((void *)0));
  }
  restart: 
#line 70
  signo = (int volatile   )0;
#line 75
  if (flags & 32) {
    goto _L;
  } else {
#line 75
    output___0 = open("/dev/tty", 2);
#line 75
    input___0 = output___0;
#line 75
    if (input___0 == -1) {
      _L: /* CIL Label */ 
#line 77
      if (flags & 2) {
#line 78
        tmp___0 = __errno_location();
#line 78
        *tmp___0 = 25;
#line 79
        return ((char *)((void *)0));
      }
#line 81
      input___0 = 0;
#line 82
      output___0 = 2;
    }
  }
#line 90
  sigemptyset(& sa.sa_mask);
#line 91
  sa.sa_flags = 0;
#line 92
  sa.__sigaction_handler.sa_handler = & handler;
#line 93
  sigaction(14, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savealrm));
#line 94
  sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savehup));
#line 95
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveint));
#line 96
  sigaction(13, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savepipe));
#line 97
  sigaction(3, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savequit));
#line 98
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveterm));
#line 99
  sigaction(20, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savetstp));
#line 100
  sigaction(21, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettin));
#line 101
  sigaction(22, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettou));
#line 104
  if (input___0 != 0) {
#line 104
    tmp___1 = tcgetattr(input___0, & oterm);
#line 104
    if (tmp___1 == 0) {
#line 105
      memcpy((void * __restrict  )(& term), (void const   * __restrict  )(& oterm),
             sizeof(term));
#line 106
      if (! (flags & 1)) {
#line 107
        term.c_lflag &= 4294967223U;
      }
#line 112
      tcsetattr(input___0, 2, (struct termios  const  *)(& term));
    } else {
#line 114
      memset((void *)(& term), 0, sizeof(term));
#line 115
      term.c_lflag |= 8U;
#line 116
      memset((void *)(& oterm), 0, sizeof(oterm));
#line 117
      oterm.c_lflag |= 8U;
    }
  } else {
#line 114
    memset((void *)(& term), 0, sizeof(term));
#line 115
    term.c_lflag |= 8U;
#line 116
    memset((void *)(& oterm), 0, sizeof(oterm));
#line 117
    oterm.c_lflag |= 8U;
  }
#line 120
  if (! (flags & 32)) {
#line 121
    tmp___2 = strlen(prompt);
#line 121
    write(output___0, (void const   *)prompt, tmp___2);
  }
#line 122
  end = (buf___1 + bufsiz) - 1;
#line 123
  p = buf___1;
#line 123
  while (1) {
#line 123
    nr = read(input___0, (void *)(& ch), 1U);
#line 123
    if (nr == 1) {
#line 123
      if ((int )ch != 10) {
#line 123
        if (! ((int )ch != 13)) {
#line 123
          break;
        }
      } else {
#line 123
        break;
      }
    } else {
#line 123
      break;
    }
#line 124
    if ((unsigned int )p < (unsigned int )end) {
#line 125
      if (flags & 16) {
#line 126
        ch = (char )((int )ch & 127);
      }
#line 127
      tmp___9 = __ctype_b_loc();
#line 127
      if ((int const   )*(*tmp___9 + (int )ch) & 1024) {
#line 128
        if (flags & 4) {
#line 129
          if (sizeof(ch) > 1U) {
#line 129
            __res = tolower((int )ch);
          } else {
#line 129
            tmp___5 = __ctype_tolower_loc();
#line 129
            __res = (int )*(*tmp___5 + (int )ch);
          }
#line 129
          ch = (char )__res;
        }
#line 130
        if (flags & 8) {
#line 131
          if (sizeof(ch) > 1U) {
#line 131
            __res___0 = toupper((int )ch);
          } else {
#line 131
            tmp___8 = __ctype_toupper_loc();
#line 131
            __res___0 = (int )*(*tmp___8 + (int )ch);
          }
#line 131
          ch = (char )__res___0;
        }
      }
#line 133
      tmp___10 = p;
#line 133
      p ++;
#line 133
      *tmp___10 = ch;
    }
  }
#line 136
  *p = (char )'\000';
#line 137
  tmp___11 = __errno_location();
#line 137
  save_errno = *tmp___11;
#line 138
  if (! (term.c_lflag & 8U)) {
#line 139
    write(output___0, (void const   *)"\n", 1U);
  }
#line 142
  tmp___14 = memcmp((void const   *)(& term), (void const   *)(& oterm), sizeof(term));
#line 142
  if (tmp___14 != 0) {
#line 143
    while (1) {
#line 143
      tmp___12 = tcsetattr(input___0, 2, (struct termios  const  *)(& oterm));
#line 143
      if (tmp___12 == -1) {
#line 143
        tmp___13 = __errno_location();
#line 143
        if (! (*tmp___13 == 4)) {
#line 143
          break;
        }
      } else {
#line 143
        break;
      }
#line 145
      continue;
    }
  }
#line 147
  sigaction(14, (struct sigaction  const  * __restrict  )(& savealrm), (struct sigaction * __restrict  )((void *)0));
#line 148
  sigaction(1, (struct sigaction  const  * __restrict  )(& savehup), (struct sigaction * __restrict  )((void *)0));
#line 149
  sigaction(2, (struct sigaction  const  * __restrict  )(& saveint), (struct sigaction * __restrict  )((void *)0));
#line 150
  sigaction(3, (struct sigaction  const  * __restrict  )(& savequit), (struct sigaction * __restrict  )((void *)0));
#line 151
  sigaction(13, (struct sigaction  const  * __restrict  )(& savepipe), (struct sigaction * __restrict  )((void *)0));
#line 152
  sigaction(15, (struct sigaction  const  * __restrict  )(& saveterm), (struct sigaction * __restrict  )((void *)0));
#line 153
  sigaction(20, (struct sigaction  const  * __restrict  )(& savetstp), (struct sigaction * __restrict  )((void *)0));
#line 154
  sigaction(21, (struct sigaction  const  * __restrict  )(& savettin), (struct sigaction * __restrict  )((void *)0));
#line 155
  if (input___0 != 0) {
#line 156
    close(input___0);
  }
#line 162
  if (signo) {
#line 163
    tmp___15 = getpid();
#line 163
    kill(tmp___15, (int )signo);
#line 164
    switch ((int )signo) {
    case 20: 
    case 21: 
    case 22: 
    goto restart;
    }
  }
#line 172
  tmp___16 = __errno_location();
#line 172
  *tmp___16 = save_errno;
#line 173
  if (nr == -1) {
#line 173
    tmp___17 = (char *)((void *)0);
  } else {
#line 173
    tmp___17 = buf___1;
  }
#line 173
  return (tmp___17);
}
}
#line 186 "openbsd-compat/readpassphrase.c"
static void handler(int s ) 
{ 

  {
#line 189
  signo = (int volatile   )s;
#line 190
  return;
}
}
#line 1 "realpath.o"
#pragma merger(0,"./realpath.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "rresvport.o"
#pragma merger(0,"./rresvport.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "setenv.o"
#pragma merger(0,"./setenv.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "setproctitle.o"
#pragma merger(0,"./setproctitle.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 84 "./openbsd-compat/vis.h"
int strnvis(char *dst , char const   *src , size_t siz , int flag ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 79 "./openbsd-compat/openbsd-compat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 126
void setproctitle(char const   *fmt  , ...) ;
#line 127
void compat_init_setproctitle(int argc , char **argv ) ;
#line 498 "/usr/include/unistd.h"
extern char **environ ;
#line 61 "openbsd-compat/setproctitle.c"
static char *argv_start  =    (char *)((void *)0);
#line 62 "openbsd-compat/setproctitle.c"
static size_t argv_env_len  =    (size_t )0;
#line 67 "openbsd-compat/setproctitle.c"
void compat_init_setproctitle(int argc , char **argv ) 
{ char *lastargv ;
  char **envp ;
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___11 ;

  {
#line 72
  lastargv = (char *)((void *)0);
#line 73
  envp = environ;
#line 82
  if (argc == 0) {
#line 83
    return;
  } else {
#line 82
    if ((unsigned int )*(argv + 0) == (unsigned int )((void *)0)) {
#line 83
      return;
    }
  }
#line 86
  i = 0;
#line 86
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 86
    i ++;
  }
#line 88
  tmp = calloc((unsigned int )(i + 1), sizeof(*environ));
#line 88
  environ = (char **)tmp;
#line 88
  if ((unsigned int )environ == (unsigned int )((void *)0)) {
#line 89
    environ = envp;
#line 90
    return;
  }
#line 97
  i = 0;
#line 97
  while (i < argc) {
#line 98
    if ((unsigned int )lastargv == (unsigned int )((void *)0)) {
#line 99
      tmp___0 = strlen((char const   *)*(argv + i));
#line 99
      lastargv = *(argv + i) + tmp___0;
    } else {
#line 98
      if ((unsigned int )(lastargv + 1) == (unsigned int )*(argv + i)) {
#line 99
        tmp___0 = strlen((char const   *)*(argv + i));
#line 99
        lastargv = *(argv + i) + tmp___0;
      }
    }
#line 97
    i ++;
  }
#line 101
  i = 0;
#line 101
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 102
    if ((unsigned int )(lastargv + 1) == (unsigned int )*(envp + i)) {
#line 103
      tmp___1 = strlen((char const   *)*(envp + i));
#line 103
      lastargv = *(envp + i) + tmp___1;
    }
#line 101
    i ++;
  }
#line 106
  *(argv + 1) = (char *)((void *)0);
#line 107
  argv_start = *(argv + 0);
#line 108
  argv_env_len = (unsigned int )((lastargv - *(argv + 0)) - 1);
#line 114
  i = 0;
#line 114
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 115
    tmp___11 = __strdup((char const   *)*(envp + i));
#line 115
    *(environ + i) = tmp___11;
#line 114
    i ++;
  }
#line 116
  *(environ + i) = (char *)((void *)0);
#line 118
  return;
}
}
#line 121 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ va_list ap ;
  char buf___1[1024] ;
  char ptitle[1024] ;
  size_t len ;

  {
#line 134
  if (argv_env_len <= 0U) {
#line 135
    return;
  }
#line 138
  strlcpy(buf___1, (char const   *)__progname, sizeof(buf___1));
#line 140
  __builtin_va_start(ap, fmt);
#line 141
  if ((unsigned int )fmt != (unsigned int )((void *)0)) {
#line 142
    len = strlcat(buf___1, ": ", sizeof(buf___1));
#line 143
    if (len < sizeof(buf___1)) {
#line 144
      vsnprintf((char * __restrict  )(buf___1 + len), sizeof(buf___1) - len, (char const   * __restrict  )fmt,
                ap);
    }
  }
#line 146
  __builtin_va_end(ap);
#line 147
  strnvis(ptitle, (char const   *)(buf___1), sizeof(ptitle), 27);
#line 156
  len = strlcpy(argv_start, (char const   *)(ptitle), argv_env_len);
#line 157
  while (len < argv_env_len) {
#line 158
    *(argv_start + len) = (char )'\000';
#line 157
    len ++;
  }
#line 162
  return;
}
}
#line 1 "sigact.o"
#pragma merger(0,"./sigact.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "strlcat.o"
#pragma merger(0,"./strlcat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 34 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ char *d ;
  char const   *s ;
  size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 37
  d = dst;
#line 38
  s = src;
#line 39
  n___0 = siz;
#line 43
  while (1) {
#line 43
    tmp = n___0;
#line 43
    n___0 --;
#line 43
    if (tmp != 0U) {
#line 43
      if (! ((int )*d != 0)) {
#line 43
        break;
      }
    } else {
#line 43
      break;
    }
#line 44
    d ++;
  }
#line 45
  dlen = (unsigned int )(d - dst);
#line 46
  n___0 = siz - dlen;
#line 48
  if (n___0 == 0U) {
#line 49
    tmp___0 = strlen(s);
#line 49
    return (dlen + tmp___0);
  }
#line 50
  while ((int const   )*s != 0) {
#line 51
    if (n___0 != 1U) {
#line 52
      tmp___1 = d;
#line 52
      d ++;
#line 52
      *tmp___1 = (char )*s;
#line 53
      n___0 --;
    }
#line 55
    s ++;
  }
#line 57
  *d = (char )'\000';
#line 59
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#pragma merger(0,"./strlcpy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 32 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ char *d ;
  char const   *s ;
  size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 35
  d = dst;
#line 36
  s = src;
#line 37
  n___0 = siz;
#line 40
  if (n___0 != 0U) {
#line 40
    n___0 --;
#line 40
    if (n___0 != 0U) {
#line 41
      while (1) {
#line 42
        tmp = d;
#line 42
        d ++;
#line 42
        tmp___0 = s;
#line 42
        s ++;
#line 42
        *tmp = (char )*tmp___0;
#line 42
        if ((int )*tmp == 0) {
#line 43
          break;
        }
#line 41
        n___0 --;
#line 41
        if (! (n___0 != 0U)) {
#line 41
          break;
        }
      }
    }
  }
#line 48
  if (n___0 == 0U) {
#line 49
    if (siz != 0U) {
#line 50
      *d = (char )'\000';
    }
#line 51
    while (1) {
#line 51
      tmp___1 = s;
#line 51
      s ++;
#line 51
      if (! *tmp___1) {
#line 51
        break;
      }
    }
  }
#line 55
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#pragma merger(0,"./strmode.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 87 "./openbsd-compat/openbsd-compat.h"
void strmode(int mode , char *p ) ;
#line 42 "openbsd-compat/strmode.c"
void strmode(int mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 46
  switch (mode & 61440) {
  case 16384: 
#line 48
  tmp = p;
#line 48
  p ++;
#line 48
  *tmp = (char )'d';
#line 49
  break;
  case 8192: 
#line 51
  tmp___0 = p;
#line 51
  p ++;
#line 51
  *tmp___0 = (char )'c';
#line 52
  break;
  case 24576: 
#line 54
  tmp___1 = p;
#line 54
  p ++;
#line 54
  *tmp___1 = (char )'b';
#line 55
  break;
  case 32768: 
#line 57
  tmp___2 = p;
#line 57
  p ++;
#line 57
  *tmp___2 = (char )'-';
#line 58
  break;
  case 40960: 
#line 60
  tmp___3 = p;
#line 60
  p ++;
#line 60
  *tmp___3 = (char )'l';
#line 61
  break;
  case 49152: 
#line 64
  tmp___4 = p;
#line 64
  p ++;
#line 64
  *tmp___4 = (char )'s';
#line 65
  break;
  case 4096: 
#line 69
  tmp___5 = p;
#line 69
  p ++;
#line 69
  *tmp___5 = (char )'p';
#line 70
  break;
  default: 
#line 73
  tmp___6 = p;
#line 73
  p ++;
#line 73
  *tmp___6 = (char )'?';
#line 74
  break;
  }
#line 77
  if (mode & 256) {
#line 78
    tmp___7 = p;
#line 78
    p ++;
#line 78
    *tmp___7 = (char )'r';
  } else {
#line 80
    tmp___8 = p;
#line 80
    p ++;
#line 80
    *tmp___8 = (char )'-';
  }
#line 81
  if (mode & 128) {
#line 82
    tmp___9 = p;
#line 82
    p ++;
#line 82
    *tmp___9 = (char )'w';
  } else {
#line 84
    tmp___10 = p;
#line 84
    p ++;
#line 84
    *tmp___10 = (char )'-';
  }
#line 85
  switch (mode & 2112) {
  case 0: 
#line 87
  tmp___11 = p;
#line 87
  p ++;
#line 87
  *tmp___11 = (char )'-';
#line 88
  break;
  case 64: 
#line 90
  tmp___12 = p;
#line 90
  p ++;
#line 90
  *tmp___12 = (char )'x';
#line 91
  break;
  case 2048: 
#line 93
  tmp___13 = p;
#line 93
  p ++;
#line 93
  *tmp___13 = (char )'S';
#line 94
  break;
  case 2112: 
#line 96
  tmp___14 = p;
#line 96
  p ++;
#line 96
  *tmp___14 = (char )'s';
#line 97
  break;
  }
#line 100
  if (mode & (256 >> 3)) {
#line 101
    tmp___15 = p;
#line 101
    p ++;
#line 101
    *tmp___15 = (char )'r';
  } else {
#line 103
    tmp___16 = p;
#line 103
    p ++;
#line 103
    *tmp___16 = (char )'-';
  }
#line 104
  if (mode & (128 >> 3)) {
#line 105
    tmp___17 = p;
#line 105
    p ++;
#line 105
    *tmp___17 = (char )'w';
  } else {
#line 107
    tmp___18 = p;
#line 107
    p ++;
#line 107
    *tmp___18 = (char )'-';
  }
#line 108
  switch (mode & ((64 >> 3) | 1024)) {
  case 0: 
#line 110
  tmp___19 = p;
#line 110
  p ++;
#line 110
  *tmp___19 = (char )'-';
#line 111
  break;
  case 64 >> 3: 
#line 113
  tmp___20 = p;
#line 113
  p ++;
#line 113
  *tmp___20 = (char )'x';
#line 114
  break;
  case 1024: 
#line 116
  tmp___21 = p;
#line 116
  p ++;
#line 116
  *tmp___21 = (char )'S';
#line 117
  break;
  case (64 >> 3) | 1024: 
#line 119
  tmp___22 = p;
#line 119
  p ++;
#line 119
  *tmp___22 = (char )'s';
#line 120
  break;
  }
#line 123
  if (mode & ((256 >> 3) >> 3)) {
#line 124
    tmp___23 = p;
#line 124
    p ++;
#line 124
    *tmp___23 = (char )'r';
  } else {
#line 126
    tmp___24 = p;
#line 126
    p ++;
#line 126
    *tmp___24 = (char )'-';
  }
#line 127
  if (mode & ((128 >> 3) >> 3)) {
#line 128
    tmp___25 = p;
#line 128
    p ++;
#line 128
    *tmp___25 = (char )'w';
  } else {
#line 130
    tmp___26 = p;
#line 130
    p ++;
#line 130
    *tmp___26 = (char )'-';
  }
#line 131
  switch (mode & (((64 >> 3) >> 3) | 512)) {
  case 0: 
#line 133
  tmp___27 = p;
#line 133
  p ++;
#line 133
  *tmp___27 = (char )'-';
#line 134
  break;
  case (64 >> 3) >> 3: 
#line 136
  tmp___28 = p;
#line 136
  p ++;
#line 136
  *tmp___28 = (char )'x';
#line 137
  break;
  case 512: 
#line 139
  tmp___29 = p;
#line 139
  p ++;
#line 139
  *tmp___29 = (char )'T';
#line 140
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 142
  tmp___30 = p;
#line 142
  p ++;
#line 142
  *tmp___30 = (char )'t';
#line 143
  break;
  }
#line 145
  tmp___31 = p;
#line 145
  p ++;
#line 145
  *tmp___31 = (char )' ';
#line 146
  *p = (char )'\000';
#line 147
  return;
}
}
#line 1 "strsep.o"
#pragma merger(0,"./strsep.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "strtoul.o"
#pragma merger(0,"./strtoul.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "vis.o"
#pragma merger(0,"./vis.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 82 "./openbsd-compat/vis.h"
char *vis(char *dst , int c , int flag , int nextc ) ;
#line 83
int strvis(char *dst , char const   *src , int flag ) ;
#line 86
int strvisx(char *dst , char const   *src , size_t len , int flag ) ;
#line 56 "openbsd-compat/vis.c"
char *vis(char *dst , int c , int flag , int nextc ) 
{ char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned short const   **tmp___34 ;

  {
#line 59
  if ((unsigned int )c <= 255U) {
#line 59
    if (((int )((unsigned char )c) & -128) == 0) {
#line 59
      if (c != 42) {
#line 59
        if (c != 63) {
#line 59
          if (c != 91) {
#line 59
            if (c != 35) {
              goto _L___6;
            } else {
              goto _L___9;
            }
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
#line 59
        if ((flag & 256) == 0) {
          _L___6: /* CIL Label */ 
#line 59
          tmp___1 = __ctype_b_loc();
#line 59
          if ((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 32768) {
            goto _L___0;
          } else {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      }
    } else {
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ 
#line 59
    if ((flag & 4) == 0) {
#line 59
      if (c == 32) {
        goto _L___0;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 59
      if ((flag & 8) == 0) {
#line 59
        if (c == 9) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 59
        if ((flag & 16) == 0) {
#line 59
          if (c == 10) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 59
          if (flag & 32) {
#line 59
            if (c == 8) {
              goto _L___0;
            } else {
#line 59
              if (c == 7) {
                goto _L___0;
              } else {
#line 59
                if (c == 13) {
                  goto _L___0;
                } else {
#line 59
                  tmp___2 = __ctype_b_loc();
#line 59
                  if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
                    _L___0: /* CIL Label */ 
#line 60
                    tmp = dst;
#line 60
                    dst ++;
#line 60
                    *tmp = (char )c;
#line 61
                    if (c == 92) {
#line 61
                      if ((flag & 64) == 0) {
#line 62
                        tmp___0 = dst;
#line 62
                        dst ++;
#line 62
                        *tmp___0 = (char )'\\';
                      }
                    }
#line 63
                    *dst = (char )'\000';
#line 64
                    return (dst);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 67
  if (flag & 2) {
#line 68
    switch (c) {
    case 10: 
#line 70
    tmp___3 = dst;
#line 70
    dst ++;
#line 70
    *tmp___3 = (char )'\\';
#line 71
    tmp___4 = dst;
#line 71
    dst ++;
#line 71
    *tmp___4 = (char )'n';
    goto done;
    case 13: 
#line 74
    tmp___5 = dst;
#line 74
    dst ++;
#line 74
    *tmp___5 = (char )'\\';
#line 75
    tmp___6 = dst;
#line 75
    dst ++;
#line 75
    *tmp___6 = (char )'r';
    goto done;
    case 8: 
#line 78
    tmp___7 = dst;
#line 78
    dst ++;
#line 78
    *tmp___7 = (char )'\\';
#line 79
    tmp___8 = dst;
#line 79
    dst ++;
#line 79
    *tmp___8 = (char )'b';
    goto done;
    case 7: 
#line 82
    tmp___9 = dst;
#line 82
    dst ++;
#line 82
    *tmp___9 = (char )'\\';
#line 83
    tmp___10 = dst;
#line 83
    dst ++;
#line 83
    *tmp___10 = (char )'a';
    goto done;
    case 11: 
#line 86
    tmp___11 = dst;
#line 86
    dst ++;
#line 86
    *tmp___11 = (char )'\\';
#line 87
    tmp___12 = dst;
#line 87
    dst ++;
#line 87
    *tmp___12 = (char )'v';
    goto done;
    case 9: 
#line 90
    tmp___13 = dst;
#line 90
    dst ++;
#line 90
    *tmp___13 = (char )'\\';
#line 91
    tmp___14 = dst;
#line 91
    dst ++;
#line 91
    *tmp___14 = (char )'t';
    goto done;
    case 12: 
#line 94
    tmp___15 = dst;
#line 94
    dst ++;
#line 94
    *tmp___15 = (char )'\\';
#line 95
    tmp___16 = dst;
#line 95
    dst ++;
#line 95
    *tmp___16 = (char )'f';
    goto done;
    case 32: 
#line 98
    tmp___17 = dst;
#line 98
    dst ++;
#line 98
    *tmp___17 = (char )'\\';
#line 99
    tmp___18 = dst;
#line 99
    dst ++;
#line 99
    *tmp___18 = (char )'s';
    goto done;
    case 0: 
#line 102
    tmp___19 = dst;
#line 102
    dst ++;
#line 102
    *tmp___19 = (char )'\\';
#line 103
    tmp___20 = dst;
#line 103
    dst ++;
#line 103
    *tmp___20 = (char )'0';
#line 104
    if ((int )((unsigned char )nextc) >= 48) {
#line 104
      if ((int )((unsigned char )nextc) <= 55) {
#line 105
        tmp___21 = dst;
#line 105
        dst ++;
#line 105
        *tmp___21 = (char )'0';
#line 106
        tmp___22 = dst;
#line 106
        dst ++;
#line 106
        *tmp___22 = (char )'0';
      }
    }
    goto done;
    }
  }
#line 111
  if ((c & 127) == 32) {
    goto _L___12;
  } else {
#line 111
    if (flag & 1) {
      goto _L___12;
    } else {
#line 111
      if (flag & 256) {
#line 111
        if (c == 42) {
          goto _L___12;
        } else {
#line 111
          if (c == 63) {
            goto _L___12;
          } else {
#line 111
            if (c == 91) {
              goto _L___12;
            } else {
#line 111
              if (c == 35) {
                _L___12: /* CIL Label */ 
#line 113
                tmp___23 = dst;
#line 113
                dst ++;
#line 113
                *tmp___23 = (char )'\\';
#line 114
                tmp___24 = dst;
#line 114
                dst ++;
#line 114
                *tmp___24 = (char )((((int )((unsigned char )c) >> 6) & 7) + 48);
#line 115
                tmp___25 = dst;
#line 115
                dst ++;
#line 115
                *tmp___25 = (char )((((int )((unsigned char )c) >> 3) & 7) + 48);
#line 116
                tmp___26 = dst;
#line 116
                dst ++;
#line 116
                *tmp___26 = (char )(((int )((unsigned char )c) & 7) + 48);
                goto done;
              }
            }
          }
        }
      }
    }
  }
#line 119
  if ((flag & 64) == 0) {
#line 120
    tmp___27 = dst;
#line 120
    dst ++;
#line 120
    *tmp___27 = (char )'\\';
  }
#line 121
  if (c & 128) {
#line 122
    c &= 127;
#line 123
    tmp___28 = dst;
#line 123
    dst ++;
#line 123
    *tmp___28 = (char )'M';
  }
#line 125
  tmp___34 = __ctype_b_loc();
#line 125
  if ((int const   )*(*tmp___34 + (int )((unsigned char )c)) & 2) {
#line 126
    tmp___29 = dst;
#line 126
    dst ++;
#line 126
    *tmp___29 = (char )'^';
#line 127
    if (c == 127) {
#line 128
      tmp___30 = dst;
#line 128
      dst ++;
#line 128
      *tmp___30 = (char )'?';
    } else {
#line 130
      tmp___31 = dst;
#line 130
      dst ++;
#line 130
      *tmp___31 = (char )(c + 64);
    }
  } else {
#line 132
    tmp___32 = dst;
#line 132
    dst ++;
#line 132
    *tmp___32 = (char )'-';
#line 133
    tmp___33 = dst;
#line 133
    dst ++;
#line 133
    *tmp___33 = (char )c;
  }
  done: 
#line 136
  *dst = (char )'\000';
#line 137
  return (dst);
}
}
#line 153 "openbsd-compat/vis.c"
int strvis(char *dst , char const   *src , int flag ) 
{ char c ;
  char *start___0 ;

  {
#line 159
  start___0 = dst;
#line 159
  while (1) {
#line 159
    c = (char )*src;
#line 159
    if (! c) {
#line 159
      break;
    }
#line 160
    src ++;
#line 160
    dst = vis(dst, (int )c, flag, (int )*src);
  }
#line 161
  *dst = (char )'\000';
#line 162
  return (dst - start___0);
}
}
#line 165 "openbsd-compat/vis.c"
int strnvis(char *dst , char const   *src , size_t siz , int flag ) 
{ char *start___0 ;
  char *end ;
  char tbuf[5] ;
  int c ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
#line 172
  i = 0;
#line 173
  start___0 = dst;
#line 173
  end = (start___0 + siz) - 1;
#line 173
  while (1) {
#line 173
    c = (int )*src;
#line 173
    if (c) {
#line 173
      if (! ((unsigned int )dst < (unsigned int )end)) {
#line 173
        break;
      }
    } else {
#line 173
      break;
    }
#line 174
    if ((unsigned int )c <= 255U) {
#line 174
      if (((int )((unsigned char )c) & -128) == 0) {
#line 174
        if (c != 42) {
#line 174
          if (c != 63) {
#line 174
            if (c != 91) {
#line 174
              if (c != 35) {
                goto _L___7;
              } else {
                goto _L___10;
              }
            } else {
              goto _L___10;
            }
          } else {
            goto _L___10;
          }
        } else {
          _L___10: /* CIL Label */ 
#line 174
          if ((flag & 256) == 0) {
            _L___7: /* CIL Label */ 
#line 174
            tmp___2 = __ctype_b_loc();
#line 174
            if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
              goto _L___1;
            } else {
              goto _L___11;
            }
          } else {
            goto _L___11;
          }
        }
      } else {
        goto _L___11;
      }
    } else {
      _L___11: /* CIL Label */ 
#line 174
      if ((flag & 4) == 0) {
#line 174
        if (c == 32) {
          goto _L___1;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 174
        if ((flag & 8) == 0) {
#line 174
          if (c == 9) {
            goto _L___1;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 174
          if ((flag & 16) == 0) {
#line 174
            if (c == 10) {
              goto _L___1;
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 174
            if (flag & 32) {
#line 174
              if (c == 8) {
                goto _L___1;
              } else {
#line 174
                if (c == 7) {
                  goto _L___1;
                } else {
#line 174
                  if (c == 13) {
                    goto _L___1;
                  } else {
#line 174
                    tmp___3 = __ctype_b_loc();
#line 174
                    if ((int const   )*(*tmp___3 + (int )((unsigned char )c)) & 32768) {
                      _L___1: /* CIL Label */ 
#line 175
                      i = 1;
#line 176
                      tmp = dst;
#line 176
                      dst ++;
#line 176
                      *tmp = (char )c;
#line 177
                      if (c == 92) {
#line 177
                        if ((flag & 64) == 0) {
#line 179
                          if ((unsigned int )dst < (unsigned int )end) {
#line 180
                            tmp___0 = dst;
#line 180
                            dst ++;
#line 180
                            *tmp___0 = (char )'\\';
                          } else {
#line 182
                            dst --;
#line 183
                            i = 2;
#line 184
                            break;
                          }
                        }
                      }
#line 187
                      src ++;
                    } else {
                      goto _L___0;
                    }
                  }
                }
              }
            } else {
              _L___0: /* CIL Label */ 
#line 189
              src ++;
#line 189
              tmp___1 = vis(tbuf, c, flag, (int )*src);
#line 189
              i = tmp___1 - tbuf;
#line 190
              if ((unsigned int )(dst + i) <= (unsigned int )end) {
#line 191
                memcpy((void * __restrict  )dst, (void const   * __restrict  )(tbuf),
                       (unsigned int )i);
#line 192
                dst += i;
              } else {
#line 194
                src --;
#line 195
                break;
              }
            }
          }
        }
      }
    }
  }
#line 199
  if (siz > 0U) {
#line 200
    *dst = (char )'\000';
  }
#line 201
  if ((unsigned int )(dst + i) > (unsigned int )end) {
#line 203
    while (1) {
#line 203
      c = (int )*src;
#line 203
      if (! c) {
#line 203
        break;
      }
#line 204
      src ++;
#line 204
      tmp___4 = vis(tbuf, c, flag, (int )*src);
#line 204
      dst += tmp___4 - tbuf;
    }
  }
#line 206
  return (dst - start___0);
}
}
#line 209 "openbsd-compat/vis.c"
int strvisx(char *dst , char const   *src , size_t len , int flag ) 
{ char c ;
  char *start___0 ;

  {
#line 215
  start___0 = dst;
#line 215
  while (len > 1U) {
#line 216
    c = (char )*src;
#line 217
    src ++;
#line 217
    dst = vis(dst, (int )c, flag, (int )*src);
#line 215
    len --;
  }
#line 219
  if (len) {
#line 220
    dst = vis(dst, (int )*src, flag, '\000');
  }
#line 221
  *dst = (char )'\000';
#line 222
  return (dst - start___0);
}
}
#line 1 "acss.o"
#pragma merger(0,"./acss.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 43 "acss.h"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) ;
#line 44
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) ;
#line 45
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) ;
#line 29 "acss.c"
static unsigned char sboxdec[256]  = 
#line 29 "acss.c"
  {      (unsigned char)51,      (unsigned char)115,      (unsigned char)59,      (unsigned char)38, 
        (unsigned char)99,      (unsigned char)35,      (unsigned char)107,      (unsigned char)118, 
        (unsigned char)62,      (unsigned char)126,      (unsigned char)54,      (unsigned char)43, 
        (unsigned char)110,      (unsigned char)46,      (unsigned char)102,      (unsigned char)123, 
        (unsigned char)211,      (unsigned char)147,      (unsigned char)219,      (unsigned char)6, 
        (unsigned char)67,      (unsigned char)3,      (unsigned char)75,      (unsigned char)150, 
        (unsigned char)222,      (unsigned char)158,      (unsigned char)214,      (unsigned char)11, 
        (unsigned char)78,      (unsigned char)14,      (unsigned char)70,      (unsigned char)155, 
        (unsigned char)87,      (unsigned char)23,      (unsigned char)95,      (unsigned char)130, 
        (unsigned char)199,      (unsigned char)135,      (unsigned char)207,      (unsigned char)18, 
        (unsigned char)90,      (unsigned char)26,      (unsigned char)82,      (unsigned char)143, 
        (unsigned char)202,      (unsigned char)138,      (unsigned char)194,      (unsigned char)31, 
        (unsigned char)217,      (unsigned char)153,      (unsigned char)209,      (unsigned char)0, 
        (unsigned char)73,      (unsigned char)9,      (unsigned char)65,      (unsigned char)144, 
        (unsigned char)216,      (unsigned char)152,      (unsigned char)208,      (unsigned char)1, 
        (unsigned char)72,      (unsigned char)8,      (unsigned char)64,      (unsigned char)145, 
        (unsigned char)61,      (unsigned char)125,      (unsigned char)53,      (unsigned char)36, 
        (unsigned char)109,      (unsigned char)45,      (unsigned char)101,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)124,      (unsigned char)52,      (unsigned char)37, 
        (unsigned char)108,      (unsigned char)44,      (unsigned char)100,      (unsigned char)117, 
        (unsigned char)221,      (unsigned char)157,      (unsigned char)213,      (unsigned char)4, 
        (unsigned char)77,      (unsigned char)13,      (unsigned char)69,      (unsigned char)148, 
        (unsigned char)220,      (unsigned char)156,      (unsigned char)212,      (unsigned char)5, 
        (unsigned char)76,      (unsigned char)12,      (unsigned char)68,      (unsigned char)149, 
        (unsigned char)89,      (unsigned char)25,      (unsigned char)81,      (unsigned char)128, 
        (unsigned char)201,      (unsigned char)137,      (unsigned char)193,      (unsigned char)16, 
        (unsigned char)88,      (unsigned char)24,      (unsigned char)80,      (unsigned char)129, 
        (unsigned char)200,      (unsigned char)136,      (unsigned char)192,      (unsigned char)17, 
        (unsigned char)215,      (unsigned char)151,      (unsigned char)223,      (unsigned char)2, 
        (unsigned char)71,      (unsigned char)7,      (unsigned char)79,      (unsigned char)146, 
        (unsigned char)218,      (unsigned char)154,      (unsigned char)210,      (unsigned char)15, 
        (unsigned char)74,      (unsigned char)10,      (unsigned char)66,      (unsigned char)159, 
        (unsigned char)83,      (unsigned char)19,      (unsigned char)91,      (unsigned char)134, 
        (unsigned char)195,      (unsigned char)131,      (unsigned char)203,      (unsigned char)22, 
        (unsigned char)94,      (unsigned char)30,      (unsigned char)86,      (unsigned char)139, 
        (unsigned char)206,      (unsigned char)142,      (unsigned char)198,      (unsigned char)27, 
        (unsigned char)179,      (unsigned char)243,      (unsigned char)187,      (unsigned char)166, 
        (unsigned char)227,      (unsigned char)163,      (unsigned char)235,      (unsigned char)246, 
        (unsigned char)190,      (unsigned char)254,      (unsigned char)182,      (unsigned char)171, 
        (unsigned char)238,      (unsigned char)174,      (unsigned char)230,      (unsigned char)251, 
        (unsigned char)55,      (unsigned char)119,      (unsigned char)63,      (unsigned char)34, 
        (unsigned char)103,      (unsigned char)39,      (unsigned char)111,      (unsigned char)114, 
        (unsigned char)58,      (unsigned char)122,      (unsigned char)50,      (unsigned char)47, 
        (unsigned char)106,      (unsigned char)42,      (unsigned char)98,      (unsigned char)127, 
        (unsigned char)185,      (unsigned char)249,      (unsigned char)177,      (unsigned char)160, 
        (unsigned char)233,      (unsigned char)169,      (unsigned char)225,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)248,      (unsigned char)176,      (unsigned char)161, 
        (unsigned char)232,      (unsigned char)168,      (unsigned char)224,      (unsigned char)241, 
        (unsigned char)93,      (unsigned char)29,      (unsigned char)85,      (unsigned char)132, 
        (unsigned char)205,      (unsigned char)141,      (unsigned char)197,      (unsigned char)20, 
        (unsigned char)92,      (unsigned char)28,      (unsigned char)84,      (unsigned char)133, 
        (unsigned char)204,      (unsigned char)140,      (unsigned char)196,      (unsigned char)21, 
        (unsigned char)189,      (unsigned char)253,      (unsigned char)181,      (unsigned char)164, 
        (unsigned char)237,      (unsigned char)173,      (unsigned char)229,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)252,      (unsigned char)180,      (unsigned char)165, 
        (unsigned char)236,      (unsigned char)172,      (unsigned char)228,      (unsigned char)245, 
        (unsigned char)57,      (unsigned char)121,      (unsigned char)49,      (unsigned char)32, 
        (unsigned char)105,      (unsigned char)41,      (unsigned char)97,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)120,      (unsigned char)48,      (unsigned char)33, 
        (unsigned char)104,      (unsigned char)40,      (unsigned char)96,      (unsigned char)113, 
        (unsigned char)183,      (unsigned char)247,      (unsigned char)191,      (unsigned char)162, 
        (unsigned char)231,      (unsigned char)167,      (unsigned char)239,      (unsigned char)242, 
        (unsigned char)186,      (unsigned char)250,      (unsigned char)178,      (unsigned char)175, 
        (unsigned char)234,      (unsigned char)170,      (unsigned char)226,      (unsigned char)255};
#line 65 "acss.c"
static unsigned char sboxenc[256]  = 
#line 65
  {      (unsigned char)51,      (unsigned char)59,      (unsigned char)115,      (unsigned char)21, 
        (unsigned char)83,      (unsigned char)91,      (unsigned char)19,      (unsigned char)117, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)125,      (unsigned char)27, 
        (unsigned char)93,      (unsigned char)85,      (unsigned char)29,      (unsigned char)123, 
        (unsigned char)103,      (unsigned char)111,      (unsigned char)39,      (unsigned char)129, 
        (unsigned char)199,      (unsigned char)207,      (unsigned char)135,      (unsigned char)33, 
        (unsigned char)105,      (unsigned char)97,      (unsigned char)41,      (unsigned char)143, 
        (unsigned char)201,      (unsigned char)193,      (unsigned char)137,      (unsigned char)47, 
        (unsigned char)227,      (unsigned char)235,      (unsigned char)163,      (unsigned char)5, 
        (unsigned char)67,      (unsigned char)75,      (unsigned char)3,      (unsigned char)165, 
        (unsigned char)237,      (unsigned char)229,      (unsigned char)173,      (unsigned char)11, 
        (unsigned char)77,      (unsigned char)69,      (unsigned char)13,      (unsigned char)171, 
        (unsigned char)234,      (unsigned char)226,      (unsigned char)170,      (unsigned char)0, 
        (unsigned char)74,      (unsigned char)66,      (unsigned char)10,      (unsigned char)160, 
        (unsigned char)232,      (unsigned char)224,      (unsigned char)168,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)64,      (unsigned char)8,      (unsigned char)162, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)126,      (unsigned char)20, 
        (unsigned char)94,      (unsigned char)86,      (unsigned char)30,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)124,      (unsigned char)22, 
        (unsigned char)92,      (unsigned char)84,      (unsigned char)28,      (unsigned char)118, 
        (unsigned char)106,      (unsigned char)98,      (unsigned char)42,      (unsigned char)128, 
        (unsigned char)202,      (unsigned char)194,      (unsigned char)138,      (unsigned char)32, 
        (unsigned char)104,      (unsigned char)96,      (unsigned char)40,      (unsigned char)130, 
        (unsigned char)200,      (unsigned char)192,      (unsigned char)136,      (unsigned char)34, 
        (unsigned char)238,      (unsigned char)230,      (unsigned char)174,      (unsigned char)4, 
        (unsigned char)78,      (unsigned char)70,      (unsigned char)14,      (unsigned char)164, 
        (unsigned char)236,      (unsigned char)228,      (unsigned char)172,      (unsigned char)6, 
        (unsigned char)76,      (unsigned char)68,      (unsigned char)12,      (unsigned char)166, 
        (unsigned char)231,      (unsigned char)239,      (unsigned char)167,      (unsigned char)1, 
        (unsigned char)71,      (unsigned char)79,      (unsigned char)7,      (unsigned char)161, 
        (unsigned char)233,      (unsigned char)225,      (unsigned char)169,      (unsigned char)15, 
        (unsigned char)73,      (unsigned char)65,      (unsigned char)9,      (unsigned char)175, 
        (unsigned char)99,      (unsigned char)107,      (unsigned char)35,      (unsigned char)133, 
        (unsigned char)195,      (unsigned char)203,      (unsigned char)131,      (unsigned char)37, 
        (unsigned char)109,      (unsigned char)101,      (unsigned char)45,      (unsigned char)139, 
        (unsigned char)205,      (unsigned char)197,      (unsigned char)141,      (unsigned char)43, 
        (unsigned char)55,      (unsigned char)63,      (unsigned char)119,      (unsigned char)17, 
        (unsigned char)87,      (unsigned char)95,      (unsigned char)23,      (unsigned char)113, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)121,      (unsigned char)31, 
        (unsigned char)89,      (unsigned char)81,      (unsigned char)25,      (unsigned char)127, 
        (unsigned char)179,      (unsigned char)187,      (unsigned char)243,      (unsigned char)149, 
        (unsigned char)211,      (unsigned char)219,      (unsigned char)147,      (unsigned char)245, 
        (unsigned char)189,      (unsigned char)181,      (unsigned char)253,      (unsigned char)155, 
        (unsigned char)221,      (unsigned char)213,      (unsigned char)157,      (unsigned char)251, 
        (unsigned char)186,      (unsigned char)178,      (unsigned char)250,      (unsigned char)144, 
        (unsigned char)218,      (unsigned char)210,      (unsigned char)154,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)176,      (unsigned char)248,      (unsigned char)146, 
        (unsigned char)216,      (unsigned char)208,      (unsigned char)152,      (unsigned char)242, 
        (unsigned char)110,      (unsigned char)102,      (unsigned char)46,      (unsigned char)132, 
        (unsigned char)206,      (unsigned char)198,      (unsigned char)142,      (unsigned char)36, 
        (unsigned char)108,      (unsigned char)100,      (unsigned char)44,      (unsigned char)134, 
        (unsigned char)204,      (unsigned char)196,      (unsigned char)140,      (unsigned char)38, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)122,      (unsigned char)16, 
        (unsigned char)90,      (unsigned char)82,      (unsigned char)26,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)48,      (unsigned char)120,      (unsigned char)18, 
        (unsigned char)88,      (unsigned char)80,      (unsigned char)24,      (unsigned char)114, 
        (unsigned char)190,      (unsigned char)182,      (unsigned char)254,      (unsigned char)148, 
        (unsigned char)222,      (unsigned char)214,      (unsigned char)158,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)180,      (unsigned char)252,      (unsigned char)150, 
        (unsigned char)220,      (unsigned char)212,      (unsigned char)156,      (unsigned char)246, 
        (unsigned char)183,      (unsigned char)191,      (unsigned char)247,      (unsigned char)145, 
        (unsigned char)215,      (unsigned char)223,      (unsigned char)151,      (unsigned char)241, 
        (unsigned char)185,      (unsigned char)177,      (unsigned char)249,      (unsigned char)159, 
        (unsigned char)217,      (unsigned char)209,      (unsigned char)153,      (unsigned char)255};
#line 100 "acss.c"
static unsigned char reverse[256]  = 
#line 100
  {      (unsigned char)0,      (unsigned char)128,      (unsigned char)64,      (unsigned char)192, 
        (unsigned char)32,      (unsigned char)160,      (unsigned char)96,      (unsigned char)224, 
        (unsigned char)16,      (unsigned char)144,      (unsigned char)80,      (unsigned char)208, 
        (unsigned char)48,      (unsigned char)176,      (unsigned char)112,      (unsigned char)240, 
        (unsigned char)8,      (unsigned char)136,      (unsigned char)72,      (unsigned char)200, 
        (unsigned char)40,      (unsigned char)168,      (unsigned char)104,      (unsigned char)232, 
        (unsigned char)24,      (unsigned char)152,      (unsigned char)88,      (unsigned char)216, 
        (unsigned char)56,      (unsigned char)184,      (unsigned char)120,      (unsigned char)248, 
        (unsigned char)4,      (unsigned char)132,      (unsigned char)68,      (unsigned char)196, 
        (unsigned char)36,      (unsigned char)164,      (unsigned char)100,      (unsigned char)228, 
        (unsigned char)20,      (unsigned char)148,      (unsigned char)84,      (unsigned char)212, 
        (unsigned char)52,      (unsigned char)180,      (unsigned char)116,      (unsigned char)244, 
        (unsigned char)12,      (unsigned char)140,      (unsigned char)76,      (unsigned char)204, 
        (unsigned char)44,      (unsigned char)172,      (unsigned char)108,      (unsigned char)236, 
        (unsigned char)28,      (unsigned char)156,      (unsigned char)92,      (unsigned char)220, 
        (unsigned char)60,      (unsigned char)188,      (unsigned char)124,      (unsigned char)252, 
        (unsigned char)2,      (unsigned char)130,      (unsigned char)66,      (unsigned char)194, 
        (unsigned char)34,      (unsigned char)162,      (unsigned char)98,      (unsigned char)226, 
        (unsigned char)18,      (unsigned char)146,      (unsigned char)82,      (unsigned char)210, 
        (unsigned char)50,      (unsigned char)178,      (unsigned char)114,      (unsigned char)242, 
        (unsigned char)10,      (unsigned char)138,      (unsigned char)74,      (unsigned char)202, 
        (unsigned char)42,      (unsigned char)170,      (unsigned char)106,      (unsigned char)234, 
        (unsigned char)26,      (unsigned char)154,      (unsigned char)90,      (unsigned char)218, 
        (unsigned char)58,      (unsigned char)186,      (unsigned char)122,      (unsigned char)250, 
        (unsigned char)6,      (unsigned char)134,      (unsigned char)70,      (unsigned char)198, 
        (unsigned char)38,      (unsigned char)166,      (unsigned char)102,      (unsigned char)230, 
        (unsigned char)22,      (unsigned char)150,      (unsigned char)86,      (unsigned char)214, 
        (unsigned char)54,      (unsigned char)182,      (unsigned char)118,      (unsigned char)246, 
        (unsigned char)14,      (unsigned char)142,      (unsigned char)78,      (unsigned char)206, 
        (unsigned char)46,      (unsigned char)174,      (unsigned char)110,      (unsigned char)238, 
        (unsigned char)30,      (unsigned char)158,      (unsigned char)94,      (unsigned char)222, 
        (unsigned char)62,      (unsigned char)190,      (unsigned char)126,      (unsigned char)254, 
        (unsigned char)1,      (unsigned char)129,      (unsigned char)65,      (unsigned char)193, 
        (unsigned char)33,      (unsigned char)161,      (unsigned char)97,      (unsigned char)225, 
        (unsigned char)17,      (unsigned char)145,      (unsigned char)81,      (unsigned char)209, 
        (unsigned char)49,      (unsigned char)177,      (unsigned char)113,      (unsigned char)241, 
        (unsigned char)9,      (unsigned char)137,      (unsigned char)73,      (unsigned char)201, 
        (unsigned char)41,      (unsigned char)169,      (unsigned char)105,      (unsigned char)233, 
        (unsigned char)25,      (unsigned char)153,      (unsigned char)89,      (unsigned char)217, 
        (unsigned char)57,      (unsigned char)185,      (unsigned char)121,      (unsigned char)249, 
        (unsigned char)5,      (unsigned char)133,      (unsigned char)69,      (unsigned char)197, 
        (unsigned char)37,      (unsigned char)165,      (unsigned char)101,      (unsigned char)229, 
        (unsigned char)21,      (unsigned char)149,      (unsigned char)85,      (unsigned char)213, 
        (unsigned char)53,      (unsigned char)181,      (unsigned char)117,      (unsigned char)245, 
        (unsigned char)13,      (unsigned char)141,      (unsigned char)77,      (unsigned char)205, 
        (unsigned char)45,      (unsigned char)173,      (unsigned char)109,      (unsigned char)237, 
        (unsigned char)29,      (unsigned char)157,      (unsigned char)93,      (unsigned char)221, 
        (unsigned char)61,      (unsigned char)189,      (unsigned char)125,      (unsigned char)253, 
        (unsigned char)3,      (unsigned char)131,      (unsigned char)67,      (unsigned char)195, 
        (unsigned char)35,      (unsigned char)163,      (unsigned char)99,      (unsigned char)227, 
        (unsigned char)19,      (unsigned char)147,      (unsigned char)83,      (unsigned char)211, 
        (unsigned char)51,      (unsigned char)179,      (unsigned char)115,      (unsigned char)243, 
        (unsigned char)11,      (unsigned char)139,      (unsigned char)75,      (unsigned char)203, 
        (unsigned char)43,      (unsigned char)171,      (unsigned char)107,      (unsigned char)235, 
        (unsigned char)27,      (unsigned char)155,      (unsigned char)91,      (unsigned char)219, 
        (unsigned char)59,      (unsigned char)187,      (unsigned char)123,      (unsigned char)251, 
        (unsigned char)7,      (unsigned char)135,      (unsigned char)71,      (unsigned char)199, 
        (unsigned char)39,      (unsigned char)167,      (unsigned char)103,      (unsigned char)231, 
        (unsigned char)23,      (unsigned char)151,      (unsigned char)87,      (unsigned char)215, 
        (unsigned char)55,      (unsigned char)183,      (unsigned char)119,      (unsigned char)247, 
        (unsigned char)15,      (unsigned char)143,      (unsigned char)79,      (unsigned char)207, 
        (unsigned char)47,      (unsigned char)175,      (unsigned char)111,      (unsigned char)239, 
        (unsigned char)31,      (unsigned char)159,      (unsigned char)95,      (unsigned char)223, 
        (unsigned char)63,      (unsigned char)191,      (unsigned char)127,      (unsigned char)255};
#line 162 "acss.c"
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) 
{ unsigned long i ;
  unsigned long lfsr17tmp ;
  unsigned long lfsr25tmp ;
  unsigned long lfsrsumtmp ;

  {
#line 169
  lfsr25tmp = 0UL;
#line 169
  lfsr17tmp = lfsr25tmp;
#line 169
  lfsrsumtmp = lfsr17tmp;
#line 172
  i = 0UL;
#line 172
  while (i < len) {
#line 173
    lfsr17tmp = (unsigned long )(key->lfsr17 ^ (key->lfsr17 >> 14));
#line 174
    key->lfsr17 = (unsigned int )((((unsigned long )(key->lfsr17 >> 8) ^ (lfsr17tmp << 9)) ^ (lfsr17tmp << 12)) ^ (lfsr17tmp << 15));
#line 178
    key->lfsr17 &= 131071U;
#line 180
    lfsr25tmp = (unsigned long )(((key->lfsr25 ^ (key->lfsr25 >> 3)) ^ (key->lfsr25 >> 4)) ^ (key->lfsr25 >> 12));
#line 184
    key->lfsr25 = (unsigned int )((unsigned long )(key->lfsr25 >> 8) ^ (lfsr25tmp << 17));
#line 185
    key->lfsr25 &= 33554431U;
#line 187
    lfsrsumtmp = (unsigned long )key->lfsrsum;
#line 190
    switch (key->mode) {
    case 0: 
    case 3: 
#line 193
    key->lfsrsum = 255U & ~ (key->lfsr17 >> 9);
#line 194
    key->lfsrsum += key->lfsr25 >> 17;
#line 195
    break;
    case 1: 
#line 197
    key->lfsrsum = key->lfsr17 >> 9;
#line 198
    key->lfsrsum += key->lfsr25 >> 17;
#line 199
    break;
    case 2: 
#line 201
    key->lfsrsum = key->lfsr17 >> 9;
#line 202
    key->lfsrsum += 255U & ~ (key->lfsr25 >> 17);
#line 203
    break;
    default: ;
#line 205
    return (1);
    }
#line 207
    key->lfsrsum = (unsigned int )((unsigned long )key->lfsrsum + (lfsrsumtmp >> 8));
#line 209
    if (key->encrypt) {
#line 210
      *(out + i) = sboxenc[((unsigned int )*(in + i) ^ key->lfsrsum) & 255U];
    } else {
#line 212
      *(out + i) = (unsigned char )(((unsigned int )sboxdec[*(in + i)] ^ key->lfsrsum) & 255U);
    }
#line 172
    i ++;
  }
#line 216
  return (0);
}
}
#line 219 "acss.c"
static void acss_seed(ACSS_KEY *key ) 
{ int i ;

  {
#line 225
  if (key->subkey_avilable) {
#line 226
    i = 0;
#line 226
    while (i < 5) {
#line 227
      key->seed[i] = reverse[(int )key->data[i] ^ (int )key->subkey[i]];
#line 226
      i ++;
    }
  } else {
#line 229
    i = 0;
#line 229
    while (i < 5) {
#line 230
      key->seed[i] = reverse[key->data[i]];
#line 229
      i ++;
    }
  }
#line 234
  key->lfsr17 = (unsigned int )(((int )key->seed[1] | ((int )key->seed[0] << 9)) | (1 << 8));
#line 237
  key->lfsr25 = (unsigned int )(((((int )key->seed[4] | ((int )key->seed[3] << 8)) | (((int )key->seed[2] & 31) << 16)) | (((int )key->seed[2] & 224) << 17)) | (1 << 21));
#line 243
  key->lfsrsum = 0U;
#line 244
  return;
}
}
#line 246 "acss.c"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) 
{ 

  {
#line 249
  memcpy((void * __restrict  )(key->data), (void const   * __restrict  )data, sizeof(key->data));
#line 250
  memset((void *)(key->subkey), 0, sizeof(key->subkey));
#line 252
  if (enc != -1) {
#line 253
    key->encrypt = enc;
  }
#line 254
  key->mode = mode;
#line 255
  key->subkey_avilable = 0;
#line 257
  acss_seed(key);
#line 258
  return;
}
}
#line 260 "acss.c"
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) 
{ 

  {
#line 263
  memcpy((void * __restrict  )(key->subkey), (void const   * __restrict  )subkey,
         sizeof(key->subkey));
#line 264
  key->subkey_avilable = 1;
#line 265
  acss_seed(key);
#line 266
  return;
}
}
#line 1 "authfd.o"
#pragma merger(0,"./authfd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 27
void buffer_clear(Buffer *buffer ) ;
#line 28
void buffer_free(Buffer *buffer ) ;
#line 30
u_int buffer_len(Buffer *buffer ) ;
#line 31
void *buffer_ptr(Buffer *buffer ) ;
#line 33
void buffer_append(Buffer *buffer , void const   *data , u_int len ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 51 "buffer.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) ;
#line 52
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) ;
#line 53
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 59
u_int buffer_get_int(Buffer *buffer ) ;
#line 60
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 65
int buffer_get_char(Buffer *buffer ) ;
#line 66
void buffer_put_char(Buffer *buffer , int value ) ;
#line 71
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 19 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 22
void xfree(void *ptr ) ;
#line 59 "key.h"
Key *key_new(int type ) ;
#line 75
Key *key_from_blob(u_char const   *blob , u_int blen ) ;
#line 76
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) ;
#line 77
char const   *key_ssh_name(Key const   *k ) ;
#line 69 "authfd.h"
int ssh_agent_present(void) ;
#line 70
int ssh_get_authentication_socket(void) ;
#line 71
void ssh_close_authentication_socket(int sock ) ;
#line 73
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 74
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 75
int ssh_get_num_identities(AuthenticationConnection *auth , int version___0 ) ;
#line 76
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version___0 ) ;
#line 77
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version___0 ) ;
#line 78
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 79
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) ;
#line 81
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 82
int ssh_remove_all_identities(AuthenticationConnection *auth , int version___0 ) ;
#line 83
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) ;
#line 84
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) ;
#line 87
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 91
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) ;
#line 70 "compat.h"
int datafellows ;
#line 58 "log.h"
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 61
void ( /* format attribute */  logit)(char const   *fmt  , ...) ;
#line 35 "atomicio.h"
size_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) ;
#line 70 "misc.h"
u_int32_t get_u32(void const   *vp ) ;
#line 76
void put_u32(void *vp , u_int32_t v ) ;
#line 67 "authfd.c"
static int agent_present  =    0;
#line 70
int decode_reply(int type ) ;
#line 77 "authfd.c"
int ssh_agent_present(void) 
{ int authfd ;

  {
#line 82
  if (agent_present) {
#line 83
    return (1);
  }
#line 84
  authfd = ssh_get_authentication_socket();
#line 84
  if (authfd == -1) {
#line 85
    return (0);
  } else {
#line 87
    ssh_close_authentication_socket(authfd);
#line 88
    return (1);
  }
}
}
#line 94 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 101
  tmp = getenv("SSH_AUTH_SOCK");
#line 101
  authsocket = (char const   *)tmp;
#line 102
  if (! authsocket) {
#line 103
    return (-1);
  }
#line 105
  sunaddr.sun_family = (unsigned short)1;
#line 106
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 108
  sock = socket(1, 1, 0);
#line 109
  if (sock < 0) {
#line 110
    return (-1);
  }
#line 113
  tmp___0 = fcntl(sock, 2, 1);
#line 113
  if (tmp___0 == -1) {
#line 114
    close(sock);
#line 115
    return (-1);
  }
#line 117
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 117
  if (tmp___1 < 0) {
#line 118
    close(sock);
#line 119
    return (-1);
  }
#line 121
  agent_present = 1;
#line 122
  return (sock);
}
}
#line 125 "authfd.c"
static int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ u_int l ;
  u_int len ;
  char buf___1[1024] ;
  size_t tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  u_int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 132
  len = buffer_len(request);
#line 133
  put_u32((void *)(buf___1), len);
#line 136
  tmp = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd, (void *)(buf___1),
                 4U);
#line 136
  if (tmp != 4U) {
#line 139
    error("Error writing to authentication socket.");
#line 140
    return (0);
  } else {
#line 136
    tmp___0 = buffer_len(request);
#line 136
    tmp___1 = buffer_ptr(request);
#line 136
    tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd,
                       tmp___1, tmp___0);
#line 136
    tmp___3 = buffer_len(request);
#line 136
    if (tmp___2 != tmp___3) {
#line 139
      error("Error writing to authentication socket.");
#line 140
      return (0);
    }
  }
#line 146
  tmp___4 = atomicio(& read, auth->fd, (void *)(buf___1), 4U);
#line 146
  if (tmp___4 != 4U) {
#line 147
    error("Error reading response length from authentication socket.");
#line 148
    return (0);
  }
#line 152
  len = get_u32((void const   *)(buf___1));
#line 153
  if (len > 262144U) {
#line 154
    fatal("Authentication response too long: %u", len);
  }
#line 157
  buffer_clear(reply);
#line 158
  while (len > 0U) {
#line 159
    l = len;
#line 160
    if (l > sizeof(buf___1)) {
#line 161
      l = sizeof(buf___1);
    }
#line 162
    tmp___5 = atomicio(& read, auth->fd, (void *)(buf___1), l);
#line 162
    if (tmp___5 != l) {
#line 163
      error("Error reading response from authentication socket.");
#line 164
      return (0);
    }
#line 166
    buffer_append(reply, (void const   *)(buf___1), l);
#line 167
    len -= l;
  }
#line 169
  return (1);
}
}
#line 178 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 181
  tmp = getenv("SSH_AUTH_SOCK");
#line 181
  if (tmp) {
#line 182
    close(sock);
  }
#line 183
  return;
}
}
#line 193 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 199
  sock = ssh_get_authentication_socket();
#line 205
  if (sock < 0) {
#line 206
    return ((AuthenticationConnection *)((void *)0));
  }
#line 208
  tmp = xmalloc(sizeof(*auth));
#line 208
  auth = (AuthenticationConnection *)tmp;
#line 209
  auth->fd = sock;
#line 210
  buffer_init(& auth->identities);
#line 211
  auth->howmany = 0;
#line 213
  return (auth);
}
}
#line 221 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 224
  buffer_free(& auth->identities);
#line 225
  close(auth->fd);
#line 226
  xfree((void *)auth);
#line 227
  return;
}
}
#line 230 "authfd.c"
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) 
{ int type ;
  Buffer msg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 236
  buffer_init(& msg);
#line 237
  if (lock) {
#line 237
    tmp = 22;
  } else {
#line 237
    tmp = 23;
  }
#line 237
  buffer_put_char(& msg, tmp);
#line 238
  buffer_put_cstring(& msg, password);
#line 240
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 240
  if (tmp___0 == 0) {
#line 241
    buffer_free(& msg);
#line 242
    return (0);
  }
#line 244
  type = buffer_get_char(& msg);
#line 245
  buffer_free(& msg);
#line 246
  tmp___1 = decode_reply(type);
#line 246
  return (tmp___1);
}
}
#line 253 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version___0 ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 256
  code1 = 0;
#line 256
  code2 = 0;
#line 259
  switch (version___0) {
  case 1: 
#line 261
  code1 = 1;
#line 262
  code2 = 2;
#line 263
  break;
  case 2: 
#line 265
  code1 = 11;
#line 266
  code2 = 12;
#line 267
  break;
  default: ;
#line 269
  return (0);
  }
#line 276
  buffer_init(& request);
#line 277
  buffer_put_char(& request, code1);
#line 279
  buffer_clear(& auth->identities);
#line 280
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 280
  if (tmp == 0) {
#line 281
    buffer_free(& request);
#line 282
    return (0);
  }
#line 284
  buffer_free(& request);
#line 287
  type = buffer_get_char(& auth->identities);
#line 288
  if (type == 5) {
#line 289
    return (0);
  } else {
#line 288
    if (type == 102) {
#line 289
      return (0);
    } else {
#line 288
      if (type == 30) {
#line 289
        return (0);
      } else {
#line 290
        if (type != code2) {
#line 291
          fatal("Bad authentication reply message type: %d", type);
        }
      }
    }
  }
#line 295
  tmp___0 = buffer_get_int(& auth->identities);
#line 295
  auth->howmany = (int )tmp___0;
#line 296
  if ((unsigned int )auth->howmany > 1024U) {
#line 297
    fatal("Too many identities in authentication reply: %d", auth->howmany);
  }
#line 300
  return (auth->howmany);
}
}
#line 303 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version___0 ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 307
  tmp___0 = ssh_get_num_identities(auth, version___0);
#line 307
  if (tmp___0 > 0) {
#line 308
    tmp = ssh_get_next_identity(auth, comment, version___0);
#line 308
    return (tmp);
  }
#line 309
  return ((Key *)((void *)0));
}
}
#line 312 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version___0 ) 
{ int keybits ;
  u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 319
  key = (Key *)((void *)0);
#line 322
  if (auth->howmany <= 0) {
#line 323
    return ((Key *)((void *)0));
  }
#line 329
  switch (version___0) {
  case 1: 
#line 331
  key = key_new(0);
#line 332
  bits = buffer_get_int(& auth->identities);
#line 333
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 334
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 335
  tmp = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 335
  *comment = (char *)tmp;
#line 336
  keybits = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 337
  if (keybits < 0) {
#line 338
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 338
    logit("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0,
          bits);
  } else {
#line 337
    if (bits != (unsigned int )keybits) {
#line 338
      tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 338
      logit("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0,
            bits);
    }
  }
#line 340
  break;
  case 2: 
#line 342
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 342
  blob = (u_char *)tmp___1;
#line 343
  tmp___2 = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 343
  *comment = (char *)tmp___2;
#line 344
  key = key_from_blob((u_char const   *)blob, blen);
#line 345
  xfree((void *)blob);
#line 346
  break;
  default: ;
#line 348
  return ((Key *)((void *)0));
  }
#line 351
  (auth->howmany) --;
#line 352
  return (key);
}
}
#line 363 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 371
  success = 0;
#line 375
  if (key->type != 0) {
#line 376
    return (0);
  }
#line 377
  if (response_type == 0U) {
#line 378
    logit("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 379
    return (0);
  }
#line 381
  buffer_init(& buffer);
#line 382
  buffer_put_char(& buffer, 3);
#line 383
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 383
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 384
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->e);
#line 385
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->n);
#line 386
  buffer_put_bignum(& buffer, (BIGNUM const   *)challenge);
#line 387
  buffer_append(& buffer, (void const   *)session_id___0, 16U);
#line 388
  buffer_put_int(& buffer, response_type);
#line 390
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 390
  if (tmp___0 == 0) {
#line 391
    buffer_free(& buffer);
#line 392
    return (0);
  }
#line 394
  type = buffer_get_char(& buffer);
#line 396
  if (type == 5) {
#line 397
    logit("Agent admitted failure to authenticate using the key.");
  } else {
#line 396
    if (type == 102) {
#line 397
      logit("Agent admitted failure to authenticate using the key.");
    } else {
#line 396
      if (type == 30) {
#line 397
        logit("Agent admitted failure to authenticate using the key.");
      } else {
#line 398
        if (type != 4) {
#line 399
          fatal("Bad authentication response: %d", type);
        } else {
#line 401
          success = 1;
#line 406
          i = 0;
#line 406
          while (i < 16) {
#line 407
            tmp___1 = buffer_get_char(& buffer);
#line 407
            *(response + i) = (unsigned char )tmp___1;
#line 406
            i ++;
          }
        }
      }
    }
  }
#line 409
  buffer_free(& buffer);
#line 410
  return (success);
}
}
#line 414 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret___0 ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 424
  flags = 0;
#line 425
  ret___0 = -1;
#line 427
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 427
  if (tmp == 0) {
#line 428
    return (-1);
  }
#line 430
  if (datafellows & 1) {
#line 431
    flags = 1;
  }
#line 433
  buffer_init(& msg);
#line 434
  buffer_put_char(& msg, 13);
#line 435
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 436
  buffer_put_string(& msg, (void const   *)data, datalen);
#line 437
  buffer_put_int(& msg, (unsigned int )flags);
#line 438
  xfree((void *)blob);
#line 440
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 440
  if (tmp___0 == 0) {
#line 441
    buffer_free(& msg);
#line 442
    return (-1);
  }
#line 444
  type = buffer_get_char(& msg);
#line 445
  if (type == 5) {
#line 446
    logit("Agent admitted failure to sign using the key.");
  } else {
#line 445
    if (type == 102) {
#line 446
      logit("Agent admitted failure to sign using the key.");
    } else {
#line 445
      if (type == 30) {
#line 446
        logit("Agent admitted failure to sign using the key.");
      } else {
#line 447
        if (type != 14) {
#line 448
          fatal("Bad authentication response: %d", type);
        } else {
#line 450
          ret___0 = 0;
#line 451
          tmp___1 = buffer_get_string(& msg, lenp);
#line 451
          *sigp = (u_char *)tmp___1;
        }
      }
    }
  }
#line 453
  buffer_free(& msg);
#line 454
  return (ret___0);
}
}
#line 459 "authfd.c"
static void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;

  {
#line 462
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 462
  buffer_put_int(b, (unsigned int )tmp);
#line 463
  buffer_put_bignum(b, (BIGNUM const   *)key->n);
#line 464
  buffer_put_bignum(b, (BIGNUM const   *)key->e);
#line 465
  buffer_put_bignum(b, (BIGNUM const   *)key->d);
#line 467
  buffer_put_bignum(b, (BIGNUM const   *)key->iqmp);
#line 468
  buffer_put_bignum(b, (BIGNUM const   *)key->q);
#line 469
  buffer_put_bignum(b, (BIGNUM const   *)key->p);
#line 470
  buffer_put_cstring(b, comment);
#line 471
  return;
}
}
#line 473 "authfd.c"
static void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char const   *tmp ;

  {
#line 476
  tmp = key_ssh_name((Key const   *)key);
#line 476
  buffer_put_cstring(b, tmp);
#line 477
  switch (key->type) {
  case 1: 
#line 479
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->n);
#line 480
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->e);
#line 481
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->d);
#line 482
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->iqmp);
#line 483
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->p);
#line 484
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->q);
#line 485
  break;
  case 2: 
#line 487
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->p);
#line 488
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->q);
#line 489
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->g);
#line 490
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 491
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->priv_key);
#line 492
  break;
  }
#line 494
  buffer_put_cstring(b, comment);
#line 495
  return;
}
}
#line 502 "authfd.c"
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 507
  if (life) {
#line 507
    tmp = 1;
  } else {
#line 507
    if (confirm) {
#line 507
      tmp = 1;
    } else {
#line 507
      tmp = 0;
    }
  }
#line 507
  constrained = tmp;
#line 509
  buffer_init(& msg);
#line 511
  switch (key->type) {
  case 0: 
#line 513
  if (constrained) {
#line 513
    type = 24;
  } else {
#line 513
    type = 7;
  }
#line 516
  buffer_put_char(& msg, type);
#line 517
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 518
  break;
  case 1: 
  case 2: 
#line 521
  if (constrained) {
#line 521
    type = 25;
  } else {
#line 521
    type = 17;
  }
#line 524
  buffer_put_char(& msg, type);
#line 525
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 526
  break;
  default: 
#line 528
  buffer_free(& msg);
#line 529
  return (0);
  }
#line 531
  if (constrained) {
#line 532
    if (life != 0U) {
#line 533
      buffer_put_char(& msg, 1);
#line 534
      buffer_put_int(& msg, life);
    }
#line 536
    if (confirm != 0U) {
#line 537
      buffer_put_char(& msg, 2);
    }
  }
#line 539
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 539
  if (tmp___0 == 0) {
#line 540
    buffer_free(& msg);
#line 541
    return (0);
  }
#line 543
  type = buffer_get_char(& msg);
#line 544
  buffer_free(& msg);
#line 545
  tmp___1 = decode_reply(type);
#line 545
  return (tmp___1);
}
}
#line 548 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ int tmp ;

  {
#line 551
  tmp = ssh_add_identity_constrained(auth, key, comment, 0U, 0U);
#line 551
  return (tmp);
}
}
#line 559 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 567
  buffer_init(& msg);
#line 569
  if (key->type == 0) {
#line 570
    buffer_put_char(& msg, 8);
#line 571
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 571
    buffer_put_int(& msg, (unsigned int )tmp);
#line 572
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->e);
#line 573
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->n);
  } else {
#line 574
    if (key->type == 2) {
#line 575
      key_to_blob((Key const   *)key, & blob, & blen);
#line 576
      buffer_put_char(& msg, 18);
#line 577
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 578
      xfree((void *)blob);
    } else {
#line 574
      if (key->type == 1) {
#line 575
        key_to_blob((Key const   *)key, & blob, & blen);
#line 576
        buffer_put_char(& msg, 18);
#line 577
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 578
        xfree((void *)blob);
      } else {
#line 580
        buffer_free(& msg);
#line 581
        return (0);
      }
    }
  }
#line 583
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 583
  if (tmp___0 == 0) {
#line 584
    buffer_free(& msg);
#line 585
    return (0);
  }
#line 587
  type = buffer_get_char(& msg);
#line 588
  buffer_free(& msg);
#line 589
  tmp___1 = decode_reply(type);
#line 589
  return (tmp___1);
}
}
#line 592 "authfd.c"
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 597
  if (life) {
#line 597
    tmp = 1;
  } else {
#line 597
    if (confirm) {
#line 597
      tmp = 1;
    } else {
#line 597
      tmp = 0;
    }
  }
#line 597
  constrained = tmp;
#line 599
  if (add) {
#line 600
    if (constrained) {
#line 600
      type = 26;
    } else {
#line 600
      type = 20;
    }
  } else {
#line 604
    type = 21;
  }
#line 606
  buffer_init(& msg);
#line 607
  buffer_put_char(& msg, type);
#line 608
  buffer_put_cstring(& msg, reader_id);
#line 609
  buffer_put_cstring(& msg, pin);
#line 611
  if (constrained) {
#line 612
    if (life != 0U) {
#line 613
      buffer_put_char(& msg, 1);
#line 614
      buffer_put_int(& msg, life);
    }
#line 616
    if (confirm != 0U) {
#line 617
      buffer_put_char(& msg, 2);
    }
  }
#line 620
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 620
  if (tmp___0 == 0) {
#line 621
    buffer_free(& msg);
#line 622
    return (0);
  }
#line 624
  type = buffer_get_char(& msg);
#line 625
  buffer_free(& msg);
#line 626
  tmp___1 = decode_reply(type);
#line 626
  return (tmp___1);
}
}
#line 634 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version___0 ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 639
  if (version___0 == 1) {
#line 639
    tmp = 9;
  } else {
#line 639
    tmp = 19;
  }
#line 639
  code = tmp;
#line 643
  buffer_init(& msg);
#line 644
  buffer_put_char(& msg, code);
#line 646
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 646
  if (tmp___0 == 0) {
#line 647
    buffer_free(& msg);
#line 648
    return (0);
  }
#line 650
  type = buffer_get_char(& msg);
#line 651
  buffer_free(& msg);
#line 652
  tmp___1 = decode_reply(type);
#line 652
  return (tmp___1);
}
}
#line 655 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 658
  switch (type) {
  case 5: 
  case 102: 
  case 30: 
#line 662
  logit("SSH_AGENT_FAILURE");
#line 663
  return (0);
  case 6: 
#line 665
  return (1);
  default: 
#line 667
  fatal("Bad response from authentication agent: %d", type);
  }
#line 670
  return (0);
}
}
#line 1 "authfile.o"
#pragma merger(0,"./authfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 391
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64") __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 259
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 34 "buffer.h"
void *buffer_append_space(Buffer *buffer , u_int len ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 298 "/usr/include/openssl/rsa.h"
extern int RSA_blinding_on(RSA *rsa , BN_CTX *ctx ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 304 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 73 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 79
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 80
void cipher_cleanup(CipherContext *cc ) ;
#line 81
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int do_encrypt ) ;
#line 60 "key.h"
Key *key_new_private(int type ) ;
#line 61
void key_free(Key *k ) ;
#line 66
char const   *key_type(Key const   *k ) ;
#line 68
int key_read(Key *ret___0 , char **cpp ) ;
#line 65 "log.h"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 18 "authfile.h"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) ;
#line 19
Key *key_load_public(char const   *filename , char **commentp ) ;
#line 20
Key *key_load_public_type(int type , char const   *filename , char **commentp ) ;
#line 21
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) ;
#line 22
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp , int *perm_ok ) ;
#line 23
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) ;
#line 24
int key_perm_ok(int fd , char const   *filename ) ;
#line 24 "rsa.h"
void rsa_generate_additional_parameters(RSA *rsa ) ;
#line 91 "misc.h"
int read_keyfile_line(FILE *f , char const   *filename , char *buf___1 , size_t bufsz ,
                      u_long *lineno ) ;
#line 70 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 70 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 80 "authfile.c"
static int key_save_private_rsa1(Key *key , char const   *filename , char const   *passphrase ,
                                 char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  u_char buf___1[100] ;
  u_char *cp ;
  int fd ;
  int i ;
  int cipher_num ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rnd ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  u_int tmp___19 ;
  int tmp___20 ;
  u_int tmp___21 ;
  void *tmp___22 ;
  u_int tmp___23 ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  u_int tmp___29 ;
  void *tmp___30 ;
  size_t tmp___31 ;
  u_int tmp___32 ;

  {
#line 95
  if (0) {
#line 95
    __s1_len___0 = strlen(passphrase);
#line 95
    __s2_len___0 = strlen("");
#line 95
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___2;
    } else {
#line 95
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 95
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 95
          tmp___18 = 1;
        } else {
#line 95
          if (__s2_len___0 >= 4U) {
#line 95
            tmp___18 = 1;
          } else {
#line 95
            tmp___18 = 0;
          }
        }
      } else {
#line 95
        tmp___18 = 0;
      }
    }
#line 95
    if (tmp___18) {
#line 95
      tmp___14 = __builtin_strcmp(passphrase, "");
    } else {
#line 95
      tmp___17 = __builtin_strcmp(passphrase, "");
#line 95
      tmp___14 = tmp___17;
    }
  } else {
#line 95
    tmp___17 = __builtin_strcmp(passphrase, "");
#line 95
    tmp___14 = tmp___17;
  }
#line 95
  if (tmp___14 == 0) {
#line 95
    cipher_num = 0;
  } else {
#line 95
    cipher_num = 3;
  }
#line 97
  cipher = cipher_by_number(cipher_num);
#line 97
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 98
    fatal("save_private_key_rsa: bad cipher");
  }
#line 101
  buffer_init(& buffer);
#line 104
  rnd = arc4random();
#line 105
  buf___1[0] = (unsigned char )(rnd & 255U);
#line 106
  buf___1[1] = (unsigned char )((rnd >> 8) & 255U);
#line 107
  buf___1[2] = buf___1[0];
#line 108
  buf___1[3] = buf___1[1];
#line 109
  buffer_append(& buffer, (void const   *)(buf___1), 4U);
#line 116
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->d);
#line 117
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->iqmp);
#line 118
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->q);
#line 119
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->p);
#line 122
  while (1) {
#line 122
    tmp___19 = buffer_len(& buffer);
#line 122
    if (! (tmp___19 % 8U != 0U)) {
#line 122
      break;
    }
#line 123
    buffer_put_char(& buffer, 0);
  }
#line 126
  buffer_init(& encrypted);
#line 129
  i = 0;
#line 129
  while (authfile_id_string[i]) {
#line 130
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 129
    i ++;
  }
#line 131
  buffer_put_char(& encrypted, 0);
#line 134
  buffer_put_char(& encrypted, cipher_num);
#line 135
  buffer_put_int(& encrypted, 0U);
#line 138
  tmp___20 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 138
  buffer_put_int(& encrypted, (unsigned int )tmp___20);
#line 139
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->n);
#line 140
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->e);
#line 141
  buffer_put_cstring(& encrypted, comment);
#line 144
  tmp___21 = buffer_len(& buffer);
#line 144
  tmp___22 = buffer_append_space(& encrypted, tmp___21);
#line 144
  cp = (u_char *)tmp___22;
#line 146
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 1);
#line 148
  tmp___23 = buffer_len(& buffer);
#line 148
  tmp___24 = buffer_ptr(& buffer);
#line 148
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___24, tmp___23);
#line 150
  cipher_cleanup(& ciphercontext);
#line 151
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 154
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 155
  buffer_free(& buffer);
#line 157
  fd = open(filename, 577, 384);
#line 158
  if (fd < 0) {
#line 159
    tmp___25 = __errno_location();
#line 159
    tmp___26 = strerror(*tmp___25);
#line 159
    error("open %s failed: %s.", filename, tmp___26);
#line 160
    buffer_free(& encrypted);
#line 161
    return (0);
  }
#line 163
  tmp___29 = buffer_len(& encrypted);
#line 163
  tmp___30 = buffer_ptr(& encrypted);
#line 163
  tmp___31 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, tmp___30,
                      tmp___29);
#line 163
  tmp___32 = buffer_len(& encrypted);
#line 163
  if (tmp___31 != tmp___32) {
#line 165
    tmp___27 = __errno_location();
#line 165
    tmp___28 = strerror(*tmp___27);
#line 165
    error("write to key file %s failed: %s", filename, tmp___28);
#line 167
    buffer_free(& encrypted);
#line 168
    close(fd);
#line 169
    unlink(filename);
#line 170
    return (0);
  }
#line 172
  close(fd);
#line 173
  buffer_free(& encrypted);
#line 174
  return (1);
}
}
#line 178 "authfile.c"
static int key_save_private_pem(Key *key , char const   *filename , char const   *_passphrase ,
                                char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  u_char *passphrase ;
  u_char *tmp___0 ;
  EVP_CIPHER const   *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 184
  success = 0;
#line 185
  tmp = strlen(_passphrase);
#line 185
  len = (int )tmp;
#line 186
  if (len > 0) {
#line 186
    tmp___0 = (u_char *)_passphrase;
  } else {
#line 186
    tmp___0 = (u_char *)((void *)0);
  }
#line 186
  passphrase = tmp___0;
#line 187
  if (len > 0) {
#line 187
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 187
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 187
  cipher = tmp___2;
#line 189
  if (len > 0) {
#line 189
    if (len <= 4) {
#line 190
      error("passphrase too short: have %d bytes, need > 4", len);
#line 191
      return (0);
    }
  }
#line 193
  fd = open(filename, 577, 384);
#line 194
  if (fd < 0) {
#line 195
    tmp___3 = __errno_location();
#line 195
    tmp___4 = strerror(*tmp___3);
#line 195
    error("open %s failed: %s.", filename, tmp___4);
#line 196
    return (0);
  }
#line 198
  fp = fdopen(fd, "w");
#line 199
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 200
    tmp___5 = __errno_location();
#line 200
    tmp___6 = strerror(*tmp___5);
#line 200
    error("fdopen %s failed: %s.", filename, tmp___6);
#line 201
    close(fd);
#line 202
    return (0);
  }
#line 204
  switch (key->type) {
  case 2: 
#line 206
  success = PEM_write_DSAPrivateKey(fp, key->dsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 208
  break;
  case 1: 
#line 210
  success = PEM_write_RSAPrivateKey(fp, key->rsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 212
  break;
  }
#line 214
  fclose(fp);
#line 215
  return (success);
}
}
#line 218 "authfile.c"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 222
  switch (key->type) {
  case 0: 
#line 224
  tmp = key_save_private_rsa1(key, filename, passphrase, comment);
#line 224
  return (tmp);
  case 2: 
  case 1: 
#line 228
  tmp___0 = key_save_private_pem(key, filename, passphrase, comment);
#line 228
  return (tmp___0);
  default: ;
#line 231
  break;
  }
#line 233
  error("key_save_private: cannot save key type %d", key->type);
#line 234
  return (0);
}
}
#line 243 "authfile.c"
static Key *key_load_public_rsa1(int fd , char const   *filename , char **commentp ) 
{ Buffer buffer ;
  Key *pub ;
  struct stat st ;
  char *cp ;
  u_int i ;
  size_t len ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 253
  tmp___1 = fstat(fd, & st);
#line 253
  if (tmp___1 < 0) {
#line 254
    tmp = __errno_location();
#line 254
    tmp___0 = strerror(*tmp);
#line 254
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 256
    return ((Key *)((void *)0));
  }
#line 258
  if (st.st_size > 1048576LL) {
#line 259
    error("key file %.200s too large", filename);
#line 260
    return ((Key *)((void *)0));
  }
#line 262
  len = (unsigned int )st.st_size;
#line 264
  buffer_init(& buffer);
#line 265
  tmp___2 = buffer_append_space(& buffer, len);
#line 265
  cp = (char *)tmp___2;
#line 267
  tmp___5 = atomicio(& read, fd, (void *)cp, len);
#line 267
  if (tmp___5 != len) {
#line 268
    tmp___3 = __errno_location();
#line 268
    tmp___4 = strerror(*tmp___3);
#line 268
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 270
    buffer_free(& buffer);
#line 271
    return ((Key *)((void *)0));
  }
#line 275
  if (len < sizeof(authfile_id_string)) {
#line 276
    debug3("Not a RSA1 key file %.200s.", filename);
#line 277
    buffer_free(& buffer);
#line 278
    return ((Key *)((void *)0));
  }
#line 284
  i = 0U;
#line 284
  while (i < sizeof(authfile_id_string)) {
#line 285
    tmp___6 = buffer_get_char(& buffer);
#line 285
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 286
      debug3("Not a RSA1 key file %.200s.", filename);
#line 287
      buffer_free(& buffer);
#line 288
      return ((Key *)((void *)0));
    }
#line 284
    i ++;
  }
#line 291
  buffer_get_char(& buffer);
#line 292
  buffer_get_int(& buffer);
#line 295
  buffer_get_int(& buffer);
#line 296
  pub = key_new(0);
#line 297
  buffer_get_bignum(& buffer, (pub->rsa)->n);
#line 298
  buffer_get_bignum(& buffer, (pub->rsa)->e);
#line 299
  if (commentp) {
#line 300
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 300
    *commentp = (char *)tmp___7;
  }
#line 303
  buffer_free(& buffer);
#line 304
  return (pub);
}
}
#line 308 "authfile.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ Key *pub ;
  int fd ;

  {
#line 314
  if (type == 0) {
#line 315
    fd = open(filename, 0);
#line 316
    if (fd < 0) {
#line 317
      return ((Key *)((void *)0));
    }
#line 318
    pub = key_load_public_rsa1(fd, filename, commentp);
#line 319
    close(fd);
#line 320
    return (pub);
  }
#line 322
  return ((Key *)((void *)0));
}
}
#line 332 "authfile.c"
static Key *key_load_private_rsa1(int fd , char const   *filename , char const   *passphrase ,
                                  char **commentp ) 
{ u_int i ;
  int check1 ;
  int check2 ;
  int cipher_type ;
  size_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  u_char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  Key *prv ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 343
  prv = (Key *)((void *)0);
#line 346
  tmp___1 = fstat(fd, & st);
#line 346
  if (tmp___1 < 0) {
#line 347
    tmp = __errno_location();
#line 347
    tmp___0 = strerror(*tmp);
#line 347
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 349
    close(fd);
#line 350
    return ((Key *)((void *)0));
  }
#line 352
  if (st.st_size > 1048576LL) {
#line 353
    error("key file %.200s too large", filename);
#line 354
    close(fd);
#line 355
    return ((Key *)((void *)0));
  }
#line 357
  len = (unsigned int )st.st_size;
#line 359
  buffer_init(& buffer);
#line 360
  tmp___2 = buffer_append_space(& buffer, len);
#line 360
  cp = (u_char *)tmp___2;
#line 362
  tmp___5 = atomicio(& read, fd, (void *)cp, len);
#line 362
  if (tmp___5 != len) {
#line 363
    tmp___3 = __errno_location();
#line 363
    tmp___4 = strerror(*tmp___3);
#line 363
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 365
    buffer_free(& buffer);
#line 366
    close(fd);
#line 367
    return ((Key *)((void *)0));
  }
#line 371
  if (len < sizeof(authfile_id_string)) {
#line 372
    debug3("Not a RSA1 key file %.200s.", filename);
#line 373
    buffer_free(& buffer);
#line 374
    close(fd);
#line 375
    return ((Key *)((void *)0));
  }
#line 381
  i = 0U;
#line 381
  while (i < sizeof(authfile_id_string)) {
#line 382
    tmp___6 = buffer_get_char(& buffer);
#line 382
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 383
      debug3("Not a RSA1 key file %.200s.", filename);
#line 384
      buffer_free(& buffer);
#line 385
      close(fd);
#line 386
      return ((Key *)((void *)0));
    }
#line 381
    i ++;
  }
#line 390
  cipher_type = buffer_get_char(& buffer);
#line 391
  buffer_get_int(& buffer);
#line 394
  buffer_get_int(& buffer);
#line 395
  prv = key_new_private(0);
#line 397
  buffer_get_bignum(& buffer, (prv->rsa)->n);
#line 398
  buffer_get_bignum(& buffer, (prv->rsa)->e);
#line 399
  if (commentp) {
#line 400
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 400
    *commentp = (char *)tmp___7;
  } else {
#line 402
    tmp___8 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 402
    xfree(tmp___8);
  }
#line 405
  cipher = cipher_by_number(cipher_type);
#line 406
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 407
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type, filename);
#line 409
    buffer_free(& buffer);
    goto fail;
  }
#line 413
  buffer_init(& decrypted);
#line 414
  tmp___9 = buffer_len(& buffer);
#line 414
  tmp___10 = buffer_append_space(& decrypted, tmp___9);
#line 414
  cp = (u_char *)tmp___10;
#line 417
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 0);
#line 419
  tmp___11 = buffer_len(& buffer);
#line 419
  tmp___12 = buffer_ptr(& buffer);
#line 419
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___12, tmp___11);
#line 421
  cipher_cleanup(& ciphercontext);
#line 422
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 423
  buffer_free(& buffer);
#line 425
  check1 = buffer_get_char(& decrypted);
#line 426
  check2 = buffer_get_char(& decrypted);
#line 427
  tmp___23 = buffer_get_char(& decrypted);
#line 427
  if (check1 != tmp___23) {
    goto _L___1;
  } else {
#line 427
    tmp___24 = buffer_get_char(& decrypted);
#line 427
    if (check2 != tmp___24) {
      _L___1: /* CIL Label */ 
#line 429
      if (0) {
#line 429
        __s1_len = strlen(passphrase);
#line 429
        __s2_len = strlen("");
#line 429
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 429
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 429
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 429
              tmp___22 = 1;
            } else {
#line 429
              if (__s2_len >= 4U) {
#line 429
                tmp___22 = 1;
              } else {
#line 429
                tmp___22 = 0;
              }
            }
          } else {
#line 429
            tmp___22 = 0;
          }
        }
#line 429
        if (tmp___22) {
#line 429
          tmp___18 = __builtin_strcmp(passphrase, "");
        } else {
#line 429
          tmp___21 = __builtin_strcmp(passphrase, "");
#line 429
          tmp___18 = tmp___21;
        }
      } else {
#line 429
        tmp___21 = __builtin_strcmp(passphrase, "");
#line 429
        tmp___18 = tmp___21;
      }
#line 429
      if (tmp___18 != 0) {
#line 430
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 433
      buffer_free(& decrypted);
      goto fail;
    }
  }
#line 437
  buffer_get_bignum(& decrypted, (prv->rsa)->d);
#line 438
  buffer_get_bignum(& decrypted, (prv->rsa)->iqmp);
#line 440
  buffer_get_bignum(& decrypted, (prv->rsa)->q);
#line 441
  buffer_get_bignum(& decrypted, (prv->rsa)->p);
#line 444
  rsa_generate_additional_parameters(prv->rsa);
#line 446
  buffer_free(& decrypted);
#line 449
  tmp___25 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 449
  if (tmp___25 != 1) {
#line 450
    error("key_load_private_rsa1: RSA_blinding_on failed");
    goto fail;
  }
#line 453
  close(fd);
#line 454
  return (prv);
  fail: 
#line 457
  if (commentp) {
#line 458
    xfree((void *)*commentp);
  }
#line 459
  close(fd);
#line 460
  key_free(prv);
#line 461
  return ((Key *)((void *)0));
}
}
#line 464 "authfile.c"
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) 
{ FILE *fp ;
  EVP_PKEY *pk ;
  Key *prv ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;

  {
#line 469
  pk = (EVP_PKEY *)((void *)0);
#line 470
  prv = (Key *)((void *)0);
#line 471
  name = (char *)"<no key>";
#line 473
  fp = fdopen(fd, "r");
#line 474
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 475
    tmp = __errno_location();
#line 475
    tmp___0 = strerror(*tmp);
#line 475
    error("fdopen failed: %s", tmp___0);
#line 476
    close(fd);
#line 477
    return ((Key *)((void *)0));
  }
#line 479
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 480
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 481
    debug("PEM_read_PrivateKey failed");
#line 482
    ERR_get_error();
  } else {
#line 483
    if (pk->type == 6) {
#line 483
      if (type == 3) {
        goto _L___0;
      } else {
#line 483
        if (type == 1) {
          _L___0: /* CIL Label */ 
#line 485
          prv = key_new(3);
#line 486
          prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 487
          prv->type = 1;
#line 488
          name = (char *)"rsa w/o comment";
#line 492
          tmp___1 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 492
          if (tmp___1 != 1) {
#line 493
            error("key_load_private_pem: RSA_blinding_on failed");
#line 494
            key_free(prv);
#line 495
            prv = (Key *)((void *)0);
          }
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 497
      if (pk->type == 116) {
#line 497
        if (type == 3) {
#line 499
          prv = key_new(3);
#line 500
          prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 501
          prv->type = 2;
#line 502
          name = (char *)"dsa w/o comment";
        } else {
#line 497
          if (type == 2) {
#line 499
            prv = key_new(3);
#line 500
            prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 501
            prv->type = 2;
#line 502
            name = (char *)"dsa w/o comment";
          } else {
#line 507
            error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d",
                  pk->save_type);
          }
        }
      } else {
#line 507
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 510
  fclose(fp);
#line 511
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 512
    EVP_PKEY_free(pk);
  }
#line 513
  if ((unsigned int )prv != (unsigned int )((void *)0)) {
#line 513
    if (commentp) {
#line 514
      *commentp = xstrdup((char const   *)name);
    }
  }
#line 515
  if (prv) {
#line 515
    tmp___3 = key_type((Key const   *)prv);
  } else {
#line 515
    tmp___3 = "<unknown>";
  }
#line 515
  debug("read PEM private key done: type %s", tmp___3);
#line 517
  return (prv);
}
}
#line 520 "authfile.c"
int key_perm_ok(int fd , char const   *filename ) 
{ struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 525
  tmp = fstat(fd, & st);
#line 525
  if (tmp < 0) {
#line 526
    return (0);
  }
#line 535
  tmp___0 = getuid();
#line 535
  if (st.st_uid == tmp___0) {
#line 535
    if ((st.st_mode & 63U) != 0U) {
#line 536
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 537
      error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 538
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 539
      error("Permissions 0%3.3o for \'%s\' are too open.", st.st_mode & 511U, filename);
#line 541
      error("It is recommended that your private key files are NOT accessible by others.");
#line 542
      error("This private key will be ignored.");
#line 543
      return (0);
    }
  }
#line 545
  return (1);
}
}
#line 548 "authfile.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp , int *perm_ok ) 
{ int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 554
  fd = open(filename, 0);
#line 555
  if (fd < 0) {
#line 556
    return ((Key *)((void *)0));
  }
#line 557
  tmp = key_perm_ok(fd, filename);
#line 557
  if (! tmp) {
#line 558
    if ((unsigned int )perm_ok != (unsigned int )((void *)0)) {
#line 559
      *perm_ok = 0;
    }
#line 560
    error("bad permissions: ignore key: %s", filename);
#line 561
    close(fd);
#line 562
    return ((Key *)((void *)0));
  }
#line 564
  if ((unsigned int )perm_ok != (unsigned int )((void *)0)) {
#line 565
    *perm_ok = 1;
  }
#line 566
  switch (type) {
  case 0: 
#line 568
  tmp___0 = key_load_private_rsa1(fd, filename, passphrase, commentp);
#line 568
  return (tmp___0);
  case 2: 
  case 1: 
  case 3: 
#line 574
  tmp___1 = key_load_private_pem(fd, type, passphrase, commentp);
#line 574
  return (tmp___1);
  default: 
#line 577
  close(fd);
#line 578
  break;
  }
#line 580
  return ((Key *)((void *)0));
}
}
#line 583 "authfile.c"
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) 
{ Key *pub ;
  Key *prv ;
  int fd ;
  int tmp ;

  {
#line 590
  fd = open(filename, 0);
#line 591
  if (fd < 0) {
#line 592
    return ((Key *)((void *)0));
  }
#line 593
  tmp = key_perm_ok(fd, filename);
#line 593
  if (! tmp) {
#line 594
    error("bad permissions: ignore key: %s", filename);
#line 595
    close(fd);
#line 596
    return ((Key *)((void *)0));
  }
#line 598
  pub = key_load_public_rsa1(fd, filename, commentp);
#line 599
  lseek(fd, 0LL, 0);
#line 600
  if ((unsigned int )pub == (unsigned int )((void *)0)) {
#line 602
    prv = key_load_private_pem(fd, 3, passphrase, (char **)((void *)0));
#line 604
    if (commentp) {
#line 604
      if (prv) {
#line 605
        *commentp = xstrdup(filename);
      }
    }
  } else {
#line 608
    key_free(pub);
#line 610
    prv = key_load_private_rsa1(fd, filename, passphrase, (char **)((void *)0));
  }
#line 612
  return (prv);
}
}
#line 615 "authfile.c"
static int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ FILE *f ;
  char line[8192] ;
  char *cp ;
  u_long linenum ;
  int tmp ;
  int tmp___0 ;

  {
#line 621
  linenum = (u_long )0;
#line 623
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 624
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 625
    while (1) {
#line 625
      tmp___0 = read_keyfile_line(f, filename, line, sizeof(line), & linenum);
#line 625
      if (! (tmp___0 != -1)) {
#line 625
        break;
      }
#line 627
      cp = line;
#line 628
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 632
      continue;
      }
#line 635
      while (1) {
#line 635
        if (*cp) {
#line 635
          if (! ((int )*cp == 32)) {
#line 635
            if (! ((int )*cp == 9)) {
#line 635
              break;
            }
          }
        } else {
#line 635
          break;
        }
#line 635
        cp ++;
      }
#line 637
      if (*cp) {
#line 638
        tmp = key_read(k, & cp);
#line 638
        if (tmp == 1) {
#line 639
          if (commentp) {
#line 640
            *commentp = xstrdup(filename);
          }
#line 641
          fclose(f);
#line 642
          return (1);
        }
      }
    }
#line 646
    fclose(f);
  }
#line 648
  return (0);
}
}
#line 652 "authfile.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ Key *pub ;
  char file___0[4096] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 659
  pub = key_load_public_type(0, filename, commentp);
#line 660
  if ((unsigned int )pub != (unsigned int )((void *)0)) {
#line 661
    return (pub);
  }
#line 664
  pub = key_new(0);
#line 665
  tmp = key_try_load_public(pub, filename, commentp);
#line 665
  if (tmp == 1) {
#line 666
    return (pub);
  }
#line 667
  key_free(pub);
#line 670
  pub = key_new(3);
#line 671
  tmp___0 = key_try_load_public(pub, filename, commentp);
#line 671
  if (tmp___0 == 1) {
#line 672
    return (pub);
  }
#line 673
  tmp___1 = strlcpy(file___0, filename, sizeof(file___0));
#line 673
  if (tmp___1 < sizeof(file___0)) {
#line 673
    tmp___2 = strlcat(file___0, ".pub", sizeof(file___0));
#line 673
    if (tmp___2 < sizeof(file___0)) {
#line 673
      tmp___3 = key_try_load_public(pub, (char const   *)(file___0), commentp);
#line 673
      if (tmp___3 == 1) {
#line 676
        return (pub);
      }
    }
  }
#line 677
  key_free(pub);
#line 678
  return ((Key *)((void *)0));
}
}
#line 1 "bufaux.o"
#pragma merger(0,"./bufaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 40 "buffer.h"
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 45
int buffer_get_ret(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 56
u_short buffer_get_short(Buffer *buffer ) ;
#line 57
void buffer_put_short(Buffer *buffer , u_short value ) ;
#line 62
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 63
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 69
void *buffer_get_string_ptr(Buffer *buffer , u_int *length_ptr ) ;
#line 80
int buffer_get_short_ret(u_short *ret___0 , Buffer *buffer ) ;
#line 81
int buffer_get_int_ret(u_int *ret___0 , Buffer *buffer ) ;
#line 82
int buffer_get_int64_ret(u_int64_t *ret___0 , Buffer *buffer ) ;
#line 83
void *buffer_get_string_ret(Buffer *buffer , u_int *length_ptr ) ;
#line 84
int buffer_get_char_ret(char *ret___0 , Buffer *buffer ) ;
#line 68 "misc.h"
u_int64_t get_u64(void const   *vp ) ;
#line 72
u_int16_t get_u16(void const   *vp ) ;
#line 74
void put_u64(void *vp , u_int64_t v ) ;
#line 78
void put_u16(void *vp , u_int16_t v ) ;
#line 58 "bufaux.c"
int buffer_get_short_ret(u_short *ret___0 , Buffer *buffer ) 
{ u_char buf___1[2] ;
  int tmp ;

  {
#line 63
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 2U);
#line 63
  if (tmp == -1) {
#line 64
    return (-1);
  }
#line 65
  *ret___0 = get_u16((void const   *)(buf___1));
#line 66
  return (0);
}
}
#line 69 "bufaux.c"
u_short buffer_get_short(Buffer *buffer ) 
{ u_short ret___0 ;
  int tmp ;

  {
#line 74
  tmp = buffer_get_short_ret(& ret___0, buffer);
#line 74
  if (tmp == -1) {
#line 75
    fatal("buffer_get_short: buffer error");
  }
#line 77
  return (ret___0);
}
}
#line 80 "bufaux.c"
int buffer_get_int_ret(u_int *ret___0 , Buffer *buffer ) 
{ u_char buf___1[4] ;
  int tmp ;

  {
#line 85
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 4U);
#line 85
  if (tmp == -1) {
#line 86
    return (-1);
  }
#line 87
  *ret___0 = get_u32((void const   *)(buf___1));
#line 88
  return (0);
}
}
#line 91 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_int ret___0 ;
  int tmp ;

  {
#line 96
  tmp = buffer_get_int_ret(& ret___0, buffer);
#line 96
  if (tmp == -1) {
#line 97
    fatal("buffer_get_int: buffer error");
  }
#line 99
  return (ret___0);
}
}
#line 102 "bufaux.c"
int buffer_get_int64_ret(u_int64_t *ret___0 , Buffer *buffer ) 
{ u_char buf___1[8] ;
  int tmp ;

  {
#line 107
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 8U);
#line 107
  if (tmp == -1) {
#line 108
    return (-1);
  }
#line 109
  *ret___0 = get_u64((void const   *)(buf___1));
#line 110
  return (0);
}
}
#line 113 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_int64_t ret___0 ;
  int tmp ;

  {
#line 118
  tmp = buffer_get_int64_ret(& ret___0, buffer);
#line 118
  if (tmp == -1) {
#line 119
    fatal("buffer_get_int: buffer error");
  }
#line 121
  return (ret___0);
}
}
#line 127 "bufaux.c"
void buffer_put_short(Buffer *buffer , u_short value ) 
{ char buf___1[2] ;

  {
#line 132
  put_u16((void *)(buf___1), value);
#line 133
  buffer_append(buffer, (void const   *)(buf___1), 2U);
#line 134
  return;
}
}
#line 136 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___1[4] ;

  {
#line 141
  put_u32((void *)(buf___1), value);
#line 142
  buffer_append(buffer, (void const   *)(buf___1), 4U);
#line 143
  return;
}
}
#line 145 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___1[8] ;

  {
#line 150
  put_u64((void *)(buf___1), value);
#line 151
  buffer_append(buffer, (void const   *)(buf___1), 8U);
#line 152
  return;
}
}
#line 162 "bufaux.c"
void *buffer_get_string_ret(Buffer *buffer , u_int *length_ptr ) 
{ u_char *value ;
  u_int len ;
  void *tmp ;
  int tmp___0 ;

  {
#line 169
  len = buffer_get_int(buffer);
#line 170
  if (len > 262144U) {
#line 171
    error("buffer_get_string_ret: bad string length %u", len);
#line 172
    return ((void *)0);
  }
#line 175
  tmp = xmalloc(len + 1U);
#line 175
  value = (u_char *)tmp;
#line 177
  tmp___0 = buffer_get_ret(buffer, (void *)value, len);
#line 177
  if (tmp___0 == -1) {
#line 178
    error("buffer_get_string_ret: buffer_get failed");
#line 179
    xfree((void *)value);
#line 180
    return ((void *)0);
  }
#line 183
  *(value + len) = (unsigned char )'\000';
#line 185
  if (length_ptr) {
#line 186
    *length_ptr = len;
  }
#line 187
  return ((void *)value);
}
}
#line 190 "bufaux.c"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ void *ret___0 ;

  {
#line 195
  ret___0 = buffer_get_string_ret(buffer, length_ptr);
#line 195
  if ((unsigned int )ret___0 == (unsigned int )((void *)0)) {
#line 196
    fatal("buffer_get_string: buffer error");
  }
#line 197
  return (ret___0);
}
}
#line 200 "bufaux.c"
void *buffer_get_string_ptr(Buffer *buffer , u_int *length_ptr ) 
{ void *ptr ;
  u_int len ;

  {
#line 206
  len = buffer_get_int(buffer);
#line 207
  if (len > 262144U) {
#line 208
    fatal("buffer_get_string_ptr: bad string length %u", len);
  }
#line 209
  ptr = buffer_ptr(buffer);
#line 210
  buffer_consume(buffer, len);
#line 211
  if (length_ptr) {
#line 212
    *length_ptr = len;
  }
#line 213
  return (ptr);
}
}
#line 219 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) 
{ 

  {
#line 222
  buffer_put_int(buffer, len);
#line 223
  buffer_append(buffer, buf___1, len);
#line 224
  return;
}
}
#line 225 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 228
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 229
    fatal("buffer_put_cstring: s == NULL");
  }
#line 230
  tmp = strlen(s);
#line 230
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 231
  return;
}
}
#line 236 "bufaux.c"
int buffer_get_char_ret(char *ret___0 , Buffer *buffer ) 
{ int tmp ;

  {
#line 239
  tmp = buffer_get_ret(buffer, (void *)ret___0, 1U);
#line 239
  if (tmp == -1) {
#line 240
    error("buffer_get_char_ret: buffer_get_ret failed");
#line 241
    return (-1);
  }
#line 243
  return (0);
}
}
#line 246 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;
  int tmp ;

  {
#line 251
  tmp = buffer_get_char_ret(& ch, buffer);
#line 251
  if (tmp == -1) {
#line 252
    fatal("buffer_get_char: buffer error");
  }
#line 253
  return ((int )((unsigned char )ch));
}
}
#line 259 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 262
  ch = (char )value;
#line 264
  buffer_append(buffer, (void const   *)(& ch), 1U);
#line 265
  return;
}
}
#line 1 "bufbn.o"
#pragma merger(0,"./bufbn.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "buffer.h"
int buffer_consume_ret(Buffer *buffer , u_int bytes ) ;
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 54 "buffer.h"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 76
int buffer_put_bignum_ret(Buffer *buffer , BIGNUM const   *value ) ;
#line 77
int buffer_get_bignum_ret(Buffer *buffer , BIGNUM *value ) ;
#line 78
int buffer_put_bignum2_ret(Buffer *buffer , BIGNUM const   *value ) ;
#line 79
int buffer_get_bignum2_ret(Buffer *buffer , BIGNUM *value ) ;
#line 58 "bufbn.c"
int buffer_put_bignum_ret(Buffer *buffer , BIGNUM const   *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 61
  tmp = BN_num_bits(value);
#line 61
  bits = tmp;
#line 62
  bin_size = (bits + 7) / 8;
#line 63
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 63
  buf___1 = (u_char *)tmp___0;
#line 68
  oi = BN_bn2bin(value, buf___1);
#line 69
  if (oi != bin_size) {
#line 70
    error("buffer_put_bignum_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
#line 72
    xfree((void *)buf___1);
#line 73
    return (-1);
  }
#line 77
  put_u16((void *)(msg), (unsigned short )bits);
#line 78
  buffer_append(buffer, (void const   *)(msg), 2U);
#line 80
  buffer_append(buffer, (void const   *)buf___1, (unsigned int )oi);
#line 82
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 83
  xfree((void *)buf___1);
#line 85
  return (0);
}
}
#line 88 "bufbn.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) 
{ int tmp ;

  {
#line 91
  tmp = buffer_put_bignum_ret(buffer, value);
#line 91
  if (tmp == -1) {
#line 92
    fatal("buffer_put_bignum: buffer error");
  }
#line 93
  return;
}
}
#line 98 "bufbn.c"
int buffer_get_bignum_ret(Buffer *buffer , BIGNUM *value ) 
{ u_int bits ;
  u_int bytes ;
  u_char buf___1[2] ;
  u_char *bin ;
  int tmp ;
  u_int16_t tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  BIGNUM *tmp___3 ;
  int tmp___4 ;

  {
#line 105
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 2U);
#line 105
  if (tmp == -1) {
#line 106
    error("buffer_get_bignum_ret: invalid length");
#line 107
    return (-1);
  }
#line 109
  tmp___0 = get_u16((void const   *)(buf___1));
#line 109
  bits = (unsigned int )tmp___0;
#line 111
  bytes = (bits + 7U) / 8U;
#line 112
  if (bytes > 8192U) {
#line 113
    error("buffer_get_bignum_ret: cannot handle BN of size %d", bytes);
#line 114
    return (-1);
  }
#line 116
  tmp___1 = buffer_len(buffer);
#line 116
  if (tmp___1 < bytes) {
#line 117
    error("buffer_get_bignum_ret: input buffer too small");
#line 118
    return (-1);
  }
#line 120
  tmp___2 = buffer_ptr(buffer);
#line 120
  bin = (u_char *)tmp___2;
#line 121
  tmp___3 = BN_bin2bn((unsigned char const   *)bin, (int )bytes, value);
#line 121
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 122
    error("buffer_get_bignum_ret: BN_bin2bn failed");
#line 123
    return (-1);
  }
#line 125
  tmp___4 = buffer_consume_ret(buffer, bytes);
#line 125
  if (tmp___4 == -1) {
#line 126
    error("buffer_get_bignum_ret: buffer_consume failed");
#line 127
    return (-1);
  }
#line 129
  return (0);
}
}
#line 132 "bufbn.c"
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int tmp ;

  {
#line 135
  tmp = buffer_get_bignum_ret(buffer, value);
#line 135
  if (tmp == -1) {
#line 136
    fatal("buffer_get_bignum: buffer error");
  }
#line 137
  return;
}
}
#line 142 "bufbn.c"
int buffer_put_bignum2_ret(Buffer *buffer , BIGNUM const   *value ) 
{ u_int bytes ;
  u_char *buf___1 ;
  int oi ;
  u_int hasnohigh ;
  int tmp ;
  void *tmp___0 ;

  {
#line 148
  hasnohigh = (u_int )0;
#line 150
  if (value->top == 0) {
#line 151
    buffer_put_int(buffer, 0U);
#line 152
    return (0);
  }
#line 154
  if (value->neg) {
#line 155
    error("buffer_put_bignum2_ret: negative numbers not supported");
#line 156
    return (-1);
  }
#line 158
  tmp = BN_num_bits(value);
#line 158
  bytes = (unsigned int )((tmp + 7) / 8 + 1);
#line 159
  if (bytes < 2U) {
#line 160
    error("buffer_put_bignum2_ret: BN too small");
#line 161
    return (-1);
  }
#line 163
  tmp___0 = xmalloc(bytes);
#line 163
  buf___1 = (u_char *)tmp___0;
#line 164
  *(buf___1 + 0) = (unsigned char)0;
#line 166
  oi = BN_bn2bin(value, buf___1 + 1);
#line 167
  if (oi < 0) {
#line 168
    error("buffer_put_bignum2_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi,
          bytes);
#line 170
    xfree((void *)buf___1);
#line 171
    return (-1);
  } else {
#line 167
    if ((unsigned int )oi != bytes - 1U) {
#line 168
      error("buffer_put_bignum2_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi,
            bytes);
#line 170
      xfree((void *)buf___1);
#line 171
      return (-1);
    }
  }
#line 173
  if ((int )*(buf___1 + 1) & 128) {
#line 173
    hasnohigh = 0U;
  } else {
#line 173
    hasnohigh = 1U;
  }
#line 174
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), bytes - hasnohigh);
#line 175
  memset((void *)buf___1, 0, bytes);
#line 176
  xfree((void *)buf___1);
#line 177
  return (0);
}
}
#line 180 "bufbn.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) 
{ int tmp ;

  {
#line 183
  tmp = buffer_put_bignum2_ret(buffer, value);
#line 183
  if (tmp == -1) {
#line 184
    fatal("buffer_put_bignum2: buffer error");
  }
#line 185
  return;
}
}
#line 187 "bufbn.c"
int buffer_get_bignum2_ret(Buffer *buffer , BIGNUM *value ) 
{ u_int len ;
  u_char *bin ;
  void *tmp ;
  BIGNUM *tmp___0 ;

  {
#line 193
  tmp = buffer_get_string_ret(buffer, & len);
#line 193
  bin = (u_char *)tmp;
#line 193
  if ((unsigned int )bin == (unsigned int )((void *)0)) {
#line 194
    error("buffer_get_bignum2_ret: invalid bignum");
#line 195
    return (-1);
  }
#line 198
  if (len > 0U) {
#line 198
    if ((int )*(bin + 0) & 128) {
#line 199
      error("buffer_get_bignum2_ret: negative numbers not supported");
#line 200
      xfree((void *)bin);
#line 201
      return (-1);
    }
  }
#line 203
  if (len > 8192U) {
#line 204
    error("buffer_get_bignum2_ret: cannot handle BN of size %d", len);
#line 206
    xfree((void *)bin);
#line 207
    return (-1);
  }
#line 209
  tmp___0 = BN_bin2bn((unsigned char const   *)bin, (int )len, value);
#line 209
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 210
    error("buffer_get_bignum2_ret: BN_bin2bn failed");
#line 211
    xfree((void *)bin);
#line 212
    return (-1);
  }
#line 214
  xfree((void *)bin);
#line 215
  return (0);
}
}
#line 218 "bufbn.c"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int tmp ;

  {
#line 221
  tmp = buffer_get_bignum2_ret(buffer, value);
#line 221
  if (tmp == -1) {
#line 222
    fatal("buffer_get_bignum2: buffer error");
  }
#line 223
  return;
}
}
#line 1 "buffer.o"
#pragma merger(0,"./buffer.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 36 "buffer.h"
int buffer_check_alloc(Buffer *buffer , u_int len ) ;
#line 38
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 41
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 43
void buffer_dump(Buffer *buffer ) ;
#line 47
int buffer_consume_end_ret(Buffer *buffer , u_int bytes ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 21 "xmalloc.h"
void *xrealloc(void *ptr , size_t nmemb , size_t size ) ;
#line 33 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ u_int len ;
  void *tmp ;

  {
#line 36
  len = (u_int )4096;
#line 38
  buffer->alloc = 0U;
#line 39
  tmp = xmalloc(len);
#line 39
  buffer->buf = (u_char *)tmp;
#line 40
  buffer->alloc = len;
#line 41
  buffer->offset = 0U;
#line 42
  buffer->end = 0U;
#line 43
  return;
}
}
#line 47 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 50
  if (buffer->alloc > 0U) {
#line 51
    memset((void *)buffer->buf, 0, buffer->alloc);
#line 52
    buffer->alloc = 0U;
#line 53
    xfree((void *)buffer->buf);
  }
#line 55
  return;
}
}
#line 62 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 65
  buffer->offset = 0U;
#line 66
  buffer->end = 0U;
#line 67
  return;
}
}
#line 71 "buffer.c"
void buffer_append(Buffer *buffer , void const   *data , u_int len ) 
{ void *p ;

  {
#line 75
  p = buffer_append_space(buffer, len);
#line 76
  memcpy((void * __restrict  )p, (void const   * __restrict  )data, len);
#line 77
  return;
}
}
#line 79 "buffer.c"
static int buffer_compact(Buffer *buffer ) 
{ u_int tmp ;

  {
#line 86
  if (buffer->alloc < 1048576U) {
#line 86
    tmp = buffer->alloc;
  } else {
#line 86
    tmp = 1048576U;
  }
#line 86
  if (buffer->offset > tmp) {
#line 87
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 89
    buffer->end -= buffer->offset;
#line 90
    buffer->offset = 0U;
#line 91
    return (1);
  }
#line 93
  return (0);
}
}
#line 102 "buffer.c"
void *buffer_append_space(Buffer *buffer , u_int len ) 
{ u_int newlen ;
  void *p ;
  int tmp ;
  void *tmp___0 ;

  {
#line 108
  if (len > 1048576U) {
#line 109
    fatal("buffer_append_space: len %u not supported", len);
  }
#line 112
  if (buffer->offset == buffer->end) {
#line 113
    buffer->offset = 0U;
#line 114
    buffer->end = 0U;
  }
  restart: 
#line 118
  if (buffer->end + len < buffer->alloc) {
#line 119
    p = (void *)(buffer->buf + buffer->end);
#line 120
    buffer->end += len;
#line 121
    return (p);
  }
#line 125
  tmp = buffer_compact(buffer);
#line 125
  if (tmp) {
    goto restart;
  }
#line 129
  newlen = (((buffer->alloc + len) + 32768U) - 1U) & 4294934528U;
#line 130
  if (newlen > 10485760U) {
#line 131
    fatal("buffer_append_space: alloc %u not supported", newlen);
  }
#line 133
  tmp___0 = xrealloc((void *)buffer->buf, 1U, newlen);
#line 133
  buffer->buf = (u_char *)tmp___0;
#line 134
  buffer->alloc = newlen;
  goto restart;
}
}
#line 143 "buffer.c"
int buffer_check_alloc(Buffer *buffer , u_int len ) 
{ int tmp ;

  {
#line 146
  if (buffer->offset == buffer->end) {
#line 147
    buffer->offset = 0U;
#line 148
    buffer->end = 0U;
  }
  restart: 
#line 151
  if (buffer->end + len < buffer->alloc) {
#line 152
    return (1);
  }
#line 153
  tmp = buffer_compact(buffer);
#line 153
  if (tmp) {
    goto restart;
  }
#line 155
  if (((((buffer->alloc + len) + 32768U) - 1U) & 4294934528U) <= 10485760U) {
#line 156
    return (1);
  }
#line 157
  return (0);
}
}
#line 162 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 165
  return (buffer->end - buffer->offset);
}
}
#line 170 "buffer.c"
int buffer_get_ret(Buffer *buffer , void *buf___1 , u_int len ) 
{ 

  {
#line 173
  if (len > buffer->end - buffer->offset) {
#line 174
    error("buffer_get_ret: trying to get more bytes %d than in buffer %d", len, buffer->end - buffer->offset);
#line 176
    return (-1);
  }
#line 178
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 179
  buffer->offset += len;
#line 180
  return (0);
}
}
#line 183 "buffer.c"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) 
{ int tmp ;

  {
#line 186
  tmp = buffer_get_ret(buffer, buf___1, len);
#line 186
  if (tmp == -1) {
#line 187
    fatal("buffer_get: buffer error");
  }
#line 188
  return;
}
}
#line 192 "buffer.c"
int buffer_consume_ret(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 195
  if (bytes > buffer->end - buffer->offset) {
#line 196
    error("buffer_consume_ret: trying to get more bytes than in buffer");
#line 197
    return (-1);
  }
#line 199
  buffer->offset += bytes;
#line 200
  return (0);
}
}
#line 203 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ int tmp ;

  {
#line 206
  tmp = buffer_consume_ret(buffer, bytes);
#line 206
  if (tmp == -1) {
#line 207
    fatal("buffer_consume: buffer error");
  }
#line 208
  return;
}
}
#line 212 "buffer.c"
int buffer_consume_end_ret(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 215
  if (bytes > buffer->end - buffer->offset) {
#line 216
    return (-1);
  }
#line 217
  buffer->end -= bytes;
#line 218
  return (0);
}
}
#line 221 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ int tmp ;

  {
#line 224
  tmp = buffer_consume_end_ret(buffer, bytes);
#line 224
  if (tmp == -1) {
#line 225
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 226
  return;
}
}
#line 230 "buffer.c"
void *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 233
  return ((void *)(buffer->buf + buffer->offset));
}
}
#line 238 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ u_int i ;
  u_char *ucp ;

  {
#line 242
  ucp = buffer->buf;
#line 244
  i = buffer->offset;
#line 244
  while (i < buffer->end) {
#line 245
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(ucp + i));
#line 246
    if ((i - buffer->offset) % 16U == 15U) {
#line 247
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
    } else {
#line 248
      if ((i - buffer->offset) % 2U == 1U) {
#line 249
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
      }
    }
#line 244
    i ++;
  }
#line 251
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
#line 252
  return;
}
}
#line 1 "canohost.o"
#pragma merger(0,"./canohost.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 26 "packet.h"
int packet_get_connection_in(void) ;
#line 81
int packet_connection_is_on_socket(void) ;
#line 68 "log.h"
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 15 "canohost.h"
char const   *get_canonical_hostname(int use_dns ) ;
#line 16
char const   *get_remote_ipaddr(void) ;
#line 17
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) ;
#line 19
char *get_peer_ipaddr(int sock ) ;
#line 20
int get_peer_port(int sock ) ;
#line 21
char *get_local_ipaddr(int sock ) ;
#line 22
char *get_local_name(int sock ) ;
#line 24
int get_remote_port(void) ;
#line 25
int get_local_port(void) ;
#line 26
int get_sock_port(int sock , int local ) ;
#line 29
void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) ;
#line 40 "misc.h"
char const   *ssh_gai_strerror(int gaierr ) ;
#line 37 "canohost.c"
static void check_ip_options(int sock , char *ipaddr ) ;
#line 44 "canohost.c"
static char *get_remote_hostname(int sock , int use_dns ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int __res ;
  __int32_t const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
#line 54
  fromlen = sizeof(from);
#line 55
  memset((void *)(& from), 0, sizeof(from));
#line 56
  tmp___1 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 56
  if (tmp___1 < 0) {
#line 57
    tmp = __errno_location();
#line 57
    tmp___0 = strerror(*tmp);
#line 57
    debug("getpeername failed: %.100s", tmp___0);
#line 58
    cleanup_exit(255);
  }
#line 61
  if ((int )from.ss_family == 2) {
#line 62
    check_ip_options(sock, ntop);
  }
#line 64
  ipv64_normalise_mapped(& from, & fromlen);
#line 66
  if ((int )from.ss_family == 10) {
#line 67
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 69
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 69
  if (tmp___2 != 0) {
#line 71
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 73
  if (! use_dns) {
#line 74
    tmp___3 = xstrdup((char const   *)(ntop));
#line 74
    return (tmp___3);
  }
#line 76
  debug3("Trying to reverse map address %.100s.", ntop);
#line 78
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 78
  if (tmp___5 != 0) {
#line 81
    tmp___4 = xstrdup((char const   *)(ntop));
#line 81
    return (tmp___4);
  }
#line 89
  memset((void *)(& hints), 0, sizeof(hints));
#line 90
  hints.ai_socktype = 2;
#line 91
  hints.ai_flags = 4;
#line 92
  tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 92
  if (tmp___7 == 0) {
#line 93
    logit("Nasty PTR record \"%s\" is set up for %s, ignoring", name, ntop);
#line 95
    freeaddrinfo(ai);
#line 96
    tmp___6 = xstrdup((char const   *)(ntop));
#line 96
    return (tmp___6);
  }
#line 103
  i = 0;
#line 103
  while (name[i]) {
#line 104
    tmp___11 = __ctype_b_loc();
#line 104
    if ((int const   )*(*tmp___11 + (int )name[i]) & 256) {
#line 105
      if (sizeof(name[i]) > 1U) {
#line 105
        __res = tolower((int )name[i]);
      } else {
#line 105
        tmp___10 = __ctype_tolower_loc();
#line 105
        __res = (int )*(*tmp___10 + (int )name[i]);
      }
#line 105
      name[i] = (char )__res;
    }
#line 103
    i ++;
  }
#line 115
  memset((void *)(& hints), 0, sizeof(hints));
#line 116
  hints.ai_family = (int )from.ss_family;
#line 117
  hints.ai_socktype = 1;
#line 118
  tmp___13 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 118
  if (tmp___13 != 0) {
#line 119
    logit("reverse mapping checking getaddrinfo for %.700s [%s] failed - POSSIBLE BREAK-IN ATTEMPT!",
          name, ntop);
#line 121
    tmp___12 = xstrdup((char const   *)(ntop));
#line 121
    return (tmp___12);
  }
#line 124
  ai = aitop;
#line 124
  while (ai) {
#line 125
    tmp___14 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 127
    if (tmp___14 == 0) {
#line 127
      if (0) {
#line 127
        __s1_len = strlen((char const   *)(ntop));
#line 127
        __s2_len = strlen((char const   *)(ntop2));
#line 127
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 127
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 127
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 127
              tmp___24 = 1;
            } else {
#line 127
              if (__s2_len >= 4U) {
#line 127
                tmp___24 = 1;
              } else {
#line 127
                tmp___24 = 0;
              }
            }
          } else {
#line 127
            tmp___24 = 0;
          }
        }
#line 127
        if (tmp___24) {
#line 127
          tmp___20 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 127
          tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 127
          tmp___20 = tmp___23;
        }
      } else {
#line 127
        tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 127
        tmp___20 = tmp___23;
      }
#line 127
      if (tmp___20 == 0) {
#line 128
        break;
      }
    }
#line 124
    ai = ai->ai_next;
  }
#line 130
  freeaddrinfo(aitop);
#line 132
  if (! ai) {
#line 134
    logit("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAK-IN ATTEMPT!",
          ntop, name);
#line 137
    tmp___25 = xstrdup((char const   *)(ntop));
#line 137
    return (tmp___25);
  }
#line 139
  tmp___26 = xstrdup((char const   *)(name));
#line 139
  return (tmp___26);
}
}
#line 154 "canohost.c"
static void check_ip_options(int sock , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  u_int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 165
  ip = getprotobyname("ip");
#line 165
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 166
    ipproto = ip->p_proto;
  } else {
#line 168
    ipproto = 0;
  }
#line 169
  option_size = sizeof(options___0);
#line 170
  tmp = getsockopt(sock, ipproto, 4, (void * __restrict  )(options___0), (socklen_t * __restrict  )(& option_size));
#line 170
  if (tmp >= 0) {
#line 170
    if (option_size != 0U) {
#line 172
      text[0] = (char )'\000';
#line 173
      i = 0U;
#line 173
      while (i < option_size) {
#line 174
        snprintf((char * __restrict  )(text + i * 3U), sizeof(text) - i * 3U, (char const   * __restrict  )" %2.2x",
                 options___0[i]);
#line 173
        i ++;
      }
#line 176
      fatal("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 180
  return;
}
}
#line 182 "canohost.c"
void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) 
{ struct sockaddr_in6 *a6 ;
  struct sockaddr_in *a4 ;
  struct in_addr inaddr ;
  u_int16_t port___0 ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 185
  a6 = (struct sockaddr_in6 *)addr;
#line 186
  a4 = (struct sockaddr_in *)addr;
#line 191
  if ((int )addr->ss_family != 10) {
#line 192
    return;
  } else {
#line 191
    if (*((uint32_t const   *)(& a6->sin6_addr) + 0) == 0U) {
#line 191
      if (*((uint32_t const   *)(& a6->sin6_addr) + 1) == 0U) {
#line 191
        __x = 65535U;
#line 191
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 191
        if (! (*((uint32_t const   *)(& a6->sin6_addr) + 2) == (uint32_t const   )__v)) {
#line 192
          return;
        }
      } else {
#line 192
        return;
      }
    } else {
#line 192
      return;
    }
  }
#line 194
  debug3("Normalising mapped IPv4 in IPv6 address");
#line 196
  memcpy((void * __restrict  )(& inaddr), (void const   * __restrict  )((char *)(& a6->sin6_addr) + 12),
         sizeof(inaddr));
#line 197
  port___0 = a6->sin6_port;
#line 199
  memset((void *)addr, 0, sizeof(*a4));
#line 201
  a4->sin_family = (unsigned short)2;
#line 202
  *len = sizeof(*a4);
#line 203
  memcpy((void * __restrict  )(& a4->sin_addr), (void const   * __restrict  )(& inaddr),
         sizeof(inaddr));
#line 204
  a4->sin_port = port___0;
#line 205
  return;
}
}
#line 217 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 218 "canohost.c"
static char *remote_ip  =    (char *)((void *)0);
#line 213 "canohost.c"
char const   *get_canonical_hostname(int use_dns ) 
{ char *host ;
  int tmp ;
  int tmp___0 ;

  {
#line 221
  if (use_dns) {
#line 221
    if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 222
      return ((char const   *)canonical_host_name);
    }
  }
#line 223
  if (! use_dns) {
#line 223
    if ((unsigned int )remote_ip != (unsigned int )((void *)0)) {
#line 224
      return ((char const   *)remote_ip);
    }
  }
#line 227
  tmp___0 = packet_connection_is_on_socket();
#line 227
  if (tmp___0) {
#line 228
    tmp = packet_get_connection_in();
#line 228
    host = get_remote_hostname(tmp, use_dns);
  } else {
#line 230
    host = (char *)"UNKNOWN";
  }
#line 232
  if (use_dns) {
#line 233
    canonical_host_name = host;
  } else {
#line 235
    remote_ip = host;
  }
#line 236
  return ((char const   *)host);
}
}
#line 243 "canohost.c"
static char *get_socket_address(int sock , int remote___0 , int flags ) 
{ struct sockaddr_storage addr ;
  socklen_t addrlen ;
  char ntop[1025] ;
  int r ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 252
  addrlen = sizeof(addr);
#line 253
  memset((void *)(& addr), 0, sizeof(addr));
#line 255
  if (remote___0) {
#line 256
    tmp = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                      (socklen_t * __restrict  )(& addrlen));
#line 256
    if (tmp < 0) {
#line 258
      return ((char *)((void *)0));
    }
  } else {
#line 260
    tmp___0 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 260
    if (tmp___0 < 0) {
#line 262
      return ((char *)((void *)0));
    }
  }
#line 266
  if ((int )addr.ss_family == 10) {
#line 267
    addrlen = sizeof(struct sockaddr_in6 );
  }
#line 269
  ipv64_normalise_mapped(& addr, & addrlen);
#line 272
  r = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                  addrlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                  0U, (unsigned int )flags);
#line 272
  if (r != 0) {
#line 274
    tmp___1 = ssh_gai_strerror(r);
#line 274
    error("get_socket_address: getnameinfo %d failed: %s", flags, tmp___1);
#line 276
    return ((char *)((void *)0));
  }
#line 278
  tmp___2 = xstrdup((char const   *)(ntop));
#line 278
  return (tmp___2);
}
}
#line 281 "canohost.c"
char *get_peer_ipaddr(int sock ) 
{ char *p ;
  char *tmp ;

  {
#line 286
  p = get_socket_address(sock, 1, 1);
#line 286
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 287
    return (p);
  }
#line 288
  tmp = xstrdup("UNKNOWN");
#line 288
  return (tmp);
}
}
#line 291 "canohost.c"
char *get_local_ipaddr(int sock ) 
{ char *p ;
  char *tmp ;

  {
#line 296
  p = get_socket_address(sock, 0, 1);
#line 296
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 297
    return (p);
  }
#line 298
  tmp = xstrdup("UNKNOWN");
#line 298
  return (tmp);
}
}
#line 301 "canohost.c"
char *get_local_name(int sock ) 
{ char *tmp ;

  {
#line 304
  tmp = get_socket_address(sock, 0, 8);
#line 304
  return (tmp);
}
}
#line 315 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 312 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 318
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 319
    tmp___0 = packet_connection_is_on_socket();
#line 319
    if (tmp___0) {
#line 320
      tmp = packet_get_connection_in();
#line 320
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 322
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 323
        cleanup_exit(255);
      }
    } else {
#line 326
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 329
  return ((char const   *)canonical_host_ip);
}
}
#line 335 "canohost.c"
static char const   *remote  =    "";
#line 332 "canohost.c"
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) 
{ size_t tmp ;

  {
#line 336
  if (utmp_len___0 > 0U) {
#line 337
    remote = get_canonical_hostname(use_dns);
  }
#line 338
  if (utmp_len___0 == 0U) {
#line 339
    remote = get_remote_ipaddr();
  } else {
#line 338
    tmp = strlen(remote);
#line 338
    if (tmp > utmp_len___0) {
#line 339
      remote = get_remote_ipaddr();
    }
  }
#line 340
  return (remote);
}
}
#line 345 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int r ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 354
  fromlen = sizeof(from);
#line 355
  memset((void *)(& from), 0, sizeof(from));
#line 356
  if (local) {
#line 357
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 357
    if (tmp___1 < 0) {
#line 358
      tmp = __errno_location();
#line 358
      tmp___0 = strerror(*tmp);
#line 358
      error("getsockname failed: %.100s", tmp___0);
#line 359
      return (0);
    }
  } else {
#line 362
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 362
    if (tmp___4 < 0) {
#line 363
      tmp___2 = __errno_location();
#line 363
      tmp___3 = strerror(*tmp___2);
#line 363
      debug("getpeername failed: %.100s", tmp___3);
#line 364
      return (-1);
    }
  }
#line 369
  if ((int )from.ss_family == 10) {
#line 370
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 373
  r = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                  fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                  sizeof(strport), 2U);
#line 373
  if (r != 0) {
#line 375
    tmp___5 = ssh_gai_strerror(r);
#line 375
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed: %s", tmp___5);
  }
#line 377
  tmp___6 = atoi((char const   *)(strport));
#line 377
  return (tmp___6);
}
}
#line 382 "canohost.c"
static int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 389
  tmp = packet_connection_is_on_socket();
#line 389
  if (! tmp) {
#line 390
    return (65535);
  }
#line 393
  tmp___0 = packet_get_connection_in();
#line 393
  tmp___1 = get_sock_port(tmp___0, local);
#line 393
  return (tmp___1);
}
}
#line 396 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 399
  tmp = get_sock_port(sock, 0);
#line 399
  return (tmp);
}
}
#line 405 "canohost.c"
static int port  =    -1;
#line 402 "canohost.c"
int get_remote_port(void) 
{ 

  {
#line 408
  if (port == -1) {
#line 409
    port = get_port(0);
  }
#line 411
  return (port);
}
}
#line 414 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 417
  tmp = get_port(1);
#line 417
  return (tmp);
}
}
#line 1 "channels.o"
#pragma merger(0,"./channels.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 65
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 20 "xmalloc.h"
void *xcalloc(size_t nmemb , size_t size ) ;
#line 32 "packet.h"
u_int packet_get_protocol_flags(void) ;
#line 35
int packet_is_interactive(void) ;
#line 39
void packet_start(u_char type ) ;
#line 40
void packet_put_char(int value ) ;
#line 41
void packet_put_int(u_int value ) ;
#line 44
void packet_put_string(void const   *buf___1 , u_int len ) ;
#line 45
void packet_put_cstring(char const   *str ) ;
#line 47
void packet_send(void) ;
#line 49
int packet_read(void) ;
#line 57
u_int packet_get_int(void) ;
#line 61
void *packet_get_string(u_int *length_ptr ) ;
#line 62
void *packet_get_string_ptr(u_int *length_ptr ) ;
#line 63
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 77
void packet_write_wait(void) ;
#line 83
int packet_remaining(void) ;
#line 84
void packet_send_ignore(int nbytes ) ;
#line 90
u_int max_packet_size ;
#line 91
int keep_alive_timeouts ;
#line 62 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 64
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 22 "misc.h"
int set_nonblock(int fd ) ;
#line 24
void set_nodelay(int fd ) ;
#line 34
char *tohex(void const   *vp , size_t l ) ;
#line 186 "channels.h"
Channel *channel_by_id(int id ) ;
#line 187
Channel *channel_lookup(int id ) ;
#line 188
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 189
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     int is_tty , u_int window_max ) ;
#line 190
void channel_free(Channel *c ) ;
#line 191
void channel_free_all(void) ;
#line 192
void channel_stop_listening(void) ;
#line 194
void channel_send_open(int id ) ;
#line 195
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 196
void channel_register_cleanup(int id , channel_callback_fn *fn , int do_close ) ;
#line 197
void channel_register_open_confirm(int id , channel_callback_fn *fn , void *ctx ) ;
#line 198
void channel_register_filter(int id , channel_infilter_fn *ifn , channel_outfilter_fn *ofn ,
                             channel_filter_cleanup_fn *cfn , void *ctx ) ;
#line 200
void channel_register_status_confirm(int id , channel_confirm_cb *cb , channel_confirm_abandon_cb *abandon_cb ,
                                     void *ctx ) ;
#line 202
void channel_cancel_cleanup(int id ) ;
#line 203
int channel_close_fd(int *fdp ) ;
#line 204
void channel_send_window_changes(void) ;
#line 208
void channel_input_close(int type , u_int32_t seq , void *ctxt ) ;
#line 209
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 210
void channel_input_data(int type , u_int32_t seq , void *ctxt ) ;
#line 211
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) ;
#line 212
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) ;
#line 213
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) ;
#line 214
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 215
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) ;
#line 216
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) ;
#line 217
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) ;
#line 218
void channel_input_status_confirm(int type , u_int32_t seq , void *ctxt ) ;
#line 222
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            u_int *nallocp , int rekeying___0 ) ;
#line 223
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 224
void channel_output_poll(void) ;
#line 226
int channel_not_very_much_buffered_data(void) ;
#line 227
void channel_close_all(void) ;
#line 228
int channel_still_open(void) ;
#line 229
char *channel_open_message(void) ;
#line 230
int channel_find_open(void) ;
#line 233
void channel_set_af(int af ) ;
#line 234
void channel_permit_all_opens(void) ;
#line 235
void channel_add_permitted_opens(char *host , int port___0 ) ;
#line 236
int channel_add_adm_permitted_opens(char *host , int port___0 ) ;
#line 237
void channel_clear_permitted_opens(void) ;
#line 238
void channel_clear_adm_permitted_opens(void) ;
#line 239
void channel_print_adm_permitted_opens(void) ;
#line 240
int channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 241
Channel *channel_connect_to(char const   *host , u_short port___0 , char *ctype ,
                            char *rname ) ;
#line 242
Channel *channel_connect_by_listen_address(u_short listen_port , char *ctype , char *rname ) ;
#line 243
int channel_request_remote_forwarding(char const   *listen_host , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ) ;
#line 245
int channel_setup_local_fwd_listener(char const   *listen_host , u_short listen_port ,
                                     char const   *host_to_connect , u_short port_to_connect ,
                                     int gateway_ports ) ;
#line 247
void channel_request_rforward_cancel(char const   *host , u_short port___0 ) ;
#line 248
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int *allocated_listen_port , int gateway_ports ) ;
#line 249
int channel_cancel_rport_listener(char const   *host , u_short port___0 ) ;
#line 253
int x11_connect_display(void) ;
#line 254
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp , int **chanids ) ;
#line 255
void x11_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 256
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *disp ,
                                          char const   *proto , char const   *data ) ;
#line 258
void deny_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 262
void auth_request_forwarding(void) ;
#line 266
int chan_is_dead(Channel *c , int do_send ) ;
#line 267
void chan_mark_dead(Channel *c ) ;
#line 271
void chan_rcvd_oclose(Channel *c ) ;
#line 273
void chan_read_failed(Channel *c ) ;
#line 274
void chan_ibuf_empty(Channel *c ) ;
#line 276
void chan_rcvd_ieof(Channel *c ) ;
#line 277
void chan_write_failed(Channel *c ) ;
#line 278
void chan_obuf_empty(Channel *c ) ;
#line 68 "compat.h"
int compat13 ;
#line 69
int compat20 ;
#line 86 "channels.c"
static Channel **channels  =    (Channel **)((void *)0);
#line 92 "channels.c"
static u_int channels_alloc  =    (u_int )0;
#line 98 "channels.c"
static int channel_max_fd  =    0;
#line 116 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 119 "channels.c"
static ForwardPermission permitted_adm_opens[100]  ;
#line 122 "channels.c"
static int num_permitted_opens  =    0;
#line 125 "channels.c"
static int num_adm_permitted_opens  =    0;
#line 132 "channels.c"
static int all_opens_permitted  =    0;
#line 141 "channels.c"
static char *x11_saved_display  =    (char *)((void *)0);
#line 144 "channels.c"
static char *x11_saved_proto  =    (char *)((void *)0);
#line 147 "channels.c"
static char *x11_saved_data  =    (char *)((void *)0);
#line 148 "channels.c"
static u_int x11_saved_data_len  =    (u_int )0;
#line 154 "channels.c"
static u_char *x11_fake_data  =    (u_char *)((void *)0);
#line 155 "channels.c"
static u_int x11_fake_data_len  ;
#line 163 "channels.c"
static int IPv4or6  =    0;
#line 166
static void port_open_helper(Channel *c , char *rtype ) ;
#line 169
static int connect_next(struct channel_connect *cctx ) ;
#line 170
static void channel_connect_ctx_free(struct channel_connect *cctx ) ;
#line 174 "channels.c"
Channel *channel_by_id(int id ) 
{ Channel *c ;

  {
#line 179
  if (id < 0) {
#line 180
    logit("channel_by_id: %d: bad id", id);
#line 181
    return ((Channel *)((void *)0));
  } else {
#line 179
    if ((unsigned int )id >= channels_alloc) {
#line 180
      logit("channel_by_id: %d: bad id", id);
#line 181
      return ((Channel *)((void *)0));
    }
  }
#line 183
  c = *(channels + id);
#line 184
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 185
    logit("channel_by_id: %d: bad id: channel free", id);
#line 186
    return ((Channel *)((void *)0));
  }
#line 188
  return (c);
}
}
#line 195 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 200
  c = channel_by_id(id);
#line 200
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 201
    return ((Channel *)((void *)0));
  }
#line 203
  switch (c->type) {
  case 7: 
  case 10: 
  case 12: 
  case 13: 
  case 3: 
  case 4: 
  case 8: 
  case 9: 
#line 212
  return (c);
  }
#line 214
  logit("Non-public channel %d, type %d.", id, c->type);
#line 215
  return ((Channel *)((void *)0));
}
}
#line 222 "channels.c"
static void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                                 int nonblock , int is_tty ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 227
  if (channel_max_fd > rfd) {
#line 227
    channel_max_fd = channel_max_fd;
  } else {
#line 227
    channel_max_fd = rfd;
  }
#line 228
  if (channel_max_fd > wfd) {
#line 228
    channel_max_fd = channel_max_fd;
  } else {
#line 228
    channel_max_fd = wfd;
  }
#line 229
  if (channel_max_fd > efd) {
#line 229
    channel_max_fd = channel_max_fd;
  } else {
#line 229
    channel_max_fd = efd;
  }
#line 233
  c->rfd = rfd;
#line 234
  c->wfd = wfd;
#line 235
  if (rfd == wfd) {
#line 235
    c->sock = rfd;
  } else {
#line 235
    c->sock = -1;
  }
#line 236
  c->ctl_fd = -1;
#line 237
  c->efd = efd;
#line 238
  c->extended_usage = extusage;
#line 240
  c->isatty = is_tty;
#line 240
  if (c->isatty != 0) {
#line 241
    debug2("channel %d: rfd %d isatty", c->self, c->rfd);
  }
#line 242
  if (is_tty) {
#line 242
    tmp___0 = 1;
  } else {
#line 242
    tmp = isatty(c->wfd);
#line 242
    if (tmp) {
#line 242
      tmp___0 = 1;
    } else {
#line 242
      tmp___0 = 0;
    }
  }
#line 242
  c->wfd_isatty = tmp___0;
#line 245
  if (nonblock) {
#line 246
    if (rfd != -1) {
#line 247
      set_nonblock(rfd);
    }
#line 248
    if (wfd != -1) {
#line 249
      set_nonblock(wfd);
    }
#line 250
    if (efd != -1) {
#line 251
      set_nonblock(efd);
    }
  }
#line 253
  return;
}
}
#line 259 "channels.c"
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int found ;
  u_int i ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 268
  if (channels_alloc == 0U) {
#line 269
    channels_alloc = 10U;
#line 270
    tmp = xcalloc(channels_alloc, sizeof(Channel *));
#line 270
    channels = (Channel **)tmp;
#line 271
    i = 0U;
#line 271
    while (i < channels_alloc) {
#line 272
      *(channels + i) = (Channel *)((void *)0);
#line 271
      i ++;
    }
  }
#line 275
  found = -1;
#line 275
  i = 0U;
#line 275
  while (i < channels_alloc) {
#line 276
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
#line 278
      found = (int )i;
#line 279
      break;
    }
#line 275
    i ++;
  }
#line 281
  if (found < 0) {
#line 283
    found = (int )channels_alloc;
#line 284
    if (channels_alloc > 10000U) {
#line 285
      fatal("channel_new: internal error: channels_alloc %d too big.", channels_alloc);
    }
#line 287
    tmp___0 = xrealloc((void *)channels, channels_alloc + 10U, sizeof(Channel *));
#line 287
    channels = (Channel **)tmp___0;
#line 289
    channels_alloc += 10U;
#line 290
    debug2("channel: expanding %d", channels_alloc);
#line 291
    i = (unsigned int )found;
#line 291
    while (i < channels_alloc) {
#line 292
      *(channels + i) = (Channel *)((void *)0);
#line 291
      i ++;
    }
  }
#line 295
  tmp___1 = xcalloc(1U, sizeof(Channel ));
#line 295
  *(channels + found) = (Channel *)tmp___1;
#line 295
  c = *(channels + found);
#line 296
  buffer_init(& c->input);
#line 297
  buffer_init(& c->output);
#line 298
  buffer_init(& c->extended);
#line 299
  c->path = (char *)((void *)0);
#line 300
  c->ostate = 0U;
#line 301
  c->istate = 0U;
#line 302
  c->flags = 0;
#line 303
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, 0);
#line 304
  c->self = found;
#line 305
  c->type = type;
#line 306
  c->ctype = ctype;
#line 307
  c->local_window = window;
#line 308
  c->local_window_max = window;
#line 309
  c->local_consumed = 0U;
#line 310
  c->local_maxpacket = maxpack;
#line 311
  c->remote_id = -1;
#line 312
  c->remote_name = xstrdup((char const   *)remote_name);
#line 313
  c->remote_window = 0U;
#line 314
  c->remote_maxpacket = 0U;
#line 315
  c->force_drain = 0;
#line 316
  c->single_connection = 0;
#line 317
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 318
  c->detach_close = 0;
#line 319
  c->open_confirm = (channel_callback_fn *)((void *)0);
#line 320
  c->open_confirm_ctx = (void *)0;
#line 321
  c->input_filter = (channel_infilter_fn *)((void *)0);
#line 322
  c->output_filter = (channel_outfilter_fn *)((void *)0);
#line 323
  c->filter_ctx = (void *)0;
#line 324
  c->filter_cleanup = (channel_filter_cleanup_fn *)((void *)0);
#line 325
  while (1) {
#line 325
    c->status_confirms.tqh_first = (struct channel_confirm *)((void *)0);
#line 325
    c->status_confirms.tqh_last = & c->status_confirms.tqh_first;
#line 325
    break;
  }
#line 326
  debug("channel %d: new [%s]", found, remote_name);
#line 327
  return (c);
}
}
#line 330 "channels.c"
static int channel_find_maxfd(void) 
{ u_int i ;
  int max ;
  Channel *c ;

  {
#line 334
  max = 0;
#line 337
  i = 0U;
#line 337
  while (i < channels_alloc) {
#line 338
    c = *(channels + i);
#line 339
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 340
      if (max > c->rfd) {
#line 340
        max = max;
      } else {
#line 340
        max = c->rfd;
      }
#line 341
      if (max > c->wfd) {
#line 341
        max = max;
      } else {
#line 341
        max = c->wfd;
      }
#line 342
      if (max > c->efd) {
#line 342
        max = max;
      } else {
#line 342
        max = c->efd;
      }
    }
#line 337
    i ++;
  }
#line 345
  return (max);
}
}
#line 348 "channels.c"
int channel_close_fd(int *fdp ) 
{ int ret___0 ;
  int fd ;

  {
#line 351
  ret___0 = 0;
#line 351
  fd = *fdp;
#line 353
  if (fd != -1) {
#line 354
    ret___0 = close(fd);
#line 355
    *fdp = -1;
#line 356
    if (fd == channel_max_fd) {
#line 357
      channel_max_fd = channel_find_maxfd();
    }
  }
#line 359
  return (ret___0);
}
}
#line 363 "channels.c"
static void channel_close_fds(Channel *c ) 
{ 

  {
#line 366
  debug3("channel %d: close_fds r %d w %d e %d c %d", c->self, c->rfd, c->wfd, c->efd,
         c->ctl_fd);
#line 369
  channel_close_fd(& c->sock);
#line 370
  channel_close_fd(& c->ctl_fd);
#line 371
  channel_close_fd(& c->rfd);
#line 372
  channel_close_fd(& c->wfd);
#line 373
  channel_close_fd(& c->efd);
#line 374
  return;
}
}
#line 377 "channels.c"
void channel_free(Channel *c ) 
{ char *s ;
  u_int i ;
  u_int n___0 ;
  struct channel_confirm *cc ;
  char const   *tmp ;

  {
#line 384
  n___0 = 0U;
#line 384
  i = 0U;
#line 384
  while (i < channels_alloc) {
#line 385
    if (*(channels + i)) {
#line 386
      n___0 ++;
    }
#line 384
    i ++;
  }
#line 387
  if (c->remote_name) {
#line 387
    tmp = (char const   *)c->remote_name;
  } else {
#line 387
    tmp = "???";
  }
#line 387
  debug("channel %d: free: %s, nchannels %u", c->self, tmp, n___0);
#line 390
  s = channel_open_message();
#line 391
  debug3("channel %d: status: %s", c->self, s);
#line 392
  xfree((void *)s);
#line 394
  if (c->sock != -1) {
#line 395
    shutdown(c->sock, 2);
  }
#line 396
  if (c->ctl_fd != -1) {
#line 397
    shutdown(c->ctl_fd, 2);
  }
#line 398
  channel_close_fds(c);
#line 399
  buffer_free(& c->input);
#line 400
  buffer_free(& c->output);
#line 401
  buffer_free(& c->extended);
#line 402
  if (c->remote_name) {
#line 403
    xfree((void *)c->remote_name);
#line 404
    c->remote_name = (char *)((void *)0);
  }
#line 406
  if (c->path) {
#line 407
    xfree((void *)c->path);
#line 408
    c->path = (char *)((void *)0);
  }
#line 410
  while (1) {
#line 410
    cc = c->status_confirms.tqh_first;
#line 410
    if (! ((unsigned int )cc != (unsigned int )((void *)0))) {
#line 410
      break;
    }
#line 411
    if ((unsigned int )cc->abandon_cb != (unsigned int )((void *)0)) {
#line 412
      (*(cc->abandon_cb))(c, cc->ctx);
    }
#line 413
    while (1) {
#line 413
      if ((unsigned int )cc->entry.tqe_next != (unsigned int )((void *)0)) {
#line 413
        (cc->entry.tqe_next)->entry.tqe_prev = cc->entry.tqe_prev;
      } else {
#line 413
        c->status_confirms.tqh_last = cc->entry.tqe_prev;
      }
#line 413
      *(cc->entry.tqe_prev) = cc->entry.tqe_next;
#line 413
      break;
    }
#line 414
    bzero((void *)cc, sizeof(*cc));
#line 415
    xfree((void *)cc);
  }
#line 417
  if ((unsigned int )c->filter_cleanup != (unsigned int )((void *)0)) {
#line 417
    if ((unsigned int )c->filter_ctx != (unsigned int )((void *)0)) {
#line 418
      (*(c->filter_cleanup))(c->self, c->filter_ctx);
    }
  }
#line 419
  *(channels + c->self) = (Channel *)((void *)0);
#line 420
  xfree((void *)c);
#line 421
  return;
}
}
#line 423 "channels.c"
void channel_free_all(void) 
{ u_int i ;

  {
#line 428
  i = 0U;
#line 428
  while (i < channels_alloc) {
#line 429
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 430
      channel_free(*(channels + i));
    }
#line 428
    i ++;
  }
#line 431
  return;
}
}
#line 437 "channels.c"
void channel_close_all(void) 
{ u_int i ;

  {
#line 442
  i = 0U;
#line 442
  while (i < channels_alloc) {
#line 443
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 444
      channel_close_fds(*(channels + i));
    }
#line 442
    i ++;
  }
#line 445
  return;
}
}
#line 450 "channels.c"
void channel_stop_listening(void) 
{ u_int i ;
  Channel *c ;

  {
#line 456
  i = 0U;
#line 456
  while (i < channels_alloc) {
#line 457
    c = *(channels + i);
#line 458
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 459
      switch (c->type) {
      case 6: 
      case 2: 
      case 11: 
      case 1: 
#line 464
      channel_close_fd(& c->sock);
#line 465
      channel_free(c);
#line 466
      break;
      }
    }
#line 456
    i ++;
  }
#line 470
  return;
}
}
#line 476 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 482
  i = 0U;
#line 482
  while (i < channels_alloc) {
#line 483
    c = *(channels + i);
#line 484
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 484
      if (c->type == 4) {
#line 493
        tmp___0 = buffer_len(& c->output);
#line 493
        if (tmp___0 > max_packet_size) {
#line 494
          tmp = buffer_len(& c->output);
#line 494
          debug2("channel %d: big output buffer %u > %u", c->self, tmp, max_packet_size);
#line 497
          return (0);
        }
      }
    }
#line 482
    i ++;
  }
#line 501
  return (1);
}
}
#line 505 "channels.c"
int channel_still_open(void) 
{ u_int i ;
  Channel *c ;

  {
#line 511
  i = 0U;
#line 511
  while (i < channels_alloc) {
#line 512
    c = *(channels + i);
#line 513
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 515
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 13: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
#line 526
    if (! compat20) {
#line 527
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 532
    return (1);
    case 8: 
    case 9: 
#line 535
    if (! compat13) {
#line 536
      fatal("cannot happen: OUT_DRAIN");
    }
#line 537
    return (1);
    default: 
#line 539
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 511
    i ++;
  }
#line 543
  return (0);
}
}
#line 547 "channels.c"
int channel_find_open(void) 
{ u_int i ;
  Channel *c ;

  {
#line 553
  i = 0U;
#line 553
  while (i < channels_alloc) {
#line 554
    c = *(channels + i);
#line 555
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 555
      if (c->remote_id < 0) {
        goto __Cont;
      }
    }
#line 557
    switch (c->type) {
    case 5: 
    case 13: 
    case 1: 
    case 2: 
    case 11: 
    case 3: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
    case 6: 
    case 4: 
    case 7: 
#line 571
    return ((int )i);
    case 8: 
    case 9: 
#line 574
    if (! compat13) {
#line 575
      fatal("cannot happen: OUT_DRAIN");
    }
#line 576
    return ((int )i);
    default: 
#line 578
    fatal("channel_find_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 553
    i ++;
  }
#line 582
  return (-1);
}
}
#line 591 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  Channel *c ;
  char buf___1[1024] ;
  char *cp ;
  u_int i ;
  size_t tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 599
  buffer_init(& buffer);
#line 600
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 601
  tmp = strlen((char const   *)(buf___1));
#line 601
  buffer_append(& buffer, (void const   *)(buf___1), tmp);
#line 602
  i = 0U;
#line 602
  while (i < channels_alloc) {
#line 603
    c = *(channels + i);
#line 604
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 606
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 14: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 13: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 622
    tmp___0 = buffer_len(& c->output);
#line 622
    tmp___1 = buffer_len(& c->input);
#line 622
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d cfd %d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd, c->ctl_fd);
#line 629
    tmp___2 = strlen((char const   *)(buf___1));
#line 629
    buffer_append(& buffer, (void const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 632
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 602
    i ++;
  }
#line 636
  buffer_append(& buffer, (void const   *)"\000", 1U);
#line 637
  tmp___3 = buffer_ptr(& buffer);
#line 637
  cp = xstrdup((char const   *)tmp___3);
#line 638
  buffer_free(& buffer);
#line 639
  return (cp);
}
}
#line 642 "channels.c"
void channel_send_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 645
  tmp = channel_lookup(id);
#line 645
  c = tmp;
#line 647
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 648
    logit("channel_send_open: %d: bad id", id);
#line 649
    return;
  }
#line 651
  debug2("channel %d: send open", id);
#line 652
  packet_start((unsigned char)90);
#line 653
  packet_put_cstring((char const   *)c->ctype);
#line 654
  packet_put_int((unsigned int )c->self);
#line 655
  packet_put_int(c->local_window);
#line 656
  packet_put_int(c->local_maxpacket);
#line 657
  packet_send();
#line 658
  return;
}
}
#line 660 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 663
  tmp = channel_lookup(id);
#line 663
  c = tmp;
#line 665
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 666
    logit("channel_request_start: %d: unknown channel id", id);
#line 667
    return;
  }
#line 669
  debug2("channel %d: request %s confirm %d", id, service, wantconfirm);
#line 670
  packet_start((unsigned char)98);
#line 671
  packet_put_int((unsigned int )c->remote_id);
#line 672
  packet_put_cstring((char const   *)service);
#line 673
  packet_put_char(wantconfirm);
#line 674
  return;
}
}
#line 676 "channels.c"
void channel_register_status_confirm(int id , channel_confirm_cb *cb , channel_confirm_abandon_cb *abandon_cb ,
                                     void *ctx ) 
{ struct channel_confirm *cc ;
  Channel *c ;
  void *tmp ;

  {
#line 683
  c = channel_lookup(id);
#line 683
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 684
    fatal("channel_register_expect: %d: bad id", id);
  }
#line 686
  tmp = xmalloc(sizeof(*cc));
#line 686
  cc = (struct channel_confirm *)tmp;
#line 687
  cc->cb = cb;
#line 688
  cc->abandon_cb = abandon_cb;
#line 689
  cc->ctx = ctx;
#line 690
  while (1) {
#line 690
    cc->entry.tqe_next = (struct channel_confirm *)((void *)0);
#line 690
    cc->entry.tqe_prev = c->status_confirms.tqh_last;
#line 690
    *(c->status_confirms.tqh_last) = cc;
#line 690
    c->status_confirms.tqh_last = & cc->entry.tqe_next;
#line 690
    break;
  }
#line 691
  return;
}
}
#line 693 "channels.c"
void channel_register_open_confirm(int id , channel_callback_fn *fn , void *ctx ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 696
  tmp = channel_lookup(id);
#line 696
  c = tmp;
#line 698
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 699
    logit("channel_register_open_confirm: %d: bad id", id);
#line 700
    return;
  }
#line 702
  c->open_confirm = fn;
#line 703
  c->open_confirm_ctx = ctx;
#line 704
  return;
}
}
#line 706 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn , int do_close ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 709
  tmp = channel_by_id(id);
#line 709
  c = tmp;
#line 711
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 712
    logit("channel_register_cleanup: %d: bad id", id);
#line 713
    return;
  }
#line 715
  c->detach_user = fn;
#line 716
  c->detach_close = do_close;
#line 717
  return;
}
}
#line 719 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 722
  tmp = channel_by_id(id);
#line 722
  c = tmp;
#line 724
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 725
    logit("channel_cancel_cleanup: %d: bad id", id);
#line 726
    return;
  }
#line 728
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 729
  c->detach_close = 0;
#line 730
  return;
}
}
#line 732 "channels.c"
void channel_register_filter(int id , channel_infilter_fn *ifn , channel_outfilter_fn *ofn ,
                             channel_filter_cleanup_fn *cfn , void *ctx ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 736
  tmp = channel_lookup(id);
#line 736
  c = tmp;
#line 738
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 739
    logit("channel_register_filter: %d: bad id", id);
#line 740
    return;
  }
#line 742
  c->input_filter = ifn;
#line 743
  c->output_filter = ofn;
#line 744
  c->filter_ctx = ctx;
#line 745
  c->filter_cleanup = cfn;
#line 746
  return;
}
}
#line 748 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     int is_tty , u_int window_max ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 752
  tmp = channel_lookup(id);
#line 752
  c = tmp;
#line 754
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 755
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 754
    if (c->type != 10) {
#line 755
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 756
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock, is_tty);
#line 757
  c->type = 4;
#line 758
  c->local_window_max = window_max;
#line 758
  c->local_window = c->local_window_max;
#line 759
  packet_start((unsigned char)93);
#line 760
  packet_put_int((unsigned int )c->remote_id);
#line 761
  packet_put_int(c->local_window);
#line 762
  packet_send();
#line 763
  return;
}
}
#line 774 "channels.c"
chan_fn *channel_pre[15]  ;
#line 775 "channels.c"
chan_fn *channel_post[15]  ;
#line 778 "channels.c"
static void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 781
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 782
  return;
}
}
#line 785 "channels.c"
static void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 788
  debug3("channel %d: waiting for connection", c->self);
#line 789
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 790
  return;
}
}
#line 792 "channels.c"
static void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 795
  tmp = buffer_len(& c->input);
#line 795
  if (tmp < max_packet_size) {
#line 796
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 797
  tmp___0 = buffer_len(& c->output);
#line 797
  if (tmp___0 > 0U) {
#line 798
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 799
  return;
}
}
#line 801 "channels.c"
static void channel_pre_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int limit ;
  u_int tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 804
  if (compat20) {
#line 804
    tmp = c->remote_window;
  } else {
#line 804
    tmp = max_packet_size;
  }
#line 804
  limit = tmp;
#line 806
  if (c->istate == 0U) {
#line 806
    if (limit > 0U) {
#line 806
      tmp___0 = buffer_len(& c->input);
#line 806
      if (tmp___0 < limit) {
#line 806
        tmp___1 = buffer_check_alloc(& c->input, 16384U);
#line 806
        if (tmp___1) {
#line 810
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 811
  if (c->ostate == 0U) {
    goto _L;
  } else {
#line 811
    if (c->ostate == 1U) {
      _L: /* CIL Label */ 
#line 813
      tmp___4 = buffer_len(& c->output);
#line 813
      if (tmp___4 > 0U) {
#line 814
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 815
        if (c->ostate == 1U) {
#line 816
          if (compat20) {
#line 816
            if (c->extended_usage == 2) {
#line 816
              if (c->efd != -1) {
#line 816
                if (! (c->flags & 10)) {
#line 817
                  tmp___2 = buffer_len(& c->extended);
#line 817
                  debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___2);
                } else {
#line 816
                  tmp___3 = buffer_len(& c->extended);
#line 816
                  if (tmp___3 > 0U) {
#line 817
                    tmp___2 = buffer_len(& c->extended);
#line 817
                    debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self,
                           c->efd, tmp___2);
                  } else {
#line 820
                    chan_obuf_empty(c);
                  }
                }
              } else {
#line 820
                chan_obuf_empty(c);
              }
            } else {
#line 820
              chan_obuf_empty(c);
            }
          } else {
#line 820
            chan_obuf_empty(c);
          }
        }
      }
    }
  }
#line 824
  if (compat20) {
#line 824
    if (c->efd != -1) {
#line 824
      if (c->istate == 3U) {
#line 824
        if (! (c->ostate == 3U)) {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 826
        if (c->extended_usage == 2) {
#line 826
          tmp___6 = buffer_len(& c->extended);
#line 826
          if (tmp___6 > 0U) {
#line 828
            __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                                 "memory");
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 829
          if (! (c->flags & 4)) {
#line 829
            if (c->extended_usage == 1) {
#line 829
              tmp___5 = buffer_len(& c->extended);
#line 829
              if (tmp___5 < c->remote_window) {
#line 832
                __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                                     "memory");
              }
            }
          }
        }
      }
    }
  }
#line 835
  if (compat20) {
#line 835
    if (c->ctl_fd != -1) {
#line 835
      if (c->istate == 0U) {
#line 835
        if (c->ostate == 0U) {
#line 837
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->ctl_fd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->ctl_fd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 838
  return;
}
}
#line 841 "channels.c"
static void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 844
  tmp = buffer_len(& c->input);
#line 844
  if (tmp == 0U) {
#line 845
    packet_start((unsigned char)24);
#line 846
    packet_put_int((unsigned int )c->remote_id);
#line 847
    packet_send();
#line 848
    c->type = 5;
#line 849
    debug2("channel %d: closing after input drain.", c->self);
  }
#line 851
  return;
}
}
#line 854 "channels.c"
static void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 857
  tmp = buffer_len(& c->output);
#line 857
  if (tmp == 0U) {
#line 858
    chan_mark_dead(c);
  } else {
#line 860
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 861
  return;
}
}
#line 872 "channels.c"
static int x11_open_helper(Buffer *b ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 879
  tmp = buffer_len(b);
#line 879
  if (tmp < 12U) {
#line 880
    return (0);
  }
#line 883
  tmp___0 = buffer_ptr(b);
#line 883
  ucp = (u_char *)tmp___0;
#line 884
  if ((int )*(ucp + 0) == 66) {
#line 885
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 886
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 887
    if ((int )*(ucp + 0) == 108) {
#line 888
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 889
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 891
      debug2("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 893
      return (-1);
    }
  }
#line 897
  tmp___1 = buffer_len(b);
#line 897
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 899
    return (0);
  }
#line 902
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 902
  if (proto_len != tmp___2) {
#line 904
    debug2("X11 connection uses different authentication protocol.");
#line 905
    return (-1);
  } else {
#line 902
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 902
    if (tmp___3 != 0) {
#line 904
      debug2("X11 connection uses different authentication protocol.");
#line 905
      return (-1);
    }
  }
#line 908
  if (data_len != x11_fake_data_len) {
#line 911
    debug2("X11 auth data does not match fake data.");
#line 912
    return (-1);
  } else {
#line 908
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 908
    if (tmp___4 != 0) {
#line 911
      debug2("X11 auth data does not match fake data.");
#line 912
      return (-1);
    }
  }
#line 915
  if (x11_fake_data_len != x11_saved_data_len) {
#line 916
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 918
    return (-1);
  }
#line 925
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 927
  return (1);
}
}
#line 930 "channels.c"
static void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret___0 ;
  int tmp ;

  {
#line 933
  tmp = x11_open_helper(& c->output);
#line 933
  ret___0 = tmp;
#line 935
  if (ret___0 == 1) {
#line 937
    c->type = 4;
#line 938
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 939
    if (ret___0 == -1) {
#line 944
      logit("X11 connection rejected because of wrong authentication.");
#line 945
      buffer_clear(& c->input);
#line 946
      buffer_clear(& c->output);
#line 947
      channel_close_fd(& c->sock);
#line 948
      c->sock = -1;
#line 949
      c->type = 5;
#line 950
      packet_start((unsigned char)24);
#line 951
      packet_put_int((unsigned int )c->remote_id);
#line 952
      packet_send();
    }
  }
#line 954
  return;
}
}
#line 956 "channels.c"
static void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret___0 ;
  int tmp ;

  {
#line 959
  tmp = x11_open_helper(& c->output);
#line 959
  ret___0 = tmp;
#line 963
  if (ret___0 == 1) {
#line 964
    c->type = 4;
#line 965
    channel_pre_open(c, readset, writeset);
  } else {
#line 966
    if (ret___0 == -1) {
#line 967
      logit("X11 connection rejected because of wrong authentication.");
#line 968
      debug2("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 969
      chan_read_failed(c);
#line 970
      buffer_clear(& c->input);
#line 971
      chan_ibuf_empty(c);
#line 972
      buffer_clear(& c->output);
#line 974
      if (compat20) {
#line 975
        chan_write_failed(c);
      } else {
#line 977
        c->type = 4;
      }
#line 978
      debug2("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 980
  return;
}
}
#line 984 "channels.c"
static int channel_decode_socks4(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char *p ;
  char *host ;
  u_int len ;
  u_int have ;
  u_int i ;
  u_int found ;
  u_int need ;
  char username[256] ;
  struct __anonstruct_s4_req_60 s4_req ;
  struct __anonstruct_s4_req_60 s4_rsp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;
  char const   *tmp___2 ;

  {
#line 997
  debug2("channel %d: decode socks4", c->self);
#line 999
  have = buffer_len(& c->input);
#line 1000
  len = sizeof(s4_req);
#line 1001
  if (have < len) {
#line 1002
    return (0);
  }
#line 1003
  tmp = buffer_ptr(& c->input);
#line 1003
  p = (char *)tmp;
#line 1005
  need = 1U;
#line 1007
  if ((int )*(p + 4) == 0) {
#line 1007
    if ((int )*(p + 5) == 0) {
#line 1007
      if ((int )*(p + 6) == 0) {
#line 1007
        if ((int )*(p + 7) != 0) {
#line 1008
          debug2("channel %d: socks4a request", c->self);
#line 1010
          need = 2U;
        }
      }
    }
  }
#line 1013
  found = 0U;
#line 1013
  i = len;
#line 1013
  while (i < have) {
#line 1014
    if ((int )*(p + i) == 0) {
#line 1015
      found ++;
#line 1016
      if (found == need) {
#line 1017
        break;
      }
    }
#line 1019
    if (i > 1024U) {
#line 1021
      debug("channel %d: decode socks4: too long", c->self);
#line 1023
      return (-1);
    }
#line 1013
    i ++;
  }
#line 1026
  if (found < need) {
#line 1027
    return (0);
  }
#line 1028
  buffer_get(& c->input, (void *)((char *)(& s4_req.version)), 1U);
#line 1029
  buffer_get(& c->input, (void *)((char *)(& s4_req.command)), 1U);
#line 1030
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_port)), 2U);
#line 1031
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_addr)), 4U);
#line 1032
  have = buffer_len(& c->input);
#line 1033
  tmp___0 = buffer_ptr(& c->input);
#line 1033
  p = (char *)tmp___0;
#line 1034
  len = strlen((char const   *)p);
#line 1035
  debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
#line 1036
  len ++;
#line 1037
  if (len > have) {
#line 1038
    fatal("channel %d: decode socks4: len %d > have %d", c->self, len, have);
  }
#line 1040
  strlcpy(username, (char const   *)p, sizeof(username));
#line 1041
  buffer_consume(& c->input, len);
#line 1043
  if ((unsigned int )c->path != (unsigned int )((void *)0)) {
#line 1044
    xfree((void *)c->path);
#line 1045
    c->path = (char *)((void *)0);
  }
#line 1047
  if (need == 1U) {
#line 1048
    host = inet_ntoa(s4_req.dest_addr);
#line 1049
    c->path = xstrdup((char const   *)host);
  } else {
#line 1051
    have = buffer_len(& c->input);
#line 1052
    tmp___1 = buffer_ptr(& c->input);
#line 1052
    p = (char *)tmp___1;
#line 1053
    len = strlen((char const   *)p);
#line 1054
    debug2("channel %d: decode socks4a: host %s/%d", c->self, p, len);
#line 1056
    len ++;
#line 1057
    if (len > have) {
#line 1058
      fatal("channel %d: decode socks4a: len %d > have %d", c->self, len, have);
    }
#line 1060
    if (len > 1025U) {
#line 1061
      error("channel %d: hostname \"%.100s\" too long", c->self, p);
#line 1063
      return (-1);
    }
#line 1065
    c->path = xstrdup((char const   *)p);
#line 1066
    buffer_consume(& c->input, len);
  }
#line 1068
  __x = s4_req.dest_port;
#line 1068
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1068
  c->host_port = (int )__v;
#line 1070
  debug2("channel %d: dynamic request: socks4 host %s port %u command %u", c->self,
         c->path, c->host_port, s4_req.command);
#line 1073
  if ((int )s4_req.command != 1) {
#line 1074
    if (need == 1U) {
#line 1074
      tmp___2 = "SOCKS4";
    } else {
#line 1074
      tmp___2 = "SOCKS4A";
    }
#line 1074
    debug("channel %d: cannot handle: %s cn %d", c->self, tmp___2, s4_req.command);
#line 1076
    return (-1);
  }
#line 1078
  s4_rsp.version = (unsigned char)0;
#line 1079
  s4_rsp.command = (unsigned char)90;
#line 1080
  s4_rsp.dest_port = (unsigned short)0;
#line 1081
  s4_rsp.dest_addr.s_addr = 0U;
#line 1082
  buffer_append(& c->output, (void const   *)(& s4_rsp), sizeof(s4_rsp));
#line 1083
  return (1);
}
}
#line 1096 "channels.c"
static int channel_decode_socks5(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct __anonstruct_s5_req_61 s5_req ;
  struct __anonstruct_s5_req_61 s5_rsp ;
  u_int16_t dest_port ;
  u_char *p ;
  u_char dest_addr[256] ;
  u_char ntop[46] ;
  u_int have ;
  u_int need ;
  u_int i ;
  u_int found ;
  u_int nmethods ;
  u_int addrlen ;
  u_int af ;
  void *tmp ;
  char const   *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 1109
  debug2("channel %d: decode socks5", c->self);
#line 1110
  tmp = buffer_ptr(& c->input);
#line 1110
  p = (u_char *)tmp;
#line 1111
  if ((int )*(p + 0) != 5) {
#line 1112
    return (-1);
  }
#line 1113
  have = buffer_len(& c->input);
#line 1114
  if (! (c->flags & 4096)) {
#line 1116
    if (have < 2U) {
#line 1117
      return (0);
    }
#line 1118
    nmethods = (unsigned int )*(p + 1);
#line 1119
    if (have < nmethods + 2U) {
#line 1120
      return (0);
    }
#line 1122
    found = 0U;
#line 1122
    i = 2U;
#line 1122
    while (i < nmethods + 2U) {
#line 1123
      if ((int )*(p + i) == 0) {
#line 1124
        found = 1U;
#line 1125
        break;
      }
#line 1122
      i ++;
    }
#line 1128
    if (! found) {
#line 1129
      debug("channel %d: method SSH_SOCKS5_NOAUTH not found", c->self);
#line 1131
      return (-1);
    }
#line 1133
    buffer_consume(& c->input, nmethods + 2U);
#line 1134
    buffer_put_char(& c->output, 5);
#line 1135
    buffer_put_char(& c->output, 0);
#line 1136
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1137
    c->flags |= 4096;
#line 1138
    debug2("channel %d: socks5 auth done", c->self);
#line 1139
    return (0);
  }
#line 1141
  debug2("channel %d: socks5 post auth", c->self);
#line 1142
  if (have < sizeof(s5_req) + 1U) {
#line 1143
    return (0);
  }
#line 1144
  memcpy((void * __restrict  )(& s5_req), (void const   * __restrict  )p, sizeof(s5_req));
#line 1145
  if ((int )s5_req.version != 5) {
#line 1148
    debug2("channel %d: only socks5 connect supported", c->self);
#line 1149
    return (-1);
  } else {
#line 1145
    if ((int )s5_req.command != 1) {
#line 1148
      debug2("channel %d: only socks5 connect supported", c->self);
#line 1149
      return (-1);
    } else {
#line 1145
      if ((int )s5_req.reserved != 0) {
#line 1148
        debug2("channel %d: only socks5 connect supported", c->self);
#line 1149
        return (-1);
      }
    }
  }
#line 1151
  switch ((int )s5_req.atyp) {
  case 1: 
#line 1153
  addrlen = 4U;
#line 1154
  af = 2U;
#line 1155
  break;
  case 3: 
#line 1157
  addrlen = (unsigned int )*(p + sizeof(s5_req));
#line 1158
  af = 4294967295U;
#line 1159
  break;
  case 4: 
#line 1161
  addrlen = 16U;
#line 1162
  af = 10U;
#line 1163
  break;
  default: 
#line 1165
  debug2("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
#line 1166
  return (-1);
  }
#line 1168
  need = (sizeof(s5_req) + addrlen) + 2U;
#line 1169
  if ((int )s5_req.atyp == 3) {
#line 1170
    need ++;
  }
#line 1171
  if (have < need) {
#line 1172
    return (0);
  }
#line 1173
  buffer_consume(& c->input, sizeof(s5_req));
#line 1174
  if ((int )s5_req.atyp == 3) {
#line 1175
    buffer_consume(& c->input, 1U);
  }
#line 1176
  buffer_get(& c->input, (void *)((char *)(& dest_addr)), addrlen);
#line 1177
  buffer_get(& c->input, (void *)((char *)(& dest_port)), 2U);
#line 1178
  dest_addr[addrlen] = (unsigned char )'\000';
#line 1179
  if ((unsigned int )c->path != (unsigned int )((void *)0)) {
#line 1180
    xfree((void *)c->path);
#line 1181
    c->path = (char *)((void *)0);
  }
#line 1183
  if ((int )s5_req.atyp == 3) {
#line 1184
    if (addrlen >= 1025U) {
#line 1185
      error("channel %d: dynamic request: socks5 hostname \"%.100s\" too long", c->self,
            dest_addr);
#line 1187
      return (-1);
    }
#line 1189
    c->path = xstrdup((char const   *)(dest_addr));
  } else {
#line 1191
    tmp___0 = inet_ntop((int )af, (void const   * __restrict  )(dest_addr), (char * __restrict  )(ntop),
                        sizeof(ntop));
#line 1191
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 1192
      return (-1);
    }
#line 1193
    c->path = xstrdup((char const   *)(ntop));
  }
#line 1195
  __x = dest_port;
#line 1195
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1195
  c->host_port = (int )__v;
#line 1197
  debug2("channel %d: dynamic request: socks5 host %s port %u command %u", c->self,
         c->path, c->host_port, s5_req.command);
#line 1200
  s5_rsp.version = (unsigned char)5;
#line 1201
  s5_rsp.command = (unsigned char)0;
#line 1202
  s5_rsp.reserved = (unsigned char)0;
#line 1203
  s5_rsp.atyp = (unsigned char)1;
#line 1204
  ((struct in_addr *)(& dest_addr))->s_addr = 0U;
#line 1205
  dest_port = (unsigned short)0;
#line 1207
  buffer_append(& c->output, (void const   *)(& s5_rsp), sizeof(s5_rsp));
#line 1208
  buffer_append(& c->output, (void const   *)(& dest_addr), sizeof(struct in_addr ));
#line 1209
  buffer_append(& c->output, (void const   *)(& dest_port), sizeof(dest_port));
#line 1210
  return (1);
}
}
#line 1214 "channels.c"
static void channel_pre_dynamic(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  u_int have ;
  int ret___0 ;
  void *tmp ;

  {
#line 1221
  have = buffer_len(& c->input);
#line 1222
  c->delayed = 0;
#line 1223
  debug2("channel %d: pre_dynamic: have %d", c->self, have);
#line 1226
  if (have < 3U) {
#line 1228
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1229
    return;
  }
#line 1232
  tmp = buffer_ptr(& c->input);
#line 1232
  p = (u_char *)tmp;
#line 1233
  switch ((int )*(p + 0)) {
  case 4: 
#line 1235
  ret___0 = channel_decode_socks4(c, readset, writeset);
#line 1236
  break;
  case 5: 
#line 1238
  ret___0 = channel_decode_socks5(c, readset, writeset);
#line 1239
  break;
  default: 
#line 1241
  ret___0 = -1;
#line 1242
  break;
  }
#line 1244
  if (ret___0 < 0) {
#line 1245
    chan_mark_dead(c);
  } else {
#line 1246
    if (ret___0 == 0) {
#line 1247
      debug2("channel %d: pre_dynamic: need more", c->self);
#line 1249
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    } else {
#line 1252
      c->type = 3;
#line 1253
      port_open_helper(c, (char *)"direct-tcpip");
    }
  }
#line 1255
  return;
}
}
#line 1259 "channels.c"
static void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr_storage addr ;
  int newsock ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  register char __result ;

  {
#line 1269
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1269
  if (__result) {
#line 1270
    debug("X11 connection requested.");
#line 1271
    addrlen = sizeof(addr);
#line 1272
    newsock = accept(c->sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                     (socklen_t * __restrict  )(& addrlen));
#line 1273
    if (c->single_connection) {
#line 1274
      debug2("single_connection: closing X11 listener.");
#line 1275
      channel_close_fd(& c->sock);
#line 1276
      chan_mark_dead(c);
    }
#line 1278
    if (newsock < 0) {
#line 1279
      tmp = __errno_location();
#line 1279
      tmp___0 = strerror(*tmp);
#line 1279
      error("accept: %.100s", tmp___0);
#line 1280
      return;
    }
#line 1282
    set_nodelay(newsock);
#line 1283
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 1284
    remote_port = get_peer_port(newsock);
#line 1285
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 1288
    nc = channel_new((char *)"accepted x11 socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, buf___1, 1);
#line 1291
    if (compat20) {
#line 1292
      packet_start((unsigned char)90);
#line 1293
      packet_put_cstring("x11");
#line 1294
      packet_put_int((unsigned int )nc->self);
#line 1295
      packet_put_int(nc->local_window_max);
#line 1296
      packet_put_int(nc->local_maxpacket);
#line 1298
      packet_put_cstring((char const   *)remote_ipaddr);
#line 1299
      if (datafellows & 8) {
#line 1300
        debug2("ssh2 x11 bug compat mode");
      } else {
#line 1302
        packet_put_int((unsigned int )remote_port);
      }
#line 1304
      packet_send();
    } else {
#line 1306
      packet_start((unsigned char)27);
#line 1307
      packet_put_int((unsigned int )nc->self);
#line 1308
      tmp___1 = packet_get_protocol_flags();
#line 1308
      if (tmp___1 & 2U) {
#line 1310
        packet_put_cstring((char const   *)(buf___1));
      }
#line 1311
      packet_send();
    }
#line 1313
    xfree((void *)remote_ipaddr);
  }
#line 1315
  return;
}
}
#line 1317 "channels.c"
static void port_open_helper(Channel *c , char *rtype ) 
{ int direct ;
  char buf___1[1024] ;
  char *remote_ipaddr ;
  char *tmp ;
  int remote_port ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;

  {
#line 1322
  tmp = get_peer_ipaddr(c->sock);
#line 1322
  remote_ipaddr = tmp;
#line 1323
  tmp___0 = get_peer_port(c->sock);
#line 1323
  remote_port = tmp___0;
#line 1325
  if (0) {
#line 1325
    __s1_len = strlen((char const   *)rtype);
#line 1325
    __s2_len = strlen("direct-tcpip");
#line 1325
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 1325
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1325
        if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1325
          tmp___10 = 1;
        } else {
#line 1325
          if (__s2_len >= 4U) {
#line 1325
            tmp___10 = 1;
          } else {
#line 1325
            tmp___10 = 0;
          }
        }
      } else {
#line 1325
        tmp___10 = 0;
      }
    }
#line 1325
    if (tmp___10) {
#line 1325
      tmp___6 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
    } else {
#line 1325
      tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1325
      tmp___6 = tmp___9;
    }
  } else {
#line 1325
    tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1325
    tmp___6 = tmp___9;
  }
#line 1325
  direct = tmp___6 == 0;
#line 1327
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s: listening port %d for %.100s port %d, connect from %.200s port %d",
           rtype, c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 1333
  xfree((void *)c->remote_name);
#line 1334
  c->remote_name = xstrdup((char const   *)(buf___1));
#line 1336
  if (compat20) {
#line 1337
    packet_start((unsigned char)90);
#line 1338
    packet_put_cstring((char const   *)rtype);
#line 1339
    packet_put_int((unsigned int )c->self);
#line 1340
    packet_put_int(c->local_window_max);
#line 1341
    packet_put_int(c->local_maxpacket);
#line 1342
    if (direct) {
#line 1344
      packet_put_cstring((char const   *)c->path);
#line 1345
      packet_put_int((unsigned int )c->host_port);
    } else {
#line 1348
      packet_put_cstring((char const   *)c->path);
#line 1349
      packet_put_int((unsigned int )c->listening_port);
    }
#line 1352
    packet_put_cstring((char const   *)remote_ipaddr);
#line 1353
    packet_put_int((unsigned int )remote_port);
#line 1354
    packet_send();
  } else {
#line 1356
    packet_start((unsigned char)29);
#line 1357
    packet_put_int((unsigned int )c->self);
#line 1358
    packet_put_cstring((char const   *)c->path);
#line 1359
    packet_put_int((unsigned int )c->host_port);
#line 1360
    tmp___11 = packet_get_protocol_flags();
#line 1360
    if (tmp___11 & 2U) {
#line 1362
      packet_put_cstring((char const   *)c->remote_name);
    }
#line 1363
    packet_send();
  }
#line 1365
  xfree((void *)remote_ipaddr);
#line 1366
  return;
}
}
#line 1368 "channels.c"
static void channel_set_reuseaddr(int fd ) 
{ int on ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1371
  on = 1;
#line 1377
  tmp___1 = setsockopt(fd, 1, 2, (void const   *)(& on), sizeof(on));
#line 1377
  if (tmp___1 == -1) {
#line 1378
    tmp = __errno_location();
#line 1378
    tmp___0 = strerror(*tmp);
#line 1378
    error("setsockopt SO_REUSEADDR fd %d: %s", fd, tmp___0);
  }
#line 1379
  return;
}
}
#line 1385 "channels.c"
static void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr_storage addr ;
  int newsock ;
  int nextstate ;
  socklen_t addrlen ;
  char *rtype ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1394
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1394
  if (__result) {
#line 1395
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 1399
    if (c->type == 11) {
#line 1400
      nextstate = 3;
#line 1401
      rtype = (char *)"forwarded-tcpip";
    } else {
#line 1403
      if (c->host_port == 0) {
#line 1404
        nextstate = 13;
#line 1405
        rtype = (char *)"dynamic-tcpip";
      } else {
#line 1407
        nextstate = 3;
#line 1408
        rtype = (char *)"direct-tcpip";
      }
    }
#line 1412
    addrlen = sizeof(addr);
#line 1413
    newsock = accept(c->sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                     (socklen_t * __restrict  )(& addrlen));
#line 1414
    if (newsock < 0) {
#line 1415
      tmp = __errno_location();
#line 1415
      tmp___0 = strerror(*tmp);
#line 1415
      error("accept: %.100s", tmp___0);
#line 1416
      return;
    }
#line 1418
    set_nodelay(newsock);
#line 1419
    nc = channel_new(rtype, nextstate, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, rtype, 1);
#line 1421
    nc->listening_port = c->listening_port;
#line 1422
    nc->host_port = c->host_port;
#line 1423
    if ((unsigned int )c->path != (unsigned int )((void *)0)) {
#line 1424
      nc->path = xstrdup((char const   *)c->path);
    }
#line 1426
    if (nextstate == 13) {
#line 1432
      nc->delayed = 1;
    } else {
#line 1434
      port_open_helper(nc, rtype);
    }
  }
#line 1437
  return;
}
}
#line 1444 "channels.c"
static void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  int newsock ;
  struct sockaddr_storage addr ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1452
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1452
  if (__result) {
#line 1453
    addrlen = sizeof(addr);
#line 1454
    newsock = accept(c->sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                     (socklen_t * __restrict  )(& addrlen));
#line 1455
    if (newsock < 0) {
#line 1456
      tmp = __errno_location();
#line 1456
      tmp___0 = strerror(*tmp);
#line 1456
      error("accept from auth socket: %.100s", tmp___0);
#line 1457
      return;
    }
#line 1459
    nc = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, (char *)"accepted auth socket", 1);
#line 1463
    if (compat20) {
#line 1464
      packet_start((unsigned char)90);
#line 1465
      packet_put_cstring("auth-agent@openssh.com");
#line 1466
      packet_put_int((unsigned int )nc->self);
#line 1467
      packet_put_int(c->local_window_max);
#line 1468
      packet_put_int(c->local_maxpacket);
    } else {
#line 1470
      packet_start((unsigned char)31);
#line 1471
      packet_put_int((unsigned int )nc->self);
    }
#line 1473
    packet_send();
  }
#line 1475
  return;
}
}
#line 1478 "channels.c"
static void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  int sock ;
  socklen_t sz ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register char __result ;

  {
#line 1481
  err = 0;
#line 1482
  sz = sizeof(err);
#line 1484
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1484
  if (__result) {
#line 1485
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )(& err), (socklen_t * __restrict  )(& sz));
#line 1485
    if (tmp___0 < 0) {
#line 1486
      tmp = __errno_location();
#line 1486
      err = *tmp;
#line 1487
      error("getsockopt SO_ERROR failed");
    }
#line 1489
    if (err == 0) {
#line 1490
      debug("channel %d: connected to %s port %d", c->self, c->connect_ctx.host, c->connect_ctx.port);
#line 1492
      channel_connect_ctx_free(& c->connect_ctx);
#line 1493
      c->type = 4;
#line 1494
      if (compat20) {
#line 1495
        packet_start((unsigned char)91);
#line 1496
        packet_put_int((unsigned int )c->remote_id);
#line 1497
        packet_put_int((unsigned int )c->self);
#line 1498
        packet_put_int(c->local_window);
#line 1499
        packet_put_int(c->local_maxpacket);
      } else {
#line 1501
        packet_start((unsigned char)21);
#line 1502
        packet_put_int((unsigned int )c->remote_id);
#line 1503
        packet_put_int((unsigned int )c->self);
      }
    } else {
#line 1506
      tmp___1 = strerror(err);
#line 1506
      debug("channel %d: connection failed: %s", c->self, tmp___1);
#line 1509
      sock = connect_next(& c->connect_ctx);
#line 1509
      if (sock > 0) {
#line 1510
        close(c->sock);
#line 1511
        c->wfd = sock;
#line 1511
        c->rfd = c->wfd;
#line 1511
        c->sock = c->rfd;
#line 1512
        channel_max_fd = channel_find_maxfd();
#line 1513
        return;
      }
#line 1516
      error("connect_to %.100s port %d: failed.", c->connect_ctx.host, c->connect_ctx.port);
#line 1518
      channel_connect_ctx_free(& c->connect_ctx);
#line 1519
      if (compat20) {
#line 1520
        packet_start((unsigned char)92);
#line 1521
        packet_put_int((unsigned int )c->remote_id);
#line 1522
        packet_put_int(2U);
#line 1523
        if (! (datafellows & 131072)) {
#line 1524
          tmp___2 = strerror(err);
#line 1524
          packet_put_cstring((char const   *)tmp___2);
#line 1525
          packet_put_cstring("");
        }
      } else {
#line 1528
        packet_start((unsigned char)22);
#line 1529
        packet_put_int((unsigned int )c->remote_id);
      }
#line 1531
      chan_mark_dead(c);
    }
#line 1533
    packet_send();
  }
#line 1535
  return;
}
}
#line 1538 "channels.c"
static int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int force ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  register char __result ;

  {
#line 1544
  if (c->isatty) {
#line 1544
    if (c->detach_close) {
#line 1544
      if (c->istate != 3U) {
#line 1544
        tmp = 1;
      } else {
#line 1544
        tmp = 0;
      }
    } else {
#line 1544
      tmp = 0;
    }
  } else {
#line 1544
    tmp = 0;
  }
#line 1544
  force = tmp;
#line 1545
  if (c->rfd != -1) {
#line 1545
    if (force) {
      goto _L___0;
    } else {
#line 1545
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                           "m" (readset->fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1545
      if (__result) {
        _L___0: /* CIL Label */ 
#line 1546
        tmp___0 = __errno_location();
#line 1546
        *tmp___0 = 0;
#line 1547
        len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 1548
        if (len < 0) {
#line 1548
          tmp___1 = __errno_location();
#line 1548
          if (*tmp___1 == 4) {
#line 1550
            return (1);
          } else {
#line 1548
            tmp___2 = __errno_location();
#line 1548
            if (*tmp___2 == 11) {
              goto _L;
            } else {
#line 1548
              tmp___3 = __errno_location();
#line 1548
              if (*tmp___3 == 11) {
                _L: /* CIL Label */ 
#line 1548
                if (! force) {
#line 1550
                  return (1);
                }
              }
            }
          }
        }
#line 1552
        if (len <= 0) {
#line 1557
          debug2("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 1559
          if (c->type != 4) {
#line 1560
            debug2("channel %d: not open", c->self);
#line 1561
            chan_mark_dead(c);
#line 1562
            return (-1);
          } else {
#line 1563
            if (compat13) {
#line 1564
              buffer_clear(& c->output);
#line 1565
              c->type = 8;
#line 1566
              debug2("channel %d: input draining.", c->self);
            } else {
#line 1568
              chan_read_failed(c);
            }
          }
#line 1570
          return (-1);
        }
#line 1572
        if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 1573
          tmp___4 = (*(c->input_filter))(c, buf___1, len);
#line 1573
          if (tmp___4 == -1) {
#line 1574
            debug2("channel %d: filter stops", c->self);
#line 1575
            chan_read_failed(c);
          }
        } else {
#line 1577
          if (c->datagram) {
#line 1578
            buffer_put_string(& c->input, (void const   *)(buf___1), (unsigned int )len);
          } else {
#line 1580
            buffer_append(& c->input, (void const   *)(buf___1), (unsigned int )len);
          }
        }
      }
    }
  }
#line 1583
  return (1);
}
}
#line 1587 "channels.c"
static int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_char *buf___1 ;
  u_int dlen ;
  int len ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  register char __result ;
  u_int tmp___8 ;

  {
#line 1591
  data = (u_char *)((void *)0);
#line 1597
  if (c->wfd != -1) {
#line 1597
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1597
    if (__result) {
#line 1597
      tmp___8 = buffer_len(& c->output);
#line 1597
      if (tmp___8 > 0U) {
#line 1599
        if ((unsigned int )c->output_filter != (unsigned int )((void *)0)) {
#line 1600
          buf___1 = (*(c->output_filter))(c, & data, & dlen);
#line 1600
          if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 1601
            debug2("channel %d: filter stops", c->self);
#line 1602
            if (c->type != 4) {
#line 1603
              chan_mark_dead(c);
            } else {
#line 1605
              chan_write_failed(c);
            }
#line 1606
            return (-1);
          }
        } else {
#line 1608
          if (c->datagram) {
#line 1609
            tmp = buffer_get_string(& c->output, & dlen);
#line 1609
            data = (u_char *)tmp;
#line 1609
            buf___1 = data;
          } else {
#line 1611
            tmp___0 = buffer_ptr(& c->output);
#line 1611
            data = (u_char *)tmp___0;
#line 1611
            buf___1 = data;
#line 1612
            dlen = buffer_len(& c->output);
          }
        }
#line 1615
        if (c->datagram) {
#line 1617
          c->local_consumed += dlen + 4U;
#line 1618
          len = write(c->wfd, (void const   *)buf___1, dlen);
#line 1619
          xfree((void *)data);
#line 1620
          if (len < 0) {
#line 1620
            tmp___1 = __errno_location();
#line 1620
            if (*tmp___1 == 4) {
#line 1622
              return (1);
            } else {
#line 1620
              tmp___2 = __errno_location();
#line 1620
              if (*tmp___2 == 11) {
#line 1622
                return (1);
              } else {
#line 1620
                tmp___3 = __errno_location();
#line 1620
                if (*tmp___3 == 11) {
#line 1622
                  return (1);
                }
              }
            }
          }
#line 1623
          if (len <= 0) {
#line 1624
            if (c->type != 4) {
#line 1625
              chan_mark_dead(c);
            } else {
#line 1627
              chan_write_failed(c);
            }
#line 1628
            return (-1);
          }
#line 1630
          return (1);
        }
#line 1638
        len = write(c->wfd, (void const   *)buf___1, dlen);
#line 1639
        if (len < 0) {
#line 1639
          tmp___4 = __errno_location();
#line 1639
          if (*tmp___4 == 4) {
#line 1641
            return (1);
          } else {
#line 1639
            tmp___5 = __errno_location();
#line 1639
            if (*tmp___5 == 11) {
#line 1641
              return (1);
            } else {
#line 1639
              tmp___6 = __errno_location();
#line 1639
              if (*tmp___6 == 11) {
#line 1641
                return (1);
              }
            }
          }
        }
#line 1642
        if (len <= 0) {
#line 1643
          if (c->type != 4) {
#line 1644
            debug2("channel %d: not open", c->self);
#line 1645
            chan_mark_dead(c);
#line 1646
            return (-1);
          } else {
#line 1647
            if (compat13) {
#line 1648
              buffer_clear(& c->output);
#line 1649
              debug2("channel %d: input draining.", c->self);
#line 1650
              c->type = 8;
            } else {
#line 1652
              chan_write_failed(c);
            }
          }
#line 1654
          return (-1);
        }
#line 1656
        if (compat20) {
#line 1656
          if (c->isatty) {
#line 1656
            if (dlen >= 1U) {
#line 1656
              if ((int )*(buf___1 + 0) != 13) {
#line 1657
                tmp___7 = tcgetattr(c->wfd, & tio);
#line 1657
                if (tmp___7 == 0) {
#line 1657
                  if (! (tio.c_lflag & 8U)) {
#line 1657
                    if (tio.c_lflag & 2U) {
#line 1665
                      packet_send_ignore(4 + len);
#line 1666
                      packet_send();
                    }
                  }
                }
              }
            }
          }
        }
#line 1669
        buffer_consume(& c->output, (unsigned int )len);
#line 1670
        if (compat20) {
#line 1670
          if (len > 0) {
#line 1671
            c->local_consumed += (u_int )len;
          }
        }
      }
    }
  }
#line 1674
  return (1);
}
}
#line 1677 "channels.c"
static int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___7 ;

  {
#line 1684
  if (c->efd != -1) {
#line 1686
    if (c->extended_usage == 2) {
#line 1686
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1686
      if (__result___0) {
#line 1686
        tmp___7 = buffer_len(& c->extended);
#line 1686
        if (tmp___7 > 0U) {
#line 1688
          tmp = buffer_len(& c->extended);
#line 1688
          tmp___0 = buffer_ptr(& c->extended);
#line 1688
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 1690
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 1692
          if (len < 0) {
#line 1692
            tmp___1 = __errno_location();
#line 1692
            if (*tmp___1 == 4) {
#line 1694
              return (1);
            } else {
#line 1692
              tmp___2 = __errno_location();
#line 1692
              if (*tmp___2 == 11) {
#line 1694
                return (1);
              } else {
#line 1692
                tmp___3 = __errno_location();
#line 1692
                if (*tmp___3 == 11) {
#line 1694
                  return (1);
                }
              }
            }
          }
#line 1695
          if (len <= 0) {
#line 1696
            debug2("channel %d: closing write-efd %d", c->self, c->efd);
#line 1698
            channel_close_fd(& c->efd);
          } else {
#line 1700
            buffer_consume(& c->extended, (unsigned int )len);
#line 1701
            c->local_consumed += (u_int )len;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 1704
      if (c->extended_usage == 1) {
#line 1704
        if (c->detach_close) {
          goto _L___0;
        } else {
#line 1704
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                               "m" (readset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1704
          if (__result) {
            _L___0: /* CIL Label */ 
#line 1705
            len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 1706
            debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 1708
            if (len < 0) {
#line 1708
              tmp___4 = __errno_location();
#line 1708
              if (*tmp___4 == 4) {
#line 1710
                return (1);
              } else {
#line 1708
                tmp___5 = __errno_location();
#line 1708
                if (*tmp___5 == 11) {
                  goto _L;
                } else {
#line 1708
                  tmp___6 = __errno_location();
#line 1708
                  if (*tmp___6 == 11) {
                    _L: /* CIL Label */ 
#line 1708
                    if (! c->detach_close) {
#line 1710
                      return (1);
                    }
                  }
                }
              }
            }
#line 1711
            if (len <= 0) {
#line 1712
              debug2("channel %d: closing read-efd %d", c->self, c->efd);
#line 1714
              channel_close_fd(& c->efd);
            } else {
#line 1716
              buffer_append(& c->extended, (void const   *)(buf___1), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 1720
  return (1);
}
}
#line 1724 "channels.c"
static int channel_handle_ctl(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  register char __result ;

  {
#line 1731
  if (c->ctl_fd != -1) {
#line 1731
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->ctl_fd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )c->ctl_fd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1731
    if (__result) {
#line 1732
      len = read(c->ctl_fd, (void *)(buf___1), sizeof(buf___1));
#line 1733
      if (len < 0) {
#line 1733
        tmp = __errno_location();
#line 1733
        if (*tmp == 4) {
#line 1735
          return (1);
        } else {
#line 1733
          tmp___0 = __errno_location();
#line 1733
          if (*tmp___0 == 11) {
#line 1735
            return (1);
          } else {
#line 1733
            tmp___1 = __errno_location();
#line 1733
            if (*tmp___1 == 11) {
#line 1735
              return (1);
            }
          }
        }
      }
#line 1736
      if (len <= 0) {
#line 1737
        debug2("channel %d: ctl read<=0", c->self);
#line 1738
        if (c->type != 4) {
#line 1739
          debug2("channel %d: not open", c->self);
#line 1740
          chan_mark_dead(c);
#line 1741
          return (-1);
        } else {
#line 1743
          chan_read_failed(c);
#line 1744
          chan_write_failed(c);
        }
#line 1746
        return (-1);
      } else {
#line 1748
        fatal("%s: unexpected data on ctl fd", "channel_handle_ctl");
      }
    }
  }
#line 1750
  return (1);
}
}
#line 1753 "channels.c"
static int channel_check_window(Channel *c ) 
{ 

  {
#line 1756
  if (c->type == 4) {
#line 1756
    if (! (c->flags & 3)) {
#line 1756
      if (c->local_window_max - c->local_window > c->local_maxpacket * 3U) {
        goto _L;
      } else {
#line 1756
        if (c->local_window < c->local_window_max / 2U) {
          _L: /* CIL Label */ 
#line 1756
          if (c->local_consumed > 0U) {
#line 1762
            packet_start((unsigned char)93);
#line 1763
            packet_put_int((unsigned int )c->remote_id);
#line 1764
            packet_put_int(c->local_consumed);
#line 1765
            packet_send();
#line 1766
            debug2("channel %d: window %d sent adjust %d", c->self, c->local_window,
                   c->local_consumed);
#line 1769
            c->local_window += c->local_consumed;
#line 1770
            c->local_consumed = 0U;
          }
        }
      }
    }
  }
#line 1772
  return (1);
}
}
#line 1775 "channels.c"
static void channel_post_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1778
  if (c->delayed) {
#line 1779
    return;
  }
#line 1780
  channel_handle_rfd(c, readset, writeset);
#line 1781
  channel_handle_wfd(c, readset, writeset);
#line 1782
  if (! compat20) {
#line 1783
    return;
  }
#line 1784
  channel_handle_efd(c, readset, writeset);
#line 1785
  channel_handle_ctl(c, readset, writeset);
#line 1786
  channel_check_window(c);
#line 1787
  return;
}
}
#line 1790 "channels.c"
static void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  register char __result ;
  u_int tmp___1 ;

  {
#line 1796
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1796
  if (__result) {
#line 1796
    tmp___1 = buffer_len(& c->output);
#line 1796
    if (tmp___1 > 0U) {
#line 1797
      tmp = buffer_len(& c->output);
#line 1797
      tmp___0 = buffer_ptr(& c->output);
#line 1797
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 1799
      if (len <= 0) {
#line 1800
        buffer_clear(& c->output);
      } else {
#line 1802
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 1804
  return;
}
}
#line 1806 "channels.c"
static void channel_handler_init_20(void) 
{ 

  {
#line 1809
  channel_pre[4] = & channel_pre_open;
#line 1810
  channel_pre[7] = & channel_pre_x11_open;
#line 1811
  channel_pre[2] = & channel_pre_listener;
#line 1812
  channel_pre[11] = & channel_pre_listener;
#line 1813
  channel_pre[1] = & channel_pre_listener;
#line 1814
  channel_pre[6] = & channel_pre_listener;
#line 1815
  channel_pre[12] = & channel_pre_connecting;
#line 1816
  channel_pre[13] = & channel_pre_dynamic;
#line 1818
  channel_post[4] = & channel_post_open;
#line 1819
  channel_post[2] = & channel_post_port_listener;
#line 1820
  channel_post[11] = & channel_post_port_listener;
#line 1821
  channel_post[1] = & channel_post_x11_listener;
#line 1822
  channel_post[6] = & channel_post_auth_listener;
#line 1823
  channel_post[12] = & channel_post_connecting;
#line 1824
  channel_post[13] = & channel_post_open;
#line 1825
  return;
}
}
#line 1827 "channels.c"
static void channel_handler_init_13(void) 
{ 

  {
#line 1830
  channel_pre[4] = & channel_pre_open_13;
#line 1831
  channel_pre[7] = & channel_pre_x11_open_13;
#line 1832
  channel_pre[1] = & channel_pre_listener;
#line 1833
  channel_pre[2] = & channel_pre_listener;
#line 1834
  channel_pre[6] = & channel_pre_listener;
#line 1835
  channel_pre[8] = & channel_pre_input_draining;
#line 1836
  channel_pre[9] = & channel_pre_output_draining;
#line 1837
  channel_pre[12] = & channel_pre_connecting;
#line 1838
  channel_pre[13] = & channel_pre_dynamic;
#line 1840
  channel_post[4] = & channel_post_open;
#line 1841
  channel_post[1] = & channel_post_x11_listener;
#line 1842
  channel_post[2] = & channel_post_port_listener;
#line 1843
  channel_post[6] = & channel_post_auth_listener;
#line 1844
  channel_post[9] = & channel_post_output_drain_13;
#line 1845
  channel_post[12] = & channel_post_connecting;
#line 1846
  channel_post[13] = & channel_post_open;
#line 1847
  return;
}
}
#line 1849 "channels.c"
static void channel_handler_init_15(void) 
{ 

  {
#line 1852
  channel_pre[4] = & channel_pre_open;
#line 1853
  channel_pre[7] = & channel_pre_x11_open;
#line 1854
  channel_pre[1] = & channel_pre_listener;
#line 1855
  channel_pre[2] = & channel_pre_listener;
#line 1856
  channel_pre[6] = & channel_pre_listener;
#line 1857
  channel_pre[12] = & channel_pre_connecting;
#line 1858
  channel_pre[13] = & channel_pre_dynamic;
#line 1860
  channel_post[1] = & channel_post_x11_listener;
#line 1861
  channel_post[2] = & channel_post_port_listener;
#line 1862
  channel_post[6] = & channel_post_auth_listener;
#line 1863
  channel_post[4] = & channel_post_open;
#line 1864
  channel_post[12] = & channel_post_connecting;
#line 1865
  channel_post[13] = & channel_post_open;
#line 1866
  return;
}
}
#line 1868 "channels.c"
static void channel_handler_init(void) 
{ int i ;

  {
#line 1873
  i = 0;
#line 1873
  while (i < 15) {
#line 1874
    channel_pre[i] = (chan_fn *)((void *)0);
#line 1875
    channel_post[i] = (chan_fn *)((void *)0);
#line 1873
    i ++;
  }
#line 1877
  if (compat20) {
#line 1878
    channel_handler_init_20();
  } else {
#line 1879
    if (compat13) {
#line 1880
      channel_handler_init_13();
    } else {
#line 1882
      channel_handler_init_15();
    }
  }
#line 1883
  return;
}
}
#line 1886 "channels.c"
static void channel_garbage_collect(Channel *c ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1889
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1890
    return;
  }
#line 1891
  if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1892
    tmp = chan_is_dead(c, c->detach_close);
#line 1892
    if (! tmp) {
#line 1893
      return;
    }
#line 1894
    debug2("channel %d: gc: notify user", c->self);
#line 1895
    (*(c->detach_user))(c->self, (void *)0);
#line 1897
    if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1898
      return;
    }
#line 1899
    debug2("channel %d: gc: user detached", c->self);
  }
#line 1901
  tmp___0 = chan_is_dead(c, 1);
#line 1901
  if (! tmp___0) {
#line 1902
    return;
  }
#line 1903
  debug2("channel %d: garbage collecting", c->self);
#line 1904
  channel_free(c);
#line 1905
  return;
}
}
#line 1910
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 1910 "channels.c"
static int did_init  =    0;
#line 1907 "channels.c"
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ u_int i ;
  Channel *c ;

  {
#line 1914
  if (! did_init) {
#line 1915
    channel_handler_init();
#line 1916
    did_init = 1;
  }
#line 1918
  i = 0U;
#line 1918
  while (i < channels_alloc) {
#line 1919
    c = *(channels + i);
#line 1920
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1922
    if ((unsigned int )*(ftab + c->type) != (unsigned int )((void *)0)) {
#line 1923
      (*(*(ftab + c->type)))(c, readset, writeset);
    }
#line 1924
    channel_garbage_collect(c);
    __Cont: /* CIL Label */ 
#line 1918
    i ++;
  }
#line 1926
  return;
}
}
#line 1932 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            u_int *nallocp , int rekeying___0 ) 
{ u_int n___0 ;
  u_int sz ;
  u_int nfdset ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1938
  if (*maxfdp > channel_max_fd) {
#line 1938
    n___0 = (unsigned int )*maxfdp;
  } else {
#line 1938
    n___0 = (unsigned int )channel_max_fd;
  }
#line 1940
  nfdset = ((n___0 + 1U) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ));
#line 1942
  if (nfdset) {
#line 1942
    if (4294967295UL / (unsigned long )nfdset < (unsigned long )sizeof(fd_mask )) {
#line 1943
      fatal("channel_prepare_select: max_fd (%d) is too large", n___0);
    }
  }
#line 1944
  sz = nfdset * sizeof(fd_mask );
#line 1947
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
#line 1948
    tmp = xrealloc((void *)*readsetp, nfdset, sizeof(fd_mask ));
#line 1948
    *readsetp = (fd_set *)tmp;
#line 1949
    tmp___0 = xrealloc((void *)*writesetp, nfdset, sizeof(fd_mask ));
#line 1949
    *writesetp = (fd_set *)tmp___0;
#line 1950
    *nallocp = sz;
  } else {
#line 1947
    if (sz > *nallocp) {
#line 1948
      tmp = xrealloc((void *)*readsetp, nfdset, sizeof(fd_mask ));
#line 1948
      *readsetp = (fd_set *)tmp;
#line 1949
      tmp___0 = xrealloc((void *)*writesetp, nfdset, sizeof(fd_mask ));
#line 1949
      *writesetp = (fd_set *)tmp___0;
#line 1950
      *nallocp = sz;
    }
  }
#line 1952
  *maxfdp = (int )n___0;
#line 1953
  memset((void *)*readsetp, 0, sz);
#line 1954
  memset((void *)*writesetp, 0, sz);
#line 1956
  if (! rekeying___0) {
#line 1957
    channel_handler(channel_pre, *readsetp, *writesetp);
  }
#line 1958
  return;
}
}
#line 1964 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1967
  channel_handler(channel_post, readset, writeset);
#line 1968
  return;
}
}
#line 1972 "channels.c"
void channel_output_poll(void) 
{ Channel *c ;
  u_int i ;
  u_int len ;
  u_char *data ;
  u_int dlen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;

  {
#line 1978
  i = 0U;
#line 1978
  while (i < channels_alloc) {
#line 1979
    c = *(channels + i);
#line 1980
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1987
    if (compat13) {
#line 1988
      if (c->type != 4) {
#line 1988
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1992
      if (c->type != 4) {
        goto __Cont;
      }
    }
#line 1995
    if (compat20) {
#line 1995
      if (c->flags & 3) {
#line 1998
        debug3("channel %d: will not send data after close", c->self);
        goto __Cont;
      }
    }
#line 2003
    if (c->istate == 0U) {
      goto _L___0;
    } else {
#line 2003
      if (c->istate == 1U) {
        _L___0: /* CIL Label */ 
#line 2003
        len = buffer_len(& c->input);
#line 2003
        if (len > 0U) {
#line 2006
          if (c->datagram) {
#line 2007
            if (len > 0U) {
#line 2011
              tmp = buffer_get_string(& c->input, & dlen);
#line 2011
              data = (u_char *)tmp;
#line 2013
              packet_start((unsigned char)94);
#line 2014
              packet_put_int((unsigned int )c->remote_id);
#line 2015
              packet_put_string((void const   *)data, dlen);
#line 2016
              packet_send();
#line 2017
              c->remote_window -= dlen + 4U;
#line 2018
              xfree((void *)data);
            }
            goto __Cont;
          }
#line 2026
          if (compat20) {
#line 2027
            if (len > c->remote_window) {
#line 2028
              len = c->remote_window;
            }
#line 2029
            if (len > c->remote_maxpacket) {
#line 2030
              len = c->remote_maxpacket;
            }
          } else {
#line 2032
            tmp___0 = packet_is_interactive();
#line 2032
            if (tmp___0) {
#line 2033
              if (len > 1024U) {
#line 2034
                len = 512U;
              }
            } else {
#line 2037
              if (len > max_packet_size / 2U) {
#line 2038
                len = max_packet_size / 2U;
              }
            }
          }
#line 2041
          if (len > 0U) {
#line 2042
            if (compat20) {
#line 2042
              tmp___1 = 94;
            } else {
#line 2042
              tmp___1 = 23;
            }
#line 2042
            packet_start((unsigned char )tmp___1);
#line 2044
            packet_put_int((unsigned int )c->remote_id);
#line 2045
            tmp___2 = buffer_ptr(& c->input);
#line 2045
            packet_put_string((void const   *)tmp___2, len);
#line 2046
            packet_send();
#line 2047
            buffer_consume(& c->input, len);
#line 2048
            c->remote_window -= len;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 2050
        if (c->istate == 1U) {
#line 2051
          if (compat13) {
#line 2052
            fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
          }
#line 2058
          if (compat20) {
#line 2058
            if (c->extended_usage == 1) {
#line 2058
              if (c->efd != -1) {
#line 2059
                tmp___3 = buffer_len(& c->extended);
#line 2059
                debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                       tmp___3);
              } else {
#line 2058
                tmp___4 = buffer_len(& c->extended);
#line 2058
                if (tmp___4 > 0U) {
#line 2059
                  tmp___3 = buffer_len(& c->extended);
#line 2059
                  debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___3);
                } else {
#line 2062
                  chan_ibuf_empty(c);
                }
              }
            } else {
#line 2062
              chan_ibuf_empty(c);
            }
          } else {
#line 2062
            chan_ibuf_empty(c);
          }
        }
      }
    }
#line 2065
    if (compat20) {
#line 2065
      if (! (c->flags & 4)) {
#line 2065
        if (c->remote_window > 0U) {
#line 2065
          len = buffer_len(& c->extended);
#line 2065
          if (len > 0U) {
#line 2065
            if (c->extended_usage == 1) {
#line 2070
              tmp___5 = buffer_len(& c->extended);
#line 2070
              debug2("channel %d: rwin %u elen %u euse %d", c->self, c->remote_window,
                     tmp___5, c->extended_usage);
#line 2073
              if (len > c->remote_window) {
#line 2074
                len = c->remote_window;
              }
#line 2075
              if (len > c->remote_maxpacket) {
#line 2076
                len = c->remote_maxpacket;
              }
#line 2077
              packet_start((unsigned char)95);
#line 2078
              packet_put_int((unsigned int )c->remote_id);
#line 2079
              packet_put_int(1U);
#line 2080
              tmp___6 = buffer_ptr(& c->extended);
#line 2080
              packet_put_string((void const   *)tmp___6, len);
#line 2081
              packet_send();
#line 2082
              buffer_consume(& c->extended, len);
#line 2083
              c->remote_window -= len;
#line 2084
              debug2("channel %d: sent ext data %d", c->self, len);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1978
    i ++;
  }
#line 2087
  return;
}
}
#line 2093 "channels.c"
void channel_input_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2102
  tmp = packet_get_int();
#line 2102
  id = (int )tmp;
#line 2103
  c = channel_lookup(id);
#line 2104
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2105
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 2108
  if (c->type != 4) {
#line 2108
    if (c->type != 7) {
#line 2110
      return;
    }
  }
#line 2113
  tmp___0 = packet_get_string_ptr(& data_len);
#line 2113
  data = (char *)tmp___0;
#line 2122
  if (! compat13) {
#line 2122
    if (c->ostate != 0U) {
#line 2123
      if (compat20) {
#line 2124
        c->local_window -= data_len;
#line 2125
        c->local_consumed += data_len;
      }
#line 2127
      return;
    }
  }
#line 2130
  if (compat20) {
#line 2131
    if (data_len > c->local_maxpacket) {
#line 2132
      logit("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 2135
    if (data_len > c->local_window) {
#line 2136
      logit("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 2138
      return;
    }
#line 2140
    c->local_window -= data_len;
  }
#line 2142
  if (c->datagram) {
#line 2143
    buffer_put_string(& c->output, (void const   *)data, data_len);
  } else {
#line 2145
    buffer_append(& c->output, (void const   *)data, data_len);
  }
#line 2146
  while (1) {
#line 2146
    tmp___1 = packet_remaining();
#line 2146
    _len = tmp___1;
#line 2146
    if (_len > 0) {
#line 2146
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2146);
#line 2146
      packet_disconnect("Packet integrity error.");
    }
#line 2146
    break;
  }
#line 2147
  return;
}
}
#line 2150 "channels.c"
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  u_int tcode ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2159
  tmp = packet_get_int();
#line 2159
  id = (int )tmp;
#line 2160
  c = channel_lookup(id);
#line 2162
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2163
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 2164
  if (c->type != 4) {
#line 2165
    logit("channel %d: ext data for non open", id);
#line 2166
    return;
  }
#line 2168
  if (c->flags & 8) {
#line 2169
    if (datafellows & 2097152) {
#line 2170
      debug("channel %d: accepting ext data after eof", id);
    } else {
#line 2172
      packet_disconnect("Received extended_data after EOF on channel %d.", id);
    }
  }
#line 2175
  tcode = packet_get_int();
#line 2176
  if (c->efd == -1) {
#line 2179
    logit("channel %d: bad ext data", c->self);
#line 2180
    return;
  } else {
#line 2176
    if (c->extended_usage != 2) {
#line 2179
      logit("channel %d: bad ext data", c->self);
#line 2180
      return;
    } else {
#line 2176
      if (tcode != 1U) {
#line 2179
        logit("channel %d: bad ext data", c->self);
#line 2180
        return;
      }
    }
  }
#line 2182
  tmp___0 = packet_get_string(& data_len);
#line 2182
  data = (char *)tmp___0;
#line 2183
  while (1) {
#line 2183
    tmp___1 = packet_remaining();
#line 2183
    _len = tmp___1;
#line 2183
    if (_len > 0) {
#line 2183
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2183);
#line 2183
      packet_disconnect("Packet integrity error.");
    }
#line 2183
    break;
  }
#line 2184
  if (data_len > c->local_window) {
#line 2185
    logit("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len,
          c->local_window);
#line 2187
    xfree((void *)data);
#line 2188
    return;
  }
#line 2190
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 2191
  c->local_window -= data_len;
#line 2192
  buffer_append(& c->extended, (void const   *)data, data_len);
#line 2193
  xfree((void *)data);
#line 2194
  return;
}
}
#line 2197 "channels.c"
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 2203
  tmp = packet_get_int();
#line 2203
  id = (int )tmp;
#line 2204
  while (1) {
#line 2204
    tmp___0 = packet_remaining();
#line 2204
    _len = tmp___0;
#line 2204
    if (_len > 0) {
#line 2204
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2204);
#line 2204
      packet_disconnect("Packet integrity error.");
    }
#line 2204
    break;
  }
#line 2205
  c = channel_lookup(id);
#line 2206
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2207
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 2208
  chan_rcvd_ieof(c);
#line 2211
  if (c->force_drain) {
#line 2211
    if (c->istate == 0U) {
#line 2212
      debug("channel %d: FORCE input drain", c->self);
#line 2213
      c->istate = 1U;
#line 2214
      tmp___1 = buffer_len(& c->input);
#line 2214
      if (tmp___1 == 0U) {
#line 2215
        chan_ibuf_empty(c);
      }
    }
  }
#line 2218
  return;
}
}
#line 2221 "channels.c"
void channel_input_close(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2227
  tmp = packet_get_int();
#line 2227
  id = (int )tmp;
#line 2228
  while (1) {
#line 2228
    tmp___0 = packet_remaining();
#line 2228
    _len = tmp___0;
#line 2228
    if (_len > 0) {
#line 2228
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2228);
#line 2228
      packet_disconnect("Packet integrity error.");
    }
#line 2228
    break;
  }
#line 2229
  c = channel_lookup(id);
#line 2230
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2231
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 2237
  packet_start((unsigned char)25);
#line 2238
  packet_put_int((unsigned int )c->remote_id);
#line 2239
  packet_send();
#line 2248
  if (c->type != 5) {
#line 2253
    buffer_clear(& c->input);
#line 2254
    c->type = 9;
  }
#line 2256
  return;
}
}
#line 2260 "channels.c"
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2263
  tmp = packet_get_int();
#line 2263
  id = (int )tmp;
#line 2264
  tmp___0 = channel_lookup(id);
#line 2264
  c = tmp___0;
#line 2266
  while (1) {
#line 2266
    tmp___1 = packet_remaining();
#line 2266
    _len = tmp___1;
#line 2266
    if (_len > 0) {
#line 2266
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2266);
#line 2266
      packet_disconnect("Packet integrity error.");
    }
#line 2266
    break;
  }
#line 2267
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2268
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 2269
  chan_rcvd_oclose(c);
#line 2270
  return;
}
}
#line 2273 "channels.c"
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2276
  tmp = packet_get_int();
#line 2276
  id = (int )tmp;
#line 2277
  tmp___0 = channel_lookup(id);
#line 2277
  c = tmp___0;
#line 2279
  while (1) {
#line 2279
    tmp___1 = packet_remaining();
#line 2279
    _len = tmp___1;
#line 2279
    if (_len > 0) {
#line 2279
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2279);
#line 2279
      packet_disconnect("Packet integrity error.");
    }
#line 2279
    break;
  }
#line 2280
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2281
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 2283
  if (c->type != 5) {
#line 2284
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 2286
  channel_free(c);
#line 2287
  return;
}
}
#line 2290 "channels.c"
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2296
  tmp = packet_get_int();
#line 2296
  id = (int )tmp;
#line 2297
  c = channel_lookup(id);
#line 2299
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2300
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 2299
    if (c->type != 3) {
#line 2300
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 2302
  tmp___0 = packet_get_int();
#line 2302
  remote_id = (int )tmp___0;
#line 2304
  c->remote_id = remote_id;
#line 2305
  c->type = 4;
#line 2307
  if (compat20) {
#line 2308
    c->remote_window = packet_get_int();
#line 2309
    c->remote_maxpacket = packet_get_int();
#line 2310
    if (c->open_confirm) {
#line 2311
      debug2("callback start");
#line 2312
      (*(c->open_confirm))(c->self, c->open_confirm_ctx);
#line 2313
      debug2("callback done");
    }
#line 2315
    debug2("channel %d: open confirm rwindow %u rmax %u", c->self, c->remote_window,
           c->remote_maxpacket);
  }
#line 2318
  while (1) {
#line 2318
    tmp___1 = packet_remaining();
#line 2318
    _len = tmp___1;
#line 2318
    if (_len > 0) {
#line 2318
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2318);
#line 2318
      packet_disconnect("Packet integrity error.");
    }
#line 2318
    break;
  }
#line 2319
  return;
}
}
#line 2321 "channels.c"
static char *reason2txt(int reason ) 
{ 

  {
#line 2324
  switch (reason) {
  case 1: 
#line 2326
  return ((char *)"administratively prohibited");
  case 2: 
#line 2328
  return ((char *)"connect failed");
  case 3: 
#line 2330
  return ((char *)"unknown channel type");
  case 4: 
#line 2332
  return ((char *)"resource shortage");
  }
#line 2334
  return ((char *)"unknown reason");
}
}
#line 2338 "channels.c"
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int _len ;
  int tmp___6 ;

  {
#line 2342
  msg = (char *)((void *)0);
#line 2342
  lang = (char *)((void *)0);
#line 2345
  tmp = packet_get_int();
#line 2345
  id = (int )tmp;
#line 2346
  c = channel_lookup(id);
#line 2348
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2349
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 2348
    if (c->type != 3) {
#line 2349
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 2351
  if (compat20) {
#line 2352
    tmp___0 = packet_get_int();
#line 2352
    reason = (int )tmp___0;
#line 2353
    if (! (datafellows & 131072)) {
#line 2354
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 2354
      msg = (char *)tmp___1;
#line 2355
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2355
      lang = (char *)tmp___2;
    }
#line 2357
    if (msg) {
#line 2357
      tmp___3 = (char const   *)msg;
    } else {
#line 2357
      tmp___3 = "";
    }
#line 2357
    if (msg) {
#line 2357
      tmp___4 = ": ";
    } else {
#line 2357
      tmp___4 = "";
    }
#line 2357
    tmp___5 = reason2txt(reason);
#line 2357
    logit("channel %d: open failed: %s%s%s", id, tmp___5, tmp___4, tmp___3);
#line 2359
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 2360
      xfree((void *)msg);
    }
#line 2361
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 2362
      xfree((void *)lang);
    }
  }
#line 2364
  while (1) {
#line 2364
    tmp___6 = packet_remaining();
#line 2364
    _len = tmp___6;
#line 2364
    if (_len > 0) {
#line 2364
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2364);
#line 2364
      packet_disconnect("Packet integrity error.");
    }
#line 2364
    break;
  }
#line 2366
  chan_mark_dead(c);
#line 2367
  return;
}
}
#line 2370 "channels.c"
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  u_int adjust ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2377
  if (! compat20) {
#line 2378
    return;
  }
#line 2381
  tmp = packet_get_int();
#line 2381
  id = (int )tmp;
#line 2382
  c = channel_lookup(id);
#line 2384
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2385
    logit("Received window adjust for non-open channel %d.", id);
#line 2386
    return;
  }
#line 2388
  adjust = packet_get_int();
#line 2389
  while (1) {
#line 2389
    tmp___0 = packet_remaining();
#line 2389
    _len = tmp___0;
#line 2389
    if (_len > 0) {
#line 2389
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2389);
#line 2389
      packet_disconnect("Packet integrity error.");
    }
#line 2389
    break;
  }
#line 2390
  debug2("channel %d: rcvd adjust %u", id, adjust);
#line 2391
  c->remote_window += adjust;
#line 2392
  return;
}
}
#line 2395 "channels.c"
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_id ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  int _len ;
  int tmp___4 ;

  {
#line 2398
  c = (Channel *)((void *)0);
#line 2403
  tmp = packet_get_int();
#line 2403
  remote_id = (int )tmp;
#line 2404
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2404
  host = (char *)tmp___0;
#line 2405
  tmp___1 = packet_get_int();
#line 2405
  host_port = (unsigned short )tmp___1;
#line 2407
  tmp___3 = packet_get_protocol_flags();
#line 2407
  if (tmp___3 & 2U) {
#line 2408
    tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2408
    originator_string = (char *)tmp___2;
  } else {
#line 2410
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 2412
  while (1) {
#line 2412
    tmp___4 = packet_remaining();
#line 2412
    _len = tmp___4;
#line 2412
    if (_len > 0) {
#line 2412
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2412);
#line 2412
      packet_disconnect("Packet integrity error.");
    }
#line 2412
    break;
  }
#line 2413
  c = channel_connect_to((char const   *)host, host_port, (char *)"connected socket",
                         originator_string);
#line 2415
  xfree((void *)originator_string);
#line 2416
  xfree((void *)host);
#line 2417
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2418
    packet_start((unsigned char)22);
#line 2419
    packet_put_int((unsigned int )remote_id);
#line 2420
    packet_send();
  } else {
#line 2422
    c->remote_id = remote_id;
  }
#line 2423
  return;
}
}
#line 2426 "channels.c"
void channel_input_status_confirm(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  struct channel_confirm *cc ;
  int id ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2434
  keep_alive_timeouts = 0;
#line 2436
  tmp = packet_get_int();
#line 2436
  id = (int )tmp;
#line 2437
  while (1) {
#line 2437
    tmp___0 = packet_remaining();
#line 2437
    _len = tmp___0;
#line 2437
    if (_len > 0) {
#line 2437
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2437);
#line 2437
      packet_disconnect("Packet integrity error.");
    }
#line 2437
    break;
  }
#line 2439
  debug2("channel_input_status_confirm: type %d id %d", type, id);
#line 2441
  c = channel_lookup(id);
#line 2441
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2442
    logit("channel_input_status_confirm: %d: unknown", id);
#line 2443
    return;
  }
#line 2446
  cc = c->status_confirms.tqh_first;
#line 2446
  if ((unsigned int )cc == (unsigned int )((void *)0)) {
#line 2447
    return;
  }
#line 2448
  (*(cc->cb))(type, c, cc->ctx);
#line 2449
  while (1) {
#line 2449
    if ((unsigned int )cc->entry.tqe_next != (unsigned int )((void *)0)) {
#line 2449
      (cc->entry.tqe_next)->entry.tqe_prev = cc->entry.tqe_prev;
    } else {
#line 2449
      c->status_confirms.tqh_last = cc->entry.tqe_prev;
    }
#line 2449
    *(cc->entry.tqe_prev) = cc->entry.tqe_next;
#line 2449
    break;
  }
#line 2450
  bzero((void *)cc, sizeof(*cc));
#line 2451
  xfree((void *)cc);
#line 2452
  return;
}
}
#line 2456 "channels.c"
void channel_set_af(int af ) 
{ 

  {
#line 2459
  IPv4or6 = af;
#line 2460
  return;
}
}
#line 2462 "channels.c"
static int channel_setup_fwd_listener(int type , char const   *listen_addr , u_short listen_port ,
                                      int *allocated_listen_port , char const   *host_to_connect ,
                                      u_short port_to_connect , int gateway_ports ) 
{ Channel *c ;
  int sock ;
  int r ;
  int success ;
  int wildcard ;
  int is_client ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char const   *host ;
  char const   *addr ;
  char ntop[1025] ;
  char strport[32] ;
  in_port_t *lport_p ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;

  {
#line 2468
  success = 0;
#line 2468
  wildcard = 0;
#line 2474
  if (type == 11) {
#line 2474
    host = listen_addr;
  } else {
#line 2474
    host = host_to_connect;
  }
#line 2476
  is_client = type == 2;
#line 2478
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2479
    error("No forward host name.");
#line 2480
    return (0);
  }
#line 2482
  tmp = strlen(host);
#line 2482
  if (tmp >= 1025U) {
#line 2483
    error("Forward host name too long.");
#line 2484
    return (0);
  }
#line 2502
  addr = (char const   *)((void *)0);
#line 2503
  if ((unsigned int )listen_addr == (unsigned int )((void *)0)) {
#line 2505
    if (gateway_ports) {
#line 2506
      wildcard = 1;
    }
  } else {
#line 2507
    if (gateway_ports) {
      goto _L___8;
    } else {
#line 2507
      if (is_client) {
        _L___8: /* CIL Label */ 
#line 2510
        if (datafellows & 16777216) {
#line 2509
          if (0) {
#line 2509
            __s1_len___0 = strlen(listen_addr);
#line 2509
            __s2_len___0 = strlen("0.0.0.0");
#line 2509
            if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
              goto _L___2;
            } else {
#line 2509
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2509
                if (! ((unsigned int )((void const   *)("0.0.0.0" + 1)) - (unsigned int )((void const   *)"0.0.0.0") == 1U)) {
#line 2509
                  tmp___19 = 1;
                } else {
#line 2509
                  if (__s2_len___0 >= 4U) {
#line 2509
                    tmp___19 = 1;
                  } else {
#line 2509
                    tmp___19 = 0;
                  }
                }
              } else {
#line 2509
                tmp___19 = 0;
              }
            }
#line 2509
            if (tmp___19) {
#line 2509
              tmp___15 = __builtin_strcmp(listen_addr, "0.0.0.0");
            } else {
#line 2509
              tmp___18 = __builtin_strcmp(listen_addr, "0.0.0.0");
#line 2509
              tmp___15 = tmp___18;
            }
          } else {
#line 2509
            tmp___18 = __builtin_strcmp(listen_addr, "0.0.0.0");
#line 2509
            tmp___15 = tmp___18;
          }
#line 2510
          if (tmp___15 == 0) {
#line 2510
            if (is_client == 0) {
#line 2512
              wildcard = 1;
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ 
#line 2510
          if ((int const   )*listen_addr == 0) {
#line 2512
            wildcard = 1;
          } else {
#line 2510
            if (0) {
#line 2510
              __s1_len___1 = strlen(listen_addr);
#line 2510
              __s2_len___1 = strlen("*");
#line 2510
              if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
                goto _L___4;
              } else {
#line 2510
                if (__s1_len___1 >= 4U) {
                  _L___4: /* CIL Label */ 
#line 2510
                  if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2510
                    tmp___29 = 1;
                  } else {
#line 2510
                    if (__s2_len___1 >= 4U) {
#line 2510
                      tmp___29 = 1;
                    } else {
#line 2510
                      tmp___29 = 0;
                    }
                  }
                } else {
#line 2510
                  tmp___29 = 0;
                }
              }
#line 2510
              if (tmp___29) {
#line 2510
                tmp___25 = __builtin_strcmp(listen_addr, "*");
              } else {
#line 2510
                tmp___28 = __builtin_strcmp(listen_addr, "*");
#line 2510
                tmp___25 = tmp___28;
              }
            } else {
#line 2510
              tmp___28 = __builtin_strcmp(listen_addr, "*");
#line 2510
              tmp___25 = tmp___28;
            }
#line 2510
            if (tmp___25 == 0) {
#line 2512
              wildcard = 1;
            } else {
#line 2510
              if (! is_client) {
#line 2510
                if (gateway_ports == 1) {
#line 2512
                  wildcard = 1;
                } else {
                  goto _L___5;
                }
              } else {
                _L___5: /* CIL Label */ 
#line 2513
                if (0) {
#line 2513
                  __s1_len = strlen(listen_addr);
#line 2513
                  __s2_len = strlen("localhost");
#line 2513
                  if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
                    goto _L___0;
                  } else {
#line 2513
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 2513
                      if (! ((unsigned int )((void const   *)("localhost" + 1)) - (unsigned int )((void const   *)"localhost") == 1U)) {
#line 2513
                        tmp___9 = 1;
                      } else {
#line 2513
                        if (__s2_len >= 4U) {
#line 2513
                          tmp___9 = 1;
                        } else {
#line 2513
                          tmp___9 = 0;
                        }
                      }
                    } else {
#line 2513
                      tmp___9 = 0;
                    }
                  }
#line 2513
                  if (tmp___9) {
#line 2513
                    tmp___5 = __builtin_strcmp(listen_addr, "localhost");
                  } else {
#line 2513
                    tmp___8 = __builtin_strcmp(listen_addr, "localhost");
#line 2513
                    tmp___5 = tmp___8;
                  }
                } else {
#line 2513
                  tmp___8 = __builtin_strcmp(listen_addr, "localhost");
#line 2513
                  tmp___5 = tmp___8;
                }
#line 2513
                if (tmp___5 != 0) {
#line 2514
                  addr = listen_addr;
                }
              }
            }
          }
        }
      }
    }
  }
#line 2517
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 2517
    tmp___30 = "NULL";
  } else {
#line 2517
    tmp___30 = addr;
  }
#line 2517
  debug3("channel_setup_fwd_listener: type %d wildcard %d addr %s", type, wildcard,
         tmp___30);
#line 2524
  memset((void *)(& hints), 0, sizeof(hints));
#line 2525
  hints.ai_family = IPv4or6;
#line 2526
  if (wildcard) {
#line 2526
    hints.ai_flags = 1;
  } else {
#line 2526
    hints.ai_flags = 0;
  }
#line 2527
  hints.ai_socktype = 1;
#line 2528
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 2529
  r = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                  (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2529
  if (r != 0) {
#line 2530
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 2532
      tmp___31 = ssh_gai_strerror(r);
#line 2532
      packet_disconnect("getaddrinfo: fatal error: %s", tmp___31);
    } else {
#line 2535
      tmp___32 = ssh_gai_strerror(r);
#line 2535
      error("channel_setup_fwd_listener: getaddrinfo(%.64s): %s", addr, tmp___32);
    }
#line 2539
    return (0);
  }
#line 2541
  if ((unsigned int )allocated_listen_port != (unsigned int )((void *)0)) {
#line 2542
    *allocated_listen_port = 0;
  }
#line 2543
  ai = aitop;
#line 2543
  while (ai) {
#line 2544
    switch (ai->ai_family) {
    case 2: 
#line 2546
    lport_p = & ((struct sockaddr_in *)ai->ai_addr)->sin_port;
#line 2548
    break;
    case 10: 
#line 2550
    lport_p = & ((struct sockaddr_in6 *)ai->ai_addr)->sin6_port;
#line 2552
    break;
    default: ;
    goto __Cont;
    }
#line 2560
    if (type == 11) {
#line 2560
      if ((int )listen_port == 0) {
#line 2560
        if ((unsigned int )allocated_listen_port != (unsigned int )((void *)0)) {
#line 2560
          if (*allocated_listen_port > 0) {
#line 2562
            __x = (unsigned short )*allocated_listen_port;
#line 2562
            __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 2562
            *lport_p = __v;
          }
        }
      }
    }
#line 2564
    tmp___33 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                           sizeof(strport), 3U);
#line 2564
    if (tmp___33 != 0) {
#line 2566
      error("channel_setup_fwd_listener: getnameinfo failed");
      goto __Cont;
    }
#line 2570
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2571
    if (sock < 0) {
#line 2573
      tmp___34 = __errno_location();
#line 2573
      tmp___35 = strerror(*tmp___34);
#line 2573
      verbose("socket: %.100s", tmp___35);
      goto __Cont;
    }
#line 2577
    channel_set_reuseaddr(sock);
#line 2579
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 2583
    tmp___40 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2583
    if (tmp___40 < 0) {
#line 2585
      if (! ai->ai_next) {
#line 2586
        tmp___36 = __errno_location();
#line 2586
        tmp___37 = strerror(*tmp___36);
#line 2586
        error("bind: %.100s", tmp___37);
      } else {
#line 2588
        tmp___38 = __errno_location();
#line 2588
        tmp___39 = strerror(*tmp___38);
#line 2588
        verbose("bind: %.100s", tmp___39);
      }
#line 2590
      close(sock);
      goto __Cont;
    }
#line 2594
    tmp___43 = listen(sock, 128);
#line 2594
    if (tmp___43 < 0) {
#line 2595
      tmp___41 = __errno_location();
#line 2595
      tmp___42 = strerror(*tmp___41);
#line 2595
      error("listen: %.100s", tmp___42);
#line 2596
      close(sock);
      goto __Cont;
    }
#line 2604
    if (type == 11) {
#line 2604
      if ((int )listen_port == 0) {
#line 2604
        if ((unsigned int )allocated_listen_port != (unsigned int )((void *)0)) {
#line 2604
          if (*allocated_listen_port == 0) {
#line 2607
            *allocated_listen_port = get_sock_port(sock, 1);
#line 2608
            debug("Allocated listen port %d", *allocated_listen_port);
          }
        }
      }
    }
#line 2613
    c = channel_new((char *)"port listener", type, sock, sock, -1, 2097152U, 32768U,
                    0, (char *)"port listener", 1);
#line 2616
    c->path = xstrdup(host);
#line 2617
    c->host_port = (int )port_to_connect;
#line 2618
    c->listening_port = (int )listen_port;
#line 2619
    success = 1;
    __Cont: /* CIL Label */ 
#line 2543
    ai = ai->ai_next;
  }
#line 2621
  if (success == 0) {
#line 2622
    error("channel_setup_fwd_listener: cannot listen to port: %d", listen_port);
  }
#line 2624
  freeaddrinfo(aitop);
#line 2625
  return (success);
}
}
#line 2628 "channels.c"
int channel_cancel_rport_listener(char const   *host , u_short port___0 ) 
{ u_int i ;
  int found ;
  Channel *c ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 2632
  found = 0;
#line 2634
  i = 0U;
#line 2634
  while (i < channels_alloc) {
#line 2635
    c = *(channels + i);
#line 2638
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 2638
      if (c->type == 11) {
#line 2638
        if (0) {
#line 2638
          __s1_len = strlen((char const   *)c->path);
#line 2638
          __s2_len = strlen(host);
#line 2638
          if (! ((unsigned int )((void const   *)(c->path + 1)) - (unsigned int )((void const   *)c->path) == 1U)) {
            goto _L___0;
          } else {
#line 2638
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2638
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2638
                tmp___8 = 1;
              } else {
#line 2638
                if (__s2_len >= 4U) {
#line 2638
                  tmp___8 = 1;
                } else {
#line 2638
                  tmp___8 = 0;
                }
              }
            } else {
#line 2638
              tmp___8 = 0;
            }
          }
#line 2638
          if (tmp___8) {
#line 2638
            tmp___4 = __builtin_strcmp((char const   *)c->path, host);
          } else {
#line 2638
            tmp___7 = __builtin_strcmp((char const   *)c->path, host);
#line 2638
            tmp___4 = tmp___7;
          }
        } else {
#line 2638
          tmp___7 = __builtin_strcmp((char const   *)c->path, host);
#line 2638
          tmp___4 = tmp___7;
        }
#line 2638
        if (tmp___4 == 0) {
#line 2638
          if (c->listening_port == (int )port___0) {
#line 2639
            debug2("%s: close channel %d", "channel_cancel_rport_listener", i);
#line 2640
            channel_free(c);
#line 2641
            found = 1;
          }
        }
      }
    }
#line 2634
    i ++;
  }
#line 2645
  return (found);
}
}
#line 2649 "channels.c"
int channel_setup_local_fwd_listener(char const   *listen_host , u_short listen_port ,
                                     char const   *host_to_connect , u_short port_to_connect ,
                                     int gateway_ports ) 
{ int tmp ;

  {
#line 2653
  tmp = channel_setup_fwd_listener(2, listen_host, listen_port, (int *)((void *)0),
                                   host_to_connect, port_to_connect, gateway_ports);
#line 2653
  return (tmp);
}
}
#line 2659 "channels.c"
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int *allocated_listen_port , int gateway_ports ) 
{ int tmp ;

  {
#line 2663
  tmp = channel_setup_fwd_listener(11, listen_address, listen_port, allocated_listen_port,
                                   (char const   *)((void *)0), (unsigned short)0,
                                   gateway_ports);
#line 2663
  return (tmp);
}
}
#line 2673 "channels.c"
int channel_request_remote_forwarding(char const   *listen_host , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ) 
{ int type ;
  int success ;
  char const   *address_to_bind ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2677
  success = 0;
#line 2680
  if (num_permitted_opens >= 100) {
#line 2681
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2684
  if (compat20) {
#line 2686
    if ((unsigned int )listen_host == (unsigned int )((void *)0)) {
#line 2687
      if (datafellows & 33554432) {
#line 2688
        address_to_bind = "127.0.0.1";
      } else {
#line 2690
        address_to_bind = "localhost";
      }
    } else {
#line 2692
      if ((int const   )*listen_host == 0) {
        goto _L___1;
      } else {
#line 2692
        if (0) {
#line 2692
          __s1_len = strlen(listen_host);
#line 2692
          __s2_len = strlen("*");
#line 2692
          if (! ((unsigned int )((void const   *)(listen_host + 1)) - (unsigned int )((void const   *)listen_host) == 1U)) {
            goto _L___0;
          } else {
#line 2692
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2692
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2692
                tmp___8 = 1;
              } else {
#line 2692
                if (__s2_len >= 4U) {
#line 2692
                  tmp___8 = 1;
                } else {
#line 2692
                  tmp___8 = 0;
                }
              }
            } else {
#line 2692
              tmp___8 = 0;
            }
          }
#line 2692
          if (tmp___8) {
#line 2692
            tmp___4 = __builtin_strcmp(listen_host, "*");
          } else {
#line 2692
            tmp___7 = __builtin_strcmp(listen_host, "*");
#line 2692
            tmp___4 = tmp___7;
          }
        } else {
#line 2692
          tmp___7 = __builtin_strcmp(listen_host, "*");
#line 2692
          tmp___4 = tmp___7;
        }
#line 2692
        if (tmp___4 == 0) {
          _L___1: /* CIL Label */ 
#line 2693
          if (datafellows & 33554432) {
#line 2694
            address_to_bind = "0.0.0.0";
          } else {
#line 2696
            address_to_bind = "";
          }
        } else {
#line 2698
          address_to_bind = listen_host;
        }
      }
    }
#line 2700
    packet_start((unsigned char)80);
#line 2701
    packet_put_cstring("tcpip-forward");
#line 2702
    packet_put_char(1);
#line 2703
    packet_put_cstring(address_to_bind);
#line 2704
    packet_put_int((unsigned int )listen_port);
#line 2705
    packet_send();
#line 2706
    packet_write_wait();
#line 2708
    success = 1;
  } else {
#line 2710
    packet_start((unsigned char)28);
#line 2711
    packet_put_int((unsigned int )listen_port);
#line 2712
    packet_put_cstring(host_to_connect);
#line 2713
    packet_put_int((unsigned int )port_to_connect);
#line 2714
    packet_send();
#line 2715
    packet_write_wait();
#line 2718
    type = packet_read();
#line 2719
    switch (type) {
    case 14: 
#line 2721
    success = 1;
#line 2722
    break;
    case 15: 
#line 2724
    break;
    default: 
#line 2727
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 2731
  if (success) {
#line 2732
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 2733
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 2734
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 2735
    num_permitted_opens ++;
  }
#line 2737
  if (success) {
#line 2737
    tmp___9 = 0;
  } else {
#line 2737
    tmp___9 = -1;
  }
#line 2737
  return (tmp___9);
}
}
#line 2744 "channels.c"
void channel_request_rforward_cancel(char const   *host , u_short port___0 ) 
{ int i ;
  char const   *tmp ;

  {
#line 2749
  if (! compat20) {
#line 2750
    return;
  }
#line 2752
  i = 0;
#line 2752
  while (i < num_permitted_opens) {
#line 2753
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2753
      if ((int )permitted_opens[i].listen_port == (int )port___0) {
#line 2755
        break;
      }
    }
#line 2752
    i ++;
  }
#line 2757
  if (i >= num_permitted_opens) {
#line 2758
    debug("%s: requested forward not found", "channel_request_rforward_cancel");
#line 2759
    return;
  }
#line 2761
  packet_start((unsigned char)80);
#line 2762
  packet_put_cstring("cancel-tcpip-forward");
#line 2763
  packet_put_char(0);
#line 2764
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2764
    tmp = "";
  } else {
#line 2764
    tmp = host;
  }
#line 2764
  packet_put_cstring(tmp);
#line 2765
  packet_put_int((unsigned int )port___0);
#line 2766
  packet_send();
#line 2768
  permitted_opens[i].listen_port = (unsigned short)0;
#line 2769
  permitted_opens[i].port_to_connect = (unsigned short)0;
#line 2770
  xfree((void *)permitted_opens[i].host_to_connect);
#line 2771
  permitted_opens[i].host_to_connect = (char *)((void *)0);
#line 2772
  return;
}
}
#line 2779 "channels.c"
int channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port___0 ;
  u_short host_port ;
  int success ;
  char *hostname ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 2783
  success = 0;
#line 2787
  tmp = packet_get_int();
#line 2787
  port___0 = (unsigned short )tmp;
#line 2788
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2788
  hostname = (char *)tmp___0;
#line 2789
  tmp___1 = packet_get_int();
#line 2789
  host_port = (unsigned short )tmp___1;
#line 2796
  if ((int )port___0 < 1024) {
#line 2796
    if (! is_root) {
#line 2797
      packet_disconnect("Requested forwarding of port %d but user is not root.", port___0);
    }
  }
#line 2800
  if ((int )host_port == 0) {
#line 2801
    packet_disconnect("Dynamic forwarding denied.");
  }
#line 2805
  success = channel_setup_local_fwd_listener((char const   *)((void *)0), port___0,
                                             (char const   *)hostname, host_port,
                                             gateway_ports);
#line 2809
  xfree((void *)hostname);
#line 2811
  if (success) {
#line 2811
    tmp___2 = 0;
  } else {
#line 2811
    tmp___2 = -1;
  }
#line 2811
  return (tmp___2);
}
}
#line 2819 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 2822
  if (num_permitted_opens == 0) {
#line 2823
    all_opens_permitted = 1;
  }
#line 2824
  return;
}
}
#line 2826 "channels.c"
void channel_add_permitted_opens(char *host , int port___0 ) 
{ 

  {
#line 2829
  if (num_permitted_opens >= 100) {
#line 2830
    fatal("channel_add_permitted_opens: too many forwards");
  }
#line 2831
  debug("allow port forwarding to host %s port %d", host, port___0);
#line 2833
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2834
  permitted_opens[num_permitted_opens].port_to_connect = (unsigned short )port___0;
#line 2835
  num_permitted_opens ++;
#line 2837
  all_opens_permitted = 0;
#line 2838
  return;
}
}
#line 2840 "channels.c"
int channel_add_adm_permitted_opens(char *host , int port___0 ) 
{ 

  {
#line 2843
  if (num_adm_permitted_opens >= 100) {
#line 2844
    fatal("channel_add_adm_permitted_opens: too many forwards");
  }
#line 2845
  debug("config allows port forwarding to host %s port %d", host, port___0);
#line 2847
  permitted_adm_opens[num_adm_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2849
  permitted_adm_opens[num_adm_permitted_opens].port_to_connect = (unsigned short )port___0;
#line 2850
  num_adm_permitted_opens ++;
#line 2850
  return (num_adm_permitted_opens);
}
}
#line 2853 "channels.c"
void channel_clear_permitted_opens(void) 
{ int i ;

  {
#line 2858
  i = 0;
#line 2858
  while (i < num_permitted_opens) {
#line 2859
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2860
      xfree((void *)permitted_opens[i].host_to_connect);
    }
#line 2858
    i ++;
  }
#line 2861
  num_permitted_opens = 0;
#line 2862
  return;
}
}
#line 2864 "channels.c"
void channel_clear_adm_permitted_opens(void) 
{ int i ;

  {
#line 2869
  i = 0;
#line 2869
  while (i < num_adm_permitted_opens) {
#line 2870
    if ((unsigned int )permitted_adm_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2871
      xfree((void *)permitted_adm_opens[i].host_to_connect);
    }
#line 2869
    i ++;
  }
#line 2872
  num_adm_permitted_opens = 0;
#line 2873
  return;
}
}
#line 2875 "channels.c"
void channel_print_adm_permitted_opens(void) 
{ int i ;

  {
#line 2880
  printf((char const   * __restrict  )"permitopen");
#line 2881
  if (num_adm_permitted_opens == 0) {
#line 2882
    printf((char const   * __restrict  )" any\n");
#line 2883
    return;
  }
#line 2885
  i = 0;
#line 2885
  while (i < num_adm_permitted_opens) {
#line 2886
    if ((unsigned int )permitted_adm_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2887
      printf((char const   * __restrict  )" %s:%d", permitted_adm_opens[i].host_to_connect,
             permitted_adm_opens[i].port_to_connect);
    }
#line 2885
    i ++;
  }
#line 2889
  printf((char const   * __restrict  )"\n");
#line 2890
  return;
}
}
#line 2893 "channels.c"
static int connect_next(struct channel_connect *cctx ) 
{ int sock ;
  int saved_errno ;
  char ntop[1025] ;
  char strport[32] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;

  {
#line 2899
  while (cctx->ai) {
#line 2900
    if ((cctx->ai)->ai_family != 2) {
#line 2900
      if ((cctx->ai)->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2903
    tmp = getnameinfo((struct sockaddr  const  * __restrict  )(cctx->ai)->ai_addr,
                      (cctx->ai)->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                      (char * __restrict  )(strport), sizeof(strport), 3U);
#line 2903
    if (tmp != 0) {
#line 2906
      error("connect_next: getnameinfo failed");
      goto __Cont;
    }
#line 2909
    sock = socket((cctx->ai)->ai_family, (cctx->ai)->ai_socktype, (cctx->ai)->ai_protocol);
#line 2909
    if (sock == -1) {
#line 2911
      if ((unsigned int )(cctx->ai)->ai_next == (unsigned int )((void *)0)) {
#line 2912
        tmp___0 = __errno_location();
#line 2912
        tmp___1 = strerror(*tmp___0);
#line 2912
        error("socket: %.100s", tmp___1);
      } else {
#line 2914
        tmp___2 = __errno_location();
#line 2914
        tmp___3 = strerror(*tmp___2);
#line 2914
        verbose("socket: %.100s", tmp___3);
      }
      goto __Cont;
    }
#line 2917
    tmp___4 = set_nonblock(sock);
#line 2917
    if (tmp___4 == -1) {
#line 2918
      fatal("%s: set_nonblock(%d)", "connect_next", sock);
    }
#line 2919
    tmp___9 = connect(sock, (struct sockaddr  const  * __restrict  )(cctx->ai)->ai_addr,
                      (cctx->ai)->ai_addrlen);
#line 2919
    if (tmp___9 == -1) {
#line 2919
      tmp___10 = __errno_location();
#line 2919
      if (*tmp___10 != 115) {
#line 2921
        tmp___5 = __errno_location();
#line 2921
        tmp___6 = strerror(*tmp___5);
#line 2921
        debug("connect_next: host %.100s ([%.100s]:%s): %.100s", cctx->host, ntop,
              strport, tmp___6);
#line 2924
        tmp___7 = __errno_location();
#line 2924
        saved_errno = *tmp___7;
#line 2925
        close(sock);
#line 2926
        tmp___8 = __errno_location();
#line 2926
        *tmp___8 = saved_errno;
        goto __Cont;
      }
    }
#line 2929
    debug("connect_next: host %.100s ([%.100s]:%s) in progress, fd=%d", cctx->host,
          ntop, strport, sock);
#line 2931
    cctx->ai = (cctx->ai)->ai_next;
#line 2932
    set_nodelay(sock);
#line 2933
    return (sock);
    __Cont: /* CIL Label */ 
#line 2899
    cctx->ai = (cctx->ai)->ai_next;
  }
#line 2935
  return (-1);
}
}
#line 2938 "channels.c"
static void channel_connect_ctx_free(struct channel_connect *cctx ) 
{ 

  {
#line 2941
  xfree((void *)cctx->host);
#line 2942
  if (cctx->aitop) {
#line 2943
    freeaddrinfo(cctx->aitop);
  }
#line 2944
  bzero((void *)cctx, sizeof(*cctx));
#line 2945
  cctx->host = (char *)((void *)0);
#line 2946
  cctx->aitop = (struct addrinfo *)((void *)0);
#line 2946
  cctx->ai = cctx->aitop;
#line 2947
  return;
}
}
#line 2950 "channels.c"
static Channel *connect_to(char const   *host , u_short port___0 , char *ctype , char *rname ) 
{ struct addrinfo hints ;
  int gaierr ;
  int sock ;
  char strport[32] ;
  struct channel_connect cctx ;
  Channel *c ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 2955
  sock = -1;
#line 2960
  memset((void *)(& cctx), 0, sizeof(cctx));
#line 2961
  memset((void *)(& hints), 0, sizeof(hints));
#line 2962
  hints.ai_family = IPv4or6;
#line 2963
  hints.ai_socktype = 1;
#line 2964
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port___0);
#line 2965
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& cctx.aitop));
#line 2965
  if (gaierr != 0) {
#line 2966
    tmp = ssh_gai_strerror(gaierr);
#line 2966
    error("connect_to %.100s: unknown host (%s)", host, tmp);
#line 2968
    return ((Channel *)((void *)0));
  }
#line 2971
  cctx.host = xstrdup(host);
#line 2972
  cctx.port = (int )port___0;
#line 2973
  cctx.ai = cctx.aitop;
#line 2975
  sock = connect_next(& cctx);
#line 2975
  if (sock == -1) {
#line 2976
    tmp___0 = __errno_location();
#line 2976
    tmp___1 = strerror(*tmp___0);
#line 2976
    error("connect to %.100s port %d failed: %s", host, port___0, tmp___1);
#line 2978
    channel_connect_ctx_free(& cctx);
#line 2979
    return ((Channel *)((void *)0));
  }
#line 2981
  c = channel_new(ctype, 12, sock, sock, -1, 2097152U, 32768U, 0, rname, 1);
#line 2983
  c->connect_ctx = cctx;
#line 2984
  return (c);
}
}
#line 2987 "channels.c"
Channel *channel_connect_by_listen_address(u_short listen_port , char *ctype , char *rname ) 
{ int i ;
  Channel *tmp ;

  {
#line 2992
  i = 0;
#line 2992
  while (i < num_permitted_opens) {
#line 2993
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2993
      if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 2995
        tmp = connect_to((char const   *)permitted_opens[i].host_to_connect, permitted_opens[i].port_to_connect,
                         ctype, rname);
#line 2995
        return (tmp);
      }
    }
#line 2992
    i ++;
  }
#line 3000
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 3002
  return ((Channel *)((void *)0));
}
}
#line 3006 "channels.c"
Channel *channel_connect_to(char const   *host , u_short port___0 , char *ctype ,
                            char *rname ) 
{ int i ;
  int permit ;
  int permit_adm ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  Channel *tmp___19 ;

  {
#line 3009
  permit_adm = 1;
#line 3011
  permit = all_opens_permitted;
#line 3012
  if (! permit) {
#line 3013
    i = 0;
#line 3013
    while (i < num_permitted_opens) {
#line 3016
      if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 3016
        if ((int )permitted_opens[i].port_to_connect == (int )port___0) {
#line 3016
          if (0) {
#line 3016
            __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 3016
            __s2_len = strlen(host);
#line 3016
            if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
              goto _L___0;
            } else {
#line 3016
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 3016
                if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 3016
                  tmp___8 = 1;
                } else {
#line 3016
                  if (__s2_len >= 4U) {
#line 3016
                    tmp___8 = 1;
                  } else {
#line 3016
                    tmp___8 = 0;
                  }
                }
              } else {
#line 3016
                tmp___8 = 0;
              }
            }
#line 3016
            if (tmp___8) {
#line 3016
              tmp___4 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                         host);
            } else {
#line 3016
              tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                         host);
#line 3016
              tmp___4 = tmp___7;
            }
          } else {
#line 3016
            tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
#line 3016
            tmp___4 = tmp___7;
          }
#line 3016
          if (tmp___4 == 0) {
#line 3017
            permit = 1;
          }
        }
      }
#line 3013
      i ++;
    }
  }
#line 3020
  if (num_adm_permitted_opens > 0) {
#line 3021
    permit_adm = 0;
#line 3022
    i = 0;
#line 3022
    while (i < num_adm_permitted_opens) {
#line 3025
      if ((unsigned int )permitted_adm_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 3025
        if ((int )permitted_adm_opens[i].port_to_connect == (int )port___0) {
#line 3025
          if (0) {
#line 3025
            __s1_len___0 = strlen((char const   *)permitted_adm_opens[i].host_to_connect);
#line 3025
            __s2_len___0 = strlen(host);
#line 3025
            if (! ((unsigned int )((void const   *)(permitted_adm_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_adm_opens[i].host_to_connect) == 1U)) {
              goto _L___2;
            } else {
#line 3025
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 3025
                if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 3025
                  tmp___18 = 1;
                } else {
#line 3025
                  if (__s2_len___0 >= 4U) {
#line 3025
                    tmp___18 = 1;
                  } else {
#line 3025
                    tmp___18 = 0;
                  }
                }
              } else {
#line 3025
                tmp___18 = 0;
              }
            }
#line 3025
            if (tmp___18) {
#line 3025
              tmp___14 = __builtin_strcmp((char const   *)permitted_adm_opens[i].host_to_connect,
                                          host);
            } else {
#line 3025
              tmp___17 = __builtin_strcmp((char const   *)permitted_adm_opens[i].host_to_connect,
                                          host);
#line 3025
              tmp___14 = tmp___17;
            }
          } else {
#line 3025
            tmp___17 = __builtin_strcmp((char const   *)permitted_adm_opens[i].host_to_connect,
                                        host);
#line 3025
            tmp___14 = tmp___17;
          }
#line 3025
          if (tmp___14 == 0) {
#line 3027
            permit_adm = 1;
          }
        }
      }
#line 3022
      i ++;
    }
  }
#line 3030
  if (! permit) {
#line 3031
    logit("Received request to connect to host %.100s port %d, but the request was denied.",
          host, port___0);
#line 3033
    return ((Channel *)((void *)0));
  } else {
#line 3030
    if (! permit_adm) {
#line 3031
      logit("Received request to connect to host %.100s port %d, but the request was denied.",
            host, port___0);
#line 3033
      return ((Channel *)((void *)0));
    }
  }
#line 3035
  tmp___19 = connect_to(host, port___0, ctype, rname);
#line 3035
  return (tmp___19);
}
}
#line 3038 "channels.c"
void channel_send_window_changes(void) 
{ u_int i ;
  struct winsize ws ;
  int tmp ;

  {
#line 3044
  i = 0U;
#line 3044
  while (i < channels_alloc) {
#line 3045
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 3045
      if (! (*(channels + i))->client_tty) {
        goto __Cont;
      } else {
#line 3045
        if ((*(channels + i))->type != 4) {
          goto __Cont;
        }
      }
    }
#line 3048
    tmp = ioctl((*(channels + i))->rfd, 21523UL, & ws);
#line 3048
    if (tmp < 0) {
      goto __Cont;
    }
#line 3050
    channel_request_start((int )i, (char *)"window-change", 0);
#line 3051
    packet_put_int((unsigned int )ws.ws_col);
#line 3052
    packet_put_int((unsigned int )ws.ws_row);
#line 3053
    packet_put_int((unsigned int )ws.ws_xpixel);
#line 3054
    packet_put_int((unsigned int )ws.ws_ypixel);
#line 3055
    packet_send();
    __Cont: /* CIL Label */ 
#line 3044
    i ++;
  }
#line 3057
  return;
}
}
#line 3066 "channels.c"
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp , int **chanids ) 
{ Channel *nc ;
  int display_number ;
  int sock ;
  u_short port___0 ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int on ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;

  {
#line 3070
  nc = (Channel *)((void *)0);
#line 3075
  num_socks = 0;
#line 3077
  if ((unsigned int )chanids == (unsigned int )((void *)0)) {
#line 3078
    return (-1);
  }
#line 3080
  display_number = x11_display_offset;
#line 3080
  while (display_number < 1000) {
#line 3083
    port___0 = (unsigned short )(6000 + display_number);
#line 3084
    memset((void *)(& hints), 0, sizeof(hints));
#line 3085
    hints.ai_family = IPv4or6;
#line 3086
    if (x11_use_localhost) {
#line 3086
      hints.ai_flags = 0;
    } else {
#line 3086
      hints.ai_flags = 1;
    }
#line 3087
    hints.ai_socktype = 1;
#line 3088
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port___0);
#line 3089
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 3089
    if (gaierr != 0) {
#line 3090
      tmp = ssh_gai_strerror(gaierr);
#line 3090
      error("getaddrinfo: %.100s", tmp);
#line 3091
      return (-1);
    }
#line 3093
    ai = aitop;
#line 3093
    while (ai) {
#line 3094
      if (ai->ai_family != 2) {
#line 3094
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 3096
      sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 3098
      if (sock < 0) {
#line 3099
        tmp___2 = __errno_location();
#line 3099
        if (*tmp___2 != 22) {
#line 3099
          tmp___3 = __errno_location();
#line 3099
          if (*tmp___3 != 97) {
#line 3100
            tmp___0 = __errno_location();
#line 3100
            tmp___1 = strerror(*tmp___0);
#line 3100
            error("socket: %.100s", tmp___1);
#line 3101
            freeaddrinfo(aitop);
#line 3102
            return (-1);
          } else {
#line 3104
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 3104
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 3110
      if (ai->ai_family == 10) {
#line 3111
        on = 1;
#line 3112
        tmp___6 = setsockopt(sock, 41, 26, (void const   *)(& on), sizeof(on));
#line 3112
        if (tmp___6 < 0) {
#line 3113
          tmp___4 = __errno_location();
#line 3113
          tmp___5 = strerror(*tmp___4);
#line 3113
          error("setsockopt IPV6_V6ONLY: %.100s", tmp___5);
        }
      }
#line 3116
      if (x11_use_localhost) {
#line 3117
        channel_set_reuseaddr(sock);
      }
#line 3118
      tmp___9 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 3118
      if (tmp___9 < 0) {
#line 3119
        tmp___7 = __errno_location();
#line 3119
        tmp___8 = strerror(*tmp___7);
#line 3119
        debug2("bind port %d: %.100s", port___0, tmp___8);
#line 3120
        close(sock);
#line 3122
        n___0 = 0;
#line 3122
        while (n___0 < num_socks) {
#line 3123
          close(socks[n___0]);
#line 3122
          n___0 ++;
        }
#line 3125
        num_socks = 0;
#line 3126
        break;
      }
#line 3128
      tmp___10 = num_socks;
#line 3128
      num_socks ++;
#line 3128
      socks[tmp___10] = sock;
#line 3129
      if (num_socks == 10) {
#line 3130
        break;
      }
      __Cont: /* CIL Label */ 
#line 3093
      ai = ai->ai_next;
    }
#line 3132
    freeaddrinfo(aitop);
#line 3133
    if (num_socks > 0) {
#line 3134
      break;
    }
#line 3080
    display_number ++;
  }
#line 3136
  if (display_number >= 1000) {
#line 3137
    error("Failed to allocate internet-domain X11 display socket.");
#line 3138
    return (-1);
  }
#line 3141
  n___0 = 0;
#line 3141
  while (n___0 < num_socks) {
#line 3142
    sock = socks[n___0];
#line 3143
    tmp___13 = listen(sock, 128);
#line 3143
    if (tmp___13 < 0) {
#line 3144
      tmp___11 = __errno_location();
#line 3144
      tmp___12 = strerror(*tmp___11);
#line 3144
      error("listen: %.100s", tmp___12);
#line 3145
      close(sock);
#line 3146
      return (-1);
    }
#line 3141
    n___0 ++;
  }
#line 3151
  tmp___14 = xcalloc((unsigned int )(num_socks + 1), sizeof(*(*chanids)));
#line 3151
  *chanids = (int *)tmp___14;
#line 3152
  n___0 = 0;
#line 3152
  while (n___0 < num_socks) {
#line 3153
    sock = socks[n___0];
#line 3154
    nc = channel_new((char *)"x11 listener", 1, sock, sock, -1, 65536U, 16384U, 0,
                     (char *)"X11 inet listener", 1);
#line 3158
    nc->single_connection = single_connection;
#line 3159
    *(*chanids + n___0) = nc->self;
#line 3152
    n___0 ++;
  }
#line 3161
  *(*chanids + n___0) = -1;
#line 3164
  *display_numberp = (unsigned int )display_number;
#line 3165
  return (0);
}
}
#line 3168 "channels.c"
static int connect_local_xsocket_path(char const   *pathname ) 
{ int sock ;
  struct sockaddr_un addr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 3174
  sock = socket(1, 1, 0);
#line 3175
  if (sock < 0) {
#line 3176
    tmp = __errno_location();
#line 3176
    tmp___0 = strerror(*tmp);
#line 3176
    error("socket: %.100s", tmp___0);
  }
#line 3177
  memset((void *)(& addr), 0, sizeof(addr));
#line 3178
  addr.sun_family = (unsigned short)1;
#line 3179
  strlcpy(addr.sun_path, pathname, sizeof(addr.sun_path));
#line 3180
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                    sizeof(addr));
#line 3180
  if (tmp___1 == 0) {
#line 3181
    return (sock);
  }
#line 3182
  close(sock);
#line 3183
  tmp___2 = __errno_location();
#line 3183
  tmp___3 = strerror(*tmp___2);
#line 3183
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 3184
  return (-1);
}
}
#line 3187 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ char buf___1[1024] ;
  int tmp ;

  {
#line 3191
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"/tmp/.X11-unix/X%u",
           dnr);
#line 3192
  tmp = connect_local_xsocket_path((char const   *)(buf___1));
#line 3192
  return (tmp);
}
}
#line 3195 "channels.c"
int x11_connect_display(void) 
{ u_int display_number ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 3203
  sock = 0;
#line 3206
  tmp = getenv("DISPLAY");
#line 3206
  display = (char const   *)tmp;
#line 3207
  if (! display) {
#line 3208
    error("DISPLAY not set.");
#line 3209
    return (-1);
  }
#line 3231
  if (0) {
#line 3231
    if (0) {
#line 3231
      __s1_len___0 = strlen(display);
#line 3231
      __s2_len___0 = strlen("unix:");
#line 3231
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 3231
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 3231
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 3231
            tmp___25 = 1;
          } else {
#line 3231
            if (__s2_len___0 >= 4U) {
#line 3231
              tmp___25 = 1;
            } else {
#line 3231
              tmp___25 = 0;
            }
          }
        } else {
#line 3231
          tmp___25 = 0;
        }
      }
#line 3231
      if (tmp___25) {
#line 3231
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 3231
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 3231
        tmp___21 = tmp___24;
      }
    } else {
#line 3231
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 3231
      tmp___21 = tmp___24;
    }
#line 3231
    tmp___15 = tmp___21;
  } else {
#line 3231
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 3231
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 3231
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 3234
      tmp___0 = strrchr(display, ':');
#line 3234
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%u",
                       & display_number);
#line 3234
      if (tmp___1 != 1) {
#line 3235
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 3237
        return (-1);
      }
#line 3240
      sock = connect_local_xsocket(display_number);
#line 3241
      if (sock < 0) {
#line 3242
        return (-1);
      }
#line 3245
      return (sock);
    }
  }
#line 3251
  strlcpy(buf___1, display, sizeof(buf___1));
#line 3252
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 3252
  cp = tmp___29;
#line 3253
  if (! cp) {
#line 3254
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 3255
    return (-1);
  }
#line 3257
  *cp = (char)0;
#line 3259
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%u",
                    & display_number);
#line 3259
  if (tmp___30 != 1) {
#line 3260
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 3262
    return (-1);
  }
#line 3266
  memset((void *)(& hints), 0, sizeof(hints));
#line 3267
  hints.ai_family = IPv4or6;
#line 3268
  hints.ai_socktype = 1;
#line 3269
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%u",
           6000U + display_number);
#line 3270
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 3270
  if (gaierr != 0) {
#line 3271
    tmp___31 = ssh_gai_strerror(gaierr);
#line 3271
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 3273
    return (-1);
  }
#line 3275
  ai = aitop;
#line 3275
  while (ai) {
#line 3277
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 3278
    if (sock < 0) {
#line 3279
      tmp___32 = __errno_location();
#line 3279
      tmp___33 = strerror(*tmp___32);
#line 3279
      debug2("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 3283
    tmp___36 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                       ai->ai_addrlen);
#line 3283
    if (tmp___36 < 0) {
#line 3284
      tmp___34 = __errno_location();
#line 3284
      tmp___35 = strerror(*tmp___34);
#line 3284
      debug2("connect %.100s port %u: %.100s", buf___1, 6000U + display_number, tmp___35);
#line 3286
      close(sock);
      goto __Cont;
    }
#line 3290
    break;
    __Cont: /* CIL Label */ 
#line 3275
    ai = ai->ai_next;
  }
#line 3292
  freeaddrinfo(aitop);
#line 3293
  if (! ai) {
#line 3294
    tmp___37 = __errno_location();
#line 3294
    tmp___38 = strerror(*tmp___37);
#line 3294
    error("connect %.100s port %u: %.100s", buf___1, 6000U + display_number, tmp___38);
#line 3296
    return (-1);
  }
#line 3298
  set_nodelay(sock);
#line 3299
  return (sock);
}
}
#line 3309 "channels.c"
void x11_input_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *remote_host ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 3312
  c = (Channel *)((void *)0);
#line 3313
  sock = 0;
#line 3316
  debug("Received X11 open request.");
#line 3318
  tmp = packet_get_int();
#line 3318
  remote_id = (int )tmp;
#line 3320
  tmp___1 = packet_get_protocol_flags();
#line 3320
  if (tmp___1 & 2U) {
#line 3321
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 3321
    remote_host = (char *)tmp___0;
  } else {
#line 3323
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 3325
  while (1) {
#line 3325
    tmp___2 = packet_remaining();
#line 3325
    _len = tmp___2;
#line 3325
    if (_len > 0) {
#line 3325
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            3325);
#line 3325
      packet_disconnect("Packet integrity error.");
    }
#line 3325
    break;
  }
#line 3328
  sock = x11_connect_display();
#line 3329
  if (sock != -1) {
#line 3331
    c = channel_new((char *)"connected x11 socket", 7, sock, sock, -1, 0U, 0U, 0,
                    remote_host, 1);
#line 3334
    c->remote_id = remote_id;
#line 3335
    c->force_drain = 1;
  }
#line 3337
  xfree((void *)remote_host);
#line 3338
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 3340
    packet_start((unsigned char)22);
#line 3341
    packet_put_int((unsigned int )remote_id);
  } else {
#line 3344
    packet_start((unsigned char)21);
#line 3345
    packet_put_int((unsigned int )remote_id);
#line 3346
    packet_put_int((unsigned int )c->self);
  }
#line 3348
  packet_send();
#line 3349
  return;
}
}
#line 3353 "channels.c"
void deny_input_open(int type , u_int32_t seq , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 3356
  tmp = packet_get_int();
#line 3356
  rchan = (int )tmp;
#line 3358
  switch (type) {
  case 31: 
#line 3360
  error("Warning: ssh server tried agent forwarding.");
#line 3361
  break;
  case 27: 
#line 3363
  error("Warning: ssh server tried X11 forwarding.");
#line 3364
  break;
  default: 
#line 3366
  error("deny_input_open: type %d", type);
#line 3367
  break;
  }
#line 3369
  error("Warning: this is probably a break-in attempt by a malicious server.");
#line 3370
  packet_start((unsigned char)22);
#line 3371
  packet_put_int((unsigned int )rchan);
#line 3372
  packet_send();
#line 3373
  return;
}
}
#line 3380 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *disp ,
                                          char const   *proto , char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rnd ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  long long tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;

  {
#line 3384
  tmp = strlen(data);
#line 3384
  data_len = tmp / 2U;
#line 3389
  rnd = (u_int32_t )0;
#line 3391
  if ((unsigned int )x11_saved_display == (unsigned int )((void *)0)) {
#line 3392
    x11_saved_display = xstrdup(disp);
  } else {
#line 3393
    if (0) {
#line 3393
      __s1_len = strlen(disp);
#line 3393
      __s2_len = strlen((char const   *)x11_saved_display);
#line 3393
      if (! ((unsigned int )((void const   *)(disp + 1)) - (unsigned int )((void const   *)disp) == 1U)) {
        goto _L___0;
      } else {
#line 3393
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 3393
          if (! ((unsigned int )((void const   *)(x11_saved_display + 1)) - (unsigned int )((void const   *)x11_saved_display) == 1U)) {
#line 3393
            tmp___9 = 1;
          } else {
#line 3393
            if (__s2_len >= 4U) {
#line 3393
              tmp___9 = 1;
            } else {
#line 3393
              tmp___9 = 0;
            }
          }
        } else {
#line 3393
          tmp___9 = 0;
        }
      }
#line 3393
      if (tmp___9) {
#line 3393
        tmp___5 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
      } else {
#line 3393
        tmp___8 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
#line 3393
        tmp___5 = tmp___8;
      }
    } else {
#line 3393
      tmp___8 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
#line 3393
      tmp___5 = tmp___8;
    }
#line 3393
    if (tmp___5 != 0) {
#line 3394
      error("x11_request_forwarding_with_spoofing: different $DISPLAY already forwarded");
#line 3396
      return;
    }
  }
#line 3399
  tmp___11 = __builtin_strchr((char *)disp, ':');
#line 3399
  cp = (char const   *)tmp___11;
#line 3400
  if (cp) {
#line 3401
    tmp___13 = __builtin_strchr((char *)cp, '.');
#line 3401
    cp = (char const   *)tmp___13;
  }
#line 3402
  if (cp) {
#line 3403
    tmp___14 = strtonum(cp + 1, 0LL, 400LL, (char const   **)((void *)0));
#line 3403
    screen_number = (int )((unsigned int )tmp___14);
  } else {
#line 3405
    screen_number = 0;
  }
#line 3407
  if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 3409
    x11_saved_proto = xstrdup(proto);
#line 3414
    tmp___15 = xmalloc(data_len);
#line 3414
    x11_saved_data = (char *)tmp___15;
#line 3415
    tmp___16 = xmalloc(data_len);
#line 3415
    x11_fake_data = (u_char *)tmp___16;
#line 3416
    i = 0U;
#line 3416
    while (i < data_len) {
#line 3417
      tmp___17 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                        & value);
#line 3417
      if (tmp___17 != 1) {
#line 3418
        fatal("x11_request_forwarding: bad authentication data: %.100s", data);
      }
#line 3420
      if (i % 4U == 0U) {
#line 3421
        rnd = arc4random();
      }
#line 3422
      *(x11_saved_data + i) = (char )value;
#line 3423
      *(x11_fake_data + i) = (unsigned char )(rnd & 255U);
#line 3424
      rnd >>= 8;
#line 3416
      i ++;
    }
#line 3426
    x11_saved_data_len = data_len;
#line 3427
    x11_fake_data_len = data_len;
  }
#line 3431
  new_data = tohex((void const   *)x11_fake_data, data_len);
#line 3434
  if (compat20) {
#line 3435
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 3436
    packet_put_char(0);
  } else {
#line 3438
    packet_start((unsigned char)34);
  }
#line 3440
  packet_put_cstring(proto);
#line 3441
  packet_put_cstring((char const   *)new_data);
#line 3442
  packet_put_int((unsigned int )screen_number);
#line 3443
  packet_send();
#line 3444
  packet_write_wait();
#line 3445
  xfree((void *)new_data);
#line 3446
  return;
}
}
#line 3453 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 3456
  packet_start((unsigned char)30);
#line 3457
  packet_send();
#line 3458
  packet_write_wait();
#line 3459
  return;
}
}
#line 1 "cipher.o"
#pragma merger(0,"./cipher.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 54 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 527 "/usr/include/openssl/evp.h"
extern int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER const   *cipher , unsigned char const   *key ,
                          unsigned char const   *iv , int enc ) ;
#line 567
extern void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a ) ;
#line 568
extern int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a ) ;
#line 571
extern int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x , int keylen ) ;
#line 613
extern EVP_CIPHER const   *EVP_enc_null(void) ;
#line 637
extern EVP_CIPHER const   *EVP_des_cbc(void) ;
#line 652
extern EVP_CIPHER const   *EVP_rc4(void) ;
#line 666
extern EVP_CIPHER const   *EVP_bf_cbc(void) ;
#line 673
extern EVP_CIPHER const   *EVP_cast5_cbc(void) ;
#line 680
extern EVP_CIPHER const   *EVP_aes_128_cbc(void) ;
#line 690
extern EVP_CIPHER const   *EVP_aes_192_cbc(void) ;
#line 700
extern EVP_CIPHER const   *EVP_aes_256_cbc(void) ;
#line 71 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 72
Cipher *cipher_by_name(char const   *name ) ;
#line 74
int cipher_number(char const   *name ) ;
#line 75
char *cipher_name(int id ) ;
#line 76
int ciphers_valid(char const   *names ) ;
#line 77
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int do_encrypt ) ;
#line 82
u_int cipher_blocksize(Cipher const   *c ) ;
#line 83
u_int cipher_keylen(Cipher const   *c ) ;
#line 84
u_int cipher_is_cbc(Cipher const   *c ) ;
#line 86
u_int cipher_get_number(Cipher const   *c ) ;
#line 87
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) ;
#line 88
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) ;
#line 89
int cipher_get_keyiv_len(CipherContext const   *cc ) ;
#line 90
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) ;
#line 91
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) ;
#line 52 "openbsd-compat/openssl-compat.h"
EVP_CIPHER const   *evp_acss(void) ;
#line 54 "cipher.c"
EVP_CIPHER const   *evp_ssh1_bf(void) ;
#line 55
EVP_CIPHER const   *evp_ssh1_3des(void) ;
#line 56
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) ;
#line 57
EVP_CIPHER const   *evp_aes_128_ctr(void) ;
#line 58
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) ;
#line 60 "cipher.c"
struct Cipher ciphers[19]  = 
#line 60
  {      {(char *)"none", 0, (u_int )8, (u_int )0, (u_int )0, (u_int )0, & EVP_enc_null}, 
        {(char *)"des",
      2, (u_int )8, (u_int )8, (u_int )0, (u_int )1, & EVP_des_cbc}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, (u_int )0, (u_int )1, & evp_ssh1_3des}, 
        {(char *)"blowfish",
      6, (u_int )8, (u_int )32, (u_int )0, (u_int )1, & evp_ssh1_bf}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, (u_int )0, (u_int )1, & EVP_des_ede3_cbc}, 
        {(char *)"blowfish-cbc",
      -3, (u_int )8, (u_int )16, (u_int )0, (u_int )1, & EVP_bf_cbc}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, (u_int )0, (u_int )1, & EVP_cast5_cbc}, 
        {(char *)"arcfour",
      -3, (u_int )8, (u_int )16, (u_int )0, (u_int )0, & EVP_rc4}, 
        {(char *)"arcfour128", -3, (u_int )8, (u_int )16, (u_int )1536, (u_int )0, & EVP_rc4}, 
        {(char *)"arcfour256",
      -3, (u_int )8, (u_int )32, (u_int )1536, (u_int )0, & EVP_rc4}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, (u_int )0, (u_int )1, & EVP_aes_128_cbc}, 
        {(char *)"aes192-cbc",
      -3, (u_int )16, (u_int )24, (u_int )0, (u_int )1, & EVP_aes_192_cbc}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, (u_int )0, (u_int )1, & EVP_aes_256_cbc}, 
        {(char *)"rijndael-cbc@lysator.liu.se",
      -3, (u_int )16, (u_int )32, (u_int )0, (u_int )1, & EVP_aes_256_cbc}, 
        {(char *)"aes128-ctr", -3, (u_int )16, (u_int )16, (u_int )0, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"aes192-ctr",
      -3, (u_int )16, (u_int )24, (u_int )0, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"aes256-ctr", -3, (u_int )16, (u_int )32, (u_int )0, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"acss@openssh.org",
      -3, (u_int )16, (u_int )5, (u_int )0, (u_int )0, & evp_acss}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (u_int )0, (u_int )0, (EVP_CIPHER const   *(*)(void))((void *)0)}};
#line 96 "cipher.c"
u_int cipher_blocksize(Cipher const   *c ) 
{ 

  {
#line 99
  return ((unsigned int )c->block_size);
}
}
#line 102 "cipher.c"
u_int cipher_keylen(Cipher const   *c ) 
{ 

  {
#line 105
  return ((unsigned int )c->key_len);
}
}
#line 108 "cipher.c"
u_int cipher_get_number(Cipher const   *c ) 
{ 

  {
#line 111
  return ((unsigned int )c->number);
}
}
#line 114 "cipher.c"
u_int cipher_is_cbc(Cipher const   *c ) 
{ 

  {
#line 117
  return ((unsigned int )c->cbc_mode);
}
}
#line 120 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 123
  mask = (u_int )0;
#line 124
  mask |= (unsigned int )(1 << 3);
#line 125
  mask |= (unsigned int )(1 << 6);
#line 126
  if (client) {
#line 127
    mask |= (unsigned int )(1 << 2);
  }
#line 129
  return (mask);
}
}
#line 132 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 136
  c = ciphers;
#line 136
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 137
    if (0) {
#line 137
      __s1_len = strlen((char const   *)c->name);
#line 137
      __s2_len = strlen(name);
#line 137
      if (! ((unsigned int )((void const   *)(c->name + 1)) - (unsigned int )((void const   *)c->name) == 1U)) {
        goto _L___0;
      } else {
#line 137
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 137
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 137
            tmp___8 = 1;
          } else {
#line 137
            if (__s2_len >= 4U) {
#line 137
              tmp___8 = 1;
            } else {
#line 137
              tmp___8 = 0;
            }
          }
        } else {
#line 137
          tmp___8 = 0;
        }
      }
#line 137
      if (tmp___8) {
#line 137
        tmp___4 = __builtin_strcmp((char const   *)c->name, name);
      } else {
#line 137
        tmp___7 = __builtin_strcmp((char const   *)c->name, name);
#line 137
        tmp___4 = tmp___7;
      }
    } else {
#line 137
      tmp___7 = __builtin_strcmp((char const   *)c->name, name);
#line 137
      tmp___4 = tmp___7;
    }
#line 137
    if (tmp___4 == 0) {
#line 138
      return (c);
    }
#line 136
    c ++;
  }
#line 139
  return ((Cipher *)((void *)0));
}
}
#line 142 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 146
  c = ciphers;
#line 146
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 147
    if (c->number == id) {
#line 148
      return (c);
    }
#line 146
    c ++;
  }
#line 149
  return ((Cipher *)((void *)0));
}
}
#line 153 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *cipher_list ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 160
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 161
    return (0);
  } else {
#line 160
    if (0) {
#line 160
      __s1_len = strlen(names);
#line 160
      __s2_len = strlen("");
#line 160
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 160
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 160
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 160
            tmp___8 = 1;
          } else {
#line 160
            if (__s2_len >= 4U) {
#line 160
              tmp___8 = 1;
            } else {
#line 160
              tmp___8 = 0;
            }
          }
        } else {
#line 160
          tmp___8 = 0;
        }
      }
#line 160
      if (tmp___8) {
#line 160
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 160
        tmp___7 = __builtin_strcmp(names, "");
#line 160
        tmp___4 = tmp___7;
      }
    } else {
#line 160
      tmp___7 = __builtin_strcmp(names, "");
#line 160
      tmp___4 = tmp___7;
    }
#line 160
    if (tmp___4 == 0) {
#line 161
      return (0);
    }
  }
#line 162
  cp = xstrdup(names);
#line 162
  cipher_list = cp;
#line 163
  tmp___24 = __strsep_g(& cp, ",");
#line 163
  p = tmp___24;
#line 163
  while (1) {
#line 163
    if (p) {
#line 163
      if (! ((int )*p != 0)) {
#line 163
        break;
      }
    } else {
#line 163
      break;
    }
#line 165
    c = cipher_by_name((char const   *)p);
#line 166
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 167
      debug("bad cipher %s [%s]", p, names);
#line 168
      xfree((void *)cipher_list);
#line 169
      return (0);
    } else {
#line 166
      if (c->number != -3) {
#line 167
        debug("bad cipher %s [%s]", p, names);
#line 168
        xfree((void *)cipher_list);
#line 169
        return (0);
      } else {
#line 171
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 164
    tmp___40 = __strsep_g(& cp, ",");
#line 164
    p = tmp___40;
  }
#line 174
  debug3("ciphers ok: [%s]", names);
#line 175
  xfree((void *)cipher_list);
#line 176
  return (1);
}
}
#line 184 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 188
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 189
    return (-1);
  }
#line 190
  c = ciphers;
#line 190
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 191
    tmp = strcasecmp((char const   *)c->name, name);
#line 191
    if (tmp == 0) {
#line 192
      return (c->number);
    }
#line 190
    c ++;
  }
#line 193
  return (-1);
}
}
#line 196 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 199
  tmp = cipher_by_number(id);
#line 199
  c = tmp;
#line 200
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 200
    tmp___0 = "<unknown>";
  } else {
#line 200
    tmp___0 = (char const   *)c->name;
  }
#line 200
  return ((char *)tmp___0);
}
}
#line 208 "cipher.c"
static int dowarn  =    1;
#line 203 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int do_encrypt ) 
{ EVP_CIPHER const   *type ;
  int klen ;
  u_char *junk ;
  u_char *discard ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 217
  if (cipher->number == 2) {
#line 218
    if (dowarn) {
#line 219
      error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 221
      dowarn = 0;
    }
#line 223
    if (keylen > 8U) {
#line 224
      keylen = 8U;
    }
  }
#line 226
  cc->plaintext = cipher->number == 0;
#line 228
  if (keylen < cipher->key_len) {
#line 229
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 231
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 231
    if (ivlen < cipher->block_size) {
#line 232
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 234
  cc->cipher = cipher;
#line 236
  type = (*(cipher->evptype))();
#line 238
  EVP_CIPHER_CTX_init(& cc->evp);
#line 248
  tmp = EVP_CipherInit(& cc->evp, type, (unsigned char const   *)((void *)0), (unsigned char const   *)((u_char *)iv),
                       do_encrypt == 1);
#line 248
  if (tmp == 0) {
#line 250
    fatal("cipher_init: EVP_CipherInit failed for %s", cipher->name);
  }
#line 252
  klen = cc->evp.key_len;
#line 253
  if (klen > 0) {
#line 253
    if (keylen != (unsigned int )klen) {
#line 254
      debug2("cipher_init: set keylen (%d -> %d)", klen, keylen);
#line 255
      tmp___0 = EVP_CIPHER_CTX_set_key_length(& cc->evp, (int )keylen);
#line 255
      if (tmp___0 == 0) {
#line 256
        fatal("cipher_init: set keylen failed (%d -> %d)", klen, keylen);
      }
    }
  }
#line 259
  tmp___1 = EVP_CipherInit(& cc->evp, (EVP_CIPHER const   *)((void *)0), (unsigned char const   *)((u_char *)key),
                           (unsigned char const   *)((void *)0), -1);
#line 259
  if (tmp___1 == 0) {
#line 260
    fatal("cipher_init: EVP_CipherInit: set key failed for %s", cipher->name);
  }
#line 264
  if (cipher->discard_len > 0U) {
#line 265
    tmp___2 = xmalloc(cipher->discard_len);
#line 265
    junk = (u_char *)tmp___2;
#line 266
    tmp___3 = xmalloc(cipher->discard_len);
#line 266
    discard = (u_char *)tmp___3;
#line 267
    tmp___4 = (*((cc->evp.cipher)->do_cipher))(& cc->evp, discard, (unsigned char const   *)junk,
                                               cipher->discard_len);
#line 267
    if (tmp___4 == 0) {
#line 269
      fatal("evp_crypt: EVP_Cipher failed during discard");
    }
#line 270
    memset((void *)discard, 0, cipher->discard_len);
#line 271
    xfree((void *)junk);
#line 272
    xfree((void *)discard);
  }
#line 274
  return;
}
}
#line 276 "cipher.c"
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ int tmp ;

  {
#line 279
  if (len % (cc->cipher)->block_size) {
#line 280
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 281
  tmp = (*((cc->evp.cipher)->do_cipher))(& cc->evp, dest, (unsigned char const   *)((u_char *)src),
                                         len);
#line 281
  if (tmp == 0) {
#line 282
    fatal("evp_crypt: EVP_Cipher failed");
  }
#line 283
  return;
}
}
#line 285 "cipher.c"
void cipher_cleanup(CipherContext *cc ) 
{ int tmp ;

  {
#line 288
  tmp = EVP_CIPHER_CTX_cleanup(& cc->evp);
#line 288
  if (tmp == 0) {
#line 289
    error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
  }
#line 290
  return;
}
}
#line 297 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int do_encrypt ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 304
  MD5_Init(& md);
#line 305
  tmp = strlen(passphrase);
#line 305
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 306
  MD5_Final(digest___1, & md);
#line 308
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U, do_encrypt);
#line 310
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 311
  memset((void *)(& md), 0, sizeof(md));
#line 312
  return;
}
}
#line 320 "cipher.c"
int cipher_get_keyiv_len(CipherContext const   *cc ) 
{ Cipher *c ;
  int ivlen ;

  {
#line 323
  c = (Cipher *)cc->cipher;
#line 326
  if (c->number == 3) {
#line 327
    ivlen = 24;
  } else {
#line 329
    ivlen = (int )(cc->evp.cipher)->iv_len;
  }
#line 330
  return (ivlen);
}
}
#line 333 "cipher.c"
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) 
{ Cipher *c ;
  int evplen ;

  {
#line 336
  c = cc->cipher;
#line 339
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 343
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 344
  if (evplen <= 0) {
#line 345
    return;
  }
#line 346
  if ((unsigned int )evplen != len) {
#line 347
    fatal("%s: wrong iv length %d != %d", "cipher_get_keyiv", evplen, len);
  }
#line 354
  if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 355
    ssh_aes_ctr_iv(& cc->evp, 0, iv, len);
  } else {
#line 357
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(cc->evp.iv), len);
  }
#line 358
  break;
  case 3: 
#line 360
  ssh1_3des_iv(& cc->evp, 0, iv, 24);
#line 361
  break;
  default: 
#line 363
  fatal("%s: bad cipher %d", "cipher_get_keyiv", c->number);
  }
#line 365
  return;
}
}
#line 367 "cipher.c"
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) 
{ Cipher *c ;
  int evplen ;

  {
#line 370
  c = cc->cipher;
#line 371
  evplen = 0;
#line 373
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 377
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 378
  if (evplen == 0) {
#line 379
    return;
  }
#line 385
  if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 386
    ssh_aes_ctr_iv(& cc->evp, 1, iv, (unsigned int )evplen);
  } else {
#line 388
    memcpy((void * __restrict  )(cc->evp.iv), (void const   * __restrict  )iv, (unsigned int )evplen);
  }
#line 389
  break;
  case 3: 
#line 391
  ssh1_3des_iv(& cc->evp, 1, iv, 24);
#line 392
  break;
  default: 
#line 394
  fatal("%s: bad cipher %d", "cipher_set_keyiv", c->number);
  }
#line 396
  return;
}
}
#line 406 "cipher.c"
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 409
  c = (Cipher *)cc->cipher;
#line 410
  plen = 0;
#line 412
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
    goto _L;
  } else {
#line 412
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
      _L: /* CIL Label */ 
#line 413
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 414
      if ((unsigned int )dat == (unsigned int )((void *)0)) {
#line 415
        return (plen);
      }
#line 416
      memcpy((void * __restrict  )dat, (void const   * __restrict  )cc->evp.cipher_data,
             (unsigned int )plen);
    }
  }
#line 418
  return (plen);
}
}
#line 421 "cipher.c"
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 424
  c = cc->cipher;
#line 427
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
#line 428
    plen = (int )(cc->evp.cipher)->ctx_size;
#line 429
    memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
           (unsigned int )plen);
  } else {
#line 427
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
#line 428
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 429
      memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
             (unsigned int )plen);
    }
  }
#line 431
  return;
}
}
#line 1 "cipher-acss.o"
#pragma merger(0,"./cipher-acss.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 36 "cipher-acss.c"
static int acss_init_key(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
                         int enc ) 
{ 

  {
#line 40
  acss_setkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, key, enc, 3);
#line 41
  return (1);
}
}
#line 44 "cipher-acss.c"
static int acss_ciph(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                     unsigned int inl ) 
{ 

  {
#line 48
  acss(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned long )inl, in, out);
#line 49
  return (1);
}
}
#line 52 "cipher-acss.c"
static int acss_ctrl(EVP_CIPHER_CTX *ctx , int type , int arg , void *ptr ) 
{ 

  {
#line 55
  switch (type) {
  case 65286: 
#line 57
  ((EVP_ACSS_KEY *)ctx->cipher_data)->ks.mode = arg;
#line 58
  return (1);
  case 65287: 
#line 60
  acss_setsubkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned char const   *)((unsigned char *)ptr));
#line 61
  return (1);
  default: ;
#line 63
  return (-1);
  }
}
}
#line 70 "cipher-acss.c"
static EVP_CIPHER acss_cipher  ;
#line 67 "cipher-acss.c"
EVP_CIPHER const   *evp_acss(void) 
{ 

  {
#line 72
  memset((void *)(& acss_cipher), 0, sizeof(EVP_CIPHER ));
#line 74
  acss_cipher.nid = 0;
#line 75
  acss_cipher.block_size = 1;
#line 76
  acss_cipher.key_len = 5;
#line 77
  acss_cipher.init = & acss_init_key;
#line 78
  acss_cipher.do_cipher = & acss_ciph;
#line 79
  acss_cipher.ctx_size = (int )sizeof(EVP_ACSS_KEY );
#line 80
  acss_cipher.ctrl = & acss_ctrl;
#line 82
  return ((EVP_CIPHER const   *)(& acss_cipher));
}
}
#line 1 "cipher-aes.o"
#pragma merger(0,"./cipher-aes.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "cipher-bf1.o"
#pragma merger(0,"./cipher-bf1.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 47 "cipher-bf1.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ u_char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 53
  n___0 /= 4;
#line 53
  while (n___0 > 0) {
#line 54
    tmp = src;
#line 54
    src ++;
#line 54
    c[3] = (unsigned char )*tmp;
#line 55
    tmp___0 = src;
#line 55
    src ++;
#line 55
    c[2] = (unsigned char )*tmp___0;
#line 56
    tmp___1 = src;
#line 56
    src ++;
#line 56
    c[1] = (unsigned char )*tmp___1;
#line 57
    tmp___2 = src;
#line 57
    src ++;
#line 57
    c[0] = (unsigned char )*tmp___2;
#line 59
    tmp___3 = dst;
#line 59
    dst ++;
#line 59
    *tmp___3 = c[0];
#line 60
    tmp___4 = dst;
#line 60
    dst ++;
#line 60
    *tmp___4 = c[1];
#line 61
    tmp___5 = dst;
#line 61
    dst ++;
#line 61
    *tmp___5 = c[2];
#line 62
    tmp___6 = dst;
#line 62
    dst ++;
#line 62
    *tmp___6 = c[3];
#line 53
    n___0 --;
  }
#line 64
  return;
}
}
#line 79 "cipher-bf1.c"
static int (*orig_bf)(EVP_CIPHER_CTX * , u_char * , u_char const   * , u_int  )  =    (int (*)(EVP_CIPHER_CTX * ,
            u_char * , u_char const   * , u_int  ))((void *)0);
#line 81 "cipher-bf1.c"
static int bf_ssh1_cipher(EVP_CIPHER_CTX *ctx , u_char *out , u_char const   *in ,
                          u_int len ) 
{ int ret___0 ;

  {
#line 86
  swap_bytes(in, out, (int )len);
#line 87
  ret___0 = (*orig_bf)(ctx, out, (u_char const   *)out, len);
#line 88
  swap_bytes((u_char const   *)out, out, (int )len);
#line 89
  return (ret___0);
}
}
#line 95 "cipher-bf1.c"
static EVP_CIPHER ssh1_bf  ;
#line 92 "cipher-bf1.c"
EVP_CIPHER const   *evp_ssh1_bf(void) 
{ EVP_CIPHER const   *tmp ;

  {
#line 97
  tmp = EVP_bf_cbc();
#line 97
  memcpy((void * __restrict  )(& ssh1_bf), (void const   * __restrict  )tmp, sizeof(EVP_CIPHER ));
#line 98
  orig_bf = ssh1_bf.do_cipher;
#line 99
  ssh1_bf.nid = 0;
#line 103
  ssh1_bf.do_cipher = & bf_ssh1_cipher;
#line 104
  ssh1_bf.key_len = 32;
#line 105
  return ((EVP_CIPHER const   *)(& ssh1_bf));
}
}
#line 1 "cipher-ctr.o"
#pragma merger(0,"./cipher-ctr.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 86 "/usr/include/openssl/aes.h"
extern int AES_set_encrypt_key(unsigned char const   *userKey , int bits , AES_KEY *key ) ;
#line 91
extern void AES_encrypt(unsigned char const   *in , unsigned char *out , AES_KEY const   *key ) ;
#line 50 "cipher-ctr.c"
static void ssh_ctr_inc(u_char *ctr , u_int len ) 
{ int i ;

  {
#line 55
  i = (int )(len - 1U);
#line 55
  while (i >= 0) {
#line 56
    *(ctr + i) = (u_char )((int )*(ctr + i) + 1);
#line 56
    if (*(ctr + i)) {
#line 57
      return;
    }
#line 55
    i --;
  }
#line 58
  return;
}
}
#line 60 "cipher-ctr.c"
static int ssh_aes_ctr(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                       u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;
  u_int n___0 ;
  u_char buf___1[16] ;
  u_char *tmp ;
  u_char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 65
  n___0 = (u_int )0;
#line 68
  if (len == 0U) {
#line 69
    return (1);
  }
#line 70
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 70
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 71
    return (0);
  }
#line 73
  while (1) {
#line 73
    tmp___1 = len;
#line 73
    len --;
#line 73
    if (! (tmp___1 > 0U)) {
#line 73
      break;
    }
#line 74
    if (n___0 == 0U) {
#line 75
      AES_encrypt((unsigned char const   *)(c->aes_counter), buf___1, (AES_KEY const   *)(& c->aes_ctx));
#line 76
      ssh_ctr_inc(c->aes_counter, 16U);
    }
#line 78
    tmp = dest;
#line 78
    dest ++;
#line 78
    tmp___0 = src;
#line 78
    src ++;
#line 78
    *tmp = (unsigned char )((int const   )*tmp___0 ^ (int const   )buf___1[n___0]);
#line 79
    n___0 = (n___0 + 1U) % 16U;
  }
#line 81
  return (1);
}
}
#line 84 "cipher-ctr.c"
static int ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                            int enc ) 
{ struct ssh_aes_ctr_ctx *c ;
  void *tmp ;

  {
#line 90
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 90
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 91
    tmp = xmalloc(sizeof(*c));
#line 91
    c = (struct ssh_aes_ctr_ctx *)tmp;
#line 92
    ctx->app_data = (void *)((char *)c);
  }
#line 94
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 95
    AES_set_encrypt_key(key, ctx->key_len * 8, & c->aes_ctx);
  }
#line 97
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 98
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           16U);
  }
#line 99
  return (1);
}
}
#line 102 "cipher-ctr.c"
static int ssh_aes_ctr_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 107
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 107
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 108
    memset((void *)c, 0, sizeof(*c));
#line 109
    xfree((void *)c);
#line 110
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 112
  return (1);
}
}
#line 115 "cipher-ctr.c"
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 120
  c = (struct ssh_aes_ctr_ctx *)evp->app_data;
#line 120
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 121
    fatal("ssh_aes_ctr_iv: no context");
  }
#line 122
  if (doset) {
#line 123
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           len);
  } else {
#line 125
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->aes_counter),
           len);
  }
#line 126
  return;
}
}
#line 131 "cipher-ctr.c"
static EVP_CIPHER aes_ctr  ;
#line 128 "cipher-ctr.c"
EVP_CIPHER const   *evp_aes_128_ctr(void) 
{ 

  {
#line 133
  memset((void *)(& aes_ctr), 0, sizeof(EVP_CIPHER ));
#line 134
  aes_ctr.nid = 0;
#line 135
  aes_ctr.block_size = 16;
#line 136
  aes_ctr.iv_len = 16;
#line 137
  aes_ctr.key_len = 16;
#line 138
  aes_ctr.init = & ssh_aes_ctr_init;
#line 139
  aes_ctr.cleanup = & ssh_aes_ctr_cleanup;
#line 140
  aes_ctr.do_cipher = & ssh_aes_ctr;
#line 142
  aes_ctr.flags = 58UL;
#line 145
  return ((EVP_CIPHER const   *)(& aes_ctr));
}
}
#line 1 "cipher-3des1.o"
#pragma merger(0,"./cipher-3des1.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 62 "cipher-3des1.c"
static int ssh1_3des_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                          int enc ) 
{ struct ssh1_3des_ctx *c ;
  u_char *k1 ;
  u_char *k2 ;
  u_char *k3 ;
  void *tmp ;
  EVP_CIPHER const   *tmp___0 ;
  int tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  EVP_CIPHER const   *tmp___4 ;
  int tmp___5 ;

  {
#line 69
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 69
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 70
    tmp = xmalloc(sizeof(*c));
#line 70
    c = (struct ssh1_3des_ctx *)tmp;
#line 71
    ctx->app_data = (void *)((char *)c);
  }
#line 73
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 74
    return (1);
  }
#line 75
  if (enc == -1) {
#line 76
    enc = ctx->encrypt;
  }
#line 77
  k3 = (u_char *)key;
#line 77
  k2 = k3;
#line 77
  k1 = k2;
#line 78
  k2 += 8;
#line 79
  if (ctx->key_len >= 24) {
#line 80
    if (enc) {
#line 81
      k3 += 16;
    } else {
#line 83
      k1 += 16;
    }
  }
#line 85
  EVP_CIPHER_CTX_init(& c->k1);
#line 86
  EVP_CIPHER_CTX_init(& c->k2);
#line 87
  EVP_CIPHER_CTX_init(& c->k3);
#line 93
  tmp___0 = EVP_des_cbc();
#line 93
  tmp___1 = EVP_CipherInit(& c->k1, tmp___0, (unsigned char const   *)k1, (unsigned char const   *)((void *)0),
                           enc);
#line 93
  if (tmp___1 == 0) {
#line 96
    memset((void *)c, 0, sizeof(*c));
#line 97
    xfree((void *)c);
#line 98
    ctx->app_data = (void *)((char *)((void *)0));
#line 99
    return (0);
  } else {
#line 93
    tmp___2 = EVP_des_cbc();
#line 93
    tmp___3 = EVP_CipherInit(& c->k2, tmp___2, (unsigned char const   *)k2, (unsigned char const   *)((void *)0),
                             ! enc);
#line 93
    if (tmp___3 == 0) {
#line 96
      memset((void *)c, 0, sizeof(*c));
#line 97
      xfree((void *)c);
#line 98
      ctx->app_data = (void *)((char *)((void *)0));
#line 99
      return (0);
    } else {
#line 93
      tmp___4 = EVP_des_cbc();
#line 93
      tmp___5 = EVP_CipherInit(& c->k3, tmp___4, (unsigned char const   *)k3, (unsigned char const   *)((void *)0),
                               enc);
#line 93
      if (tmp___5 == 0) {
#line 96
        memset((void *)c, 0, sizeof(*c));
#line 97
        xfree((void *)c);
#line 98
        ctx->app_data = (void *)((char *)((void *)0));
#line 99
        return (0);
      }
    }
  }
#line 102
  return (1);
}
}
#line 105 "cipher-3des1.c"
static int ssh1_3des_cbc(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                         u_int len ) 
{ struct ssh1_3des_ctx *c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 110
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 110
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 111
    error("ssh1_3des_cbc: no context");
#line 112
    return (0);
  }
#line 119
  tmp = (*((c->k1.cipher)->do_cipher))(& c->k1, dest, (unsigned char const   *)((u_char *)src),
                                       len);
#line 119
  if (tmp == 0) {
#line 122
    return (0);
  } else {
#line 119
    tmp___0 = (*((c->k2.cipher)->do_cipher))(& c->k2, dest, (unsigned char const   *)dest,
                                             len);
#line 119
    if (tmp___0 == 0) {
#line 122
      return (0);
    } else {
#line 119
      tmp___1 = (*((c->k3.cipher)->do_cipher))(& c->k3, dest, (unsigned char const   *)dest,
                                               len);
#line 119
      if (tmp___1 == 0) {
#line 122
        return (0);
      }
    }
  }
#line 124
  return (1);
}
}
#line 127 "cipher-3des1.c"
static int ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 132
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 132
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 133
    EVP_CIPHER_CTX_cleanup(& c->k1);
#line 134
    EVP_CIPHER_CTX_cleanup(& c->k2);
#line 135
    EVP_CIPHER_CTX_cleanup(& c->k3);
#line 136
    memset((void *)c, 0, sizeof(*c));
#line 137
    xfree((void *)c);
#line 138
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 140
  return (1);
}
}
#line 143 "cipher-3des1.c"
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 148
  if (len != 24) {
#line 149
    fatal("%s: bad 3des iv length: %d", "ssh1_3des_iv", len);
  }
#line 150
  c = (struct ssh1_3des_ctx *)evp->app_data;
#line 150
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 151
    fatal("%s: no 3des context", "ssh1_3des_iv");
  }
#line 152
  if (doset) {
#line 153
    debug3("%s: Installed 3DES IV", "ssh1_3des_iv");
#line 154
    memcpy((void * __restrict  )(c->k1.iv), (void const   * __restrict  )iv, 8U);
#line 155
    memcpy((void * __restrict  )(c->k2.iv), (void const   * __restrict  )(iv + 8),
           8U);
#line 156
    memcpy((void * __restrict  )(c->k3.iv), (void const   * __restrict  )(iv + 16),
           8U);
  } else {
#line 158
    debug3("%s: Copying 3DES IV", "ssh1_3des_iv");
#line 159
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->k1.iv), 8U);
#line 160
    memcpy((void * __restrict  )(iv + 8), (void const   * __restrict  )(c->k2.iv),
           8U);
#line 161
    memcpy((void * __restrict  )(iv + 16), (void const   * __restrict  )(c->k3.iv),
           8U);
  }
#line 163
  return;
}
}
#line 168 "cipher-3des1.c"
static EVP_CIPHER ssh1_3des  ;
#line 165 "cipher-3des1.c"
EVP_CIPHER const   *evp_ssh1_3des(void) 
{ 

  {
#line 170
  memset((void *)(& ssh1_3des), 0, sizeof(EVP_CIPHER ));
#line 171
  ssh1_3des.nid = 0;
#line 172
  ssh1_3des.block_size = 8;
#line 173
  ssh1_3des.iv_len = 0;
#line 174
  ssh1_3des.key_len = 16;
#line 175
  ssh1_3des.init = & ssh1_3des_init;
#line 176
  ssh1_3des.cleanup = & ssh1_3des_cleanup;
#line 177
  ssh1_3des.do_cipher = & ssh1_3des_cbc;
#line 179
  ssh1_3des.flags = 10UL;
#line 181
  return ((EVP_CIPHER const   *)(& ssh1_3des));
}
}
#line 1 "cleanup.o"
#pragma merger(0,"./cleanup.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 548 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 28 "cleanup.c"
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 28 "cleanup.c"
void cleanup_exit(int i ) 
{ 

  {
#line 31
  _exit(i);
}
}
#line 1 "compat.o"
#pragma merger(0,"./compat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 62 "compat.h"
void enable_compat13(void) ;
#line 63
void enable_compat20(void) ;
#line 64
void compat_datafellows(char const   *version___0 ) ;
#line 65
int proto_spec(char const   *spec ) ;
#line 66
char *compat_cipher_proposal(char *cipher_prop ) ;
#line 18 "match.h"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) ;
#line 41 "compat.c"
int compat13  =    0;
#line 42 "compat.c"
int compat20  =    0;
#line 43 "compat.c"
int datafellows  =    0;
#line 45 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 48
  debug("Enabling compatibility mode for protocol 2.0");
#line 49
  compat20 = 1;
#line 50
  return;
}
}
#line 51 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 54
  debug("Enabling compatibility mode for protocol 1.3");
#line 55
  compat13 = 1;
#line 56
  return;
}
}
#line 62 "compat.c"
static struct __anonstruct_check_52 check[31]  = 
#line 62
  {      {(char *)"OpenSSH-2.0*,OpenSSH-2.1*,OpenSSH_2.1*,OpenSSH_2.2*", 18923664}, 
        {(char *)"OpenSSH_2.3.0*", 18927744}, 
        {(char *)"OpenSSH_2.3.*", 18927616}, 
        {(char *)"OpenSSH_2.5.0p1*,OpenSSH_2.5.1p1*", 18927616}, 
        {(char *)"OpenSSH_2.5.0*,OpenSSH_2.5.1*,OpenSSH_2.5.2*", 18923520}, 
        {(char *)"OpenSSH_2.5.3*", 18907136}, 
        {(char *)"OpenSSH_2.*,OpenSSH_3.0*,OpenSSH_3.1*", 18874368}, 
        {(char *)"OpenSSH_3.*", 16777216}, 
        {(char *)"Sun_SSH_1.0*", 2129920}, 
        {(char *)"OpenSSH_4*", 0}, 
        {(char *)"OpenSSH*", 67108864}, 
        {(char *)"*MindTerm*", 0}, 
        {(char *)"2.1.0*", 8462421}, 
        {(char *)"2.1 *", 8462421}, 
        {(char *)"2.0.13*,2.0.14*,2.0.15*,2.0.16*,2.0.17*,2.0.18*,2.0.19*", 9642591}, 
        {(char *)"2.0.11*,2.0.12*",
      9577087}, 
        {(char *)"2.0.*", 9839231}, 
        {(char *)"2.2.0*,2.3.0*", 8396868}, 
        {(char *)"2.3.*", 8396864}, 
        {(char *)"2.4", 16}, 
        {(char *)"2.*", 41943104}, 
        {(char *)"3.0.*", 64}, 
        {(char *)"3.0 SecureCRT*", 16}, 
        {(char *)"1.7 SecureFX*", 16}, 
        {(char *)"1.2.18*,1.2.19*,1.2.20*,1.2.21*,1.2.22*", 256}, 
        {(char *)"1.3.2*", 256}, 
        {(char *)"*SSH Compatible Server*", 1024}, 
        {(char *)"*OSU_0*,OSU_1.0*,OSU_1.1*,OSU_1.2*,OSU_1.3*,OSU_1.4*,OSU_1.5alpha1*,OSU_1.5alpha2*,OSU_1.5alpha3*",
      1024}, 
        {(char *)"*SSH_Version_Mapper*", 2048}, 
        {(char *)"Probe-*", 4194304}, 
        {(char *)((void *)0), 0}};
#line 58 "compat.c"
void compat_datafellows(char const   *version___0 ) 
{ int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 168
  i = 0;
#line 168
  while (check[i].pat) {
#line 169
    tmp = strlen((char const   *)check[i].pat);
#line 169
    tmp___0 = match_pattern_list(version___0, (char const   *)check[i].pat, tmp, 0);
#line 169
    if (tmp___0 == 1) {
#line 171
      debug("match: %s pat %s", version___0, check[i].pat);
#line 172
      datafellows = check[i].bugs;
#line 173
      return;
    }
#line 168
    i ++;
  }
#line 176
  debug("no match: %s", version___0);
#line 177
  return;
}
}
#line 180 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret___0 ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 184
  ret___0 = 0;
#line 186
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 187
    return (ret___0);
  }
#line 188
  s = xstrdup(spec);
#line 188
  q = s;
#line 189
  tmp___14 = __strsep_g(& q, ",");
#line 189
  p = tmp___14;
#line 189
  while (1) {
#line 189
    if (p) {
#line 189
      if (! ((int )*p != 0)) {
#line 189
        break;
      }
    } else {
#line 189
      break;
    }
#line 190
    tmp___31 = atoi((char const   *)p);
#line 190
    switch (tmp___31) {
    case 1: 
#line 192
    if (ret___0 == 0) {
#line 193
      ret___0 |= 2;
    }
#line 194
    ret___0 |= 1;
#line 195
    break;
    case 2: 
#line 197
    ret___0 |= 4;
#line 198
    break;
    default: 
#line 200
    logit("ignoring bad proto spec: \'%s\'.", p);
#line 201
    break;
    }
#line 189
    tmp___30 = __strsep_g(& q, ",");
#line 189
    p = tmp___30;
  }
#line 204
  xfree((void *)s);
#line 205
  return (ret___0);
}
}
#line 208 "compat.c"
char *compat_cipher_proposal(char *cipher_prop ) 
{ Buffer b ;
  char *orig_prop ;
  char *fix_ciphers ;
  char *cp ;
  char *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___43 ;
  void *tmp___44 ;

  {
#line 215
  if (! (datafellows & 4096)) {
#line 216
    return (cipher_prop);
  }
#line 218
  buffer_init(& b);
#line 219
  orig_prop = xstrdup((char const   *)cipher_prop);
#line 219
  tmp = orig_prop;
#line 220
  while (1) {
#line 220
    tmp___43 = __strsep_g(& tmp, ",");
#line 220
    cp = tmp___43;
#line 220
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 220
      break;
    }
#line 221
    if (0) {
#line 221
      if (0) {
#line 221
        __s1_len___0 = strlen((char const   *)cp);
#line 221
        __s2_len___0 = strlen("aes");
#line 221
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 221
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 221
            if (! ((unsigned int )((void const   *)("aes" + 1)) - (unsigned int )((void const   *)"aes") == 1U)) {
#line 221
              tmp___25 = 1;
            } else {
#line 221
              if (__s2_len___0 >= 4U) {
#line 221
                tmp___25 = 1;
              } else {
#line 221
                tmp___25 = 0;
              }
            }
          } else {
#line 221
            tmp___25 = 0;
          }
        }
#line 221
        if (tmp___25) {
#line 221
          tmp___21 = __builtin_strcmp((char const   *)cp, "aes");
        } else {
#line 221
          tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 221
          tmp___21 = tmp___24;
        }
      } else {
#line 221
        tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 221
        tmp___21 = tmp___24;
      }
#line 221
      tmp___15 = tmp___21;
    } else {
#line 221
      tmp___15 = strncmp((char const   *)cp, "aes", 3U);
    }
#line 221
    if (tmp___15 != 0) {
#line 222
      tmp___0 = buffer_len(& b);
#line 222
      if (tmp___0 > 0U) {
#line 223
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 224
      tmp___1 = strlen((char const   *)cp);
#line 224
      buffer_append(& b, (void const   *)cp, tmp___1);
    }
  }
#line 227
  buffer_append(& b, (void const   *)"\000", 1U);
#line 228
  tmp___44 = buffer_ptr(& b);
#line 228
  fix_ciphers = xstrdup((char const   *)tmp___44);
#line 229
  buffer_free(& b);
#line 230
  xfree((void *)orig_prop);
#line 231
  debug2("Original cipher proposal: %s", cipher_prop);
#line 232
  debug2("Compat cipher proposal: %s", fix_ciphers);
#line 233
  if (! *fix_ciphers) {
#line 234
    fatal("No available ciphers found.");
  }
#line 236
  return (fix_ciphers);
}
}
#line 1 "compress.o"
#pragma merger(0,"./compress.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 19 "compress.h"
void buffer_compress_init_send(int level ) ;
#line 20
void buffer_compress_init_recv(void) ;
#line 21
void buffer_compress_uninit(void) ;
#line 22
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 23
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 26 "compress.c"
z_stream incoming_stream  ;
#line 27 "compress.c"
z_stream outgoing_stream  ;
#line 28 "compress.c"
static int compress_init_send_called  =    0;
#line 29 "compress.c"
static int compress_init_recv_called  =    0;
#line 30 "compress.c"
static int inflate_failed  =    0;
#line 31 "compress.c"
static int deflate_failed  =    0;
#line 38 "compress.c"
void buffer_compress_init_send(int level ) 
{ 

  {
#line 41
  if (compress_init_send_called == 1) {
#line 42
    deflateEnd(& outgoing_stream);
  }
#line 43
  compress_init_send_called = 1;
#line 44
  debug("Enabling compression at level %d.", level);
#line 45
  if (level < 1) {
#line 46
    fatal("Bad compression level %d.", level);
  } else {
#line 45
    if (level > 9) {
#line 46
      fatal("Bad compression level %d.", level);
    }
  }
#line 47
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 48
  return;
}
}
#line 49 "compress.c"
void buffer_compress_init_recv(void) 
{ 

  {
#line 52
  if (compress_init_recv_called == 1) {
#line 53
    inflateEnd(& incoming_stream);
  }
#line 54
  compress_init_recv_called = 1;
#line 55
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 56
  return;
}
}
#line 60 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 63
  if (outgoing_stream.total_in == 0UL) {
#line 63
    tmp = 0.0;
  } else {
#line 63
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 63
  debug("compress outgoing: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )outgoing_stream.total_in,
        (unsigned long long )outgoing_stream.total_out, tmp);
#line 68
  if (incoming_stream.total_out == 0UL) {
#line 68
    tmp___0 = 0.0;
  } else {
#line 68
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 68
  debug("compress incoming: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )incoming_stream.total_out,
        (unsigned long long )incoming_stream.total_in, tmp___0);
#line 73
  if (compress_init_recv_called == 1) {
#line 73
    if (inflate_failed == 0) {
#line 74
      inflateEnd(& incoming_stream);
    }
  }
#line 75
  if (compress_init_send_called == 1) {
#line 75
    if (deflate_failed == 0) {
#line 76
      deflateEnd(& outgoing_stream);
    }
  }
#line 77
  return;
}
}
#line 88 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 95
  tmp = buffer_len(input_buffer);
#line 95
  if (tmp == 0U) {
#line 96
    return;
  }
#line 99
  tmp___0 = buffer_ptr(input_buffer);
#line 99
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 100
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 103
  while (1) {
#line 105
    outgoing_stream.next_out = buf___1;
#line 106
    outgoing_stream.avail_out = sizeof(buf___1);
#line 109
    status = deflate(& outgoing_stream, 1);
#line 110
    switch (status) {
    case 0: 
#line 113
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 115
    break;
    default: 
#line 117
    deflate_failed = 1;
#line 118
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 103
    if (! (outgoing_stream.avail_out == 0U)) {
#line 103
      break;
    }
  }
#line 122
  return;
}
}
#line 133 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  void *tmp ;

  {
#line 139
  tmp = buffer_ptr(input_buffer);
#line 139
  incoming_stream.next_in = (Bytef *)tmp;
#line 140
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 142
  while (1) {
#line 144
    incoming_stream.next_out = buf___1;
#line 145
    incoming_stream.avail_out = sizeof(buf___1);
#line 147
    status = inflate(& incoming_stream, 1);
#line 148
    switch (status) {
    case 0: 
#line 150
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 152
    break;
    case -5: 
#line 159
    return;
    default: 
#line 161
    inflate_failed = 1;
#line 162
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#pragma merger(0,"./crc32.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 29 "crc32.h"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) ;
#line 29 "crc32.c"
static u_int32_t const   crc32tab[256]  = 
#line 29 "crc32.c"
  {      (u_int32_t const   )0L,      (u_int32_t const   )1996959894L,      (u_int32_t const   )3993919788UL,      (u_int32_t const   )2567524794UL, 
        (u_int32_t const   )124634137L,      (u_int32_t const   )1886057615L,      (u_int32_t const   )3915621685UL,      (u_int32_t const   )2657392035UL, 
        (u_int32_t const   )249268274L,      (u_int32_t const   )2044508324L,      (u_int32_t const   )3772115230UL,      (u_int32_t const   )2547177864UL, 
        (u_int32_t const   )162941995L,      (u_int32_t const   )2125561021L,      (u_int32_t const   )3887607047UL,      (u_int32_t const   )2428444049UL, 
        (u_int32_t const   )498536548L,      (u_int32_t const   )1789927666L,      (u_int32_t const   )4089016648UL,      (u_int32_t const   )2227061214UL, 
        (u_int32_t const   )450548861L,      (u_int32_t const   )1843258603L,      (u_int32_t const   )4107580753UL,      (u_int32_t const   )2211677639UL, 
        (u_int32_t const   )325883990L,      (u_int32_t const   )1684777152L,      (u_int32_t const   )4251122042UL,      (u_int32_t const   )2321926636UL, 
        (u_int32_t const   )335633487L,      (u_int32_t const   )1661365465L,      (u_int32_t const   )4195302755UL,      (u_int32_t const   )2366115317UL, 
        (u_int32_t const   )997073096L,      (u_int32_t const   )1281953886L,      (u_int32_t const   )3579855332UL,      (u_int32_t const   )2724688242UL, 
        (u_int32_t const   )1006888145L,      (u_int32_t const   )1258607687L,      (u_int32_t const   )3524101629UL,      (u_int32_t const   )2768942443UL, 
        (u_int32_t const   )901097722L,      (u_int32_t const   )1119000684L,      (u_int32_t const   )3686517206UL,      (u_int32_t const   )2898065728UL, 
        (u_int32_t const   )853044451L,      (u_int32_t const   )1172266101L,      (u_int32_t const   )3705015759UL,      (u_int32_t const   )2882616665UL, 
        (u_int32_t const   )651767980L,      (u_int32_t const   )1373503546L,      (u_int32_t const   )3369554304UL,      (u_int32_t const   )3218104598UL, 
        (u_int32_t const   )565507253L,      (u_int32_t const   )1454621731L,      (u_int32_t const   )3485111705UL,      (u_int32_t const   )3099436303UL, 
        (u_int32_t const   )671266974L,      (u_int32_t const   )1594198024L,      (u_int32_t const   )3322730930UL,      (u_int32_t const   )2970347812UL, 
        (u_int32_t const   )795835527L,      (u_int32_t const   )1483230225L,      (u_int32_t const   )3244367275UL,      (u_int32_t const   )3060149565UL, 
        (u_int32_t const   )1994146192L,      (u_int32_t const   )31158534L,      (u_int32_t const   )2563907772UL,      (u_int32_t const   )4023717930UL, 
        (u_int32_t const   )1907459465L,      (u_int32_t const   )112637215L,      (u_int32_t const   )2680153253UL,      (u_int32_t const   )3904427059UL, 
        (u_int32_t const   )2013776290L,      (u_int32_t const   )251722036L,      (u_int32_t const   )2517215374UL,      (u_int32_t const   )3775830040UL, 
        (u_int32_t const   )2137656763L,      (u_int32_t const   )141376813L,      (u_int32_t const   )2439277719UL,      (u_int32_t const   )3865271297UL, 
        (u_int32_t const   )1802195444L,      (u_int32_t const   )476864866L,      (u_int32_t const   )2238001368UL,      (u_int32_t const   )4066508878UL, 
        (u_int32_t const   )1812370925L,      (u_int32_t const   )453092731L,      (u_int32_t const   )2181625025UL,      (u_int32_t const   )4111451223UL, 
        (u_int32_t const   )1706088902L,      (u_int32_t const   )314042704L,      (u_int32_t const   )2344532202UL,      (u_int32_t const   )4240017532UL, 
        (u_int32_t const   )1658658271L,      (u_int32_t const   )366619977L,      (u_int32_t const   )2362670323UL,      (u_int32_t const   )4224994405UL, 
        (u_int32_t const   )1303535960L,      (u_int32_t const   )984961486L,      (u_int32_t const   )2747007092UL,      (u_int32_t const   )3569037538UL, 
        (u_int32_t const   )1256170817L,      (u_int32_t const   )1037604311L,      (u_int32_t const   )2765210733UL,      (u_int32_t const   )3554079995UL, 
        (u_int32_t const   )1131014506L,      (u_int32_t const   )879679996L,      (u_int32_t const   )2909243462UL,      (u_int32_t const   )3663771856UL, 
        (u_int32_t const   )1141124467L,      (u_int32_t const   )855842277L,      (u_int32_t const   )2852801631UL,      (u_int32_t const   )3708648649UL, 
        (u_int32_t const   )1342533948L,      (u_int32_t const   )654459306L,      (u_int32_t const   )3188396048UL,      (u_int32_t const   )3373015174UL, 
        (u_int32_t const   )1466479909L,      (u_int32_t const   )544179635L,      (u_int32_t const   )3110523913UL,      (u_int32_t const   )3462522015UL, 
        (u_int32_t const   )1591671054L,      (u_int32_t const   )702138776L,      (u_int32_t const   )2966460450UL,      (u_int32_t const   )3352799412UL, 
        (u_int32_t const   )1504918807L,      (u_int32_t const   )783551873L,      (u_int32_t const   )3082640443UL,      (u_int32_t const   )3233442989UL, 
        (u_int32_t const   )3988292384UL,      (u_int32_t const   )2596254646UL,      (u_int32_t const   )62317068L,      (u_int32_t const   )1957810842L, 
        (u_int32_t const   )3939845945UL,      (u_int32_t const   )2647816111UL,      (u_int32_t const   )81470997L,      (u_int32_t const   )1943803523L, 
        (u_int32_t const   )3814918930UL,      (u_int32_t const   )2489596804UL,      (u_int32_t const   )225274430L,      (u_int32_t const   )2053790376L, 
        (u_int32_t const   )3826175755UL,      (u_int32_t const   )2466906013UL,      (u_int32_t const   )167816743L,      (u_int32_t const   )2097651377L, 
        (u_int32_t const   )4027552580UL,      (u_int32_t const   )2265490386UL,      (u_int32_t const   )503444072L,      (u_int32_t const   )1762050814L, 
        (u_int32_t const   )4150417245UL,      (u_int32_t const   )2154129355UL,      (u_int32_t const   )426522225L,      (u_int32_t const   )1852507879L, 
        (u_int32_t const   )4275313526UL,      (u_int32_t const   )2312317920UL,      (u_int32_t const   )282753626L,      (u_int32_t const   )1742555852L, 
        (u_int32_t const   )4189708143UL,      (u_int32_t const   )2394877945UL,      (u_int32_t const   )397917763L,      (u_int32_t const   )1622183637L, 
        (u_int32_t const   )3604390888UL,      (u_int32_t const   )2714866558UL,      (u_int32_t const   )953729732L,      (u_int32_t const   )1340076626L, 
        (u_int32_t const   )3518719985UL,      (u_int32_t const   )2797360999UL,      (u_int32_t const   )1068828381L,      (u_int32_t const   )1219638859L, 
        (u_int32_t const   )3624741850UL,      (u_int32_t const   )2936675148UL,      (u_int32_t const   )906185462L,      (u_int32_t const   )1090812512L, 
        (u_int32_t const   )3747672003UL,      (u_int32_t const   )2825379669UL,      (u_int32_t const   )829329135L,      (u_int32_t const   )1181335161L, 
        (u_int32_t const   )3412177804UL,      (u_int32_t const   )3160834842UL,      (u_int32_t const   )628085408L,      (u_int32_t const   )1382605366L, 
        (u_int32_t const   )3423369109UL,      (u_int32_t const   )3138078467UL,      (u_int32_t const   )570562233L,      (u_int32_t const   )1426400815L, 
        (u_int32_t const   )3317316542UL,      (u_int32_t const   )2998733608UL,      (u_int32_t const   )733239954L,      (u_int32_t const   )1555261956L, 
        (u_int32_t const   )3268935591UL,      (u_int32_t const   )3050360625UL,      (u_int32_t const   )752459403L,      (u_int32_t const   )1541320221L, 
        (u_int32_t const   )2607071920UL,      (u_int32_t const   )3965973030UL,      (u_int32_t const   )1969922972L,      (u_int32_t const   )40735498L, 
        (u_int32_t const   )2617837225UL,      (u_int32_t const   )3943577151UL,      (u_int32_t const   )1913087877L,      (u_int32_t const   )83908371L, 
        (u_int32_t const   )2512341634UL,      (u_int32_t const   )3803740692UL,      (u_int32_t const   )2075208622L,      (u_int32_t const   )213261112L, 
        (u_int32_t const   )2463272603UL,      (u_int32_t const   )3855990285UL,      (u_int32_t const   )2094854071L,      (u_int32_t const   )198958881L, 
        (u_int32_t const   )2262029012UL,      (u_int32_t const   )4057260610UL,      (u_int32_t const   )1759359992L,      (u_int32_t const   )534414190L, 
        (u_int32_t const   )2176718541UL,      (u_int32_t const   )4139329115UL,      (u_int32_t const   )1873836001L,      (u_int32_t const   )414664567L, 
        (u_int32_t const   )2282248934UL,      (u_int32_t const   )4279200368UL,      (u_int32_t const   )1711684554L,      (u_int32_t const   )285281116L, 
        (u_int32_t const   )2405801727UL,      (u_int32_t const   )4167216745UL,      (u_int32_t const   )1634467795L,      (u_int32_t const   )376229701L, 
        (u_int32_t const   )2685067896UL,      (u_int32_t const   )3608007406UL,      (u_int32_t const   )1308918612L,      (u_int32_t const   )956543938L, 
        (u_int32_t const   )2808555105UL,      (u_int32_t const   )3495958263UL,      (u_int32_t const   )1231636301L,      (u_int32_t const   )1047427035L, 
        (u_int32_t const   )2932959818UL,      (u_int32_t const   )3654703836UL,      (u_int32_t const   )1088359270L,      (u_int32_t const   )936918000L, 
        (u_int32_t const   )2847714899UL,      (u_int32_t const   )3736837829UL,      (u_int32_t const   )1202900863L,      (u_int32_t const   )817233897L, 
        (u_int32_t const   )3183342108UL,      (u_int32_t const   )3401237130UL,      (u_int32_t const   )1404277552L,      (u_int32_t const   )615818150L, 
        (u_int32_t const   )3134207493UL,      (u_int32_t const   )3453421203UL,      (u_int32_t const   )1423857449L,      (u_int32_t const   )601450431L, 
        (u_int32_t const   )3009837614UL,      (u_int32_t const   )3294710456UL,      (u_int32_t const   )1567103746L,      (u_int32_t const   )711928724L, 
        (u_int32_t const   )3020668471UL,      (u_int32_t const   )3272380065UL,      (u_int32_t const   )1510334235L,      (u_int32_t const   )755167117L};
#line 96 "crc32.c"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) 
{ u_int32_t i ;
  u_int32_t crc ;

  {
#line 101
  crc = 0U;
#line 102
  i = 0U;
#line 102
  while (i < size) {
#line 103
    crc = (unsigned int )(crc32tab[(crc ^ (unsigned int )*(buf___1 + i)) & 255U] ^ (unsigned int const   )(crc >> 8));
#line 102
    i ++;
  }
#line 104
  return (crc);
}
}
#line 1 "deattack.o"
#pragma merger(0,"./deattack.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 30 "deattack.h"
int detect_attack(u_char *buf___1 , u_int32_t len ) ;
#line 73 "deattack.c"
static void crc_update(u_int32_t *a___0 , u_int32_t b ) 
{ 

  {
#line 76
  b ^= *a___0;
#line 77
  *a___0 = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 78
  return;
}
}
#line 81 "deattack.c"
static int check_crc(u_char *S , u_char *buf___1 , u_int32_t len ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;

  {
#line 87
  crc = 0U;
#line 88
  c = buf___1;
#line 88
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 89
    tmp = memcmp((void const   *)S, (void const   *)c, 8U);
#line 89
    if (tmp) {
#line 93
      crc_update(& crc, 0U);
#line 94
      crc_update(& crc, 0U);
    } else {
#line 90
      crc_update(& crc, 1U);
#line 91
      crc_update(& crc, 0U);
    }
#line 88
    c += 8;
  }
#line 97
  return (crc == 0U);
}
}
#line 105 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 106 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 102 "deattack.c"
int detect_attack(u_char *buf___1 , u_int32_t len ) 
{ u_int32_t i ;
  u_int32_t j ;
  u_int32_t l ;
  u_int32_t same ;
  u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u_int32_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 112
  if (len > 262144U) {
#line 114
    fatal("detect_attack: bad length %d", len);
  } else {
#line 112
    if (len % 8U != 0U) {
#line 114
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 116
  l = n;
#line 116
  while (l < ((len / 8U) * 3U) / 2U) {
#line 116
    l <<= 2;
  }
#line 119
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 120
    debug("Installing crc compensation attack detector.");
#line 121
    tmp = xcalloc(l, 2U);
#line 121
    h = (u_int16_t *)tmp;
#line 122
    n = l;
  } else {
#line 124
    if (l > n) {
#line 125
      tmp___0 = xrealloc((void *)h, l, 2U);
#line 125
      h = (u_int16_t *)tmp___0;
#line 126
      n = l;
    }
  }
#line 130
  if (len <= 56U) {
#line 131
    c = buf___1;
#line 131
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 132
      d = buf___1;
#line 132
      while ((unsigned int )d < (unsigned int )c) {
#line 133
        tmp___2 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 133
        if (! tmp___2) {
#line 134
          tmp___1 = check_crc(c, buf___1, len);
#line 134
          if (tmp___1) {
#line 135
            return (1);
          } else {
#line 137
            break;
          }
        }
#line 132
        d += 8;
      }
#line 131
      c += 8;
    }
#line 141
    return (0);
  }
#line 143
  memset((void *)h, 255, n * 2U);
#line 145
  c = buf___1;
#line 145
  j = 0U;
#line 145
  same = j;
#line 145
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 146
    tmp___3 = get_u32((void const   *)c);
#line 146
    i = tmp___3 & (n - 1U);
#line 146
    while ((int )*(h + i) != 65535) {
#line 148
      tmp___5 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                       8U);
#line 148
      if (! tmp___5) {
#line 149
        same ++;
#line 149
        if (same > 32U) {
#line 150
          return (2);
        }
#line 151
        tmp___4 = check_crc(c, buf___1, len);
#line 151
        if (tmp___4) {
#line 152
          return (1);
        } else {
#line 154
          break;
        }
      }
#line 146
      i = (i + 1U) & (n - 1U);
    }
#line 157
    *(h + i) = (unsigned short )j;
#line 145
    c += 8;
#line 145
    j ++;
  }
#line 159
  return (0);
}
}
#line 1 "fatal.o"
#pragma merger(0,"./fatal.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 67 "log.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 36 "fatal.c"
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 36 "fatal.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 41
  __builtin_va_start(args, fmt);
#line 42
  do_log(1, fmt, args);
#line 43
  __builtin_va_end(args);
#line 44
  cleanup_exit(255);
}
}
#line 1 "hostfile.o"
#pragma merger(0,"./hostfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 532 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 597 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_sha1(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 19 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 63 "key.h"
int key_equal(Key const   *a___0 , Key const   *b ) ;
#line 67
int key_write(Key const   *key , FILE *f ) ;
#line 69
u_int key_size(Key const   *k ) ;
#line 21 "hostfile.h"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret___0 ) ;
#line 22
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) ;
#line 24
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ,
                         int store_hash ) ;
#line 25
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) ;
#line 31
char *host_hash(char const   *host , char const   *name_from_hostfile , u_int src_len ) ;
#line 60 "hostfile.c"
static int extract_salt(char const   *s , u_int l , char *salt , size_t salt_len ) 
{ char *p ;
  char *b64salt ;
  u_int b64len ;
  int ret___0 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  void *tmp___26 ;

  {
#line 67
  if (l < sizeof("|1|") - 1U) {
#line 68
    debug2("extract_salt: string too short");
#line 69
    return (-1);
  }
#line 71
  if (0) {
#line 71
    if (0) {
#line 71
      __s1_len___0 = strlen(s);
#line 71
      __s2_len___0 = strlen("|1|");
#line 71
      if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
        goto _L___2;
      } else {
#line 71
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 71
          if (! ((unsigned int )((void const   *)("|1|" + 1)) - (unsigned int )((void const   *)"|1|") == 1U)) {
#line 71
            tmp___22 = 1;
          } else {
#line 71
            if (__s2_len___0 >= 4U) {
#line 71
              tmp___22 = 1;
            } else {
#line 71
              tmp___22 = 0;
            }
          }
        } else {
#line 71
          tmp___22 = 0;
        }
      }
#line 71
      if (tmp___22) {
#line 71
        tmp___18 = __builtin_strcmp(s, "|1|");
      } else {
#line 71
        tmp___21 = __builtin_strcmp(s, "|1|");
#line 71
        tmp___18 = tmp___21;
      }
    } else {
#line 71
      tmp___21 = __builtin_strcmp(s, "|1|");
#line 71
      tmp___18 = tmp___21;
    }
#line 71
    tmp___12 = tmp___18;
  } else {
#line 71
    tmp___12 = strncmp(s, "|1|", sizeof("|1|") - 1U);
  }
#line 71
  if (tmp___12 != 0) {
#line 72
    debug2("extract_salt: invalid magic identifier");
#line 73
    return (-1);
  }
#line 75
  s += sizeof("|1|") - 1U;
#line 76
  l -= sizeof("|1|") - 1U;
#line 77
  tmp___25 = memchr((void const   *)s, '|', l);
#line 77
  p = (char *)tmp___25;
#line 77
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 78
    debug2("extract_salt: missing salt termination character");
#line 79
    return (-1);
  }
#line 82
  b64len = (unsigned int )(p - (char *)s);
#line 84
  if (b64len == 0U) {
#line 85
    debug2("extract_salt: bad encoded salt length %u", b64len);
#line 86
    return (-1);
  } else {
#line 84
    if (b64len > 1024U) {
#line 85
      debug2("extract_salt: bad encoded salt length %u", b64len);
#line 86
      return (-1);
    }
  }
#line 88
  tmp___26 = xmalloc(1U + b64len);
#line 88
  b64salt = (char *)tmp___26;
#line 89
  memcpy((void * __restrict  )b64salt, (void const   * __restrict  )s, b64len);
#line 90
  *(b64salt + b64len) = (char )'\000';
#line 92
  ret___0 = __b64_pton((char const   *)b64salt, (u_char *)salt, salt_len);
#line 93
  xfree((void *)b64salt);
#line 94
  if (ret___0 == -1) {
#line 95
    debug2("extract_salt: salt decode error");
#line 96
    return (-1);
  }
#line 98
  if (ret___0 != 20) {
#line 99
    debug2("extract_salt: expected salt len %d, got %d", 20, ret___0);
#line 101
    return (-1);
  }
#line 104
  return (0);
}
}
#line 113 "hostfile.c"
static char encoded[1024]  ;
#line 107 "hostfile.c"
char *host_hash(char const   *host , char const   *name_from_hostfile , u_int src_len ) 
{ EVP_MD const   *md ;
  EVP_MD const   *tmp ;
  HMAC_CTX mac_ctx ;
  char salt[256] ;
  char result[256] ;
  char uu_salt[512] ;
  char uu_result[512] ;
  u_int i ;
  u_int len ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 110
  tmp = EVP_sha1();
#line 110
  md = tmp;
#line 116
  len = (unsigned int )md->md_size;
#line 118
  if ((unsigned int )name_from_hostfile == (unsigned int )((void *)0)) {
#line 120
    i = 0U;
#line 120
    while (i < len) {
#line 121
      tmp___0 = arc4random();
#line 121
      salt[i] = (char )tmp___0;
#line 120
      i ++;
    }
  } else {
#line 124
    tmp___1 = extract_salt(name_from_hostfile, src_len, salt, sizeof(salt));
#line 124
    if (tmp___1 == -1) {
#line 126
      return ((char *)((void *)0));
    }
  }
#line 129
  HMAC_Init(& mac_ctx, (void const   *)(salt), (int )len, md);
#line 130
  tmp___2 = strlen(host);
#line 130
  HMAC_Update(& mac_ctx, (unsigned char const   *)host, tmp___2);
#line 131
  HMAC_Final(& mac_ctx, (unsigned char *)(result), (unsigned int *)((void *)0));
#line 132
  HMAC_CTX_cleanup(& mac_ctx);
#line 134
  tmp___3 = __b64_ntop((u_char const   *)(salt), len, uu_salt, sizeof(uu_salt));
#line 134
  if (tmp___3 == -1) {
#line 136
    fatal("host_hash: __b64_ntop failed");
  } else {
#line 134
    tmp___4 = __b64_ntop((u_char const   *)(result), len, uu_result, sizeof(uu_result));
#line 134
    if (tmp___4 == -1) {
#line 136
      fatal("host_hash: __b64_ntop failed");
    }
  }
#line 138
  snprintf((char * __restrict  )(encoded), sizeof(encoded), (char const   * __restrict  )"%s%s%c%s",
           "|1|", uu_salt, '|', uu_result);
#line 141
  return (encoded);
}
}
#line 149 "hostfile.c"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret___0 ) 
{ char *cp ;
  int tmp ;

  {
#line 155
  cp = *cpp;
#line 155
  while (1) {
#line 155
    if (! ((int )*cp == 32)) {
#line 155
      if (! ((int )*cp == 9)) {
#line 155
        break;
      }
    }
#line 155
    cp ++;
  }
#line 158
  tmp = key_read(ret___0, & cp);
#line 158
  if (tmp != 1) {
#line 159
    return (0);
  }
#line 162
  while (1) {
#line 162
    if (! ((int )*cp == 32)) {
#line 162
      if (! ((int )*cp == 9)) {
#line 162
        break;
      }
    }
#line 162
    cp ++;
  }
#line 166
  *cpp = cp;
#line 167
  *bitsp = key_size((Key const   *)ret___0);
#line 168
  return (1);
}
}
#line 171 "hostfile.c"
static int hostfile_check_key(int bits , Key const   *key , char const   *host , char const   *filename ,
                              int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 174
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 175
    return (1);
  } else {
#line 174
    if (key->type != 0) {
#line 175
      return (1);
    } else {
#line 174
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 175
        return (1);
      }
    }
  }
#line 176
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 176
  if (bits != tmp___1) {
#line 177
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 177
    logit("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
          filename, linenum, host, tmp, bits);
#line 180
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 180
    logit("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename,
          linenum);
  }
#line 183
  return (1);
}
}
#line 196 "hostfile.c"
static HostStatus check_host_in_hostfile_by_key_or_type(char const   *filename , char const   *host ,
                                                        Key const   *key , int keytype ,
                                                        Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  char *cp ;
  char *cp2 ;
  char *hashed_host ;
  HostStatus end_return ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;

  {
#line 202
  linenum = 0;
#line 207
  debug3("check_host_in_hostfile: filename %s", filename);
#line 210
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 211
  if (! f) {
#line 212
    return (1);
  }
#line 219
  end_return = 1;
#line 222
  while (1) {
#line 222
    tmp___29 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 222
    if (! tmp___29) {
#line 222
      break;
    }
#line 223
    cp = line;
#line 224
    linenum ++;
#line 227
    while (1) {
#line 227
      if (! ((int )*cp == 32)) {
#line 227
        if (! ((int )*cp == 9)) {
#line 227
          break;
        }
      }
#line 227
      cp ++;
    }
#line 229
    if (! *cp) {
#line 230
      continue;
    } else {
#line 229
      if ((int )*cp == 35) {
#line 230
        continue;
      } else {
#line 229
        if ((int )*cp == 10) {
#line 230
          continue;
        }
      }
    }
#line 233
    cp2 = cp;
#line 233
    while (1) {
#line 233
      if (*cp2) {
#line 233
        if ((int )*cp2 != 32) {
#line 233
          if (! ((int )*cp2 != 9)) {
#line 233
            break;
          }
        } else {
#line 233
          break;
        }
      } else {
#line 233
        break;
      }
#line 233
      cp2 ++;
    }
#line 237
    tmp___25 = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 237
    if (tmp___25 != 1) {
#line 238
      if ((int )*cp != 124) {
#line 239
        continue;
      }
#line 240
      hashed_host = host_hash(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 241
      if ((unsigned int )hashed_host == (unsigned int )((void *)0)) {
#line 242
        debug("Invalid hashed host line %d of %s", linenum, filename);
#line 244
        continue;
      }
#line 246
      if (0) {
#line 246
        if (0) {
#line 246
          __s1_len___0 = strlen((char const   *)hashed_host);
#line 246
          __s2_len___0 = strlen((char const   *)cp);
#line 246
          if (! ((unsigned int )((void const   *)(hashed_host + 1)) - (unsigned int )((void const   *)hashed_host) == 1U)) {
            goto _L___2;
          } else {
#line 246
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 246
              if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 246
                tmp___22 = 1;
              } else {
#line 246
                if (__s2_len___0 >= 4U) {
#line 246
                  tmp___22 = 1;
                } else {
#line 246
                  tmp___22 = 0;
                }
              }
            } else {
#line 246
              tmp___22 = 0;
            }
          }
#line 246
          if (tmp___22) {
#line 246
            tmp___18 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
          } else {
#line 246
            tmp___21 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
#line 246
            tmp___18 = tmp___21;
          }
        } else {
#line 246
          tmp___21 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
#line 246
          tmp___18 = tmp___21;
        }
#line 246
        tmp___12 = tmp___18;
      } else {
#line 246
        tmp___12 = strncmp((char const   *)hashed_host, (char const   *)cp, (unsigned int )(cp2 - cp));
      }
#line 246
      if (tmp___12 != 0) {
#line 247
        continue;
      }
    }
#line 251
    cp = cp2;
#line 257
    tmp___26 = hostfile_read_key(& cp, & kbits, found);
#line 257
    if (! tmp___26) {
#line 258
      continue;
    }
#line 260
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 261
      *numret = linenum;
    }
#line 263
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 265
      if (found->type == keytype) {
#line 266
        fclose(f);
#line 267
        return (3);
      }
#line 269
      continue;
    }
#line 272
    tmp___27 = hostfile_check_key((int )kbits, (Key const   *)found, host, filename,
                                  linenum);
#line 272
    if (! tmp___27) {
#line 273
      continue;
    }
#line 276
    tmp___28 = key_equal(key, (Key const   *)found);
#line 276
    if (tmp___28) {
#line 278
      debug3("check_host_in_hostfile: match line %d", linenum);
#line 279
      fclose(f);
#line 280
      return (0);
    }
#line 287
    end_return = 2;
  }
#line 290
  fclose(f);
#line 296
  return (end_return);
}
}
#line 299 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 303
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 304
    fatal("no key to look up");
  }
#line 305
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, key, 0, found, numret);
#line 305
  return (tmp);
}
}
#line 309 "hostfile.c"
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 313
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, (Key const   *)((void *)0),
                                              keytype, found, numret);
#line 313
  return ((int )tmp == 3);
}
}
#line 322 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ,
                         int store_hash ) 
{ FILE *f ;
  int success ;
  char *hashed_host ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 327
  success = 0;
#line 328
  hashed_host = (char *)((void *)0);
#line 330
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 331
    return (1);
  }
#line 332
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 333
  if (! f) {
#line 334
    return (0);
  }
#line 336
  if (store_hash) {
#line 337
    hashed_host = host_hash(host, (char const   *)((void *)0), 0U);
#line 337
    if ((unsigned int )hashed_host == (unsigned int )((void *)0)) {
#line 338
      error("add_host_to_hostfile: host_hash failed");
#line 339
      fclose(f);
#line 340
      return (0);
    }
  }
#line 343
  if (store_hash) {
#line 343
    tmp = (char const   *)hashed_host;
  } else {
#line 343
    tmp = host;
  }
#line 343
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", tmp);
#line 345
  tmp___0 = key_write(key, f);
#line 345
  if (tmp___0) {
#line 346
    success = 1;
  } else {
#line 348
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 350
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 351
  fclose(f);
#line 352
  return (success);
}
}
#line 1 "log.o"
#pragma merger(0,"./log.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 49 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 51
SyslogFacility log_facility_number(char *name ) ;
#line 52
char const   *log_facility_name(SyslogFacility facility ) ;
#line 53
LogLevel log_level_number(char *name ) ;
#line 54
char const   *log_level_name(LogLevel level ) ;
#line 59
 __attribute__((__noreturn__)) void ( /* format attribute */  sigdie)(char const   *fmt 
                                                                      , ...) ;
#line 55 "log.c"
static LogLevel log_level___0  =    3;
#line 56 "log.c"
static int log_on_stderr  =    1;
#line 57 "log.c"
static int log_facility  =    4 << 3;
#line 58 "log.c"
static char *argv0  ;
#line 67 "log.c"
static struct __anonstruct_log_facilities_55 log_facilities[13]  = 
#line 67
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"AUTHPRIV", 3}, 
        {"LOCAL0", 4}, 
        {"LOCAL1", 5}, 
        {"LOCAL2", 6}, 
        {"LOCAL3", 7}, 
        {"LOCAL4", 8}, 
        {"LOCAL5", 9}, 
        {"LOCAL6", 10}, 
        {"LOCAL7", 11}, 
        {(char const   *)((void *)0), -1}};
#line 88 "log.c"
static struct __anonstruct_log_levels_56 log_levels[10]  = 
#line 88
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), -1}};
#line 105 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 110
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 111
    i = 0;
#line 111
    while (log_facilities[i].name) {
#line 112
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 112
      if (tmp == 0) {
#line 113
        return (log_facilities[i].val);
      }
#line 111
      i ++;
    }
  }
#line 114
  return (-1);
}
}
#line 117 "log.c"
char const   *log_facility_name(SyslogFacility facility ) 
{ u_int i ;

  {
#line 122
  i = 0U;
#line 122
  while (log_facilities[i].name) {
#line 123
    if ((int )log_facilities[i].val == (int )facility) {
#line 124
      return (log_facilities[i].name);
    }
#line 122
    i ++;
  }
#line 125
  return ((char const   *)((void *)0));
}
}
#line 128 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 133
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 134
    i = 0;
#line 134
    while (log_levels[i].name) {
#line 135
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 135
      if (tmp == 0) {
#line 136
        return (log_levels[i].val);
      }
#line 134
      i ++;
    }
  }
#line 137
  return (-1);
}
}
#line 140 "log.c"
char const   *log_level_name(LogLevel level ) 
{ u_int i ;

  {
#line 145
  i = 0U;
#line 145
  while ((unsigned int )log_levels[i].name != (unsigned int )((void *)0)) {
#line 146
    if ((int )log_levels[i].val == (int )level) {
#line 147
      return (log_levels[i].name);
    }
#line 145
    i ++;
  }
#line 148
  return ((char const   *)((void *)0));
}
}
#line 153 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 158
  __builtin_va_start(args, fmt);
#line 159
  do_log(2, fmt, args);
#line 160
  __builtin_va_end(args);
#line 161
  return;
}
}
#line 163
 __attribute__((__noreturn__)) void ( /* format attribute */  sigdie)(char const   *fmt 
                                                                      , ...) ;
#line 163 "log.c"
void ( /* format attribute */  sigdie)(char const   *fmt  , ...) 
{ 

  {
#line 173
  _exit(1);
}
}
#line 179 "log.c"
void ( /* format attribute */  logit)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 184
  __builtin_va_start(args, fmt);
#line 185
  do_log(3, fmt, args);
#line 186
  __builtin_va_end(args);
#line 187
  return;
}
}
#line 191 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 196
  __builtin_va_start(args, fmt);
#line 197
  do_log(4, fmt, args);
#line 198
  __builtin_va_end(args);
#line 199
  return;
}
}
#line 203 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 208
  __builtin_va_start(args, fmt);
#line 209
  do_log(5, fmt, args);
#line 210
  __builtin_va_end(args);
#line 211
  return;
}
}
#line 213 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 218
  __builtin_va_start(args, fmt);
#line 219
  do_log(6, fmt, args);
#line 220
  __builtin_va_end(args);
#line 221
  return;
}
}
#line 223 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 228
  __builtin_va_start(args, fmt);
#line 229
  do_log(7, fmt, args);
#line 230
  __builtin_va_end(args);
#line 231
  return;
}
}
#line 237 "log.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ char *tmp ;

  {
#line 244
  argv0 = av0;
#line 246
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 255
  log_level___0 = level;
#line 256
  break;
  default: 
#line 258
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 260
  exit(1);
  }
#line 263
  log_on_stderr = on_stderr;
#line 264
  if (on_stderr) {
#line 265
    return;
  }
#line 267
  switch ((int )facility) {
  case 0: 
#line 269
  log_facility = 3 << 3;
#line 270
  break;
  case 1: 
#line 272
  log_facility = 1 << 3;
#line 273
  break;
  case 2: 
#line 275
  log_facility = 4 << 3;
#line 276
  break;
  case 3: 
#line 279
  log_facility = 10 << 3;
#line 280
  break;
  case 4: 
#line 283
  log_facility = 16 << 3;
#line 284
  break;
  case 5: 
#line 286
  log_facility = 17 << 3;
#line 287
  break;
  case 6: 
#line 289
  log_facility = 18 << 3;
#line 290
  break;
  case 7: 
#line 292
  log_facility = 19 << 3;
#line 293
  break;
  case 8: 
#line 295
  log_facility = 20 << 3;
#line 296
  break;
  case 9: 
#line 298
  log_facility = 21 << 3;
#line 299
  break;
  case 10: 
#line 301
  log_facility = 22 << 3;
#line 302
  break;
  case 11: 
#line 304
  log_facility = 23 << 3;
#line 305
  break;
  default: 
#line 307
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 310
  exit(1);
  }
#line 322
  if (argv0) {
#line 322
    tmp = argv0;
  } else {
#line 322
    tmp = __progname;
  }
#line 322
  openlog((char const   *)tmp, 1, log_facility);
#line 323
  closelog();
#line 325
  return;
}
}
#line 329 "log.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 337
  txt = (char *)((void *)0);
#line 338
  pri = 6;
#line 339
  tmp = __errno_location();
#line 339
  saved_errno = *tmp;
#line 341
  if ((int )level > (int )log_level___0) {
#line 342
    return;
  }
#line 344
  switch ((int )level) {
  case 1: 
#line 346
  if (! log_on_stderr) {
#line 347
    txt = (char *)"fatal";
  }
#line 348
  pri = 2;
#line 349
  break;
  case 2: 
#line 351
  if (! log_on_stderr) {
#line 352
    txt = (char *)"error";
  }
#line 353
  pri = 3;
#line 354
  break;
  case 3: 
#line 356
  pri = 6;
#line 357
  break;
  case 4: 
#line 359
  pri = 6;
#line 360
  break;
  case 5: 
#line 362
  txt = (char *)"debug1";
#line 363
  pri = 7;
#line 364
  break;
  case 6: 
#line 366
  txt = (char *)"debug2";
#line 367
  pri = 7;
#line 368
  break;
  case 7: 
#line 370
  txt = (char *)"debug3";
#line 371
  pri = 7;
#line 372
  break;
  default: 
#line 374
  txt = (char *)"internal error";
#line 375
  pri = 3;
#line 376
  break;
  }
#line 378
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 379
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 380
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 382
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 384
  if (log_on_stderr) {
#line 384
    tmp___0 = 33;
  } else {
#line 384
    tmp___0 = 27;
  }
#line 384
  strnvis(fmtbuf, (char const   *)(msgbuf), sizeof(fmtbuf), tmp___0);
#line 386
  if (log_on_stderr) {
#line 387
    snprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )"%s\r\n",
             fmtbuf);
#line 388
    tmp___1 = strlen((char const   *)(msgbuf));
#line 388
    write(2, (void const   *)(msgbuf), tmp___1);
  } else {
#line 395
    if (argv0) {
#line 395
      tmp___2 = argv0;
    } else {
#line 395
      tmp___2 = __progname;
    }
#line 395
    openlog((char const   *)tmp___2, 1, log_facility);
#line 396
    syslog(pri, "%.500s", fmtbuf);
#line 397
    closelog();
  }
#line 400
  tmp___3 = __errno_location();
#line 400
  *tmp___3 = saved_errno;
#line 401
  return;
}
}
#line 1 "match.o"
#pragma merger(0,"./match.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 17 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 20
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) ;
#line 21
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) ;
#line 22
char *match_list(char const   *client , char const   *server , u_int *next ) ;
#line 25
int addr_match_list(char const   *addr , char const   *_list ) ;
#line 53 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 56
  while (1) {
#line 58
    if (! *pattern) {
#line 59
      return (! *s);
    }
#line 61
    if ((int const   )*pattern == 42) {
#line 63
      pattern ++;
#line 66
      if (! *pattern) {
#line 67
        return (1);
      }
#line 70
      if ((int const   )*pattern != 63) {
#line 70
        if ((int const   )*pattern != 42) {
#line 76
          while (*s) {
#line 77
            if ((int const   )*s == (int const   )*pattern) {
#line 77
              tmp = match_pattern(s + 1, pattern + 1);
#line 77
              if (tmp) {
#line 79
                return (1);
              }
            }
#line 76
            s ++;
          }
#line 81
          return (0);
        }
      }
#line 87
      while (*s) {
#line 88
        tmp___0 = match_pattern(s, pattern);
#line 88
        if (tmp___0) {
#line 89
          return (1);
        }
#line 87
        s ++;
      }
#line 91
      return (0);
    }
#line 97
    if (! *s) {
#line 98
      return (0);
    }
#line 101
    if ((int const   )*pattern != 63) {
#line 101
      if ((int const   )*pattern != (int const   )*s) {
#line 102
        return (0);
      }
    }
#line 105
    s ++;
#line 106
    pattern ++;
  }
}
}
#line 118 "match.c"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 127
  got_positive = 0;
#line 128
  i = 0U;
#line 128
  while (i < len) {
#line 130
    if ((int const   )*(pattern + i) == 33) {
#line 131
      negated = 1;
#line 132
      i ++;
    } else {
#line 134
      negated = 0;
    }
#line 140
    subi = 0U;
#line 140
    while (1) {
#line 140
      if (i < len) {
#line 140
        if (subi < sizeof(sub) - 1U) {
#line 140
          if (! ((int const   )*(pattern + i) != 44)) {
#line 140
            break;
          }
        } else {
#line 140
          break;
        }
      } else {
#line 140
        break;
      }
#line 144
      if (dolower) {
#line 144
        tmp___6 = __ctype_b_loc();
#line 144
        if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 144
          if (sizeof(*(pattern + i)) > 1U) {
#line 144
            __res___0 = tolower((int )*(pattern + i));
          } else {
#line 144
            tmp___5 = __ctype_tolower_loc();
#line 144
            __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
          }
#line 144
          sub[subi] = (char )__res___0;
        } else {
#line 144
          sub[subi] = (char )*(pattern + i);
        }
      } else {
#line 144
        sub[subi] = (char )*(pattern + i);
      }
#line 140
      subi ++;
#line 140
      i ++;
    }
#line 146
    if (subi >= sizeof(sub) - 1U) {
#line 147
      return (0);
    }
#line 150
    if (i < len) {
#line 150
      if ((int const   )*(pattern + i) == 44) {
#line 151
        i ++;
      }
    }
#line 154
    sub[subi] = (char )'\000';
#line 157
    tmp___7 = match_pattern(string, (char const   *)(sub));
#line 157
    if (tmp___7) {
#line 158
      if (negated) {
#line 159
        return (-1);
      } else {
#line 161
        got_positive = 1;
      }
    }
  }
#line 169
  return (got_positive);
}
}
#line 178 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ int tmp ;

  {
#line 181
  tmp = match_pattern_list(host, pattern, len, 1);
#line 181
  return (tmp);
}
}
#line 189 "match.c"
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) 
{ int mhost ;
  int mip ;
  size_t tmp ;

  {
#line 196
  mip = addr_match_list(ipaddr, patterns);
#line 196
  if (mip == -2) {
#line 197
    return (-1);
  } else {
#line 198
    if (mip == -1) {
#line 199
      return (0);
    }
  }
#line 202
  tmp = strlen(patterns);
#line 202
  mhost = match_hostname(host, patterns, tmp);
#line 202
  if (mhost == -1) {
#line 203
    return (0);
  }
#line 205
  if (mhost == 0) {
#line 205
    if (mip == 0) {
#line 206
      return (0);
    }
  }
#line 207
  return (1);
}
}
#line 213 "match.c"
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) 
{ char *p ;
  char *pat ;
  int ret___0 ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 220
  tmp___1 = __builtin_strchr((char *)pattern, '@');
#line 220
  p = tmp___1;
#line 220
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 221
    tmp = match_pattern(user, pattern);
#line 221
    return (tmp);
  }
#line 223
  pat = xstrdup(pattern);
#line 224
  tmp___3 = __builtin_strchr(pat, '@');
#line 224
  p = tmp___3;
#line 225
  tmp___4 = p;
#line 225
  p ++;
#line 225
  *tmp___4 = (char )'\000';
#line 227
  ret___0 = match_pattern(user, (char const   *)pat);
#line 227
  if (ret___0 == 1) {
#line 228
    ret___0 = match_host_and_ip(host, ipaddr, (char const   *)p);
  }
#line 229
  xfree((void *)pat);
#line 231
  return (ret___0);
}
}
#line 240 "match.c"
char *match_list(char const   *client , char const   *server , u_int *next ) 
{ char *sproposals[40] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret___0 ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;

  {
#line 247
  cp = xstrdup(client);
#line 247
  c = cp;
#line 248
  sp = xstrdup(server);
#line 248
  s = sp;
#line 250
  tmp___14 = __strsep_g(& sp, ",");
#line 250
  p = tmp___14;
#line 250
  i = 0;
#line 250
  while (1) {
#line 250
    if (p) {
#line 250
      if (! ((int )*p != 0)) {
#line 250
        break;
      }
    } else {
#line 250
      break;
    }
#line 252
    if (i < 40) {
#line 253
      sproposals[i] = p;
    } else {
#line 255
      break;
    }
#line 251
    tmp___30 = __strsep_g(& sp, ",");
#line 251
    p = tmp___30;
#line 251
    i ++;
  }
#line 257
  nproposals = i;
#line 259
  tmp___46 = __strsep_g(& cp, ",");
#line 259
  p = tmp___46;
#line 259
  i = 0;
#line 259
  while (1) {
#line 259
    if (p) {
#line 259
      if (! ((int )*p != 0)) {
#line 259
        break;
      }
    } else {
#line 259
      break;
    }
#line 261
    j = 0;
#line 261
    while (j < nproposals) {
#line 262
      if (0) {
#line 262
        __s1_len = strlen((char const   *)p);
#line 262
        __s2_len = strlen((char const   *)sproposals[j]);
#line 262
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 262
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 262
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 262
              tmp___73 = 1;
            } else {
#line 262
              if (__s2_len >= 4U) {
#line 262
                tmp___73 = 1;
              } else {
#line 262
                tmp___73 = 0;
              }
            }
          } else {
#line 262
            tmp___73 = 0;
          }
        }
#line 262
        if (tmp___73) {
#line 262
          tmp___69 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 262
          tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 262
          tmp___69 = tmp___72;
        }
      } else {
#line 262
        tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 262
        tmp___69 = tmp___72;
      }
#line 262
      if (tmp___69 == 0) {
#line 263
        ret___0 = xstrdup((char const   *)p);
#line 264
        if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 265
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 265
            *next = strlen((char const   *)c);
          } else {
#line 265
            *next = (unsigned int )(cp - c);
          }
        }
#line 267
        xfree((void *)c);
#line 268
        xfree((void *)s);
#line 269
        return (ret___0);
      }
#line 261
      j ++;
    }
#line 260
    tmp___62 = __strsep_g(& cp, ",");
#line 260
    p = tmp___62;
#line 260
    i ++;
  }
#line 273
  if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 274
    *next = strlen((char const   *)c);
  }
#line 275
  xfree((void *)c);
#line 276
  xfree((void *)s);
#line 277
  return ((char *)((void *)0));
}
}
#line 1 "md-sha256.o"
#pragma merger(0,"./md-sha256.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "moduli.o"
#pragma merger(0,"./moduli.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 188 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
#line 338
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 338 "/usr/include/stdlib.h"
__inline static unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ unsigned long tmp ;

  {
#line 342
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
#line 342
  return (tmp);
}
}
#line 218 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 393 "/usr/include/openssl/bn.h"
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 401
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 410
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 419
extern int BN_add(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 449
extern unsigned long BN_mod_word(BIGNUM const   *a , unsigned long w ) ;
#line 452
extern int BN_add_word(BIGNUM *a , unsigned long w ) ;
#line 454
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 458
extern void BN_free(BIGNUM *a ) ;
#line 460
extern int BN_lshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 480
extern int BN_print_fp(FILE *fp , BIGNUM const   *a ) ;
#line 488
extern int BN_rshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 493
extern int BN_set_bit(BIGNUM *a , int n ) ;
#line 495
extern char *BN_bn2hex(BIGNUM const   *a ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 511
extern int BN_is_prime(BIGNUM const   *p , int nchecks , void (*callback)(int  , int  ,
                                                                          void * ) ,
                       BN_CTX *ctx , void *cb_arg ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 232
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 257
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 127 "moduli.c"
static u_int32_t *TinySieve  ;
#line 127 "moduli.c"
static u_int32_t tinybits  ;
#line 130 "moduli.c"
static u_int32_t *SmallSieve  ;
#line 130 "moduli.c"
static u_int32_t smallbits  ;
#line 130 "moduli.c"
static u_int32_t smallbase  ;
#line 133 "moduli.c"
static u_int32_t *LargeSieve  ;
#line 133 "moduli.c"
static u_int32_t largewords  ;
#line 133 "moduli.c"
static u_int32_t largetries  ;
#line 133 "moduli.c"
static u_int32_t largenumbers  ;
#line 134 "moduli.c"
static u_int32_t largebits  ;
#line 134 "moduli.c"
static u_int32_t largememory  ;
#line 135 "moduli.c"
static BIGNUM *largebase  ;
#line 137
int gen_candidates(FILE *out , u_int32_t memory , u_int32_t power , BIGNUM *start___0 ) ;
#line 138
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) ;
#line 143 "moduli.c"
static int qfileout(FILE *ofile , u_int32_t otype , u_int32_t otests , u_int32_t otries ,
                    u_int32_t osize , u_int32_t ogenerator , BIGNUM *omodulus ) 
{ struct tm *gtm ;
  time_t time_now ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
#line 151
  time(& time_now);
#line 152
  gtm = gmtime((time_t const   *)(& time_now));
#line 154
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"%04d%02d%02d%02d%02d%02d %u %u %u %u %x ",
                gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday, gtm->tm_hour,
                gtm->tm_min, gtm->tm_sec, otype, otests, otries, osize, ogenerator);
#line 159
  if (res < 0) {
#line 160
    return (-1);
  }
#line 162
  tmp = BN_print_fp(ofile, (BIGNUM const   *)omodulus);
#line 162
  if (tmp < 1) {
#line 163
    return (-1);
  }
#line 165
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"\n");
#line 166
  fflush(ofile);
#line 168
  if (res > 0) {
#line 168
    tmp___0 = 0;
  } else {
#line 168
    tmp___0 = -1;
  }
#line 168
  return (tmp___0);
}
}
#line 175 "moduli.c"
static void sieve_large(u_int32_t s ) 
{ u_int32_t r ;
  u_int32_t u ;
  unsigned long tmp ;

  {
#line 180
  debug3("sieve_large %u", s);
#line 181
  largetries ++;
#line 183
  tmp = BN_mod_word((BIGNUM const   *)largebase, (unsigned long )s);
#line 183
  r = (unsigned int )tmp;
#line 184
  if (r == 0U) {
#line 185
    u = 0U;
  } else {
#line 187
    u = s - r;
  }
#line 189
  if (u < largebits * 2U) {
#line 195
    if (u & 1U) {
#line 196
      u += s;
    }
#line 199
    u /= 2U;
#line 199
    while (u < largebits) {
#line 200
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 199
      u += s;
    }
  }
#line 204
  r = (2U * r + 1U) % s;
#line 205
  if (r == 0U) {
#line 206
    u = 0U;
  } else {
#line 208
    u = s - r;
  }
#line 210
  if (u < largebits * 4U) {
#line 216
    while (u & 3U) {
#line 217
      if (4294967295UL - (unsigned long )u < (unsigned long )s) {
#line 218
        return;
      }
#line 219
      u += s;
    }
#line 223
    u /= 4U;
#line 223
    while (u < largebits) {
#line 224
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 223
      u += s;
    }
  }
#line 226
  return;
}
}
#line 233 "moduli.c"
int gen_candidates(FILE *out , u_int32_t memory , u_int32_t power , BIGNUM *start___0 ) 
{ BIGNUM *q ;
  u_int32_t j ;
  u_int32_t r ;
  u_int32_t s ;
  u_int32_t t ;
  u_int32_t smallwords ;
  u_int32_t tinywords ;
  time_t time_start ;
  time_t time_stop ;
  u_int32_t i ;
  int ret___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  BIGNUM *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 238
  smallwords = (u_int32_t )((1UL << 16) >> 6);
#line 239
  tinywords = (u_int32_t )((1UL << 16) >> 6);
#line 242
  ret___0 = 0;
#line 244
  largememory = memory;
#line 246
  if (memory != 0U) {
#line 246
    if ((unsigned long )memory < 8UL) {
#line 248
      error("Invalid memory amount (min %ld, max %ld)", 8UL, 127UL);
#line 250
      return (-1);
    } else {
#line 246
      if ((unsigned long )memory > 127UL) {
#line 248
        error("Invalid memory amount (min %ld, max %ld)", 8UL, 127UL);
#line 250
        return (-1);
      }
    }
  }
#line 257
  if ((unsigned long )power > 1UL << 16) {
#line 258
    error("Too many bits: %u > %lu", power, 1UL << 16);
#line 259
    return (-1);
  } else {
#line 260
    if (power < 512U) {
#line 261
      error("Too few bits: %u < %u", power, 512);
#line 262
      return (-1);
    }
  }
#line 264
  power --;
#line 272
  largewords = power * power >> 2;
#line 278
  if ((unsigned long )largememory > 127UL) {
#line 279
    logit("Limited memory: %u MB; limit %lu MB", largememory, 127UL);
#line 281
    largememory = 127U;
  }
#line 284
  if (largewords <= largememory << 18) {
#line 285
    logit("Increased memory: %u MB; need %u bytes", largememory, largewords << 2);
#line 287
    largewords = largememory << 18;
  } else {
#line 288
    if (largememory > 0U) {
#line 289
      logit("Decreased memory: %u MB; want %u bytes", largememory, largewords << 2);
#line 291
      largewords = largememory << 18;
    }
  }
#line 294
  tmp = xcalloc(tinywords, sizeof(u_int32_t ));
#line 294
  TinySieve = (u_int32_t *)tmp;
#line 295
  tinybits = tinywords << 5;
#line 297
  tmp___0 = xcalloc(smallwords, sizeof(u_int32_t ));
#line 297
  SmallSieve = (u_int32_t *)tmp___0;
#line 298
  smallbits = smallwords << 5;
#line 303
  while (1) {
#line 303
    tmp___1 = calloc(largewords, sizeof(u_int32_t ));
#line 303
    LargeSieve = (u_int32_t *)tmp___1;
#line 303
    if (! ((unsigned int )LargeSieve == (unsigned int )((void *)0))) {
#line 303
      break;
    }
#line 304
    largewords = (unsigned int )((unsigned long )largewords - (unsigned long )(1L << 16));
  }
#line 306
  largebits = largewords << 5;
#line 307
  largenumbers = largebits * 2U;
#line 310
  largetries = 0U;
#line 311
  q = BN_new();
#line 311
  if ((unsigned int )q == (unsigned int )((void *)0)) {
#line 312
    fatal("BN_new failed");
  }
#line 318
  largebase = BN_new();
#line 318
  if ((unsigned int )largebase == (unsigned int )((void *)0)) {
#line 319
    fatal("BN_new failed");
  }
#line 320
  if ((unsigned int )start___0 == (unsigned int )((void *)0)) {
#line 321
    tmp___2 = BN_rand(largebase, (int )power, 1, 1);
#line 321
    if (tmp___2 == 0) {
#line 322
      fatal("BN_rand failed");
    }
  } else {
#line 324
    tmp___3 = BN_copy(largebase, (BIGNUM const   *)start___0);
#line 324
    if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 325
      fatal("BN_copy: failed");
    }
  }
#line 329
  tmp___4 = BN_set_bit(largebase, 0);
#line 329
  if (tmp___4 == 0) {
#line 330
    fatal("BN_set_bit: failed");
  }
#line 332
  time(& time_start);
#line 334
  tmp___5 = ctime((time_t const   *)(& time_start));
#line 334
  logit("%.24s Sieve next %u plus %u-bit", tmp___5, largenumbers, power);
#line 336
  tmp___6 = BN_bn2hex((BIGNUM const   *)largebase);
#line 336
  debug2("start point: 0x%s", tmp___6);
#line 341
  i = 0U;
#line 341
  while (i < tinybits) {
#line 342
    if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
      goto __Cont;
    }
#line 346
    t = 2U * i + 3U;
#line 349
    j = i + t;
#line 349
    while (j < tinybits) {
#line 350
      *(TinySieve + (j >> 5)) = (unsigned int )((unsigned long )*(TinySieve + (j >> 5)) | (unsigned long )(1L << (j & 31U)));
#line 349
      j += t;
    }
#line 352
    sieve_large(t);
    __Cont: /* CIL Label */ 
#line 341
    i ++;
  }
#line 359
  smallbase = (unsigned int )((1UL << 16) + 3UL);
#line 359
  while ((unsigned long )smallbase < 4294967295UL - (1UL << 16)) {
#line 362
    i = 0U;
#line 362
    while (i < tinybits) {
#line 363
      if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
        goto __Cont___0;
      }
#line 367
      t = 2U * i + 3U;
#line 368
      r = smallbase % t;
#line 370
      if (r == 0U) {
#line 371
        s = 0U;
      } else {
#line 374
        s = t - r;
      }
#line 382
      if (s & 1U) {
#line 383
        s += t;
      }
#line 386
      s /= 2U;
#line 386
      while (s < smallbits) {
#line 387
        *(SmallSieve + (s >> 5)) = (unsigned int )((unsigned long )*(SmallSieve + (s >> 5)) | (unsigned long )(1L << (s & 31U)));
#line 386
        s += t;
      }
      __Cont___0: /* CIL Label */ 
#line 362
      i ++;
    }
#line 393
    i = 0U;
#line 393
    while (i < smallbits) {
#line 394
      if ((unsigned long )*(SmallSieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
        goto __Cont___1;
      }
#line 398
      sieve_large(2U * i + smallbase);
      __Cont___1: /* CIL Label */ 
#line 393
      i ++;
    }
#line 401
    memset((void *)SmallSieve, 0, smallwords << 2);
#line 359
    smallbase = (unsigned int )((unsigned long )smallbase + (1UL << 16));
  }
#line 404
  time(& time_stop);
#line 406
  tmp___7 = ctime((time_t const   *)(& time_stop));
#line 406
  logit("%.24s Sieved with %u small primes in %ld seconds", tmp___7, largetries, time_stop - time_start);
#line 409
  r = 0U;
#line 409
  j = r;
#line 409
  while (j < largebits) {
#line 410
    if ((unsigned long )*(LargeSieve + (j >> 5)) & (unsigned long )(1L << (j & 31U))) {
      goto __Cont___2;
    }
#line 413
    debug2("test q = largebase+%u", 2U * j);
#line 414
    tmp___8 = BN_set_word(q, (unsigned long )(2U * j));
#line 414
    if (tmp___8 == 0) {
#line 415
      fatal("BN_set_word failed");
    }
#line 416
    tmp___9 = BN_add(q, (BIGNUM const   *)q, (BIGNUM const   *)largebase);
#line 416
    if (tmp___9 == 0) {
#line 417
      fatal("BN_add failed");
    }
#line 418
    tmp___10 = qfileout(out, 4U, 2U, largetries, power - 1U, 0U, q);
#line 418
    if (tmp___10 == -1) {
#line 421
      ret___0 = -1;
#line 422
      break;
    }
#line 425
    r ++;
    __Cont___2: /* CIL Label */ 
#line 409
    j ++;
  }
#line 428
  time(& time_stop);
#line 430
  xfree((void *)LargeSieve);
#line 431
  xfree((void *)SmallSieve);
#line 432
  xfree((void *)TinySieve);
#line 434
  tmp___11 = ctime((time_t const   *)(& time_stop));
#line 434
  logit("%.24s Found %u candidates", tmp___11, r);
#line 436
  return (ret___0);
}
}
#line 445 "moduli.c"
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) 
{ BIGNUM *q ;
  BIGNUM *p ;
  BIGNUM *a___0 ;
  BN_CTX *ctx ;
  char *cp ;
  char *lp ;
  u_int32_t count_in ;
  u_int32_t count_out ;
  u_int32_t count_possible ;
  u_int32_t generator_known ;
  u_int32_t in_tests ;
  u_int32_t in_tries ;
  u_int32_t in_type ;
  u_int32_t in_size ;
  time_t time_start ;
  time_t time_stop ;
  int res ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  u_int32_t r ;
  unsigned long tmp___45 ;
  unsigned long tmp___46 ;
  unsigned long tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;

  {
#line 451
  count_in = (u_int32_t )0;
#line 451
  count_out = (u_int32_t )0;
#line 451
  count_possible = (u_int32_t )0;
#line 456
  if (trials < 4U) {
#line 457
    error("Minimum primality trials is %d", 4);
#line 458
    return (-1);
  }
#line 461
  time(& time_start);
#line 463
  p = BN_new();
#line 463
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 464
    fatal("BN_new failed");
  }
#line 465
  q = BN_new();
#line 465
  if ((unsigned int )q == (unsigned int )((void *)0)) {
#line 466
    fatal("BN_new failed");
  }
#line 467
  ctx = BN_CTX_new();
#line 467
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 468
    fatal("BN_CTX_new failed");
  }
#line 470
  tmp = ctime((time_t const   *)(& time_start));
#line 470
  debug2("%.24s Final %u Miller-Rabin trials (%x generator)", tmp, trials, generator_wanted);
#line 473
  res = 0;
#line 474
  tmp___0 = xmalloc(8293U);
#line 474
  lp = (char *)tmp___0;
#line 475
  while (1) {
#line 475
    tmp___52 = fgets((char * __restrict  )lp, 8293, (FILE * __restrict  )in);
#line 475
    if (! ((unsigned int )tmp___52 != (unsigned int )((void *)0))) {
#line 475
      break;
    }
#line 476
    count_in ++;
#line 477
    tmp___1 = strlen((char const   *)lp);
#line 477
    if (tmp___1 < 14U) {
#line 478
      debug2("%10u: comment or short line", count_in);
#line 479
      continue;
    } else {
#line 477
      if ((int )*lp == 33) {
#line 478
        debug2("%10u: comment or short line", count_in);
#line 479
        continue;
      } else {
#line 477
        if ((int )*lp == 35) {
#line 478
          debug2("%10u: comment or short line", count_in);
#line 479
          continue;
        }
      }
    }
#line 484
    cp = lp + 14;
#line 487
    tmp___2 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 487
    in_type = (unsigned int )tmp___2;
#line 490
    tmp___3 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 490
    in_tests = (unsigned int )tmp___3;
#line 492
    if (in_tests & 1U) {
#line 493
      debug2("%10u: known composite", count_in);
#line 494
      continue;
    }
#line 498
    tmp___4 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 498
    in_tries = (unsigned int )tmp___4;
#line 501
    tmp___5 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 501
    in_size = (unsigned int )tmp___5;
#line 504
    tmp___6 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      16);
#line 504
    generator_known = (unsigned int )tmp___6;
#line 507
    tmp___38 = __builtin_strspn((char const   *)cp, " ");
#line 507
    cp += tmp___38;
#line 510
    switch ((int )in_type) {
    case 4: 
#line 512
    debug2("%10u: (%u) Sophie-Germain", count_in, in_type);
#line 513
    a___0 = q;
#line 514
    tmp___39 = BN_hex2bn(& a___0, (char const   *)cp);
#line 514
    if (tmp___39 == 0) {
#line 515
      fatal("BN_hex2bn failed");
    }
#line 517
    tmp___40 = BN_lshift(p, (BIGNUM const   *)q, 1);
#line 517
    if (tmp___40 == 0) {
#line 518
      fatal("BN_lshift failed");
    }
#line 519
    tmp___41 = BN_add_word(p, 1UL);
#line 519
    if (tmp___41 == 0) {
#line 520
      fatal("BN_add_word failed");
    }
#line 521
    in_size ++;
#line 522
    generator_known = 0U;
#line 523
    break;
    case 1: 
    case 2: 
    case 3: 
    case 5: 
    case 0: 
#line 529
    debug2("%10u: (%u)", count_in, in_type);
#line 530
    a___0 = p;
#line 531
    tmp___42 = BN_hex2bn(& a___0, (char const   *)cp);
#line 531
    if (tmp___42 == 0) {
#line 532
      fatal("BN_hex2bn failed");
    }
#line 534
    tmp___43 = BN_rshift(q, (BIGNUM const   *)p, 1);
#line 534
    if (tmp___43 == 0) {
#line 535
      fatal("BN_rshift failed");
    }
#line 536
    break;
    default: 
#line 538
    debug2("Unknown prime type");
#line 539
    break;
    }
#line 546
    tmp___44 = BN_num_bits((BIGNUM const   *)p);
#line 546
    if ((unsigned int )tmp___44 != in_size + 1U) {
#line 547
      debug2("%10u: bit size %u mismatch", count_in, in_size);
#line 548
      continue;
    }
#line 550
    if (in_size < 511U) {
#line 551
      debug2("%10u: bit size %u too short", count_in, in_size);
#line 552
      continue;
    }
#line 555
    if (in_tests & 4U) {
#line 556
      in_tries += trials;
    } else {
#line 558
      in_tries = trials;
    }
#line 563
    if (generator_known == 0U) {
#line 564
      tmp___47 = BN_mod_word((BIGNUM const   *)p, 24UL);
#line 564
      if (tmp___47 == 11UL) {
#line 565
        generator_known = 2U;
      } else {
#line 566
        tmp___46 = BN_mod_word((BIGNUM const   *)p, 12UL);
#line 566
        if (tmp___46 == 5UL) {
#line 567
          generator_known = 3U;
        } else {
#line 569
          tmp___45 = BN_mod_word((BIGNUM const   *)p, 10UL);
#line 569
          r = (u_int32_t )tmp___45;
#line 571
          if (r == 3U) {
#line 572
            generator_known = 5U;
          } else {
#line 571
            if (r == 7U) {
#line 572
              generator_known = 5U;
            }
          }
        }
      }
    }
#line 578
    if (generator_wanted > 0U) {
#line 578
      if (generator_wanted != generator_known) {
#line 580
        debug2("%10u: generator %d != %d", count_in, generator_known, generator_wanted);
#line 582
        continue;
      }
    }
#line 589
    if (generator_known == 0U) {
#line 590
      debug2("%10u: no known generator", count_in);
#line 591
      continue;
    }
#line 594
    count_possible ++;
#line 603
    tmp___48 = BN_is_prime((BIGNUM const   *)q, 1, (void (*)(int  , int  , void * ))((void *)0),
                           ctx, (void *)0);
#line 603
    if (tmp___48 <= 0) {
#line 604
      debug("%10u: q failed first possible prime test", count_in);
#line 606
      continue;
    }
#line 616
    tmp___49 = BN_is_prime((BIGNUM const   *)p, (int )trials, (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                           ctx, (void *)0);
#line 616
    if (! tmp___49) {
#line 617
      debug("%10u: p is not prime", count_in);
#line 618
      continue;
    }
#line 620
    debug("%10u: p is almost certainly prime", count_in);
#line 623
    tmp___50 = BN_is_prime((BIGNUM const   *)q, (int )(trials - 1U), (void (*)(int  ,
                                                                               int  ,
                                                                               void * ))((void *)0),
                           ctx, (void *)0);
#line 623
    if (! tmp___50) {
#line 624
      debug("%10u: q is not prime", count_in);
#line 625
      continue;
    }
#line 627
    debug("%10u: q is almost certainly prime", count_in);
#line 629
    tmp___51 = qfileout(out, 2U, in_tests | 4U, in_tries, in_size, generator_known,
                        p);
#line 629
    if (tmp___51) {
#line 632
      res = -1;
#line 633
      break;
    }
#line 636
    count_out ++;
  }
#line 639
  time(& time_stop);
#line 640
  xfree((void *)lp);
#line 641
  BN_free(p);
#line 642
  BN_free(q);
#line 643
  BN_CTX_free(ctx);
#line 645
  tmp___53 = ctime((time_t const   *)(& time_stop));
#line 645
  logit("%.24s Found %u safe primes of %u candidates in %ld seconds", tmp___53, count_out,
        count_possible, time_stop - time_start);
#line 649
  return (res);
}
}
#line 1 "nchan.o"
#pragma merger(0,"./nchan.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 272 "channels.h"
void chan_rcvd_eow(Channel *c ) ;
#line 77 "nchan.c"
static void chan_send_ieof1(Channel *c ) ;
#line 78
static void chan_send_oclose1(Channel *c ) ;
#line 79
static void chan_send_close2(Channel *c ) ;
#line 80
static void chan_send_eof2(Channel *c ) ;
#line 81
static void chan_send_eow2(Channel *c ) ;
#line 84
static void chan_shutdown_write(Channel *c ) ;
#line 85
static void chan_shutdown_read(Channel *c ) ;
#line 87 "nchan.c"
static char *ostates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_ieof",      (char *)"closed"};
#line 88 "nchan.c"
static char *istates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_oclose",      (char *)"closed"};
#line 90 "nchan.c"
static void chan_set_istate(Channel *c , u_int next ) 
{ 

  {
#line 93
  if (c->istate > 3U) {
#line 94
    fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
  } else {
#line 93
    if (next > 3U) {
#line 94
      fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
    }
  }
#line 95
  debug2("channel %d: input %s -> %s", c->self, istates[c->istate], istates[next]);
#line 97
  c->istate = next;
#line 98
  return;
}
}
#line 99 "nchan.c"
static void chan_set_ostate(Channel *c , u_int next ) 
{ 

  {
#line 102
  if (c->ostate > 3U) {
#line 103
    fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
  } else {
#line 102
    if (next > 3U) {
#line 103
      fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
    }
  }
#line 104
  debug2("channel %d: output %s -> %s", c->self, ostates[c->ostate], ostates[next]);
#line 106
  c->ostate = next;
#line 107
  return;
}
}
#line 113 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 116
  debug2("channel %d: rcvd oclose", c->self);
#line 117
  switch ((int )c->istate) {
  case 2: 
#line 119
  chan_set_istate(c, 3U);
#line 120
  break;
  case 0: 
#line 122
  chan_shutdown_read(c);
#line 123
  chan_send_ieof1(c);
#line 124
  chan_set_istate(c, 3U);
#line 125
  break;
  case 1: 
#line 128
  chan_send_ieof1(c);
#line 129
  chan_set_istate(c, 3U);
#line 130
  break;
  default: 
#line 132
  error("channel %d: protocol error: rcvd_oclose for istate %d", c->self, c->istate);
#line 134
  return;
  }
#line 136
  return;
}
}
#line 137 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 140
  debug2("channel %d: read failed", c->self);
#line 141
  switch ((int )c->istate) {
  case 0: 
#line 143
  chan_shutdown_read(c);
#line 144
  chan_set_istate(c, 1U);
#line 145
  break;
  default: 
#line 147
  error("channel %d: chan_read_failed for istate %d", c->self, c->istate);
#line 149
  break;
  }
#line 151
  return;
}
}
#line 152 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 155
  debug2("channel %d: ibuf empty", c->self);
#line 156
  tmp = buffer_len(& c->input);
#line 156
  if (tmp) {
#line 157
    error("channel %d: chan_ibuf_empty for non empty buffer", c->self);
#line 159
    return;
  }
#line 161
  switch ((int )c->istate) {
  case 1: 
#line 163
  if (compat20) {
#line 164
    if (! (c->flags & 1)) {
#line 165
      chan_send_eof2(c);
    }
#line 166
    chan_set_istate(c, 3U);
  } else {
#line 168
    chan_send_ieof1(c);
#line 169
    chan_set_istate(c, 2U);
  }
#line 171
  break;
  default: 
#line 173
  error("channel %d: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 175
  break;
  }
#line 177
  return;
}
}
#line 178 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 181
  debug2("channel %d: rcvd ieof", c->self);
#line 182
  switch ((int )c->ostate) {
  case 0: 
#line 184
  chan_set_ostate(c, 1U);
#line 185
  break;
  case 2: 
#line 187
  chan_set_ostate(c, 3U);
#line 188
  break;
  default: 
#line 190
  error("channel %d: protocol error: rcvd_ieof for ostate %d", c->self, c->ostate);
#line 192
  break;
  }
#line 194
  return;
}
}
#line 195 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 198
  debug2("channel %d: write failed", c->self);
#line 199
  switch ((int )c->ostate) {
  case 0: 
#line 201
  chan_shutdown_write(c);
#line 202
  chan_send_oclose1(c);
#line 203
  chan_set_ostate(c, 2U);
#line 204
  break;
  case 1: 
#line 206
  chan_shutdown_write(c);
#line 207
  chan_send_oclose1(c);
#line 208
  chan_set_ostate(c, 3U);
#line 209
  break;
  default: 
#line 211
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 213
  break;
  }
#line 215
  return;
}
}
#line 216 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 219
  debug2("channel %d: obuf empty", c->self);
#line 220
  tmp = buffer_len(& c->output);
#line 220
  if (tmp) {
#line 221
    error("channel %d: chan_obuf_empty for non empty buffer", c->self);
#line 223
    return;
  }
#line 225
  switch ((int )c->ostate) {
  case 1: 
#line 227
  chan_shutdown_write(c);
#line 228
  if (! compat20) {
#line 229
    chan_send_oclose1(c);
  }
#line 230
  chan_set_ostate(c, 3U);
#line 231
  break;
  default: 
#line 233
  error("channel %d: internal error: obuf_empty for ostate %d", c->self, c->ostate);
#line 235
  break;
  }
#line 237
  return;
}
}
#line 238 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 241
  debug2("channel %d: send ieof", c->self);
#line 242
  switch ((int )c->istate) {
  case 0: 
  case 1: 
#line 245
  packet_start((unsigned char)24);
#line 246
  packet_put_int((unsigned int )c->remote_id);
#line 247
  packet_send();
#line 248
  break;
  default: 
#line 250
  error("channel %d: cannot send ieof for istate %d", c->self, c->istate);
#line 252
  break;
  }
#line 254
  return;
}
}
#line 255 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ 

  {
#line 258
  debug2("channel %d: send oclose", c->self);
#line 259
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 262
  buffer_clear(& c->output);
#line 263
  packet_start((unsigned char)25);
#line 264
  packet_put_int((unsigned int )c->remote_id);
#line 265
  packet_send();
#line 266
  break;
  default: 
#line 268
  error("channel %d: cannot send oclose for ostate %d", c->self, c->ostate);
#line 270
  break;
  }
#line 272
  return;
}
}
#line 277 "nchan.c"
static void chan_rcvd_close2(Channel *c ) 
{ 

  {
#line 280
  debug2("channel %d: rcvd close", c->self);
#line 281
  if (c->flags & 2) {
#line 282
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 283
  c->flags |= 2;
#line 284
  if (c->type == 10) {
#line 286
    chan_set_ostate(c, 3U);
#line 287
    chan_set_istate(c, 3U);
#line 288
    return;
  }
#line 290
  switch ((int )c->ostate) {
  case 0: 
#line 296
  chan_set_ostate(c, 1U);
#line 297
  break;
  }
#line 299
  switch ((int )c->istate) {
  case 0: 
#line 301
  chan_shutdown_read(c);
#line 302
  chan_set_istate(c, 3U);
#line 303
  break;
  case 1: 
#line 305
  chan_send_eof2(c);
#line 306
  chan_set_istate(c, 3U);
#line 307
  break;
  }
#line 309
  return;
}
}
#line 310 "nchan.c"
void chan_rcvd_eow(Channel *c ) 
{ 

  {
#line 313
  debug2("channel %d: rcvd eow", c->self);
#line 314
  switch ((int )c->istate) {
  case 0: 
#line 316
  chan_shutdown_read(c);
#line 317
  chan_set_istate(c, 3U);
#line 318
  break;
  }
#line 320
  return;
}
}
#line 321 "nchan.c"
static void chan_rcvd_eof2(Channel *c ) 
{ 

  {
#line 324
  debug2("channel %d: rcvd eof", c->self);
#line 325
  c->flags |= 8;
#line 326
  if (c->ostate == 0U) {
#line 327
    chan_set_ostate(c, 1U);
  }
#line 328
  return;
}
}
#line 329 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 332
  debug2("channel %d: write failed", c->self);
#line 333
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 336
  chan_shutdown_write(c);
#line 337
  if (0) {
#line 337
    __s1_len = strlen((char const   *)c->ctype);
#line 337
    __s2_len = strlen("session");
#line 337
    if (! ((unsigned int )((void const   *)(c->ctype + 1)) - (unsigned int )((void const   *)c->ctype) == 1U)) {
      goto _L___0;
    } else {
#line 337
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 337
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 337
          tmp___8 = 1;
        } else {
#line 337
          if (__s2_len >= 4U) {
#line 337
            tmp___8 = 1;
          } else {
#line 337
            tmp___8 = 0;
          }
        }
      } else {
#line 337
        tmp___8 = 0;
      }
    }
#line 337
    if (tmp___8) {
#line 337
      tmp___4 = __builtin_strcmp((char const   *)c->ctype, "session");
    } else {
#line 337
      tmp___7 = __builtin_strcmp((char const   *)c->ctype, "session");
#line 337
      tmp___4 = tmp___7;
    }
  } else {
#line 337
    tmp___7 = __builtin_strcmp((char const   *)c->ctype, "session");
#line 337
    tmp___4 = tmp___7;
  }
#line 337
  if (tmp___4 == 0) {
#line 338
    chan_send_eow2(c);
  }
#line 339
  chan_set_ostate(c, 3U);
#line 340
  break;
  default: 
#line 342
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 344
  break;
  }
#line 346
  return;
}
}
#line 347 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 350
  debug2("channel %d: send eof", c->self);
#line 351
  switch ((int )c->istate) {
  case 1: 
#line 353
  packet_start((unsigned char)96);
#line 354
  packet_put_int((unsigned int )c->remote_id);
#line 355
  packet_send();
#line 356
  c->flags |= 4;
#line 357
  break;
  default: 
#line 359
  error("channel %d: cannot send eof for istate %d", c->self, c->istate);
#line 361
  break;
  }
#line 363
  return;
}
}
#line 364 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 367
  debug2("channel %d: send close", c->self);
#line 368
  if (c->ostate != 3U) {
#line 370
    error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
          c->ostate);
  } else {
#line 368
    if (c->istate != 3U) {
#line 370
      error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
            c->ostate);
    } else {
#line 372
      if (c->flags & 1) {
#line 373
        error("channel %d: already sent close", c->self);
      } else {
#line 375
        packet_start((unsigned char)97);
#line 376
        packet_put_int((unsigned int )c->remote_id);
#line 377
        packet_send();
#line 378
        c->flags |= 1;
      }
    }
  }
#line 380
  return;
}
}
#line 381 "nchan.c"
static void chan_send_eow2(Channel *c ) 
{ 

  {
#line 384
  debug2("channel %d: send eow", c->self);
#line 385
  if (c->ostate == 3U) {
#line 386
    error("channel %d: must not sent eow on closed output", c->self);
#line 388
    return;
  }
#line 390
  if (! (datafellows & 67108864)) {
#line 391
    return;
  }
#line 392
  packet_start((unsigned char)98);
#line 393
  packet_put_int((unsigned int )c->remote_id);
#line 394
  packet_put_cstring("eow@openssh.com");
#line 395
  packet_put_char(0);
#line 396
  packet_send();
#line 397
  return;
}
}
#line 401 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 404
  if (compat20) {
#line 405
    chan_rcvd_eof2(c);
  } else {
#line 407
    chan_rcvd_ieof1(c);
  }
#line 408
  if (c->ostate == 1U) {
#line 408
    tmp = buffer_len(& c->output);
#line 408
    if (tmp == 0U) {
#line 408
      if (compat20) {
#line 408
        if (c->extended_usage == 2) {
#line 408
          if (c->efd != -1) {
#line 408
            if (! (! (c->flags & 10))) {
#line 408
              tmp___0 = buffer_len(& c->extended);
#line 408
              if (! (tmp___0 > 0U)) {
#line 411
                chan_obuf_empty(c);
              }
            }
          } else {
#line 411
            chan_obuf_empty(c);
          }
        } else {
#line 411
          chan_obuf_empty(c);
        }
      } else {
#line 411
        chan_obuf_empty(c);
      }
    }
  }
#line 412
  return;
}
}
#line 413 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 416
  if (compat20) {
#line 417
    chan_rcvd_close2(c);
  } else {
#line 419
    chan_rcvd_oclose1(c);
  }
#line 420
  return;
}
}
#line 421 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 424
  if (compat20) {
#line 425
    chan_write_failed2(c);
  } else {
#line 427
    chan_write_failed1(c);
  }
#line 428
  return;
}
}
#line 430 "nchan.c"
void chan_mark_dead(Channel *c ) 
{ 

  {
#line 433
  c->type = 14;
#line 434
  return;
}
}
#line 436 "nchan.c"
int chan_is_dead(Channel *c , int do_send ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 439
  if (c->type == 14) {
#line 440
    debug2("channel %d: zombie", c->self);
#line 441
    return (1);
  }
#line 443
  if (c->istate != 3U) {
#line 444
    return (0);
  } else {
#line 443
    if (c->ostate != 3U) {
#line 444
      return (0);
    }
  }
#line 445
  if (! compat20) {
#line 446
    debug2("channel %d: is dead", c->self);
#line 447
    return (1);
  }
#line 449
  if (datafellows & 2097152) {
#line 449
    if (c->extended_usage == 2) {
#line 449
      if (c->efd != -1) {
#line 449
        tmp___0 = buffer_len(& c->extended);
#line 449
        if (tmp___0 > 0U) {
#line 453
          tmp = buffer_len(& c->extended);
#line 453
          debug2("channel %d: active efd: %d len %d", c->self, c->efd, tmp);
#line 455
          return (0);
        }
      }
    }
  }
#line 457
  if (! (c->flags & 1)) {
#line 458
    if (do_send) {
#line 459
      chan_send_close2(c);
    } else {
#line 462
      if (c->flags & 2) {
#line 463
        debug2("channel %d: almost dead", c->self);
#line 465
        return (1);
      }
    }
  }
#line 469
  if (c->flags & 1) {
#line 469
    if (c->flags & 2) {
#line 471
      debug2("channel %d: is dead", c->self);
#line 472
      return (1);
    }
  }
#line 474
  return (0);
}
}
#line 478 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 481
  buffer_clear(& c->output);
#line 482
  if (compat20) {
#line 482
    if (c->type == 10) {
#line 483
      return;
    }
  }
#line 485
  debug2("channel %d: close_write", c->self);
#line 486
  if (c->sock != -1) {
#line 487
    tmp___1 = shutdown(c->sock, 1);
#line 487
    if (tmp___1 < 0) {
#line 488
      tmp = __errno_location();
#line 488
      tmp___0 = strerror(*tmp);
#line 488
      debug2("channel %d: chan_shutdown_write: shutdown() failed for fd %d: %.100s",
             c->self, c->sock, tmp___0);
    }
  } else {
#line 492
    tmp___4 = channel_close_fd(& c->wfd);
#line 492
    if (tmp___4 < 0) {
#line 493
      tmp___2 = __errno_location();
#line 493
      tmp___3 = strerror(*tmp___2);
#line 493
      logit("channel %d: chan_shutdown_write: close() failed for fd %d: %.100s", c->self,
            c->wfd, tmp___3);
    }
  }
#line 497
  return;
}
}
#line 498 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 501
  if (compat20) {
#line 501
    if (c->type == 10) {
#line 502
      return;
    }
  }
#line 503
  debug2("channel %d: close_read", c->self);
#line 504
  if (c->sock != -1) {
#line 510
    tmp___1 = shutdown(c->sock, 0);
#line 510
    if (tmp___1 < 0) {
#line 510
      tmp___2 = __errno_location();
#line 510
      if (*tmp___2 != 107) {
#line 512
        tmp = __errno_location();
#line 512
        tmp___0 = strerror(*tmp);
#line 512
        error("channel %d: chan_shutdown_read: shutdown() failed for fd %d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      }
    }
  } else {
#line 517
    tmp___5 = channel_close_fd(& c->rfd);
#line 517
    if (tmp___5 < 0) {
#line 518
      tmp___3 = __errno_location();
#line 518
      tmp___4 = strerror(*tmp___3);
#line 518
      logit("channel %d: chan_shutdown_read: close() failed for fd %d: %.100s", c->self,
            c->rfd, tmp___4);
    }
  }
#line 522
  return;
}
}
#line 1 "packet.o"
#pragma merger(0,"./packet.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 23 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 24
void packet_set_timeout(int timeout , int count ) ;
#line 25
void packet_set_nonblocking(void) ;
#line 27
int packet_get_connection_out(void) ;
#line 28
void packet_close(void) ;
#line 29
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 30
u_int packet_get_encryption_key(u_char *key ) ;
#line 31
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 33
void packet_start_compression(int level ) ;
#line 34
void packet_set_interactive(int interactive ) ;
#line 36
void packet_set_server(void) ;
#line 37
void packet_set_authenticated(void) ;
#line 42
void packet_put_bignum(BIGNUM *value ) ;
#line 43
void packet_put_bignum2(BIGNUM *value ) ;
#line 46
void packet_put_raw(void const   *buf___1 , u_int len ) ;
#line 50
void packet_read_expect(int expected_type ) ;
#line 51
int packet_read_poll(void) ;
#line 52
void packet_process_incoming(char const   *buf___1 , u_int len ) ;
#line 53
int packet_read_seqnr(u_int32_t *seqnr_p ) ;
#line 54
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) ;
#line 56
u_int packet_get_char(void) ;
#line 58
void packet_get_bignum(BIGNUM *value ) ;
#line 59
void packet_get_bignum2(BIGNUM *value ) ;
#line 60
void *packet_get_raw(u_int *length_ptr ) ;
#line 64
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 66
void set_newkeys(int mode ) ;
#line 67
int packet_get_keyiv_len(int mode ) ;
#line 68
void packet_get_keyiv(int mode , u_char *iv , u_int len ) ;
#line 69
int packet_get_keycontext(int mode , u_char *dat ) ;
#line 70
void packet_set_keycontext(int mode , u_char *dat ) ;
#line 71
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ,
                      u_int64_t *bytes ) ;
#line 72
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ,
                      u_int64_t bytes ) ;
#line 73
int packet_get_ssh1_cipher(void) ;
#line 74
void packet_set_iv(int mode , u_char *dat ) ;
#line 76
void packet_write_poll(void) ;
#line 78
int packet_have_data_to_write(void) ;
#line 79
int packet_not_very_much_data_to_write(void) ;
#line 82
int packet_connection_is_ipv4(void) ;
#line 85
void packet_add_padding(u_char pad ) ;
#line 92
int packet_set_maxsize(u_int s ) ;
#line 106
int packet_need_rekeying(void) ;
#line 107
void packet_set_rekey_limit(u_int32_t bytes ) ;
#line 137 "kex.h"
Newkeys *kex_get_newkeys(int mode ) ;
#line 28 "mac.h"
int mac_init(Mac *mac ) ;
#line 29
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 30
void mac_clear(Mac *mac ) ;
#line 36 "misc.h"
void ms_subtract_diff(struct timeval *start___0 , int *ms ) ;
#line 37
void ms_to_timeval(struct timeval *tv___0 , int ms ) ;
#line 95 "packet.c"
static int connection_in  =    -1;
#line 96 "packet.c"
static int connection_out  =    -1;
#line 99 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 102 "packet.c"
static CipherContext receive_context  ;
#line 105 "packet.c"
static CipherContext send_context  ;
#line 108 "packet.c"
Buffer input  ;
#line 111 "packet.c"
Buffer output  ;
#line 114 "packet.c"
static Buffer outgoing_packet  ;
#line 117 "packet.c"
static Buffer incoming_packet  ;
#line 120 "packet.c"
static Buffer compression_buffer  ;
#line 121 "packet.c"
static int compression_buffer_ready  =    0;
#line 124 "packet.c"
static int packet_compression  =    0;
#line 127 "packet.c"
u_int max_packet_size  =    (u_int )32768;
#line 130 "packet.c"
static int initialized  =    0;
#line 133 "packet.c"
static int interactive_mode  =    0;
#line 136 "packet.c"
static int server_side  =    0;
#line 139 "packet.c"
static int after_authentication  =    0;
#line 141 "packet.c"
int keep_alive_timeouts  =    0;
#line 144 "packet.c"
static int packet_timeout_ms  =    -1;
#line 147 "packet.c"
Newkeys *newkeys[2]  ;
#line 148 "packet.c"
static struct packet_state p_read  ;
#line 148 "packet.c"
static struct packet_state p_send  ;
#line 155 "packet.c"
static u_int64_t max_blocks_in  ;
#line 155 "packet.c"
static u_int64_t max_blocks_out  ;
#line 156 "packet.c"
static u_int32_t rekey_limit  ;
#line 159 "packet.c"
static u_char ssh1_key[32]  ;
#line 160 "packet.c"
static u_int ssh1_keylen  ;
#line 163 "packet.c"
static u_char extra_pad  =    (u_char )0;
#line 166 "packet.c"
static u_int packet_discard  =    (u_int )0;
#line 167 "packet.c"
static Mac *packet_discard_mac  =    (Mac *)((void *)0);
#line 174 "packet.c"
struct __anonstruct_outgoing_79 outgoing  ;
#line 180 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 183
  tmp = cipher_by_name("none");
#line 183
  none = tmp;
#line 185
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 186
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 187
  connection_in = fd_in;
#line 188
  connection_out = fd_out;
#line 189
  cipher_init(& send_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 1);
#line 191
  cipher_init(& receive_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 0);
#line 193
  newkeys[1] = (Newkeys *)((void *)0);
#line 193
  newkeys[0] = newkeys[1];
#line 194
  if (! initialized) {
#line 195
    initialized = 1;
#line 196
    buffer_init(& input);
#line 197
    buffer_init(& output);
#line 198
    buffer_init(& outgoing_packet);
#line 199
    buffer_init(& incoming_packet);
#line 200
    while (1) {
#line 200
      outgoing.tqh_first = (struct packet *)((void *)0);
#line 200
      outgoing.tqh_last = & outgoing.tqh_first;
#line 200
      break;
    }
#line 201
    p_read.packets = 0U;
#line 201
    p_send.packets = p_read.packets;
  }
#line 203
  return;
}
}
#line 205 "packet.c"
void packet_set_timeout(int timeout , int count ) 
{ 

  {
#line 208
  if (timeout == 0) {
#line 209
    packet_timeout_ms = -1;
#line 210
    return;
  } else {
#line 208
    if (count == 0) {
#line 209
      packet_timeout_ms = -1;
#line 210
      return;
    }
  }
#line 212
  if (2147483 / count < timeout) {
#line 213
    packet_timeout_ms = 2147483647;
  } else {
#line 215
    packet_timeout_ms = (timeout * count) * 1000;
  }
#line 216
  return;
}
}
#line 218 "packet.c"
static void packet_stop_discard(void) 
{ char buf___1[1024] ;
  u_int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 221
  if (packet_discard_mac) {
#line 224
    memset((void *)(buf___1), 'a', sizeof(buf___1));
#line 225
    while (1) {
#line 225
      tmp = buffer_len(& incoming_packet);
#line 225
      if (! (tmp < 262144U)) {
#line 225
        break;
      }
#line 226
      buffer_append(& incoming_packet, (void const   *)(buf___1), sizeof(buf___1));
    }
#line 227
    tmp___0 = buffer_ptr(& incoming_packet);
#line 227
    mac_compute(packet_discard_mac, p_read.seqnr, (u_char *)tmp___0, 262144);
  }
#line 232
  tmp___1 = get_remote_ipaddr();
#line 232
  logit("Finished discarding for %.200s", tmp___1);
#line 233
  cleanup_exit(255);
}
}
#line 236 "packet.c"
static void packet_start_discard(Enc *enc , Mac *mac , u_int packet_length___0 , u_int discard ) 
{ u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 239
  if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 240
    packet_disconnect("Packet corrupt");
  } else {
#line 239
    tmp = cipher_is_cbc((Cipher const   *)enc->cipher);
#line 239
    if (! tmp) {
#line 240
      packet_disconnect("Packet corrupt");
    }
  }
#line 241
  if (packet_length___0 != 262144U) {
#line 241
    if (mac) {
#line 241
      if (mac->enabled) {
#line 242
        packet_discard_mac = mac;
      }
    }
  }
#line 243
  tmp___0 = buffer_len(& input);
#line 243
  if (tmp___0 >= discard) {
#line 244
    packet_stop_discard();
  }
#line 245
  tmp___1 = buffer_len(& input);
#line 245
  packet_discard = discard - tmp___1;
#line 246
  return;
}
}
#line 250 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 257
  if (connection_in == connection_out) {
#line 258
    return (1);
  }
#line 259
  fromlen = sizeof(from);
#line 260
  memset((void *)(& from), 0, sizeof(from));
#line 261
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 261
  if (tmp < 0) {
#line 262
    return (0);
  }
#line 263
  tolen = sizeof(to);
#line 264
  memset((void *)(& to), 0, sizeof(to));
#line 265
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 265
  if (tmp___0 < 0) {
#line 266
    return (0);
  }
#line 267
  if (fromlen != tolen) {
#line 268
    return (0);
  } else {
#line 267
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 267
    if (tmp___1 != 0) {
#line 268
      return (0);
    }
  }
#line 269
  if ((int )from.ss_family != 2) {
#line 269
    if ((int )from.ss_family != 10) {
#line 270
      return (0);
    }
  }
#line 271
  return (1);
}
}
#line 280 "packet.c"
void packet_get_keyiv(int mode , u_char *iv , u_int len ) 
{ CipherContext *cc ;

  {
#line 285
  if (mode == 1) {
#line 286
    cc = & send_context;
  } else {
#line 288
    cc = & receive_context;
  }
#line 290
  cipher_get_keyiv(cc, iv, len);
#line 291
  return;
}
}
#line 293 "packet.c"
int packet_get_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 298
  if (mode == 1) {
#line 299
    cc = & send_context;
  } else {
#line 301
    cc = & receive_context;
  }
#line 303
  tmp = cipher_get_keycontext((CipherContext const   *)cc, dat);
#line 303
  return (tmp);
}
}
#line 306 "packet.c"
void packet_set_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 311
  if (mode == 1) {
#line 312
    cc = & send_context;
  } else {
#line 314
    cc = & receive_context;
  }
#line 316
  cipher_set_keycontext(cc, dat);
#line 317
  return;
}
}
#line 319 "packet.c"
int packet_get_keyiv_len(int mode ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 324
  if (mode == 1) {
#line 325
    cc = & send_context;
  } else {
#line 327
    cc = & receive_context;
  }
#line 329
  tmp = cipher_get_keyiv_len((CipherContext const   *)cc);
#line 329
  return (tmp);
}
}
#line 332 "packet.c"
void packet_set_iv(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 337
  if (mode == 1) {
#line 338
    cc = & send_context;
  } else {
#line 340
    cc = & receive_context;
  }
#line 342
  cipher_set_keyiv(cc, dat);
#line 343
  return;
}
}
#line 345 "packet.c"
int packet_get_ssh1_cipher(void) 
{ u_int tmp ;

  {
#line 348
  tmp = cipher_get_number((Cipher const   *)receive_context.cipher);
#line 348
  return ((int )tmp);
}
}
#line 351 "packet.c"
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ,
                      u_int64_t *bytes ) 
{ struct packet_state *state ;

  {
#line 357
  if (mode == 0) {
#line 357
    state = & p_read;
  } else {
#line 357
    state = & p_send;
  }
#line 358
  if (seqnr) {
#line 359
    *seqnr = state->seqnr;
  }
#line 360
  if (blocks) {
#line 361
    *blocks = state->blocks;
  }
#line 362
  if (packets) {
#line 363
    *packets = state->packets;
  }
#line 364
  if (bytes) {
#line 365
    *bytes = state->bytes;
  }
#line 366
  return;
}
}
#line 368 "packet.c"
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ,
                      u_int64_t bytes ) 
{ struct packet_state *state ;

  {
#line 374
  if (mode == 0) {
#line 374
    state = & p_read;
  } else {
#line 374
    state = & p_send;
  }
#line 375
  state->seqnr = seqnr;
#line 376
  state->blocks = blocks;
#line 377
  state->packets = packets;
#line 378
  state->bytes = bytes;
#line 379
  return;
}
}
#line 383 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 387
  tolen = sizeof(to);
#line 389
  memset((void *)(& to), 0, sizeof(to));
#line 390
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 390
  if (tmp < 0) {
#line 391
    return (0);
  }
#line 392
  if ((int )to.ss_family == 2) {
#line 393
    return (1);
  }
#line 396
  if ((int )to.ss_family == 10) {
#line 396
    if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 0) == 0U) {
#line 396
      if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 1) == 0U) {
#line 396
        __x = 65535U;
#line 396
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 396
        if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 397
          return (1);
        }
      }
    }
  }
#line 399
  return (0);
}
}
#line 404 "packet.c"
void packet_set_nonblocking(void) 
{ 

  {
#line 408
  set_nonblock(connection_in);
#line 410
  if (connection_out != connection_in) {
#line 411
    set_nonblock(connection_out);
  }
#line 412
  return;
}
}
#line 416 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 419
  return (connection_in);
}
}
#line 424 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 427
  return (connection_out);
}
}
#line 432 "packet.c"
void packet_close(void) 
{ 

  {
#line 435
  if (! initialized) {
#line 436
    return;
  }
#line 437
  initialized = 0;
#line 438
  if (connection_in == connection_out) {
#line 439
    shutdown(connection_out, 2);
#line 440
    close(connection_out);
  } else {
#line 442
    close(connection_in);
#line 443
    close(connection_out);
  }
#line 445
  buffer_free(& input);
#line 446
  buffer_free(& output);
#line 447
  buffer_free(& outgoing_packet);
#line 448
  buffer_free(& incoming_packet);
#line 449
  if (compression_buffer_ready) {
#line 450
    buffer_free(& compression_buffer);
#line 451
    buffer_compress_uninit();
  }
#line 453
  cipher_cleanup(& send_context);
#line 454
  cipher_cleanup(& receive_context);
#line 455
  return;
}
}
#line 459 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 462
  remote_protocol_flags = protocol_flags;
#line 463
  return;
}
}
#line 467 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 470
  return (remote_protocol_flags);
}
}
#line 478 "packet.c"
static void packet_init_compression(void) 
{ 

  {
#line 481
  if (compression_buffer_ready == 1) {
#line 482
    return;
  }
#line 483
  compression_buffer_ready = 1;
#line 484
  buffer_init(& compression_buffer);
#line 485
  return;
}
}
#line 487 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 490
  if (packet_compression) {
#line 490
    if (! compat20) {
#line 491
      fatal("Compression already enabled.");
    }
  }
#line 492
  packet_compression = 1;
#line 493
  packet_init_compression();
#line 494
  buffer_compress_init_send(level);
#line 495
  buffer_compress_init_recv();
#line 496
  return;
}
}
#line 504 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 508
  tmp = cipher_by_number(number);
#line 508
  cipher = tmp;
#line 510
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 511
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 512
  if (keylen < 20U) {
#line 513
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 514
  if (keylen > 32U) {
#line 515
    fatal("packet_set_encryption_key: keylen too big: %d", keylen);
  }
#line 516
  memcpy((void * __restrict  )(ssh1_key), (void const   * __restrict  )key, keylen);
#line 517
  ssh1_keylen = keylen;
#line 518
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 1);
#line 519
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 0);
#line 520
  return;
}
}
#line 522 "packet.c"
u_int packet_get_encryption_key(u_char *key ) 
{ 

  {
#line 525
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 526
    return (ssh1_keylen);
  }
#line 527
  memcpy((void * __restrict  )key, (void const   * __restrict  )(ssh1_key), ssh1_keylen);
#line 528
  return (ssh1_keylen);
}
}
#line 532 "packet.c"
void packet_start(u_char type ) 
{ u_char buf___1[9] ;
  int len ;

  {
#line 539
  if (compat20) {
#line 539
    len = 6;
  } else {
#line 539
    len = 9;
  }
#line 540
  memset((void *)(buf___1), 0, (unsigned int )(len - 1));
#line 541
  buf___1[len - 1] = type;
#line 542
  buffer_clear(& outgoing_packet);
#line 543
  buffer_append(& outgoing_packet, (void const   *)(buf___1), (unsigned int )len);
#line 544
  return;
}
}
#line 547 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 550
  ch = (char )value;
#line 552
  buffer_append(& outgoing_packet, (void const   *)(& ch), 1U);
#line 553
  return;
}
}
#line 555 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 558
  buffer_put_int(& outgoing_packet, value);
#line 559
  return;
}
}
#line 561 "packet.c"
void packet_put_string(void const   *buf___1 , u_int len ) 
{ 

  {
#line 564
  buffer_put_string(& outgoing_packet, buf___1, len);
#line 565
  return;
}
}
#line 567 "packet.c"
void packet_put_cstring(char const   *str ) 
{ 

  {
#line 570
  buffer_put_cstring(& outgoing_packet, str);
#line 571
  return;
}
}
#line 573 "packet.c"
void packet_put_raw(void const   *buf___1 , u_int len ) 
{ 

  {
#line 576
  buffer_append(& outgoing_packet, buf___1, len);
#line 577
  return;
}
}
#line 579 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 582
  buffer_put_bignum(& outgoing_packet, (BIGNUM const   *)value);
#line 583
  return;
}
}
#line 585 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 588
  buffer_put_bignum2(& outgoing_packet, (BIGNUM const   *)value);
#line 589
  return;
}
}
#line 596 "packet.c"
static void packet_send1(void) 
{ u_char buf___1[8] ;
  u_char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rnd ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;

  {
#line 602
  rnd = (u_int32_t )0;
#line 608
  if (packet_compression) {
#line 609
    buffer_clear(& compression_buffer);
#line 611
    buffer_consume(& outgoing_packet, 8U);
#line 613
    buffer_append(& compression_buffer, (void const   *)"\000\000\000\000\000\000\000\000",
                  8U);
#line 614
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 615
    buffer_clear(& outgoing_packet);
#line 616
    tmp = buffer_len(& compression_buffer);
#line 616
    tmp___0 = buffer_ptr(& compression_buffer);
#line 616
    buffer_append(& outgoing_packet, (void const   *)tmp___0, tmp);
  }
#line 620
  tmp___1 = buffer_len(& outgoing_packet);
#line 620
  len = (int )((tmp___1 + 4U) - 8U);
#line 623
  padding = 8 - len % 8;
#line 624
  if (! send_context.plaintext) {
#line 625
    tmp___2 = buffer_ptr(& outgoing_packet);
#line 625
    cp = (u_char *)tmp___2;
#line 626
    i = 0;
#line 626
    while (i < padding) {
#line 627
      if (i % 4 == 0) {
#line 628
        rnd = arc4random();
      }
#line 629
      *(cp + (7 - i)) = (unsigned char )(rnd & 255U);
#line 630
      rnd >>= 8;
#line 626
      i ++;
    }
  }
#line 633
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 636
  tmp___3 = buffer_len(& outgoing_packet);
#line 636
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 636
  checksum = ssh_crc32((u_char const   *)tmp___4, tmp___3);
#line 638
  put_u32((void *)(buf___1), checksum);
#line 639
  buffer_append(& outgoing_packet, (void const   *)(buf___1), 4U);
#line 647
  put_u32((void *)(buf___1), (unsigned int )len);
#line 648
  buffer_append(& output, (void const   *)(buf___1), 4U);
#line 649
  tmp___5 = buffer_len(& outgoing_packet);
#line 649
  tmp___6 = buffer_append_space(& output, tmp___5);
#line 649
  cp = (u_char *)tmp___6;
#line 650
  tmp___7 = buffer_len(& outgoing_packet);
#line 650
  tmp___8 = buffer_ptr(& outgoing_packet);
#line 650
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___8, tmp___7);
#line 657
  (p_send.packets) ++;
#line 658
  tmp___9 = buffer_len(& outgoing_packet);
#line 658
  p_send.bytes += (u_int64_t )((u_int )len + tmp___9);
#line 659
  buffer_clear(& outgoing_packet);
#line 666
  return;
}
}
#line 668 "packet.c"
void set_newkeys(int mode ) 
{ Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  CipherContext *cc ;
  u_int64_t *max_blocks ;
  int crypt_type ;
  int tmp ;

  {
#line 678
  debug2("set_newkeys: mode %d", mode);
#line 680
  if (mode == 1) {
#line 681
    cc = & send_context;
#line 682
    crypt_type = 1;
#line 683
    p_send.blocks = 0ULL;
#line 683
    p_send.packets = (unsigned int )p_send.blocks;
#line 684
    max_blocks = & max_blocks_out;
  } else {
#line 686
    cc = & receive_context;
#line 687
    crypt_type = 0;
#line 688
    p_read.blocks = 0ULL;
#line 688
    p_read.packets = (unsigned int )p_read.blocks;
#line 689
    max_blocks = & max_blocks_in;
  }
#line 691
  if ((unsigned int )newkeys[mode] != (unsigned int )((void *)0)) {
#line 692
    debug("set_newkeys: rekeying");
#line 693
    cipher_cleanup(cc);
#line 694
    enc = & (newkeys[mode])->enc;
#line 695
    mac = & (newkeys[mode])->mac;
#line 696
    comp = & (newkeys[mode])->comp;
#line 697
    mac_clear(mac);
#line 698
    xfree((void *)enc->name);
#line 699
    xfree((void *)enc->iv);
#line 700
    xfree((void *)enc->key);
#line 701
    xfree((void *)mac->name);
#line 702
    xfree((void *)mac->key);
#line 703
    xfree((void *)comp->name);
#line 704
    xfree((void *)newkeys[mode]);
  }
#line 706
  newkeys[mode] = kex_get_newkeys(mode);
#line 707
  if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
#line 708
    fatal("newkeys: no keys for mode %d", mode);
  }
#line 709
  enc = & (newkeys[mode])->enc;
#line 710
  mac = & (newkeys[mode])->mac;
#line 711
  comp = & (newkeys[mode])->comp;
#line 712
  tmp = mac_init(mac);
#line 712
  if (tmp == 0) {
#line 713
    mac->enabled = 1;
  }
#line 715
  cipher_init(cc, enc->cipher, (u_char const   *)enc->key, enc->key_len, (u_char const   *)enc->iv,
              enc->block_size, crypt_type);
#line 721
  if (comp->type == 1) {
    goto _L;
  } else {
#line 721
    if (comp->type == 2) {
#line 721
      if (after_authentication) {
        _L: /* CIL Label */ 
#line 721
        if (comp->enabled == 0) {
#line 724
          packet_init_compression();
#line 725
          if (mode == 1) {
#line 726
            buffer_compress_init_send(6);
          } else {
#line 728
            buffer_compress_init_recv();
          }
#line 729
          comp->enabled = 1;
        }
      }
    }
  }
#line 735
  if (enc->block_size >= 16U) {
#line 736
    *max_blocks = 1ULL << enc->block_size * 2U;
  } else {
#line 738
    *max_blocks = (1ULL << 30) / (unsigned long long )enc->block_size;
  }
#line 739
  if (rekey_limit) {
#line 740
    if (*max_blocks < (u_int64_t )(rekey_limit / enc->block_size)) {
#line 740
      *max_blocks = *max_blocks;
    } else {
#line 740
      *max_blocks = (unsigned long long )(rekey_limit / enc->block_size);
    }
  }
#line 741
  return;
}
}
#line 748 "packet.c"
static void packet_enable_delayed_compress(void) 
{ Comp *comp ;
  int mode ;

  {
#line 751
  comp = (Comp *)((void *)0);
#line 758
  after_authentication = 1;
#line 759
  mode = 0;
#line 759
  while (mode < 2) {
#line 761
    if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 763
    comp = & (newkeys[mode])->comp;
#line 764
    if (comp) {
#line 764
      if (! comp->enabled) {
#line 764
        if (comp->type == 2) {
#line 765
          packet_init_compression();
#line 766
          if (mode == 1) {
#line 767
            buffer_compress_init_send(6);
          } else {
#line 769
            buffer_compress_init_recv();
          }
#line 770
          comp->enabled = 1;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 759
    mode ++;
  }
#line 773
  return;
}
}
#line 778 "packet.c"
static void packet_send2_wrapped(void) 
{ u_char type ;
  u_char *cp ;
  u_char *macbuf ;
  u_char padlen ;
  u_char pad ;
  u_int packet_length___0 ;
  u_int i ;
  u_int len ;
  u_int32_t rnd ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;

  {
#line 781
  macbuf = (u_char *)((void *)0);
#line 783
  packet_length___0 = (u_int )0;
#line 785
  rnd = (u_int32_t )0;
#line 786
  enc = (Enc *)((void *)0);
#line 787
  mac = (Mac *)((void *)0);
#line 788
  comp = (Comp *)((void *)0);
#line 791
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 792
    enc = & (newkeys[1])->enc;
#line 793
    mac = & (newkeys[1])->mac;
#line 794
    comp = & (newkeys[1])->comp;
  }
#line 796
  if (enc) {
#line 796
    block_size = (int )enc->block_size;
  } else {
#line 796
    block_size = 8;
  }
#line 798
  tmp = buffer_ptr(& outgoing_packet);
#line 798
  cp = (u_char *)tmp;
#line 799
  type = *(cp + 5);
#line 806
  if (comp) {
#line 806
    if (comp->enabled) {
#line 807
      len = buffer_len(& outgoing_packet);
#line 809
      buffer_consume(& outgoing_packet, 5U);
#line 810
      buffer_clear(& compression_buffer);
#line 811
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 812
      buffer_clear(& outgoing_packet);
#line 813
      buffer_append(& outgoing_packet, (void const   *)"\000\000\000\000\000", 5U);
#line 814
      tmp___0 = buffer_len(& compression_buffer);
#line 814
      tmp___1 = buffer_ptr(& compression_buffer);
#line 814
      buffer_append(& outgoing_packet, (void const   *)tmp___1, tmp___0);
    }
  }
#line 821
  len = buffer_len(& outgoing_packet);
#line 827
  padlen = (unsigned char )((unsigned int )block_size - len % (unsigned int )block_size);
#line 828
  if ((int )padlen < 4) {
#line 829
    padlen = (unsigned char )((int )padlen + block_size);
  }
#line 830
  if (extra_pad) {
#line 832
    extra_pad = (unsigned char )((((int )extra_pad + (block_size - 1)) / block_size) * block_size);
#line 833
    pad = (unsigned char )((unsigned int )extra_pad - (len + (u_int )padlen) % (unsigned int )extra_pad);
#line 834
    debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)", pad, len, padlen,
           extra_pad);
#line 836
    padlen = (unsigned char )((int )padlen + (int )pad);
#line 837
    extra_pad = (unsigned char)0;
  }
#line 839
  tmp___2 = buffer_append_space(& outgoing_packet, (unsigned int )padlen);
#line 839
  cp = (u_char *)tmp___2;
#line 840
  if (enc) {
#line 840
    if (! send_context.plaintext) {
#line 842
      i = 0U;
#line 842
      while (i < (u_int )padlen) {
#line 843
        if (i % 4U == 0U) {
#line 844
          rnd = arc4random();
        }
#line 845
        *(cp + i) = (unsigned char )(rnd & 255U);
#line 846
        rnd >>= 8;
#line 842
        i ++;
      }
    } else {
#line 850
      memset((void *)cp, 0, (unsigned int )padlen);
    }
  } else {
#line 850
    memset((void *)cp, 0, (unsigned int )padlen);
  }
#line 853
  tmp___3 = buffer_len(& outgoing_packet);
#line 853
  packet_length___0 = tmp___3 - 4U;
#line 854
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 854
  cp = (u_char *)tmp___4;
#line 855
  put_u32((void *)cp, packet_length___0);
#line 856
  *(cp + 4) = padlen;
#line 860
  if (mac) {
#line 860
    if (mac->enabled) {
#line 861
      tmp___5 = buffer_len(& outgoing_packet);
#line 861
      tmp___6 = buffer_ptr(& outgoing_packet);
#line 861
      macbuf = mac_compute(mac, p_send.seqnr, (u_char *)tmp___6, (int )tmp___5);
    }
  }
#line 867
  tmp___7 = buffer_len(& outgoing_packet);
#line 867
  tmp___8 = buffer_append_space(& output, tmp___7);
#line 867
  cp = (u_char *)tmp___8;
#line 868
  tmp___9 = buffer_len(& outgoing_packet);
#line 868
  tmp___10 = buffer_ptr(& outgoing_packet);
#line 868
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___10, tmp___9);
#line 871
  if (mac) {
#line 871
    if (mac->enabled) {
#line 872
      buffer_append(& output, (void const   *)macbuf, mac->mac_len);
    }
  }
#line 878
  (p_send.seqnr) ++;
#line 878
  if (p_send.seqnr == 0U) {
#line 879
    logit("outgoing seqnr wraps around");
  }
#line 880
  (p_send.packets) ++;
#line 880
  if (p_send.packets == 0U) {
#line 881
    if (! (datafellows & 32768)) {
#line 882
      fatal("XXX too many packets with same key");
    }
  }
#line 883
  p_send.blocks += (u_int64_t )((packet_length___0 + 4U) / (u_int )block_size);
#line 884
  p_send.bytes += (u_int64_t )(packet_length___0 + 4U);
#line 885
  buffer_clear(& outgoing_packet);
#line 887
  if ((int )type == 21) {
#line 888
    set_newkeys(1);
  } else {
#line 889
    if ((int )type == 52) {
#line 889
      if (server_side) {
#line 890
        packet_enable_delayed_compress();
      }
    }
  }
#line 891
  return;
}
}
#line 896
static void packet_send2(void) ;
#line 896 "packet.c"
static int rekeying  =    0;
#line 893 "packet.c"
static void packet_send2(void) 
{ struct packet *p ;
  u_char type ;
  u_char *cp ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 900
  tmp = buffer_ptr(& outgoing_packet);
#line 900
  cp = (u_char *)tmp;
#line 901
  type = *(cp + 5);
#line 904
  if (rekeying) {
#line 905
    if ((int )type >= 1) {
#line 905
      if (! ((int )type <= 49)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 907
      debug("enqueue packet: %u", type);
#line 908
      tmp___0 = xmalloc(sizeof(*p));
#line 908
      p = (struct packet *)tmp___0;
#line 909
      p->type = type;
#line 910
      memcpy((void * __restrict  )(& p->payload), (void const   * __restrict  )(& outgoing_packet),
             sizeof(Buffer ));
#line 911
      buffer_init(& outgoing_packet);
#line 912
      while (1) {
#line 912
        p->next.tqe_next = (struct packet *)((void *)0);
#line 912
        p->next.tqe_prev = outgoing.tqh_last;
#line 912
        *(outgoing.tqh_last) = p;
#line 912
        outgoing.tqh_last = & p->next.tqe_next;
#line 912
        break;
      }
#line 913
      return;
    }
  }
#line 918
  if ((int )type == 20) {
#line 919
    rekeying = 1;
  }
#line 921
  packet_send2_wrapped();
#line 924
  if ((int )type == 21) {
#line 925
    rekeying = 0;
#line 926
    while (1) {
#line 926
      p = outgoing.tqh_first;
#line 926
      if (! p) {
#line 926
        break;
      }
#line 927
      type = p->type;
#line 928
      debug("dequeue packet: %u", type);
#line 929
      buffer_free(& outgoing_packet);
#line 930
      memcpy((void * __restrict  )(& outgoing_packet), (void const   * __restrict  )(& p->payload),
             sizeof(Buffer ));
#line 932
      while (1) {
#line 932
        if ((unsigned int )p->next.tqe_next != (unsigned int )((void *)0)) {
#line 932
          (p->next.tqe_next)->next.tqe_prev = p->next.tqe_prev;
        } else {
#line 932
          outgoing.tqh_last = p->next.tqe_prev;
        }
#line 932
        *(p->next.tqe_prev) = p->next.tqe_next;
#line 932
        break;
      }
#line 933
      xfree((void *)p);
#line 934
      packet_send2_wrapped();
    }
  }
#line 937
  return;
}
}
#line 939 "packet.c"
void packet_send(void) 
{ 

  {
#line 942
  if (compat20) {
#line 943
    packet_send2();
  } else {
#line 945
    packet_send1();
  }
#line 947
  return;
}
}
#line 955 "packet.c"
int packet_read_seqnr(u_int32_t *seqnr_p ) 
{ int type ;
  int len ;
  int ret___0 ;
  int ms_remain ;
  fd_set *setp ;
  char buf___1[8192] ;
  struct timeval timeout ;
  struct timeval start___0 ;
  struct timeval *timeoutp ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
#line 961
  timeoutp = (struct timeval *)((void *)0);
#line 965
  tmp = xcalloc(((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask )),
                sizeof(fd_mask ));
#line 965
  setp = (fd_set *)tmp;
#line 969
  packet_write_wait();
#line 972
  while (1) {
#line 974
    type = packet_read_poll_seqnr(seqnr_p);
#line 975
    if (! compat20) {
#line 975
      if (type == 14) {
        goto _L;
      } else {
#line 975
        if (type == 15) {
          goto _L;
        } else {
#line 975
          if (type == 19) {
            goto _L;
          } else {
#line 975
            if (type == 33) {
              _L: /* CIL Label */ 
#line 980
              while (1) {
#line 980
                tmp___0 = packet_remaining();
#line 980
                _len = tmp___0;
#line 980
                if (_len > 0) {
#line 980
                  logit("Packet integrity error (%d bytes remaining) at %s:%d", _len,
                        "packet.c", 980);
#line 980
                  packet_disconnect("Packet integrity error.");
                }
#line 980
                break;
              }
            }
          }
        }
      }
    }
#line 982
    if (type != 0) {
#line 983
      xfree((void *)setp);
#line 984
      return (type);
    }
#line 990
    memset((void *)setp, 0, (((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 992
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 994
    if (packet_timeout_ms > 0) {
#line 995
      ms_remain = packet_timeout_ms;
#line 996
      timeoutp = & timeout;
    }
#line 999
    while (1) {
#line 1000
      if (packet_timeout_ms != -1) {
#line 1001
        ms_to_timeval(& timeout, ms_remain);
#line 1002
        gettimeofday((struct timeval * __restrict  )(& start___0), (struct timezone * __restrict  )((void *)0));
      }
#line 1004
      ret___0 = select(connection_in + 1, (fd_set * __restrict  )setp, (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )timeoutp);
#line 1004
      if (ret___0 >= 0) {
#line 1006
        break;
      }
#line 1007
      tmp___1 = __errno_location();
#line 1007
      if (*tmp___1 != 11) {
#line 1007
        tmp___2 = __errno_location();
#line 1007
        if (*tmp___2 != 4) {
#line 1007
          tmp___3 = __errno_location();
#line 1007
          if (*tmp___3 != 11) {
#line 1009
            break;
          }
        }
      }
#line 1010
      if (packet_timeout_ms == -1) {
        goto __Cont;
      }
#line 1012
      ms_subtract_diff(& start___0, & ms_remain);
#line 1013
      if (ms_remain <= 0) {
#line 1014
        ret___0 = 0;
#line 1015
        break;
      }
      __Cont: /* CIL Label */ ;
    }
#line 1018
    if (ret___0 == 0) {
#line 1019
      tmp___4 = get_remote_ipaddr();
#line 1019
      logit("Connection to %.200s timed out while waiting to read", tmp___4);
#line 1021
      cleanup_exit(255);
    }
#line 1024
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 1025
    if (len == 0) {
#line 1026
      tmp___5 = get_remote_ipaddr();
#line 1026
      logit("Connection closed by %.200s", tmp___5);
#line 1027
      cleanup_exit(255);
    }
#line 1029
    if (len < 0) {
#line 1030
      tmp___6 = __errno_location();
#line 1030
      tmp___7 = strerror(*tmp___6);
#line 1030
      fatal("Read from socket failed: %.100s", tmp___7);
    }
#line 1032
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 1037 "packet.c"
int packet_read(void) 
{ int tmp ;

  {
#line 1040
  tmp = packet_read_seqnr((u_int32_t *)((void *)0));
#line 1040
  return (tmp);
}
}
#line 1048 "packet.c"
void packet_read_expect(int expected_type ) 
{ int type ;

  {
#line 1053
  type = packet_read();
#line 1054
  if (type != expected_type) {
#line 1055
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 1057
  return;
}
}
#line 1068 "packet.c"
static int packet_read_poll1(void) 
{ u_int len ;
  u_int padded_len ;
  u_char *cp ;
  u_char type ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 1076
  tmp = buffer_len(& input);
#line 1076
  if (tmp < 12U) {
#line 1077
    return (0);
  }
#line 1079
  tmp___0 = buffer_ptr(& input);
#line 1079
  cp = (u_char *)tmp___0;
#line 1080
  len = get_u32((void const   *)cp);
#line 1081
  if (len < 5U) {
#line 1082
    packet_disconnect("Bad packet length %u.", len);
  } else {
#line 1081
    if (len > 262144U) {
#line 1082
      packet_disconnect("Bad packet length %u.", len);
    }
  }
#line 1083
  padded_len = (len + 8U) & 4294967288U;
#line 1086
  tmp___1 = buffer_len(& input);
#line 1086
  if (tmp___1 < 4U + padded_len) {
#line 1087
    return (0);
  }
#line 1092
  buffer_consume(& input, 4U);
#line 1099
  if (! receive_context.plaintext) {
#line 1100
    tmp___2 = buffer_ptr(& input);
#line 1100
    tmp___3 = detect_attack((u_char *)tmp___2, padded_len);
#line 1100
    switch (tmp___3) {
    case 1: 
#line 1102
    packet_disconnect("crc32 compensation attack: network attack detected");
    case 2: 
#line 1105
    packet_disconnect("deattack denial of service detected");
    }
  }
#line 1111
  buffer_clear(& incoming_packet);
#line 1112
  tmp___4 = buffer_append_space(& incoming_packet, padded_len);
#line 1112
  cp = (u_char *)tmp___4;
#line 1113
  tmp___5 = buffer_ptr(& input);
#line 1113
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, padded_len);
#line 1115
  buffer_consume(& input, padded_len);
#line 1123
  tmp___6 = buffer_len(& incoming_packet);
#line 1123
  tmp___7 = buffer_ptr(& incoming_packet);
#line 1123
  checksum = ssh_crc32((u_char const   *)tmp___7, tmp___6 - 4U);
#line 1127
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 1130
  tmp___9 = buffer_len(& incoming_packet);
#line 1130
  if (len != tmp___9) {
#line 1131
    tmp___8 = buffer_len(& incoming_packet);
#line 1131
    packet_disconnect("packet_read_poll1: len %d != buffer_len %d.", len, tmp___8);
  }
#line 1134
  tmp___10 = buffer_ptr(& incoming_packet);
#line 1134
  cp = ((u_char *)tmp___10 + len) - 4;
#line 1135
  stored_checksum = get_u32((void const   *)cp);
#line 1136
  if (checksum != stored_checksum) {
#line 1137
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 1138
  buffer_consume_end(& incoming_packet, 4U);
#line 1140
  if (packet_compression) {
#line 1141
    buffer_clear(& compression_buffer);
#line 1142
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 1143
    buffer_clear(& incoming_packet);
#line 1144
    tmp___11 = buffer_len(& compression_buffer);
#line 1144
    tmp___12 = buffer_ptr(& compression_buffer);
#line 1144
    buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
  }
#line 1147
  (p_read.packets) ++;
#line 1148
  p_read.bytes += (u_int64_t )(padded_len + 4U);
#line 1149
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1149
  type = (unsigned char )tmp___13;
#line 1150
  if ((int )type < 1) {
#line 1151
    packet_disconnect("Invalid ssh1 packet type: %d", type);
  } else {
#line 1150
    if ((int )type > 254) {
#line 1151
      packet_disconnect("Invalid ssh1 packet type: %d", type);
    }
  }
#line 1152
  return ((int )type);
}
}
#line 1158
static int packet_read_poll2(u_int32_t *seqnr_p ) ;
#line 1158 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 1155 "packet.c"
static int packet_read_poll2(u_int32_t *seqnr_p ) 
{ u_int padlen ;
  u_int need ;
  u_char *macbuf ;
  u_char *cp ;
  u_char type ;
  u_int maclen ;
  u_int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 1162
  enc = (Enc *)((void *)0);
#line 1163
  mac = (Mac *)((void *)0);
#line 1164
  comp = (Comp *)((void *)0);
#line 1166
  if (packet_discard) {
#line 1167
    return (0);
  }
#line 1169
  if ((unsigned int )newkeys[0] != (unsigned int )((void *)0)) {
#line 1170
    enc = & (newkeys[0])->enc;
#line 1171
    mac = & (newkeys[0])->mac;
#line 1172
    comp = & (newkeys[0])->comp;
  }
#line 1174
  if (mac) {
#line 1174
    if (mac->enabled) {
#line 1174
      maclen = mac->mac_len;
    } else {
#line 1174
      maclen = 0U;
    }
  } else {
#line 1174
    maclen = 0U;
  }
#line 1175
  if (enc) {
#line 1175
    block_size = enc->block_size;
  } else {
#line 1175
    block_size = 8U;
  }
#line 1177
  if (packet_length == 0U) {
#line 1182
    tmp = buffer_len(& input);
#line 1182
    if (tmp < block_size) {
#line 1183
      return (0);
    }
#line 1184
    buffer_clear(& incoming_packet);
#line 1185
    tmp___0 = buffer_append_space(& incoming_packet, block_size);
#line 1185
    cp = (u_char *)tmp___0;
#line 1186
    tmp___1 = buffer_ptr(& input);
#line 1186
    cipher_crypt(& receive_context, cp, (u_char const   *)tmp___1, block_size);
#line 1188
    tmp___2 = buffer_ptr(& incoming_packet);
#line 1188
    cp = (u_char *)tmp___2;
#line 1189
    packet_length = get_u32((void const   *)cp);
#line 1190
    if (packet_length < 5U) {
#line 1194
      logit("Bad packet length %u.", packet_length);
#line 1195
      packet_start_discard(enc, mac, packet_length, 262144U);
#line 1197
      return (0);
    } else {
#line 1190
      if (packet_length > 262144U) {
#line 1194
        logit("Bad packet length %u.", packet_length);
#line 1195
        packet_start_discard(enc, mac, packet_length, 262144U);
#line 1197
        return (0);
      }
    }
#line 1200
    buffer_consume(& input, block_size);
  }
#line 1203
  need = (4U + packet_length) - block_size;
#line 1206
  if (need % block_size != 0U) {
#line 1207
    logit("padding error: need %d block %d mod %d", need, block_size, need % block_size);
#line 1209
    packet_start_discard(enc, mac, packet_length, 262144U - block_size);
#line 1211
    return (0);
  }
#line 1217
  tmp___3 = buffer_len(& input);
#line 1217
  if (tmp___3 < need + maclen) {
#line 1218
    return (0);
  }
#line 1223
  tmp___4 = buffer_append_space(& incoming_packet, need);
#line 1223
  cp = (u_char *)tmp___4;
#line 1224
  tmp___5 = buffer_ptr(& input);
#line 1224
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, need);
#line 1225
  buffer_consume(& input, need);
#line 1230
  if (mac) {
#line 1230
    if (mac->enabled) {
#line 1231
      tmp___6 = buffer_len(& incoming_packet);
#line 1231
      tmp___7 = buffer_ptr(& incoming_packet);
#line 1231
      macbuf = mac_compute(mac, p_read.seqnr, (u_char *)tmp___7, (int )tmp___6);
#line 1234
      tmp___8 = buffer_ptr(& input);
#line 1234
      tmp___9 = memcmp((void const   *)macbuf, (void const   *)tmp___8, mac->mac_len);
#line 1234
      if (tmp___9 != 0) {
#line 1235
        logit("Corrupted MAC on input.");
#line 1236
        if (need > 262144U) {
#line 1237
          fatal("internal error need %d", need);
        }
#line 1238
        packet_start_discard(enc, mac, packet_length, 262144U - need);
#line 1240
        return (0);
      }
#line 1244
      buffer_consume(& input, mac->mac_len);
    }
  }
#line 1247
  if ((unsigned int )seqnr_p != (unsigned int )((void *)0)) {
#line 1248
    *seqnr_p = p_read.seqnr;
  }
#line 1249
  (p_read.seqnr) ++;
#line 1249
  if (p_read.seqnr == 0U) {
#line 1250
    logit("incoming seqnr wraps around");
  }
#line 1251
  (p_read.packets) ++;
#line 1251
  if (p_read.packets == 0U) {
#line 1252
    if (! (datafellows & 32768)) {
#line 1253
      fatal("XXX too many packets with same key");
    }
  }
#line 1254
  p_read.blocks += (u_int64_t )((packet_length + 4U) / block_size);
#line 1255
  p_read.bytes += (u_int64_t )(packet_length + 4U);
#line 1258
  tmp___10 = buffer_ptr(& incoming_packet);
#line 1258
  cp = (u_char *)tmp___10;
#line 1259
  padlen = (unsigned int )*(cp + 4);
#line 1261
  if (padlen < 4U) {
#line 1262
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 1265
  buffer_consume(& incoming_packet, 5U);
#line 1266
  buffer_consume_end(& incoming_packet, padlen);
#line 1269
  if (comp) {
#line 1269
    if (comp->enabled) {
#line 1270
      buffer_clear(& compression_buffer);
#line 1271
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 1272
      buffer_clear(& incoming_packet);
#line 1273
      tmp___11 = buffer_len(& compression_buffer);
#line 1273
      tmp___12 = buffer_ptr(& compression_buffer);
#line 1273
      buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
    }
  }
#line 1282
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1282
  type = (unsigned char )tmp___13;
#line 1283
  if ((int )type < 1) {
#line 1284
    packet_disconnect("Invalid ssh2 packet type: %d", type);
  } else {
#line 1283
    if ((int )type >= 192) {
#line 1284
      packet_disconnect("Invalid ssh2 packet type: %d", type);
    }
  }
#line 1285
  if ((int )type == 21) {
#line 1286
    set_newkeys(0);
  } else {
#line 1287
    if ((int )type == 52) {
#line 1287
      if (! server_side) {
#line 1288
        packet_enable_delayed_compress();
      }
    }
  }
#line 1294
  packet_length = 0U;
#line 1295
  return ((int )type);
}
}
#line 1298 "packet.c"
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) 
{ u_int reason ;
  u_int seqnr ;
  u_char type ;
  char *msg ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 1305
  while (1) {
#line 1306
    if (compat20) {
#line 1307
      tmp = packet_read_poll2(seqnr_p);
#line 1307
      type = (unsigned char )tmp;
#line 1308
      if (type) {
#line 1309
        keep_alive_timeouts = 0;
      }
#line 1312
      switch ((int )type) {
      case 2: 
#line 1314
      debug3("Received SSH2_MSG_IGNORE");
#line 1315
      break;
      case 4: 
#line 1317
      packet_get_char();
#line 1318
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1318
      msg = (char *)tmp___0;
#line 1319
      debug("Remote: %.900s", msg);
#line 1320
      xfree((void *)msg);
#line 1321
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1321
      msg = (char *)tmp___1;
#line 1322
      xfree((void *)msg);
#line 1323
      break;
      case 1: 
#line 1325
      reason = packet_get_int();
#line 1326
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 1326
      msg = (char *)tmp___2;
#line 1327
      tmp___3 = get_remote_ipaddr();
#line 1327
      logit("Received disconnect from %s: %u: %.400s", tmp___3, reason, msg);
#line 1329
      xfree((void *)msg);
#line 1330
      cleanup_exit(255);
#line 1331
      break;
      case 3: 
#line 1333
      seqnr = packet_get_int();
#line 1334
      debug("Received SSH2_MSG_UNIMPLEMENTED for %u", seqnr);
#line 1336
      break;
      default: ;
#line 1338
      return ((int )type);
      }
    } else {
#line 1341
      tmp___4 = packet_read_poll1();
#line 1341
      type = (unsigned char )tmp___4;
#line 1342
      switch ((int )type) {
      case 32: 
#line 1344
      break;
      case 36: 
#line 1346
      tmp___5 = packet_get_string((u_int *)((void *)0));
#line 1346
      msg = (char *)tmp___5;
#line 1347
      debug("Remote: %.900s", msg);
#line 1348
      xfree((void *)msg);
#line 1349
      break;
      case 1: 
#line 1351
      tmp___6 = packet_get_string((u_int *)((void *)0));
#line 1351
      msg = (char *)tmp___6;
#line 1352
      tmp___7 = get_remote_ipaddr();
#line 1352
      logit("Received disconnect from %s: %.400s", tmp___7, msg);
#line 1354
      cleanup_exit(255);
#line 1355
      break;
      default: ;
#line 1357
      if (type) {

      }
#line 1359
      return ((int )type);
      }
    }
  }
}
}
#line 1365 "packet.c"
int packet_read_poll(void) 
{ int tmp ;

  {
#line 1368
  tmp = packet_read_poll_seqnr((u_int32_t *)((void *)0));
#line 1368
  return (tmp);
}
}
#line 1376 "packet.c"
void packet_process_incoming(char const   *buf___1 , u_int len ) 
{ 

  {
#line 1379
  if (packet_discard) {
#line 1380
    keep_alive_timeouts = 0;
#line 1381
    if (len >= packet_discard) {
#line 1382
      packet_stop_discard();
    }
#line 1383
    packet_discard -= len;
#line 1384
    return;
  }
#line 1386
  buffer_append(& input, (void const   *)buf___1, len);
#line 1387
  return;
}
}
#line 1391 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 1396
  buffer_get(& incoming_packet, (void *)(& ch), 1U);
#line 1397
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1402 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 1405
  tmp = buffer_get_int(& incoming_packet);
#line 1405
  return (tmp);
}
}
#line 1413 "packet.c"
void packet_get_bignum(BIGNUM *value ) 
{ 

  {
#line 1416
  buffer_get_bignum(& incoming_packet, value);
#line 1417
  return;
}
}
#line 1419 "packet.c"
void packet_get_bignum2(BIGNUM *value ) 
{ 

  {
#line 1422
  buffer_get_bignum2(& incoming_packet, value);
#line 1423
  return;
}
}
#line 1425 "packet.c"
void *packet_get_raw(u_int *length_ptr ) 
{ u_int bytes ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 1428
  tmp = buffer_len(& incoming_packet);
#line 1428
  bytes = tmp;
#line 1430
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1431
    *length_ptr = bytes;
  }
#line 1432
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1432
  return (tmp___0);
}
}
#line 1435 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 1438
  tmp = buffer_len(& incoming_packet);
#line 1438
  return ((int )tmp);
}
}
#line 1448 "packet.c"
void *packet_get_string(u_int *length_ptr ) 
{ void *tmp ;

  {
#line 1451
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1451
  return (tmp);
}
}
#line 1454 "packet.c"
void *packet_get_string_ptr(u_int *length_ptr ) 
{ void *tmp ;

  {
#line 1457
  tmp = buffer_get_string_ptr(& incoming_packet, length_ptr);
#line 1457
  return (tmp);
}
}
#line 1469 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1475
  if (compat20) {
#line 1475
    if (datafellows & 64) {
#line 1476
      return;
    }
  }
#line 1478
  __builtin_va_start(args, fmt);
#line 1479
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1480
  __builtin_va_end(args);
#line 1482
  if (compat20) {
#line 1483
    packet_start((unsigned char)4);
#line 1484
    packet_put_char(0);
#line 1485
    packet_put_cstring((char const   *)(buf___1));
#line 1486
    packet_put_cstring("");
  } else {
#line 1488
    packet_start((unsigned char)36);
#line 1489
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1491
  packet_send();
#line 1492
  packet_write_wait();
#line 1493
  return;
}
}
#line 1507 "packet.c"
static int disconnecting  =    0;
#line 1502 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1509
  if (disconnecting) {
#line 1510
    fatal("packet_disconnect called recursively.");
  }
#line 1511
  disconnecting = 1;
#line 1517
  __builtin_va_start(args, fmt);
#line 1518
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1519
  __builtin_va_end(args);
#line 1522
  logit("Disconnecting: %.100s", buf___1);
#line 1525
  if (compat20) {
#line 1526
    packet_start((unsigned char)1);
#line 1527
    packet_put_int(2U);
#line 1528
    packet_put_cstring((char const   *)(buf___1));
#line 1529
    packet_put_cstring("");
  } else {
#line 1531
    packet_start((unsigned char)1);
#line 1532
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1534
  packet_send();
#line 1535
  packet_write_wait();
#line 1538
  channel_close_all();
#line 1541
  packet_close();
#line 1542
  cleanup_exit(255);
}
}
#line 1547 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 1550
  tmp = buffer_len(& output);
#line 1550
  len = (int )tmp;
#line 1552
  if (len > 0) {
#line 1553
    tmp___0 = buffer_ptr(& output);
#line 1553
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1554
    if (len == -1) {
#line 1555
      tmp___1 = __errno_location();
#line 1555
      if (*tmp___1 == 4) {
#line 1557
        return;
      } else {
#line 1555
        tmp___2 = __errno_location();
#line 1555
        if (*tmp___2 == 11) {
#line 1557
          return;
        } else {
#line 1555
          tmp___3 = __errno_location();
#line 1555
          if (*tmp___3 == 11) {
#line 1557
            return;
          }
        }
      }
#line 1558
      tmp___4 = __errno_location();
#line 1558
      tmp___5 = strerror(*tmp___4);
#line 1558
      fatal("Write failed: %.100s", tmp___5);
    }
#line 1560
    if (len == 0) {
#line 1561
      fatal("Write connection closed");
    }
#line 1562
    buffer_consume(& output, (unsigned int )len);
  }
#line 1564
  return;
}
}
#line 1572 "packet.c"
void packet_write_wait(void) 
{ fd_set *setp ;
  int ret___0 ;
  int ms_remain ;
  struct timeval start___0 ;
  struct timeval timeout ;
  struct timeval *timeoutp ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
#line 1577
  timeoutp = (struct timeval *)((void *)0);
#line 1579
  tmp = xcalloc(((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask )),
                sizeof(fd_mask ));
#line 1579
  setp = (fd_set *)tmp;
#line 1581
  packet_write_poll();
#line 1582
  while (1) {
#line 1582
    tmp___4 = packet_have_data_to_write();
#line 1582
    if (! tmp___4) {
#line 1582
      break;
    }
#line 1583
    memset((void *)setp, 0, (((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1585
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1587
    if (packet_timeout_ms > 0) {
#line 1588
      ms_remain = packet_timeout_ms;
#line 1589
      timeoutp = & timeout;
    }
#line 1591
    while (1) {
#line 1592
      if (packet_timeout_ms != -1) {
#line 1593
        ms_to_timeval(& timeout, ms_remain);
#line 1594
        gettimeofday((struct timeval * __restrict  )(& start___0), (struct timezone * __restrict  )((void *)0));
      }
#line 1596
      ret___0 = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )setp,
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )timeoutp);
#line 1596
      if (ret___0 >= 0) {
#line 1598
        break;
      }
#line 1599
      tmp___0 = __errno_location();
#line 1599
      if (*tmp___0 != 11) {
#line 1599
        tmp___1 = __errno_location();
#line 1599
        if (*tmp___1 != 4) {
#line 1599
          tmp___2 = __errno_location();
#line 1599
          if (*tmp___2 != 11) {
#line 1601
            break;
          }
        }
      }
#line 1602
      if (packet_timeout_ms == -1) {
        goto __Cont;
      }
#line 1604
      ms_subtract_diff(& start___0, & ms_remain);
#line 1605
      if (ms_remain <= 0) {
#line 1606
        ret___0 = 0;
#line 1607
        break;
      }
      __Cont: /* CIL Label */ ;
    }
#line 1610
    if (ret___0 == 0) {
#line 1611
      tmp___3 = get_remote_ipaddr();
#line 1611
      logit("Connection to %.200s timed out while waiting to write", tmp___3);
#line 1613
      cleanup_exit(255);
    }
#line 1615
    packet_write_poll();
  }
#line 1617
  xfree((void *)setp);
#line 1618
  return;
}
}
#line 1622 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1625
  tmp = buffer_len(& output);
#line 1625
  return (tmp != 0U);
}
}
#line 1630 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1633
  if (interactive_mode) {
#line 1634
    tmp = buffer_len(& output);
#line 1634
    return (tmp < 16384U);
  } else {
#line 1636
    tmp___0 = buffer_len(& output);
#line 1636
    return (tmp___0 < 131072U);
  }
}
}
#line 1640 "packet.c"
static void packet_set_tos(int interactive ) 
{ int tos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1644
  if (interactive) {
#line 1644
    tmp = 16;
  } else {
#line 1644
    tmp = 8;
  }
#line 1644
  tos = tmp;
#line 1646
  tmp___0 = packet_connection_is_on_socket();
#line 1646
  if (tmp___0) {
#line 1646
    tmp___1 = packet_connection_is_ipv4();
#line 1646
    if (! tmp___1) {
#line 1648
      return;
    }
  } else {
#line 1648
    return;
  }
#line 1649
  tmp___4 = setsockopt(connection_in, 0, 1, (void const   *)(& tos), sizeof(tos));
#line 1649
  if (tmp___4 < 0) {
#line 1651
    tmp___2 = __errno_location();
#line 1651
    tmp___3 = strerror(*tmp___2);
#line 1651
    error("setsockopt IP_TOS %d: %.100s:", tos, tmp___3);
  }
#line 1654
  return;
}
}
#line 1661 "packet.c"
static int called  =    0;
#line 1658 "packet.c"
void packet_set_interactive(int interactive ) 
{ int tmp ;

  {
#line 1663
  if (called) {
#line 1664
    return;
  }
#line 1665
  called = 1;
#line 1668
  interactive_mode = interactive;
#line 1671
  tmp = packet_connection_is_on_socket();
#line 1671
  if (! tmp) {
#line 1672
    return;
  }
#line 1673
  set_nodelay(connection_in);
#line 1674
  packet_set_tos(interactive);
#line 1675
  return;
}
}
#line 1679 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1682
  return (interactive_mode);
}
}
#line 1688 "packet.c"
static int called___0  =    0;
#line 1685 "packet.c"
int packet_set_maxsize(u_int s ) 
{ 

  {
#line 1690
  if (called___0) {
#line 1691
    logit("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1693
    return (-1);
  }
#line 1695
  if (s < 4096U) {
#line 1696
    logit("packet_set_maxsize: bad size %d", s);
#line 1697
    return (-1);
  } else {
#line 1695
    if (s > 1048576U) {
#line 1696
      logit("packet_set_maxsize: bad size %d", s);
#line 1697
      return (-1);
    }
  }
#line 1699
  called___0 = 1;
#line 1700
  debug("packet_set_maxsize: setting to %d", s);
#line 1701
  max_packet_size = s;
#line 1702
  return ((int )s);
}
}
#line 1706 "packet.c"
void packet_add_padding(u_char pad ) 
{ 

  {
#line 1709
  extra_pad = pad;
#line 1710
  return;
}
}
#line 1723 "packet.c"
void packet_send_ignore(int nbytes ) 
{ u_int32_t rnd ;
  int i ;
  int tmp ;

  {
#line 1726
  rnd = (u_int32_t )0;
#line 1729
  if (compat20) {
#line 1729
    tmp = 2;
  } else {
#line 1729
    tmp = 32;
  }
#line 1729
  packet_start((unsigned char )tmp);
#line 1730
  packet_put_int((unsigned int )nbytes);
#line 1731
  i = 0;
#line 1731
  while (i < nbytes) {
#line 1732
    if (i % 4 == 0) {
#line 1733
      rnd = arc4random();
    }
#line 1734
    packet_put_char((int )((unsigned char )rnd) & 255);
#line 1735
    rnd >>= 8;
#line 1731
    i ++;
  }
#line 1737
  return;
}
}
#line 1740 "packet.c"
int packet_need_rekeying(void) 
{ int tmp ;

  {
#line 1743
  if (datafellows & 32768) {
#line 1744
    return (0);
  }
#line 1745
  if (p_send.packets > 1U << 31) {
#line 1745
    tmp = 1;
  } else {
#line 1745
    if (p_read.packets > 1U << 31) {
#line 1745
      tmp = 1;
    } else {
#line 1745
      if (max_blocks_out) {
#line 1745
        if (p_send.blocks > max_blocks_out) {
#line 1745
          tmp = 1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1745
        if (max_blocks_in) {
#line 1745
          if (p_read.blocks > max_blocks_in) {
#line 1745
            tmp = 1;
          } else {
#line 1745
            tmp = 0;
          }
        } else {
#line 1745
          tmp = 0;
        }
      }
    }
  }
#line 1745
  return (tmp);
}
}
#line 1752 "packet.c"
void packet_set_rekey_limit(u_int32_t bytes ) 
{ 

  {
#line 1755
  rekey_limit = bytes;
#line 1756
  return;
}
}
#line 1758 "packet.c"
void packet_set_server(void) 
{ 

  {
#line 1761
  server_side = 1;
#line 1762
  return;
}
}
#line 1764 "packet.c"
void packet_set_authenticated(void) 
{ 

  {
#line 1767
  after_authentication = 1;
#line 1768
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
#line 1 "readpass.o"
#pragma merger(0,"./readpass.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 89 "misc.h"
char *read_passphrase(char const   *prompt , int flags ) ;
#line 90
int ( /* format attribute */  ask_permission)(char const   *fmt  , ...) ;
#line 18 "uidswap.h"
void permanently_drop_suid(uid_t uid ) ;
#line 49 "readpass.c"
static char *ssh_askpass(char *askpass , char const   *msg ) 
{ pid_t pid ;
  size_t len ;
  char *pass ;
  int p[2] ;
  int status ;
  int ret___0 ;
  char buf___1[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  __pid_t tmp___15 ;
  union __anonunion___u_75 __u ;
  union __anonunion___u_76 __u___0 ;
  unsigned int tmp___48 ;

  {
#line 58
  tmp___1 = fflush(stdout);
#line 58
  if (tmp___1 != 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("ssh_askpass: fflush: %s", tmp___0);
  }
#line 60
  if ((unsigned int )askpass == (unsigned int )((void *)0)) {
#line 61
    fatal("internal error: askpass undefined");
  }
#line 62
  tmp___4 = pipe((int *)(p));
#line 62
  if (tmp___4 < 0) {
#line 63
    tmp___2 = __errno_location();
#line 63
    tmp___3 = strerror(*tmp___2);
#line 63
    error("ssh_askpass: pipe: %s", tmp___3);
#line 64
    return ((char *)((void *)0));
  }
#line 66
  pid = fork();
#line 66
  if (pid < 0) {
#line 67
    tmp___5 = __errno_location();
#line 67
    tmp___6 = strerror(*tmp___5);
#line 67
    error("ssh_askpass: fork: %s", tmp___6);
#line 68
    return ((char *)((void *)0));
  }
#line 70
  if (pid == 0) {
#line 71
    tmp___7 = getuid();
#line 71
    permanently_drop_suid(tmp___7);
#line 72
    close(p[0]);
#line 73
    tmp___10 = dup2(p[1], 1);
#line 73
    if (tmp___10 < 0) {
#line 74
      tmp___8 = __errno_location();
#line 74
      tmp___9 = strerror(*tmp___8);
#line 74
      fatal("ssh_askpass: dup2: %s", tmp___9);
    }
#line 75
    execlp((char const   *)askpass, (char const   *)askpass, msg, (char *)0);
#line 76
    tmp___11 = __errno_location();
#line 76
    tmp___12 = strerror(*tmp___11);
#line 76
    fatal("ssh_askpass: exec(%s): %s", askpass, tmp___12);
  }
#line 78
  close(p[1]);
#line 80
  ret___0 = 0;
#line 80
  len = (unsigned int )ret___0;
#line 81
  while (1) {
#line 82
    ret___0 = read(p[0], (void *)(buf___1 + len), (sizeof(buf___1) - 1U) - len);
#line 83
    if (ret___0 == -1) {
#line 83
      tmp___13 = __errno_location();
#line 83
      if (*tmp___13 == 4) {
        goto __Cont;
      }
    }
#line 85
    if (ret___0 <= 0) {
#line 86
      break;
    }
#line 87
    len += (size_t )ret___0;
    __Cont: /* CIL Label */ 
#line 81
    if (! ((sizeof(buf___1) - 1U) - len > 0U)) {
#line 81
      break;
    }
  }
#line 89
  buf___1[len] = (char )'\000';
#line 91
  close(p[0]);
#line 92
  while (1) {
#line 92
    tmp___15 = waitpid(pid, & status, 0);
#line 92
    if (! (tmp___15 < 0)) {
#line 92
      break;
    }
#line 93
    tmp___14 = __errno_location();
#line 93
    if (*tmp___14 != 4) {
#line 94
      break;
    }
  }
#line 96
  __u.__in = status;
#line 96
  if ((__u.__i & 127) == 0) {
#line 96
    __u___0.__in = status;
#line 96
    if ((__u___0.__i & 65280) >> 8 != 0) {
#line 97
      memset((void *)(buf___1), 0, sizeof(buf___1));
#line 98
      return ((char *)((void *)0));
    }
  } else {
#line 97
    memset((void *)(buf___1), 0, sizeof(buf___1));
#line 98
    return ((char *)((void *)0));
  }
#line 101
  tmp___48 = __builtin_strcspn((char const   *)(buf___1), "\r\n");
#line 101
  buf___1[tmp___48] = (char )'\000';
#line 102
  pass = xstrdup((char const   *)(buf___1));
#line 103
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 104
  return (pass);
}
}
#line 113 "readpass.c"
char *read_passphrase(char const   *prompt , int flags ) 
{ char *askpass ;
  char *ret___0 ;
  char buf___1[1024] ;
  int rppflags ;
  int use_askpass ;
  int ttyfd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 116
  askpass = (char *)((void *)0);
#line 117
  use_askpass = 0;
#line 119
  if (flags & 1) {
#line 119
    rppflags = 1;
  } else {
#line 119
    rppflags = 0;
  }
#line 120
  if (flags & 8) {
#line 121
    use_askpass = 1;
  } else {
#line 122
    if (flags & 2) {
#line 123
      tmp = isatty(0);
#line 123
      if (! tmp) {
#line 124
        debug("read_passphrase: stdin is not a tty");
#line 125
        use_askpass = 1;
      }
    } else {
#line 128
      rppflags |= 2;
#line 129
      ttyfd = open("/dev/tty", 2);
#line 130
      if (ttyfd >= 0) {
#line 131
        close(ttyfd);
      } else {
#line 133
        tmp___0 = __errno_location();
#line 133
        tmp___1 = strerror(*tmp___0);
#line 133
        debug("read_passphrase: can\'t open %s: %s", "/dev/tty", tmp___1);
#line 135
        use_askpass = 1;
      }
    }
  }
#line 139
  if (flags & 8) {
#line 139
    tmp___4 = getenv("DISPLAY");
#line 139
    if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 140
      if (flags & 4) {
#line 140
        tmp___3 = (char *)((void *)0);
      } else {
#line 140
        tmp___3 = xstrdup("");
      }
#line 140
      return (tmp___3);
    }
  }
#line 142
  if (use_askpass) {
#line 142
    tmp___7 = getenv("DISPLAY");
#line 142
    if (tmp___7) {
#line 143
      tmp___5 = getenv("SSH_ASKPASS");
#line 143
      if (tmp___5) {
#line 144
        askpass = getenv("SSH_ASKPASS");
      } else {
#line 146
        askpass = (char *)"/usr/local/libexec/ssh-askpass";
      }
#line 147
      ret___0 = ssh_askpass(askpass, prompt);
#line 147
      if ((unsigned int )ret___0 == (unsigned int )((void *)0)) {
#line 148
        if (! (flags & 4)) {
#line 149
          tmp___6 = xstrdup("");
#line 149
          return (tmp___6);
        }
      }
#line 150
      return (ret___0);
    }
  }
#line 153
  tmp___9 = readpassphrase(prompt, buf___1, sizeof(buf___1), rppflags);
#line 153
  if ((unsigned int )tmp___9 == (unsigned int )((void *)0)) {
#line 154
    if (flags & 4) {
#line 155
      return ((char *)((void *)0));
    }
#line 156
    tmp___8 = xstrdup("");
#line 156
    return (tmp___8);
  }
#line 159
  ret___0 = xstrdup((char const   *)(buf___1));
#line 160
  memset((void *)(buf___1), 'x', sizeof(buf___1));
#line 161
  return (ret___0);
}
}
#line 164 "readpass.c"
int ( /* format attribute */  ask_permission)(char const   *fmt  , ...) 
{ va_list args ;
  char *p ;
  char prompt[1024] ;
  int allowed ;
  int tmp ;

  {
#line 169
  allowed = 0;
#line 171
  __builtin_va_start(args, fmt);
#line 172
  vsnprintf((char * __restrict  )(prompt), sizeof(prompt), (char const   * __restrict  )fmt,
            args);
#line 173
  __builtin_va_end(args);
#line 175
  p = read_passphrase((char const   *)(prompt), 12);
#line 176
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 181
    if ((int )*p == 0) {
#line 183
      allowed = 1;
    } else {
#line 181
      if ((int )*p == 10) {
#line 183
        allowed = 1;
      } else {
#line 181
        tmp = strcasecmp((char const   *)p, "yes");
#line 181
        if (tmp == 0) {
#line 183
          allowed = 1;
        }
      }
    }
#line 184
    xfree((void *)p);
  }
#line 187
  return (allowed);
}
}
#line 1 "rsa.o"
#pragma merger(0,"./rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 74 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  BIGNUM *tmp___4 ;

  {
#line 80
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 80
  if (tmp < 2) {
#line 81
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 80
    if ((key->e)->top > 0) {
#line 80
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 81
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 81
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 83
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 83
  olen = (tmp___0 + 7) / 8;
#line 84
  tmp___1 = xmalloc((unsigned int )olen);
#line 84
  outbuf = (u_char *)tmp___1;
#line 86
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 86
  ilen = (tmp___2 + 7) / 8;
#line 87
  tmp___3 = xmalloc((unsigned int )ilen);
#line 87
  inbuf = (u_char *)tmp___3;
#line 88
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 90
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 90
  if (len <= 0) {
#line 92
    fatal("rsa_public_encrypt() failed");
  }
#line 94
  tmp___4 = BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 94
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 95
    fatal("rsa_public_encrypt: BN_bin2bn failed");
  }
#line 97
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 98
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 99
  xfree((void *)outbuf);
#line 100
  xfree((void *)inbuf);
#line 101
  return;
}
}
#line 103 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  BIGNUM *tmp___3 ;

  {
#line 109
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 109
  olen = (tmp + 7) / 8;
#line 110
  tmp___0 = xmalloc((unsigned int )olen);
#line 110
  outbuf = (u_char *)tmp___0;
#line 112
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 112
  ilen = (tmp___1 + 7) / 8;
#line 113
  tmp___2 = xmalloc((unsigned int )ilen);
#line 113
  inbuf = (u_char *)tmp___2;
#line 114
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 116
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 116
  if (len <= 0) {
#line 118
    error("rsa_private_decrypt() failed");
  } else {
#line 120
    tmp___3 = BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 120
    if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 121
      fatal("rsa_private_decrypt: BN_bin2bn failed");
    }
  }
#line 123
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 124
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 125
  xfree((void *)outbuf);
#line 126
  xfree((void *)inbuf);
#line 127
  return (len);
}
}
#line 131 "rsa.c"
void rsa_generate_additional_parameters(RSA *rsa ) 
{ BIGNUM *aux ;
  BN_CTX *ctx ;
  BIGNUM const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  BIGNUM const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 137
  aux = BN_new();
#line 137
  if ((unsigned int )aux == (unsigned int )((void *)0)) {
#line 138
    fatal("rsa_generate_additional_parameters: BN_new failed");
  }
#line 139
  ctx = BN_CTX_new();
#line 139
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 140
    fatal("rsa_generate_additional_parameters: BN_CTX_new failed");
  }
#line 142
  tmp = BN_value_one();
#line 142
  tmp___0 = BN_sub(aux, (BIGNUM const   *)rsa->q, tmp);
#line 142
  if (tmp___0 == 0) {
#line 146
    fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
  } else {
#line 142
    tmp___1 = BN_div((BIGNUM *)((void *)0), rsa->dmq1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
                     ctx);
#line 142
    if (tmp___1 == 0) {
#line 146
      fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
    } else {
#line 142
      tmp___2 = BN_value_one();
#line 142
      tmp___3 = BN_sub(aux, (BIGNUM const   *)rsa->p, tmp___2);
#line 142
      if (tmp___3 == 0) {
#line 146
        fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
      } else {
#line 142
        tmp___4 = BN_div((BIGNUM *)((void *)0), rsa->dmp1, (BIGNUM const   *)rsa->d,
                         (BIGNUM const   *)aux, ctx);
#line 142
        if (tmp___4 == 0) {
#line 146
          fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
        }
      }
    }
  }
#line 148
  BN_clear_free(aux);
#line 149
  BN_CTX_free(ctx);
#line 150
  return;
}
}
#line 1 "ttymodes.o"
#pragma merger(0,"./ttymodes.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 87 "packet.h"
void tty_make_modes(int fd , struct termios *tiop ) ;
#line 88
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 74 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 77
  switch ((int )speed) {
  case 0: 
#line 79
  return (0);
  case 1: 
#line 81
  return (50);
  case 2: 
#line 83
  return (75);
  case 3: 
#line 85
  return (110);
  case 4: 
#line 87
  return (134);
  case 5: 
#line 89
  return (150);
  case 6: 
#line 91
  return (200);
  case 7: 
#line 93
  return (300);
  case 8: 
#line 95
  return (600);
  case 9: 
#line 97
  return (1200);
  case 10: 
#line 99
  return (1800);
  case 11: 
#line 101
  return (2400);
  case 12: 
#line 103
  return (4800);
  case 13: 
#line 105
  return (9600);
  case 14: 
#line 109
  return (19200);
  case 15: 
#line 119
  return (38400);
  case 4097: 
#line 141
  return (57600);
  case 4098: 
#line 149
  return (115200);
  case 4099: 
#line 153
  return (230400);
  default: ;
#line 156
  return (9600);
  }
}
}
#line 163 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 166
  switch (baud) {
  case 0: 
#line 168
  return (0U);
  case 50: 
#line 170
  return (1U);
  case 75: 
#line 172
  return (2U);
  case 110: 
#line 174
  return (3U);
  case 134: 
#line 176
  return (4U);
  case 150: 
#line 178
  return (5U);
  case 200: 
#line 180
  return (6U);
  case 300: 
#line 182
  return (7U);
  case 600: 
#line 184
  return (8U);
  case 1200: 
#line 186
  return (9U);
  case 1800: 
#line 188
  return (10U);
  case 2400: 
#line 190
  return (11U);
  case 4800: 
#line 192
  return (12U);
  case 9600: 
#line 194
  return (13U);
  case 19200: 
#line 198
  return (14U);
  case 38400: 
#line 208
  return (15U);
  case 57600: 
#line 230
  return (4097U);
  case 115200: 
#line 238
  return (4098U);
  case 230400: 
#line 242
  return (4099U);
  default: ;
#line 245
  return (13U);
  }
}
}
#line 252 "ttymodes.c"
static u_int special_char_encode(cc_t c ) 
{ 

  {
#line 259
  return ((unsigned int )c);
}
}
#line 265 "ttymodes.c"
static cc_t special_char_decode(u_int c ) 
{ 

  {
#line 272
  return ((unsigned char )c);
}
}
#line 280 "ttymodes.c"
void tty_make_modes(int fd , struct termios *tiop ) 
{ struct termios tio ;
  int baud ;
  Buffer buf___1 ;
  int tty_op_ospeed ;
  int tty_op_ispeed ;
  void (*put_arg)(Buffer * , u_int  ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  void *tmp___19 ;
  u_int tmp___20 ;
  void *tmp___21 ;

  {
#line 289
  buffer_init(& buf___1);
#line 290
  if (compat20) {
#line 291
    tty_op_ospeed = 129;
#line 292
    tty_op_ispeed = 128;
#line 293
    put_arg = & buffer_put_int;
  } else {
#line 295
    tty_op_ospeed = 193;
#line 296
    tty_op_ispeed = 192;
#line 297
    put_arg = (void (*)(Buffer * , u_int  ))(& buffer_put_char);
  }
#line 300
  if ((unsigned int )tiop == (unsigned int )((void *)0)) {
#line 301
    if (fd == -1) {
#line 302
      debug("tty_make_modes: no fd or tio");
      goto end;
    }
#line 305
    tmp___1 = tcgetattr(fd, & tio);
#line 305
    if (tmp___1 == -1) {
#line 306
      tmp = __errno_location();
#line 306
      tmp___0 = strerror(*tmp);
#line 306
      logit("tcgetattr: %.100s", tmp___0);
      goto end;
    }
  } else {
#line 310
    tio = *tiop;
  }
#line 313
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 313
  baud = speed_to_baud(tmp___2);
#line 314
  buffer_put_char(& buf___1, tty_op_ospeed);
#line 315
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 316
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 316
  baud = speed_to_baud(tmp___3);
#line 317
  buffer_put_char(& buf___1, tty_op_ispeed);
#line 318
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 70 "ttymodes.h"
  buffer_put_char(& buf___1, 1);
#line 70
  tmp___4 = special_char_encode(tio.c_cc[0]);
#line 70
  (*put_arg)(& buf___1, tmp___4);
#line 71
  buffer_put_char(& buf___1, 2);
#line 71
  tmp___5 = special_char_encode(tio.c_cc[1]);
#line 71
  (*put_arg)(& buf___1, tmp___5);
#line 72
  buffer_put_char(& buf___1, 3);
#line 72
  tmp___6 = special_char_encode(tio.c_cc[2]);
#line 72
  (*put_arg)(& buf___1, tmp___6);
#line 74
  buffer_put_char(& buf___1, 4);
#line 74
  tmp___7 = special_char_encode(tio.c_cc[3]);
#line 74
  (*put_arg)(& buf___1, tmp___7);
#line 76
  buffer_put_char(& buf___1, 5);
#line 76
  tmp___8 = special_char_encode(tio.c_cc[4]);
#line 76
  (*put_arg)(& buf___1, tmp___8);
#line 78
  buffer_put_char(& buf___1, 6);
#line 78
  tmp___9 = special_char_encode(tio.c_cc[11]);
#line 78
  (*put_arg)(& buf___1, tmp___9);
#line 81
  buffer_put_char(& buf___1, 7);
#line 81
  tmp___10 = special_char_encode(tio.c_cc[16]);
#line 81
  (*put_arg)(& buf___1, tmp___10);
#line 83
  buffer_put_char(& buf___1, 8);
#line 83
  tmp___11 = special_char_encode(tio.c_cc[8]);
#line 83
  (*put_arg)(& buf___1, tmp___11);
#line 84
  buffer_put_char(& buf___1, 9);
#line 84
  tmp___12 = special_char_encode(tio.c_cc[9]);
#line 84
  (*put_arg)(& buf___1, tmp___12);
#line 86
  buffer_put_char(& buf___1, 10);
#line 86
  tmp___13 = special_char_encode(tio.c_cc[10]);
#line 86
  (*put_arg)(& buf___1, tmp___13);
#line 92
  buffer_put_char(& buf___1, 12);
#line 92
  tmp___14 = special_char_encode(tio.c_cc[12]);
#line 92
  (*put_arg)(& buf___1, tmp___14);
#line 95
  buffer_put_char(& buf___1, 13);
#line 95
  tmp___15 = special_char_encode(tio.c_cc[14]);
#line 95
  (*put_arg)(& buf___1, tmp___15);
#line 98
  buffer_put_char(& buf___1, 14);
#line 98
  tmp___16 = special_char_encode(tio.c_cc[15]);
#line 98
  (*put_arg)(& buf___1, tmp___16);
#line 110
  buffer_put_char(& buf___1, 18);
#line 110
  tmp___17 = special_char_encode(tio.c_cc[13]);
#line 110
  (*put_arg)(& buf___1, tmp___17);
#line 114
  buffer_put_char(& buf___1, 30);
#line 114
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4U) != 0U));
#line 115
  buffer_put_char(& buf___1, 31);
#line 115
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8U) != 0U));
#line 116
  buffer_put_char(& buf___1, 32);
#line 116
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 16U) != 0U));
#line 117
  buffer_put_char(& buf___1, 33);
#line 117
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 32U) != 0U));
#line 118
  buffer_put_char(& buf___1, 34);
#line 118
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 64U) != 0U));
#line 119
  buffer_put_char(& buf___1, 35);
#line 119
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 128U) != 0U));
#line 120
  buffer_put_char(& buf___1, 36);
#line 120
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 256U) != 0U));
#line 122
  buffer_put_char(& buf___1, 37);
#line 122
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 512U) != 0U));
#line 124
  buffer_put_char(& buf___1, 38);
#line 124
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 1024U) != 0U));
#line 125
  buffer_put_char(& buf___1, 39);
#line 125
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 2048U) != 0U));
#line 126
  buffer_put_char(& buf___1, 40);
#line 126
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4096U) != 0U));
#line 128
  buffer_put_char(& buf___1, 41);
#line 128
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8192U) != 0U));
#line 131
  buffer_put_char(& buf___1, 50);
#line 131
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 1U) != 0U));
#line 132
  buffer_put_char(& buf___1, 51);
#line 132
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2U) != 0U));
#line 134
  buffer_put_char(& buf___1, 52);
#line 134
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 4U) != 0U));
#line 136
  buffer_put_char(& buf___1, 53);
#line 136
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 8U) != 0U));
#line 137
  buffer_put_char(& buf___1, 54);
#line 137
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16U) != 0U));
#line 138
  buffer_put_char(& buf___1, 55);
#line 138
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32U) != 0U));
#line 139
  buffer_put_char(& buf___1, 56);
#line 139
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 64U) != 0U));
#line 140
  buffer_put_char(& buf___1, 57);
#line 140
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 128U) != 0U));
#line 141
  buffer_put_char(& buf___1, 58);
#line 141
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 256U) != 0U));
#line 143
  buffer_put_char(& buf___1, 59);
#line 143
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32768U) != 0U));
#line 146
  buffer_put_char(& buf___1, 60);
#line 146
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 512U) != 0U));
#line 149
  buffer_put_char(& buf___1, 61);
#line 149
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2048U) != 0U));
#line 152
  buffer_put_char(& buf___1, 62);
#line 152
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16384U) != 0U));
#line 155
  buffer_put_char(& buf___1, 70);
#line 155
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 1U) != 0U));
#line 157
  buffer_put_char(& buf___1, 71);
#line 157
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 2U) != 0U));
#line 160
  buffer_put_char(& buf___1, 72);
#line 160
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 4U) != 0U));
#line 163
  buffer_put_char(& buf___1, 73);
#line 163
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 8U) != 0U));
#line 166
  buffer_put_char(& buf___1, 74);
#line 166
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 16U) != 0U));
#line 169
  buffer_put_char(& buf___1, 75);
#line 169
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 32U) != 0U));
#line 172
  buffer_put_char(& buf___1, 90);
#line 172
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 32U) != 0U));
#line 173
  buffer_put_char(& buf___1, 91);
#line 173
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 48U) != 0U));
#line 174
  buffer_put_char(& buf___1, 92);
#line 174
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 256U) != 0U));
#line 175
  buffer_put_char(& buf___1, 93);
#line 175
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 512U) != 0U));
  end: 
#line 336 "ttymodes.c"
  buffer_put_char(& buf___1, 0);
#line 337
  if (compat20) {
#line 338
    tmp___18 = buffer_len(& buf___1);
#line 338
    tmp___19 = buffer_ptr(& buf___1);
#line 338
    packet_put_string((void const   *)tmp___19, tmp___18);
  } else {
#line 340
    tmp___20 = buffer_len(& buf___1);
#line 340
    tmp___21 = buffer_ptr(& buf___1);
#line 340
    packet_put_raw((void const   *)tmp___21, tmp___20);
  }
#line 341
  buffer_free(& buf___1);
#line 342
  return;
}
}
#line 348 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  u_int (*get_arg)(void) ;
  int arg_size ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  speed_t tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  u_int tmp___56 ;
  u_int tmp___57 ;
  u_int tmp___58 ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
#line 353
  n_bytes = 0;
#line 354
  failure = 0;
#line 358
  if (compat20) {
#line 359
    tmp = packet_get_int();
#line 359
    *n_bytes_ptr = (int )tmp;
#line 360
    if (*n_bytes_ptr == 0) {
#line 361
      return;
    }
#line 362
    get_arg = & packet_get_int;
#line 363
    arg_size = 4;
  } else {
#line 365
    get_arg = & packet_get_char;
#line 366
    arg_size = 1;
  }
#line 374
  tmp___2 = tcgetattr(fd, & tio);
#line 374
  if (tmp___2 == -1) {
#line 375
    tmp___0 = __errno_location();
#line 375
    tmp___1 = strerror(*tmp___0);
#line 375
    logit("tcgetattr: %.100s", tmp___1);
#line 376
    failure = -1;
  }
#line 379
  while (1) {
#line 380
    n_bytes ++;
#line 381
    tmp___3 = packet_get_char();
#line 381
    opcode = (int )tmp___3;
#line 382
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
    case 128: 
#line 389
    n_bytes += 4;
#line 390
    tmp___4 = packet_get_int();
#line 390
    baud = (int )tmp___4;
#line 391
    if (failure != -1) {
#line 391
      tmp___5 = baud_to_speed(baud);
#line 391
      tmp___6 = cfsetispeed(& tio, tmp___5);
#line 391
      if (tmp___6 == -1) {
#line 393
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 394
    break;
    case 193: 
    case 129: 
#line 399
    n_bytes += 4;
#line 400
    tmp___7 = packet_get_int();
#line 400
    baud = (int )tmp___7;
#line 401
    if (failure != -1) {
#line 401
      tmp___8 = baud_to_speed(baud);
#line 401
      tmp___9 = cfsetospeed(& tio, tmp___8);
#line 401
      if (tmp___9 == -1) {
#line 403
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 404
    break;
    case 1: 
#line 70 "ttymodes.h"
    n_bytes += arg_size;
#line 70
    tmp___10 = (*get_arg)();
#line 70
    tio.c_cc[0] = special_char_decode(tmp___10);
#line 70
    break;
    case 2: 
#line 71
    n_bytes += arg_size;
#line 71
    tmp___11 = (*get_arg)();
#line 71
    tio.c_cc[1] = special_char_decode(tmp___11);
#line 71
    break;
    case 3: 
#line 72
    n_bytes += arg_size;
#line 72
    tmp___12 = (*get_arg)();
#line 72
    tio.c_cc[2] = special_char_decode(tmp___12);
#line 72
    break;
    case 4: 
#line 74
    n_bytes += arg_size;
#line 74
    tmp___13 = (*get_arg)();
#line 74
    tio.c_cc[3] = special_char_decode(tmp___13);
#line 74
    break;
    case 5: 
#line 76
    n_bytes += arg_size;
#line 76
    tmp___14 = (*get_arg)();
#line 76
    tio.c_cc[4] = special_char_decode(tmp___14);
#line 76
    break;
    case 6: 
#line 78
    n_bytes += arg_size;
#line 78
    tmp___15 = (*get_arg)();
#line 78
    tio.c_cc[11] = special_char_decode(tmp___15);
#line 78
    break;
    case 7: 
#line 81
    n_bytes += arg_size;
#line 81
    tmp___16 = (*get_arg)();
#line 81
    tio.c_cc[16] = special_char_decode(tmp___16);
#line 81
    break;
    case 8: 
#line 83
    n_bytes += arg_size;
#line 83
    tmp___17 = (*get_arg)();
#line 83
    tio.c_cc[8] = special_char_decode(tmp___17);
#line 83
    break;
    case 9: 
#line 84
    n_bytes += arg_size;
#line 84
    tmp___18 = (*get_arg)();
#line 84
    tio.c_cc[9] = special_char_decode(tmp___18);
#line 84
    break;
    case 10: 
#line 86
    n_bytes += arg_size;
#line 86
    tmp___19 = (*get_arg)();
#line 86
    tio.c_cc[10] = special_char_decode(tmp___19);
#line 86
    break;
    case 12: 
#line 92
    n_bytes += arg_size;
#line 92
    tmp___20 = (*get_arg)();
#line 92
    tio.c_cc[12] = special_char_decode(tmp___20);
#line 92
    break;
    case 13: 
#line 95
    n_bytes += arg_size;
#line 95
    tmp___21 = (*get_arg)();
#line 95
    tio.c_cc[14] = special_char_decode(tmp___21);
#line 95
    break;
    case 14: 
#line 98
    n_bytes += arg_size;
#line 98
    tmp___22 = (*get_arg)();
#line 98
    tio.c_cc[15] = special_char_decode(tmp___22);
#line 98
    break;
    case 18: 
#line 110
    n_bytes += arg_size;
#line 110
    tmp___23 = (*get_arg)();
#line 110
    tio.c_cc[13] = special_char_decode(tmp___23);
#line 110
    break;
    case 30: 
#line 114
    n_bytes += arg_size;
#line 114
    tmp___24 = (*get_arg)();
#line 114
    if (tmp___24) {
#line 114
      tio.c_iflag |= 4U;
    } else {
#line 114
      tio.c_iflag &= 4294967291U;
    }
#line 114
    break;
    case 31: 
#line 115
    n_bytes += arg_size;
#line 115
    tmp___25 = (*get_arg)();
#line 115
    if (tmp___25) {
#line 115
      tio.c_iflag |= 8U;
    } else {
#line 115
      tio.c_iflag &= 4294967287U;
    }
#line 115
    break;
    case 32: 
#line 116
    n_bytes += arg_size;
#line 116
    tmp___26 = (*get_arg)();
#line 116
    if (tmp___26) {
#line 116
      tio.c_iflag |= 16U;
    } else {
#line 116
      tio.c_iflag &= 4294967279U;
    }
#line 116
    break;
    case 33: 
#line 117
    n_bytes += arg_size;
#line 117
    tmp___27 = (*get_arg)();
#line 117
    if (tmp___27) {
#line 117
      tio.c_iflag |= 32U;
    } else {
#line 117
      tio.c_iflag &= 4294967263U;
    }
#line 117
    break;
    case 34: 
#line 118
    n_bytes += arg_size;
#line 118
    tmp___28 = (*get_arg)();
#line 118
    if (tmp___28) {
#line 118
      tio.c_iflag |= 64U;
    } else {
#line 118
      tio.c_iflag &= 4294967231U;
    }
#line 118
    break;
    case 35: 
#line 119
    n_bytes += arg_size;
#line 119
    tmp___29 = (*get_arg)();
#line 119
    if (tmp___29) {
#line 119
      tio.c_iflag |= 128U;
    } else {
#line 119
      tio.c_iflag &= 4294967167U;
    }
#line 119
    break;
    case 36: 
#line 120
    n_bytes += arg_size;
#line 120
    tmp___30 = (*get_arg)();
#line 120
    if (tmp___30) {
#line 120
      tio.c_iflag |= 256U;
    } else {
#line 120
      tio.c_iflag &= 4294967039U;
    }
#line 120
    break;
    case 37: 
#line 122
    n_bytes += arg_size;
#line 122
    tmp___31 = (*get_arg)();
#line 122
    if (tmp___31) {
#line 122
      tio.c_iflag |= 512U;
    } else {
#line 122
      tio.c_iflag &= 4294966783U;
    }
#line 122
    break;
    case 38: 
#line 124
    n_bytes += arg_size;
#line 124
    tmp___32 = (*get_arg)();
#line 124
    if (tmp___32) {
#line 124
      tio.c_iflag |= 1024U;
    } else {
#line 124
      tio.c_iflag &= 4294966271U;
    }
#line 124
    break;
    case 39: 
#line 125
    n_bytes += arg_size;
#line 125
    tmp___33 = (*get_arg)();
#line 125
    if (tmp___33) {
#line 125
      tio.c_iflag |= 2048U;
    } else {
#line 125
      tio.c_iflag &= 4294965247U;
    }
#line 125
    break;
    case 40: 
#line 126
    n_bytes += arg_size;
#line 126
    tmp___34 = (*get_arg)();
#line 126
    if (tmp___34) {
#line 126
      tio.c_iflag |= 4096U;
    } else {
#line 126
      tio.c_iflag &= 4294963199U;
    }
#line 126
    break;
    case 41: 
#line 128
    n_bytes += arg_size;
#line 128
    tmp___35 = (*get_arg)();
#line 128
    if (tmp___35) {
#line 128
      tio.c_iflag |= 8192U;
    } else {
#line 128
      tio.c_iflag &= 4294959103U;
    }
#line 128
    break;
    case 50: 
#line 131
    n_bytes += arg_size;
#line 131
    tmp___36 = (*get_arg)();
#line 131
    if (tmp___36) {
#line 131
      tio.c_lflag |= 1U;
    } else {
#line 131
      tio.c_lflag &= 4294967294U;
    }
#line 131
    break;
    case 51: 
#line 132
    n_bytes += arg_size;
#line 132
    tmp___37 = (*get_arg)();
#line 132
    if (tmp___37) {
#line 132
      tio.c_lflag |= 2U;
    } else {
#line 132
      tio.c_lflag &= 4294967293U;
    }
#line 132
    break;
    case 52: 
#line 134
    n_bytes += arg_size;
#line 134
    tmp___38 = (*get_arg)();
#line 134
    if (tmp___38) {
#line 134
      tio.c_lflag |= 4U;
    } else {
#line 134
      tio.c_lflag &= 4294967291U;
    }
#line 134
    break;
    case 53: 
#line 136
    n_bytes += arg_size;
#line 136
    tmp___39 = (*get_arg)();
#line 136
    if (tmp___39) {
#line 136
      tio.c_lflag |= 8U;
    } else {
#line 136
      tio.c_lflag &= 4294967287U;
    }
#line 136
    break;
    case 54: 
#line 137
    n_bytes += arg_size;
#line 137
    tmp___40 = (*get_arg)();
#line 137
    if (tmp___40) {
#line 137
      tio.c_lflag |= 16U;
    } else {
#line 137
      tio.c_lflag &= 4294967279U;
    }
#line 137
    break;
    case 55: 
#line 138
    n_bytes += arg_size;
#line 138
    tmp___41 = (*get_arg)();
#line 138
    if (tmp___41) {
#line 138
      tio.c_lflag |= 32U;
    } else {
#line 138
      tio.c_lflag &= 4294967263U;
    }
#line 138
    break;
    case 56: 
#line 139
    n_bytes += arg_size;
#line 139
    tmp___42 = (*get_arg)();
#line 139
    if (tmp___42) {
#line 139
      tio.c_lflag |= 64U;
    } else {
#line 139
      tio.c_lflag &= 4294967231U;
    }
#line 139
    break;
    case 57: 
#line 140
    n_bytes += arg_size;
#line 140
    tmp___43 = (*get_arg)();
#line 140
    if (tmp___43) {
#line 140
      tio.c_lflag |= 128U;
    } else {
#line 140
      tio.c_lflag &= 4294967167U;
    }
#line 140
    break;
    case 58: 
#line 141
    n_bytes += arg_size;
#line 141
    tmp___44 = (*get_arg)();
#line 141
    if (tmp___44) {
#line 141
      tio.c_lflag |= 256U;
    } else {
#line 141
      tio.c_lflag &= 4294967039U;
    }
#line 141
    break;
    case 59: 
#line 143
    n_bytes += arg_size;
#line 143
    tmp___45 = (*get_arg)();
#line 143
    if (tmp___45) {
#line 143
      tio.c_lflag |= 32768U;
    } else {
#line 143
      tio.c_lflag &= 4294934527U;
    }
#line 143
    break;
    case 60: 
#line 146
    n_bytes += arg_size;
#line 146
    tmp___46 = (*get_arg)();
#line 146
    if (tmp___46) {
#line 146
      tio.c_lflag |= 512U;
    } else {
#line 146
      tio.c_lflag &= 4294966783U;
    }
#line 146
    break;
    case 61: 
#line 149
    n_bytes += arg_size;
#line 149
    tmp___47 = (*get_arg)();
#line 149
    if (tmp___47) {
#line 149
      tio.c_lflag |= 2048U;
    } else {
#line 149
      tio.c_lflag &= 4294965247U;
    }
#line 149
    break;
    case 62: 
#line 152
    n_bytes += arg_size;
#line 152
    tmp___48 = (*get_arg)();
#line 152
    if (tmp___48) {
#line 152
      tio.c_lflag |= 16384U;
    } else {
#line 152
      tio.c_lflag &= 4294950911U;
    }
#line 152
    break;
    case 70: 
#line 155
    n_bytes += arg_size;
#line 155
    tmp___49 = (*get_arg)();
#line 155
    if (tmp___49) {
#line 155
      tio.c_oflag |= 1U;
    } else {
#line 155
      tio.c_oflag &= 4294967294U;
    }
#line 155
    break;
    case 71: 
#line 157
    n_bytes += arg_size;
#line 157
    tmp___50 = (*get_arg)();
#line 157
    if (tmp___50) {
#line 157
      tio.c_oflag |= 2U;
    } else {
#line 157
      tio.c_oflag &= 4294967293U;
    }
#line 157
    break;
    case 72: 
#line 160
    n_bytes += arg_size;
#line 160
    tmp___51 = (*get_arg)();
#line 160
    if (tmp___51) {
#line 160
      tio.c_oflag |= 4U;
    } else {
#line 160
      tio.c_oflag &= 4294967291U;
    }
#line 160
    break;
    case 73: 
#line 163
    n_bytes += arg_size;
#line 163
    tmp___52 = (*get_arg)();
#line 163
    if (tmp___52) {
#line 163
      tio.c_oflag |= 8U;
    } else {
#line 163
      tio.c_oflag &= 4294967287U;
    }
#line 163
    break;
    case 74: 
#line 166
    n_bytes += arg_size;
#line 166
    tmp___53 = (*get_arg)();
#line 166
    if (tmp___53) {
#line 166
      tio.c_oflag |= 16U;
    } else {
#line 166
      tio.c_oflag &= 4294967279U;
    }
#line 166
    break;
    case 75: 
#line 169
    n_bytes += arg_size;
#line 169
    tmp___54 = (*get_arg)();
#line 169
    if (tmp___54) {
#line 169
      tio.c_oflag |= 32U;
    } else {
#line 169
      tio.c_oflag &= 4294967263U;
    }
#line 169
    break;
    case 90: 
#line 172
    n_bytes += arg_size;
#line 172
    tmp___55 = (*get_arg)();
#line 172
    if (tmp___55) {
#line 172
      tio.c_cflag |= 32U;
    } else {
#line 172
      tio.c_cflag &= 4294967263U;
    }
#line 172
    break;
    case 91: 
#line 173
    n_bytes += arg_size;
#line 173
    tmp___56 = (*get_arg)();
#line 173
    if (tmp___56) {
#line 173
      tio.c_cflag |= 48U;
    } else {
#line 173
      tio.c_cflag &= 4294967247U;
    }
#line 173
    break;
    case 92: 
#line 174
    n_bytes += arg_size;
#line 174
    tmp___57 = (*get_arg)();
#line 174
    if (tmp___57) {
#line 174
      tio.c_cflag |= 256U;
    } else {
#line 174
      tio.c_cflag &= 4294967039U;
    }
#line 174
    break;
    case 93: 
#line 175
    n_bytes += arg_size;
#line 175
    tmp___58 = (*get_arg)();
#line 175
    if (tmp___58) {
#line 175
      tio.c_cflag |= 512U;
    } else {
#line 175
      tio.c_cflag &= 4294966783U;
    }
#line 175
    break;
    default: 
#line 426 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 428
    if (! compat20) {
#line 436
      if (opcode > 0) {
#line 436
        if (opcode < 128) {
#line 437
          n_bytes ++;
#line 438
          packet_get_char();
#line 439
          break;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 440
        if (opcode >= 128) {
#line 440
          if (opcode < 160) {
#line 441
            n_bytes += 4;
#line 442
            packet_get_int();
#line 443
            break;
          } else {
#line 452
            logit("parse_tty_modes: unknown opcode %d", opcode);
            goto set;
          }
        } else {
#line 452
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      }
    } else {
#line 464
      if (opcode > 0) {
#line 464
        if (opcode < 160) {
#line 465
          n_bytes += 4;
#line 466
          packet_get_int();
#line 467
          break;
        } else {
#line 469
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      } else {
#line 469
        logit("parse_tty_modes: unknown opcode %d", opcode);
        goto set;
      }
    }
    }
  }
  set: 
#line 478
  if (*n_bytes_ptr != n_bytes) {
#line 479
    *n_bytes_ptr = n_bytes;
#line 480
    logit("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d", *n_bytes_ptr, n_bytes);
#line 482
    return;
  }
#line 484
  if (failure == -1) {
#line 485
    return;
  }
#line 488
  tmp___61 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 488
  if (tmp___61 == -1) {
#line 489
    tmp___59 = __errno_location();
#line 489
    tmp___60 = strerror(*tmp___59);
#line 489
    logit("Setting tty modes failed: %.100s", tmp___60);
  }
#line 490
  return;
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"./xmalloc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 370 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 24 "xmalloc.h"
int ( /* format attribute */  xasprintf)(char **ret___0 , char const   *fmt  , ...)  __attribute__((__nonnull__(2))) ;
#line 27 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 32
  if (size == 0U) {
#line 33
    fatal("xmalloc: zero size");
  }
#line 34
  ptr = malloc(size);
#line 35
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 36
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 37
  return (ptr);
}
}
#line 40 "xmalloc.c"
void *xcalloc(size_t nmemb , size_t size ) 
{ void *ptr ;

  {
#line 45
  if (size == 0U) {
#line 46
    fatal("xcalloc: zero size");
  } else {
#line 45
    if (nmemb == 0U) {
#line 46
      fatal("xcalloc: zero size");
    }
  }
#line 47
  if (4294967295UL / (unsigned long )nmemb < (unsigned long )size) {
#line 48
    fatal("xcalloc: nmemb * size > SIZE_T_MAX");
  }
#line 49
  ptr = calloc(nmemb, size);
#line 50
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 51
    fatal("xcalloc: out of memory (allocating %lu bytes)", (unsigned long )(size * nmemb));
  }
#line 53
  return (ptr);
}
}
#line 56 "xmalloc.c"
void *xrealloc(void *ptr , size_t nmemb , size_t size ) 
{ void *new_ptr ;
  size_t new_size ;

  {
#line 60
  new_size = nmemb * size;
#line 62
  if (new_size == 0U) {
#line 63
    fatal("xrealloc: zero size");
  }
#line 64
  if (4294967295UL / (unsigned long )nmemb < (unsigned long )size) {
#line 65
    fatal("xrealloc: nmemb * size > SIZE_T_MAX");
  }
#line 66
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 67
    new_ptr = malloc(new_size);
  } else {
#line 69
    new_ptr = realloc(ptr, new_size);
  }
#line 70
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 71
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 73
  return (new_ptr);
}
}
#line 76 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 79
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 80
    fatal("xfree: NULL pointer given as argument");
  }
#line 81
  free(ptr);
#line 82
  return;
}
}
#line 84 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 90
  tmp = strlen(str);
#line 90
  len = tmp + 1U;
#line 91
  tmp___0 = xmalloc(len);
#line 91
  cp = (char *)tmp___0;
#line 92
  strlcpy(cp, str, len);
#line 93
  return (cp);
}
}
#line 96
int ( /* format attribute */  xasprintf)(char **ret___0 , char const   *fmt  , ...)  __attribute__((__nonnull__(2))) ;
#line 96 "xmalloc.c"
int ( /* format attribute */  xasprintf)(char **ret___0 , char const   *fmt  , ...) 
{ va_list ap ;
  int i ;

  {
#line 102
  __builtin_va_start(ap, fmt);
#line 103
  i = vasprintf((char ** __restrict  )ret___0, (char const   * __restrict  )fmt, ap);
#line 104
  __builtin_va_end(ap);
#line 106
  if (i < 0) {
#line 107
    fatal("xasprintf: could not allocate memory");
  } else {
#line 106
    if ((unsigned int )*ret___0 == (unsigned int )((void *)0)) {
#line 107
      fatal("xasprintf: could not allocate memory");
    }
  }
#line 109
  return (i);
}
}
#line 1 "addrmatch.o"
#pragma merger(0,"./addrmatch.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 188 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 51 "addrmatch.c"
static int addr_unicast_masklen(int af ) 
{ 

  {
#line 54
  switch (af) {
  case 2: 
#line 56
  return (32);
  case 10: 
#line 58
  return (128);
  default: ;
#line 60
  return (-1);
  }
}
}
#line 64 "addrmatch.c"
__inline static int masklen_valid(int af , u_int masklen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 67
  switch (af) {
  case 2: 
#line 69
  if (masklen <= 32U) {
#line 69
    tmp = 0;
  } else {
#line 69
    tmp = -1;
  }
#line 69
  return (tmp);
  case 10: 
#line 71
  if (masklen <= 128U) {
#line 71
    tmp___0 = 0;
  } else {
#line 71
    tmp___0 = -1;
  }
#line 71
  return (tmp___0);
  default: ;
#line 73
  return (-1);
  }
}
}
#line 81 "addrmatch.c"
static int addr_sa_to_xaddr(struct sockaddr *sa , socklen_t slen , struct xaddr *xa ) 
{ struct sockaddr_in *in4 ;
  struct sockaddr_in6 *in6 ;

  {
#line 84
  in4 = (struct sockaddr_in *)sa;
#line 85
  in6 = (struct sockaddr_in6 *)sa;
#line 87
  memset((void *)xa, '\000', sizeof(*xa));
#line 89
  switch ((int )sa->sa_family) {
  case 2: 
#line 91
  if (slen < sizeof(*in4)) {
#line 92
    return (-1);
  }
#line 93
  xa->af = (unsigned short)2;
#line 94
  memcpy((void * __restrict  )(& xa->xa.v4), (void const   * __restrict  )(& in4->sin_addr),
         sizeof(xa->xa.v4));
#line 95
  break;
  case 10: 
#line 97
  if (slen < sizeof(*in6)) {
#line 98
    return (-1);
  }
#line 99
  xa->af = (unsigned short)10;
#line 100
  memcpy((void * __restrict  )(& xa->xa.v6), (void const   * __restrict  )(& in6->sin6_addr),
         sizeof(xa->xa.v6));
#line 102
  xa->scope_id = in6->sin6_scope_id;
#line 104
  break;
  default: ;
#line 106
  return (-1);
  }
#line 109
  return (0);
}
}
#line 117 "addrmatch.c"
static int addr_netmask(int af , u_int l , struct xaddr *n___0 ) 
{ int i ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;

  {
#line 122
  tmp = masklen_valid(af, l);
#line 122
  if (tmp != 0) {
#line 123
    return (-1);
  } else {
#line 122
    if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 123
      return (-1);
    }
  }
#line 125
  memset((void *)n___0, '\000', sizeof(*n___0));
#line 126
  switch (af) {
  case 2: 
#line 128
  n___0->af = (unsigned short)2;
#line 129
  __x = (4294967295U << (32U - l)) & 4294967295U;
#line 129
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 129
  n___0->xa.v4.s_addr = __v;
#line 130
  return (0);
  case 10: 
#line 132
  n___0->af = (unsigned short)10;
#line 133
  i = 0;
#line 133
  while (1) {
#line 133
    if (i < 4) {
#line 133
      if (! (l >= 32U)) {
#line 133
        break;
      }
    } else {
#line 133
      break;
    }
#line 134
    n___0->xa.addr32[i] = 4294967295U;
#line 133
    i ++;
#line 133
    l -= 32U;
  }
#line 135
  if (i < 4) {
#line 135
    if (l != 0U) {
#line 136
      __x___0 = (4294967295U << (32U - l)) & 4294967295U;
#line 136
      __asm__  ("rorw $8, %w0;"
                "rorl $16, %0;"
                "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 136
      n___0->xa.addr32[i] = __v___0;
    }
  }
#line 138
  return (0);
  default: ;
#line 140
  return (-1);
  }
}
}
#line 148 "addrmatch.c"
static int addr_and(struct xaddr *dst , struct xaddr  const  *a___0 , struct xaddr  const  *b ) 
{ int i ;

  {
#line 153
  if ((unsigned int )dst == (unsigned int )((void *)0)) {
#line 154
    return (-1);
  } else {
#line 153
    if ((unsigned int )a___0 == (unsigned int )((void *)0)) {
#line 154
      return (-1);
    } else {
#line 153
      if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 154
        return (-1);
      } else {
#line 153
        if ((int const   )a___0->af != (int const   )b->af) {
#line 154
          return (-1);
        }
      }
    }
  }
#line 156
  memcpy((void * __restrict  )dst, (void const   * __restrict  )a___0, sizeof(*dst));
#line 157
  switch ((int )a___0->af) {
  case 2: 
#line 159
  dst->xa.v4.s_addr &= (unsigned int )b->xa.v4.s_addr;
#line 160
  return (0);
  case 10: 
#line 162
  dst->scope_id = (unsigned int )a___0->scope_id;
#line 163
  i = 0;
#line 163
  while (i < 4) {
#line 164
    dst->xa.addr32[i] &= b->xa.addr32[i];
#line 163
    i ++;
  }
#line 165
  return (0);
  default: ;
#line 167
  return (-1);
  }
}
}
#line 175 "addrmatch.c"
static int addr_cmp(struct xaddr  const  *a___0 , struct xaddr  const  *b ) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  register unsigned int __v___1 ;
  register unsigned int __x___1 ;
  register unsigned int __v___2 ;
  register unsigned int __x___2 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 180
  if ((int const   )a___0->af != (int const   )b->af) {
#line 181
    if ((int const   )a___0->af == 10) {
#line 181
      tmp = 1;
    } else {
#line 181
      tmp = -1;
    }
#line 181
    return (tmp);
  }
#line 183
  switch ((int )a___0->af) {
  case 2: 
#line 185
  if (a___0->xa.v4.s_addr == b->xa.v4.s_addr) {
#line 186
    return (0);
  }
#line 187
  __x___1 = (unsigned int )a___0->xa.v4.s_addr;
#line 187
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 187
  __x___2 = (unsigned int )b->xa.v4.s_addr;
#line 187
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v___2): "0" (__x___2): "cc");
#line 187
  if (__v___1 > __v___2) {
#line 187
    tmp___0 = 1;
  } else {
#line 187
    tmp___0 = -1;
  }
#line 187
  return (tmp___0);
  case 10: 
#line 189
  i = 0;
#line 189
  while (i < 16) {
#line 190
    if ((int )a___0->xa.addr8[i] - (int )b->xa.addr8[i] != 0) {
#line 191
      if ((int )a___0->xa.addr8[i] > (int )b->xa.addr8[i]) {
#line 191
        tmp___1 = 1;
      } else {
#line 191
        tmp___1 = -1;
      }
#line 191
      return (tmp___1);
    }
#line 189
    i ++;
  }
#line 192
  if (a___0->scope_id == b->scope_id) {
#line 193
    return (0);
  }
#line 194
  if (a___0->scope_id > b->scope_id) {
#line 194
    tmp___2 = 1;
  } else {
#line 194
    tmp___2 = -1;
  }
#line 194
  return (tmp___2);
  default: ;
#line 196
  return (-1);
  }
}
}
#line 204 "addrmatch.c"
static int addr_pton(char const   *p , struct xaddr *n___0 ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  int tmp ;
  int tmp___0 ;

  {
#line 209
  memset((void *)(& hints), '\000', sizeof(hints));
#line 210
  hints.ai_flags = 4;
#line 212
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 213
    return (-1);
  } else {
#line 212
    tmp = getaddrinfo((char const   * __restrict  )p, (char const   * __restrict  )((void *)0),
                      (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 212
    if (tmp != 0) {
#line 213
      return (-1);
    }
  }
#line 215
  if ((unsigned int )ai == (unsigned int )((void *)0)) {
#line 216
    return (-1);
  } else {
#line 215
    if ((unsigned int )ai->ai_addr == (unsigned int )((void *)0)) {
#line 216
      return (-1);
    }
  }
#line 218
  if ((unsigned int )n___0 != (unsigned int )((void *)0)) {
#line 218
    tmp___0 = addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen, n___0);
#line 218
    if (tmp___0 == -1) {
#line 220
      freeaddrinfo(ai);
#line 221
      return (-1);
    }
  }
#line 224
  freeaddrinfo(ai);
#line 225
  return (0);
}
}
#line 232 "addrmatch.c"
static int addr_invert(struct xaddr *n___0 ) 
{ int i ;

  {
#line 237
  if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 238
    return (-1);
  }
#line 240
  switch ((int )n___0->af) {
  case 2: 
#line 242
  n___0->xa.v4.s_addr = ~ n___0->xa.v4.s_addr;
#line 243
  return (0);
  case 10: 
#line 245
  i = 0;
#line 245
  while (i < 4) {
#line 246
    n___0->xa.addr32[i] = ~ n___0->xa.addr32[i];
#line 245
    i ++;
  }
#line 247
  return (0);
  default: ;
#line 249
  return (-1);
  }
}
}
#line 258 "addrmatch.c"
static int addr_hostmask(int af , u_int l , struct xaddr *n___0 ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 261
  tmp = addr_netmask(af, l, n___0);
#line 261
  if (tmp == -1) {
#line 262
    return (-1);
  } else {
#line 261
    tmp___0 = addr_invert(n___0);
#line 261
    if (tmp___0 == -1) {
#line 262
      return (-1);
    }
  }
#line 263
  return (0);
}
}
#line 270 "addrmatch.c"
static int addr_is_all0s(struct xaddr  const  *a___0 ) 
{ int i ;
  int tmp ;

  {
#line 275
  switch ((int )a___0->af) {
  case 2: 
#line 277
  if (a___0->xa.v4.s_addr == 0U) {
#line 277
    tmp = 0;
  } else {
#line 277
    tmp = -1;
  }
#line 277
  return (tmp);
  case 10: 
#line 279
  i = 0;
#line 279
  while (i < 4) {
#line 280
    if (a___0->xa.addr32[i] != 0U) {
#line 281
      return (-1);
    }
#line 279
    i ++;
  }
#line 282
  return (0);
  default: ;
#line 284
  return (-1);
  }
}
}
#line 294 "addrmatch.c"
static int addr_host_is_all0s(struct xaddr  const  *a___0 , u_int masklen ) 
{ struct xaddr tmp_addr ;
  struct xaddr tmp_mask ;
  struct xaddr tmp_result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 299
  memcpy((void * __restrict  )(& tmp_addr), (void const   * __restrict  )a___0, sizeof(tmp_addr));
#line 300
  tmp = addr_hostmask((int )a___0->af, masklen, & tmp_mask);
#line 300
  if (tmp == -1) {
#line 301
    return (-1);
  }
#line 302
  tmp___0 = addr_and(& tmp_result, (struct xaddr  const  *)(& tmp_addr), (struct xaddr  const  *)(& tmp_mask));
#line 302
  if (tmp___0 == -1) {
#line 303
    return (-1);
  }
#line 304
  tmp___1 = addr_is_all0s((struct xaddr  const  *)(& tmp_result));
#line 304
  return (tmp___1);
}
}
#line 311 "addrmatch.c"
static int addr_pton_cidr(char const   *p , struct xaddr *n___0 , u_int *l ) 
{ struct xaddr tmp ;
  unsigned long masklen ;
  char addrbuf[64] ;
  char *mp ;
  char *cp ;
  size_t tmp___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 315
  masklen = 999UL;
#line 319
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 320
    return (-1);
  } else {
#line 319
    tmp___0 = strlcpy(addrbuf, p, sizeof(addrbuf));
#line 319
    if (tmp___0 > sizeof(addrbuf)) {
#line 320
      return (-1);
    }
  }
#line 322
  tmp___2 = __builtin_strchr(addrbuf, '/');
#line 322
  mp = tmp___2;
#line 322
  if ((unsigned int )mp != (unsigned int )((void *)0)) {
#line 323
    *mp = (char )'\000';
#line 324
    mp ++;
#line 325
    masklen = strtoul((char const   * __restrict  )mp, (char ** __restrict  )(& cp),
                      10);
#line 326
    if ((int )*mp == 0) {
#line 327
      return (-1);
    } else {
#line 326
      if ((int )*cp != 0) {
#line 327
        return (-1);
      } else {
#line 326
        if (masklen > 128UL) {
#line 327
          return (-1);
        }
      }
    }
  }
#line 330
  tmp___3 = addr_pton((char const   *)(addrbuf), & tmp);
#line 330
  if (tmp___3 == -1) {
#line 331
    return (-1);
  }
#line 333
  if ((unsigned int )mp == (unsigned int )((void *)0)) {
#line 334
    tmp___4 = addr_unicast_masklen((int )tmp.af);
#line 334
    masklen = (unsigned long )tmp___4;
  }
#line 335
  tmp___5 = masklen_valid((int )tmp.af, (unsigned int )masklen);
#line 335
  if (tmp___5 == -1) {
#line 336
    return (-2);
  }
#line 337
  tmp___6 = addr_host_is_all0s((struct xaddr  const  *)(& tmp), (unsigned int )masklen);
#line 337
  if (tmp___6 != 0) {
#line 338
    return (-2);
  }
#line 340
  if ((unsigned int )n___0 != (unsigned int )((void *)0)) {
#line 341
    memcpy((void * __restrict  )n___0, (void const   * __restrict  )(& tmp), sizeof(*n___0));
  }
#line 342
  if ((unsigned int )l != (unsigned int )((void *)0)) {
#line 343
    *l = (unsigned int )masklen;
  }
#line 345
  return (0);
}
}
#line 348 "addrmatch.c"
static int addr_netmatch(struct xaddr  const  *host , struct xaddr  const  *net ,
                         u_int masklen ) 
{ struct xaddr tmp_mask ;
  struct xaddr tmp_result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 353
  if ((int const   )host->af != (int const   )net->af) {
#line 354
    return (-1);
  }
#line 356
  tmp = addr_netmask((int )host->af, masklen, & tmp_mask);
#line 356
  if (tmp == -1) {
#line 357
    return (-1);
  }
#line 358
  tmp___0 = addr_and(& tmp_result, host, (struct xaddr  const  *)(& tmp_mask));
#line 358
  if (tmp___0 == -1) {
#line 359
    return (-1);
  }
#line 360
  tmp___1 = addr_cmp((struct xaddr  const  *)(& tmp_result), net);
#line 360
  return (tmp___1);
}
}
#line 375 "addrmatch.c"
int addr_match_list(char const   *addr , char const   *_list ) 
{ char *list ;
  char *cp ;
  char *o ;
  struct xaddr try_addr ;
  struct xaddr match_addr ;
  u_int masklen ;
  u_int neg ;
  int ret___0 ;
  int r ;
  int tmp ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___27 ;

  {
#line 381
  ret___0 = 0;
#line 383
  if ((unsigned int )addr != (unsigned int )((void *)0)) {
#line 383
    tmp = addr_pton(addr, & try_addr);
#line 383
    if (tmp != 0) {
#line 384
      debug2("%s: couldn\'t parse address %.100s", "addr_match_list", addr);
#line 385
      return (0);
    }
  }
#line 387
  tmp___9 = __strdup(_list);
#line 387
  list = tmp___9;
#line 387
  o = list;
#line 387
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 388
    return (-1);
  }
#line 389
  while (1) {
#line 389
    tmp___27 = __strsep_g(& list, ",");
#line 389
    cp = tmp___27;
#line 389
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 389
      break;
    }
#line 390
    neg = (unsigned int )((int )*cp == 33);
#line 391
    if (neg) {
#line 392
      cp ++;
    }
#line 393
    if ((int )*cp == 0) {
#line 394
      ret___0 = -2;
#line 395
      break;
    }
#line 398
    r = addr_pton_cidr((char const   *)cp, & match_addr, & masklen);
#line 399
    if (r == -2) {
#line 400
      error("Inconsistent mask length for network \"%.100s\"", cp);
#line 402
      ret___0 = -2;
#line 403
      break;
    } else {
#line 404
      if (r == 0) {
#line 405
        if ((unsigned int )addr != (unsigned int )((void *)0)) {
#line 405
          tmp___10 = addr_netmatch((struct xaddr  const  *)(& try_addr), (struct xaddr  const  *)(& match_addr),
                                   masklen);
#line 405
          if (tmp___10 == 0) {
            foundit: 
#line 408
            if (neg) {
#line 409
              ret___0 = -1;
#line 410
              break;
            }
#line 412
            ret___0 = 1;
          }
        }
#line 414
        continue;
      } else {
#line 417
        if ((unsigned int )addr != (unsigned int )((void *)0)) {
#line 417
          tmp___11 = match_pattern(addr, (char const   *)cp);
#line 417
          if (tmp___11 == 1) {
            goto foundit;
          }
        }
      }
    }
  }
#line 421
  xfree((void *)o);
#line 423
  return (ret___0);
}
}
#line 1 "atomicio.o"
#pragma merger(0,"./atomicio.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 40 "/usr/include/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 58 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 42 "atomicio.h"
size_t atomiciov(ssize_t (*f)(int  , struct iovec  const  * , int  ) , int fd , struct iovec  const  *_iov ,
                 int iovcnt ) ;
#line 50 "atomicio.c"
size_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  size_t pos ;
  ssize_t res ;
  struct pollfd pfd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 53
  s = (char *)_s;
#line 54
  pos = (size_t )0;
#line 58
  pfd.fd = fd;
#line 59
  if ((unsigned int )f == (unsigned int )(& read)) {
#line 59
    pfd.events = (short)1;
  } else {
#line 59
    pfd.events = (short)4;
  }
#line 60
  while (n___0 > pos) {
#line 61
    res = (*f)(fd, (void *)(s + pos), n___0 - pos);
#line 62
    switch (res) {
    case -1: 
#line 64
    tmp = __errno_location();
#line 64
    if (*tmp == 4) {
#line 65
      continue;
    }
#line 66
    tmp___0 = __errno_location();
#line 66
    if (*tmp___0 == 11) {
#line 67
      poll(& pfd, 1UL, -1);
#line 68
      continue;
    } else {
#line 66
      tmp___1 = __errno_location();
#line 66
      if (*tmp___1 == 11) {
#line 67
        poll(& pfd, 1UL, -1);
#line 68
        continue;
      }
    }
#line 70
    return (0U);
    case 0: 
#line 72
    tmp___2 = __errno_location();
#line 72
    *tmp___2 = 32;
#line 73
    return (pos);
    default: 
#line 75
    pos += (unsigned int )res;
    }
  }
#line 78
  return (pos);
}
}
#line 84 "atomicio.c"
size_t atomiciov(ssize_t (*f)(int  , struct iovec  const  * , int  ) , int fd , struct iovec  const  *_iov ,
                 int iovcnt ) 
{ size_t pos ;
  size_t rem ;
  ssize_t res ;
  struct iovec iov_array[1024] ;
  struct iovec *iov ;
  struct pollfd pfd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 88
  pos = (size_t )0;
#line 90
  iov = iov_array;
#line 93
  if (iovcnt > 1024) {
#line 94
    tmp = __errno_location();
#line 94
    *tmp = 22;
#line 95
    return (0U);
  }
#line 98
  memcpy((void * __restrict  )iov, (void const   * __restrict  )_iov, (unsigned int )iovcnt * sizeof(*_iov));
#line 101
  pfd.fd = fd;
#line 102
  if ((unsigned int )f == (unsigned int )(& readv)) {
#line 102
    pfd.events = (short)1;
  } else {
#line 102
    pfd.events = (short)4;
  }
#line 104
  while (1) {
#line 104
    if (iovcnt > 0) {
#line 104
      if (! ((iov + 0)->iov_len > 0U)) {
#line 104
        break;
      }
    } else {
#line 104
      break;
    }
#line 105
    res = (*f)(fd, (struct iovec  const  *)iov, iovcnt);
#line 106
    switch (res) {
    case -1: 
#line 108
    tmp___0 = __errno_location();
#line 108
    if (*tmp___0 == 4) {
      goto __Cont;
    }
#line 110
    tmp___1 = __errno_location();
#line 110
    if (*tmp___1 == 11) {
#line 112
      poll(& pfd, 1UL, -1);
      goto __Cont;
    } else {
#line 110
      tmp___2 = __errno_location();
#line 110
      if (*tmp___2 == 11) {
#line 112
        poll(& pfd, 1UL, -1);
        goto __Cont;
      }
    }
#line 116
    return (0U);
    case 0: 
#line 118
    tmp___3 = __errno_location();
#line 118
    *tmp___3 = 32;
#line 119
    return (pos);
    default: 
#line 121
    rem = (unsigned int )res;
#line 122
    pos += rem;
#line 124
    while (1) {
#line 124
      if (iovcnt > 0) {
#line 124
        if (! (rem >= (iov + 0)->iov_len)) {
#line 124
          break;
        }
      } else {
#line 124
        break;
      }
#line 125
      rem -= (iov + 0)->iov_len;
#line 126
      iov ++;
#line 127
      iovcnt --;
    }
#line 130
    if (rem > 0U) {
#line 130
      if (iovcnt <= 0) {
#line 131
        tmp___4 = __errno_location();
#line 131
        *tmp___4 = 14;
#line 132
        return (0U);
      } else {
#line 130
        if (rem > (iov + 0)->iov_len) {
#line 131
          tmp___4 = __errno_location();
#line 131
          *tmp___4 = 14;
#line 132
          return (0U);
        }
      }
    }
#line 134
    if (iovcnt == 0) {
#line 135
      break;
    }
#line 137
    (iov + 0)->iov_base = (void *)((char *)(iov + 0)->iov_base + rem);
#line 138
    (iov + 0)->iov_len -= rem;
    }
    __Cont: /* CIL Label */ ;
  }
#line 141
  return (pos);
}
}
#line 1 "key.o"
#pragma merger(0,"./key.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 491
extern BIGNUM *BN_dup(BIGNUM const   *a ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 470 "/usr/include/openssl/crypto.h"
extern void CRYPTO_free(void * ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 593
extern EVP_MD const   *EVP_md5(void) ;
#line 394 "/usr/include/bits/string2.h"
extern void *__rawmemchr(void const   *__s , int __c ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 192
extern void DSA_free(DSA *r ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 62 "key.h"
Key *key_demote(Key const   *k ) ;
#line 64
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) ;
#line 65
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) ;
#line 71
Key *key_generate(int type , u_int bits ) ;
#line 72
Key *key_from_private(Key const   *k ) ;
#line 73
int key_type_from_name(char *name ) ;
#line 78
int key_names_valid2(char const   *names ) ;
#line 80
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) ;
#line 81
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) ;
#line 83
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 84
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 85
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 86
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 27 "uuencode.h"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) ;
#line 28
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 56 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 62
  tmp = xcalloc(1U, sizeof(*k));
#line 62
  k = (Key *)tmp;
#line 63
  k->type = type;
#line 64
  k->dsa = (DSA *)((void *)0);
#line 65
  k->rsa = (RSA *)((void *)0);
#line 66
  switch (k->type) {
  case 0: 
  case 1: 
#line 69
  rsa = RSA_new();
#line 69
  if ((unsigned int )rsa == (unsigned int )((void *)0)) {
#line 70
    fatal("key_new: RSA_new failed");
  }
#line 71
  rsa->n = BN_new();
#line 71
  if ((unsigned int )rsa->n == (unsigned int )((void *)0)) {
#line 72
    fatal("key_new: BN_new failed");
  }
#line 73
  rsa->e = BN_new();
#line 73
  if ((unsigned int )rsa->e == (unsigned int )((void *)0)) {
#line 74
    fatal("key_new: BN_new failed");
  }
#line 75
  k->rsa = rsa;
#line 76
  break;
  case 2: 
#line 78
  dsa = DSA_new();
#line 78
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 79
    fatal("key_new: DSA_new failed");
  }
#line 80
  dsa->p = BN_new();
#line 80
  if ((unsigned int )dsa->p == (unsigned int )((void *)0)) {
#line 81
    fatal("key_new: BN_new failed");
  }
#line 82
  dsa->q = BN_new();
#line 82
  if ((unsigned int )dsa->q == (unsigned int )((void *)0)) {
#line 83
    fatal("key_new: BN_new failed");
  }
#line 84
  dsa->g = BN_new();
#line 84
  if ((unsigned int )dsa->g == (unsigned int )((void *)0)) {
#line 85
    fatal("key_new: BN_new failed");
  }
#line 86
  dsa->pub_key = BN_new();
#line 86
  if ((unsigned int )dsa->pub_key == (unsigned int )((void *)0)) {
#line 87
    fatal("key_new: BN_new failed");
  }
#line 88
  k->dsa = dsa;
#line 89
  break;
  case 3: 
#line 91
  break;
  default: 
#line 93
  fatal("key_new: bad key type %d", k->type);
#line 94
  break;
  }
#line 96
  return (k);
}
}
#line 99 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 102
  tmp = key_new(type);
#line 102
  k = tmp;
#line 103
  switch (k->type) {
  case 0: 
  case 1: 
#line 106
  (k->rsa)->d = BN_new();
#line 106
  if ((unsigned int )(k->rsa)->d == (unsigned int )((void *)0)) {
#line 107
    fatal("key_new_private: BN_new failed");
  }
#line 108
  (k->rsa)->iqmp = BN_new();
#line 108
  if ((unsigned int )(k->rsa)->iqmp == (unsigned int )((void *)0)) {
#line 109
    fatal("key_new_private: BN_new failed");
  }
#line 110
  (k->rsa)->q = BN_new();
#line 110
  if ((unsigned int )(k->rsa)->q == (unsigned int )((void *)0)) {
#line 111
    fatal("key_new_private: BN_new failed");
  }
#line 112
  (k->rsa)->p = BN_new();
#line 112
  if ((unsigned int )(k->rsa)->p == (unsigned int )((void *)0)) {
#line 113
    fatal("key_new_private: BN_new failed");
  }
#line 114
  (k->rsa)->dmq1 = BN_new();
#line 114
  if ((unsigned int )(k->rsa)->dmq1 == (unsigned int )((void *)0)) {
#line 115
    fatal("key_new_private: BN_new failed");
  }
#line 116
  (k->rsa)->dmp1 = BN_new();
#line 116
  if ((unsigned int )(k->rsa)->dmp1 == (unsigned int )((void *)0)) {
#line 117
    fatal("key_new_private: BN_new failed");
  }
#line 118
  break;
  case 2: 
#line 120
  (k->dsa)->priv_key = BN_new();
#line 120
  if ((unsigned int )(k->dsa)->priv_key == (unsigned int )((void *)0)) {
#line 121
    fatal("key_new_private: BN_new failed");
  }
#line 122
  break;
  case 3: 
#line 124
  break;
  default: ;
#line 126
  break;
  }
#line 128
  return (k);
}
}
#line 131 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 134
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 135
    fatal("key_free: key is NULL");
  }
#line 136
  switch (k->type) {
  case 0: 
  case 1: 
#line 139
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 140
    RSA_free(k->rsa);
  }
#line 141
  k->rsa = (RSA *)((void *)0);
#line 142
  break;
  case 2: 
#line 144
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 145
    DSA_free(k->dsa);
  }
#line 146
  k->dsa = (DSA *)((void *)0);
#line 147
  break;
  case 3: 
#line 149
  break;
  default: 
#line 151
  fatal("key_free: bad key type %d", k->type);
#line 152
  break;
  }
#line 154
  xfree((void *)k);
#line 155
  return;
}
}
#line 157 "key.c"
int key_equal(Key const   *a___0 , Key const   *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 160
  if ((unsigned int )a___0 == (unsigned int )((void *)0)) {
#line 161
    return (0);
  } else {
#line 160
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 161
      return (0);
    } else {
#line 160
      if (a___0->type != b->type) {
#line 161
        return (0);
      }
    }
  }
#line 162
  switch ((int )a___0->type) {
  case 0: 
  case 1: 
#line 165
  if ((unsigned int )a___0->rsa != (unsigned int )((void *)0)) {
#line 165
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 165
      tmp = BN_cmp((BIGNUM const   *)(a___0->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 165
      if (tmp == 0) {
#line 165
        tmp___0 = BN_cmp((BIGNUM const   *)(a___0->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 165
        if (tmp___0 == 0) {
#line 165
          tmp___1 = 1;
        } else {
#line 165
          tmp___1 = 0;
        }
      } else {
#line 165
        tmp___1 = 0;
      }
    } else {
#line 165
      tmp___1 = 0;
    }
  } else {
#line 165
    tmp___1 = 0;
  }
#line 165
  return (tmp___1);
  case 2: 
#line 169
  if ((unsigned int )a___0->dsa != (unsigned int )((void *)0)) {
#line 169
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 169
      tmp___2 = BN_cmp((BIGNUM const   *)(a___0->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 169
      if (tmp___2 == 0) {
#line 169
        tmp___3 = BN_cmp((BIGNUM const   *)(a___0->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 169
        if (tmp___3 == 0) {
#line 169
          tmp___4 = BN_cmp((BIGNUM const   *)(a___0->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 169
          if (tmp___4 == 0) {
#line 169
            tmp___5 = BN_cmp((BIGNUM const   *)(a___0->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 169
            if (tmp___5 == 0) {
#line 169
              tmp___6 = 1;
            } else {
#line 169
              tmp___6 = 0;
            }
          } else {
#line 169
            tmp___6 = 0;
          }
        } else {
#line 169
          tmp___6 = 0;
        }
      } else {
#line 169
        tmp___6 = 0;
      }
    } else {
#line 169
      tmp___6 = 0;
    }
  } else {
#line 169
    tmp___6 = 0;
  }
#line 169
  return (tmp___6);
  default: 
#line 175
  fatal("key_equal: bad key type %d", a___0->type);
  }
}
}
#line 180 "key.c"
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) 
{ EVP_MD const   *md ;
  EVP_MD_CTX ctx ;
  u_char *blob ;
  u_char *retval ;
  u_int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 184
  md = (EVP_MD const   *)((void *)0);
#line 186
  blob = (u_char *)((void *)0);
#line 187
  retval = (u_char *)((void *)0);
#line 188
  len = (u_int )0;
#line 191
  *dgst_raw_length = 0U;
#line 193
  switch ((int )dgst_type) {
  case 1: 
#line 195
  md = EVP_md5();
#line 196
  break;
  case 0: 
#line 198
  md = EVP_sha1();
#line 199
  break;
  default: 
#line 201
  fatal("key_fingerprint_raw: bad digest type %d", dgst_type);
  }
#line 204
  switch ((int )k->type) {
  case 0: 
#line 206
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 206
  nlen = (tmp + 7) / 8;
#line 207
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 207
  elen = (tmp___0 + 7) / 8;
#line 208
  len = (unsigned int )(nlen + elen);
#line 209
  tmp___1 = xmalloc(len);
#line 209
  blob = (u_char *)tmp___1;
#line 210
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 211
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 212
  break;
  case 2: 
  case 1: 
#line 215
  key_to_blob(k, & blob, & len);
#line 216
  break;
  case 3: 
#line 218
  return (retval);
  default: 
#line 220
  fatal("key_fingerprint_raw: bad key type %d", k->type);
#line 221
  break;
  }
#line 223
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 224
    tmp___2 = xmalloc(64U);
#line 224
    retval = (u_char *)tmp___2;
#line 225
    EVP_DigestInit(& ctx, md);
#line 226
    EVP_DigestUpdate(& ctx, (void const   *)blob, len);
#line 227
    EVP_DigestFinal(& ctx, retval, dgst_raw_length);
#line 228
    memset((void *)blob, 0, len);
#line 229
    xfree((void *)blob);
  } else {
#line 231
    fatal("key_fingerprint_raw: blob is null");
  }
#line 233
  return (retval);
}
}
#line 236 "key.c"
static char *key_fingerprint_hex(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char *retval ;
  u_int i ;
  void *tmp ;
  char hex[4] ;

  {
#line 242
  tmp = xcalloc(1U, dgst_raw_len * 3U + 1U);
#line 242
  retval = (char *)tmp;
#line 243
  i = 0U;
#line 243
  while (i < dgst_raw_len) {
#line 245
    snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
             *(dgst_raw + i));
#line 246
    strlcat(retval, (char const   *)(hex), dgst_raw_len * 3U + 1U);
#line 243
    i ++;
  }
#line 250
  *(retval + (dgst_raw_len * 3U - 1U)) = (char )'\000';
#line 251
  return (retval);
}
}
#line 254 "key.c"
static char *key_fingerprint_bubblebabble(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char vowels[6] ;
  char consonants[17] ;
  u_int i ;
  u_int j ;
  u_int rounds ;
  u_int seed ;
  char *retval ;
  void *tmp ;
  u_int tmp___0 ;
  u_int idx0 ;
  u_int idx1 ;
  u_int idx2 ;
  u_int idx3 ;
  u_int idx4 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;

  {
#line 257
  vowels[0] = (char )'a';
#line 257
  vowels[1] = (char )'e';
#line 257
  vowels[2] = (char )'i';
#line 257
  vowels[3] = (char )'o';
#line 257
  vowels[4] = (char )'u';
#line 257
  vowels[5] = (char )'y';
#line 258
  consonants[0] = (char )'b';
#line 258
  consonants[1] = (char )'c';
#line 258
  consonants[2] = (char )'d';
#line 258
  consonants[3] = (char )'f';
#line 258
  consonants[4] = (char )'g';
#line 258
  consonants[5] = (char )'h';
#line 258
  consonants[6] = (char )'k';
#line 258
  consonants[7] = (char )'l';
#line 258
  consonants[8] = (char )'m';
#line 258
  consonants[9] = (char )'n';
#line 258
  consonants[10] = (char )'p';
#line 258
  consonants[11] = (char )'r';
#line 258
  consonants[12] = (char )'s';
#line 258
  consonants[13] = (char )'t';
#line 258
  consonants[14] = (char )'v';
#line 258
  consonants[15] = (char )'z';
#line 258
  consonants[16] = (char )'x';
#line 260
  j = (u_int )0;
#line 260
  seed = (u_int )1;
#line 263
  rounds = dgst_raw_len / 2U + 1U;
#line 264
  tmp = xcalloc(rounds * 6U, sizeof(char ));
#line 264
  retval = (char *)tmp;
#line 265
  tmp___0 = j;
#line 265
  j ++;
#line 265
  *(retval + tmp___0) = (char )'x';
#line 266
  i = 0U;
#line 266
  while (i < rounds) {
#line 268
    if (i + 1U < rounds) {
      goto _L;
    } else {
#line 268
      if (dgst_raw_len % 2U != 0U) {
        _L: /* CIL Label */ 
#line 269
        idx0 = ((((unsigned int )*(dgst_raw + 2U * i) >> 6) & 3U) + seed) % 6U;
#line 271
        idx1 = ((unsigned int )*(dgst_raw + 2U * i) >> 2) & 15U;
#line 272
        idx2 = (((unsigned int )*(dgst_raw + 2U * i) & 3U) + seed / 6U) % 6U;
#line 274
        tmp___1 = j;
#line 274
        j ++;
#line 274
        *(retval + tmp___1) = vowels[idx0];
#line 275
        tmp___2 = j;
#line 275
        j ++;
#line 275
        *(retval + tmp___2) = consonants[idx1];
#line 276
        tmp___3 = j;
#line 276
        j ++;
#line 276
        *(retval + tmp___3) = vowels[idx2];
#line 277
        if (i + 1U < rounds) {
#line 278
          idx3 = ((unsigned int )*(dgst_raw + (2U * i + 1U)) >> 4) & 15U;
#line 279
          idx4 = (unsigned int )*(dgst_raw + (2U * i + 1U)) & 15U;
#line 280
          tmp___4 = j;
#line 280
          j ++;
#line 280
          *(retval + tmp___4) = consonants[idx3];
#line 281
          tmp___5 = j;
#line 281
          j ++;
#line 281
          *(retval + tmp___5) = (char )'-';
#line 282
          tmp___6 = j;
#line 282
          j ++;
#line 282
          *(retval + tmp___6) = consonants[idx4];
#line 283
          seed = (seed * 5U + ((unsigned int )*(dgst_raw + 2U * i) * 7U + (unsigned int )*(dgst_raw + (2U * i + 1U)))) % 36U;
        }
      } else {
#line 288
        idx0 = seed % 6U;
#line 289
        idx1 = 16U;
#line 290
        idx2 = seed / 6U;
#line 291
        tmp___7 = j;
#line 291
        j ++;
#line 291
        *(retval + tmp___7) = vowels[idx0];
#line 292
        tmp___8 = j;
#line 292
        j ++;
#line 292
        *(retval + tmp___8) = consonants[idx1];
#line 293
        tmp___9 = j;
#line 293
        j ++;
#line 293
        *(retval + tmp___9) = vowels[idx2];
      }
    }
#line 266
    i ++;
  }
#line 296
  tmp___10 = j;
#line 296
  j ++;
#line 296
  *(retval + tmp___10) = (char )'x';
#line 297
  tmp___11 = j;
#line 297
  j ++;
#line 297
  *(retval + tmp___11) = (char )'\000';
#line 298
  return (retval);
}
}
#line 334 "key.c"
static char *key_fingerprint_randomart(u_char *dgst_raw , u_int dgst_raw_len , Key const   *k ) 
{ char *augmentation_string ;
  char *retval ;
  char *p ;
  u_char field[17][9] ;
  u_int i ;
  u_int b ;
  int x ;
  int y ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  int input___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 341
  augmentation_string = (char *)" .o+=*BOX@%&#/^SE";
#line 346
  tmp = strlen((char const   *)augmentation_string);
#line 346
  len = tmp - 1U;
#line 348
  tmp___0 = xcalloc(1U, 220U);
#line 348
  retval = (char *)tmp___0;
#line 351
  memset((void *)(field), 0, 153U * sizeof(char ));
#line 352
  x = 8;
#line 353
  y = 4;
#line 356
  i = 0U;
#line 356
  while (i < dgst_raw_len) {
#line 359
    input___0 = (int )*(dgst_raw + i);
#line 360
    b = 0U;
#line 360
    while (b < 4U) {
#line 362
      if (input___0 & 1) {
#line 362
        tmp___1 = 1;
      } else {
#line 362
        tmp___1 = -1;
      }
#line 362
      x += tmp___1;
#line 363
      if (input___0 & 2) {
#line 363
        tmp___2 = 1;
      } else {
#line 363
        tmp___2 = -1;
      }
#line 363
      y += tmp___2;
#line 366
      if (x > 0) {
#line 366
        x = x;
      } else {
#line 366
        x = 0;
      }
#line 367
      if (y > 0) {
#line 367
        y = y;
      } else {
#line 367
        y = 0;
      }
#line 368
      if (x < 16) {
#line 368
        x = x;
      } else {
#line 368
        x = 16;
      }
#line 369
      if (y < 8) {
#line 369
        y = y;
      } else {
#line 369
        y = 8;
      }
#line 372
      if ((size_t )field[x][y] < len - 2U) {
#line 373
        field[x][y] = (u_char )((int )field[x][y] + 1);
      }
#line 374
      input___0 >>= 2;
#line 360
      b ++;
    }
#line 356
    i ++;
  }
#line 379
  field[8][4] = (unsigned char )(len - 1U);
#line 380
  field[x][y] = (unsigned char )len;
#line 383
  tmp___3 = key_size(k);
#line 383
  tmp___4 = key_type(k);
#line 383
  snprintf((char * __restrict  )retval, 17U, (char const   * __restrict  )"+--[%4s %4u]",
           tmp___4, tmp___3);
#line 384
  tmp___5 = __rawmemchr((void const   *)retval, '\000');
#line 384
  p = (char *)tmp___5;
#line 387
  i = (unsigned int )((p - retval) - 1);
#line 387
  while (i < 17U) {
#line 388
    tmp___7 = p;
#line 388
    p ++;
#line 388
    *tmp___7 = (char )'-';
#line 387
    i ++;
  }
#line 389
  tmp___8 = p;
#line 389
  p ++;
#line 389
  *tmp___8 = (char )'+';
#line 390
  tmp___9 = p;
#line 390
  p ++;
#line 390
  *tmp___9 = (char )'\n';
#line 393
  y = 0;
#line 393
  while (y < 9) {
#line 394
    tmp___10 = p;
#line 394
    p ++;
#line 394
    *tmp___10 = (char )'|';
#line 395
    x = 0;
#line 395
    while (x < 17) {
#line 396
      tmp___11 = p;
#line 396
      p ++;
#line 396
      if ((size_t )field[x][y] < len) {
#line 396
        tmp___12 = (unsigned int )field[x][y];
      } else {
#line 396
        tmp___12 = len;
      }
#line 396
      *tmp___11 = *(augmentation_string + tmp___12);
#line 395
      x ++;
    }
#line 397
    tmp___13 = p;
#line 397
    p ++;
#line 397
    *tmp___13 = (char )'|';
#line 398
    tmp___14 = p;
#line 398
    p ++;
#line 398
    *tmp___14 = (char )'\n';
#line 393
    y ++;
  }
#line 402
  tmp___15 = p;
#line 402
  p ++;
#line 402
  *tmp___15 = (char )'+';
#line 403
  i = 0U;
#line 403
  while (i < 17U) {
#line 404
    tmp___16 = p;
#line 404
    p ++;
#line 404
    *tmp___16 = (char )'-';
#line 403
    i ++;
  }
#line 405
  tmp___17 = p;
#line 405
  p ++;
#line 405
  *tmp___17 = (char )'+';
#line 407
  return (retval);
}
}
#line 410 "key.c"
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) 
{ char *retval ;
  u_char *dgst_raw ;
  u_int dgst_raw_len ;

  {
#line 413
  retval = (char *)((void *)0);
#line 417
  dgst_raw = key_fingerprint_raw(k, dgst_type, & dgst_raw_len);
#line 418
  if (! dgst_raw) {
#line 419
    fatal("key_fingerprint: null from key_fingerprint_raw()");
  }
#line 420
  switch ((int )dgst_rep) {
  case 0: 
#line 422
  retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
#line 423
  break;
  case 1: 
#line 425
  retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
#line 426
  break;
  case 2: 
#line 428
  retval = key_fingerprint_randomart(dgst_raw, dgst_raw_len, k);
#line 429
  break;
  default: 
#line 431
  fatal("key_fingerprint: bad digest representation %d", dgst_rep);
#line 433
  break;
  }
#line 435
  memset((void *)dgst_raw, 0, dgst_raw_len);
#line 436
  xfree((void *)dgst_raw);
#line 437
  return (retval);
}
}
#line 447 "key.c"
static int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 450
  cp = *cpp;
#line 454
  while (1) {
#line 454
    if (! ((int )*cp == 32)) {
#line 454
      if (! ((int )*cp == 9)) {
#line 454
        break;
      }
    }
#line 454
    cp ++;
  }
#line 458
  if ((int )*cp < 48) {
#line 459
    return (0);
  } else {
#line 458
    if ((int )*cp > 57) {
#line 459
      return (0);
    }
  }
#line 462
  *cpp = cp;
#line 465
  while (1) {
#line 465
    if ((int )*cp >= 48) {
#line 465
      if (! ((int )*cp <= 57)) {
#line 465
        break;
      }
    } else {
#line 465
      break;
    }
#line 465
    cp ++;
  }
#line 469
  old = (int )*cp;
#line 470
  *cp = (char)0;
#line 473
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 473
  if (tmp == 0) {
#line 474
    return (0);
  }
#line 477
  *cp = (char )old;
#line 480
  *cpp = cp;
#line 481
  return (1);
}
}
#line 484 "key.c"
static int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 487
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 487
  buf___1 = tmp;
#line 488
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 489
    error("write_bignum: BN_bn2dec() failed");
#line 490
    return (0);
  }
#line 492
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 493
  CRYPTO_free((void *)buf___1);
#line 494
  return (1);
}
}
#line 498 "key.c"
int key_read(Key *ret___0 , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 502
  success = -1;
#line 508
  cp = *cpp;
#line 510
  switch (ret___0->type) {
  case 0: 
#line 513
  if ((int )*cp < 48) {
#line 514
    return (-1);
  } else {
#line 513
    if ((int )*cp > 57) {
#line 514
      return (-1);
    }
  }
#line 515
  bits = 0U;
#line 515
  while (1) {
#line 515
    if ((int )*cp >= 48) {
#line 515
      if (! ((int )*cp <= 57)) {
#line 515
        break;
      }
    } else {
#line 515
      break;
    }
#line 516
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 515
    cp ++;
  }
#line 517
  if (bits == 0U) {
#line 518
    return (-1);
  }
#line 519
  *cpp = cp;
#line 521
  tmp = read_bignum(cpp, (ret___0->rsa)->e);
#line 521
  if (! tmp) {
#line 522
    return (-1);
  }
#line 523
  tmp___0 = read_bignum(cpp, (ret___0->rsa)->n);
#line 523
  if (! tmp___0) {
#line 524
    return (-1);
  }
#line 525
  success = 1;
#line 526
  break;
  case 3: 
  case 1: 
  case 2: 
#line 530
  tmp___2 = __builtin_strchr(cp, ' ');
#line 530
  space = tmp___2;
#line 531
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 532
    debug3("key_read: missing whitespace");
#line 533
    return (-1);
  }
#line 535
  *space = (char )'\000';
#line 536
  type = key_type_from_name(cp);
#line 537
  *space = (char )' ';
#line 538
  if (type == 3) {
#line 539
    debug3("key_read: missing keytype");
#line 540
    return (-1);
  }
#line 542
  cp = space + 1;
#line 543
  if ((int )*cp == 0) {
#line 544
    debug3("key_read: short string");
#line 545
    return (-1);
  }
#line 547
  if (ret___0->type == 3) {
#line 548
    ret___0->type = type;
  } else {
#line 549
    if (ret___0->type != type) {
#line 551
      debug3("key_read: type mismatch");
#line 552
      return (-1);
    }
  }
#line 554
  tmp___3 = strlen((char const   *)cp);
#line 554
  len = (int )(2U * tmp___3);
#line 555
  tmp___4 = xmalloc((unsigned int )len);
#line 555
  blob = (u_char *)tmp___4;
#line 556
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 557
  if (n___0 < 0) {
#line 558
    error("key_read: uudecode %s failed", cp);
#line 559
    xfree((void *)blob);
#line 560
    return (-1);
  }
#line 562
  k = key_from_blob((u_char const   *)blob, (unsigned int )n___0);
#line 563
  xfree((void *)blob);
#line 564
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 565
    error("key_read: key_from_blob %s failed", cp);
#line 566
    return (-1);
  }
#line 568
  if (k->type != type) {
#line 569
    error("key_read: type mismatch: encoding error");
#line 570
    key_free(k);
#line 571
    return (-1);
  }
#line 574
  if (ret___0->type == 1) {
#line 575
    if ((unsigned int )ret___0->rsa != (unsigned int )((void *)0)) {
#line 576
      RSA_free(ret___0->rsa);
    }
#line 577
    ret___0->rsa = k->rsa;
#line 578
    k->rsa = (RSA *)((void *)0);
#line 579
    success = 1;
  } else {
#line 584
    if ((unsigned int )ret___0->dsa != (unsigned int )((void *)0)) {
#line 585
      DSA_free(ret___0->dsa);
    }
#line 586
    ret___0->dsa = k->dsa;
#line 587
    k->dsa = (DSA *)((void *)0);
#line 588
    success = 1;
  }
#line 594
  key_free(k);
#line 595
  if (success != 1) {
#line 596
    break;
  }
#line 598
  while (1) {
#line 598
    if (! ((int )*cp == 32)) {
#line 598
      if (! ((int )*cp == 9)) {
#line 598
        break;
      }
    }
#line 599
    cp ++;
  }
#line 600
  while (1) {
#line 600
    if ((int )*cp != 0) {
#line 600
      if ((int )*cp != 32) {
#line 600
        if (! ((int )*cp != 9)) {
#line 600
          break;
        }
      } else {
#line 600
        break;
      }
    } else {
#line 600
      break;
    }
#line 601
    cp ++;
  }
#line 602
  *cpp = cp;
#line 603
  break;
  default: 
#line 605
  fatal("key_read: bad key type: %d", ret___0->type);
#line 606
  break;
  }
#line 608
  return (success);
}
}
#line 611 "key.c"
int key_write(Key const   *key , FILE *f ) 
{ int n___0 ;
  int success ;
  u_int len ;
  u_int bits ;
  u_char *blob ;
  char *uu ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 614
  success = 0;
#line 615
  bits = (u_int )0;
#line 619
  if (key->type == 0) {
#line 619
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 621
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 621
      bits = (unsigned int )tmp;
#line 622
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 623
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 623
      if (tmp___0) {
#line 623
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 623
        if (tmp___1) {
#line 625
          success = 1;
        } else {
#line 627
          error("key_write: failed for RSA key");
        }
      } else {
#line 627
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 629
    if (key->type == 2) {
#line 629
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 629
      if (key->type == 1) {
#line 629
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 631
          key_to_blob(key, & blob, & len);
#line 632
          tmp___2 = xmalloc(2U * len);
#line 632
          uu = (char *)tmp___2;
#line 633
          n___0 = uuencode((u_char const   *)blob, len, uu, 2U * len);
#line 634
          if (n___0 > 0) {
#line 635
            tmp___3 = key_ssh_name(key);
#line 635
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 636
            success = 1;
          }
#line 638
          xfree((void *)blob);
#line 639
          xfree((void *)uu);
        }
      }
    }
  }
#line 641
  return (success);
}
}
#line 644 "key.c"
char const   *key_type(Key const   *k ) 
{ 

  {
#line 647
  switch ((int )k->type) {
  case 0: 
#line 649
  return ("RSA1");
  case 1: 
#line 651
  return ("RSA");
  case 2: 
#line 653
  return ("DSA");
  }
#line 655
  return ("unknown");
}
}
#line 658 "key.c"
char const   *key_ssh_name(Key const   *k ) 
{ 

  {
#line 661
  switch ((int )k->type) {
  case 1: 
#line 663
  return ("ssh-rsa");
  case 2: 
#line 665
  return ("ssh-dss");
  }
#line 667
  return ("ssh-unknown");
}
}
#line 670 "key.c"
u_int key_size(Key const   *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 673
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 676
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 676
  return ((unsigned int )tmp);
  case 2: 
#line 678
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 678
  return ((unsigned int )tmp___0);
  }
#line 680
  return (0U);
}
}
#line 683 "key.c"
static RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 688
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 689
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 690
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 691
  return (private);
}
}
#line 694 "key.c"
static DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 697
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 697
  private = tmp;
#line 699
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 700
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 701
  tmp___0 = DSA_generate_key(private);
#line 701
  if (! tmp___0) {
#line 702
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 703
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 704
    fatal("dsa_generate_private_key: NULL.");
  }
#line 705
  return (private);
}
}
#line 708 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 711
  tmp = key_new(3);
#line 711
  k = tmp;
#line 712
  switch (type) {
  case 2: 
#line 714
  k->dsa = dsa_generate_private_key(bits);
#line 715
  break;
  case 1: 
  case 0: 
#line 718
  k->rsa = rsa_generate_private_key(bits);
#line 719
  break;
  default: 
#line 721
  fatal("key_generate: unknown type %d", type);
  }
#line 723
  k->type = type;
#line 724
  return (k);
}
}
#line 727 "key.c"
Key *key_from_private(Key const   *k ) 
{ Key *n___0 ;
  BIGNUM *tmp ;
  BIGNUM *tmp___0 ;
  BIGNUM *tmp___1 ;
  BIGNUM *tmp___2 ;
  BIGNUM *tmp___3 ;
  BIGNUM *tmp___4 ;

  {
#line 730
  n___0 = (Key *)((void *)0);
#line 731
  switch ((int )k->type) {
  case 2: 
#line 733
  n___0 = key_new((int )k->type);
#line 734
  tmp = BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 734
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 738
    fatal("key_from_private: BN_copy failed");
  } else {
#line 734
    tmp___0 = BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 734
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 738
      fatal("key_from_private: BN_copy failed");
    } else {
#line 734
      tmp___1 = BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 734
      if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 738
        fatal("key_from_private: BN_copy failed");
      } else {
#line 734
        tmp___2 = BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 734
        if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 738
          fatal("key_from_private: BN_copy failed");
        }
      }
    }
  }
#line 739
  break;
  case 1: 
  case 0: 
#line 742
  n___0 = key_new((int )k->type);
#line 743
  tmp___3 = BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 743
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 745
    fatal("key_from_private: BN_copy failed");
  } else {
#line 743
    tmp___4 = BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 743
    if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 745
      fatal("key_from_private: BN_copy failed");
    }
  }
#line 746
  break;
  default: 
#line 748
  fatal("key_from_private: unknown type %d", k->type);
#line 749
  break;
  }
#line 751
  return (n___0);
}
}
#line 754 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 757
  if (0) {
#line 757
    __s1_len___3 = strlen((char const   *)name);
#line 757
    __s2_len___3 = strlen("rsa1");
#line 757
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 757
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 757
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 757
          tmp___48 = 1;
        } else {
#line 757
          if (__s2_len___3 >= 4U) {
#line 757
            tmp___48 = 1;
          } else {
#line 757
            tmp___48 = 0;
          }
        }
      } else {
#line 757
        tmp___48 = 0;
      }
    }
#line 757
    if (tmp___48) {
#line 757
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 757
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 757
      tmp___44 = tmp___47;
    }
  } else {
#line 757
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 757
    tmp___44 = tmp___47;
  }
#line 757
  if (tmp___44 == 0) {
#line 758
    return (0);
  } else {
#line 759
    if (0) {
#line 759
      __s1_len___2 = strlen((char const   *)name);
#line 759
      __s2_len___2 = strlen("rsa");
#line 759
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 759
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 759
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 759
            tmp___38 = 1;
          } else {
#line 759
            if (__s2_len___2 >= 4U) {
#line 759
              tmp___38 = 1;
            } else {
#line 759
              tmp___38 = 0;
            }
          }
        } else {
#line 759
          tmp___38 = 0;
        }
      }
#line 759
      if (tmp___38) {
#line 759
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 759
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 759
        tmp___34 = tmp___37;
      }
    } else {
#line 759
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 759
      tmp___34 = tmp___37;
    }
#line 759
    if (tmp___34 == 0) {
#line 760
      return (1);
    } else {
#line 761
      if (0) {
#line 761
        __s1_len___1 = strlen((char const   *)name);
#line 761
        __s2_len___1 = strlen("dsa");
#line 761
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 761
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 761
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 761
              tmp___28 = 1;
            } else {
#line 761
              if (__s2_len___1 >= 4U) {
#line 761
                tmp___28 = 1;
              } else {
#line 761
                tmp___28 = 0;
              }
            }
          } else {
#line 761
            tmp___28 = 0;
          }
        }
#line 761
        if (tmp___28) {
#line 761
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 761
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 761
          tmp___24 = tmp___27;
        }
      } else {
#line 761
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 761
        tmp___24 = tmp___27;
      }
#line 761
      if (tmp___24 == 0) {
#line 762
        return (2);
      } else {
#line 763
        if (0) {
#line 763
          __s1_len___0 = strlen((char const   *)name);
#line 763
          __s2_len___0 = strlen("ssh-rsa");
#line 763
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 763
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 763
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 763
                tmp___18 = 1;
              } else {
#line 763
                if (__s2_len___0 >= 4U) {
#line 763
                  tmp___18 = 1;
                } else {
#line 763
                  tmp___18 = 0;
                }
              }
            } else {
#line 763
              tmp___18 = 0;
            }
          }
#line 763
          if (tmp___18) {
#line 763
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 763
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 763
            tmp___14 = tmp___17;
          }
        } else {
#line 763
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 763
          tmp___14 = tmp___17;
        }
#line 763
        if (tmp___14 == 0) {
#line 764
          return (1);
        } else {
#line 765
          if (0) {
#line 765
            __s1_len = strlen((char const   *)name);
#line 765
            __s2_len = strlen("ssh-dss");
#line 765
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 765
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 765
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 765
                  tmp___8 = 1;
                } else {
#line 765
                  if (__s2_len >= 4U) {
#line 765
                    tmp___8 = 1;
                  } else {
#line 765
                    tmp___8 = 0;
                  }
                }
              } else {
#line 765
                tmp___8 = 0;
              }
            }
#line 765
            if (tmp___8) {
#line 765
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 765
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 765
              tmp___4 = tmp___7;
            }
          } else {
#line 765
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 765
            tmp___4 = tmp___7;
          }
#line 765
          if (tmp___4 == 0) {
#line 766
            return (2);
          }
        }
      }
    }
  }
#line 768
  debug2("key_type_from_name: unknown key type \'%s\'", name);
#line 769
  return (3);
}
}
#line 772 "key.c"
int key_names_valid2(char const   *names ) 
{ char *s ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 777
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 778
    return (0);
  } else {
#line 777
    if (0) {
#line 777
      __s1_len = strlen(names);
#line 777
      __s2_len = strlen("");
#line 777
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 777
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 777
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 777
            tmp___8 = 1;
          } else {
#line 777
            if (__s2_len >= 4U) {
#line 777
              tmp___8 = 1;
            } else {
#line 777
              tmp___8 = 0;
            }
          }
        } else {
#line 777
          tmp___8 = 0;
        }
      }
#line 777
      if (tmp___8) {
#line 777
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 777
        tmp___7 = __builtin_strcmp(names, "");
#line 777
        tmp___4 = tmp___7;
      }
    } else {
#line 777
      tmp___7 = __builtin_strcmp(names, "");
#line 777
      tmp___4 = tmp___7;
    }
#line 777
    if (tmp___4 == 0) {
#line 778
      return (0);
    }
  }
#line 779
  cp = xstrdup(names);
#line 779
  s = cp;
#line 780
  tmp___24 = __strsep_g(& cp, ",");
#line 780
  p = tmp___24;
#line 780
  while (1) {
#line 780
    if (p) {
#line 780
      if (! ((int )*p != 0)) {
#line 780
        break;
      }
    } else {
#line 780
      break;
    }
#line 782
    tmp___41 = key_type_from_name(p);
#line 782
    switch (tmp___41) {
    case 0: 
    case 3: 
#line 785
    xfree((void *)s);
#line 786
    return (0);
    }
#line 781
    tmp___40 = __strsep_g(& cp, ",");
#line 781
    p = tmp___40;
  }
#line 789
  debug3("key names ok: [%s]", names);
#line 790
  xfree((void *)s);
#line 791
  return (1);
}
}
#line 794 "key.c"
Key *key_from_blob(u_char const   *blob , u_int blen ) 
{ Buffer b ;
  int rlen ;
  int type ;
  char *ktype ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;

  {
#line 799
  ktype = (char *)((void *)0);
#line 800
  key = (Key *)((void *)0);
#line 805
  buffer_init(& b);
#line 806
  buffer_append(& b, (void const   *)blob, blen);
#line 807
  tmp = buffer_get_string_ret(& b, (u_int *)((void *)0));
#line 807
  ktype = (char *)tmp;
#line 807
  if ((unsigned int )ktype == (unsigned int )((void *)0)) {
#line 808
    error("key_from_blob: can\'t read key type");
    goto out;
  }
#line 812
  type = key_type_from_name(ktype);
#line 814
  switch (type) {
  case 1: 
#line 816
  key = key_new(type);
#line 817
  tmp___0 = buffer_get_bignum2_ret(& b, (key->rsa)->e);
#line 817
  if (tmp___0 == -1) {
#line 819
    error("key_from_blob: can\'t read rsa key");
#line 820
    key_free(key);
#line 821
    key = (Key *)((void *)0);
    goto out;
  } else {
#line 817
    tmp___1 = buffer_get_bignum2_ret(& b, (key->rsa)->n);
#line 817
    if (tmp___1 == -1) {
#line 819
      error("key_from_blob: can\'t read rsa key");
#line 820
      key_free(key);
#line 821
      key = (Key *)((void *)0);
      goto out;
    }
  }
#line 827
  break;
  case 2: 
#line 829
  key = key_new(type);
#line 830
  tmp___2 = buffer_get_bignum2_ret(& b, (key->dsa)->p);
#line 830
  if (tmp___2 == -1) {
#line 834
    error("key_from_blob: can\'t read dsa key");
#line 835
    key_free(key);
#line 836
    key = (Key *)((void *)0);
    goto out;
  } else {
#line 830
    tmp___3 = buffer_get_bignum2_ret(& b, (key->dsa)->q);
#line 830
    if (tmp___3 == -1) {
#line 834
      error("key_from_blob: can\'t read dsa key");
#line 835
      key_free(key);
#line 836
      key = (Key *)((void *)0);
      goto out;
    } else {
#line 830
      tmp___4 = buffer_get_bignum2_ret(& b, (key->dsa)->g);
#line 830
      if (tmp___4 == -1) {
#line 834
        error("key_from_blob: can\'t read dsa key");
#line 835
        key_free(key);
#line 836
        key = (Key *)((void *)0);
        goto out;
      } else {
#line 830
        tmp___5 = buffer_get_bignum2_ret(& b, (key->dsa)->pub_key);
#line 830
        if (tmp___5 == -1) {
#line 834
          error("key_from_blob: can\'t read dsa key");
#line 835
          key_free(key);
#line 836
          key = (Key *)((void *)0);
          goto out;
        }
      }
    }
  }
#line 842
  break;
  case 3: 
#line 844
  key = key_new(type);
#line 845
  break;
  default: 
#line 847
  error("key_from_blob: cannot handle type %s", ktype);
  goto out;
  }
#line 850
  tmp___6 = buffer_len(& b);
#line 850
  rlen = (int )tmp___6;
#line 851
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 851
    if (rlen != 0) {
#line 852
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
  out: 
#line 854
  if ((unsigned int )ktype != (unsigned int )((void *)0)) {
#line 855
    xfree((void *)ktype);
  }
#line 856
  buffer_free(& b);
#line 857
  return (key);
}
}
#line 860 "key.c"
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 866
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 867
    error("key_to_blob: key == NULL");
#line 868
    return (0);
  }
#line 870
  buffer_init(& b);
#line 871
  switch ((int )key->type) {
  case 2: 
#line 873
  tmp = key_ssh_name(key);
#line 873
  buffer_put_cstring(& b, tmp);
#line 874
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->p);
#line 875
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->q);
#line 876
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->g);
#line 877
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 878
  break;
  case 1: 
#line 880
  tmp___0 = key_ssh_name(key);
#line 880
  buffer_put_cstring(& b, tmp___0);
#line 881
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->e);
#line 882
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->n);
#line 883
  break;
  default: 
#line 885
  error("key_to_blob: unsupported key type %d", key->type);
#line 886
  buffer_free(& b);
#line 887
  return (0);
  }
#line 889
  tmp___1 = buffer_len(& b);
#line 889
  len = (int )tmp___1;
#line 890
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 891
    *lenp = (unsigned int )len;
  }
#line 892
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 893
    tmp___2 = xmalloc((unsigned int )len);
#line 893
    *blobp = (u_char *)tmp___2;
#line 894
    tmp___3 = buffer_ptr(& b);
#line 894
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___3, (unsigned int )len);
  }
#line 896
  tmp___4 = buffer_ptr(& b);
#line 896
  memset(tmp___4, 0, (unsigned int )len);
#line 897
  buffer_free(& b);
#line 898
  return (len);
}
}
#line 901 "key.c"
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 907
  switch ((int )key->type) {
  case 2: 
#line 909
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 909
  return (tmp);
  case 1: 
#line 911
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 911
  return (tmp___0);
  default: 
#line 913
  error("key_sign: invalid key type %d", key->type);
#line 914
  return (-1);
  }
}
}
#line 922 "key.c"
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 928
  if (signaturelen == 0U) {
#line 929
    return (-1);
  }
#line 931
  switch ((int )key->type) {
  case 2: 
#line 933
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 933
  return (tmp);
  case 1: 
#line 935
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 935
  return (tmp___0);
  default: 
#line 937
  error("key_verify: invalid key type %d", key->type);
#line 938
  return (-1);
  }
}
}
#line 943 "key.c"
Key *key_demote(Key const   *k ) 
{ Key *pk ;
  void *tmp ;

  {
#line 948
  tmp = xcalloc(1U, sizeof(*pk));
#line 948
  pk = (Key *)tmp;
#line 949
  pk->type = (int )k->type;
#line 950
  pk->flags = (int )k->flags;
#line 951
  pk->dsa = (DSA *)((void *)0);
#line 952
  pk->rsa = (RSA *)((void *)0);
#line 954
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 957
  pk->rsa = RSA_new();
#line 957
  if ((unsigned int )pk->rsa == (unsigned int )((void *)0)) {
#line 958
    fatal("key_demote: RSA_new failed");
  }
#line 959
  (pk->rsa)->e = BN_dup((BIGNUM const   *)(k->rsa)->e);
#line 959
  if ((unsigned int )(pk->rsa)->e == (unsigned int )((void *)0)) {
#line 960
    fatal("key_demote: BN_dup failed");
  }
#line 961
  (pk->rsa)->n = BN_dup((BIGNUM const   *)(k->rsa)->n);
#line 961
  if ((unsigned int )(pk->rsa)->n == (unsigned int )((void *)0)) {
#line 962
    fatal("key_demote: BN_dup failed");
  }
#line 963
  break;
  case 2: 
#line 965
  pk->dsa = DSA_new();
#line 965
  if ((unsigned int )pk->dsa == (unsigned int )((void *)0)) {
#line 966
    fatal("key_demote: DSA_new failed");
  }
#line 967
  (pk->dsa)->p = BN_dup((BIGNUM const   *)(k->dsa)->p);
#line 967
  if ((unsigned int )(pk->dsa)->p == (unsigned int )((void *)0)) {
#line 968
    fatal("key_demote: BN_dup failed");
  }
#line 969
  (pk->dsa)->q = BN_dup((BIGNUM const   *)(k->dsa)->q);
#line 969
  if ((unsigned int )(pk->dsa)->q == (unsigned int )((void *)0)) {
#line 970
    fatal("key_demote: BN_dup failed");
  }
#line 971
  (pk->dsa)->g = BN_dup((BIGNUM const   *)(k->dsa)->g);
#line 971
  if ((unsigned int )(pk->dsa)->g == (unsigned int )((void *)0)) {
#line 972
    fatal("key_demote: BN_dup failed");
  }
#line 973
  (pk->dsa)->pub_key = BN_dup((BIGNUM const   *)(k->dsa)->pub_key);
#line 973
  if ((unsigned int )(pk->dsa)->pub_key == (unsigned int )((void *)0)) {
#line 974
    fatal("key_demote: BN_dup failed");
  }
#line 975
  break;
  default: 
#line 977
  fatal("key_free: bad key type %d", k->type);
#line 978
  break;
  }
#line 981
  return (pk);
}
}
#line 1 "dispatch.o"
#pragma merger(0,"./dispatch.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 36 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 37
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 38
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) ;
#line 39
void dispatch_run(int mode , sig_atomic_t volatile   *done , void *ctxt ) ;
#line 40
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) ;
#line 41
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) ;
#line 42 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 44 "dispatch.c"
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 47
  logit("dispatch_protocol_error: type %d seq %u", type, seq);
#line 48
  if (! compat20) {
#line 49
    fatal("protocol error");
  }
#line 50
  packet_start((unsigned char)3);
#line 51
  packet_put_int(seq);
#line 52
  packet_send();
#line 53
  packet_write_wait();
#line 54
  return;
}
}
#line 55 "dispatch.c"
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 58
  logit("dispatch_protocol_ignore: type %d seq %u", type, seq);
#line 59
  return;
}
}
#line 60 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ u_int i ;

  {
#line 64
  i = 0U;
#line 64
  while (i < 255U) {
#line 65
    dispatch[i] = dflt;
#line 64
    i ++;
  }
#line 66
  return;
}
}
#line 67 "dispatch.c"
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) 
{ u_int i ;

  {
#line 72
  i = from;
#line 72
  while (i <= to) {
#line 73
    if (i >= 255U) {
#line 74
      break;
    }
#line 75
    dispatch[i] = fn;
#line 72
    i ++;
  }
#line 77
  return;
}
}
#line 78 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 81
  dispatch[type] = fn;
#line 82
  return;
}
}
#line 83 "dispatch.c"
void dispatch_run(int mode , sig_atomic_t volatile   *done , void *ctxt ) 
{ int type ;
  u_int32_t seqnr ;

  {
#line 86
  while (1) {
#line 90
    if (mode == 0) {
#line 91
      type = packet_read_seqnr(& seqnr);
    } else {
#line 93
      type = packet_read_poll_seqnr(& seqnr);
#line 94
      if (type == 0) {
#line 95
        return;
      }
    }
#line 97
    if (type > 0) {
#line 97
      if (type < 255) {
#line 97
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 98
          (*(dispatch[type]))(type, seqnr, ctxt);
        } else {
#line 100
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 100
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 100
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 101
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 101
      if (*done) {
#line 102
        return;
      }
    }
  }
}
}
#line 1 "kex.o"
#pragma merger(0,"./kex.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 604 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_sha256(void) ;
#line 130 "kex.h"
Kex *kex_setup(char **proposal ) ;
#line 131
void kex_finish(Kex *kex ) ;
#line 133
void kex_send_kexinit(Kex *kex ) ;
#line 134
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) ;
#line 135
void kex_derive_keys(Kex *kex , u_char *hash , u_int hashlen , BIGNUM *shared_secret ) ;
#line 152
void derive_ssh1_session_id(BIGNUM *host_modulus , BIGNUM *server_modulus , u_int8_t *cookie ,
                            u_int8_t *id ) ;
#line 27 "mac.h"
int mac_setup(Mac *mac , char *name ) ;
#line 63 "kex.c"
static void kex_kexinit_finish(Kex *kex ) ;
#line 64
static void kex_choose_conf(Kex *kex ) ;
#line 67 "kex.c"
static void kex_prop2buf(Buffer *b , char **proposal ) 
{ u_int i ;

  {
#line 72
  buffer_clear(b);
#line 77
  i = 0U;
#line 77
  while (i < 16U) {
#line 78
    buffer_put_char(b, 0);
#line 77
    i ++;
  }
#line 79
  i = 0U;
#line 79
  while (i < 10U) {
#line 80
    buffer_put_cstring(b, (char const   *)*(proposal + i));
#line 79
    i ++;
  }
#line 81
  buffer_put_char(b, 0);
#line 82
  buffer_put_int(b, 0U);
#line 83
  return;
}
}
#line 86 "kex.c"
static char **kex_buf2prop(Buffer *raw , int *first_kex_follows ) 
{ Buffer b ;
  u_int i ;
  char **proposal ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 93
  tmp = xcalloc(10U, sizeof(char *));
#line 93
  proposal = (char **)tmp;
#line 95
  buffer_init(& b);
#line 96
  tmp___0 = buffer_len(raw);
#line 96
  tmp___1 = buffer_ptr(raw);
#line 96
  buffer_append(& b, (void const   *)tmp___1, tmp___0);
#line 98
  i = 0U;
#line 98
  while (i < 16U) {
#line 99
    buffer_get_char(& b);
#line 98
    i ++;
  }
#line 101
  i = 0U;
#line 101
  while (i < 10U) {
#line 102
    tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 102
    *(proposal + i) = (char *)tmp___2;
#line 103
    debug2("kex_parse_kexinit: %s", *(proposal + i));
#line 101
    i ++;
  }
#line 106
  tmp___3 = buffer_get_char(& b);
#line 106
  i = (unsigned int )tmp___3;
#line 107
  if ((unsigned int )first_kex_follows != (unsigned int )((void *)0)) {
#line 108
    *first_kex_follows = (int )i;
  }
#line 109
  debug2("kex_parse_kexinit: first_kex_follows %d ", i);
#line 110
  i = buffer_get_int(& b);
#line 111
  debug2("kex_parse_kexinit: reserved %u ", i);
#line 112
  buffer_free(& b);
#line 113
  return (proposal);
}
}
#line 116 "kex.c"
static void kex_prop_free(char **proposal ) 
{ u_int i ;

  {
#line 121
  i = 0U;
#line 121
  while (i < 10U) {
#line 122
    xfree((void *)*(proposal + i));
#line 121
    i ++;
  }
#line 123
  xfree((void *)proposal);
#line 124
  return;
}
}
#line 127 "kex.c"
static void kex_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 130
  error("Hm, kex protocol error: type %d seq %u", type, seq);
#line 131
  return;
}
}
#line 133 "kex.c"
static void kex_reset_dispatch(void) 
{ 

  {
#line 136
  dispatch_range(1U, 49U, & kex_protocol_error);
#line 138
  dispatch_set(20, & kex_input_kexinit);
#line 139
  return;
}
}
#line 141 "kex.c"
void kex_finish(Kex *kex ) 
{ int _len ;
  int tmp ;

  {
#line 144
  kex_reset_dispatch();
#line 146
  packet_start((unsigned char)21);
#line 147
  packet_send();
#line 149
  debug("SSH2_MSG_NEWKEYS sent");
#line 151
  debug("expecting SSH2_MSG_NEWKEYS");
#line 152
  packet_read_expect(21);
#line 153
  while (1) {
#line 153
    tmp = packet_remaining();
#line 153
    _len = tmp;
#line 153
    if (_len > 0) {
#line 153
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            153);
#line 153
      packet_disconnect("Packet integrity error.");
    }
#line 153
    break;
  }
#line 154
  debug("SSH2_MSG_NEWKEYS received");
#line 156
  kex->done = 1;
#line 157
  buffer_clear(& kex->peer);
#line 159
  kex->flags &= -2;
#line 160
  xfree((void *)kex->name);
#line 161
  kex->name = (char *)((void *)0);
#line 162
  return;
}
}
#line 164 "kex.c"
void kex_send_kexinit(Kex *kex ) 
{ u_int32_t rnd ;
  u_char *cookie ;
  u_int i ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 167
  rnd = (u_int32_t )0;
#line 171
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 172
    error("kex_send_kexinit: no kex, cannot rekey");
#line 173
    return;
  }
#line 175
  if (kex->flags & 1) {
#line 176
    debug("KEX_INIT_SENT");
#line 177
    return;
  }
#line 179
  kex->done = 0;
#line 182
  tmp = buffer_len(& kex->my);
#line 182
  if (tmp < 16U) {
#line 183
    fatal("kex_send_kexinit: kex proposal too short");
  }
#line 184
  tmp___0 = buffer_ptr(& kex->my);
#line 184
  cookie = (u_char *)tmp___0;
#line 185
  i = 0U;
#line 185
  while (i < 16U) {
#line 186
    if (i % 4U == 0U) {
#line 187
      rnd = arc4random();
    }
#line 188
    *(cookie + i) = (unsigned char )rnd;
#line 189
    rnd >>= 8;
#line 185
    i ++;
  }
#line 191
  packet_start((unsigned char)20);
#line 192
  tmp___1 = buffer_len(& kex->my);
#line 192
  tmp___2 = buffer_ptr(& kex->my);
#line 192
  packet_put_raw((void const   *)tmp___2, tmp___1);
#line 193
  packet_send();
#line 194
  debug("SSH2_MSG_KEXINIT sent");
#line 195
  kex->flags |= 1;
#line 196
  return;
}
}
#line 199 "kex.c"
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) 
{ char *ptr ;
  u_int i ;
  u_int dlen ;
  Kex *kex ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 204
  kex = (Kex *)ctxt;
#line 206
  debug("SSH2_MSG_KEXINIT received");
#line 207
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 208
    fatal("kex_input_kexinit: no kex, cannot rekey");
  }
#line 210
  tmp = packet_get_raw(& dlen);
#line 210
  ptr = (char *)tmp;
#line 211
  buffer_append(& kex->peer, (void const   *)ptr, dlen);
#line 214
  i = 0U;
#line 214
  while (i < 16U) {
#line 215
    packet_get_char();
#line 214
    i ++;
  }
#line 216
  i = 0U;
#line 216
  while (i < 10U) {
#line 217
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 217
    xfree(tmp___0);
#line 216
    i ++;
  }
#line 218
  packet_get_char();
#line 219
  packet_get_int();
#line 220
  while (1) {
#line 220
    tmp___1 = packet_remaining();
#line 220
    _len = tmp___1;
#line 220
    if (_len > 0) {
#line 220
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            220);
#line 220
      packet_disconnect("Packet integrity error.");
    }
#line 220
    break;
  }
#line 222
  kex_kexinit_finish(kex);
#line 223
  return;
}
}
#line 225 "kex.c"
Kex *kex_setup(char **proposal ) 
{ Kex *kex ;
  void *tmp ;

  {
#line 230
  tmp = xcalloc(1U, sizeof(*kex));
#line 230
  kex = (Kex *)tmp;
#line 231
  buffer_init(& kex->peer);
#line 232
  buffer_init(& kex->my);
#line 233
  kex_prop2buf(& kex->my, proposal);
#line 234
  kex->done = 0;
#line 236
  kex_send_kexinit(kex);
#line 237
  kex_reset_dispatch();
#line 239
  return (kex);
}
}
#line 242 "kex.c"
static void kex_kexinit_finish(Kex *kex ) 
{ 

  {
#line 245
  if (! (kex->flags & 1)) {
#line 246
    kex_send_kexinit(kex);
  }
#line 248
  kex_choose_conf(kex);
#line 250
  if (kex->kex_type >= 0) {
#line 250
    if (kex->kex_type < 4) {
#line 250
      if ((unsigned int )kex->kex[kex->kex_type] != (unsigned int )((void *)0)) {
#line 252
        (*(kex->kex[kex->kex_type]))(kex);
      } else {
#line 254
        fatal("Unsupported key exchange %d", kex->kex_type);
      }
    } else {
#line 254
      fatal("Unsupported key exchange %d", kex->kex_type);
    }
  } else {
#line 254
    fatal("Unsupported key exchange %d", kex->kex_type);
  }
#line 256
  return;
}
}
#line 258 "kex.c"
static void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 261
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 261
  name = tmp;
#line 262
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 263
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 265
  enc->cipher = cipher_by_name((char const   *)name);
#line 265
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 266
    fatal("matching cipher is not supported: %s", name);
  }
#line 267
  enc->name = name;
#line 268
  enc->enabled = 0;
#line 269
  enc->iv = (u_char *)((void *)0);
#line 270
  enc->key = (u_char *)((void *)0);
#line 271
  enc->key_len = cipher_keylen((Cipher const   *)enc->cipher);
#line 272
  enc->block_size = cipher_blocksize((Cipher const   *)enc->cipher);
#line 273
  return;
}
}
#line 275 "kex.c"
static void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 278
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 278
  name = tmp;
#line 279
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 280
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 282
  tmp___0 = mac_setup(mac, name);
#line 282
  if (tmp___0 < 0) {
#line 283
    fatal("unsupported mac %s", name);
  }
#line 285
  if (datafellows & 4) {
#line 286
    mac->key_len = 16U;
  }
#line 287
  mac->name = name;
#line 288
  mac->key = (u_char *)((void *)0);
#line 289
  mac->enabled = 0;
#line 290
  return;
}
}
#line 292 "kex.c"
static void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 295
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 295
  name = tmp;
#line 296
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 297
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 298
  if (0) {
#line 298
    __s1_len___1 = strlen((char const   *)name);
#line 298
    __s2_len___1 = strlen("zlib@openssh.com");
#line 298
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 298
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 298
        if (! ((unsigned int )((void const   *)("zlib@openssh.com" + 1)) - (unsigned int )((void const   *)"zlib@openssh.com") == 1U)) {
#line 298
          tmp___29 = 1;
        } else {
#line 298
          if (__s2_len___1 >= 4U) {
#line 298
            tmp___29 = 1;
          } else {
#line 298
            tmp___29 = 0;
          }
        }
      } else {
#line 298
        tmp___29 = 0;
      }
    }
#line 298
    if (tmp___29) {
#line 298
      tmp___25 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
    } else {
#line 298
      tmp___28 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
#line 298
      tmp___25 = tmp___28;
    }
  } else {
#line 298
    tmp___28 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
#line 298
    tmp___25 = tmp___28;
  }
#line 298
  if (tmp___25 == 0) {
#line 299
    comp->type = 2;
  } else {
#line 300
    if (0) {
#line 300
      __s1_len___0 = strlen((char const   *)name);
#line 300
      __s2_len___0 = strlen("zlib");
#line 300
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 300
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 300
          if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 300
            tmp___19 = 1;
          } else {
#line 300
            if (__s2_len___0 >= 4U) {
#line 300
              tmp___19 = 1;
            } else {
#line 300
              tmp___19 = 0;
            }
          }
        } else {
#line 300
          tmp___19 = 0;
        }
      }
#line 300
      if (tmp___19) {
#line 300
        tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
      } else {
#line 300
        tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 300
        tmp___15 = tmp___18;
      }
    } else {
#line 300
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 300
      tmp___15 = tmp___18;
    }
#line 300
    if (tmp___15 == 0) {
#line 301
      comp->type = 1;
    } else {
#line 302
      if (0) {
#line 302
        __s1_len = strlen((char const   *)name);
#line 302
        __s2_len = strlen("none");
#line 302
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 302
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 302
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 302
              tmp___9 = 1;
            } else {
#line 302
              if (__s2_len >= 4U) {
#line 302
                tmp___9 = 1;
              } else {
#line 302
                tmp___9 = 0;
              }
            }
          } else {
#line 302
            tmp___9 = 0;
          }
        }
#line 302
        if (tmp___9) {
#line 302
          tmp___5 = __builtin_strcmp((char const   *)name, "none");
        } else {
#line 302
          tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 302
          tmp___5 = tmp___8;
        }
      } else {
#line 302
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 302
        tmp___5 = tmp___8;
      }
#line 302
      if (tmp___5 == 0) {
#line 303
        comp->type = 0;
      } else {
#line 305
        fatal("unsupported comp %s", name);
      }
    }
  }
#line 307
  comp->name = name;
#line 308
  return;
}
}
#line 310 "kex.c"
static void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 313
  k->name = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 314
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 315
    fatal("Unable to negotiate a key exchange method");
  }
#line 316
  if (0) {
#line 316
    __s1_len___2 = strlen((char const   *)k->name);
#line 316
    __s2_len___2 = strlen("diffie-hellman-group1-sha1");
#line 316
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___6;
    } else {
#line 316
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 316
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 316
          tmp___38 = 1;
        } else {
#line 316
          if (__s2_len___2 >= 4U) {
#line 316
            tmp___38 = 1;
          } else {
#line 316
            tmp___38 = 0;
          }
        }
      } else {
#line 316
        tmp___38 = 0;
      }
    }
#line 316
    if (tmp___38) {
#line 316
      tmp___34 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 316
      tmp___37 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 316
      tmp___34 = tmp___37;
    }
  } else {
#line 316
    tmp___37 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 316
    tmp___34 = tmp___37;
  }
#line 316
  if (tmp___34 == 0) {
#line 317
    k->kex_type = 0;
#line 318
    k->evp_md = EVP_sha1();
  } else {
#line 319
    if (0) {
#line 319
      __s1_len___1 = strlen((char const   *)k->name);
#line 319
      __s2_len___1 = strlen("diffie-hellman-group14-sha1");
#line 319
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___4;
      } else {
#line 319
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 319
          if (! ((unsigned int )((void const   *)("diffie-hellman-group14-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group14-sha1") == 1U)) {
#line 319
            tmp___28 = 1;
          } else {
#line 319
            if (__s2_len___1 >= 4U) {
#line 319
              tmp___28 = 1;
            } else {
#line 319
              tmp___28 = 0;
            }
          }
        } else {
#line 319
          tmp___28 = 0;
        }
      }
#line 319
      if (tmp___28) {
#line 319
        tmp___24 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
      } else {
#line 319
        tmp___27 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
#line 319
        tmp___24 = tmp___27;
      }
    } else {
#line 319
      tmp___27 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
#line 319
      tmp___24 = tmp___27;
    }
#line 319
    if (tmp___24 == 0) {
#line 320
      k->kex_type = 1;
#line 321
      k->evp_md = EVP_sha1();
    } else {
#line 322
      if (0) {
#line 322
        __s1_len___0 = strlen((char const   *)k->name);
#line 322
        __s2_len___0 = strlen("diffie-hellman-group-exchange-sha1");
#line 322
        if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
          goto _L___2;
        } else {
#line 322
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 322
            if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 322
              tmp___18 = 1;
            } else {
#line 322
              if (__s2_len___0 >= 4U) {
#line 322
                tmp___18 = 1;
              } else {
#line 322
                tmp___18 = 0;
              }
            }
          } else {
#line 322
            tmp___18 = 0;
          }
        }
#line 322
        if (tmp___18) {
#line 322
          tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
        } else {
#line 322
          tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 322
          tmp___14 = tmp___17;
        }
      } else {
#line 322
        tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 322
        tmp___14 = tmp___17;
      }
#line 322
      if (tmp___14 == 0) {
#line 323
        k->kex_type = 2;
#line 324
        k->evp_md = EVP_sha1();
      } else {
#line 326
        if (0) {
#line 326
          __s1_len = strlen((char const   *)k->name);
#line 326
          __s2_len = strlen("diffie-hellman-group-exchange-sha256");
#line 326
          if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
            goto _L___0;
          } else {
#line 326
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 326
              if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha256" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha256") == 1U)) {
#line 326
                tmp___8 = 1;
              } else {
#line 326
                if (__s2_len >= 4U) {
#line 326
                  tmp___8 = 1;
                } else {
#line 326
                  tmp___8 = 0;
                }
              }
            } else {
#line 326
              tmp___8 = 0;
            }
          }
#line 326
          if (tmp___8) {
#line 326
            tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha256");
          } else {
#line 326
            tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha256");
#line 326
            tmp___4 = tmp___7;
          }
        } else {
#line 326
          tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha256");
#line 326
          tmp___4 = tmp___7;
        }
#line 326
        if (tmp___4 == 0) {
#line 327
          k->kex_type = 3;
#line 328
          k->evp_md = EVP_sha256();
        } else {
#line 331
          fatal("bad kex alg %s", k->name);
        }
      }
    }
  }
#line 332
  return;
}
}
#line 334 "kex.c"
static void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 337
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 337
  hostkeyalg = tmp;
#line 338
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 339
    fatal("no hostkey alg");
  }
#line 340
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 341
  if (k->hostkey_type == 3) {
#line 342
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 343
  xfree((void *)hostkeyalg);
#line 344
  return;
}
}
#line 349
static int proposals_match(char **my , char **peer ) ;
#line 349 "kex.c"
static int check___0[3]  = {      0,      1,      -1};
#line 346 "kex.c"
static int proposals_match(char **my , char **peer ) 
{ int *idx ;
  char *p ;
  char *tmp___0 ;
  char *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 355
  idx = check___0;
#line 355
  while (*idx != -1) {
#line 356
    tmp___0 = __builtin_strchr(*(my + *idx), ',');
#line 356
    p = tmp___0;
#line 356
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 357
      *p = (char )'\000';
    }
#line 358
    tmp___2 = __builtin_strchr(*(peer + *idx), ',');
#line 358
    p = tmp___2;
#line 358
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 359
      *p = (char )'\000';
    }
#line 360
    if (0) {
#line 360
      __s1_len = strlen((char const   *)*(my + *idx));
#line 360
      __s2_len = strlen((char const   *)*(peer + *idx));
#line 360
      if (! ((unsigned int )((void const   *)(*(my + *idx) + 1)) - (unsigned int )((void const   *)*(my + *idx)) == 1U)) {
        goto _L___0;
      } else {
#line 360
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 360
          if (! ((unsigned int )((void const   *)(*(peer + *idx) + 1)) - (unsigned int )((void const   *)*(peer + *idx)) == 1U)) {
#line 360
            tmp___12 = 1;
          } else {
#line 360
            if (__s2_len >= 4U) {
#line 360
              tmp___12 = 1;
            } else {
#line 360
              tmp___12 = 0;
            }
          }
        } else {
#line 360
          tmp___12 = 0;
        }
      }
#line 360
      if (tmp___12) {
#line 360
        tmp___8 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
      } else {
#line 360
        tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 360
        tmp___8 = tmp___11;
      }
    } else {
#line 360
      tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 360
      tmp___8 = tmp___11;
    }
#line 360
    if (tmp___8 != 0) {
#line 361
      debug2("proposal mismatch: my %s peer %s", *(my + *idx), *(peer + *idx));
#line 363
      return (0);
    }
#line 355
    idx ++;
  }
#line 366
  debug2("proposals match");
#line 367
  return (1);
}
}
#line 370 "kex.c"
static void kex_choose_conf(Kex *kex ) 
{ Newkeys *newkeys___0 ;
  char **my ;
  char **peer ;
  char **cprop ;
  char **sprop ;
  int nenc ;
  int nmac ;
  int ncomp ;
  u_int mode ;
  u_int ctos ;
  u_int need ;
  int first_kex_follows ;
  int type ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 380
  my = kex_buf2prop(& kex->my, (int *)((void *)0));
#line 381
  peer = kex_buf2prop(& kex->peer, & first_kex_follows);
#line 383
  if (kex->server) {
#line 384
    cprop = peer;
#line 385
    sprop = my;
  } else {
#line 387
    cprop = my;
#line 388
    sprop = peer;
  }
#line 392
  mode = 0U;
#line 392
  while (mode < 2U) {
#line 393
    tmp = xcalloc(1U, sizeof(*newkeys___0));
#line 393
    newkeys___0 = (Newkeys *)tmp;
#line 394
    kex->newkeys[mode] = newkeys___0;
#line 395
    if (! kex->server) {
#line 395
      if (mode == 1U) {
#line 395
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 395
      if (kex->server) {
#line 395
        if (mode == 0U) {
#line 395
          tmp___0 = 1;
        } else {
#line 395
          tmp___0 = 0;
        }
      } else {
#line 395
        tmp___0 = 0;
      }
    }
#line 395
    ctos = (unsigned int )tmp___0;
#line 397
    if (ctos) {
#line 397
      nenc = 2;
    } else {
#line 397
      nenc = 3;
    }
#line 398
    if (ctos) {
#line 398
      nmac = 4;
    } else {
#line 398
      nmac = 5;
    }
#line 399
    if (ctos) {
#line 399
      ncomp = 6;
    } else {
#line 399
      ncomp = 7;
    }
#line 400
    choose_enc(& newkeys___0->enc, *(cprop + nenc), *(sprop + nenc));
#line 401
    choose_mac(& newkeys___0->mac, *(cprop + nmac), *(sprop + nmac));
#line 402
    choose_comp(& newkeys___0->comp, *(cprop + ncomp), *(sprop + ncomp));
#line 403
    if (ctos) {
#line 403
      tmp___1 = "client->server";
    } else {
#line 403
      tmp___1 = "server->client";
    }
#line 403
    debug("kex: %s %s %s %s", tmp___1, newkeys___0->enc.name, newkeys___0->mac.name,
          newkeys___0->comp.name);
#line 392
    mode ++;
  }
#line 409
  choose_kex(kex, *(cprop + 0), *(sprop + 0));
#line 410
  choose_hostkeyalg(kex, *(cprop + 1), *(sprop + 1));
#line 412
  need = 0U;
#line 413
  mode = 0U;
#line 413
  while (mode < 2U) {
#line 414
    newkeys___0 = kex->newkeys[mode];
#line 415
    if (need < newkeys___0->enc.key_len) {
#line 416
      need = newkeys___0->enc.key_len;
    }
#line 417
    if (need < newkeys___0->enc.block_size) {
#line 418
      need = newkeys___0->enc.block_size;
    }
#line 419
    if (need < newkeys___0->mac.key_len) {
#line 420
      need = newkeys___0->mac.key_len;
    }
#line 413
    mode ++;
  }
#line 423
  kex->we_need = need;
#line 426
  if (first_kex_follows) {
#line 426
    tmp___2 = proposals_match((char **)my, (char **)peer);
#line 426
    if (! tmp___2) {
#line 426
      if (! (datafellows & 8388608)) {
#line 428
        type = packet_read();
#line 429
        debug2("skipping next packet (type %u)", type);
      }
    }
  }
#line 432
  kex_prop_free(my);
#line 433
  kex_prop_free(peer);
#line 434
  return;
}
}
#line 436 "kex.c"
static u_char *derive_key(Kex *kex , int id , u_int need , u_char *hash , u_int hashlen ,
                          BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD_CTX md ;
  char c ;
  u_int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  void *tmp___3 ;

  {
#line 442
  c = (char )id;
#line 447
  mdsz = (int )(kex->evp_md)->md_size;
#line 447
  if (mdsz <= 0) {
#line 448
    fatal("bad kex md size %d", mdsz);
  }
#line 449
  tmp = xmalloc(((need + (u_int )(mdsz - 1)) / (u_int )mdsz) * (u_int )mdsz);
#line 449
  digest___1 = (u_char *)tmp;
#line 451
  buffer_init(& b);
#line 452
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 455
  EVP_DigestInit(& md, kex->evp_md);
#line 456
  if (! (datafellows & 262144)) {
#line 457
    tmp___0 = buffer_len(& b);
#line 457
    tmp___1 = buffer_ptr(& b);
#line 457
    EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
  }
#line 458
  EVP_DigestUpdate(& md, (void const   *)hash, hashlen);
#line 459
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 460
  EVP_DigestUpdate(& md, (void const   *)kex->session_id, kex->session_id_len);
#line 461
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 468
  have = (unsigned int )mdsz;
#line 468
  while (need > have) {
#line 469
    EVP_DigestInit(& md, kex->evp_md);
#line 470
    if (! (datafellows & 262144)) {
#line 471
      tmp___2 = buffer_len(& b);
#line 471
      tmp___3 = buffer_ptr(& b);
#line 471
      EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
    }
#line 472
    EVP_DigestUpdate(& md, (void const   *)hash, hashlen);
#line 473
    EVP_DigestUpdate(& md, (void const   *)digest___1, have);
#line 474
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 468
    have += (u_int )mdsz;
  }
#line 476
  buffer_free(& b);
#line 481
  return (digest___1);
}
}
#line 484 "kex.c"
Newkeys *current_keys[2]  ;
#line 487 "kex.c"
void kex_derive_keys(Kex *kex , u_char *hash , u_int hashlen , BIGNUM *shared_secret ) 
{ u_char *keys[6] ;
  u_int i ;
  u_int mode ;
  u_int ctos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 493
  i = 0U;
#line 493
  while (i < 6U) {
#line 494
    keys[i] = derive_key(kex, (int )(65U + i), kex->we_need, hash, hashlen, shared_secret);
#line 493
    i ++;
  }
#line 498
  debug2("kex_derive_keys");
#line 499
  mode = 0U;
#line 499
  while (mode < 2U) {
#line 500
    current_keys[mode] = kex->newkeys[mode];
#line 501
    kex->newkeys[mode] = (Newkeys *)((void *)0);
#line 502
    if (! kex->server) {
#line 502
      if (mode == 1U) {
#line 502
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 502
      if (kex->server) {
#line 502
        if (mode == 0U) {
#line 502
          tmp = 1;
        } else {
#line 502
          tmp = 0;
        }
      } else {
#line 502
        tmp = 0;
      }
    }
#line 502
    ctos = (unsigned int )tmp;
#line 504
    if (ctos) {
#line 504
      tmp___0 = 0;
    } else {
#line 504
      tmp___0 = 1;
    }
#line 504
    (current_keys[mode])->enc.iv = keys[tmp___0];
#line 505
    if (ctos) {
#line 505
      tmp___1 = 2;
    } else {
#line 505
      tmp___1 = 3;
    }
#line 505
    (current_keys[mode])->enc.key = keys[tmp___1];
#line 506
    if (ctos) {
#line 506
      tmp___2 = 4;
    } else {
#line 506
      tmp___2 = 5;
    }
#line 506
    (current_keys[mode])->mac.key = keys[tmp___2];
#line 499
    mode ++;
  }
#line 508
  return;
}
}
#line 510 "kex.c"
Newkeys *kex_get_newkeys(int mode ) 
{ Newkeys *ret___0 ;

  {
#line 515
  ret___0 = current_keys[mode];
#line 516
  current_keys[mode] = (Newkeys *)((void *)0);
#line 517
  return (ret___0);
}
}
#line 520 "kex.c"
void derive_ssh1_session_id(BIGNUM *host_modulus , BIGNUM *server_modulus , u_int8_t *cookie ,
                            u_int8_t *id ) 
{ EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int8_t nbuf[2048] ;
  u_int8_t obuf[64] ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 524
  tmp = EVP_md5();
#line 524
  evp_md = tmp;
#line 529
  EVP_DigestInit(& md, evp_md);
#line 531
  tmp___0 = BN_num_bits((BIGNUM const   *)host_modulus);
#line 531
  len = (tmp___0 + 7) / 8;
#line 532
  if (len < 64) {
#line 533
    fatal("%s: bad host modulus (len %d)", "derive_ssh1_session_id", len);
  } else {
#line 532
    if ((unsigned int )len > sizeof(nbuf)) {
#line 533
      fatal("%s: bad host modulus (len %d)", "derive_ssh1_session_id", len);
    }
  }
#line 534
  BN_bn2bin((BIGNUM const   *)host_modulus, nbuf);
#line 535
  EVP_DigestUpdate(& md, (void const   *)(nbuf), (unsigned int )len);
#line 537
  tmp___1 = BN_num_bits((BIGNUM const   *)server_modulus);
#line 537
  len = (tmp___1 + 7) / 8;
#line 538
  if (len < 64) {
#line 539
    fatal("%s: bad server modulus (len %d)", "derive_ssh1_session_id", len);
  } else {
#line 538
    if ((unsigned int )len > sizeof(nbuf)) {
#line 539
      fatal("%s: bad server modulus (len %d)", "derive_ssh1_session_id", len);
    }
  }
#line 540
  BN_bn2bin((BIGNUM const   *)server_modulus, nbuf);
#line 541
  EVP_DigestUpdate(& md, (void const   *)(nbuf), (unsigned int )len);
#line 543
  EVP_DigestUpdate(& md, (void const   *)cookie, 8U);
#line 545
  EVP_DigestFinal(& md, obuf, (unsigned int *)((void *)0));
#line 546
  memcpy((void * __restrict  )id, (void const   * __restrict  )(obuf), 16U);
#line 548
  memset((void *)(nbuf), 0, sizeof(nbuf));
#line 549
  memset((void *)(obuf), 0, sizeof(obuf));
#line 550
  memset((void *)(& md), 0, sizeof(md));
#line 551
  return;
}
}
#line 1 "mac.o"
#pragma merger(0,"./mac.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 55 "umac.h"
struct umac_ctx *umac_new(u_char *key ) ;
#line 65
int umac_update(struct umac_ctx *ctx , u_char *input___0 , long len ) ;
#line 68
int umac_final(struct umac_ctx *ctx , u_char *tag , u_char *nonce ) ;
#line 73
int umac_delete(struct umac_ctx *ctx ) ;
#line 50 "mac.c"
struct __anonstruct_macs_74 macs[8]  = 
#line 50 "mac.c"
  {      {(char *)"hmac-sha1", 1, & EVP_sha1, 0, -1, -1}, 
        {(char *)"hmac-sha1-96", 1, & EVP_sha1, 96, -1, -1}, 
        {(char *)"hmac-md5", 1, & EVP_md5, 0, -1, -1}, 
        {(char *)"hmac-md5-96", 1, & EVP_md5, 96, -1, -1}, 
        {(char *)"hmac-ripemd160", 1, & EVP_ripemd160, 0, -1, -1}, 
        {(char *)"hmac-ripemd160@openssh.com", 1, & EVP_ripemd160, 0, -1, -1}, 
        {(char *)"umac-64@openssh.com", 2, (EVP_MD const   *(*)(void))((void *)0), 0,
      128, 64}, 
        {(char *)((void *)0), 0, (EVP_MD const   *(*)(void))((void *)0), 0, -1, -1}};
#line 68 "mac.c"
static void mac_setup_by_id(Mac *mac , int which ) 
{ int evp_len ;

  {
#line 72
  mac->type = macs[which].type;
#line 73
  if (mac->type == 1) {
#line 74
    mac->evp_md = (*(macs[which].mdfunc))();
#line 75
    evp_len = (int )(mac->evp_md)->md_size;
#line 75
    if (evp_len <= 0) {
#line 76
      fatal("mac %s len %d", mac->name, evp_len);
    }
#line 77
    mac->mac_len = (unsigned int )evp_len;
#line 77
    mac->key_len = mac->mac_len;
  } else {
#line 79
    mac->mac_len = (unsigned int )(macs[which].len / 8);
#line 80
    mac->key_len = (unsigned int )(macs[which].key_len / 8);
#line 81
    mac->umac_ctx = (struct umac_ctx *)((void *)0);
  }
#line 83
  if (macs[which].truncatebits != 0) {
#line 84
    mac->mac_len = (unsigned int )(macs[which].truncatebits / 8);
  }
#line 85
  return;
}
}
#line 87 "mac.c"
int mac_setup(Mac *mac , char *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 92
  i = 0;
#line 92
  while (macs[i].name) {
#line 93
    if (0) {
#line 93
      __s1_len = strlen((char const   *)name);
#line 93
      __s2_len = strlen((char const   *)macs[i].name);
#line 93
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 93
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 93
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 93
            tmp___8 = 1;
          } else {
#line 93
            if (__s2_len >= 4U) {
#line 93
              tmp___8 = 1;
            } else {
#line 93
              tmp___8 = 0;
            }
          }
        } else {
#line 93
          tmp___8 = 0;
        }
      }
#line 93
      if (tmp___8) {
#line 93
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 93
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 93
        tmp___4 = tmp___7;
      }
    } else {
#line 93
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 93
      tmp___4 = tmp___7;
    }
#line 93
    if (tmp___4 == 0) {
#line 94
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 95
        mac_setup_by_id(mac, i);
      }
#line 96
      debug2("mac_setup: found %s", name);
#line 97
      return (0);
    }
#line 92
    i ++;
  }
#line 100
  debug2("mac_setup: unknown %s", name);
#line 101
  return (-1);
}
}
#line 104 "mac.c"
int mac_init(Mac *mac ) 
{ 

  {
#line 107
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 108
    fatal("mac_init: no key");
  }
#line 109
  switch (mac->type) {
  case 1: 
#line 111
  if ((unsigned int )mac->evp_md == (unsigned int )((void *)0)) {
#line 112
    return (-1);
  }
#line 113
  HMAC_Init(& mac->evp_ctx, (void const   *)mac->key, (int )mac->key_len, mac->evp_md);
#line 114
  return (0);
  case 2: 
#line 116
  mac->umac_ctx = umac_new(mac->key);
#line 117
  return (0);
  default: ;
#line 119
  return (-1);
  }
}
}
#line 126 "mac.c"
static u_char m[64]  ;
#line 123 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ u_char b[4] ;
  u_char nonce[8] ;

  {
#line 129
  if (mac->mac_len > sizeof(m)) {
#line 130
    fatal("mac_compute: mac too long %u %lu", mac->mac_len, (unsigned long )sizeof(m));
  }
#line 133
  switch (mac->type) {
  case 1: 
#line 135
  put_u32((void *)(b), seqno);
#line 137
  HMAC_Init(& mac->evp_ctx, (void const   *)((void *)0), 0, (EVP_MD const   *)((void *)0));
#line 138
  HMAC_Update(& mac->evp_ctx, (unsigned char const   *)(b), sizeof(b));
#line 139
  HMAC_Update(& mac->evp_ctx, (unsigned char const   *)data, (unsigned int )datalen);
#line 140
  HMAC_Final(& mac->evp_ctx, m, (unsigned int *)((void *)0));
#line 141
  break;
  case 2: 
#line 143
  put_u64((void *)(nonce), (unsigned long long )seqno);
#line 144
  umac_update(mac->umac_ctx, data, (long )datalen);
#line 145
  umac_final(mac->umac_ctx, m, (u_char *)(nonce));
#line 146
  break;
  default: 
#line 148
  fatal("mac_compute: unknown MAC type");
  }
#line 150
  return (m);
}
}
#line 153 "mac.c"
void mac_clear(Mac *mac ) 
{ 

  {
#line 156
  if (mac->type == 2) {
#line 157
    if ((unsigned int )mac->umac_ctx != (unsigned int )((void *)0)) {
#line 158
      umac_delete(mac->umac_ctx);
    }
  } else {
#line 159
    if ((unsigned int )mac->evp_md != (unsigned int )((void *)0)) {
#line 160
      HMAC_CTX_cleanup(& mac->evp_ctx);
    }
  }
#line 161
  mac->evp_md = (EVP_MD const   *)((void *)0);
#line 162
  mac->umac_ctx = (struct umac_ctx *)((void *)0);
#line 163
  return;
}
}
#line 167 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 172
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 173
    return (0);
  } else {
#line 172
    if (0) {
#line 172
      __s1_len = strlen(names);
#line 172
      __s2_len = strlen("");
#line 172
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 172
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 172
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 172
            tmp___8 = 1;
          } else {
#line 172
            if (__s2_len >= 4U) {
#line 172
              tmp___8 = 1;
            } else {
#line 172
              tmp___8 = 0;
            }
          }
        } else {
#line 172
          tmp___8 = 0;
        }
      }
#line 172
      if (tmp___8) {
#line 172
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 172
        tmp___7 = __builtin_strcmp(names, "");
#line 172
        tmp___4 = tmp___7;
      }
    } else {
#line 172
      tmp___7 = __builtin_strcmp(names, "");
#line 172
      tmp___4 = tmp___7;
    }
#line 172
    if (tmp___4 == 0) {
#line 173
      return (0);
    }
  }
#line 174
  cp = xstrdup(names);
#line 174
  maclist = cp;
#line 175
  tmp___24 = __strsep_g(& cp, ",");
#line 175
  p = tmp___24;
#line 175
  while (1) {
#line 175
    if (p) {
#line 175
      if (! ((int )*p != 0)) {
#line 175
        break;
      }
    } else {
#line 175
      break;
    }
#line 177
    tmp___41 = mac_setup((Mac *)((void *)0), p);
#line 177
    if (tmp___41 < 0) {
#line 178
      debug("bad mac %s [%s]", p, names);
#line 179
      xfree((void *)maclist);
#line 180
      return (0);
    } else {
#line 182
      debug3("mac ok: %s [%s]", p, names);
    }
#line 176
    tmp___40 = __strsep_g(& cp, ",");
#line 176
    p = tmp___40;
  }
#line 185
  debug3("macs ok: [%s]", names);
#line 186
  xfree((void *)maclist);
#line 187
  return (1);
}
}
#line 1 "uidswap.o"
#pragma merger(0,"./uidswap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 648 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 651
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 710
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 715
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 15 "uidswap.h"
void temporarily_use_uid(struct passwd *pw___0 ) ;
#line 16
void restore_uid(void) ;
#line 17
void permanently_set_uid(struct passwd *pw___0 ) ;
#line 44 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 45 "uidswap.c"
static gid_t saved_egid  =    (gid_t )0;
#line 49 "uidswap.c"
static int privileged  =    0;
#line 50 "uidswap.c"
static int temporarily_use_uid_effective  =    0;
#line 51 "uidswap.c"
static gid_t *saved_egroups  =    (gid_t *)((void *)0);
#line 51 "uidswap.c"
static gid_t *user_groups  =    (gid_t *)((void *)0);
#line 52 "uidswap.c"
static int saved_egroupslen  =    -1;
#line 52 "uidswap.c"
static int user_groupslen  =    -1;
#line 58 "uidswap.c"
void temporarily_use_uid(struct passwd *pw___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
#line 63
  saved_euid = geteuid();
#line 64
  saved_egid = getegid();
#line 65
  debug("temporarily_use_uid: %u/%u (e=%u/%u)", pw___0->pw_uid, pw___0->pw_gid, saved_euid,
        saved_egid);
#line 69
  if (saved_euid != 0U) {
#line 70
    privileged = 0;
#line 71
    return;
  }
#line 81
  privileged = 1;
#line 82
  temporarily_use_uid_effective = 1;
#line 84
  saved_egroupslen = getgroups(0, (__gid_t *)((void *)0));
#line 85
  if (saved_egroupslen < 0) {
#line 86
    tmp = __errno_location();
#line 86
    tmp___0 = strerror(*tmp);
#line 86
    fatal("getgroups: %.100s", tmp___0);
  }
#line 87
  if (saved_egroupslen > 0) {
#line 88
    tmp___1 = xrealloc((void *)saved_egroups, (unsigned int )saved_egroupslen, sizeof(gid_t ));
#line 88
    saved_egroups = (gid_t *)tmp___1;
#line 90
    tmp___4 = getgroups(saved_egroupslen, saved_egroups);
#line 90
    if (tmp___4 < 0) {
#line 91
      tmp___2 = __errno_location();
#line 91
      tmp___3 = strerror(*tmp___2);
#line 91
      fatal("getgroups: %.100s", tmp___3);
    }
  } else {
#line 93
    if ((unsigned int )saved_egroups != (unsigned int )((void *)0)) {
#line 94
      xfree((void *)saved_egroups);
    }
  }
#line 98
  if (user_groupslen == -1) {
#line 99
    tmp___7 = initgroups((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 99
    if (tmp___7 < 0) {
#line 100
      tmp___5 = __errno_location();
#line 100
      tmp___6 = strerror(*tmp___5);
#line 100
      fatal("initgroups: %s: %.100s", pw___0->pw_name, tmp___6);
    }
#line 103
    user_groupslen = getgroups(0, (__gid_t *)((void *)0));
#line 104
    if (user_groupslen < 0) {
#line 105
      tmp___8 = __errno_location();
#line 105
      tmp___9 = strerror(*tmp___8);
#line 105
      fatal("getgroups: %.100s", tmp___9);
    }
#line 106
    if (user_groupslen > 0) {
#line 107
      tmp___10 = xrealloc((void *)user_groups, (unsigned int )user_groupslen, sizeof(gid_t ));
#line 107
      user_groups = (gid_t *)tmp___10;
#line 109
      tmp___13 = getgroups(user_groupslen, user_groups);
#line 109
      if (tmp___13 < 0) {
#line 110
        tmp___11 = __errno_location();
#line 110
        tmp___12 = strerror(*tmp___11);
#line 110
        fatal("getgroups: %.100s", tmp___12);
      }
    } else {
#line 112
      if (user_groups) {
#line 113
        xfree((void *)user_groups);
      }
    }
  }
#line 117
  tmp___16 = setgroups((unsigned int )user_groupslen, (__gid_t const   *)user_groups);
#line 117
  if (tmp___16 < 0) {
#line 118
    tmp___14 = __errno_location();
#line 118
    tmp___15 = strerror(*tmp___14);
#line 118
    fatal("setgroups: %.100s", tmp___15);
  }
#line 127
  tmp___19 = setegid(pw___0->pw_gid);
#line 127
  if (tmp___19 < 0) {
#line 128
    tmp___17 = __errno_location();
#line 128
    tmp___18 = strerror(*tmp___17);
#line 128
    fatal("setegid %u: %.100s", pw___0->pw_gid, tmp___18);
  }
#line 130
  tmp___22 = seteuid(pw___0->pw_uid);
#line 130
  if (tmp___22 == -1) {
#line 131
    tmp___20 = __errno_location();
#line 131
    tmp___21 = strerror(*tmp___20);
#line 131
    fatal("seteuid %u: %.100s", pw___0->pw_uid, tmp___21);
  }
#line 133
  return;
}
}
#line 135 "uidswap.c"
void permanently_drop_suid(uid_t uid ) 
{ uid_t old_uid ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
#line 138
  tmp = getuid();
#line 138
  old_uid = tmp;
#line 140
  debug("permanently_drop_suid: %u", uid);
#line 142
  tmp___2 = setresuid(uid, uid, uid);
#line 142
  if (tmp___2 < 0) {
#line 143
    tmp___0 = __errno_location();
#line 143
    tmp___1 = strerror(*tmp___0);
#line 143
    fatal("setresuid %u: %.100s", uid, tmp___1);
  }
#line 158
  if (old_uid != uid) {
#line 158
    tmp___3 = setuid(old_uid);
#line 158
    if (tmp___3 != -1) {
#line 160
      fatal("%s: was able to restore old [e]uid", "permanently_drop_suid");
    } else {
#line 158
      tmp___4 = seteuid(old_uid);
#line 158
      if (tmp___4 != -1) {
#line 160
        fatal("%s: was able to restore old [e]uid", "permanently_drop_suid");
      }
    }
  }
#line 164
  tmp___7 = getuid();
#line 164
  if (tmp___7 != uid) {
#line 165
    tmp___5 = geteuid();
#line 165
    tmp___6 = getuid();
#line 165
    fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_drop_suid",
          tmp___6, tmp___5, uid);
  } else {
#line 164
    tmp___8 = geteuid();
#line 164
    if (tmp___8 != uid) {
#line 165
      tmp___5 = geteuid();
#line 165
      tmp___6 = getuid();
#line 165
      fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_drop_suid",
            tmp___6, tmp___5, uid);
    }
  }
#line 168
  return;
}
}
#line 173 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 177
  if (! privileged) {
#line 178
    debug("restore_uid: (unprivileged)");
#line 179
    return;
  }
#line 181
  if (! temporarily_use_uid_effective) {
#line 182
    fatal("restore_uid: temporarily_use_uid not effective");
  }
#line 185
  debug("restore_uid: %u/%u", saved_euid, saved_egid);
#line 187
  tmp___1 = seteuid(saved_euid);
#line 187
  if (tmp___1 < 0) {
#line 188
    tmp = __errno_location();
#line 188
    tmp___0 = strerror(*tmp);
#line 188
    fatal("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 189
  tmp___4 = setegid(saved_egid);
#line 189
  if (tmp___4 < 0) {
#line 190
    tmp___2 = __errno_location();
#line 190
    tmp___3 = strerror(*tmp___2);
#line 190
    fatal("setegid %u: %.100s", saved_egid, tmp___3);
  }
#line 201
  tmp___7 = setgroups((unsigned int )saved_egroupslen, (__gid_t const   *)saved_egroups);
#line 201
  if (tmp___7 < 0) {
#line 202
    tmp___5 = __errno_location();
#line 202
    tmp___6 = strerror(*tmp___5);
#line 202
    fatal("setgroups: %.100s", tmp___6);
  }
#line 203
  temporarily_use_uid_effective = 0;
#line 204
  return;
}
}
#line 210 "uidswap.c"
void permanently_set_uid(struct passwd *pw___0 ) 
{ uid_t old_uid ;
  __uid_t tmp ;
  gid_t old_gid ;
  __gid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __gid_t tmp___9 ;
  __gid_t tmp___10 ;
  __gid_t tmp___11 ;
  __gid_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  __uid_t tmp___15 ;
  __uid_t tmp___16 ;
  __uid_t tmp___17 ;
  __uid_t tmp___18 ;

  {
#line 213
  tmp = getuid();
#line 213
  old_uid = tmp;
#line 214
  tmp___0 = getgid();
#line 214
  old_gid = tmp___0;
#line 216
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 217
    fatal("permanently_set_uid: no user given");
  }
#line 218
  if (temporarily_use_uid_effective) {
#line 219
    fatal("permanently_set_uid: temporarily_use_uid effective");
  }
#line 220
  debug("permanently_set_uid: %u/%u", pw___0->pw_uid, pw___0->pw_gid);
#line 224
  tmp___3 = setresgid(pw___0->pw_gid, pw___0->pw_gid, pw___0->pw_gid);
#line 224
  if (tmp___3 < 0) {
#line 225
    tmp___1 = __errno_location();
#line 225
    tmp___2 = strerror(*tmp___1);
#line 225
    fatal("setresgid %u: %.100s", pw___0->pw_gid, tmp___2);
  }
#line 247
  tmp___6 = setresuid(pw___0->pw_uid, pw___0->pw_uid, pw___0->pw_uid);
#line 247
  if (tmp___6 < 0) {
#line 248
    tmp___4 = __errno_location();
#line 248
    tmp___5 = strerror(*tmp___4);
#line 248
    fatal("setresuid %u: %.100s", pw___0->pw_uid, tmp___5);
  }
#line 263
  if (old_gid != pw___0->pw_gid) {
#line 263
    if (pw___0->pw_uid != 0U) {
#line 263
      tmp___7 = setgid(old_gid);
#line 263
      if (tmp___7 != -1) {
#line 265
        fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
      } else {
#line 263
        tmp___8 = setegid(old_gid);
#line 263
        if (tmp___8 != -1) {
#line 265
          fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
        }
      }
    }
  }
#line 269
  tmp___11 = getgid();
#line 269
  if (tmp___11 != pw___0->pw_gid) {
#line 270
    tmp___9 = getegid();
#line 270
    tmp___10 = getgid();
#line 270
    fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
          tmp___10, tmp___9, pw___0->pw_gid);
  } else {
#line 269
    tmp___12 = getegid();
#line 269
    if (tmp___12 != pw___0->pw_gid) {
#line 270
      tmp___9 = getegid();
#line 270
      tmp___10 = getgid();
#line 270
      fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
            tmp___10, tmp___9, pw___0->pw_gid);
    }
  }
#line 277
  if (old_uid != pw___0->pw_uid) {
#line 277
    tmp___13 = setuid(old_uid);
#line 277
    if (tmp___13 != -1) {
#line 279
      fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
    } else {
#line 277
      tmp___14 = seteuid(old_uid);
#line 277
      if (tmp___14 != -1) {
#line 279
        fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
      }
    }
  }
#line 283
  tmp___17 = getuid();
#line 283
  if (tmp___17 != pw___0->pw_uid) {
#line 284
    tmp___15 = geteuid();
#line 284
    tmp___16 = getuid();
#line 284
    fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
          tmp___16, tmp___15, pw___0->pw_uid);
  } else {
#line 283
    tmp___18 = geteuid();
#line 283
    if (tmp___18 != pw___0->pw_uid) {
#line 284
      tmp___15 = geteuid();
#line 284
      tmp___16 = getuid();
#line 284
      fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
            tmp___16, tmp___15, pw___0->pw_uid);
    }
  }
#line 288
  return;
}
}
#line 1 "uuencode.o"
#pragma merger(0,"./uuencode.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 29 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , u_int len ) ;
#line 36 "uuencode.c"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 40
  tmp = __b64_ntop(src, srclength, target, targsize);
#line 40
  return (tmp);
}
}
#line 43 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded___0 ;
  char *p ;

  {
#line 50
  encoded___0 = xstrdup(src);
#line 52
  p = encoded___0;
#line 52
  while (1) {
#line 52
    if (! ((int )*p == 32)) {
#line 52
      if (! ((int )*p == 9)) {
#line 52
        break;
      }
    }
#line 52
    p ++;
  }
#line 54
  while (1) {
#line 54
    if ((int )*p != 0) {
#line 54
      if ((int )*p != 32) {
#line 54
        if (! ((int )*p != 9)) {
#line 54
          break;
        }
      } else {
#line 54
        break;
      }
    } else {
#line 54
      break;
    }
#line 54
    p ++;
  }
#line 57
  *p = (char )'\000';
#line 58
  len = __b64_pton((char const   *)encoded___0, target, targsize);
#line 59
  xfree((void *)encoded___0);
#line 60
  return (len);
}
}
#line 63 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , u_int len ) 
{ char *buf___1 ;
  int i ;
  int n___0 ;
  void *tmp ;

  {
#line 69
  if (len > 65536U) {
#line 70
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"dump_base64: len > 65536\n");
#line 71
    return;
  }
#line 73
  tmp = xmalloc(2U * len);
#line 73
  buf___1 = (char *)tmp;
#line 74
  n___0 = uuencode((u_char const   *)data, len, buf___1, 2U * len);
#line 75
  i = 0;
#line 75
  while (i < n___0) {
#line 76
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 77
    if (i % 70 == 69) {
#line 78
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 75
    i ++;
  }
#line 80
  if (i % 70 != 69) {
#line 81
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 82
  xfree((void *)buf___1);
#line 83
  return;
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
#line 1 "misc.o"
#pragma merger(0,"./misc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 376 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 441
extern int fgetc(FILE *__stream ) ;
#line 729
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 20 "misc.h"
char *chop(char *s ) ;
#line 21
char *strdelim(char **s ) ;
#line 23
int unset_nonblock(int fd ) ;
#line 25
int a2port(char const   *s ) ;
#line 26
int a2tun(char const   *s , int *remote___0 ) ;
#line 27
char *put_host_port(char const   *host , u_short port___0 ) ;
#line 28
char *hpdelim(char **cp ) ;
#line 29
char *cleanhostname(char *host ) ;
#line 30
char *colon(char *cp ) ;
#line 31
long convtime(char const   *s ) ;
#line 32
char *tilde_expand_filename(char const   *filename , uid_t uid ) ;
#line 33
char *percent_expand(char const   *string  , ...) ;
#line 35
void sanitise_stdfd(void) ;
#line 39
struct passwd *pwcopy(struct passwd *pw___0 ) ;
#line 48
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) ;
#line 50
void ( /* format attribute */  replacearg)(arglist *args , u_int which , char *fmt 
                                           , ...) ;
#line 52
void freeargs(arglist *args ) ;
#line 54
int tun_open(int tun , int mode ) ;
#line 60 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 63
  t = s;
#line 64
  while (*t) {
#line 65
    if ((int )*t == 10) {
#line 66
      *t = (char )'\000';
#line 67
      return (s);
    } else {
#line 65
      if ((int )*t == 13) {
#line 66
        *t = (char )'\000';
#line 67
        return (s);
      }
    }
#line 69
    t ++;
  }
#line 71
  return (s);
}
}
#line 76 "misc.c"
int set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 81
  val = fcntl(fd, 3, 0);
#line 82
  if (val < 0) {
#line 83
    tmp = __errno_location();
#line 83
    tmp___0 = strerror(*tmp);
#line 83
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 84
    return (-1);
  }
#line 86
  if (val & 2048) {
#line 87
    debug3("fd %d is O_NONBLOCK", fd);
#line 88
    return (0);
  }
#line 90
  debug2("fd %d setting O_NONBLOCK", fd);
#line 91
  val |= 2048;
#line 92
  tmp___3 = fcntl(fd, 4, val);
#line 92
  if (tmp___3 == -1) {
#line 93
    tmp___1 = __errno_location();
#line 93
    tmp___2 = strerror(*tmp___1);
#line 93
    debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
#line 95
    return (-1);
  }
#line 97
  return (0);
}
}
#line 100 "misc.c"
int unset_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 105
  val = fcntl(fd, 3, 0);
#line 106
  if (val < 0) {
#line 107
    tmp = __errno_location();
#line 107
    tmp___0 = strerror(*tmp);
#line 107
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 108
    return (-1);
  }
#line 110
  if (! (val & 2048)) {
#line 111
    debug3("fd %d is not O_NONBLOCK", fd);
#line 112
    return (0);
  }
#line 114
  debug("fd %d clearing O_NONBLOCK", fd);
#line 115
  val &= -2049;
#line 116
  tmp___3 = fcntl(fd, 4, val);
#line 116
  if (tmp___3 == -1) {
#line 117
    tmp___1 = __errno_location();
#line 117
    tmp___2 = strerror(*tmp___1);
#line 117
    debug("fcntl(%d, F_SETFL, ~O_NONBLOCK): %s", fd, tmp___2);
#line 119
    return (-1);
  }
#line 121
  return (0);
}
}
#line 124 "misc.c"
char const   *ssh_gai_strerror(int gaierr ) 
{ int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 127
  if (gaierr == -11) {
#line 128
    tmp = __errno_location();
#line 128
    tmp___0 = strerror(*tmp);
#line 128
    return ((char const   *)tmp___0);
  }
#line 129
  tmp___1 = gai_strerror(gaierr);
#line 129
  return (tmp___1);
}
}
#line 133 "misc.c"
void set_nodelay(int fd ) 
{ int opt ;
  socklen_t optlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 139
  optlen = sizeof(opt);
#line 140
  tmp___1 = getsockopt(fd, 6, 1, (void * __restrict  )(& opt), (socklen_t * __restrict  )(& optlen));
#line 140
  if (tmp___1 == -1) {
#line 141
    tmp = __errno_location();
#line 141
    tmp___0 = strerror(*tmp);
#line 141
    debug("getsockopt TCP_NODELAY: %.100s", tmp___0);
#line 142
    return;
  }
#line 144
  if (opt == 1) {
#line 145
    debug2("fd %d is TCP_NODELAY", fd);
#line 146
    return;
  }
#line 148
  opt = 1;
#line 149
  debug2("fd %d setting TCP_NODELAY", fd);
#line 150
  tmp___4 = setsockopt(fd, 6, 1, (void const   *)(& opt), sizeof(opt));
#line 150
  if (tmp___4 == -1) {
#line 151
    tmp___2 = __errno_location();
#line 151
    tmp___3 = strerror(*tmp___2);
#line 151
    error("setsockopt TCP_NODELAY: %.100s", tmp___3);
  }
#line 152
  return;
}
}
#line 159 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  size_t tmp___31 ;
  char *tmp___63 ;
  unsigned int tmp___95 ;
  unsigned int tmp___127 ;

  {
#line 163
  wspace = 0;
#line 165
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 166
    return ((char *)((void *)0));
  }
#line 168
  old = *s;
#line 170
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n\"=");
#line 170
  *s = tmp___30;
#line 171
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 172
    return (old);
  }
#line 174
  if ((int )*(*(s + 0)) == 34) {
#line 175
    tmp___31 = strlen((char const   *)*s);
#line 175
    memmove((void *)*s, (void const   *)(*s + 1), tmp___31);
#line 177
    tmp___63 = __builtin_strpbrk((char const   *)*s, "\"");
#line 177
    *s = tmp___63;
#line 177
    if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 178
      return ((char *)((void *)0));
    } else {
#line 180
      *(*(s + 0)) = (char )'\000';
#line 181
      return (old);
    }
  }
#line 186
  if ((int )*(*(s + 0)) == 61) {
#line 187
    wspace = 1;
  }
#line 188
  *(*(s + 0)) = (char )'\000';
#line 191
  tmp___95 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 191
  *s += tmp___95 + 1U;
#line 192
  if ((int )*(*(s + 0)) == 61) {
#line 192
    if (! wspace) {
#line 193
      tmp___127 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 193
      *s += tmp___127 + 1U;
    }
  }
#line 195
  return (old);
}
}
#line 198 "misc.c"
struct passwd *pwcopy(struct passwd *pw___0 ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 201
  tmp = xcalloc(1U, sizeof(*copy));
#line 201
  copy = (struct passwd *)tmp;
#line 203
  copy->pw_name = xstrdup((char const   *)pw___0->pw_name);
#line 204
  copy->pw_passwd = xstrdup((char const   *)pw___0->pw_passwd);
#line 205
  copy->pw_gecos = xstrdup((char const   *)pw___0->pw_gecos);
#line 206
  copy->pw_uid = pw___0->pw_uid;
#line 207
  copy->pw_gid = pw___0->pw_gid;
#line 217
  copy->pw_dir = xstrdup((char const   *)pw___0->pw_dir);
#line 218
  copy->pw_shell = xstrdup((char const   *)pw___0->pw_shell);
#line 219
  return (copy);
}
}
#line 227 "misc.c"
int a2port(char const   *s ) 
{ long long port___0 ;
  char const   *errstr ;

  {
#line 233
  port___0 = strtonum(s, 0LL, 65535LL, & errstr);
#line 234
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
#line 235
    return (-1);
  }
#line 236
  return ((int )port___0);
}
}
#line 239 "misc.c"
int a2tun(char const   *s , int *remote___0 ) 
{ char const   *errstr ;
  char *sp ;
  char *ep ;
  int tun ;
  int tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long long tmp___4 ;

  {
#line 242
  errstr = (char const   *)((void *)0);
#line 246
  if ((unsigned int )remote___0 != (unsigned int )((void *)0)) {
#line 247
    *remote___0 = 2147483647;
#line 248
    sp = xstrdup(s);
#line 249
    tmp___1 = __builtin_strchr(sp, ':');
#line 249
    ep = tmp___1;
#line 249
    if ((unsigned int )ep == (unsigned int )((void *)0)) {
#line 250
      xfree((void *)sp);
#line 251
      tmp = a2tun(s, (int *)((void *)0));
#line 251
      return (tmp);
    }
#line 253
    *(ep + 0) = (char )'\000';
#line 253
    ep ++;
#line 254
    *remote___0 = a2tun((char const   *)ep, (int *)((void *)0));
#line 255
    tun = a2tun((char const   *)sp, (int *)((void *)0));
#line 256
    xfree((void *)sp);
#line 257
    if (*remote___0 == 2147483646) {
#line 257
      tmp___2 = *remote___0;
    } else {
#line 257
      tmp___2 = tun;
    }
#line 257
    return (tmp___2);
  }
#line 260
  tmp___3 = strcasecmp(s, "any");
#line 260
  if (tmp___3 == 0) {
#line 261
    return (2147483647);
  }
#line 263
  tmp___4 = strtonum(s, 0LL, 2147483645LL, & errstr);
#line 263
  tun = (int )tmp___4;
#line 264
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
#line 265
    return (2147483646);
  }
#line 267
  return (tun);
}
}
#line 297 "misc.c"
long convtime(char const   *s ) 
{ long total ;
  long secs ;
  char const   *p ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 304
  tmp = __errno_location();
#line 304
  *tmp = 0;
#line 305
  total = 0L;
#line 306
  p = s;
#line 308
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 309
    return (-1L);
  } else {
#line 308
    if ((int const   )*p == 0) {
#line 309
      return (-1L);
    }
  }
#line 311
  while (*p) {
#line 312
    secs = strtol((char const   * __restrict  )p, (char ** __restrict  )(& endp),
                  10);
#line 313
    if ((unsigned int )p == (unsigned int )endp) {
#line 316
      return (-1L);
    } else {
#line 313
      tmp___0 = __errno_location();
#line 313
      if (*tmp___0 == 34) {
#line 313
        if (secs == (-0x7FFFFFFF-1)) {
#line 316
          return (-1L);
        } else {
#line 313
          if (secs == 2147483647L) {
#line 316
            return (-1L);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 313
        if (secs < 0L) {
#line 316
          return (-1L);
        }
      }
    }
#line 318
    tmp___1 = endp;
#line 318
    endp ++;
#line 318
    switch ((int )*tmp___1) {
    case 0: 
#line 320
    endp --;
#line 321
    break;
    case 115: 
    case 83: 
#line 324
    break;
    case 109: 
    case 77: 
#line 327
    secs *= 60L;
#line 328
    break;
    case 104: 
    case 72: 
#line 331
    secs *= 3600L;
#line 332
    break;
    case 100: 
    case 68: 
#line 335
    secs *= 86400L;
#line 336
    break;
    case 119: 
    case 87: 
#line 339
    secs *= 604800L;
#line 340
    break;
    default: ;
#line 342
    return (-1L);
    }
#line 344
    total += secs;
#line 345
    if (total < 0L) {
#line 346
      return (-1L);
    }
#line 347
    p = (char const   *)endp;
  }
#line 350
  return (total);
}
}
#line 357 "misc.c"
char *put_host_port(char const   *host , u_short port___0 ) 
{ char *hoststr ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 362
  if ((int )port___0 == 0) {
#line 363
    tmp = xstrdup(host);
#line 363
    return (tmp);
  } else {
#line 362
    if ((int )port___0 == 22) {
#line 363
      tmp = xstrdup(host);
#line 363
      return (tmp);
    }
  }
#line 364
  tmp___2 = asprintf((char ** __restrict  )(& hoststr), (char const   * __restrict  )"[%s]:%d",
                     host, (int )port___0);
#line 364
  if (tmp___2 < 0) {
#line 365
    tmp___0 = __errno_location();
#line 365
    tmp___1 = strerror(*tmp___0);
#line 365
    fatal("put_host_port: asprintf: %s", tmp___1);
  }
#line 366
  debug3("put_host_port: %s", hoststr);
#line 367
  return (hoststr);
}
}
#line 377 "misc.c"
char *hpdelim(char **cp ) 
{ char *s ;
  char *old ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___33 ;

  {
#line 382
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 383
    return ((char *)((void *)0));
  } else {
#line 382
    if ((unsigned int )*cp == (unsigned int )((void *)0)) {
#line 383
      return ((char *)((void *)0));
    }
  }
#line 385
  s = *cp;
#line 385
  old = s;
#line 386
  if ((int )*s == 91) {
#line 387
    tmp___0 = __builtin_strchr(s, ']');
#line 387
    s = tmp___0;
#line 387
    if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 388
      return ((char *)((void *)0));
    } else {
#line 390
      s ++;
    }
  } else {
#line 391
    tmp___33 = __builtin_strpbrk((char const   *)s, ":/");
#line 391
    s = tmp___33;
#line 391
    if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 392
      tmp___1 = strlen((char const   *)*cp);
#line 392
      s = *cp + tmp___1;
    }
  }
#line 394
  switch ((int )*s) {
  case 0: 
#line 396
  *cp = (char *)((void *)0);
#line 397
  break;
  case 58: 
  case 47: 
#line 401
  *s = (char )'\000';
#line 402
  *cp = s + 1;
#line 403
  break;
  default: ;
#line 406
  return ((char *)((void *)0));
  }
#line 409
  return (old);
}
}
#line 412 "misc.c"
char *cleanhostname(char *host ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 415
  if ((int )*host == 91) {
#line 415
    tmp___0 = strlen((char const   *)host);
#line 415
    if ((int )*(host + (tmp___0 - 1U)) == 93) {
#line 416
      tmp = strlen((char const   *)host);
#line 416
      *(host + (tmp - 1U)) = (char )'\000';
#line 417
      return (host + 1);
    } else {
#line 419
      return (host);
    }
  } else {
#line 419
    return (host);
  }
}
}
#line 422 "misc.c"
char *colon(char *cp ) 
{ int flag ;

  {
#line 425
  flag = 0;
#line 427
  if ((int )*cp == 58) {
#line 428
    return ((char *)0);
  }
#line 429
  if ((int )*cp == 91) {
#line 430
    flag = 1;
  }
#line 432
  while (*cp) {
#line 433
    if ((int )*cp == 64) {
#line 433
      if ((int )*(cp + 1) == 91) {
#line 434
        flag = 1;
      }
    }
#line 435
    if ((int )*cp == 93) {
#line 435
      if ((int )*(cp + 1) == 58) {
#line 435
        if (flag) {
#line 436
          return (cp + 1);
        }
      }
    }
#line 437
    if ((int )*cp == 58) {
#line 437
      if (! flag) {
#line 438
        return (cp);
      }
    }
#line 439
    if ((int )*cp == 47) {
#line 440
      return ((char *)0);
    }
#line 432
    cp ++;
  }
#line 442
  return ((char *)0);
}
}
#line 446 "misc.c"
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) 
{ va_list ap ;
  char *cp ;
  u_int nalloc ;
  int r ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 454
  __builtin_va_start(ap, fmt);
#line 455
  r = vasprintf((char ** __restrict  )(& cp), (char const   * __restrict  )fmt, ap);
#line 456
  __builtin_va_end(ap);
#line 457
  if (r == -1) {
#line 458
    fatal("addargs: argument too long");
  }
#line 460
  nalloc = args->nalloc;
#line 461
  if ((unsigned int )args->list == (unsigned int )((void *)0)) {
#line 462
    nalloc = 32U;
#line 463
    args->num = 0U;
  } else {
#line 464
    if (args->num + 2U >= nalloc) {
#line 465
      nalloc *= 2U;
    }
  }
#line 467
  tmp = xrealloc((void *)args->list, nalloc, sizeof(char *));
#line 467
  args->list = (char **)tmp;
#line 468
  args->nalloc = nalloc;
#line 469
  tmp___0 = args->num;
#line 469
  (args->num) ++;
#line 469
  *(args->list + tmp___0) = cp;
#line 470
  *(args->list + args->num) = (char *)((void *)0);
#line 471
  return;
}
}
#line 473 "misc.c"
void ( /* format attribute */  replacearg)(arglist *args , u_int which , char *fmt 
                                           , ...) 
{ va_list ap ;
  char *cp ;
  int r ;

  {
#line 480
  __builtin_va_start(ap, fmt);
#line 481
  r = vasprintf((char ** __restrict  )(& cp), (char const   * __restrict  )fmt, ap);
#line 482
  __builtin_va_end(ap);
#line 483
  if (r == -1) {
#line 484
    fatal("replacearg: argument too long");
  }
#line 486
  if (which >= args->num) {
#line 487
    fatal("replacearg: tried to replace invalid arg %d >= %d", which, args->num);
  }
#line 489
  xfree((void *)*(args->list + which));
#line 490
  *(args->list + which) = cp;
#line 491
  return;
}
}
#line 493 "misc.c"
void freeargs(arglist *args ) 
{ u_int i ;

  {
#line 498
  if ((unsigned int )args->list != (unsigned int )((void *)0)) {
#line 499
    i = 0U;
#line 499
    while (i < args->num) {
#line 500
      xfree((void *)*(args->list + i));
#line 499
      i ++;
    }
#line 501
    xfree((void *)args->list);
#line 502
    args->num = 0U;
#line 502
    args->nalloc = args->num;
#line 503
    args->list = (char **)((void *)0);
  }
#line 505
  return;
}
}
#line 511 "misc.c"
char *tilde_expand_filename(char const   *filename , uid_t uid ) 
{ char const   *path ;
  char user[128] ;
  char ret___0[4096] ;
  struct passwd *pw___0 ;
  u_int len ;
  u_int slash ;
  char *tmp ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
#line 519
  if ((int const   )*filename != 126) {
#line 520
    tmp = xstrdup(filename);
#line 520
    return (tmp);
  }
#line 521
  filename ++;
#line 523
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 523
  path = (char const   *)tmp___1;
#line 524
  if ((unsigned int )path != (unsigned int )((void *)0)) {
#line 524
    if ((unsigned int )path > (unsigned int )filename) {
#line 525
      slash = (unsigned int )(path - filename);
#line 526
      if (slash > sizeof(user) - 1U) {
#line 527
        fatal("tilde_expand_filename: ~username too long");
      }
#line 528
      memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, slash);
#line 529
      user[slash] = (char )'\000';
#line 530
      pw___0 = getpwnam((char const   *)(user));
#line 530
      if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 531
        fatal("tilde_expand_filename: No such user %s", user);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 532
    pw___0 = getpwuid(uid);
#line 532
    if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 533
      fatal("tilde_expand_filename: No such uid %ld", (long )uid);
    }
  }
#line 535
  tmp___2 = strlcpy(ret___0, (char const   *)pw___0->pw_dir, sizeof(ret___0));
#line 535
  if (tmp___2 >= sizeof(ret___0)) {
#line 536
    fatal("tilde_expand_filename: Path too long");
  }
#line 539
  len = strlen((char const   *)pw___0->pw_dir);
#line 540
  if (len == 0U) {
    goto _L___0;
  } else {
#line 540
    if ((int )*(pw___0->pw_dir + (len - 1U)) != 47) {
      _L___0: /* CIL Label */ 
#line 540
      tmp___3 = strlcat(ret___0, "/", sizeof(ret___0));
#line 540
      if (tmp___3 >= sizeof(ret___0)) {
#line 542
        fatal("tilde_expand_filename: Path too long");
      }
    }
  }
#line 545
  if ((unsigned int )path != (unsigned int )((void *)0)) {
#line 546
    filename = path + 1;
  }
#line 547
  tmp___4 = strlcat(ret___0, filename, sizeof(ret___0));
#line 547
  if (tmp___4 >= sizeof(ret___0)) {
#line 548
    fatal("tilde_expand_filename: Path too long");
  }
#line 550
  tmp___5 = xstrdup((char const   *)(ret___0));
#line 550
  return (tmp___5);
}
}
#line 559 "misc.c"
char *percent_expand(char const   *string  , ...) 
{ struct __anonstruct_keys_56 keys[16] ;
  u_int num_keys ;
  u_int i ;
  u_int j ;
  char buf___1[4096] ;
  va_list ap ;
  u_int tmp ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 572
  __builtin_va_start(ap, string);
#line 573
  num_keys = 0U;
#line 573
  while (num_keys < 16U) {
#line 574
    keys[num_keys].key = __builtin_va_arg(ap, char *);
#line 575
    if ((unsigned int )keys[num_keys].key == (unsigned int )((void *)0)) {
#line 576
      break;
    }
#line 577
    keys[num_keys].repl = __builtin_va_arg(ap, char *);
#line 578
    if ((unsigned int )keys[num_keys].repl == (unsigned int )((void *)0)) {
#line 579
      fatal("percent_expand: NULL replacement");
    }
#line 573
    num_keys ++;
  }
#line 581
  __builtin_va_end(ap);
#line 583
  if (num_keys >= 16U) {
#line 584
    fatal("percent_expand: too many keys");
  }
#line 587
  buf___1[0] = (char )'\000';
#line 588
  i = 0U;
#line 588
  while ((int const   )*string != 0) {
#line 589
    if ((int const   )*string != 37) {
      append: 
#line 591
      tmp = i;
#line 591
      i ++;
#line 591
      buf___1[tmp] = (char )*string;
#line 592
      if (i >= sizeof(buf___1)) {
#line 593
        fatal("percent_expand: string too long");
      }
#line 594
      buf___1[i] = (char )'\000';
      goto __Cont;
    }
#line 597
    string ++;
#line 598
    if ((int const   )*string == 37) {
      goto append;
    }
#line 600
    j = 0U;
#line 600
    while (j < num_keys) {
#line 601
      tmp___1 = __builtin_strchr((char *)keys[j].key, (int )*string);
#line 601
      if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
#line 602
        i = strlcat(buf___1, keys[j].repl, sizeof(buf___1));
#line 603
        if (i >= sizeof(buf___1)) {
#line 604
          fatal("percent_expand: string too long");
        }
#line 605
        break;
      }
#line 600
      j ++;
    }
#line 608
    if (j >= num_keys) {
#line 609
      fatal("percent_expand: unknown key %%%c", *string);
    }
    __Cont: /* CIL Label */ 
#line 588
    string ++;
  }
#line 611
  tmp___2 = xstrdup((char const   *)(buf___1));
#line 611
  return (tmp___2);
}
}
#line 619 "misc.c"
int read_keyfile_line(FILE *f , char const   *filename , char *buf___1 , size_t bufsz ,
                      u_long *lineno ) 
{ int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 623
  while (1) {
#line 623
    tmp___3 = fgets((char * __restrict  )buf___1, (int )bufsz, (FILE * __restrict  )f);
#line 623
    if (! ((unsigned int )tmp___3 != (unsigned int )((void *)0))) {
#line 623
      break;
    }
#line 624
    if ((int )*(buf___1 + 0) == 0) {
#line 625
      continue;
    }
#line 626
    (*lineno) ++;
#line 627
    tmp___1 = strlen((char const   *)buf___1);
#line 627
    if ((int )*(buf___1 + (tmp___1 - 1U)) == 10) {
#line 628
      return (0);
    } else {
#line 627
      tmp___2 = feof(f);
#line 627
      if (tmp___2) {
#line 628
        return (0);
      } else {
#line 630
        debug("%s: %s line %lu exceeds size limit", "read_keyfile_line", filename,
              *lineno);
#line 633
        while (1) {
#line 633
          tmp = fgetc(f);
#line 633
          if (tmp != 10) {
#line 633
            tmp___0 = feof(f);
#line 633
            if (tmp___0) {
#line 633
              break;
            }
          } else {
#line 633
            break;
          }
        }
      }
    }
  }
#line 637
  return (-1);
}
}
#line 640 "misc.c"
int tun_open(int tun , int mode ) 
{ int tmp ;

  {
#line 644
  tmp = sys_tun_open(tun, mode);
#line 644
  return (tmp);
}
}
#line 711 "misc.c"
void sanitise_stdfd(void) 
{ int nullfd ;
  int dupfd ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 716
  dupfd = open("/dev/null", 2);
#line 716
  nullfd = dupfd;
#line 716
  if (nullfd == -1) {
#line 717
    tmp = __errno_location();
#line 717
    tmp___0 = strerror(*tmp);
#line 717
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t open /dev/null: %s\n",
            tmp___0);
#line 719
    exit(1);
  }
#line 721
  while (1) {
#line 721
    dupfd ++;
#line 721
    if (! (dupfd <= 2)) {
#line 721
      break;
    }
#line 723
    tmp___1 = fcntl(dupfd, 3, 0);
#line 723
    if (tmp___1 >= 0) {
#line 724
      continue;
    }
#line 725
    tmp___4 = dup2(nullfd, dupfd);
#line 725
    if (tmp___4 == -1) {
#line 726
      tmp___2 = __errno_location();
#line 726
      tmp___3 = strerror(*tmp___2);
#line 726
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dup2: %s\n",
              tmp___3);
#line 727
      exit(1);
    }
  }
#line 730
  if (nullfd > 2) {
#line 731
    close(nullfd);
  }
#line 732
  return;
}
}
#line 734 "misc.c"
char *tohex(void const   *vp , size_t l ) 
{ u_char const   *p ;
  char b[3] ;
  char *r ;
  size_t i ;
  size_t hl ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 737
  p = (u_char const   *)vp;
#line 741
  if (l > 65536U) {
#line 742
    tmp = xstrdup("tohex: length > 65536");
#line 742
    return (tmp);
  }
#line 744
  hl = l * 2U + 1U;
#line 745
  tmp___0 = xcalloc(1U, hl);
#line 745
  r = (char *)tmp___0;
#line 746
  i = 0U;
#line 746
  while (i < l) {
#line 747
    snprintf((char * __restrict  )(b), sizeof(b), (char const   * __restrict  )"%02x",
             *(p + i));
#line 748
    strlcat(r, (char const   *)(b), hl);
#line 746
    i ++;
  }
#line 750
  return (r);
}
}
#line 753 "misc.c"
u_int64_t get_u64(void const   *vp ) 
{ u_char const   *p ;
  u_int64_t v ;

  {
#line 756
  p = (u_char const   *)vp;
#line 759
  v = (unsigned long long )*(p + 0) << 56;
#line 760
  v |= (unsigned long long )*(p + 1) << 48;
#line 761
  v |= (unsigned long long )*(p + 2) << 40;
#line 762
  v |= (unsigned long long )*(p + 3) << 32;
#line 763
  v |= (unsigned long long )*(p + 4) << 24;
#line 764
  v |= (unsigned long long )*(p + 5) << 16;
#line 765
  v |= (unsigned long long )*(p + 6) << 8;
#line 766
  v |= (unsigned long long )*(p + 7);
#line 768
  return (v);
}
}
#line 771 "misc.c"
u_int32_t get_u32(void const   *vp ) 
{ u_char const   *p ;
  u_int32_t v ;

  {
#line 774
  p = (u_char const   *)vp;
#line 777
  v = (unsigned int )*(p + 0) << 24;
#line 778
  v |= (unsigned int )*(p + 1) << 16;
#line 779
  v |= (unsigned int )*(p + 2) << 8;
#line 780
  v |= (unsigned int )*(p + 3);
#line 782
  return (v);
}
}
#line 785 "misc.c"
u_int16_t get_u16(void const   *vp ) 
{ u_char const   *p ;
  u_int16_t v ;

  {
#line 788
  p = (u_char const   *)vp;
#line 791
  v = (unsigned short )((int )((unsigned short )*(p + 0)) << 8);
#line 792
  v = (unsigned short )((int )v | (int )((unsigned short )*(p + 1)));
#line 794
  return (v);
}
}
#line 797 "misc.c"
void put_u64(void *vp , u_int64_t v ) 
{ u_char *p ;

  {
#line 800
  p = (u_char *)vp;
#line 802
  *(p + 0) = (unsigned char )((int )((unsigned char )(v >> 56)) & 255);
#line 803
  *(p + 1) = (unsigned char )((int )((unsigned char )(v >> 48)) & 255);
#line 804
  *(p + 2) = (unsigned char )((int )((unsigned char )(v >> 40)) & 255);
#line 805
  *(p + 3) = (unsigned char )((int )((unsigned char )(v >> 32)) & 255);
#line 806
  *(p + 4) = (unsigned char )((int )((unsigned char )(v >> 24)) & 255);
#line 807
  *(p + 5) = (unsigned char )((int )((unsigned char )(v >> 16)) & 255);
#line 808
  *(p + 6) = (unsigned char )((int )((unsigned char )(v >> 8)) & 255);
#line 809
  *(p + 7) = (unsigned char )((int )((unsigned char )v) & 255);
#line 810
  return;
}
}
#line 812 "misc.c"
void put_u32(void *vp , u_int32_t v ) 
{ u_char *p ;

  {
#line 815
  p = (u_char *)vp;
#line 817
  *(p + 0) = (unsigned char )((int )((unsigned char )(v >> 24)) & 255);
#line 818
  *(p + 1) = (unsigned char )((int )((unsigned char )(v >> 16)) & 255);
#line 819
  *(p + 2) = (unsigned char )((int )((unsigned char )(v >> 8)) & 255);
#line 820
  *(p + 3) = (unsigned char )((int )((unsigned char )v) & 255);
#line 821
  return;
}
}
#line 824 "misc.c"
void put_u16(void *vp , u_int16_t v ) 
{ u_char *p ;

  {
#line 827
  p = (u_char *)vp;
#line 829
  *(p + 0) = (unsigned char )((int )((unsigned char )((int )v >> 8)) & 255);
#line 830
  *(p + 1) = (unsigned char )((int )((unsigned char )v) & 255);
#line 831
  return;
}
}
#line 833 "misc.c"
void ms_subtract_diff(struct timeval *start___0 , int *ms ) 
{ struct timeval diff ;
  struct timeval finish ;

  {
#line 838
  gettimeofday((struct timeval * __restrict  )(& finish), (struct timezone * __restrict  )((void *)0));
#line 839
  while (1) {
#line 839
    diff.tv_sec = finish.tv_sec - start___0->tv_sec;
#line 839
    diff.tv_usec = finish.tv_usec - start___0->tv_usec;
#line 839
    if (diff.tv_usec < 0L) {
#line 839
      (diff.tv_sec) --;
#line 839
      diff.tv_usec += 1000000L;
    }
#line 839
    break;
  }
#line 840
  *ms = (int )((__time_t )*ms - (diff.tv_sec * 1000L + diff.tv_usec / 1000L));
#line 841
  return;
}
}
#line 843 "misc.c"
void ms_to_timeval(struct timeval *tv___0 , int ms ) 
{ 

  {
#line 846
  if (ms < 0) {
#line 847
    ms = 0;
  }
#line 848
  tv___0->tv_sec = (long )(ms / 1000);
#line 849
  tv___0->tv_usec = (long )((ms % 1000) * 1000);
#line 850
  return;
}
}
#line 1 "monitor_fdpass.o"
#pragma merger(0,"./monitor_fdpass.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 171 "/usr/include/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 179
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 31 "monitor_fdpass.h"
int mm_send_fd(int sock , int fd ) ;
#line 32
int mm_receive_fd(int sock ) ;
#line 43 "monitor_fdpass.c"
int mm_send_fd(int sock , int fd ) 
{ struct msghdr msg ;
  union __anonunion_cmsgbuf_52 cmsgbuf ;
  struct cmsghdr *cmsg ;
  struct iovec vec ;
  char ch ;
  ssize_t n___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 56
  ch = (char )'\000';
#line 59
  memset((void *)(& msg), 0, sizeof(msg));
#line 64
  msg.msg_control = (void *)((char *)(& cmsgbuf.buf));
#line 65
  msg.msg_controllen = sizeof(cmsgbuf.buf);
#line 66
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 66
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 66
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 67
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 68
  cmsg->cmsg_level = 1;
#line 69
  cmsg->cmsg_type = 1;
#line 70
  *((int *)(cmsg->__cmsg_data)) = fd;
#line 73
  vec.iov_base = (void *)(& ch);
#line 74
  vec.iov_len = 1U;
#line 75
  msg.msg_iov = & vec;
#line 76
  msg.msg_iovlen = 1U;
#line 78
  while (1) {
#line 78
    n___0 = sendmsg(sock, (struct msghdr  const  *)(& msg), 0);
#line 78
    if (n___0 == -1) {
#line 78
      tmp___1 = __errno_location();
#line 78
      if (! (*tmp___1 == 11)) {
#line 78
        tmp___2 = __errno_location();
#line 78
        if (! (*tmp___2 == 4)) {
#line 78
          break;
        }
      }
    } else {
#line 78
      break;
    }
#line 80
    tmp = __errno_location();
#line 80
    tmp___0 = strerror(*tmp);
#line 80
    debug3("%s: sendmsg(%d): %s", "mm_send_fd", fd, tmp___0);
  }
#line 81
  if (n___0 == -1) {
#line 82
    tmp___3 = __errno_location();
#line 82
    tmp___4 = strerror(*tmp___3);
#line 82
    error("%s: sendmsg(%d): %s", "mm_send_fd", fd, tmp___4);
#line 84
    return (-1);
  }
#line 87
  if (n___0 != 1) {
#line 88
    error("%s: sendmsg: expected sent 1 got %ld", "mm_send_fd", (long )n___0);
#line 90
    return (-1);
  }
#line 92
  return (0);
}
}
#line 99 "monitor_fdpass.c"
int mm_receive_fd(int sock ) 
{ struct msghdr msg ;
  union __anonunion_cmsgbuf_53 cmsgbuf ;
  struct cmsghdr *cmsg ;
  struct iovec vec ;
  ssize_t n___0 ;
  char ch ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 116
  memset((void *)(& msg), 0, sizeof(msg));
#line 117
  vec.iov_base = (void *)(& ch);
#line 118
  vec.iov_len = 1U;
#line 119
  msg.msg_iov = & vec;
#line 120
  msg.msg_iovlen = 1U;
#line 125
  msg.msg_control = (void *)(& cmsgbuf.buf);
#line 126
  msg.msg_controllen = sizeof(cmsgbuf.buf);
#line 129
  while (1) {
#line 129
    n___0 = recvmsg(sock, & msg, 0);
#line 129
    if (n___0 == -1) {
#line 129
      tmp___1 = __errno_location();
#line 129
      if (! (*tmp___1 == 11)) {
#line 129
        tmp___2 = __errno_location();
#line 129
        if (! (*tmp___2 == 4)) {
#line 129
          break;
        }
      }
    } else {
#line 129
      break;
    }
#line 131
    tmp = __errno_location();
#line 131
    tmp___0 = strerror(*tmp);
#line 131
    debug3("%s: recvmsg: %s", "mm_receive_fd", tmp___0);
  }
#line 132
  if (n___0 == -1) {
#line 133
    tmp___3 = __errno_location();
#line 133
    tmp___4 = strerror(*tmp___3);
#line 133
    error("%s: recvmsg: %s", "mm_receive_fd", tmp___4);
#line 134
    return (-1);
  }
#line 137
  if (n___0 != 1) {
#line 138
    error("%s: recvmsg: expected received 1 got %ld", "mm_receive_fd", (long )n___0);
#line 140
    return (-1);
  }
#line 149
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 149
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 149
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 150
  if ((unsigned int )cmsg == (unsigned int )((void *)0)) {
#line 151
    error("%s: no message header", "mm_receive_fd");
#line 152
    return (-1);
  }
#line 156
  if (cmsg->cmsg_type != 1) {
#line 157
    error("%s: expected type %d got %d", "mm_receive_fd", 1, cmsg->cmsg_type);
#line 159
    return (-1);
  }
#line 162
  fd = *((int *)(cmsg->__cmsg_data));
#line 164
  return (fd);
}
}
#line 1 "rijndael.o"
#pragma merger(0,"./rijndael.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 47 "rijndael.h"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int do_encrypt ) ;
#line 48
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 49
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 51 "rijndael.c"
static u32 const   Te0[256]  = 
#line 51 "rijndael.c"
  {      (u32 const   )3328402341U,      (u32 const   )4168907908U,      (u32 const   )4000806809U,      (u32 const   )4135287693U, 
        (u32 const   )4294111757U,      (u32 const   )3597364157U,      (u32 const   )3731845041U,      (u32 const   )2445657428U, 
        (u32 const   )1613770832U,      (u32 const   )33620227U,      (u32 const   )3462883241U,      (u32 const   )1445669757U, 
        (u32 const   )3892248089U,      (u32 const   )3050821474U,      (u32 const   )1303096294U,      (u32 const   )3967186586U, 
        (u32 const   )2412431941U,      (u32 const   )528646813U,      (u32 const   )2311702848U,      (u32 const   )4202528135U, 
        (u32 const   )4026202645U,      (u32 const   )2992200171U,      (u32 const   )2387036105U,      (u32 const   )4226871307U, 
        (u32 const   )1101901292U,      (u32 const   )3017069671U,      (u32 const   )1604494077U,      (u32 const   )1169141738U, 
        (u32 const   )597466303U,      (u32 const   )1403299063U,      (u32 const   )3832705686U,      (u32 const   )2613100635U, 
        (u32 const   )1974974402U,      (u32 const   )3791519004U,      (u32 const   )1033081774U,      (u32 const   )1277568618U, 
        (u32 const   )1815492186U,      (u32 const   )2118074177U,      (u32 const   )4126668546U,      (u32 const   )2211236943U, 
        (u32 const   )1748251740U,      (u32 const   )1369810420U,      (u32 const   )3521504564U,      (u32 const   )4193382664U, 
        (u32 const   )3799085459U,      (u32 const   )2883115123U,      (u32 const   )1647391059U,      (u32 const   )706024767U, 
        (u32 const   )134480908U,      (u32 const   )2512897874U,      (u32 const   )1176707941U,      (u32 const   )2646852446U, 
        (u32 const   )806885416U,      (u32 const   )932615841U,      (u32 const   )168101135U,      (u32 const   )798661301U, 
        (u32 const   )235341577U,      (u32 const   )605164086U,      (u32 const   )461406363U,      (u32 const   )3756188221U, 
        (u32 const   )3454790438U,      (u32 const   )1311188841U,      (u32 const   )2142417613U,      (u32 const   )3933566367U, 
        (u32 const   )302582043U,      (u32 const   )495158174U,      (u32 const   )1479289972U,      (u32 const   )874125870U, 
        (u32 const   )907746093U,      (u32 const   )3698224818U,      (u32 const   )3025820398U,      (u32 const   )1537253627U, 
        (u32 const   )2756858614U,      (u32 const   )1983593293U,      (u32 const   )3084310113U,      (u32 const   )2108928974U, 
        (u32 const   )1378429307U,      (u32 const   )3722699582U,      (u32 const   )1580150641U,      (u32 const   )327451799U, 
        (u32 const   )2790478837U,      (u32 const   )3117535592U,      (u32 const   )0U,      (u32 const   )3253595436U, 
        (u32 const   )1075847264U,      (u32 const   )3825007647U,      (u32 const   )2041688520U,      (u32 const   )3059440621U, 
        (u32 const   )3563743934U,      (u32 const   )2378943302U,      (u32 const   )1740553945U,      (u32 const   )1916352843U, 
        (u32 const   )2487896798U,      (u32 const   )2555137236U,      (u32 const   )2958579944U,      (u32 const   )2244988746U, 
        (u32 const   )3151024235U,      (u32 const   )3320835882U,      (u32 const   )1336584933U,      (u32 const   )3992714006U, 
        (u32 const   )2252555205U,      (u32 const   )2588757463U,      (u32 const   )1714631509U,      (u32 const   )293963156U, 
        (u32 const   )2319795663U,      (u32 const   )3925473552U,      (u32 const   )67240454U,      (u32 const   )4269768577U, 
        (u32 const   )2689618160U,      (u32 const   )2017213508U,      (u32 const   )631218106U,      (u32 const   )1269344483U, 
        (u32 const   )2723238387U,      (u32 const   )1571005438U,      (u32 const   )2151694528U,      (u32 const   )93294474U, 
        (u32 const   )1066570413U,      (u32 const   )563977660U,      (u32 const   )1882732616U,      (u32 const   )4059428100U, 
        (u32 const   )1673313503U,      (u32 const   )2008463041U,      (u32 const   )2950355573U,      (u32 const   )1109467491U, 
        (u32 const   )537923632U,      (u32 const   )3858759450U,      (u32 const   )4260623118U,      (u32 const   )3218264685U, 
        (u32 const   )2177748300U,      (u32 const   )403442708U,      (u32 const   )638784309U,      (u32 const   )3287084079U, 
        (u32 const   )3193921505U,      (u32 const   )899127202U,      (u32 const   )2286175436U,      (u32 const   )773265209U, 
        (u32 const   )2479146071U,      (u32 const   )1437050866U,      (u32 const   )4236148354U,      (u32 const   )2050833735U, 
        (u32 const   )3362022572U,      (u32 const   )3126681063U,      (u32 const   )840505643U,      (u32 const   )3866325909U, 
        (u32 const   )3227541664U,      (u32 const   )427917720U,      (u32 const   )2655997905U,      (u32 const   )2749160575U, 
        (u32 const   )1143087718U,      (u32 const   )1412049534U,      (u32 const   )999329963U,      (u32 const   )193497219U, 
        (u32 const   )2353415882U,      (u32 const   )3354324521U,      (u32 const   )1807268051U,      (u32 const   )672404540U, 
        (u32 const   )2816401017U,      (u32 const   )3160301282U,      (u32 const   )369822493U,      (u32 const   )2916866934U, 
        (u32 const   )3688947771U,      (u32 const   )1681011286U,      (u32 const   )1949973070U,      (u32 const   )336202270U, 
        (u32 const   )2454276571U,      (u32 const   )201721354U,      (u32 const   )1210328172U,      (u32 const   )3093060836U, 
        (u32 const   )2680341085U,      (u32 const   )3184776046U,      (u32 const   )1135389935U,      (u32 const   )3294782118U, 
        (u32 const   )965841320U,      (u32 const   )831886756U,      (u32 const   )3554993207U,      (u32 const   )4068047243U, 
        (u32 const   )3588745010U,      (u32 const   )2345191491U,      (u32 const   )1849112409U,      (u32 const   )3664604599U, 
        (u32 const   )26054028U,      (u32 const   )2983581028U,      (u32 const   )2622377682U,      (u32 const   )1235855840U, 
        (u32 const   )3630984372U,      (u32 const   )2891339514U,      (u32 const   )4092916743U,      (u32 const   )3488279077U, 
        (u32 const   )3395642799U,      (u32 const   )4101667470U,      (u32 const   )1202630377U,      (u32 const   )268961816U, 
        (u32 const   )1874508501U,      (u32 const   )4034427016U,      (u32 const   )1243948399U,      (u32 const   )1546530418U, 
        (u32 const   )941366308U,      (u32 const   )1470539505U,      (u32 const   )1941222599U,      (u32 const   )2546386513U, 
        (u32 const   )3421038627U,      (u32 const   )2715671932U,      (u32 const   )3899946140U,      (u32 const   )1042226977U, 
        (u32 const   )2521517021U,      (u32 const   )1639824860U,      (u32 const   )227249030U,      (u32 const   )260737669U, 
        (u32 const   )3765465232U,      (u32 const   )2084453954U,      (u32 const   )1907733956U,      (u32 const   )3429263018U, 
        (u32 const   )2420656344U,      (u32 const   )100860677U,      (u32 const   )4160157185U,      (u32 const   )470683154U, 
        (u32 const   )3261161891U,      (u32 const   )1781871967U,      (u32 const   )2924959737U,      (u32 const   )1773779408U, 
        (u32 const   )394692241U,      (u32 const   )2579611992U,      (u32 const   )974986535U,      (u32 const   )664706745U, 
        (u32 const   )3655459128U,      (u32 const   )3958962195U,      (u32 const   )731420851U,      (u32 const   )571543859U, 
        (u32 const   )3530123707U,      (u32 const   )2849626480U,      (u32 const   )126783113U,      (u32 const   )865375399U, 
        (u32 const   )765172662U,      (u32 const   )1008606754U,      (u32 const   )361203602U,      (u32 const   )3387549984U, 
        (u32 const   )2278477385U,      (u32 const   )2857719295U,      (u32 const   )1344809080U,      (u32 const   )2782912378U, 
        (u32 const   )59542671U,      (u32 const   )1503764984U,      (u32 const   )160008576U,      (u32 const   )437062935U, 
        (u32 const   )1707065306U,      (u32 const   )3622233649U,      (u32 const   )2218934982U,      (u32 const   )3496503480U, 
        (u32 const   )2185314755U,      (u32 const   )697932208U,      (u32 const   )1512910199U,      (u32 const   )504303377U, 
        (u32 const   )2075177163U,      (u32 const   )2824099068U,      (u32 const   )1841019862U,      (u32 const   )739644986U};
#line 117 "rijndael.c"
static u32 const   Te1[256]  = 
#line 117
  {      (u32 const   )2781242211U,      (u32 const   )2230877308U,      (u32 const   )2582542199U,      (u32 const   )2381740923U, 
        (u32 const   )234877682U,      (u32 const   )3184946027U,      (u32 const   )2984144751U,      (u32 const   )1418839493U, 
        (u32 const   )1348481072U,      (u32 const   )50462977U,      (u32 const   )2848876391U,      (u32 const   )2102799147U, 
        (u32 const   )434634494U,      (u32 const   )1656084439U,      (u32 const   )3863849899U,      (u32 const   )2599188086U, 
        (u32 const   )1167051466U,      (u32 const   )2636087938U,      (u32 const   )1082771913U,      (u32 const   )2281340285U, 
        (u32 const   )368048890U,      (u32 const   )3954334041U,      (u32 const   )3381544775U,      (u32 const   )201060592U, 
        (u32 const   )3963727277U,      (u32 const   )1739838676U,      (u32 const   )4250903202U,      (u32 const   )3930435503U, 
        (u32 const   )3206782108U,      (u32 const   )4149453988U,      (u32 const   )2531553906U,      (u32 const   )1536934080U, 
        (u32 const   )3262494647U,      (u32 const   )484572669U,      (u32 const   )2923271059U,      (u32 const   )1783375398U, 
        (u32 const   )1517041206U,      (u32 const   )1098792767U,      (u32 const   )49674231U,      (u32 const   )1334037708U, 
        (u32 const   )1550332980U,      (u32 const   )4098991525U,      (u32 const   )886171109U,      (u32 const   )150598129U, 
        (u32 const   )2481090929U,      (u32 const   )1940642008U,      (u32 const   )1398944049U,      (u32 const   )1059722517U, 
        (u32 const   )201851908U,      (u32 const   )1385547719U,      (u32 const   )1699095331U,      (u32 const   )1587397571U, 
        (u32 const   )674240536U,      (u32 const   )2704774806U,      (u32 const   )252314885U,      (u32 const   )3039795866U, 
        (u32 const   )151914247U,      (u32 const   )908333586U,      (u32 const   )2602270848U,      (u32 const   )1038082786U, 
        (u32 const   )651029483U,      (u32 const   )1766729511U,      (u32 const   )3447698098U,      (u32 const   )2682942837U, 
        (u32 const   )454166793U,      (u32 const   )2652734339U,      (u32 const   )1951935532U,      (u32 const   )775166490U, 
        (u32 const   )758520603U,      (u32 const   )3000790638U,      (u32 const   )4004797018U,      (u32 const   )4217086112U, 
        (u32 const   )4137964114U,      (u32 const   )1299594043U,      (u32 const   )1639438038U,      (u32 const   )3464344499U, 
        (u32 const   )2068982057U,      (u32 const   )1054729187U,      (u32 const   )1901997871U,      (u32 const   )2534638724U, 
        (u32 const   )4121318227U,      (u32 const   )1757008337U,      (u32 const   )0U,      (u32 const   )750906861U, 
        (u32 const   )1614815264U,      (u32 const   )535035132U,      (u32 const   )3363418545U,      (u32 const   )3988151131U, 
        (u32 const   )3201591914U,      (u32 const   )1183697867U,      (u32 const   )3647454910U,      (u32 const   )1265776953U, 
        (u32 const   )3734260298U,      (u32 const   )3566750796U,      (u32 const   )3903871064U,      (u32 const   )1250283471U, 
        (u32 const   )1807470800U,      (u32 const   )717615087U,      (u32 const   )3847203498U,      (u32 const   )384695291U, 
        (u32 const   )3313910595U,      (u32 const   )3617213773U,      (u32 const   )1432761139U,      (u32 const   )2484176261U, 
        (u32 const   )3481945413U,      (u32 const   )283769337U,      (u32 const   )100925954U,      (u32 const   )2180939647U, 
        (u32 const   )4037038160U,      (u32 const   )1148730428U,      (u32 const   )3123027871U,      (u32 const   )3813386408U, 
        (u32 const   )4087501137U,      (u32 const   )4267549603U,      (u32 const   )3229630528U,      (u32 const   )2315620239U, 
        (u32 const   )2906624658U,      (u32 const   )3156319645U,      (u32 const   )1215313976U,      (u32 const   )82966005U, 
        (u32 const   )3747855548U,      (u32 const   )3245848246U,      (u32 const   )1974459098U,      (u32 const   )1665278241U, 
        (u32 const   )807407632U,      (u32 const   )451280895U,      (u32 const   )251524083U,      (u32 const   )1841287890U, 
        (u32 const   )1283575245U,      (u32 const   )337120268U,      (u32 const   )891687699U,      (u32 const   )801369324U, 
        (u32 const   )3787349855U,      (u32 const   )2721421207U,      (u32 const   )3431482436U,      (u32 const   )959321879U, 
        (u32 const   )1469301956U,      (u32 const   )4065699751U,      (u32 const   )2197585534U,      (u32 const   )1199193405U, 
        (u32 const   )2898814052U,      (u32 const   )3887750493U,      (u32 const   )724703513U,      (u32 const   )2514908019U, 
        (u32 const   )2696962144U,      (u32 const   )2551808385U,      (u32 const   )3516813135U,      (u32 const   )2141445340U, 
        (u32 const   )1715741218U,      (u32 const   )2119445034U,      (u32 const   )2872807568U,      (u32 const   )2198571144U, 
        (u32 const   )3398190662U,      (u32 const   )700968686U,      (u32 const   )3547052216U,      (u32 const   )1009259540U, 
        (u32 const   )2041044702U,      (u32 const   )3803995742U,      (u32 const   )487983883U,      (u32 const   )1991105499U, 
        (u32 const   )1004265696U,      (u32 const   )1449407026U,      (u32 const   )1316239930U,      (u32 const   )504629770U, 
        (u32 const   )3683797321U,      (u32 const   )168560134U,      (u32 const   )1816667172U,      (u32 const   )3837287516U, 
        (u32 const   )1570751170U,      (u32 const   )1857934291U,      (u32 const   )4014189740U,      (u32 const   )2797888098U, 
        (u32 const   )2822345105U,      (u32 const   )2754712981U,      (u32 const   )936633572U,      (u32 const   )2347923833U, 
        (u32 const   )852879335U,      (u32 const   )1133234376U,      (u32 const   )1500395319U,      (u32 const   )3084545389U, 
        (u32 const   )2348912013U,      (u32 const   )1689376213U,      (u32 const   )3533459022U,      (u32 const   )3762923945U, 
        (u32 const   )3034082412U,      (u32 const   )4205598294U,      (u32 const   )133428468U,      (u32 const   )634383082U, 
        (u32 const   )2949277029U,      (u32 const   )2398386810U,      (u32 const   )3913789102U,      (u32 const   )403703816U, 
        (u32 const   )3580869306U,      (u32 const   )2297460856U,      (u32 const   )1867130149U,      (u32 const   )1918643758U, 
        (u32 const   )607656988U,      (u32 const   )4049053350U,      (u32 const   )3346248884U,      (u32 const   )1368901318U, 
        (u32 const   )600565992U,      (u32 const   )2090982877U,      (u32 const   )2632479860U,      (u32 const   )557719327U, 
        (u32 const   )3717614411U,      (u32 const   )3697393085U,      (u32 const   )2249034635U,      (u32 const   )2232388234U, 
        (u32 const   )2430627952U,      (u32 const   )1115438654U,      (u32 const   )3295786421U,      (u32 const   )2865522278U, 
        (u32 const   )3633334344U,      (u32 const   )84280067U,      (u32 const   )33027830U,      (u32 const   )303828494U, 
        (u32 const   )2747425121U,      (u32 const   )1600795957U,      (u32 const   )4188952407U,      (u32 const   )3496589753U, 
        (u32 const   )2434238086U,      (u32 const   )1486471617U,      (u32 const   )658119965U,      (u32 const   )3106381470U, 
        (u32 const   )953803233U,      (u32 const   )334231800U,      (u32 const   )3005978776U,      (u32 const   )857870609U, 
        (u32 const   )3151128937U,      (u32 const   )1890179545U,      (u32 const   )2298973838U,      (u32 const   )2805175444U, 
        (u32 const   )3056442267U,      (u32 const   )574365214U,      (u32 const   )2450884487U,      (u32 const   )550103529U, 
        (u32 const   )1233637070U,      (u32 const   )4289353045U,      (u32 const   )2018519080U,      (u32 const   )2057691103U, 
        (u32 const   )2399374476U,      (u32 const   )4166623649U,      (u32 const   )2148108681U,      (u32 const   )387583245U, 
        (u32 const   )3664101311U,      (u32 const   )836232934U,      (u32 const   )3330556482U,      (u32 const   )3100665960U, 
        (u32 const   )3280093505U,      (u32 const   )2955516313U,      (u32 const   )2002398509U,      (u32 const   )287182607U, 
        (u32 const   )3413881008U,      (u32 const   )4238890068U,      (u32 const   )3597515707U,      (u32 const   )975967766U};
#line 183 "rijndael.c"
static u32 const   Te2[256]  = 
#line 183
  {      (u32 const   )1671808611U,      (u32 const   )2089089148U,      (u32 const   )2006576759U,      (u32 const   )2072901243U, 
        (u32 const   )4061003762U,      (u32 const   )1807603307U,      (u32 const   )1873927791U,      (u32 const   )3310653893U, 
        (u32 const   )810573872U,      (u32 const   )16974337U,      (u32 const   )1739181671U,      (u32 const   )729634347U, 
        (u32 const   )4263110654U,      (u32 const   )3613570519U,      (u32 const   )2883997099U,      (u32 const   )1989864566U, 
        (u32 const   )3393556426U,      (u32 const   )2191335298U,      (u32 const   )3376449993U,      (u32 const   )2106063485U, 
        (u32 const   )4195741690U,      (u32 const   )1508618841U,      (u32 const   )1204391495U,      (u32 const   )4027317232U, 
        (u32 const   )2917941677U,      (u32 const   )3563566036U,      (u32 const   )2734514082U,      (u32 const   )2951366063U, 
        (u32 const   )2629772188U,      (u32 const   )2767672228U,      (u32 const   )1922491506U,      (u32 const   )3227229120U, 
        (u32 const   )3082974647U,      (u32 const   )4246528509U,      (u32 const   )2477669779U,      (u32 const   )644500518U, 
        (u32 const   )911895606U,      (u32 const   )1061256767U,      (u32 const   )4144166391U,      (u32 const   )3427763148U, 
        (u32 const   )878471220U,      (u32 const   )2784252325U,      (u32 const   )3845444069U,      (u32 const   )4043897329U, 
        (u32 const   )1905517169U,      (u32 const   )3631459288U,      (u32 const   )827548209U,      (u32 const   )356461077U, 
        (u32 const   )67897348U,      (u32 const   )3344078279U,      (u32 const   )593839651U,      (u32 const   )3277757891U, 
        (u32 const   )405286936U,      (u32 const   )2527147926U,      (u32 const   )84871685U,      (u32 const   )2595565466U, 
        (u32 const   )118033927U,      (u32 const   )305538066U,      (u32 const   )2157648768U,      (u32 const   )3795705826U, 
        (u32 const   )3945188843U,      (u32 const   )661212711U,      (u32 const   )2999812018U,      (u32 const   )1973414517U, 
        (u32 const   )152769033U,      (u32 const   )2208177539U,      (u32 const   )745822252U,      (u32 const   )439235610U, 
        (u32 const   )455947803U,      (u32 const   )1857215598U,      (u32 const   )1525593178U,      (u32 const   )2700827552U, 
        (u32 const   )1391895634U,      (u32 const   )994932283U,      (u32 const   )3596728278U,      (u32 const   )3016654259U, 
        (u32 const   )695947817U,      (u32 const   )3812548067U,      (u32 const   )795958831U,      (u32 const   )2224493444U, 
        (u32 const   )1408607827U,      (u32 const   )3513301457U,      (u32 const   )0U,      (u32 const   )3979133421U, 
        (u32 const   )543178784U,      (u32 const   )4229948412U,      (u32 const   )2982705585U,      (u32 const   )1542305371U, 
        (u32 const   )1790891114U,      (u32 const   )3410398667U,      (u32 const   )3201918910U,      (u32 const   )961245753U, 
        (u32 const   )1256100938U,      (u32 const   )1289001036U,      (u32 const   )1491644504U,      (u32 const   )3477767631U, 
        (u32 const   )3496721360U,      (u32 const   )4012557807U,      (u32 const   )2867154858U,      (u32 const   )4212583931U, 
        (u32 const   )1137018435U,      (u32 const   )1305975373U,      (u32 const   )861234739U,      (u32 const   )2241073541U, 
        (u32 const   )1171229253U,      (u32 const   )4178635257U,      (u32 const   )33948674U,      (u32 const   )2139225727U, 
        (u32 const   )1357946960U,      (u32 const   )1011120188U,      (u32 const   )2679776671U,      (u32 const   )2833468328U, 
        (u32 const   )1374921297U,      (u32 const   )2751356323U,      (u32 const   )1086357568U,      (u32 const   )2408187279U, 
        (u32 const   )2460827538U,      (u32 const   )2646352285U,      (u32 const   )944271416U,      (u32 const   )4110742005U, 
        (u32 const   )3168756668U,      (u32 const   )3066132406U,      (u32 const   )3665145818U,      (u32 const   )560153121U, 
        (u32 const   )271589392U,      (u32 const   )4279952895U,      (u32 const   )4077846003U,      (u32 const   )3530407890U, 
        (u32 const   )3444343245U,      (u32 const   )202643468U,      (u32 const   )322250259U,      (u32 const   )3962553324U, 
        (u32 const   )1608629855U,      (u32 const   )2543990167U,      (u32 const   )1154254916U,      (u32 const   )389623319U, 
        (u32 const   )3294073796U,      (u32 const   )2817676711U,      (u32 const   )2122513534U,      (u32 const   )1028094525U, 
        (u32 const   )1689045092U,      (u32 const   )1575467613U,      (u32 const   )422261273U,      (u32 const   )1939203699U, 
        (u32 const   )1621147744U,      (u32 const   )2174228865U,      (u32 const   )1339137615U,      (u32 const   )3699352540U, 
        (u32 const   )577127458U,      (u32 const   )712922154U,      (u32 const   )2427141008U,      (u32 const   )2290289544U, 
        (u32 const   )1187679302U,      (u32 const   )3995715566U,      (u32 const   )3100863416U,      (u32 const   )339486740U, 
        (u32 const   )3732514782U,      (u32 const   )1591917662U,      (u32 const   )186455563U,      (u32 const   )3681988059U, 
        (u32 const   )3762019296U,      (u32 const   )844522546U,      (u32 const   )978220090U,      (u32 const   )169743370U, 
        (u32 const   )1239126601U,      (u32 const   )101321734U,      (u32 const   )611076132U,      (u32 const   )1558493276U, 
        (u32 const   )3260915650U,      (u32 const   )3547250131U,      (u32 const   )2901361580U,      (u32 const   )1655096418U, 
        (u32 const   )2443721105U,      (u32 const   )2510565781U,      (u32 const   )3828863972U,      (u32 const   )2039214713U, 
        (u32 const   )3878868455U,      (u32 const   )3359869896U,      (u32 const   )928607799U,      (u32 const   )1840765549U, 
        (u32 const   )2374762893U,      (u32 const   )3580146133U,      (u32 const   )1322425422U,      (u32 const   )2850048425U, 
        (u32 const   )1823791212U,      (u32 const   )1459268694U,      (u32 const   )4094161908U,      (u32 const   )3928346602U, 
        (u32 const   )1706019429U,      (u32 const   )2056189050U,      (u32 const   )2934523822U,      (u32 const   )135794696U, 
        (u32 const   )3134549946U,      (u32 const   )2022240376U,      (u32 const   )628050469U,      (u32 const   )779246638U, 
        (u32 const   )472135708U,      (u32 const   )2800834470U,      (u32 const   )3032970164U,      (u32 const   )3327236038U, 
        (u32 const   )3894660072U,      (u32 const   )3715932637U,      (u32 const   )1956440180U,      (u32 const   )522272287U, 
        (u32 const   )1272813131U,      (u32 const   )3185336765U,      (u32 const   )2340818315U,      (u32 const   )2323976074U, 
        (u32 const   )1888542832U,      (u32 const   )1044544574U,      (u32 const   )3049550261U,      (u32 const   )1722469478U, 
        (u32 const   )1222152264U,      (u32 const   )50660867U,      (u32 const   )4127324150U,      (u32 const   )236067854U, 
        (u32 const   )1638122081U,      (u32 const   )895445557U,      (u32 const   )1475980887U,      (u32 const   )3117443513U, 
        (u32 const   )2257655686U,      (u32 const   )3243809217U,      (u32 const   )489110045U,      (u32 const   )2662934430U, 
        (u32 const   )3778599393U,      (u32 const   )4162055160U,      (u32 const   )2561878936U,      (u32 const   )288563729U, 
        (u32 const   )1773916777U,      (u32 const   )3648039385U,      (u32 const   )2391345038U,      (u32 const   )2493985684U, 
        (u32 const   )2612407707U,      (u32 const   )505560094U,      (u32 const   )2274497927U,      (u32 const   )3911240169U, 
        (u32 const   )3460925390U,      (u32 const   )1442818645U,      (u32 const   )678973480U,      (u32 const   )3749357023U, 
        (u32 const   )2358182796U,      (u32 const   )2717407649U,      (u32 const   )2306869641U,      (u32 const   )219617805U, 
        (u32 const   )3218761151U,      (u32 const   )3862026214U,      (u32 const   )1120306242U,      (u32 const   )1756942440U, 
        (u32 const   )1103331905U,      (u32 const   )2578459033U,      (u32 const   )762796589U,      (u32 const   )252780047U, 
        (u32 const   )2966125488U,      (u32 const   )1425844308U,      (u32 const   )3151392187U,      (u32 const   )372911126U};
#line 249 "rijndael.c"
static u32 const   Te3[256]  = 
#line 249
  {      (u32 const   )1667474886U,      (u32 const   )2088535288U,      (u32 const   )2004326894U,      (u32 const   )2071694838U, 
        (u32 const   )4075949567U,      (u32 const   )1802223062U,      (u32 const   )1869591006U,      (u32 const   )3318043793U, 
        (u32 const   )808472672U,      (u32 const   )16843522U,      (u32 const   )1734846926U,      (u32 const   )724270422U, 
        (u32 const   )4278065639U,      (u32 const   )3621216949U,      (u32 const   )2880169549U,      (u32 const   )1987484396U, 
        (u32 const   )3402253711U,      (u32 const   )2189597983U,      (u32 const   )3385409673U,      (u32 const   )2105378810U, 
        (u32 const   )4210693615U,      (u32 const   )1499065266U,      (u32 const   )1195886990U,      (u32 const   )4042263547U, 
        (u32 const   )2913856577U,      (u32 const   )3570689971U,      (u32 const   )2728590687U,      (u32 const   )2947541573U, 
        (u32 const   )2627518243U,      (u32 const   )2762274643U,      (u32 const   )1920112356U,      (u32 const   )3233831835U, 
        (u32 const   )3082273397U,      (u32 const   )4261223649U,      (u32 const   )2475929149U,      (u32 const   )640051788U, 
        (u32 const   )909531756U,      (u32 const   )1061110142U,      (u32 const   )4160160501U,      (u32 const   )3435941763U, 
        (u32 const   )875846760U,      (u32 const   )2779116625U,      (u32 const   )3857003729U,      (u32 const   )4059105529U, 
        (u32 const   )1903268834U,      (u32 const   )3638064043U,      (u32 const   )825316194U,      (u32 const   )353713962U, 
        (u32 const   )67374088U,      (u32 const   )3351728789U,      (u32 const   )589522246U,      (u32 const   )3284360861U, 
        (u32 const   )404236336U,      (u32 const   )2526454071U,      (u32 const   )84217610U,      (u32 const   )2593830191U, 
        (u32 const   )117901582U,      (u32 const   )303183396U,      (u32 const   )2155911963U,      (u32 const   )3806477791U, 
        (u32 const   )3958056653U,      (u32 const   )656894286U,      (u32 const   )2998062463U,      (u32 const   )1970642922U, 
        (u32 const   )151591698U,      (u32 const   )2206440989U,      (u32 const   )741110872U,      (u32 const   )437923380U, 
        (u32 const   )454765878U,      (u32 const   )1852748508U,      (u32 const   )1515908788U,      (u32 const   )2694904667U, 
        (u32 const   )1381168804U,      (u32 const   )993742198U,      (u32 const   )3604373943U,      (u32 const   )3014905469U, 
        (u32 const   )690584402U,      (u32 const   )3823320797U,      (u32 const   )791638366U,      (u32 const   )2223281939U, 
        (u32 const   )1398011302U,      (u32 const   )3520161977U,      (u32 const   )0U,      (u32 const   )3991743681U, 
        (u32 const   )538992704U,      (u32 const   )4244381667U,      (u32 const   )2981218425U,      (u32 const   )1532751286U, 
        (u32 const   )1785380564U,      (u32 const   )3419096717U,      (u32 const   )3200178535U,      (u32 const   )960056178U, 
        (u32 const   )1246420628U,      (u32 const   )1280103576U,      (u32 const   )1482221744U,      (u32 const   )3486468741U, 
        (u32 const   )3503319995U,      (u32 const   )4025428677U,      (u32 const   )2863326543U,      (u32 const   )4227536621U, 
        (u32 const   )1128514950U,      (u32 const   )1296947098U,      (u32 const   )859002214U,      (u32 const   )2240123921U, 
        (u32 const   )1162203018U,      (u32 const   )4193849577U,      (u32 const   )33687044U,      (u32 const   )2139062782U, 
        (u32 const   )1347481760U,      (u32 const   )1010582648U,      (u32 const   )2678045221U,      (u32 const   )2829640523U, 
        (u32 const   )1364325282U,      (u32 const   )2745433693U,      (u32 const   )1077985408U,      (u32 const   )2408548869U, 
        (u32 const   )2459086143U,      (u32 const   )2644360225U,      (u32 const   )943212656U,      (u32 const   )4126475505U, 
        (u32 const   )3166494563U,      (u32 const   )3065430391U,      (u32 const   )3671750063U,      (u32 const   )555836226U, 
        (u32 const   )269496352U,      (u32 const   )4294908645U,      (u32 const   )4092792573U,      (u32 const   )3537006015U, 
        (u32 const   )3452783745U,      (u32 const   )202118168U,      (u32 const   )320025894U,      (u32 const   )3974901699U, 
        (u32 const   )1600119230U,      (u32 const   )2543297077U,      (u32 const   )1145359496U,      (u32 const   )387397934U, 
        (u32 const   )3301201811U,      (u32 const   )2812801621U,      (u32 const   )2122220284U,      (u32 const   )1027426170U, 
        (u32 const   )1684319432U,      (u32 const   )1566435258U,      (u32 const   )421079858U,      (u32 const   )1936954854U, 
        (u32 const   )1616945344U,      (u32 const   )2172753945U,      (u32 const   )1330631070U,      (u32 const   )3705438115U, 
        (u32 const   )572679748U,      (u32 const   )707427924U,      (u32 const   )2425400123U,      (u32 const   )2290647819U, 
        (u32 const   )1179044492U,      (u32 const   )4008585671U,      (u32 const   )3099120491U,      (u32 const   )336870440U, 
        (u32 const   )3739122087U,      (u32 const   )1583276732U,      (u32 const   )185277718U,      (u32 const   )3688593069U, 
        (u32 const   )3772791771U,      (u32 const   )842159716U,      (u32 const   )976899700U,      (u32 const   )168435220U, 
        (u32 const   )1229577106U,      (u32 const   )101059084U,      (u32 const   )606366792U,      (u32 const   )1549591736U, 
        (u32 const   )3267517855U,      (u32 const   )3553849021U,      (u32 const   )2897014595U,      (u32 const   )1650632388U, 
        (u32 const   )2442242105U,      (u32 const   )2509612081U,      (u32 const   )3840161747U,      (u32 const   )2038008818U, 
        (u32 const   )3890688725U,      (u32 const   )3368567691U,      (u32 const   )926374254U,      (u32 const   )1835907034U, 
        (u32 const   )2374863873U,      (u32 const   )3587531953U,      (u32 const   )1313788572U,      (u32 const   )2846482505U, 
        (u32 const   )1819063512U,      (u32 const   )1448540844U,      (u32 const   )4109633523U,      (u32 const   )3941213647U, 
        (u32 const   )1701162954U,      (u32 const   )2054852340U,      (u32 const   )2930698567U,      (u32 const   )134748176U, 
        (u32 const   )3132806511U,      (u32 const   )2021165296U,      (u32 const   )623210314U,      (u32 const   )774795868U, 
        (u32 const   )471606328U,      (u32 const   )2795958615U,      (u32 const   )3031746419U,      (u32 const   )3334885783U, 
        (u32 const   )3907527627U,      (u32 const   )3722280097U,      (u32 const   )1953799400U,      (u32 const   )522133822U, 
        (u32 const   )1263263126U,      (u32 const   )3183336545U,      (u32 const   )2341176845U,      (u32 const   )2324333839U, 
        (u32 const   )1886425312U,      (u32 const   )1044267644U,      (u32 const   )3048588401U,      (u32 const   )1718004428U, 
        (u32 const   )1212733584U,      (u32 const   )50529542U,      (u32 const   )4143317495U,      (u32 const   )235803164U, 
        (u32 const   )1633788866U,      (u32 const   )892690282U,      (u32 const   )1465383342U,      (u32 const   )3115962473U, 
        (u32 const   )2256965911U,      (u32 const   )3250673817U,      (u32 const   )488449850U,      (u32 const   )2661202215U, 
        (u32 const   )3789633753U,      (u32 const   )4177007595U,      (u32 const   )2560144171U,      (u32 const   )286339874U, 
        (u32 const   )1768537042U,      (u32 const   )3654906025U,      (u32 const   )2391705863U,      (u32 const   )2492770099U, 
        (u32 const   )2610673197U,      (u32 const   )505291324U,      (u32 const   )2273808917U,      (u32 const   )3924369609U, 
        (u32 const   )3469625735U,      (u32 const   )1431699370U,      (u32 const   )673740880U,      (u32 const   )3755965093U, 
        (u32 const   )2358021891U,      (u32 const   )2711746649U,      (u32 const   )2307489801U,      (u32 const   )218961690U, 
        (u32 const   )3217021541U,      (u32 const   )3873845719U,      (u32 const   )1111672452U,      (u32 const   )1751693520U, 
        (u32 const   )1094828930U,      (u32 const   )2576986153U,      (u32 const   )757954394U,      (u32 const   )252645662U, 
        (u32 const   )2964376443U,      (u32 const   )1414855848U,      (u32 const   )3149649517U,      (u32 const   )370555436U};
#line 316 "rijndael.c"
static u32 const   Te4[256]  = 
#line 316
  {      (u32 const   )1667457891U,      (u32 const   )2088533116U,      (u32 const   )2004318071U,      (u32 const   )2071690107U, 
        (u32 const   )4076008178U,      (u32 const   )1802201963U,      (u32 const   )1869573999U,      (u32 const   )3318072773U, 
        (u32 const   )808464432U,      (u32 const   )16843009U,      (u32 const   )1734829927U,      (u32 const   )724249387U, 
        (u32 const   )4278124286U,      (u32 const   )3621246935U,      (u32 const   )2880154539U,      (u32 const   )1987475062U, 
        (u32 const   )3402287818U,      (u32 const   )2189591170U,      (u32 const   )3385444809U,      (u32 const   )2105376125U, 
        (u32 const   )4210752250U,      (u32 const   )1499027801U,      (u32 const   )1195853639U,      (u32 const   )4042322160U, 
        (u32 const   )2913840557U,      (u32 const   )3570717908U,      (u32 const   )2728567458U,      (u32 const   )2947526575U, 
        (u32 const   )2627509404U,      (u32 const   )2762253476U,      (u32 const   )1920103026U,      (u32 const   )3233857728U, 
        (u32 const   )3082270647U,      (u32 const   )4261281277U,      (u32 const   )2475922323U,      (u32 const   )640034342U, 
        (u32 const   )909522486U,      (u32 const   )1061109567U,      (u32 const   )4160223223U,      (u32 const   )3435973836U, 
        (u32 const   )875836468U,      (u32 const   )2779096485U,      (u32 const   )3857049061U,      (u32 const   )4059165169U, 
        (u32 const   )1903260017U,      (u32 const   )3638089944U,      (u32 const   )825307441U,      (u32 const   )353703189U, 
        (u32 const   )67372036U,      (u32 const   )3351758791U,      (u32 const   )589505315U,      (u32 const   )3284386755U, 
        (u32 const   )404232216U,      (u32 const   )2526451350U,      (u32 const   )84215045U,      (u32 const   )2593823386U, 
        (u32 const   )117901063U,      (u32 const   )303174162U,      (u32 const   )2155905152U,      (u32 const   )3806520034U, 
        (u32 const   )3958107115U,      (u32 const   )656877351U,      (u32 const   )2998055602U,      (u32 const   )1970632053U, 
        (u32 const   )151587081U,      (u32 const   )2206434179U,      (u32 const   )741092396U,      (u32 const   )437918234U, 
        (u32 const   )454761243U,      (u32 const   )1852730990U,      (u32 const   )1515870810U,      (u32 const   )2694881440U, 
        (u32 const   )1381126738U,      (u32 const   )993737531U,      (u32 const   )3604403926U,      (u32 const   )3014898611U, 
        (u32 const   )690563369U,      (u32 const   )3823363043U,      (u32 const   )791621423U,      (u32 const   )2223277188U, 
        (u32 const   )1397969747U,      (u32 const   )3520188881U,      (u32 const   )0U,      (u32 const   )3991793133U, 
        (u32 const   )538976288U,      (u32 const   )4244438268U,      (u32 const   )2981212593U,      (u32 const   )1532713819U, 
        (u32 const   )1785358954U,      (u32 const   )3419130827U,      (u32 const   )3200171710U,      (u32 const   )960051513U, 
        (u32 const   )1246382666U,      (u32 const   )1280068684U,      (u32 const   )1482184792U,      (u32 const   )3486502863U, 
        (u32 const   )3503345872U,      (u32 const   )4025479151U,      (u32 const   )2863311530U,      (u32 const   )4227595259U, 
        (u32 const   )1128481603U,      (u32 const   )1296911693U,      (u32 const   )858993459U,      (u32 const   )2240120197U, 
        (u32 const   )1162167621U,      (u32 const   )4193909241U,      (u32 const   )33686018U,      (u32 const   )2139062143U, 
        (u32 const   )1347440720U,      (u32 const   )1010580540U,      (u32 const   )2678038431U,      (u32 const   )2829625512U, 
        (u32 const   )1364283729U,      (u32 const   )2745410467U,      (u32 const   )1077952576U,      (u32 const   )2408550287U, 
        (u32 const   )2459079314U,      (u32 const   )2644352413U,      (u32 const   )943208504U,      (u32 const   )4126537205U, 
        (u32 const   )3166485692U,      (u32 const   )3065427638U,      (u32 const   )3671775962U,      (u32 const   )555819297U, 
        (u32 const   )269488144U,      (u32 const   )4294967295U,      (u32 const   )4092851187U,      (u32 const   )3537031890U, 
        (u32 const   )3452816845U,      (u32 const   )202116108U,      (u32 const   )320017171U,      (u32 const   )3974950124U, 
        (u32 const   )1600085855U,      (u32 const   )2543294359U,      (u32 const   )1145324612U,      (u32 const   )387389207U, 
        (u32 const   )3301229764U,      (u32 const   )2812782503U,      (u32 const   )2122219134U,      (u32 const   )1027423549U, 
        (u32 const   )1684300900U,      (u32 const   )1566399837U,      (u32 const   )421075225U,      (u32 const   )1936946035U, 
        (u32 const   )1616928864U,      (u32 const   )2172748161U,      (u32 const   )1330597711U,      (u32 const   )3705461980U, 
        (u32 const   )572662306U,      (u32 const   )707406378U,      (u32 const   )2425393296U,      (u32 const   )2290649224U, 
        (u32 const   )1179010630U,      (u32 const   )4008636142U,      (u32 const   )3099113656U,      (u32 const   )336860180U, 
        (u32 const   )3739147998U,      (u32 const   )1583242846U,      (u32 const   )185273099U,      (u32 const   )3688618971U, 
        (u32 const   )3772834016U,      (u32 const   )842150450U,      (u32 const   )976894522U,      (u32 const   )168430090U, 
        (u32 const   )1229539657U,      (u32 const   )101058054U,      (u32 const   )606348324U,      (u32 const   )1549556828U, 
        (u32 const   )3267543746U,      (u32 const   )3553874899U,      (u32 const   )2896997548U,      (u32 const   )1650614882U, 
        (u32 const   )2442236305U,      (u32 const   )2509608341U,      (u32 const   )3840206052U,      (u32 const   )2038004089U, 
        (u32 const   )3890735079U,      (u32 const   )3368601800U,      (u32 const   )926365495U,      (u32 const   )1835887981U, 
        (u32 const   )2374864269U,      (u32 const   )3587560917U,      (u32 const   )1313754702U,      (u32 const   )2846468521U, 
        (u32 const   )1819044972U,      (u32 const   )1448498774U,      (u32 const   )4109694196U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )2054847098U,      (u32 const   )2930683566U,      (u32 const   )134744072U, 
        (u32 const   )3132799674U,      (u32 const   )2021161080U,      (u32 const   )623191333U,      (u32 const   )774778414U, 
        (u32 const   )471604252U,      (u32 const   )2795939494U,      (u32 const   )3031741620U,      (u32 const   )3334915782U, 
        (u32 const   )3907578088U,      (u32 const   )3722304989U,      (u32 const   )1953789044U,      (u32 const   )522133279U, 
        (u32 const   )1263225675U,      (u32 const   )3183328701U,      (u32 const   )2341178251U,      (u32 const   )2324335242U, 
        (u32 const   )1886417008U,      (u32 const   )1044266558U,      (u32 const   )3048584629U,      (u32 const   )1717986918U, 
        (u32 const   )1212696648U,      (u32 const   )50529027U,      (u32 const   )4143380214U,      (u32 const   )235802126U, 
        (u32 const   )1633771873U,      (u32 const   )892679477U,      (u32 const   )1465341783U,      (u32 const   )3115956665U, 
        (u32 const   )2256963206U,      (u32 const   )3250700737U,      (u32 const   )488447261U,      (u32 const   )2661195422U, 
        (u32 const   )3789677025U,      (u32 const   )4177066232U,      (u32 const   )2560137368U,      (u32 const   )286331153U, 
        (u32 const   )1768515945U,      (u32 const   )3654932953U,      (u32 const   )2391707278U,      (u32 const   )2492765332U, 
        (u32 const   )2610666395U,      (u32 const   )505290270U,      (u32 const   )2273806215U,      (u32 const   )3924421097U, 
        (u32 const   )3469659854U,      (u32 const   )1431655765U,      (u32 const   )673720360U,      (u32 const   )3755991007U, 
        (u32 const   )2358021260U,      (u32 const   )2711724449U,      (u32 const   )2307492233U,      (u32 const   )218959117U, 
        (u32 const   )3217014719U,      (u32 const   )3873892070U,      (u32 const   )1111638594U,      (u32 const   )1751672936U, 
        (u32 const   )1094795585U,      (u32 const   )2576980377U,      (u32 const   )757935405U,      (u32 const   )252645135U, 
        (u32 const   )2964369584U,      (u32 const   )1414812756U,      (u32 const   )3149642683U,      (u32 const   )370546198U};
#line 382 "rijndael.c"
static u32 const   Td0[256]  = 
#line 382
  {      (u32 const   )1374988112U,      (u32 const   )2118214995U,      (u32 const   )437757123U,      (u32 const   )975658646U, 
        (u32 const   )1001089995U,      (u32 const   )530400753U,      (u32 const   )2902087851U,      (u32 const   )1273168787U, 
        (u32 const   )540080725U,      (u32 const   )2910219766U,      (u32 const   )2295101073U,      (u32 const   )4110568485U, 
        (u32 const   )1340463100U,      (u32 const   )3307916247U,      (u32 const   )641025152U,      (u32 const   )3043140495U, 
        (u32 const   )3736164937U,      (u32 const   )632953703U,      (u32 const   )1172967064U,      (u32 const   )1576976609U, 
        (u32 const   )3274667266U,      (u32 const   )2169303058U,      (u32 const   )2370213795U,      (u32 const   )1809054150U, 
        (u32 const   )59727847U,      (u32 const   )361929877U,      (u32 const   )3211623147U,      (u32 const   )2505202138U, 
        (u32 const   )3569255213U,      (u32 const   )1484005843U,      (u32 const   )1239443753U,      (u32 const   )2395588676U, 
        (u32 const   )1975683434U,      (u32 const   )4102977912U,      (u32 const   )2572697195U,      (u32 const   )666464733U, 
        (u32 const   )3202437046U,      (u32 const   )4035489047U,      (u32 const   )3374361702U,      (u32 const   )2110667444U, 
        (u32 const   )1675577880U,      (u32 const   )3843699074U,      (u32 const   )2538681184U,      (u32 const   )1649639237U, 
        (u32 const   )2976151520U,      (u32 const   )3144396420U,      (u32 const   )4269907996U,      (u32 const   )4178062228U, 
        (u32 const   )1883793496U,      (u32 const   )2403728665U,      (u32 const   )2497604743U,      (u32 const   )1383856311U, 
        (u32 const   )2876494627U,      (u32 const   )1917518562U,      (u32 const   )3810496343U,      (u32 const   )1716890410U, 
        (u32 const   )3001755655U,      (u32 const   )800440835U,      (u32 const   )2261089178U,      (u32 const   )3543599269U, 
        (u32 const   )807962610U,      (u32 const   )599762354U,      (u32 const   )33778362U,      (u32 const   )3977675356U, 
        (u32 const   )2328828971U,      (u32 const   )2809771154U,      (u32 const   )4077384432U,      (u32 const   )1315562145U, 
        (u32 const   )1708848333U,      (u32 const   )101039829U,      (u32 const   )3509871135U,      (u32 const   )3299278474U, 
        (u32 const   )875451293U,      (u32 const   )2733856160U,      (u32 const   )92987698U,      (u32 const   )2767645557U, 
        (u32 const   )193195065U,      (u32 const   )1080094634U,      (u32 const   )1584504582U,      (u32 const   )3178106961U, 
        (u32 const   )1042385657U,      (u32 const   )2531067453U,      (u32 const   )3711829422U,      (u32 const   )1306967366U, 
        (u32 const   )2438237621U,      (u32 const   )1908694277U,      (u32 const   )67556463U,      (u32 const   )1615861247U, 
        (u32 const   )429456164U,      (u32 const   )3602770327U,      (u32 const   )2302690252U,      (u32 const   )1742315127U, 
        (u32 const   )2968011453U,      (u32 const   )126454664U,      (u32 const   )3877198648U,      (u32 const   )2043211483U, 
        (u32 const   )2709260871U,      (u32 const   )2084704233U,      (u32 const   )4169408201U,      (u32 const   )0U, 
        (u32 const   )159417987U,      (u32 const   )841739592U,      (u32 const   )504459436U,      (u32 const   )1817866830U, 
        (u32 const   )4245618683U,      (u32 const   )260388950U,      (u32 const   )1034867998U,      (u32 const   )908933415U, 
        (u32 const   )168810852U,      (u32 const   )1750902305U,      (u32 const   )2606453969U,      (u32 const   )607530554U, 
        (u32 const   )202008497U,      (u32 const   )2472011535U,      (u32 const   )3035535058U,      (u32 const   )463180190U, 
        (u32 const   )2160117071U,      (u32 const   )1641816226U,      (u32 const   )1517767529U,      (u32 const   )470948374U, 
        (u32 const   )3801332234U,      (u32 const   )3231722213U,      (u32 const   )1008918595U,      (u32 const   )303765277U, 
        (u32 const   )235474187U,      (u32 const   )4069246893U,      (u32 const   )766945465U,      (u32 const   )337553864U, 
        (u32 const   )1475418501U,      (u32 const   )2943682380U,      (u32 const   )4003061179U,      (u32 const   )2743034109U, 
        (u32 const   )4144047775U,      (u32 const   )1551037884U,      (u32 const   )1147550661U,      (u32 const   )1543208500U, 
        (u32 const   )2336434550U,      (u32 const   )3408119516U,      (u32 const   )3069049960U,      (u32 const   )3102011747U, 
        (u32 const   )3610369226U,      (u32 const   )1113818384U,      (u32 const   )328671808U,      (u32 const   )2227573024U, 
        (u32 const   )2236228733U,      (u32 const   )3535486456U,      (u32 const   )2935566865U,      (u32 const   )3341394285U, 
        (u32 const   )496906059U,      (u32 const   )3702665459U,      (u32 const   )226906860U,      (u32 const   )2009195472U, 
        (u32 const   )733156972U,      (u32 const   )2842737049U,      (u32 const   )294930682U,      (u32 const   )1206477858U, 
        (u32 const   )2835123396U,      (u32 const   )2700099354U,      (u32 const   )1451044056U,      (u32 const   )573804783U, 
        (u32 const   )2269728455U,      (u32 const   )3644379585U,      (u32 const   )2362090238U,      (u32 const   )2564033334U, 
        (u32 const   )2801107407U,      (u32 const   )2776292904U,      (u32 const   )3669462566U,      (u32 const   )1068351396U, 
        (u32 const   )742039012U,      (u32 const   )1350078989U,      (u32 const   )1784663195U,      (u32 const   )1417561698U, 
        (u32 const   )4136440770U,      (u32 const   )2430122216U,      (u32 const   )775550814U,      (u32 const   )2193862645U, 
        (u32 const   )2673705150U,      (u32 const   )1775276924U,      (u32 const   )1876241833U,      (u32 const   )3475313331U, 
        (u32 const   )3366754619U,      (u32 const   )270040487U,      (u32 const   )3902563182U,      (u32 const   )3678124923U, 
        (u32 const   )3441850377U,      (u32 const   )1851332852U,      (u32 const   )3969562369U,      (u32 const   )2203032232U, 
        (u32 const   )3868552805U,      (u32 const   )2868897406U,      (u32 const   )566021896U,      (u32 const   )4011190502U, 
        (u32 const   )3135740889U,      (u32 const   )1248802510U,      (u32 const   )3936291284U,      (u32 const   )699432150U, 
        (u32 const   )832877231U,      (u32 const   )708780849U,      (u32 const   )3332740144U,      (u32 const   )899835584U, 
        (u32 const   )1951317047U,      (u32 const   )4236429990U,      (u32 const   )3767586992U,      (u32 const   )866637845U, 
        (u32 const   )4043610186U,      (u32 const   )1106041591U,      (u32 const   )2144161806U,      (u32 const   )395441711U, 
        (u32 const   )1984812685U,      (u32 const   )1139781709U,      (u32 const   )3433712980U,      (u32 const   )3835036895U, 
        (u32 const   )2664543715U,      (u32 const   )1282050075U,      (u32 const   )3240894392U,      (u32 const   )1181045119U, 
        (u32 const   )2640243204U,      (u32 const   )25965917U,      (u32 const   )4203181171U,      (u32 const   )4211818798U, 
        (u32 const   )3009879386U,      (u32 const   )2463879762U,      (u32 const   )3910161971U,      (u32 const   )1842759443U, 
        (u32 const   )2597806476U,      (u32 const   )933301370U,      (u32 const   )1509430414U,      (u32 const   )3943906441U, 
        (u32 const   )3467192302U,      (u32 const   )3076639029U,      (u32 const   )3776767469U,      (u32 const   )2051518780U, 
        (u32 const   )2631065433U,      (u32 const   )1441952575U,      (u32 const   )404016761U,      (u32 const   )1942435775U, 
        (u32 const   )1408749034U,      (u32 const   )1610459739U,      (u32 const   )3745345300U,      (u32 const   )2017778566U, 
        (u32 const   )3400528769U,      (u32 const   )3110650942U,      (u32 const   )941896748U,      (u32 const   )3265478751U, 
        (u32 const   )371049330U,      (u32 const   )3168937228U,      (u32 const   )675039627U,      (u32 const   )4279080257U, 
        (u32 const   )967311729U,      (u32 const   )135050206U,      (u32 const   )3635733660U,      (u32 const   )1683407248U, 
        (u32 const   )2076935265U,      (u32 const   )3576870512U,      (u32 const   )1215061108U,      (u32 const   )3501741890U};
#line 448 "rijndael.c"
static u32 const   Td1[256]  = 
#line 448
  {      (u32 const   )1347548327U,      (u32 const   )1400783205U,      (u32 const   )3273267108U,      (u32 const   )2520393566U, 
        (u32 const   )3409685355U,      (u32 const   )4045380933U,      (u32 const   )2880240216U,      (u32 const   )2471224067U, 
        (u32 const   )1428173050U,      (u32 const   )4138563181U,      (u32 const   )2441661558U,      (u32 const   )636813900U, 
        (u32 const   )4233094615U,      (u32 const   )3620022987U,      (u32 const   )2149987652U,      (u32 const   )2411029155U, 
        (u32 const   )1239331162U,      (u32 const   )1730525723U,      (u32 const   )2554718734U,      (u32 const   )3781033664U, 
        (u32 const   )46346101U,      (u32 const   )310463728U,      (u32 const   )2743944855U,      (u32 const   )3328955385U, 
        (u32 const   )3875770207U,      (u32 const   )2501218972U,      (u32 const   )3955191162U,      (u32 const   )3667219033U, 
        (u32 const   )768917123U,      (u32 const   )3545789473U,      (u32 const   )692707433U,      (u32 const   )1150208456U, 
        (u32 const   )1786102409U,      (u32 const   )2029293177U,      (u32 const   )1805211710U,      (u32 const   )3710368113U, 
        (u32 const   )3065962831U,      (u32 const   )401639597U,      (u32 const   )1724457132U,      (u32 const   )3028143674U, 
        (u32 const   )409198410U,      (u32 const   )2196052529U,      (u32 const   )1620529459U,      (u32 const   )1164071807U, 
        (u32 const   )3769721975U,      (u32 const   )2226875310U,      (u32 const   )486441376U,      (u32 const   )2499348523U, 
        (u32 const   )1483753576U,      (u32 const   )428819965U,      (u32 const   )2274680428U,      (u32 const   )3075636216U, 
        (u32 const   )598438867U,      (u32 const   )3799141122U,      (u32 const   )1474502543U,      (u32 const   )711349675U, 
        (u32 const   )129166120U,      (u32 const   )53458370U,      (u32 const   )2592523643U,      (u32 const   )2782082824U, 
        (u32 const   )4063242375U,      (u32 const   )2988687269U,      (u32 const   )3120694122U,      (u32 const   )1559041666U, 
        (u32 const   )730517276U,      (u32 const   )2460449204U,      (u32 const   )4042459122U,      (u32 const   )2706270690U, 
        (u32 const   )3446004468U,      (u32 const   )3573941694U,      (u32 const   )533804130U,      (u32 const   )2328143614U, 
        (u32 const   )2637442643U,      (u32 const   )2695033685U,      (u32 const   )839224033U,      (u32 const   )1973745387U, 
        (u32 const   )957055980U,      (u32 const   )2856345839U,      (u32 const   )106852767U,      (u32 const   )1371368976U, 
        (u32 const   )4181598602U,      (u32 const   )1033297158U,      (u32 const   )2933734917U,      (u32 const   )1179510461U, 
        (u32 const   )3046200461U,      (u32 const   )91341917U,      (u32 const   )1862534868U,      (u32 const   )4284502037U, 
        (u32 const   )605657339U,      (u32 const   )2547432937U,      (u32 const   )3431546947U,      (u32 const   )2003294622U, 
        (u32 const   )3182487618U,      (u32 const   )2282195339U,      (u32 const   )954669403U,      (u32 const   )3682191598U, 
        (u32 const   )1201765386U,      (u32 const   )3917234703U,      (u32 const   )3388507166U,      (u32 const   )0U, 
        (u32 const   )2198438022U,      (u32 const   )1211247597U,      (u32 const   )2887651696U,      (u32 const   )1315723890U, 
        (u32 const   )4227665663U,      (u32 const   )1443857720U,      (u32 const   )507358933U,      (u32 const   )657861945U, 
        (u32 const   )1678381017U,      (u32 const   )560487590U,      (u32 const   )3516619604U,      (u32 const   )975451694U, 
        (u32 const   )2970356327U,      (u32 const   )261314535U,      (u32 const   )3535072918U,      (u32 const   )2652609425U, 
        (u32 const   )1333838021U,      (u32 const   )2724322336U,      (u32 const   )1767536459U,      (u32 const   )370938394U, 
        (u32 const   )182621114U,      (u32 const   )3854606378U,      (u32 const   )1128014560U,      (u32 const   )487725847U, 
        (u32 const   )185469197U,      (u32 const   )2918353863U,      (u32 const   )3106780840U,      (u32 const   )3356761769U, 
        (u32 const   )2237133081U,      (u32 const   )1286567175U,      (u32 const   )3152976349U,      (u32 const   )4255350624U, 
        (u32 const   )2683765030U,      (u32 const   )3160175349U,      (u32 const   )3309594171U,      (u32 const   )878443390U, 
        (u32 const   )1988838185U,      (u32 const   )3704300486U,      (u32 const   )1756818940U,      (u32 const   )1673061617U, 
        (u32 const   )3403100636U,      (u32 const   )272786309U,      (u32 const   )1075025698U,      (u32 const   )545572369U, 
        (u32 const   )2105887268U,      (u32 const   )4174560061U,      (u32 const   )296679730U,      (u32 const   )1841768865U, 
        (u32 const   )1260232239U,      (u32 const   )4091327024U,      (u32 const   )3960309330U,      (u32 const   )3497509347U, 
        (u32 const   )1814803222U,      (u32 const   )2578018489U,      (u32 const   )4195456072U,      (u32 const   )575138148U, 
        (u32 const   )3299409036U,      (u32 const   )446754879U,      (u32 const   )3629546796U,      (u32 const   )4011996048U, 
        (u32 const   )3347532110U,      (u32 const   )3252238545U,      (u32 const   )4270639778U,      (u32 const   )915985419U, 
        (u32 const   )3483825537U,      (u32 const   )681933534U,      (u32 const   )651868046U,      (u32 const   )2755636671U, 
        (u32 const   )3828103837U,      (u32 const   )223377554U,      (u32 const   )2607439820U,      (u32 const   )1649704518U, 
        (u32 const   )3270937875U,      (u32 const   )3901806776U,      (u32 const   )1580087799U,      (u32 const   )4118987695U, 
        (u32 const   )3198115200U,      (u32 const   )2087309459U,      (u32 const   )2842678573U,      (u32 const   )3016697106U, 
        (u32 const   )1003007129U,      (u32 const   )2802849917U,      (u32 const   )1860738147U,      (u32 const   )2077965243U, 
        (u32 const   )164439672U,      (u32 const   )4100872472U,      (u32 const   )32283319U,      (u32 const   )2827177882U, 
        (u32 const   )1709610350U,      (u32 const   )2125135846U,      (u32 const   )136428751U,      (u32 const   )3874428392U, 
        (u32 const   )3652904859U,      (u32 const   )3460984630U,      (u32 const   )3572145929U,      (u32 const   )3593056380U, 
        (u32 const   )2939266226U,      (u32 const   )824852259U,      (u32 const   )818324884U,      (u32 const   )3224740454U, 
        (u32 const   )930369212U,      (u32 const   )2801566410U,      (u32 const   )2967507152U,      (u32 const   )355706840U, 
        (u32 const   )1257309336U,      (u32 const   )4148292826U,      (u32 const   )243256656U,      (u32 const   )790073846U, 
        (u32 const   )2373340630U,      (u32 const   )1296297904U,      (u32 const   )1422699085U,      (u32 const   )3756299780U, 
        (u32 const   )3818836405U,      (u32 const   )457992840U,      (u32 const   )3099667487U,      (u32 const   )2135319889U, 
        (u32 const   )77422314U,      (u32 const   )1560382517U,      (u32 const   )1945798516U,      (u32 const   )788204353U, 
        (u32 const   )1521706781U,      (u32 const   )1385356242U,      (u32 const   )870912086U,      (u32 const   )325965383U, 
        (u32 const   )2358957921U,      (u32 const   )2050466060U,      (u32 const   )2388260884U,      (u32 const   )2313884476U, 
        (u32 const   )4006521127U,      (u32 const   )901210569U,      (u32 const   )3990953189U,      (u32 const   )1014646705U, 
        (u32 const   )1503449823U,      (u32 const   )1062597235U,      (u32 const   )2031621326U,      (u32 const   )3212035895U, 
        (u32 const   )3931371469U,      (u32 const   )1533017514U,      (u32 const   )350174575U,      (u32 const   )2256028891U, 
        (u32 const   )2177544179U,      (u32 const   )1052338372U,      (u32 const   )741876788U,      (u32 const   )1606591296U, 
        (u32 const   )1914052035U,      (u32 const   )213705253U,      (u32 const   )2334669897U,      (u32 const   )1107234197U, 
        (u32 const   )1899603969U,      (u32 const   )3725069491U,      (u32 const   )2631447780U,      (u32 const   )2422494913U, 
        (u32 const   )1635502980U,      (u32 const   )1893020342U,      (u32 const   )1950903388U,      (u32 const   )1120974935U};
#line 514 "rijndael.c"
static u32 const   Td2[256]  = 
#line 514
  {      (u32 const   )2807058932U,      (u32 const   )1699970625U,      (u32 const   )2764249623U,      (u32 const   )1586903591U, 
        (u32 const   )1808481195U,      (u32 const   )1173430173U,      (u32 const   )1487645946U,      (u32 const   )59984867U, 
        (u32 const   )4199882800U,      (u32 const   )1844882806U,      (u32 const   )1989249228U,      (u32 const   )1277555970U, 
        (u32 const   )3623636965U,      (u32 const   )3419915562U,      (u32 const   )1149249077U,      (u32 const   )2744104290U, 
        (u32 const   )1514790577U,      (u32 const   )459744698U,      (u32 const   )244860394U,      (u32 const   )3235995134U, 
        (u32 const   )1963115311U,      (u32 const   )4027744588U,      (u32 const   )2544078150U,      (u32 const   )4190530515U, 
        (u32 const   )1608975247U,      (u32 const   )2627016082U,      (u32 const   )2062270317U,      (u32 const   )1507497298U, 
        (u32 const   )2200818878U,      (u32 const   )567498868U,      (u32 const   )1764313568U,      (u32 const   )3359936201U, 
        (u32 const   )2305455554U,      (u32 const   )2037970062U,      (u32 const   )1047239000U,      (u32 const   )1910319033U, 
        (u32 const   )1337376481U,      (u32 const   )2904027272U,      (u32 const   )2892417312U,      (u32 const   )984907214U, 
        (u32 const   )1243112415U,      (u32 const   )830661914U,      (u32 const   )861968209U,      (u32 const   )2135253587U, 
        (u32 const   )2011214180U,      (u32 const   )2927934315U,      (u32 const   )2686254721U,      (u32 const   )731183368U, 
        (u32 const   )1750626376U,      (u32 const   )4246310725U,      (u32 const   )1820824798U,      (u32 const   )4172763771U, 
        (u32 const   )3542330227U,      (u32 const   )48394827U,      (u32 const   )2404901663U,      (u32 const   )2871682645U, 
        (u32 const   )671593195U,      (u32 const   )3254988725U,      (u32 const   )2073724613U,      (u32 const   )145085239U, 
        (u32 const   )2280796200U,      (u32 const   )2779915199U,      (u32 const   )1790575107U,      (u32 const   )2187128086U, 
        (u32 const   )472615631U,      (u32 const   )3029510009U,      (u32 const   )4075877127U,      (u32 const   )3802222185U, 
        (u32 const   )4107101658U,      (u32 const   )3201631749U,      (u32 const   )1646252340U,      (u32 const   )4270507174U, 
        (u32 const   )1402811438U,      (u32 const   )1436590835U,      (u32 const   )3778151818U,      (u32 const   )3950355702U, 
        (u32 const   )3963161475U,      (u32 const   )4020912224U,      (u32 const   )2667994737U,      (u32 const   )273792366U, 
        (u32 const   )2331590177U,      (u32 const   )104699613U,      (u32 const   )95345982U,      (u32 const   )3175501286U, 
        (u32 const   )2377486676U,      (u32 const   )1560637892U,      (u32 const   )3564045318U,      (u32 const   )369057872U, 
        (u32 const   )4213447064U,      (u32 const   )3919042237U,      (u32 const   )1137477952U,      (u32 const   )2658625497U, 
        (u32 const   )1119727848U,      (u32 const   )2340947849U,      (u32 const   )1530455833U,      (u32 const   )4007360968U, 
        (u32 const   )172466556U,      (u32 const   )266959938U,      (u32 const   )516552836U,      (u32 const   )0U, 
        (u32 const   )2256734592U,      (u32 const   )3980931627U,      (u32 const   )1890328081U,      (u32 const   )1917742170U, 
        (u32 const   )4294704398U,      (u32 const   )945164165U,      (u32 const   )3575528878U,      (u32 const   )958871085U, 
        (u32 const   )3647212047U,      (u32 const   )2787207260U,      (u32 const   )1423022939U,      (u32 const   )775562294U, 
        (u32 const   )1739656202U,      (u32 const   )3876557655U,      (u32 const   )2530391278U,      (u32 const   )2443058075U, 
        (u32 const   )3310321856U,      (u32 const   )547512796U,      (u32 const   )1265195639U,      (u32 const   )437656594U, 
        (u32 const   )3121275539U,      (u32 const   )719700128U,      (u32 const   )3762502690U,      (u32 const   )387781147U, 
        (u32 const   )218828297U,      (u32 const   )3350065803U,      (u32 const   )2830708150U,      (u32 const   )2848461854U, 
        (u32 const   )428169201U,      (u32 const   )122466165U,      (u32 const   )3720081049U,      (u32 const   )1627235199U, 
        (u32 const   )648017665U,      (u32 const   )4122762354U,      (u32 const   )1002783846U,      (u32 const   )2117360635U, 
        (u32 const   )695634755U,      (u32 const   )3336358691U,      (u32 const   )4234721005U,      (u32 const   )4049844452U, 
        (u32 const   )3704280881U,      (u32 const   )2232435299U,      (u32 const   )574624663U,      (u32 const   )287343814U, 
        (u32 const   )612205898U,      (u32 const   )1039717051U,      (u32 const   )840019705U,      (u32 const   )2708326185U, 
        (u32 const   )793451934U,      (u32 const   )821288114U,      (u32 const   )1391201670U,      (u32 const   )3822090177U, 
        (u32 const   )376187827U,      (u32 const   )3113855344U,      (u32 const   )1224348052U,      (u32 const   )1679968233U, 
        (u32 const   )2361698556U,      (u32 const   )1058709744U,      (u32 const   )752375421U,      (u32 const   )2431590963U, 
        (u32 const   )1321699145U,      (u32 const   )3519142200U,      (u32 const   )2734591178U,      (u32 const   )188127444U, 
        (u32 const   )2177869557U,      (u32 const   )3727205754U,      (u32 const   )2384911031U,      (u32 const   )3215212461U, 
        (u32 const   )2648976442U,      (u32 const   )2450346104U,      (u32 const   )3432737375U,      (u32 const   )1180849278U, 
        (u32 const   )331544205U,      (u32 const   )3102249176U,      (u32 const   )4150144569U,      (u32 const   )2952102595U, 
        (u32 const   )2159976285U,      (u32 const   )2474404304U,      (u32 const   )766078933U,      (u32 const   )313773861U, 
        (u32 const   )2570832044U,      (u32 const   )2108100632U,      (u32 const   )1668212892U,      (u32 const   )3145456443U, 
        (u32 const   )2013908262U,      (u32 const   )418672217U,      (u32 const   )3070356634U,      (u32 const   )2594734927U, 
        (u32 const   )1852171925U,      (u32 const   )3867060991U,      (u32 const   )3473416636U,      (u32 const   )3907448597U, 
        (u32 const   )2614737639U,      (u32 const   )919489135U,      (u32 const   )164948639U,      (u32 const   )2094410160U, 
        (u32 const   )2997825956U,      (u32 const   )590424639U,      (u32 const   )2486224549U,      (u32 const   )1723872674U, 
        (u32 const   )3157750862U,      (u32 const   )3399941250U,      (u32 const   )3501252752U,      (u32 const   )3625268135U, 
        (u32 const   )2555048196U,      (u32 const   )3673637356U,      (u32 const   )1343127501U,      (u32 const   )4130281361U, 
        (u32 const   )3599595085U,      (u32 const   )2957853679U,      (u32 const   )1297403050U,      (u32 const   )81781910U, 
        (u32 const   )3051593425U,      (u32 const   )2283490410U,      (u32 const   )532201772U,      (u32 const   )1367295589U, 
        (u32 const   )3926170974U,      (u32 const   )895287692U,      (u32 const   )1953757831U,      (u32 const   )1093597963U, 
        (u32 const   )492483431U,      (u32 const   )3528626907U,      (u32 const   )1446242576U,      (u32 const   )1192455638U, 
        (u32 const   )1636604631U,      (u32 const   )209336225U,      (u32 const   )344873464U,      (u32 const   )1015671571U, 
        (u32 const   )669961897U,      (u32 const   )3375740769U,      (u32 const   )3857572124U,      (u32 const   )2973530695U, 
        (u32 const   )3747192018U,      (u32 const   )1933530610U,      (u32 const   )3464042516U,      (u32 const   )935293895U, 
        (u32 const   )3454686199U,      (u32 const   )2858115069U,      (u32 const   )1863638845U,      (u32 const   )3683022916U, 
        (u32 const   )4085369519U,      (u32 const   )3292445032U,      (u32 const   )875313188U,      (u32 const   )1080017571U, 
        (u32 const   )3279033885U,      (u32 const   )621591778U,      (u32 const   )1233856572U,      (u32 const   )2504130317U, 
        (u32 const   )24197544U,      (u32 const   )3017672716U,      (u32 const   )3835484340U,      (u32 const   )3247465558U, 
        (u32 const   )2220981195U,      (u32 const   )3060847922U,      (u32 const   )1551124588U,      (u32 const   )1463996600U};
#line 581 "rijndael.c"
static u32 const   Td3[256]  = 
#line 581
  {      (u32 const   )4104605777U,      (u32 const   )1097159550U,      (u32 const   )396673818U,      (u32 const   )660510266U, 
        (u32 const   )2875968315U,      (u32 const   )2638606623U,      (u32 const   )4200115116U,      (u32 const   )3808662347U, 
        (u32 const   )821712160U,      (u32 const   )1986918061U,      (u32 const   )3430322568U,      (u32 const   )38544885U, 
        (u32 const   )3856137295U,      (u32 const   )718002117U,      (u32 const   )893681702U,      (u32 const   )1654886325U, 
        (u32 const   )2975484382U,      (u32 const   )3122358053U,      (u32 const   )3926825029U,      (u32 const   )4274053469U, 
        (u32 const   )796197571U,      (u32 const   )1290801793U,      (u32 const   )1184342925U,      (u32 const   )3556361835U, 
        (u32 const   )2405426947U,      (u32 const   )2459735317U,      (u32 const   )1836772287U,      (u32 const   )1381620373U, 
        (u32 const   )3196267988U,      (u32 const   )1948373848U,      (u32 const   )3764988233U,      (u32 const   )3385345166U, 
        (u32 const   )3263785589U,      (u32 const   )2390325492U,      (u32 const   )1480485785U,      (u32 const   )3111247143U, 
        (u32 const   )3780097726U,      (u32 const   )2293045232U,      (u32 const   )548169417U,      (u32 const   )3459953789U, 
        (u32 const   )3746175075U,      (u32 const   )439452389U,      (u32 const   )1362321559U,      (u32 const   )1400849762U, 
        (u32 const   )1685577905U,      (u32 const   )1806599355U,      (u32 const   )2174754046U,      (u32 const   )137073913U, 
        (u32 const   )1214797936U,      (u32 const   )1174215055U,      (u32 const   )3731654548U,      (u32 const   )2079897426U, 
        (u32 const   )1943217067U,      (u32 const   )1258480242U,      (u32 const   )529487843U,      (u32 const   )1437280870U, 
        (u32 const   )3945269170U,      (u32 const   )3049390895U,      (u32 const   )3313212038U,      (u32 const   )923313619U, 
        (u32 const   )679998000U,      (u32 const   )3215307299U,      (u32 const   )57326082U,      (u32 const   )377642221U, 
        (u32 const   )3474729866U,      (u32 const   )2041877159U,      (u32 const   )133361907U,      (u32 const   )1776460110U, 
        (u32 const   )3673476453U,      (u32 const   )96392454U,      (u32 const   )878845905U,      (u32 const   )2801699524U, 
        (u32 const   )777231668U,      (u32 const   )4082475170U,      (u32 const   )2330014213U,      (u32 const   )4142626212U, 
        (u32 const   )2213296395U,      (u32 const   )1626319424U,      (u32 const   )1906247262U,      (u32 const   )1846563261U, 
        (u32 const   )562755902U,      (u32 const   )3708173718U,      (u32 const   )1040559837U,      (u32 const   )3871163981U, 
        (u32 const   )1418573201U,      (u32 const   )3294430577U,      (u32 const   )114585348U,      (u32 const   )1343618912U, 
        (u32 const   )2566595609U,      (u32 const   )3186202582U,      (u32 const   )1078185097U,      (u32 const   )3651041127U, 
        (u32 const   )3896688048U,      (u32 const   )2307622919U,      (u32 const   )425408743U,      (u32 const   )3371096953U, 
        (u32 const   )2081048481U,      (u32 const   )1108339068U,      (u32 const   )2216610296U,      (u32 const   )0U, 
        (u32 const   )2156299017U,      (u32 const   )736970802U,      (u32 const   )292596766U,      (u32 const   )1517440620U, 
        (u32 const   )251657213U,      (u32 const   )2235061775U,      (u32 const   )2933202493U,      (u32 const   )758720310U, 
        (u32 const   )265905162U,      (u32 const   )1554391400U,      (u32 const   )1532285339U,      (u32 const   )908999204U, 
        (u32 const   )174567692U,      (u32 const   )1474760595U,      (u32 const   )4002861748U,      (u32 const   )2610011675U, 
        (u32 const   )3234156416U,      (u32 const   )3693126241U,      (u32 const   )2001430874U,      (u32 const   )303699484U, 
        (u32 const   )2478443234U,      (u32 const   )2687165888U,      (u32 const   )585122620U,      (u32 const   )454499602U, 
        (u32 const   )151849742U,      (u32 const   )2345119218U,      (u32 const   )3064510765U,      (u32 const   )514443284U, 
        (u32 const   )4044981591U,      (u32 const   )1963412655U,      (u32 const   )2581445614U,      (u32 const   )2137062819U, 
        (u32 const   )19308535U,      (u32 const   )1928707164U,      (u32 const   )1715193156U,      (u32 const   )4219352155U, 
        (u32 const   )1126790795U,      (u32 const   )600235211U,      (u32 const   )3992742070U,      (u32 const   )3841024952U, 
        (u32 const   )836553431U,      (u32 const   )1669664834U,      (u32 const   )2535604243U,      (u32 const   )3323011204U, 
        (u32 const   )1243905413U,      (u32 const   )3141400786U,      (u32 const   )4180808110U,      (u32 const   )698445255U, 
        (u32 const   )2653899549U,      (u32 const   )2989552604U,      (u32 const   )2253581325U,      (u32 const   )3252932727U, 
        (u32 const   )3004591147U,      (u32 const   )1891211689U,      (u32 const   )2487810577U,      (u32 const   )3915653703U, 
        (u32 const   )4237083816U,      (u32 const   )4030667424U,      (u32 const   )2100090966U,      (u32 const   )865136418U, 
        (u32 const   )1229899655U,      (u32 const   )953270745U,      (u32 const   )3399679628U,      (u32 const   )3557504664U, 
        (u32 const   )4118925222U,      (u32 const   )2061379749U,      (u32 const   )3079546586U,      (u32 const   )2915017791U, 
        (u32 const   )983426092U,      (u32 const   )2022837584U,      (u32 const   )1607244650U,      (u32 const   )2118541908U, 
        (u32 const   )2366882550U,      (u32 const   )3635996816U,      (u32 const   )972512814U,      (u32 const   )3283088770U, 
        (u32 const   )1568718495U,      (u32 const   )3499326569U,      (u32 const   )3576539503U,      (u32 const   )621982671U, 
        (u32 const   )2895723464U,      (u32 const   )410887952U,      (u32 const   )2623762152U,      (u32 const   )1002142683U, 
        (u32 const   )645401037U,      (u32 const   )1494807662U,      (u32 const   )2595684844U,      (u32 const   )1335535747U, 
        (u32 const   )2507040230U,      (u32 const   )4293295786U,      (u32 const   )3167684641U,      (u32 const   )367585007U, 
        (u32 const   )3885750714U,      (u32 const   )1865862730U,      (u32 const   )2668221674U,      (u32 const   )2960971305U, 
        (u32 const   )2763173681U,      (u32 const   )1059270954U,      (u32 const   )2777952454U,      (u32 const   )2724642869U, 
        (u32 const   )1320957812U,      (u32 const   )2194319100U,      (u32 const   )2429595872U,      (u32 const   )2815956275U, 
        (u32 const   )77089521U,      (u32 const   )3973773121U,      (u32 const   )3444575871U,      (u32 const   )2448830231U, 
        (u32 const   )1305906550U,      (u32 const   )4021308739U,      (u32 const   )2857194700U,      (u32 const   )2516901860U, 
        (u32 const   )3518358430U,      (u32 const   )1787304780U,      (u32 const   )740276417U,      (u32 const   )1699839814U, 
        (u32 const   )1592394909U,      (u32 const   )2352307457U,      (u32 const   )2272556026U,      (u32 const   )188821243U, 
        (u32 const   )1729977011U,      (u32 const   )3687994002U,      (u32 const   )274084841U,      (u32 const   )3594982253U, 
        (u32 const   )3613494426U,      (u32 const   )2701949495U,      (u32 const   )4162096729U,      (u32 const   )322734571U, 
        (u32 const   )2837966542U,      (u32 const   )1640576439U,      (u32 const   )484830689U,      (u32 const   )1202797690U, 
        (u32 const   )3537852828U,      (u32 const   )4067639125U,      (u32 const   )349075736U,      (u32 const   )3342319475U, 
        (u32 const   )4157467219U,      (u32 const   )4255800159U,      (u32 const   )1030690015U,      (u32 const   )1155237496U, 
        (u32 const   )2951971274U,      (u32 const   )1757691577U,      (u32 const   )607398968U,      (u32 const   )2738905026U, 
        (u32 const   )499347990U,      (u32 const   )3794078908U,      (u32 const   )1011452712U,      (u32 const   )227885567U, 
        (u32 const   )2818666809U,      (u32 const   )213114376U,      (u32 const   )3034881240U,      (u32 const   )1455525988U, 
        (u32 const   )3414450555U,      (u32 const   )850817237U,      (u32 const   )1817998408U,      (u32 const   )3092726480U};
#line 647 "rijndael.c"
static u32 const   Td4[256]  = 
#line 647
  {      (u32 const   )1381126738U,      (u32 const   )151587081U,      (u32 const   )1785358954U,      (u32 const   )3587560917U, 
        (u32 const   )808464432U,      (u32 const   )909522486U,      (u32 const   )2779096485U,      (u32 const   )943208504U, 
        (u32 const   )3217014719U,      (u32 const   )1077952576U,      (u32 const   )2745410467U,      (u32 const   )2661195422U, 
        (u32 const   )2172748161U,      (u32 const   )4092851187U,      (u32 const   )3621246935U,      (u32 const   )4227595259U, 
        (u32 const   )2088533116U,      (u32 const   )3823363043U,      (u32 const   )960051513U,      (u32 const   )2189591170U, 
        (u32 const   )2610666395U,      (u32 const   )791621423U,      (u32 const   )4294967295U,      (u32 const   )2273806215U, 
        (u32 const   )875836468U,      (u32 const   )2391707278U,      (u32 const   )1128481603U,      (u32 const   )1145324612U, 
        (u32 const   )3301229764U,      (u32 const   )3739147998U,      (u32 const   )3924421097U,      (u32 const   )3419130827U, 
        (u32 const   )1414812756U,      (u32 const   )2071690107U,      (u32 const   )2492765332U,      (u32 const   )842150450U, 
        (u32 const   )2795939494U,      (u32 const   )3267543746U,      (u32 const   )589505315U,      (u32 const   )1027423549U, 
        (u32 const   )4008636142U,      (u32 const   )1280068684U,      (u32 const   )2509608341U,      (u32 const   )185273099U, 
        (u32 const   )1111638594U,      (u32 const   )4210752250U,      (u32 const   )3284386755U,      (u32 const   )1313754702U, 
        (u32 const   )134744072U,      (u32 const   )774778414U,      (u32 const   )2711724449U,      (u32 const   )1717986918U, 
        (u32 const   )673720360U,      (u32 const   )3654932953U,      (u32 const   )606348324U,      (u32 const   )2998055602U, 
        (u32 const   )1987475062U,      (u32 const   )1532713819U,      (u32 const   )2728567458U,      (u32 const   )1229539657U, 
        (u32 const   )1835887981U,      (u32 const   )2341178251U,      (u32 const   )3520188881U,      (u32 const   )623191333U, 
        (u32 const   )1920103026U,      (u32 const   )4177066232U,      (u32 const   )4143380214U,      (u32 const   )1684300900U, 
        (u32 const   )2256963206U,      (u32 const   )1751672936U,      (u32 const   )2560137368U,      (u32 const   )370546198U, 
        (u32 const   )3570717908U,      (u32 const   )2762253476U,      (u32 const   )1549556828U,      (u32 const   )3435973836U, 
        (u32 const   )1566399837U,      (u32 const   )1701143909U,      (u32 const   )3065427638U,      (u32 const   )2459079314U, 
        (u32 const   )1819044972U,      (u32 const   )1886417008U,      (u32 const   )1212696648U,      (u32 const   )1347440720U, 
        (u32 const   )4261281277U,      (u32 const   )3991793133U,      (u32 const   )3115956665U,      (u32 const   )3671775962U, 
        (u32 const   )1583242846U,      (u32 const   )353703189U,      (u32 const   )1179010630U,      (u32 const   )1465341783U, 
        (u32 const   )2812782503U,      (u32 const   )2374864269U,      (u32 const   )2644352413U,      (u32 const   )2223277188U, 
        (u32 const   )2425393296U,      (u32 const   )3638089944U,      (u32 const   )2880154539U,      (u32 const   )0U, 
        (u32 const   )2358021260U,      (u32 const   )3166485692U,      (u32 const   )3553874899U,      (u32 const   )168430090U, 
        (u32 const   )4160223223U,      (u32 const   )3840206052U,      (u32 const   )1482184792U,      (u32 const   )84215045U, 
        (u32 const   )3099113656U,      (u32 const   )3014898611U,      (u32 const   )1162167621U,      (u32 const   )101058054U, 
        (u32 const   )3503345872U,      (u32 const   )741092396U,      (u32 const   )505290270U,      (u32 const   )2408550287U, 
        (u32 const   )3402287818U,      (u32 const   )1061109567U,      (u32 const   )252645135U,      (u32 const   )33686018U, 
        (u32 const   )3250700737U,      (u32 const   )2947526575U,      (u32 const   )3183328701U,      (u32 const   )50529027U, 
        (u32 const   )16843009U,      (u32 const   )320017171U,      (u32 const   )2324335242U,      (u32 const   )1802201963U, 
        (u32 const   )976894522U,      (u32 const   )2442236305U,      (u32 const   )286331153U,      (u32 const   )1094795585U, 
        (u32 const   )1330597711U,      (u32 const   )1734829927U,      (u32 const   )3705461980U,      (u32 const   )3941264106U, 
        (u32 const   )2543294359U,      (u32 const   )4076008178U,      (u32 const   )3486502863U,      (u32 const   )3469659854U, 
        (u32 const   )4042322160U,      (u32 const   )3031741620U,      (u32 const   )3873892070U,      (u32 const   )1936946035U, 
        (u32 const   )2526451350U,      (u32 const   )2896997548U,      (u32 const   )1953789044U,      (u32 const   )572662306U, 
        (u32 const   )3890735079U,      (u32 const   )2913840557U,      (u32 const   )892679477U,      (u32 const   )2240120197U, 
        (u32 const   )3806520034U,      (u32 const   )4193909241U,      (u32 const   )926365495U,      (u32 const   )3907578088U, 
        (u32 const   )471604252U,      (u32 const   )1970632053U,      (u32 const   )3755991007U,      (u32 const   )1852730990U, 
        (u32 const   )1195853639U,      (u32 const   )4059165169U,      (u32 const   )437918234U,      (u32 const   )1903260017U, 
        (u32 const   )488447261U,      (u32 const   )690563369U,      (u32 const   )3318072773U,      (u32 const   )2307492233U, 
        (u32 const   )1869573999U,      (u32 const   )3082270647U,      (u32 const   )1650614882U,      (u32 const   )235802126U, 
        (u32 const   )2863311530U,      (u32 const   )404232216U,      (u32 const   )3200171710U,      (u32 const   )454761243U, 
        (u32 const   )4244438268U,      (u32 const   )1448498774U,      (u32 const   )1044266558U,      (u32 const   )1263225675U, 
        (u32 const   )3334915782U,      (u32 const   )3537031890U,      (u32 const   )2038004089U,      (u32 const   )538976288U, 
        (u32 const   )2593823386U,      (u32 const   )3688618971U,      (u32 const   )3233857728U,      (u32 const   )4278124286U, 
        (u32 const   )2021161080U,      (u32 const   )3452816845U,      (u32 const   )1515870810U,      (u32 const   )4109694196U, 
        (u32 const   )522133279U,      (u32 const   )3722304989U,      (u32 const   )2829625512U,      (u32 const   )858993459U, 
        (u32 const   )2290649224U,      (u32 const   )117901063U,      (u32 const   )3351758791U,      (u32 const   )825307441U, 
        (u32 const   )2981212593U,      (u32 const   )303174162U,      (u32 const   )269488144U,      (u32 const   )1499027801U, 
        (u32 const   )656877351U,      (u32 const   )2155905152U,      (u32 const   )3974950124U,      (u32 const   )1600085855U, 
        (u32 const   )1616928864U,      (u32 const   )1364283729U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )421075225U,      (u32 const   )3048584629U,      (u32 const   )1246382666U,      (u32 const   )218959117U, 
        (u32 const   )757935405U,      (u32 const   )3857049061U,      (u32 const   )2054847098U,      (u32 const   )2678038431U, 
        (u32 const   )2475922323U,      (u32 const   )3385444809U,      (u32 const   )2627509404U,      (u32 const   )4025479151U, 
        (u32 const   )2694881440U,      (u32 const   )3772834016U,      (u32 const   )993737531U,      (u32 const   )1296911693U, 
        (u32 const   )2930683566U,      (u32 const   )707406378U,      (u32 const   )4126537205U,      (u32 const   )2964369584U, 
        (u32 const   )3368601800U,      (u32 const   )3958107115U,      (u32 const   )3149642683U,      (u32 const   )1010580540U, 
        (u32 const   )2206434179U,      (u32 const   )1397969747U,      (u32 const   )2576980377U,      (u32 const   )1633771873U, 
        (u32 const   )387389207U,      (u32 const   )724249387U,      (u32 const   )67372036U,      (u32 const   )2122219134U, 
        (u32 const   )3132799674U,      (u32 const   )2004318071U,      (u32 const   )3604403926U,      (u32 const   )640034342U, 
        (u32 const   )3789677025U,      (u32 const   )1768515945U,      (u32 const   )336860180U,      (u32 const   )1667457891U, 
        (u32 const   )1431655765U,      (u32 const   )555819297U,      (u32 const   )202116108U,      (u32 const   )2105376125U};
#line 713 "rijndael.c"
static u32 const   rcon[10]  = 
#line 713
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )2147483648U, 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 727 "rijndael.c"
static int rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  u32 temp ;

  {
#line 728
  i = 0;
#line 731
  *(rk + 0) = ((((unsigned int )*(cipherKey + 0) << 24) ^ ((unsigned int )*(cipherKey + 1) << 16)) ^ ((unsigned int )*(cipherKey + 2) << 8)) ^ (unsigned int )*(cipherKey + 3);
#line 732
  *(rk + 1) = ((((unsigned int )*((cipherKey + 4) + 0) << 24) ^ ((unsigned int )*((cipherKey + 4) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 4) + 2) << 8)) ^ (unsigned int )*((cipherKey + 4) + 3);
#line 733
  *(rk + 2) = ((((unsigned int )*((cipherKey + 8) + 0) << 24) ^ ((unsigned int )*((cipherKey + 8) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 8) + 2) << 8)) ^ (unsigned int )*((cipherKey + 8) + 3);
#line 734
  *(rk + 3) = ((((unsigned int )*((cipherKey + 12) + 0) << 24) ^ ((unsigned int )*((cipherKey + 12) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 12) + 2) << 8)) ^ (unsigned int )*((cipherKey + 12) + 3);
#line 735
  if (keyBits == 128) {
#line 736
    while (1) {
#line 737
      temp = *(rk + 3);
#line 738
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 744
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 745
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 746
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 747
      i ++;
#line 747
      if (i == 10) {
#line 748
        return (10);
      }
#line 750
      rk += 4;
    }
  }
#line 753
  *(rk + 4) = ((((unsigned int )*((cipherKey + 16) + 0) << 24) ^ ((unsigned int )*((cipherKey + 16) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 16) + 2) << 8)) ^ (unsigned int )*((cipherKey + 16) + 3);
#line 754
  *(rk + 5) = ((((unsigned int )*((cipherKey + 20) + 0) << 24) ^ ((unsigned int )*((cipherKey + 20) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 20) + 2) << 8)) ^ (unsigned int )*((cipherKey + 20) + 3);
#line 755
  if (keyBits == 192) {
#line 756
    while (1) {
#line 757
      temp = *(rk + 5);
#line 758
      *(rk + 6) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 764
      *(rk + 7) = *(rk + 1) ^ *(rk + 6);
#line 765
      *(rk + 8) = *(rk + 2) ^ *(rk + 7);
#line 766
      *(rk + 9) = *(rk + 3) ^ *(rk + 8);
#line 767
      i ++;
#line 767
      if (i == 8) {
#line 768
        return (12);
      }
#line 770
      *(rk + 10) = *(rk + 4) ^ *(rk + 9);
#line 771
      *(rk + 11) = *(rk + 5) ^ *(rk + 10);
#line 772
      rk += 6;
    }
  }
#line 775
  *(rk + 6) = ((((unsigned int )*((cipherKey + 24) + 0) << 24) ^ ((unsigned int )*((cipherKey + 24) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 24) + 2) << 8)) ^ (unsigned int )*((cipherKey + 24) + 3);
#line 776
  *(rk + 7) = ((((unsigned int )*((cipherKey + 28) + 0) << 24) ^ ((unsigned int )*((cipherKey + 28) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 28) + 2) << 8)) ^ (unsigned int )*((cipherKey + 28) + 3);
#line 777
  if (keyBits == 256) {
#line 778
    while (1) {
#line 779
      temp = *(rk + 7);
#line 780
      *(rk + 8) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 786
      *(rk + 9) = *(rk + 1) ^ *(rk + 8);
#line 787
      *(rk + 10) = *(rk + 2) ^ *(rk + 9);
#line 788
      *(rk + 11) = *(rk + 3) ^ *(rk + 10);
#line 789
      i ++;
#line 789
      if (i == 7) {
#line 790
        return (14);
      }
#line 792
      temp = *(rk + 11);
#line 793
      *(rk + 12) = (((*(rk + 4) ^ (unsigned int )(Te4[temp >> 24] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 16711680U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 65280U)) ^ (unsigned int )(Te4[temp & 255U] & 255U);
#line 798
      *(rk + 13) = *(rk + 5) ^ *(rk + 12);
#line 799
      *(rk + 14) = *(rk + 6) ^ *(rk + 13);
#line 800
      *(rk + 15) = *(rk + 7) ^ *(rk + 14);
#line 801
      rk += 8;
    }
  }
#line 804
  return (0);
}
}
#line 812 "rijndael.c"
static int rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits , int have_encrypt ) 
{ int Nr ;
  int i ;
  int j ;
  u32 temp ;

  {
#line 818
  if (have_encrypt) {
#line 819
    Nr = have_encrypt;
  } else {
#line 822
    Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
  }
#line 825
  i = 0;
#line 825
  j = 4 * Nr;
#line 825
  while (i < j) {
#line 826
    temp = *(rk + i);
#line 826
    *(rk + i) = *(rk + j);
#line 826
    *(rk + j) = temp;
#line 827
    temp = *(rk + (i + 1));
#line 827
    *(rk + (i + 1)) = *(rk + (j + 1));
#line 827
    *(rk + (j + 1)) = temp;
#line 828
    temp = *(rk + (i + 2));
#line 828
    *(rk + (i + 2)) = *(rk + (j + 2));
#line 828
    *(rk + (j + 2)) = temp;
#line 829
    temp = *(rk + (i + 3));
#line 829
    *(rk + (i + 3)) = *(rk + (j + 3));
#line 829
    *(rk + (j + 3)) = temp;
#line 825
    i += 4;
#line 825
    j -= 4;
  }
#line 832
  i = 1;
#line 832
  while (i < Nr) {
#line 833
    rk += 4;
#line 834
    *(rk + 0) = (unsigned int )(((Td0[Te4[*(rk + 0) >> 24] & 255U] ^ Td1[Te4[(*(rk + 0) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 0) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 0) & 255U] & 255U]);
#line 839
    *(rk + 1) = (unsigned int )(((Td0[Te4[*(rk + 1) >> 24] & 255U] ^ Td1[Te4[(*(rk + 1) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 1) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 1) & 255U] & 255U]);
#line 844
    *(rk + 2) = (unsigned int )(((Td0[Te4[*(rk + 2) >> 24] & 255U] ^ Td1[Te4[(*(rk + 2) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 2) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 2) & 255U] & 255U]);
#line 849
    *(rk + 3) = (unsigned int )(((Td0[Te4[*(rk + 3) >> 24] & 255U] ^ Td1[Te4[(*(rk + 3) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 3) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 3) & 255U] & 255U]);
#line 832
    i ++;
  }
#line 855
  return (Nr);
}
}
#line 858 "rijndael.c"
static void rijndaelEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 868
  s0 = (((((unsigned int )*(pt + 0) << 24) ^ ((unsigned int )*(pt + 1) << 16)) ^ ((unsigned int )*(pt + 2) << 8)) ^ (unsigned int )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 869
  s1 = (((((unsigned int )*((pt + 4) + 0) << 24) ^ ((unsigned int )*((pt + 4) + 1) << 16)) ^ ((unsigned int )*((pt + 4) + 2) << 8)) ^ (unsigned int )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 870
  s2 = (((((unsigned int )*((pt + 8) + 0) << 24) ^ ((unsigned int )*((pt + 8) + 1) << 16)) ^ ((unsigned int )*((pt + 8) + 2) << 8)) ^ (unsigned int )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 871
  s3 = (((((unsigned int )*((pt + 12) + 0) << 24) ^ ((unsigned int )*((pt + 12) + 1) << 16)) ^ ((unsigned int )*((pt + 12) + 2) << 8)) ^ (unsigned int )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 874
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 4));
#line 875
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 5));
#line 876
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 6));
#line 877
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 7));
#line 879
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 8));
#line 880
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 9));
#line 881
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 10));
#line 882
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 11));
#line 884
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 12));
#line 885
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 13));
#line 886
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 14));
#line 887
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 15));
#line 889
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 16));
#line 890
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 17));
#line 891
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 18));
#line 892
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 19));
#line 894
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 20));
#line 895
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 21));
#line 896
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 22));
#line 897
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 23));
#line 899
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 24));
#line 900
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 25));
#line 901
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 26));
#line 902
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 27));
#line 904
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 28));
#line 905
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 29));
#line 906
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 30));
#line 907
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 31));
#line 909
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 32));
#line 910
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 33));
#line 911
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 34));
#line 912
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 35));
#line 914
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 36));
#line 915
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 37));
#line 916
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 38));
#line 917
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 39));
#line 918
  if (Nr > 10) {
#line 920
    s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 40));
#line 921
    s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 41));
#line 922
    s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 42));
#line 923
    s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 43));
#line 925
    t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 44));
#line 926
    t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 45));
#line 927
    t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 46));
#line 928
    t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 47));
#line 929
    if (Nr > 12) {
#line 931
      s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 48));
#line 932
      s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 49));
#line 933
      s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 50));
#line 934
      s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 51));
#line 936
      t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 52));
#line 937
      t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 53));
#line 938
      t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 54));
#line 939
      t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 55));
    }
  }
#line 942
  rk += Nr << 2;
#line 1009
  s0 = (unsigned int )(((((Te4[t0 >> 24] & 4278190080U) ^ (Te4[(t1 >> 16) & 255U] & 16711680U)) ^ (Te4[(t2 >> 8) & 255U] & 65280U)) ^ (Te4[t3 & 255U] & 255U)) ^ *(rk + 0));
#line 1015
  *(ct + 0) = (unsigned char )(s0 >> 24);
#line 1015
  *(ct + 1) = (unsigned char )(s0 >> 16);
#line 1015
  *(ct + 2) = (unsigned char )(s0 >> 8);
#line 1015
  *(ct + 3) = (unsigned char )s0;
#line 1016
  s1 = (unsigned int )(((((Te4[t1 >> 24] & 4278190080U) ^ (Te4[(t2 >> 16) & 255U] & 16711680U)) ^ (Te4[(t3 >> 8) & 255U] & 65280U)) ^ (Te4[t0 & 255U] & 255U)) ^ *(rk + 1));
#line 1022
  *((ct + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1022
  *((ct + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1022
  *((ct + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1022
  *((ct + 4) + 3) = (unsigned char )s1;
#line 1023
  s2 = (unsigned int )(((((Te4[t2 >> 24] & 4278190080U) ^ (Te4[(t3 >> 16) & 255U] & 16711680U)) ^ (Te4[(t0 >> 8) & 255U] & 65280U)) ^ (Te4[t1 & 255U] & 255U)) ^ *(rk + 2));
#line 1029
  *((ct + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1029
  *((ct + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1029
  *((ct + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1029
  *((ct + 8) + 3) = (unsigned char )s2;
#line 1030
  s3 = (unsigned int )(((((Te4[t3 >> 24] & 4278190080U) ^ (Te4[(t0 >> 16) & 255U] & 16711680U)) ^ (Te4[(t1 >> 8) & 255U] & 65280U)) ^ (Te4[t2 & 255U] & 255U)) ^ *(rk + 3));
#line 1036
  *((ct + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1036
  *((ct + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1036
  *((ct + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1036
  *((ct + 12) + 3) = (unsigned char )s3;
#line 1037
  return;
}
}
#line 1039 "rijndael.c"
static void rijndaelDecrypt(u32 const   *rk , int Nr , u8 const   *ct , u8 *pt ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 1049
  s0 = (((((unsigned int )*(ct + 0) << 24) ^ ((unsigned int )*(ct + 1) << 16)) ^ ((unsigned int )*(ct + 2) << 8)) ^ (unsigned int )*(ct + 3)) ^ (unsigned int )*(rk + 0);
#line 1050
  s1 = (((((unsigned int )*((ct + 4) + 0) << 24) ^ ((unsigned int )*((ct + 4) + 1) << 16)) ^ ((unsigned int )*((ct + 4) + 2) << 8)) ^ (unsigned int )*((ct + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 1051
  s2 = (((((unsigned int )*((ct + 8) + 0) << 24) ^ ((unsigned int )*((ct + 8) + 1) << 16)) ^ ((unsigned int )*((ct + 8) + 2) << 8)) ^ (unsigned int )*((ct + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 1052
  s3 = (((((unsigned int )*((ct + 12) + 0) << 24) ^ ((unsigned int )*((ct + 12) + 1) << 16)) ^ ((unsigned int )*((ct + 12) + 2) << 8)) ^ (unsigned int )*((ct + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 1055
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 4));
#line 1056
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 5));
#line 1057
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 6));
#line 1058
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 7));
#line 1060
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 8));
#line 1061
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 9));
#line 1062
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 10));
#line 1063
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 11));
#line 1065
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 12));
#line 1066
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 13));
#line 1067
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 14));
#line 1068
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 15));
#line 1070
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 16));
#line 1071
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 17));
#line 1072
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 18));
#line 1073
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 19));
#line 1075
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 20));
#line 1076
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 21));
#line 1077
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 22));
#line 1078
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 23));
#line 1080
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 24));
#line 1081
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 25));
#line 1082
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 26));
#line 1083
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 27));
#line 1085
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 28));
#line 1086
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 29));
#line 1087
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 30));
#line 1088
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 31));
#line 1090
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 32));
#line 1091
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 33));
#line 1092
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 34));
#line 1093
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 35));
#line 1095
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 36));
#line 1096
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 37));
#line 1097
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 38));
#line 1098
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 39));
#line 1099
  if (Nr > 10) {
#line 1101
    s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 40));
#line 1102
    s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 41));
#line 1103
    s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 42));
#line 1104
    s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 43));
#line 1106
    t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 44));
#line 1107
    t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 45));
#line 1108
    t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 46));
#line 1109
    t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 47));
#line 1110
    if (Nr > 12) {
#line 1112
      s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 48));
#line 1113
      s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 49));
#line 1114
      s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 50));
#line 1115
      s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 51));
#line 1117
      t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 52));
#line 1118
      t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 53));
#line 1119
      t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 54));
#line 1120
      t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 55));
    }
  }
#line 1123
  rk += Nr << 2;
#line 1190
  s0 = (unsigned int )(((((Td4[t0 >> 24] & 4278190080U) ^ (Td4[(t3 >> 16) & 255U] & 16711680U)) ^ (Td4[(t2 >> 8) & 255U] & 65280U)) ^ (Td4[t1 & 255U] & 255U)) ^ *(rk + 0));
#line 1196
  *(pt + 0) = (unsigned char )(s0 >> 24);
#line 1196
  *(pt + 1) = (unsigned char )(s0 >> 16);
#line 1196
  *(pt + 2) = (unsigned char )(s0 >> 8);
#line 1196
  *(pt + 3) = (unsigned char )s0;
#line 1197
  s1 = (unsigned int )(((((Td4[t1 >> 24] & 4278190080U) ^ (Td4[(t0 >> 16) & 255U] & 16711680U)) ^ (Td4[(t3 >> 8) & 255U] & 65280U)) ^ (Td4[t2 & 255U] & 255U)) ^ *(rk + 1));
#line 1203
  *((pt + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1203
  *((pt + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1203
  *((pt + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1203
  *((pt + 4) + 3) = (unsigned char )s1;
#line 1204
  s2 = (unsigned int )(((((Td4[t2 >> 24] & 4278190080U) ^ (Td4[(t1 >> 16) & 255U] & 16711680U)) ^ (Td4[(t0 >> 8) & 255U] & 65280U)) ^ (Td4[t3 & 255U] & 255U)) ^ *(rk + 2));
#line 1210
  *((pt + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1210
  *((pt + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1210
  *((pt + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1210
  *((pt + 8) + 3) = (unsigned char )s2;
#line 1211
  s3 = (unsigned int )(((((Td4[t3 >> 24] & 4278190080U) ^ (Td4[(t2 >> 16) & 255U] & 16711680U)) ^ (Td4[(t1 >> 8) & 255U] & 65280U)) ^ (Td4[t0 & 255U] & 255U)) ^ *(rk + 3));
#line 1217
  *((pt + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1217
  *((pt + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1217
  *((pt + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1217
  *((pt + 12) + 3) = (unsigned char )s3;
#line 1218
  return;
}
}
#line 1220 "rijndael.c"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int do_encrypt ) 
{ 

  {
#line 1223
  ctx->Nr = rijndaelKeySetupEnc(ctx->ek, (u8 const   *)key, bits);
#line 1224
  if (do_encrypt) {
#line 1225
    ctx->decrypt = 0;
#line 1226
    memset((void *)(ctx->dk), 0, sizeof(ctx->dk));
  } else {
#line 1228
    ctx->decrypt = 1;
#line 1229
    memcpy((void * __restrict  )(ctx->dk), (void const   * __restrict  )(ctx->ek),
           sizeof(ctx->dk));
#line 1230
    rijndaelKeySetupDec(ctx->dk, (u8 const   *)key, bits, ctx->Nr);
  }
#line 1232
  return;
}
}
#line 1234 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1237
  rijndaelDecrypt((u32 const   *)(ctx->dk), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1238
  return;
}
}
#line 1240 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1243
  rijndaelEncrypt((u32 const   *)(ctx->ek), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1244
  return;
}
}
#line 1 "ssh-dss.o"
#pragma merger(0,"./ssh-dss.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 45 "ssh-dss.c"
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char sigblob[40] ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  Buffer b ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 50
  tmp = EVP_sha1();
#line 50
  evp_md = tmp;
#line 56
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 57
    error("ssh_dss_sign: no DSA key");
#line 58
    return (-1);
  } else {
#line 56
    if (key->type != 2) {
#line 57
      error("ssh_dss_sign: no DSA key");
#line 58
      return (-1);
    } else {
#line 56
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 57
        error("ssh_dss_sign: no DSA key");
#line 58
        return (-1);
      }
    }
  }
#line 60
  EVP_DigestInit(& md, evp_md);
#line 61
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 62
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 64
  sig = DSA_do_sign((unsigned char const   *)(digest___1), (int )dlen, (DSA *)key->dsa);
#line 65
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 67
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 68
    error("ssh_dss_sign: sign failed");
#line 69
    return (-1);
  }
#line 72
  tmp___0 = BN_num_bits((BIGNUM const   *)sig->r);
#line 72
  rlen = (unsigned int )((tmp___0 + 7) / 8);
#line 73
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->s);
#line 73
  slen = (unsigned int )((tmp___1 + 7) / 8);
#line 74
  if (rlen > 20U) {
#line 75
    error("bad sig size %u %u", rlen, slen);
#line 76
    DSA_SIG_free(sig);
#line 77
    return (-1);
  } else {
#line 74
    if (slen > 20U) {
#line 75
      error("bad sig size %u %u", rlen, slen);
#line 76
      DSA_SIG_free(sig);
#line 77
      return (-1);
    }
  }
#line 79
  memset((void *)(sigblob), 0, 40U);
#line 80
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 81
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 82
  DSA_SIG_free(sig);
#line 84
  if (datafellows & 1) {
#line 85
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 86
      *lenp = 40U;
    }
#line 87
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 88
      tmp___2 = xmalloc(40U);
#line 88
      *sigp = (u_char *)tmp___2;
#line 89
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )(sigblob), 40U);
    }
  } else {
#line 93
    buffer_init(& b);
#line 94
    buffer_put_cstring(& b, "ssh-dss");
#line 95
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 96
    len = buffer_len(& b);
#line 97
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 98
      *lenp = len;
    }
#line 99
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 100
      tmp___3 = xmalloc(len);
#line 100
      *sigp = (u_char *)tmp___3;
#line 101
      tmp___4 = buffer_ptr(& b);
#line 101
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___4, len);
    }
#line 103
    buffer_free(& b);
  }
#line 105
  return (0);
}
}
#line 107 "ssh-dss.c"
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret___0 ;
  Buffer b ;
  void *tmp___0 ;
  char *ktype ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  BIGNUM *tmp___14 ;
  BIGNUM *tmp___15 ;
  char const   *tmp___17 ;

  {
#line 112
  tmp = EVP_sha1();
#line 112
  evp_md = tmp;
#line 119
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 120
    error("ssh_dss_verify: no DSA key");
#line 121
    return (-1);
  } else {
#line 119
    if (key->type != 2) {
#line 120
      error("ssh_dss_verify: no DSA key");
#line 121
      return (-1);
    } else {
#line 119
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 120
        error("ssh_dss_verify: no DSA key");
#line 121
        return (-1);
      }
    }
  }
#line 125
  if (datafellows & 1) {
#line 126
    tmp___0 = xmalloc(signaturelen);
#line 126
    sigblob = (u_char *)tmp___0;
#line 127
    memcpy((void * __restrict  )sigblob, (void const   * __restrict  )signature, signaturelen);
#line 128
    len = signaturelen;
  } else {
#line 132
    buffer_init(& b);
#line 133
    buffer_append(& b, (void const   *)signature, signaturelen);
#line 134
    tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 134
    ktype = (char *)tmp___1;
#line 135
    if (0) {
#line 135
      __s1_len = strlen("ssh-dss");
#line 135
      __s2_len = strlen((char const   *)ktype);
#line 135
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___0;
      } else {
#line 135
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 135
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 135
            tmp___11 = 1;
          } else {
#line 135
            if (__s2_len >= 4U) {
#line 135
              tmp___11 = 1;
            } else {
#line 135
              tmp___11 = 0;
            }
          }
        } else {
#line 135
          tmp___11 = 0;
        }
      }
#line 135
      if (tmp___11) {
#line 135
        tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 135
        tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 135
        tmp___7 = tmp___10;
      }
    } else {
#line 135
      tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 135
      tmp___7 = tmp___10;
    }
#line 135
    if (tmp___7 != 0) {
#line 136
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 137
      buffer_free(& b);
#line 138
      xfree((void *)ktype);
#line 139
      return (-1);
    }
#line 141
    xfree((void *)ktype);
#line 142
    tmp___12 = buffer_get_string(& b, & len);
#line 142
    sigblob = (u_char *)tmp___12;
#line 143
    tmp___13 = buffer_len(& b);
#line 143
    rlen = (int )tmp___13;
#line 144
    buffer_free(& b);
#line 145
    if (rlen != 0) {
#line 146
      error("ssh_dss_verify: remaining bytes in signature %d", rlen);
#line 148
      xfree((void *)sigblob);
#line 149
      return (-1);
    }
  }
#line 153
  if (len != 40U) {
#line 154
    fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
  }
#line 158
  sig = DSA_SIG_new();
#line 158
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 159
    fatal("ssh_dss_verify: DSA_SIG_new failed");
  }
#line 160
  sig->r = BN_new();
#line 160
  if ((unsigned int )sig->r == (unsigned int )((void *)0)) {
#line 161
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 162
  sig->s = BN_new();
#line 162
  if ((unsigned int )sig->s == (unsigned int )((void *)0)) {
#line 163
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 164
  tmp___14 = BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 164
  if ((unsigned int )tmp___14 == (unsigned int )((void *)0)) {
#line 166
    fatal("ssh_dss_verify: BN_bin2bn failed");
  } else {
#line 164
    tmp___15 = BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 164
    if ((unsigned int )tmp___15 == (unsigned int )((void *)0)) {
#line 166
      fatal("ssh_dss_verify: BN_bin2bn failed");
    }
  }
#line 169
  memset((void *)sigblob, 0, len);
#line 170
  xfree((void *)sigblob);
#line 173
  EVP_DigestInit(& md, evp_md);
#line 174
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 175
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 177
  ret___0 = DSA_do_verify((unsigned char const   *)(digest___1), (int )dlen, sig,
                          (DSA *)key->dsa);
#line 178
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 180
  DSA_SIG_free(sig);
#line 182
  if (ret___0 == 1) {
#line 182
    tmp___17 = "correct";
  } else {
#line 182
    if (ret___0 == 0) {
#line 182
      tmp___17 = "incorrect";
    } else {
#line 182
      tmp___17 = "error";
    }
  }
#line 182
  debug("ssh_dss_verify: signature %s", tmp___17);
#line 184
  return (ret___0);
}
}
#line 1 "ssh-rsa.o"
#pragma merger(0,"./ssh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1006 "/usr/include/openssl/objects.h"
extern char const   *OBJ_nid2sn(int n ) ;
#line 732 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_get_digestbyname(char const   *name ) ;
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 234
extern int RSA_public_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 35 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) ;
#line 38 "ssh-rsa.c"
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sig ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  int nid ;
  Buffer b ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int ecode ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  u_int diff ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 49
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 50
    error("ssh_rsa_sign: no RSA key");
#line 51
    return (-1);
  } else {
#line 49
    if (key->type != 1) {
#line 50
      error("ssh_rsa_sign: no RSA key");
#line 51
      return (-1);
    } else {
#line 49
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 50
        error("ssh_rsa_sign: no RSA key");
#line 51
        return (-1);
      }
    }
  }
#line 53
  if (datafellows & 8192) {
#line 53
    nid = 4;
  } else {
#line 53
    nid = 64;
  }
#line 54
  tmp = OBJ_nid2sn(nid);
#line 54
  evp_md = EVP_get_digestbyname(tmp);
#line 54
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 55
    error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
#line 56
    return (-1);
  }
#line 58
  EVP_DigestInit(& md, evp_md);
#line 59
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 60
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 62
  tmp___0 = RSA_size((RSA const   *)key->rsa);
#line 62
  slen = (unsigned int )tmp___0;
#line 63
  tmp___1 = xmalloc(slen);
#line 63
  sig = (u_char *)tmp___1;
#line 65
  ok = RSA_sign(nid, (unsigned char const   *)(digest___1), dlen, sig, & len, (RSA *)key->rsa);
#line 66
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 68
  if (ok != 1) {
#line 69
    tmp___2 = ERR_get_error();
#line 69
    ecode = (int )tmp___2;
#line 71
    tmp___3 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 71
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___3);
#line 73
    xfree((void *)sig);
#line 74
    return (-1);
  }
#line 76
  if (len < slen) {
#line 77
    diff = slen - len;
#line 78
    debug("slen %u > len %u", slen, len);
#line 79
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 80
    memset((void *)sig, 0, diff);
  } else {
#line 81
    if (len > slen) {
#line 82
      error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
#line 83
      xfree((void *)sig);
#line 84
      return (-1);
    }
  }
#line 87
  buffer_init(& b);
#line 88
  buffer_put_cstring(& b, "ssh-rsa");
#line 89
  buffer_put_string(& b, (void const   *)sig, slen);
#line 90
  len = buffer_len(& b);
#line 91
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 92
    *lenp = len;
  }
#line 93
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 94
    tmp___4 = xmalloc(len);
#line 94
    *sigp = (u_char *)tmp___4;
#line 95
    tmp___5 = buffer_ptr(& b);
#line 95
    memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___5, len);
  }
#line 97
  buffer_free(& b);
#line 98
  memset((void *)sig, 's', slen);
#line 99
  xfree((void *)sig);
#line 101
  return (0);
}
}
#line 104 "ssh-rsa.c"
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  u_int modlen ;
  int rlen ;
  int ret___0 ;
  int nid ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  int tmp___14 ;
  u_int diff ;
  void *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 116
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 117
    error("ssh_rsa_verify: no RSA key");
#line 118
    return (-1);
  } else {
#line 116
    if (key->type != 1) {
#line 117
      error("ssh_rsa_verify: no RSA key");
#line 118
      return (-1);
    } else {
#line 116
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 117
        error("ssh_rsa_verify: no RSA key");
#line 118
        return (-1);
      }
    }
  }
#line 120
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 120
  if (tmp___0 < 768) {
#line 121
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 121
    error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits", tmp, 768);
#line 123
    return (-1);
  }
#line 125
  buffer_init(& b);
#line 126
  buffer_append(& b, (void const   *)signature, signaturelen);
#line 127
  tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 127
  ktype = (char *)tmp___1;
#line 128
  if (0) {
#line 128
    __s1_len = strlen("ssh-rsa");
#line 128
    __s2_len = strlen((char const   *)ktype);
#line 128
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 128
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 128
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 128
          tmp___11 = 1;
        } else {
#line 128
          if (__s2_len >= 4U) {
#line 128
            tmp___11 = 1;
          } else {
#line 128
            tmp___11 = 0;
          }
        }
      } else {
#line 128
        tmp___11 = 0;
      }
    }
#line 128
    if (tmp___11) {
#line 128
      tmp___7 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 128
      tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 128
      tmp___7 = tmp___10;
    }
  } else {
#line 128
    tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 128
    tmp___7 = tmp___10;
  }
#line 128
  if (tmp___7 != 0) {
#line 129
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 130
    buffer_free(& b);
#line 131
    xfree((void *)ktype);
#line 132
    return (-1);
  }
#line 134
  xfree((void *)ktype);
#line 135
  tmp___12 = buffer_get_string(& b, & len);
#line 135
  sigblob = (u_char *)tmp___12;
#line 136
  tmp___13 = buffer_len(& b);
#line 136
  rlen = (int )tmp___13;
#line 137
  buffer_free(& b);
#line 138
  if (rlen != 0) {
#line 139
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 140
    xfree((void *)sigblob);
#line 141
    return (-1);
  }
#line 144
  tmp___14 = RSA_size((RSA const   *)key->rsa);
#line 144
  modlen = (unsigned int )tmp___14;
#line 145
  if (len > modlen) {
#line 146
    error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
#line 147
    xfree((void *)sigblob);
#line 148
    return (-1);
  } else {
#line 149
    if (len < modlen) {
#line 150
      diff = modlen - len;
#line 151
      debug("ssh_rsa_verify: add padding: modlen %u > len %u", modlen, len);
#line 153
      tmp___15 = xrealloc((void *)sigblob, 1U, modlen);
#line 153
      sigblob = (u_char *)tmp___15;
#line 154
      memmove((void *)(sigblob + diff), (void const   *)sigblob, len);
#line 155
      memset((void *)sigblob, 0, diff);
#line 156
      len = modlen;
    }
  }
#line 158
  if (datafellows & 8192) {
#line 158
    nid = 4;
  } else {
#line 158
    nid = 64;
  }
#line 159
  tmp___16 = OBJ_nid2sn(nid);
#line 159
  evp_md = EVP_get_digestbyname(tmp___16);
#line 159
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 160
    error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
#line 161
    xfree((void *)sigblob);
#line 162
    return (-1);
  }
#line 164
  EVP_DigestInit(& md, evp_md);
#line 165
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 166
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 168
  ret___0 = openssh_RSA_verify(nid, digest___1, dlen, sigblob, len, (RSA *)key->rsa);
#line 169
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 170
  memset((void *)sigblob, 's', len);
#line 171
  xfree((void *)sigblob);
#line 172
  if (ret___0 == 0) {
#line 172
    tmp___17 = "in";
  } else {
#line 172
    tmp___17 = "";
  }
#line 172
  debug("ssh_rsa_verify: signature %scorrect", tmp___17);
#line 173
  return (ret___0);
}
}
#line 185 "ssh-rsa.c"
static u_char const   id_sha1[15]  = 
#line 185
  {      (u_char const   )48,      (u_char const   )33,      (u_char const   )48,      (u_char const   )9, 
        (u_char const   )6,      (u_char const   )5,      (u_char const   )43,      (u_char const   )14, 
        (u_char const   )3,      (u_char const   )2,      (u_char const   )26,      (u_char const   )5, 
        (u_char const   )0,      (u_char const   )4,      (u_char const   )20};
#line 197 "ssh-rsa.c"
static u_char const   id_md5[18]  = 
#line 197
  {      (u_char const   )48,      (u_char const   )32,      (u_char const   )48,      (u_char const   )12, 
        (u_char const   )6,      (u_char const   )8,      (u_char const   )42,      (u_char const   )134, 
        (u_char const   )72,      (u_char const   )134,      (u_char const   )247,      (u_char const   )13, 
        (u_char const   )2,      (u_char const   )5,      (u_char const   )5,      (u_char const   )0, 
        (u_char const   )4,      (u_char const   )16};
#line 206 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) 
{ u_int ret___0 ;
  u_int rsasize ;
  u_int oidlen ;
  u_int hlen ;
  int len ;
  u_char const   *oid ;
  u_char *decrypted ;
  int tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 210
  oidlen = (u_int )0;
#line 210
  hlen = (u_int )0;
#line 212
  oid = (u_char const   *)((void *)0);
#line 213
  decrypted = (u_char *)((void *)0);
#line 215
  ret___0 = 0U;
#line 216
  switch (type) {
  case 64: 
#line 218
  oid = id_sha1;
#line 219
  oidlen = sizeof(id_sha1);
#line 220
  hlen = 20U;
#line 221
  break;
  case 4: 
#line 223
  oid = id_md5;
#line 224
  oidlen = sizeof(id_md5);
#line 225
  hlen = 16U;
#line 226
  break;
  default: ;
  goto done;
  }
#line 230
  if (hashlen != hlen) {
#line 231
    error("bad hashlen");
    goto done;
  }
#line 234
  tmp = RSA_size((RSA const   *)rsa);
#line 234
  rsasize = (unsigned int )tmp;
#line 235
  if (siglen == 0U) {
#line 236
    error("bad siglen");
    goto done;
  } else {
#line 235
    if (siglen > rsasize) {
#line 236
      error("bad siglen");
      goto done;
    }
  }
#line 239
  tmp___0 = xmalloc(rsasize);
#line 239
  decrypted = (u_char *)tmp___0;
#line 240
  len = RSA_public_decrypt((int )siglen, (unsigned char const   *)sigbuf, decrypted,
                           rsa, 1);
#line 240
  if (len < 0) {
#line 242
    tmp___1 = ERR_get_error();
#line 242
    tmp___2 = ERR_error_string(tmp___1, (char *)((void *)0));
#line 242
    error("RSA_public_decrypt failed: %s", tmp___2);
    goto done;
  }
#line 246
  if (len < 0) {
#line 247
    error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
    goto done;
  } else {
#line 246
    if ((unsigned int )len != hlen + oidlen) {
#line 247
      error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
      goto done;
    }
  }
#line 250
  tmp___3 = memcmp((void const   *)decrypted, (void const   *)oid, oidlen);
#line 250
  if (tmp___3 != 0) {
#line 251
    error("oid mismatch");
    goto done;
  }
#line 254
  tmp___4 = memcmp((void const   *)(decrypted + oidlen), (void const   *)hash, hlen);
#line 254
  if (tmp___4 != 0) {
#line 255
    error("hash mismatch");
    goto done;
  }
#line 258
  ret___0 = 1U;
  done: 
#line 260
  if (decrypted) {
#line 261
    xfree((void *)decrypted);
  }
#line 262
  return ((int )ret___0);
}
}
#line 1 "dh.o"
#pragma merger(0,"./dh.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 660 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 459 "/usr/include/openssl/bn.h"
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 35 "dh.h"
DH *choose_dh(int min , int wantbits , int max ) ;
#line 36
DH *dh_new_group_asc(char const   *gen___1 , char const   *modulus ) ;
#line 37
DH *dh_new_group(BIGNUM *gen___1 , BIGNUM *modulus ) ;
#line 38
DH *dh_new_group1(void) ;
#line 39
DH *dh_new_group14(void) ;
#line 41
void dh_gen_key(DH *dh , int need ) ;
#line 42
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 44
int dh_estimate(int bits ) ;
#line 43 "dh.c"
static int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___1 ;
  char *prime ;
  char const   *errstr ;
  long long n___0 ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  long long tmp___63 ;
  char *tmp___79 ;
  char *tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;

  {
#line 48
  errstr = (char const   *)((void *)0);
#line 51
  cp = line;
#line 52
  arg = strdelim(& cp);
#line 52
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 53
    return (0);
  }
#line 55
  if ((int )*arg == 0) {
#line 56
    arg = strdelim(& cp);
  }
#line 57
  if (! arg) {
#line 58
    return (0);
  } else {
#line 57
    if (! *arg) {
#line 58
      return (0);
    } else {
#line 57
      if ((int )*arg == 35) {
#line 58
        return (0);
      }
    }
  }
#line 61
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 61
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 63
  tmp___14 = __strsep_g(& cp, " ");
#line 63
  arg = tmp___14;
#line 64
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 64
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 67
  n___0 = strtonum((char const   *)arg, 0LL, 5LL, & errstr);
#line 68
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 68
    if (n___0 != 2LL) {
      goto fail;
    }
  }
#line 70
  tmp___30 = __strsep_g(& cp, " ");
#line 70
  arg = tmp___30;
#line 71
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 71
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 74
  n___0 = strtonum((char const   *)arg, 0LL, 31LL, & errstr);
#line 75
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 75
    if (n___0 & 1LL) {
      goto fail;
    } else {
#line 75
      if (! (n___0 & -2LL)) {
        goto fail;
      }
    }
  }
#line 78
  tmp___46 = __strsep_g(& cp, " ");
#line 78
  arg = tmp___46;
#line 79
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 79
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 81
  n___0 = strtonum((char const   *)arg, 0LL, (long long )(1 << 30), & errstr);
#line 82
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 82
    if (n___0 == 0LL) {
      goto fail;
    }
  }
#line 84
  tmp___62 = __strsep_g(& cp, " ");
#line 84
  strsize = tmp___62;
#line 85
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 85
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 85
      tmp___63 = strtonum((char const   *)strsize, 0LL, 65536LL, & errstr);
#line 85
      dhg->size = (int )((unsigned int )tmp___63);
#line 85
      if (dhg->size == 0) {
        goto fail;
      } else {
#line 85
        if (errstr) {
          goto fail;
        }
      }
    }
  }
#line 90
  (dhg->size) ++;
#line 91
  tmp___79 = __strsep_g(& cp, " ");
#line 91
  gen___1 = tmp___79;
#line 92
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 92
    if ((int )*gen___1 == 0) {
      goto fail;
    }
  }
#line 94
  tmp___95 = __strsep_g(& cp, " ");
#line 94
  prime = tmp___95;
#line 95
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 95
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 98
  dhg->g = BN_new();
#line 98
  if ((unsigned int )dhg->g == (unsigned int )((void *)0)) {
#line 99
    fatal("parse_prime: BN_new failed");
  }
#line 100
  dhg->p = BN_new();
#line 100
  if ((unsigned int )dhg->p == (unsigned int )((void *)0)) {
#line 101
    fatal("parse_prime: BN_new failed");
  }
#line 102
  tmp___96 = BN_hex2bn(& dhg->g, (char const   *)gen___1);
#line 102
  if (tmp___96 == 0) {
    goto failclean;
  }
#line 105
  tmp___97 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 105
  if (tmp___97 == 0) {
    goto failclean;
  }
#line 108
  tmp___98 = BN_num_bits((BIGNUM const   *)dhg->p);
#line 108
  if (tmp___98 != dhg->size) {
    goto failclean;
  }
#line 111
  if ((dhg->g)->top == 0) {
    goto failclean;
  } else {
#line 111
    if ((dhg->g)->top == 1) {
#line 111
      if (*((dhg->g)->d + 0) == 1UL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 111
      if (0) {
        _L: /* CIL Label */ 
#line 111
        if (! (dhg->g)->neg) {
          goto failclean;
        }
      }
    }
  }
#line 114
  return (1);
  failclean: 
#line 117
  BN_clear_free(dhg->g);
#line 118
  BN_clear_free(dhg->p);
  fail: 
#line 120
  error("Bad prime description in line %d", linenum);
#line 121
  return (0);
}
}
#line 124 "dh.c"
DH *choose_dh(int min , int wantbits , int max ) 
{ FILE *f ;
  char line[4096] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  DH *tmp___2 ;
  u_int32_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  DH *tmp___7 ;

  {
#line 133
  f = fopen((char const   * __restrict  )"/usr/local/etc/moduli", (char const   * __restrict  )"r");
#line 133
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 133
    f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 133
    if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 135
      logit("WARNING: %s does not exist, using fixed modulus", "/usr/local/etc/moduli");
#line 137
      tmp = dh_new_group14();
#line 137
      return (tmp);
    }
  }
#line 140
  linenum = 0;
#line 141
  bestcount = 0;
#line 141
  best = bestcount;
#line 142
  while (1) {
#line 142
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 142
    if (! tmp___1) {
#line 142
      break;
    }
#line 143
    linenum ++;
#line 144
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 144
    if (! tmp___0) {
#line 145
      continue;
    }
#line 146
    BN_clear_free(dhg.g);
#line 147
    BN_clear_free(dhg.p);
#line 149
    if (dhg.size > max) {
#line 150
      continue;
    } else {
#line 149
      if (dhg.size < min) {
#line 150
        continue;
      }
    }
#line 152
    if (dhg.size > wantbits) {
#line 152
      if (dhg.size < best) {
#line 154
        best = dhg.size;
#line 155
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 152
      if (dhg.size > best) {
#line 152
        if (best < wantbits) {
#line 154
          best = dhg.size;
#line 155
          bestcount = 0;
        }
      }
    }
#line 157
    if (dhg.size == best) {
#line 158
      bestcount ++;
    }
  }
#line 160
  rewind(f);
#line 162
  if (bestcount == 0) {
#line 163
    fclose(f);
#line 164
    logit("WARNING: no suitable primes in %s", "/usr/local/etc/primes");
#line 165
    tmp___2 = dh_new_group14();
#line 165
    return (tmp___2);
  }
#line 168
  linenum = 0;
#line 169
  tmp___3 = arc4random_uniform((unsigned int )bestcount);
#line 169
  which = (int )tmp___3;
#line 170
  while (1) {
#line 170
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 170
    if (! tmp___6) {
#line 170
      break;
    }
#line 171
    tmp___4 = parse_prime(linenum, line, & dhg);
#line 171
    if (! tmp___4) {
#line 172
      continue;
    }
#line 173
    if (dhg.size > max) {
#line 176
      BN_clear_free(dhg.g);
#line 177
      BN_clear_free(dhg.p);
#line 178
      continue;
    } else {
#line 173
      if (dhg.size < min) {
#line 176
        BN_clear_free(dhg.g);
#line 177
        BN_clear_free(dhg.p);
#line 178
        continue;
      } else {
#line 173
        if (dhg.size != best) {
#line 176
          BN_clear_free(dhg.g);
#line 177
          BN_clear_free(dhg.p);
#line 178
          continue;
        } else {
#line 173
          tmp___5 = linenum;
#line 173
          linenum ++;
#line 173
          if (tmp___5 != which) {
#line 176
            BN_clear_free(dhg.g);
#line 177
            BN_clear_free(dhg.p);
#line 178
            continue;
          }
        }
      }
    }
#line 180
    break;
  }
#line 182
  fclose(f);
#line 183
  if (linenum != which + 1) {
#line 184
    fatal("WARNING: line %d disappeared in %s, giving up", which, "/usr/local/etc/primes");
  }
#line 187
  tmp___7 = dh_new_group(dhg.g, dhg.p);
#line 187
  return (tmp___7);
}
}
#line 192 "dh.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  BIGNUM *tmp___0 ;
  BIGNUM const   *tmp___1 ;
  int tmp___2 ;
  BIGNUM const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 196
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 196
  n___0 = tmp;
#line 197
  bits_set = 0;
#line 200
  if (dh_pub->neg) {
#line 201
    logit("invalid public DH value: negative");
#line 202
    return (0);
  }
#line 204
  tmp___1 = BN_value_one();
#line 204
  tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, tmp___1);
#line 204
  if (tmp___2 != 1) {
#line 205
    logit("invalid public DH value: <= 1");
#line 206
    return (0);
  }
#line 209
  tmp___0 = BN_new();
#line 209
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 210
    error("%s: BN_new failed", "dh_pub_is_valid");
#line 211
    return (0);
  }
#line 213
  tmp___3 = BN_value_one();
#line 213
  tmp___4 = BN_sub(tmp___0, (BIGNUM const   *)dh->p, tmp___3);
#line 213
  if (tmp___4) {
#line 213
    tmp___5 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)tmp___0);
#line 213
    if (tmp___5 != -1) {
#line 215
      BN_clear_free(tmp___0);
#line 216
      logit("invalid public DH value: >= p-1");
#line 217
      return (0);
    }
  } else {
#line 215
    BN_clear_free(tmp___0);
#line 216
    logit("invalid public DH value: >= p-1");
#line 217
    return (0);
  }
#line 219
  BN_clear_free(tmp___0);
#line 221
  i = 0;
#line 221
  while (i <= n___0) {
#line 222
    tmp___6 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 222
    if (tmp___6) {
#line 223
      bits_set ++;
    }
#line 221
    i ++;
  }
#line 224
  tmp___7 = BN_num_bits((BIGNUM const   *)dh->p);
#line 224
  debug2("bits set: %d/%d", bits_set, tmp___7);
#line 227
  if (bits_set > 1) {
#line 228
    return (1);
  }
#line 230
  tmp___8 = BN_num_bits((BIGNUM const   *)dh->p);
#line 230
  logit("invalid public DH value (%d/%d)", bits_set, tmp___8);
#line 231
  return (0);
}
}
#line 234 "dh.c"
void dh_gen_key(DH *dh , int need ) 
{ int i ;
  int bits_set ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 237
  tries = 0;
#line 239
  if ((unsigned int )dh->p == (unsigned int )((void *)0)) {
#line 240
    fatal("dh_gen_key: dh->p == NULL");
  }
#line 241
  if (need > 1073741823) {
#line 242
    tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 242
    fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
  } else {
#line 241
    tmp___0 = BN_num_bits((BIGNUM const   *)dh->p);
#line 241
    if (2 * need >= tmp___0) {
#line 242
      tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 242
      fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
    }
  }
#line 244
  while (1) {
#line 245
    if ((unsigned int )dh->priv_key != (unsigned int )((void *)0)) {
#line 246
      BN_clear_free(dh->priv_key);
    }
#line 247
    dh->priv_key = BN_new();
#line 247
    if ((unsigned int )dh->priv_key == (unsigned int )((void *)0)) {
#line 248
      fatal("dh_gen_key: BN_new failed");
    }
#line 250
    tmp___1 = BN_rand(dh->priv_key, 2 * need, 0, 0);
#line 250
    if (! tmp___1) {
#line 251
      fatal("dh_gen_key: BN_rand failed");
    }
#line 252
    tmp___2 = DH_generate_key(dh);
#line 252
    if (tmp___2 == 0) {
#line 253
      fatal("DH_generate_key");
    }
#line 254
    i = 0;
#line 254
    bits_set = 0;
#line 254
    while (1) {
#line 254
      tmp___4 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 254
      if (! (i <= tmp___4)) {
#line 254
        break;
      }
#line 255
      tmp___3 = BN_is_bit_set((BIGNUM const   *)dh->priv_key, i);
#line 255
      if (tmp___3) {
#line 256
        bits_set ++;
      }
#line 254
      i ++;
    }
#line 257
    tmp___5 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 257
    debug2("dh_gen_key: priv key bits set: %d/%d", bits_set, tmp___5);
#line 259
    tmp___6 = tries;
#line 259
    tries ++;
#line 259
    if (tmp___6 > 10) {
#line 260
      fatal("dh_gen_key: too many bad keys: giving up");
    }
#line 244
    tmp___7 = dh_pub_is_valid(dh, dh->pub_key);
#line 244
    if (tmp___7) {
#line 244
      break;
    }
  }
#line 262
  return;
}
}
#line 264 "dh.c"
DH *dh_new_group_asc(char const   *gen___1 , char const   *modulus ) 
{ DH *dh ;
  int tmp ;
  int tmp___0 ;

  {
#line 269
  dh = DH_new();
#line 269
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 270
    fatal("dh_new_group_asc: DH_new");
  }
#line 272
  tmp = BN_hex2bn(& dh->p, modulus);
#line 272
  if (tmp == 0) {
#line 273
    fatal("BN_hex2bn p");
  }
#line 274
  tmp___0 = BN_hex2bn(& dh->g, gen___1);
#line 274
  if (tmp___0 == 0) {
#line 275
    fatal("BN_hex2bn g");
  }
#line 277
  return (dh);
}
}
#line 285 "dh.c"
DH *dh_new_group(BIGNUM *gen___1 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 290
  dh = DH_new();
#line 290
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 291
    fatal("dh_new_group: DH_new");
  }
#line 292
  dh->p = modulus;
#line 293
  dh->g = gen___1;
#line 295
  return (dh);
}
}
#line 301 "dh.c"
static char *gen  =    (char *)"2";
#line 301 "dh.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 298 "dh.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 309
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 309
  return (tmp);
}
}
#line 315 "dh.c"
static char *gen___0  =    (char *)"2";
#line 315 "dh.c"
static char *group14  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF";
#line 312 "dh.c"
DH *dh_new_group14(void) 
{ DH *tmp ;

  {
#line 328
  tmp = dh_new_group_asc((char const   *)gen___0, (char const   *)group14);
#line 328
  return (tmp);
}
}
#line 337 "dh.c"
int dh_estimate(int bits ) 
{ 

  {
#line 341
  if (bits <= 128) {
#line 342
    return (1024);
  }
#line 343
  if (bits <= 192) {
#line 344
    return (2048);
  }
#line 345
  return (4096);
}
}
#line 1 "kexdh.o"
#pragma merger(0,"./kexdh.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 144 "kex.h"
void kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) ;
#line 53 "kexdh.c"
static u_char digest[64]  ;
#line 40 "kexdh.c"
void kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  void *tmp___1 ;

  {
#line 54
  tmp = EVP_sha1();
#line 54
  evp_md = tmp;
#line 57
  buffer_init(& b);
#line 58
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 59
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 62
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 63
  buffer_put_char(& b, 20);
#line 64
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 65
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 66
  buffer_put_char(& b, 20);
#line 67
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 69
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 70
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 71
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 72
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 77
  EVP_DigestInit(& md, evp_md);
#line 78
  tmp___0 = buffer_len(& b);
#line 78
  tmp___1 = buffer_ptr(& b);
#line 78
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 79
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 81
  buffer_free(& b);
#line 86
  *hash = digest;
#line 87
  *hashlen = (unsigned int )evp_md->md_size;
#line 88
  return;
}
}
#line 1 "kexgex.o"
#pragma merger(0,"./kexgex.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 147 "kex.h"
void kexgex_hash(EVP_MD const   *evp_md , char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                 int max , BIGNUM *prime , BIGNUM *gen___1 , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) ;
#line 55 "kexgex.c"
static u_char digest___0[64]  ;
#line 40 "kexgex.c"
void kexgex_hash(EVP_MD const   *evp_md , char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                 int max , BIGNUM *prime , BIGNUM *gen___1 , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) 
{ Buffer b ;
  EVP_MD_CTX md ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 58
  buffer_init(& b);
#line 59
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 60
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 63
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 64
  buffer_put_char(& b, 20);
#line 65
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 66
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 67
  buffer_put_char(& b, 20);
#line 68
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 70
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 71
  if (min == -1) {
#line 72
    buffer_put_int(& b, (unsigned int )wantbits);
  } else {
#line 71
    if (max == -1) {
#line 72
      buffer_put_int(& b, (unsigned int )wantbits);
    } else {
#line 74
      buffer_put_int(& b, (unsigned int )min);
#line 75
      buffer_put_int(& b, (unsigned int )wantbits);
#line 76
      buffer_put_int(& b, (unsigned int )max);
    }
  }
#line 78
  buffer_put_bignum2(& b, (BIGNUM const   *)prime);
#line 79
  buffer_put_bignum2(& b, (BIGNUM const   *)gen___1);
#line 80
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 81
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 82
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 88
  EVP_DigestInit(& md, evp_md);
#line 89
  tmp = buffer_len(& b);
#line 89
  tmp___0 = buffer_ptr(& b);
#line 89
  EVP_DigestUpdate(& md, (void const   *)tmp___0, tmp);
#line 90
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 92
  buffer_free(& b);
#line 93
  *hash = digest___0;
#line 94
  *hashlen = (unsigned int )evp_md->md_size;
#line 98
  return;
}
}
#line 1 "kexdhc.o"
#pragma merger(0,"./kexdhc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 139 "kex.h"
void kexdh_client(Kex *kex ) ;
#line 45 "kexdhc.c"
void kexdh_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  DH *dh ;
  Key *server_host_key ;
  u_char *server_host_key_blob ;
  u_char *signature ;
  u_char *kbuf ;
  u_char *hash ;
  u_int klen ;
  u_int slen ;
  u_int sbloblen ;
  u_int hashlen ;
  int kout ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  BIGNUM *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;

  {
#line 48
  dh_server_pub = (BIGNUM *)((void *)0);
#line 48
  shared_secret = (BIGNUM *)((void *)0);
#line 51
  server_host_key_blob = (u_char *)((void *)0);
#line 51
  signature = (u_char *)((void *)0);
#line 57
  switch (kex->kex_type) {
  case 0: 
#line 59
  dh = dh_new_group1();
#line 60
  break;
  case 1: 
#line 62
  dh = dh_new_group14();
#line 63
  break;
  default: 
#line 65
  fatal("%s: Unexpected KEX type %d", "kexdh_client", kex->kex_type);
  }
#line 67
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 68
  packet_start((unsigned char)30);
#line 69
  packet_put_bignum2(dh->pub_key);
#line 70
  packet_send();
#line 72
  debug("sending SSH2_MSG_KEXDH_INIT");
#line 80
  debug("expecting SSH2_MSG_KEXDH_REPLY");
#line 81
  packet_read_expect(31);
#line 84
  tmp = packet_get_string(& sbloblen);
#line 84
  server_host_key_blob = (u_char *)tmp;
#line 85
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 86
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 87
    fatal("cannot decode server_host_key_blob");
  }
#line 88
  if (server_host_key->type != kex->hostkey_type) {
#line 89
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 90
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 91
    fatal("cannot verify server_host_key");
  }
#line 92
  tmp___0 = (*(kex->verify_host_key))(server_host_key);
#line 92
  if (tmp___0 == -1) {
#line 93
    fatal("server_host_key verification failed");
  }
#line 96
  dh_server_pub = BN_new();
#line 96
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 97
    fatal("dh_server_pub == NULL");
  }
#line 98
  packet_get_bignum2(dh_server_pub);
#line 108
  tmp___1 = packet_get_string(& slen);
#line 108
  signature = (u_char *)tmp___1;
#line 109
  while (1) {
#line 109
    tmp___2 = packet_remaining();
#line 109
    _len = tmp___2;
#line 109
    if (_len > 0) {
#line 109
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhc.c",
            109);
#line 109
      packet_disconnect("Packet integrity error.");
    }
#line 109
    break;
  }
#line 111
  tmp___3 = dh_pub_is_valid(dh, dh_server_pub);
#line 111
  if (! tmp___3) {
#line 112
    packet_disconnect("bad server public DH value");
  }
#line 114
  tmp___4 = DH_size((DH const   *)dh);
#line 114
  klen = (unsigned int )tmp___4;
#line 115
  tmp___5 = xmalloc(klen);
#line 115
  kbuf = (u_char *)tmp___5;
#line 116
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 116
  if (kout < 0) {
#line 117
    fatal("DH_compute_key: failed");
  }
#line 121
  shared_secret = BN_new();
#line 121
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 122
    fatal("kexdh_client: BN_new failed");
  }
#line 123
  tmp___6 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 123
  if ((unsigned int )tmp___6 == (unsigned int )((void *)0)) {
#line 124
    fatal("kexdh_client: BN_bin2bn failed");
  }
#line 125
  memset((void *)kbuf, 0, klen);
#line 126
  xfree((void *)kbuf);
#line 129
  tmp___7 = buffer_len(& kex->peer);
#line 129
  tmp___8 = buffer_ptr(& kex->peer);
#line 129
  tmp___9 = buffer_len(& kex->my);
#line 129
  tmp___10 = buffer_ptr(& kex->my);
#line 129
  kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___10,
              (int )tmp___9, (char *)tmp___8, (int )tmp___7, server_host_key_blob,
              (int )sbloblen, dh->pub_key, dh_server_pub, shared_secret, & hash, & hashlen);
#line 140
  xfree((void *)server_host_key_blob);
#line 141
  BN_clear_free(dh_server_pub);
#line 142
  DH_free(dh);
#line 144
  tmp___11 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, hashlen);
#line 144
  if (tmp___11 != 1) {
#line 145
    fatal("key_verify failed for server_host_key");
  }
#line 146
  key_free(server_host_key);
#line 147
  xfree((void *)signature);
#line 150
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 151
    kex->session_id_len = hashlen;
#line 152
    tmp___12 = xmalloc(kex->session_id_len);
#line 152
    kex->session_id = (u_char *)tmp___12;
#line 153
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 156
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 157
  BN_clear_free(shared_secret);
#line 158
  kex_finish(kex);
#line 159
  return;
}
}
#line 1 "kexgexc.o"
#pragma merger(0,"./kexgexc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 141 "kex.h"
void kexgex_client(Kex *kex ) ;
#line 47 "kexgexc.c"
void kexgex_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  BIGNUM *p ;
  BIGNUM *g ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int klen ;
  u_int slen ;
  u_int sbloblen ;
  u_int hashlen ;
  int kout ;
  int min ;
  int max ;
  int nbits ;
  DH *dh ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  BIGNUM *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 50
  dh_server_pub = (BIGNUM *)((void *)0);
#line 50
  shared_secret = (BIGNUM *)((void *)0);
#line 51
  p = (BIGNUM *)((void *)0);
#line 51
  g = (BIGNUM *)((void *)0);
#line 53
  signature = (u_char *)((void *)0);
#line 53
  server_host_key_blob = (u_char *)((void *)0);
#line 59
  nbits = dh_estimate((int )(kex->we_need * 8U));
#line 61
  if (datafellows & 16384) {
#line 63
    packet_start((unsigned char)30);
#line 64
    packet_put_int((unsigned int )nbits);
#line 65
    min = 1024;
#line 66
    max = 8192;
#line 68
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", nbits);
  } else {
#line 71
    min = 1024;
#line 72
    max = 8192;
#line 73
    packet_start((unsigned char)34);
#line 74
    packet_put_int((unsigned int )min);
#line 75
    packet_put_int((unsigned int )nbits);
#line 76
    packet_put_int((unsigned int )max);
#line 78
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent", min, nbits, max);
  }
#line 85
  packet_send();
#line 87
  debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
#line 88
  packet_read_expect(31);
#line 90
  p = BN_new();
#line 90
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 91
    fatal("BN_new");
  }
#line 92
  packet_get_bignum2(p);
#line 93
  g = BN_new();
#line 93
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 94
    fatal("BN_new");
  }
#line 95
  packet_get_bignum2(g);
#line 96
  while (1) {
#line 96
    tmp = packet_remaining();
#line 96
    _len = tmp;
#line 96
    if (_len > 0) {
#line 96
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexc.c",
            96);
#line 96
      packet_disconnect("Packet integrity error.");
    }
#line 96
    break;
  }
#line 98
  tmp___1 = BN_num_bits((BIGNUM const   *)p);
#line 98
  if (tmp___1 < min) {
#line 99
    tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 99
    fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
  } else {
#line 98
    tmp___2 = BN_num_bits((BIGNUM const   *)p);
#line 98
    if (tmp___2 > max) {
#line 99
      tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 99
      fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
    }
  }
#line 102
  dh = dh_new_group(g, p);
#line 103
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 112
  debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#line 114
  packet_start((unsigned char)32);
#line 115
  packet_put_bignum2(dh->pub_key);
#line 116
  packet_send();
#line 118
  debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
#line 119
  packet_read_expect(33);
#line 122
  tmp___3 = packet_get_string(& sbloblen);
#line 122
  server_host_key_blob = (u_char *)tmp___3;
#line 123
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 124
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 125
    fatal("cannot decode server_host_key_blob");
  }
#line 126
  if (server_host_key->type != kex->hostkey_type) {
#line 127
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 128
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 129
    fatal("cannot verify server_host_key");
  }
#line 130
  tmp___4 = (*(kex->verify_host_key))(server_host_key);
#line 130
  if (tmp___4 == -1) {
#line 131
    fatal("server_host_key verification failed");
  }
#line 134
  dh_server_pub = BN_new();
#line 134
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 135
    fatal("dh_server_pub == NULL");
  }
#line 136
  packet_get_bignum2(dh_server_pub);
#line 146
  tmp___5 = packet_get_string(& slen);
#line 146
  signature = (u_char *)tmp___5;
#line 147
  while (1) {
#line 147
    tmp___6 = packet_remaining();
#line 147
    _len___0 = tmp___6;
#line 147
    if (_len___0 > 0) {
#line 147
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexc.c",
            147);
#line 147
      packet_disconnect("Packet integrity error.");
    }
#line 147
    break;
  }
#line 149
  tmp___7 = dh_pub_is_valid(dh, dh_server_pub);
#line 149
  if (! tmp___7) {
#line 150
    packet_disconnect("bad server public DH value");
  }
#line 152
  tmp___8 = DH_size((DH const   *)dh);
#line 152
  klen = (unsigned int )tmp___8;
#line 153
  tmp___9 = xmalloc(klen);
#line 153
  kbuf = (u_char *)tmp___9;
#line 154
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 154
  if (kout < 0) {
#line 155
    fatal("DH_compute_key: failed");
  }
#line 159
  shared_secret = BN_new();
#line 159
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 160
    fatal("kexgex_client: BN_new failed");
  }
#line 161
  tmp___10 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 161
  if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
#line 162
    fatal("kexgex_client: BN_bin2bn failed");
  }
#line 163
  memset((void *)kbuf, 0, klen);
#line 164
  xfree((void *)kbuf);
#line 166
  if (datafellows & 16384) {
#line 167
    max = -1;
#line 167
    min = max;
  }
#line 170
  tmp___11 = buffer_len(& kex->peer);
#line 170
  tmp___12 = buffer_ptr(& kex->peer);
#line 170
  tmp___13 = buffer_len(& kex->my);
#line 170
  tmp___14 = buffer_ptr(& kex->my);
#line 170
  kexgex_hash(kex->evp_md, kex->client_version_string, kex->server_version_string,
              (char *)tmp___14, (int )tmp___13, (char *)tmp___12, (int )tmp___11,
              server_host_key_blob, (int )sbloblen, min, nbits, max, dh->p, dh->g,
              dh->pub_key, dh_server_pub, shared_secret, & hash, & hashlen);
#line 186
  DH_free(dh);
#line 187
  xfree((void *)server_host_key_blob);
#line 188
  BN_clear_free(dh_server_pub);
#line 190
  tmp___15 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, hashlen);
#line 190
  if (tmp___15 != 1) {
#line 191
    fatal("key_verify failed for server_host_key");
  }
#line 192
  key_free(server_host_key);
#line 193
  xfree((void *)signature);
#line 196
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 197
    kex->session_id_len = hashlen;
#line 198
    tmp___16 = xmalloc(kex->session_id_len);
#line 198
    kex->session_id = (u_char *)tmp___16;
#line 199
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 201
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 202
  BN_clear_free(shared_secret);
#line 204
  kex_finish(kex);
#line 205
  return;
}
}
#line 1 "scard.o"
#pragma merger(0,"./scard.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "msg.o"
#pragma merger(0,"./msg.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 28 "msg.h"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) ;
#line 29
int ssh_msg_recv(int fd , Buffer *m___0 ) ;
#line 43 "msg.c"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) 
{ u_char buf___1[5] ;
  u_int mlen ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 47
  tmp = buffer_len(m___0);
#line 47
  mlen = tmp;
#line 49
  debug3("ssh_msg_send: type %u", (unsigned int )type & 255U);
#line 51
  put_u32((void *)(buf___1), mlen + 1U);
#line 52
  buf___1[4] = type;
#line 53
  tmp___0 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(buf___1),
                     sizeof(buf___1));
#line 53
  if (tmp___0 != sizeof(buf___1)) {
#line 54
    error("ssh_msg_send: write");
#line 55
    return (-1);
  }
#line 57
  tmp___1 = buffer_ptr(m___0);
#line 57
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, tmp___1,
                     mlen);
#line 57
  if (tmp___2 != mlen) {
#line 58
    error("ssh_msg_send: write");
#line 59
    return (-1);
  }
#line 61
  return (0);
}
}
#line 64 "msg.c"
int ssh_msg_recv(int fd , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  u_int msg_len ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
#line 70
  debug3("ssh_msg_recv entering");
#line 72
  tmp___0 = atomicio(& read, fd, (void *)(buf___1), sizeof(buf___1));
#line 72
  if (tmp___0 != sizeof(buf___1)) {
#line 73
    tmp = __errno_location();
#line 73
    if (*tmp != 32) {
#line 74
      error("ssh_msg_recv: read: header");
    }
#line 75
    return (-1);
  }
#line 77
  msg_len = get_u32((void const   *)(buf___1));
#line 78
  if (msg_len > 262144U) {
#line 79
    error("ssh_msg_recv: read: bad msg_len %u", msg_len);
#line 80
    return (-1);
  }
#line 82
  buffer_clear(m___0);
#line 83
  buffer_append_space(m___0, msg_len);
#line 84
  tmp___3 = buffer_ptr(m___0);
#line 84
  tmp___4 = atomicio(& read, fd, tmp___3, msg_len);
#line 84
  if (tmp___4 != msg_len) {
#line 85
    tmp___1 = __errno_location();
#line 85
    tmp___2 = strerror(*tmp___1);
#line 85
    error("ssh_msg_recv: read: %s", tmp___2);
#line 86
    return (-1);
  }
#line 88
  return (0);
}
}
#line 1 "progressmeter.o"
#pragma merger(0,"./progressmeter.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 581
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 805
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 26 "progressmeter.h"
void start_progress_meter(char *f , off_t filesize , off_t *ctr ) ;
#line 27
void stop_progress_meter(void) ;
#line 50 "progressmeter.c"
static int can_output(void) ;
#line 53
static void format_size(char *buf___1 , int size , off_t bytes ) ;
#line 54
static void format_rate(char *buf___1 , int size , off_t bytes ) ;
#line 57
static void sig_winch(int sig ) ;
#line 58
static void setscreensize(void) ;
#line 61
void refresh_progress_meter(void) ;
#line 64
static void update_progress_meter(int ignore ) ;
#line 66 "progressmeter.c"
static time_t start  ;
#line 67 "progressmeter.c"
static time_t last_update  ;
#line 68 "progressmeter.c"
static char *file  ;
#line 69 "progressmeter.c"
static off_t end_pos  ;
#line 70 "progressmeter.c"
static off_t cur_pos  ;
#line 71 "progressmeter.c"
static off_t volatile   *counter  ;
#line 72 "progressmeter.c"
static long stalled  ;
#line 73 "progressmeter.c"
static int bytes_per_second  ;
#line 74 "progressmeter.c"
static int win_size  ;
#line 75 "progressmeter.c"
static sig_atomic_t volatile   win_resized  ;
#line 78 "progressmeter.c"
static char const   unit[6]  = {      (char const   )' ',      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'\000'};
#line 80 "progressmeter.c"
static int can_output(void) 
{ __pid_t tmp ;
  __pid_t tmp___0 ;

  {
#line 83
  tmp = getpgrp();
#line 83
  tmp___0 = tcgetpgrp(1);
#line 83
  return (tmp == tmp___0);
}
}
#line 86 "progressmeter.c"
static void format_rate(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 91
  bytes *= 100LL;
#line 92
  i = 0;
#line 92
  while (1) {
#line 92
    if (bytes >= 100000LL) {
#line 92
      if (! ((int const   )unit[i] != 84)) {
#line 92
        break;
      }
    } else {
#line 92
      break;
    }
#line 93
    bytes = (bytes + 512LL) / 1024LL;
#line 92
    i ++;
  }
#line 94
  if (i == 0) {
#line 95
    i ++;
#line 96
    bytes = (bytes + 512LL) / 1024LL;
  }
#line 98
  if (i) {
#line 98
    tmp = "B";
  } else {
#line 98
    tmp = " ";
  }
#line 98
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%3lld.%1lld%c%s",
           (bytes + 5LL) / 100LL, ((bytes + 5LL) / 10LL) % 10LL, unit[i], tmp);
#line 103
  return;
}
}
#line 105 "progressmeter.c"
static void format_size(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 110
  i = 0;
#line 110
  while (1) {
#line 110
    if (bytes >= 10000LL) {
#line 110
      if (! ((int const   )unit[i] != 84)) {
#line 110
        break;
      }
    } else {
#line 110
      break;
    }
#line 111
    bytes = (bytes + 512LL) / 1024LL;
#line 110
    i ++;
  }
#line 112
  if (i) {
#line 112
    tmp = "B";
  } else {
#line 112
    tmp = " ";
  }
#line 112
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%4lld%c%s",
           bytes, unit[i], tmp);
#line 116
  return;
}
}
#line 118 "progressmeter.c"
void refresh_progress_meter(void) 
{ char buf___1[513] ;
  time_t now ;
  off_t transferred ;
  double elapsed ;
  int percent ;
  off_t bytes_left ;
  int cur_speed ;
  int hours ;
  int minutes ;
  int seconds ;
  int i ;
  int len ;
  int file_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 132
  transferred = (long long )(*counter - (off_t volatile   )cur_pos);
#line 133
  cur_pos = (long long )*counter;
#line 134
  now = time((time_t *)((void *)0));
#line 135
  bytes_left = end_pos - cur_pos;
#line 137
  if (bytes_left > 0LL) {
#line 138
    elapsed = (double )(now - last_update);
  } else {
#line 140
    elapsed = (double )(now - start);
#line 142
    transferred = end_pos;
#line 143
    bytes_per_second = 0;
  }
#line 147
  if (elapsed != (double )0) {
#line 148
    cur_speed = (int )((double )transferred / elapsed);
  } else {
#line 150
    cur_speed = (int )transferred;
  }
#line 153
  if (bytes_per_second != 0) {
#line 154
    bytes_per_second = (int )((double )bytes_per_second * 0.9 + (double )cur_speed * (1.0 - 0.9));
  } else {
#line 157
    bytes_per_second = cur_speed;
  }
#line 160
  buf___1[0] = (char )'\000';
#line 161
  file_len = win_size - 35;
#line 162
  if (file_len > 0) {
#line 163
    len = snprintf((char * __restrict  )(buf___1), (unsigned int )(file_len + 1),
                   (char const   * __restrict  )"\r%s", file);
#line 164
    if (len < 0) {
#line 165
      len = 0;
    }
#line 166
    if (len >= file_len + 1) {
#line 167
      len = file_len;
    }
#line 168
    i = len;
#line 168
    while (i < file_len) {
#line 169
      buf___1[i] = (char )' ';
#line 168
      i ++;
    }
#line 170
    buf___1[file_len] = (char )'\000';
  }
#line 174
  if (end_pos != 0LL) {
#line 175
    percent = (int )(((float )cur_pos / (float )end_pos) * (float )100);
  } else {
#line 177
    percent = 100;
  }
#line 178
  tmp = strlen((char const   *)(buf___1));
#line 178
  tmp___0 = strlen((char const   *)(buf___1));
#line 178
  snprintf((char * __restrict  )(buf___1 + tmp___0), (size_t )win_size - tmp, (char const   * __restrict  )" %3d%% ",
           percent);
#line 182
  tmp___1 = strlen((char const   *)(buf___1));
#line 182
  tmp___2 = strlen((char const   *)(buf___1));
#line 182
  format_size(buf___1 + tmp___2, (int )((size_t )win_size - tmp___1), cur_pos);
#line 184
  strlcat(buf___1, " ", (unsigned int )win_size);
#line 187
  tmp___3 = strlen((char const   *)(buf___1));
#line 187
  tmp___4 = strlen((char const   *)(buf___1));
#line 187
  format_rate(buf___1 + tmp___4, (int )((size_t )win_size - tmp___3), (long long )bytes_per_second);
#line 189
  strlcat(buf___1, "/s ", (unsigned int )win_size);
#line 192
  if (! transferred) {
#line 193
    stalled = (long )((double )stalled + elapsed);
  } else {
#line 195
    stalled = 0L;
  }
#line 197
  if (stalled >= 5L) {
#line 198
    strlcat(buf___1, "- stalled -", (unsigned int )win_size);
  } else {
#line 199
    if (bytes_per_second == 0) {
#line 199
      if (bytes_left) {
#line 200
        strlcat(buf___1, "  --:-- ETA", (unsigned int )win_size);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 202
      if (bytes_left > 0LL) {
#line 203
        seconds = (int )(bytes_left / (off_t )bytes_per_second);
      } else {
#line 205
        seconds = (int )elapsed;
      }
#line 207
      hours = seconds / 3600;
#line 208
      seconds -= hours * 3600;
#line 209
      minutes = seconds / 60;
#line 210
      seconds -= minutes * 60;
#line 212
      if (hours != 0) {
#line 213
        tmp___5 = strlen((char const   *)(buf___1));
#line 213
        tmp___6 = strlen((char const   *)(buf___1));
#line 213
        snprintf((char * __restrict  )(buf___1 + tmp___6), (size_t )win_size - tmp___5,
                 (char const   * __restrict  )"%d:%02d:%02d", hours, minutes, seconds);
      } else {
#line 216
        tmp___7 = strlen((char const   *)(buf___1));
#line 216
        tmp___8 = strlen((char const   *)(buf___1));
#line 216
        snprintf((char * __restrict  )(buf___1 + tmp___8), (size_t )win_size - tmp___7,
                 (char const   * __restrict  )"  %02d:%02d", minutes, seconds);
      }
#line 219
      if (bytes_left > 0LL) {
#line 220
        strlcat(buf___1, " ETA", (unsigned int )win_size);
      } else {
#line 222
        strlcat(buf___1, "    ", (unsigned int )win_size);
      }
    }
  }
#line 225
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)(buf___1),
           (unsigned int )(win_size - 1));
#line 226
  last_update = now;
#line 227
  return;
}
}
#line 230 "progressmeter.c"
static void update_progress_meter(int ignore ) 
{ int save_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 235
  tmp = __errno_location();
#line 235
  save_errno = *tmp;
#line 237
  if (win_resized) {
#line 238
    setscreensize();
#line 239
    win_resized = (int volatile   )0;
  }
#line 241
  tmp___0 = can_output();
#line 241
  if (tmp___0) {
#line 242
    refresh_progress_meter();
  }
#line 244
  mysignal(14, & update_progress_meter);
#line 245
  alarm(1U);
#line 246
  tmp___1 = __errno_location();
#line 246
  *tmp___1 = save_errno;
#line 247
  return;
}
}
#line 249 "progressmeter.c"
void start_progress_meter(char *f , off_t filesize , off_t *ctr ) 
{ int tmp ;

  {
#line 252
  last_update = time((time_t *)((void *)0));
#line 252
  start = last_update;
#line 253
  file = f;
#line 254
  end_pos = filesize;
#line 255
  cur_pos = 0LL;
#line 256
  counter = (off_t volatile   *)ctr;
#line 257
  stalled = 0L;
#line 258
  bytes_per_second = 0;
#line 260
  setscreensize();
#line 261
  tmp = can_output();
#line 261
  if (tmp) {
#line 262
    refresh_progress_meter();
  }
#line 264
  mysignal(14, & update_progress_meter);
#line 265
  mysignal(28, & sig_winch);
#line 266
  alarm(1U);
#line 267
  return;
}
}
#line 269 "progressmeter.c"
void stop_progress_meter(void) 
{ int tmp ;

  {
#line 272
  alarm(0U);
#line 274
  tmp = can_output();
#line 274
  if (! tmp) {
#line 275
    return;
  }
#line 278
  if (cur_pos != end_pos) {
#line 279
    refresh_progress_meter();
  }
#line 281
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)"\n", 1U);
#line 282
  return;
}
}
#line 285 "progressmeter.c"
static void sig_winch(int sig ) 
{ 

  {
#line 288
  win_resized = (int volatile   )1;
#line 289
  return;
}
}
#line 291 "progressmeter.c"
static void setscreensize(void) 
{ struct winsize winsize ;
  int tmp ;

  {
#line 296
  tmp = ioctl(1, 21523UL, & winsize);
#line 296
  if (tmp != -1) {
#line 296
    if ((int )winsize.ws_col != 0) {
#line 298
      if ((int )winsize.ws_col > 512) {
#line 299
        win_size = 512;
      } else {
#line 301
        win_size = (int )winsize.ws_col;
      }
    } else {
#line 303
      win_size = 80;
    }
  } else {
#line 303
    win_size = 80;
  }
#line 304
  win_size ++;
#line 305
  return;
}
}
#line 1 "dns.o"
#pragma merger(0,"./dns.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "dns.h"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) ;
#line 50
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) ;
#line 43 "dns.c"
static char const   *errset_text[6]  = {      "success",      "out of memory",      "general failure",      "invalid parameter", 
        "name does not exist",      "data does not exist"};
#line 52 "dns.c"
static char const   *dns_result_totext(unsigned int res ) 
{ 

  {
#line 55
  switch ((int )res) {
  case 0: 
#line 57
  return (errset_text[0]);
  case 1: 
#line 59
  return (errset_text[1]);
  case 2: 
#line 61
  return (errset_text[2]);
  case 3: 
#line 63
  return (errset_text[3]);
  case 4: 
#line 65
  return (errset_text[4]);
  case 5: 
#line 67
  return (errset_text[5]);
  default: ;
#line 69
  return ("unknown error");
  }
}
}
#line 76 "dns.c"
static int dns_read_key(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                        u_int *digest_len , Key const   *key ) 
{ int success ;

  {
#line 80
  success = 0;
#line 82
  switch ((int )key->type) {
  case 1: 
#line 84
  *algorithm = (unsigned char)1;
#line 85
  break;
  case 2: 
#line 87
  *algorithm = (unsigned char)2;
#line 88
  break;
  default: 
#line 90
  *algorithm = (unsigned char)0;
  }
#line 93
  if (*algorithm) {
#line 94
    *digest_type = (unsigned char)1;
#line 95
    *digest___1 = key_fingerprint_raw(key, 0, digest_len);
#line 96
    if ((unsigned int )*digest___1 == (unsigned int )((void *)0)) {
#line 97
      fatal("dns_read_key: null from key_fingerprint_raw()");
    }
#line 98
    success = 1;
  } else {
#line 100
    *digest_type = (unsigned char)0;
#line 101
    *digest___1 = (u_char *)((void *)0);
#line 102
    *digest_len = 0U;
#line 103
    success = 0;
  }
#line 106
  return (success);
}
}
#line 112 "dns.c"
static int dns_read_rdata(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                          u_int *digest_len , u_char *rdata , int rdata_len ) 
{ int success ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 116
  success = 0;
#line 118
  *algorithm = (unsigned char)0;
#line 119
  *digest_type = (unsigned char)0;
#line 121
  if (rdata_len >= 2) {
#line 122
    *algorithm = *(rdata + 0);
#line 123
    *digest_type = *(rdata + 1);
#line 124
    *digest_len = (unsigned int )(rdata_len - 2);
#line 126
    if (*digest_len > 0U) {
#line 127
      tmp = xmalloc(*digest_len);
#line 127
      *digest___1 = (u_char *)tmp;
#line 128
      memcpy((void * __restrict  )*digest___1, (void const   * __restrict  )(rdata + 2),
             *digest_len);
    } else {
#line 130
      tmp___0 = xstrdup("");
#line 130
      *digest___1 = (u_char *)tmp___0;
    }
#line 133
    success = 1;
  }
#line 136
  return (success);
}
}
#line 143 "dns.c"
static int is_numeric_hostname(char const   *hostname ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  int tmp ;

  {
#line 152
  if ((unsigned int )hostname == (unsigned int )((void *)0)) {
#line 153
    error("is_numeric_hostname called with NULL hostname");
#line 154
    return (-1);
  }
#line 157
  memset((void *)(& hints), 0, sizeof(hints));
#line 158
  hints.ai_socktype = 2;
#line 159
  hints.ai_flags = 4;
#line 161
  tmp = getaddrinfo((char const   * __restrict  )hostname, (char const   * __restrict  )((void *)0),
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 161
  if (tmp == 0) {
#line 162
    freeaddrinfo(ai);
#line 163
    return (-1);
  }
#line 166
  return (0);
}
}
#line 173 "dns.c"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) 
{ u_int counter___0 ;
  int result ;
  struct rrsetinfo *fingerprints ;
  u_int8_t hostkey_algorithm ;
  u_int8_t hostkey_digest_type ;
  u_char *hostkey_digest ;
  u_int hostkey_digest_len ;
  u_int8_t dnskey_algorithm ;
  u_int8_t dnskey_digest_type ;
  u_char *dnskey_digest ;
  u_int dnskey_digest_len ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 179
  fingerprints = (struct rrsetinfo *)((void *)0);
#line 191
  *flags = 0;
#line 193
  debug3("verify_host_key_dns");
#line 194
  if ((unsigned int )hostkey == (unsigned int )((void *)0)) {
#line 195
    fatal("No key to look up!");
  }
#line 197
  tmp = is_numeric_hostname(hostname);
#line 197
  if (tmp) {
#line 198
    debug("skipped DNS lookup for numerical hostname");
#line 199
    return (-1);
  }
#line 202
  result = getrrsetbyname(hostname, 1U, 44U, 0U, & fingerprints);
#line 204
  if (result) {
#line 205
    tmp___0 = dns_result_totext((unsigned int )result);
#line 205
    verbose("DNS lookup error: %s", tmp___0);
#line 206
    return (-1);
  }
#line 209
  if (fingerprints->rri_flags & 1U) {
#line 210
    *flags |= 4;
#line 211
    debug("found %d secure fingerprints in DNS", fingerprints->rri_nrdatas);
  } else {
#line 214
    debug("found %d insecure fingerprints in DNS", fingerprints->rri_nrdatas);
  }
#line 219
  tmp___1 = dns_read_key(& hostkey_algorithm, & hostkey_digest_type, & hostkey_digest,
                         & hostkey_digest_len, hostkey);
#line 219
  if (! tmp___1) {
#line 221
    error("Error calculating host key fingerprint.");
#line 222
    freerrset(fingerprints);
#line 223
    return (-1);
  }
#line 226
  if (fingerprints->rri_nrdatas) {
#line 227
    *flags |= 1;
  }
#line 229
  counter___0 = 0U;
#line 229
  while (counter___0 < fingerprints->rri_nrdatas) {
#line 234
    tmp___2 = dns_read_rdata(& dnskey_algorithm, & dnskey_digest_type, & dnskey_digest,
                             & dnskey_digest_len, (fingerprints->rri_rdatas + counter___0)->rdi_data,
                             (int )(fingerprints->rri_rdatas + counter___0)->rdi_length);
#line 234
    if (! tmp___2) {
#line 238
      verbose("Error parsing fingerprint from DNS.");
      goto __Cont;
    }
#line 243
    if ((int )hostkey_algorithm == (int )dnskey_algorithm) {
#line 243
      if ((int )hostkey_digest_type == (int )dnskey_digest_type) {
#line 246
        if (hostkey_digest_len == dnskey_digest_len) {
#line 246
          tmp___3 = memcmp((void const   *)hostkey_digest, (void const   *)dnskey_digest,
                           hostkey_digest_len);
#line 246
          if (tmp___3 == 0) {
#line 250
            *flags |= 2;
          }
        }
      }
    }
#line 253
    xfree((void *)dnskey_digest);
    __Cont: /* CIL Label */ 
#line 229
    counter___0 ++;
  }
#line 256
  xfree((void *)hostkey_digest);
#line 257
  freerrset(fingerprints);
#line 259
  if (*flags & 1) {
#line 260
    if (*flags & 2) {
#line 261
      debug("matching host key fingerprint found in DNS");
    } else {
#line 263
      debug("mismatching host key fingerprint found in DNS");
    }
  } else {
#line 265
    debug("no host key fingerprint found in DNS");
  }
#line 267
  return (0);
}
}
#line 273 "dns.c"
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) 
{ u_int8_t rdata_pubkey_algorithm ;
  u_int8_t rdata_digest_type ;
  u_char *rdata_digest ;
  u_int rdata_digest_len ;
  u_int i ;
  int success ;
  int tmp ;

  {
#line 276
  rdata_pubkey_algorithm = (u_int8_t )0;
#line 277
  rdata_digest_type = (u_int8_t )1;
#line 282
  success = 0;
#line 284
  tmp = dns_read_key(& rdata_pubkey_algorithm, & rdata_digest_type, & rdata_digest,
                     & rdata_digest_len, key);
#line 284
  if (tmp) {
#line 287
    if (generic) {
#line 288
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN TYPE%d \\# %d %02x %02x ",
              hostname, 44, 2U + rdata_digest_len, rdata_pubkey_algorithm, rdata_digest_type);
    } else {
#line 292
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN SSHFP %d %d ",
              hostname, rdata_pubkey_algorithm, rdata_digest_type);
    }
#line 295
    i = 0U;
#line 295
    while (i < rdata_digest_len) {
#line 296
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%02x", *(rdata_digest + i));
#line 295
      i ++;
    }
#line 297
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 298
    xfree((void *)rdata_digest);
#line 299
    success = 1;
  } else {
#line 301
    error("export_dns_rr: unsupported algorithm");
  }
#line 304
  return (success);
}
}
#line 1 "entropy.o"
#pragma merger(0,"./entropy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 33 "entropy.h"
void init_rng(void) ;
#line 109 "/usr/include/openssl/rand.h"
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 70 "entropy.c"
void seed_rng(void) 
{ int tmp ;

  {
#line 147
  tmp = RAND_status();
#line 147
  if (tmp != 1) {
#line 148
    fatal("PRNG is not seeded");
  }
#line 149
  return;
}
}
#line 151 "entropy.c"
void init_rng(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 158
  tmp___0 = SSLeay();
#line 158
  if ((tmp___0 ^ 9469999UL) & 4294963215UL) {
#line 159
    tmp = SSLeay();
#line 159
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 166
  return;
}
}
#line 1 "scard-opensc.o"
#pragma merger(0,"./scard-opensc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "gss-genr.o"
#pragma merger(0,"./gss-genr.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "umac.o"
#pragma merger(0,"./umac.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 131 "umac.c"
static UINT32 LOAD_UINT32_REVERSED(void *ptr ) 
{ UINT32 temp ;

  {
#line 133
  temp = *((UINT32 *)ptr);
#line 134
  temp = (((temp >> 24) | ((temp & 16711680U) >> 8)) | ((temp & 65280U) << 8)) | (temp << 24);
#line 136
  return (temp);
}
}
#line 140 "umac.c"
static void STORE_UINT32_REVERSED(void *ptr , UINT32 x ) 
{ UINT32 i ;

  {
#line 142
  i = x;
#line 143
  *((UINT32 *)ptr) = (((i >> 24) | ((i & 16711680U) >> 8)) | ((i & 65280U) << 8)) | (i << 24);
#line 145
  return;
}
}
#line 187 "umac.c"
static void kdf(void *bufp , AES_KEY *key , UINT8 ndx , int nbytes ) 
{ UINT8 in_buf[16] ;
  UINT8 out_buf[16] ;
  UINT8 *dst_buf ;
  int i ;

  {
#line 189
  in_buf[0] = (UINT8 )0;
#line 189
  in_buf[1] = (unsigned char)0;
#line 189
  in_buf[2] = (unsigned char)0;
#line 189
  in_buf[3] = (unsigned char)0;
#line 189
  in_buf[4] = (unsigned char)0;
#line 189
  in_buf[5] = (unsigned char)0;
#line 189
  in_buf[6] = (unsigned char)0;
#line 189
  in_buf[7] = (unsigned char)0;
#line 189
  in_buf[8] = (unsigned char)0;
#line 189
  in_buf[9] = (unsigned char)0;
#line 189
  in_buf[10] = (unsigned char)0;
#line 189
  in_buf[11] = (unsigned char)0;
#line 189
  in_buf[12] = (unsigned char)0;
#line 189
  in_buf[13] = (unsigned char)0;
#line 189
  in_buf[14] = (unsigned char)0;
#line 189
  in_buf[15] = (unsigned char)0;
#line 191
  dst_buf = (UINT8 *)bufp;
#line 195
  in_buf[7] = ndx;
#line 196
  i = 1;
#line 196
  in_buf[15] = (unsigned char )i;
#line 198
  while (nbytes >= 16) {
#line 199
    AES_encrypt((unsigned char const   *)(in_buf), out_buf, (AES_KEY const   *)((AES_KEY *)key));
#line 200
    memcpy((void * __restrict  )dst_buf, (void const   * __restrict  )(out_buf), 16U);
#line 201
    i ++;
#line 201
    in_buf[15] = (unsigned char )i;
#line 202
    nbytes -= 16;
#line 203
    dst_buf += 16;
  }
#line 205
  if (nbytes) {
#line 206
    AES_encrypt((unsigned char const   *)(in_buf), out_buf, (AES_KEY const   *)((AES_KEY *)key));
#line 207
    memcpy((void * __restrict  )dst_buf, (void const   * __restrict  )(out_buf), (unsigned int )nbytes);
  }
#line 209
  return;
}
}
#line 223 "umac.c"
static void pdf_init(pdf_ctx *pc , AES_KEY *prf_key ) 
{ UINT8 buf___1[16] ;

  {
#line 227
  kdf((void *)(buf___1), prf_key, (unsigned char)0, 16);
#line 228
  AES_set_encrypt_key((unsigned char const   *)(buf___1), 128, pc->prf_key);
#line 231
  memset((void *)(pc->nonce), 0, sizeof(pc->nonce));
#line 232
  AES_encrypt((unsigned char const   *)(pc->nonce), pc->cache, (AES_KEY const   *)(pc->prf_key));
#line 233
  return;
}
}
#line 235 "umac.c"
static void pdf_gen_xor(pdf_ctx *pc , UINT8 *nonce , UINT8 *buf___1 ) 
{ UINT8 tmp_nonce_lo[4] ;
  int ndx ;

  {
#line 252
  ndx = (int )*(nonce + 7) & 1;
#line 254
  *((UINT32 *)(tmp_nonce_lo)) = *((UINT32 *)nonce + 1);
#line 255
  tmp_nonce_lo[3] = (unsigned char )((int )tmp_nonce_lo[3] & -2);
#line 257
  if (*((UINT32 *)(tmp_nonce_lo) + 0) != *((UINT32 *)(pc->nonce) + 1)) {
#line 260
    *((UINT32 *)(pc->nonce) + 0) = *((UINT32 *)nonce + 0);
#line 261
    *((UINT32 *)(pc->nonce) + 1) = *((UINT32 *)(tmp_nonce_lo) + 0);
#line 262
    AES_encrypt((unsigned char const   *)(pc->nonce), pc->cache, (AES_KEY const   *)(pc->prf_key));
  } else {
#line 257
    if (*((UINT32 *)nonce + 0) != *((UINT32 *)(pc->nonce) + 0)) {
#line 260
      *((UINT32 *)(pc->nonce) + 0) = *((UINT32 *)nonce + 0);
#line 261
      *((UINT32 *)(pc->nonce) + 1) = *((UINT32 *)(tmp_nonce_lo) + 0);
#line 262
      AES_encrypt((unsigned char const   *)(pc->nonce), pc->cache, (AES_KEY const   *)(pc->prf_key));
    }
  }
#line 268
  *((UINT64 *)buf___1) ^= *((UINT64 *)(pc->cache) + ndx);
#line 276
  return;
}
}
#line 363 "umac.c"
static void nh_aux(void *kp , void *dp , void *hp , UINT32 dlen ) 
{ UINT64 h1 ;
  UINT64 h2 ;
  UWORD c ;
  UINT32 *k ;
  UINT32 *d ;
  UINT32 d0 ;
  UINT32 d1 ;
  UINT32 d2 ;
  UINT32 d3 ;
  UINT32 d4 ;
  UINT32 d5 ;
  UINT32 d6 ;
  UINT32 d7 ;
  UINT32 k0 ;
  UINT32 k1 ;
  UINT32 k2 ;
  UINT32 k3 ;
  UINT32 k4 ;
  UINT32 k5 ;
  UINT32 k6 ;
  UINT32 k7 ;
  UINT32 k8 ;
  UINT32 k9 ;
  UINT32 k10 ;
  UINT32 k11 ;

  {
#line 369
  c = dlen / 32U;
#line 370
  k = (UINT32 *)kp;
#line 371
  d = (UINT32 *)dp;
#line 376
  h1 = *((UINT64 *)hp);
#line 377
  h2 = *((UINT64 *)hp + 1);
#line 378
  k0 = *(k + 0);
#line 378
  k1 = *(k + 1);
#line 378
  k2 = *(k + 2);
#line 378
  k3 = *(k + 3);
#line 379
  while (1) {
#line 380
    d0 = *(d + 0);
#line 380
    d1 = *(d + 1);
#line 381
    d2 = *(d + 2);
#line 381
    d3 = *(d + 3);
#line 382
    d4 = *(d + 4);
#line 382
    d5 = *(d + 5);
#line 383
    d6 = *(d + 6);
#line 383
    d7 = *(d + 7);
#line 384
    k4 = *(k + 4);
#line 384
    k5 = *(k + 5);
#line 384
    k6 = *(k + 6);
#line 384
    k7 = *(k + 7);
#line 385
    k8 = *(k + 8);
#line 385
    k9 = *(k + 9);
#line 385
    k10 = *(k + 10);
#line 385
    k11 = *(k + 11);
#line 387
    h1 += (unsigned long long )(k0 + d0) * (unsigned long long )(k4 + d4);
#line 388
    h2 += (unsigned long long )(k4 + d0) * (unsigned long long )(k8 + d4);
#line 390
    h1 += (unsigned long long )(k1 + d1) * (unsigned long long )(k5 + d5);
#line 391
    h2 += (unsigned long long )(k5 + d1) * (unsigned long long )(k9 + d5);
#line 393
    h1 += (unsigned long long )(k2 + d2) * (unsigned long long )(k6 + d6);
#line 394
    h2 += (unsigned long long )(k6 + d2) * (unsigned long long )(k10 + d6);
#line 396
    h1 += (unsigned long long )(k3 + d3) * (unsigned long long )(k7 + d7);
#line 397
    h2 += (unsigned long long )(k7 + d3) * (unsigned long long )(k11 + d7);
#line 399
    k0 = k8;
#line 399
    k1 = k9;
#line 399
    k2 = k10;
#line 399
    k3 = k11;
#line 401
    d += 8;
#line 402
    k += 8;
#line 379
    c --;
#line 379
    if (! c) {
#line 379
      break;
    }
  }
#line 404
  *((UINT64 *)hp + 0) = h1;
#line 405
  *((UINT64 *)hp + 1) = h2;
#line 406
  return;
}
}
#line 534 "umac.c"
static void nh_transform(nh_ctx *hc , UINT8 *buf___1 , UINT32 nbytes ) 
{ UINT8 *key ;

  {
#line 543
  key = hc->nh_key + hc->bytes_hashed;
#line 544
  nh_aux((void *)key, (void *)buf___1, (void *)(hc->state), nbytes);
#line 545
  return;
}
}
#line 550 "umac.c"
static void endian_convert(void *buf___1 , UWORD bpw , UINT32 num_bytes ) 
{ UWORD iters ;
  UINT32 *p ;
  UINT32 *p___0 ;
  UINT32 t ;

  {
#line 554
  iters = num_bytes / bpw;
#line 555
  if (bpw == 4U) {
#line 556
    p = (UINT32 *)buf___1;
#line 557
    while (1) {
#line 558
      *p = LOAD_UINT32_REVERSED((void *)p);
#line 559
      p ++;
#line 557
      iters --;
#line 557
      if (! iters) {
#line 557
        break;
      }
    }
  } else {
#line 561
    if (bpw == 8U) {
#line 562
      p___0 = (UINT32 *)buf___1;
#line 564
      while (1) {
#line 565
        t = LOAD_UINT32_REVERSED((void *)(p___0 + 1));
#line 566
        *(p___0 + 1) = LOAD_UINT32_REVERSED((void *)p___0);
#line 567
        *(p___0 + 0) = t;
#line 568
        p___0 += 2;
#line 564
        iters --;
#line 564
        if (! iters) {
#line 564
          break;
        }
      }
    }
  }
#line 571
  return;
}
}
#line 579 "umac.c"
static void nh_reset(nh_ctx *hc ) 
{ 

  {
#line 582
  hc->bytes_hashed = 0;
#line 583
  hc->next_data_empty = 0;
#line 584
  hc->state[0] = 0ULL;
#line 586
  hc->state[1] = 0ULL;
#line 595
  return;
}
}
#line 599 "umac.c"
static void nh_init(nh_ctx *hc , AES_KEY *prf_key ) 
{ 

  {
#line 602
  kdf((void *)(hc->nh_key), prf_key, (unsigned char)1, (int )sizeof(hc->nh_key));
#line 603
  endian_convert((void *)(hc->nh_key), 4U, sizeof(hc->nh_key));
#line 604
  nh_reset(hc);
#line 605
  return;
}
}
#line 609 "umac.c"
static void nh_update(nh_ctx *hc , UINT8 *buf___1 , UINT32 nbytes ) 
{ UINT32 i ;
  UINT32 j ;

  {
#line 615
  j = (unsigned int )hc->next_data_empty;
#line 616
  if (j + nbytes >= 64U) {
#line 617
    if (j) {
#line 618
      i = 64U - j;
#line 619
      memcpy((void * __restrict  )(hc->data + j), (void const   * __restrict  )buf___1,
             i);
#line 620
      nh_transform(hc, hc->data, 64U);
#line 621
      nbytes -= i;
#line 622
      buf___1 += i;
#line 623
      hc->bytes_hashed += 64;
    }
#line 625
    if (nbytes >= 64U) {
#line 626
      i = nbytes & 4294967232U;
#line 627
      nh_transform(hc, buf___1, i);
#line 628
      nbytes -= i;
#line 629
      buf___1 += i;
#line 630
      hc->bytes_hashed = (int )((UINT32 )hc->bytes_hashed + i);
    }
#line 632
    j = 0U;
  }
#line 634
  memcpy((void * __restrict  )(hc->data + j), (void const   * __restrict  )buf___1,
         nbytes);
#line 635
  hc->next_data_empty = (int )(j + nbytes);
#line 636
  return;
}
}
#line 640 "umac.c"
static void zero_pad(UINT8 *p , int nbytes ) 
{ 

  {
#line 643
  if (nbytes >= (int )sizeof(UWORD )) {
#line 644
    while ((unsigned int )((int )p) % sizeof(UWORD )) {
#line 645
      *p = (unsigned char)0;
#line 646
      nbytes --;
#line 647
      p ++;
    }
#line 649
    while (nbytes >= (int )sizeof(UWORD )) {
#line 650
      *((UWORD *)p) = 0U;
#line 651
      nbytes = (int )((unsigned int )nbytes - sizeof(UWORD ));
#line 652
      p += sizeof(UWORD );
    }
  }
#line 655
  while (nbytes) {
#line 656
    *p = (unsigned char)0;
#line 657
    nbytes --;
#line 658
    p ++;
  }
#line 660
  return;
}
}
#line 664 "umac.c"
static void nh_final(nh_ctx *hc , UINT8 *result ) 
{ int nh_len ;
  int nbits ;

  {
#line 675
  if (hc->next_data_empty != 0) {
#line 676
    nh_len = (hc->next_data_empty + 31) & -32;
#line 678
    zero_pad(hc->data + hc->next_data_empty, nh_len - hc->next_data_empty);
#line 680
    nh_transform(hc, hc->data, (unsigned int )nh_len);
#line 681
    hc->bytes_hashed += hc->next_data_empty;
  } else {
#line 682
    if (hc->bytes_hashed == 0) {
#line 683
      nh_len = 32;
#line 684
      zero_pad(hc->data, 32);
#line 685
      nh_transform(hc, hc->data, (unsigned int )nh_len);
    }
  }
#line 688
  nbits = hc->bytes_hashed << 3;
#line 689
  *((UINT64 *)result + 0) = hc->state[0] + (UINT64 )nbits;
#line 691
  *((UINT64 *)result + 1) = hc->state[1] + (UINT64 )nbits;
#line 699
  nh_reset(hc);
#line 700
  return;
}
}
#line 704 "umac.c"
static void nh(nh_ctx *hc , UINT8 *buf___1 , UINT32 padded_len , UINT32 unpadded_len ,
               UINT8 *result ) 
{ UINT32 nbits ;

  {
#line 714
  nbits = unpadded_len << 3;
#line 716
  *((UINT64 *)result + 0) = (unsigned long long )nbits;
#line 718
  *((UINT64 *)result + 1) = (unsigned long long )nbits;
#line 727
  nh_aux((void *)(hc->nh_key), (void *)buf___1, (void *)result, padded_len);
#line 728
  return;
}
}
#line 794 "umac.c"
static UINT64 poly64(UINT64 cur , UINT64 key , UINT64 data ) 
{ UINT32 key_hi ;
  UINT32 key_lo ;
  UINT32 cur_hi ;
  UINT32 cur_lo ;
  UINT32 x_lo ;
  UINT32 x_hi ;
  UINT64 X ;
  UINT64 T ;
  UINT64 res ;

  {
#line 796
  key_hi = (unsigned int )(key >> 32);
#line 796
  key_lo = (unsigned int )key;
#line 796
  cur_hi = (unsigned int )(cur >> 32);
#line 796
  cur_lo = (unsigned int )cur;
#line 804
  X = (unsigned long long )key_hi * (unsigned long long )cur_lo + (unsigned long long )cur_hi * (unsigned long long )key_lo;
#line 805
  x_lo = (unsigned int )X;
#line 806
  x_hi = (unsigned int )(X >> 32);
#line 808
  res = ((unsigned long long )key_hi * (unsigned long long )cur_hi + (unsigned long long )x_hi) * 59ULL + (unsigned long long )key_lo * (unsigned long long )cur_lo;
#line 810
  T = (unsigned long long )x_lo << 32;
#line 811
  res += T;
#line 812
  if (res < T) {
#line 813
    res += 59ULL;
  }
#line 815
  res += data;
#line 816
  if (res < data) {
#line 817
    res += 59ULL;
  }
#line 819
  return (res);
}
}
#line 829 "umac.c"
static void poly_hash(uhash_ctx_t hc , UINT32 *data_in ) 
{ int i ;
  UINT64 *data ;

  {
#line 832
  data = (UINT64 *)data_in;
#line 834
  i = 0;
#line 834
  while (i < 2) {
#line 835
    if ((unsigned long )((unsigned int )(*(data + i) >> 32)) == 4294967295UL) {
#line 836
      hc->poly_accum[i] = poly64(hc->poly_accum[i], hc->poly_key_8[i], 0xffffffffffffffc4ULL);
#line 838
      hc->poly_accum[i] = poly64(hc->poly_accum[i], hc->poly_key_8[i], *(data + i) - 59ULL);
    } else {
#line 841
      hc->poly_accum[i] = poly64(hc->poly_accum[i], hc->poly_key_8[i], *(data + i));
    }
#line 834
    i ++;
  }
#line 845
  return;
}
}
#line 857 "umac.c"
static UINT64 ip_aux(UINT64 t , UINT64 *ipkp , UINT64 data ) 
{ 

  {
#line 859
  t += *(ipkp + 0) * (unsigned long long )((unsigned short )(data >> 48));
#line 860
  t += *(ipkp + 1) * (unsigned long long )((unsigned short )(data >> 32));
#line 861
  t += *(ipkp + 2) * (unsigned long long )((unsigned short )(data >> 16));
#line 862
  t += *(ipkp + 3) * (unsigned long long )((unsigned short )data);
#line 864
  return (t);
}
}
#line 867 "umac.c"
static UINT32 ip_reduce_p36(UINT64 t ) 
{ UINT64 ret___0 ;

  {
#line 872
  ret___0 = (t & 68719476735ULL) + 5ULL * (t >> 36);
#line 873
  if (ret___0 >= 68719476731ULL) {
#line 874
    ret___0 -= 68719476731ULL;
  }
#line 877
  return ((unsigned int )ret___0);
}
}
#line 885 "umac.c"
static void ip_short(uhash_ctx_t ahc , UINT8 *nh_res , u_char *res ) 
{ UINT64 t ;
  UINT64 *nhp ;
  UINT32 tmp ;
  UINT32 tmp___0 ;

  {
#line 888
  nhp = (UINT64 *)nh_res;
#line 890
  t = ip_aux(0ULL, ahc->ip_keys, *(nhp + 0));
#line 891
  tmp = ip_reduce_p36(t);
#line 891
  STORE_UINT32_REVERSED((void *)((UINT32 *)res + 0), tmp ^ ahc->ip_trans[0]);
#line 893
  t = ip_aux(0ULL, ahc->ip_keys + 4, *(nhp + 1));
#line 894
  tmp___0 = ip_reduce_p36(t);
#line 894
  STORE_UINT32_REVERSED((void *)((UINT32 *)res + 1), tmp___0 ^ ahc->ip_trans[1]);
#line 904
  return;
}
}
#line 910 "umac.c"
static void ip_long(uhash_ctx_t ahc , u_char *res ) 
{ int i ;
  UINT64 t ;
  UINT32 tmp ;

  {
#line 915
  i = 0;
#line 915
  while (i < 2) {
#line 917
    if (ahc->poly_accum[i] >= 0xffffffffffffffc5ULL) {
#line 918
      ahc->poly_accum[i] -= 0xffffffffffffffc5ULL;
    }
#line 919
    t = ip_aux(0ULL, ahc->ip_keys + i * 4, ahc->poly_accum[i]);
#line 920
    tmp = ip_reduce_p36(t);
#line 920
    STORE_UINT32_REVERSED((void *)((UINT32 *)res + i), tmp ^ ahc->ip_trans[i]);
#line 915
    i ++;
  }
#line 923
  return;
}
}
#line 931 "umac.c"
static int uhash_reset(uhash_ctx_t pc ) 
{ 

  {
#line 933
  nh_reset(& pc->hash);
#line 934
  pc->msg_len = 0U;
#line 935
  pc->poly_accum[0] = 1ULL;
#line 937
  pc->poly_accum[1] = 1ULL;
#line 945
  return (1);
}
}
#line 955 "umac.c"
static void uhash_init(uhash_ctx_t ahc , AES_KEY *prf_key ) 
{ int i ;
  UINT8 buf___1[20U * sizeof(UINT64 )] ;

  {
#line 961
  memset((void *)ahc, 0, sizeof(uhash_ctx ));
#line 964
  nh_init(& ahc->hash, prf_key);
#line 967
  kdf((void *)(buf___1), prf_key, (unsigned char)2, (int )sizeof(buf___1));
#line 968
  i = 0;
#line 968
  while (i < 2) {
#line 973
    memcpy((void * __restrict  )(ahc->poly_key_8 + i), (void const   * __restrict  )(buf___1 + 24 * i),
           8U);
#line 974
    endian_convert((void *)(ahc->poly_key_8 + i), 8U, 8U);
#line 976
    ahc->poly_key_8[i] &= (33554431ULL << 32) + 33554431ULL;
#line 977
    ahc->poly_accum[i] = 1ULL;
#line 968
    i ++;
  }
#line 981
  kdf((void *)(buf___1), prf_key, (unsigned char)3, (int )sizeof(buf___1));
#line 982
  i = 0;
#line 982
  while (i < 2) {
#line 983
    memcpy((void * __restrict  )(ahc->ip_keys + 4 * i), (void const   * __restrict  )(buf___1 + (unsigned int )(8 * i + 4) * sizeof(UINT64 )),
           4U * sizeof(UINT64 ));
#line 982
    i ++;
  }
#line 985
  endian_convert((void *)(ahc->ip_keys), sizeof(UINT64 ), sizeof(ahc->ip_keys));
#line 987
  i = 0;
#line 987
  while (i < 8) {
#line 988
    ahc->ip_keys[i] %= 68719476731ULL;
#line 987
    i ++;
  }
#line 992
  kdf((void *)(ahc->ip_trans), prf_key, (unsigned char)4, (int )(2U * sizeof(UINT32 )));
#line 993
  endian_convert((void *)(ahc->ip_trans), sizeof(UINT32 ), 2U * sizeof(UINT32 ));
#line 995
  return;
}
}
#line 1042 "umac.c"
static int uhash_update(uhash_ctx_t ctx , u_char *input___0 , long len ) 
{ UWORD bytes_hashed ;
  UWORD bytes_remaining ;
  UINT64 result_buf[2] ;
  UINT8 *nh_result ;

  {
#line 1049
  nh_result = (UINT8 *)(& result_buf);
#line 1051
  if ((unsigned long )ctx->msg_len + (unsigned long )len <= 1024UL) {
#line 1052
    nh_update(& ctx->hash, input___0, (unsigned int )len);
#line 1053
    ctx->msg_len = (unsigned int )((unsigned long )ctx->msg_len + (unsigned long )len);
  } else {
#line 1056
    bytes_hashed = ctx->msg_len % 1024U;
#line 1057
    if (ctx->msg_len == 1024U) {
#line 1058
      bytes_hashed = 1024U;
    }
#line 1060
    if ((unsigned long )bytes_hashed + (unsigned long )len >= 1024UL) {
#line 1065
      if (bytes_hashed) {
#line 1066
        bytes_remaining = 1024U - bytes_hashed;
#line 1067
        nh_update(& ctx->hash, input___0, bytes_remaining);
#line 1068
        nh_final(& ctx->hash, nh_result);
#line 1069
        ctx->msg_len += bytes_remaining;
#line 1070
        poly_hash(ctx, (UINT32 *)nh_result);
#line 1071
        len = (long )((unsigned long )len - (unsigned long )bytes_remaining);
#line 1072
        input___0 += bytes_remaining;
      }
#line 1076
      while (len >= 1024L) {
#line 1077
        nh(& ctx->hash, input___0, 1024U, 1024U, nh_result);
#line 1079
        ctx->msg_len += 1024U;
#line 1080
        len -= 1024L;
#line 1081
        input___0 += 1024;
#line 1082
        poly_hash(ctx, (UINT32 *)nh_result);
      }
    }
#line 1087
    if (len) {
#line 1088
      nh_update(& ctx->hash, input___0, (unsigned int )len);
#line 1089
      ctx->msg_len = (unsigned int )((unsigned long )ctx->msg_len + (unsigned long )len);
    }
  }
#line 1093
  return (1);
}
}
#line 1098 "umac.c"
static int uhash_final(uhash_ctx_t ctx , u_char *res ) 
{ UINT64 result_buf[2] ;
  UINT8 *nh_result ;

  {
#line 1102
  nh_result = (UINT8 *)(& result_buf);
#line 1104
  if (ctx->msg_len > 1024U) {
#line 1105
    if (ctx->msg_len % 1024U) {
#line 1106
      nh_final(& ctx->hash, nh_result);
#line 1107
      poly_hash(ctx, (UINT32 *)nh_result);
    }
#line 1109
    ip_long(ctx, res);
  } else {
#line 1111
    nh_final(& ctx->hash, nh_result);
#line 1112
    ip_short(ctx, nh_result, res);
  }
#line 1114
  uhash_reset(ctx);
#line 1115
  return (1);
}
}
#line 1179 "umac.c"
struct umac_ctx umac_ctx  ;
#line 1198 "umac.c"
int umac_delete(struct umac_ctx *ctx ) 
{ 

  {
#line 1201
  if (ctx) {
#line 1203
    ctx = (struct umac_ctx *)ctx->free_ptr;
#line 1204
    xfree((void *)ctx);
  }
#line 1206
  return (1);
}
}
#line 1211 "umac.c"
struct umac_ctx *umac_new(u_char *key ) 
{ struct umac_ctx *ctx ;
  struct umac_ctx *octx ;
  size_t bytes_to_add ;
  aes_int_key prf_key ;
  void *tmp ;

  {
#line 1220
  tmp = xmalloc(sizeof(*ctx) + 16U);
#line 1220
  ctx = (struct umac_ctx *)tmp;
#line 1220
  octx = ctx;
#line 1221
  if (ctx) {
#line 1223
    bytes_to_add = (unsigned int )(16 - ((int )ctx & 15));
#line 1225
    ctx = (struct umac_ctx *)((u_char *)ctx + bytes_to_add);
#line 1227
    ctx->free_ptr = (void *)octx;
#line 1228
    AES_set_encrypt_key((unsigned char const   *)key, 128, prf_key);
#line 1229
    pdf_init(& ctx->pdf, (AES_KEY *)(prf_key));
#line 1230
    uhash_init(& ctx->hash, (AES_KEY *)(prf_key));
  }
#line 1233
  return (ctx);
}
}
#line 1238 "umac.c"
int umac_final(struct umac_ctx *ctx , u_char *tag , u_char *nonce ) 
{ 

  {
#line 1241
  uhash_final(& ctx->hash, tag);
#line 1242
  pdf_gen_xor(& ctx->pdf, (UINT8 *)((UINT8 *)nonce), (UINT8 *)tag);
#line 1244
  return (1);
}
}
#line 1249 "umac.c"
int umac_update(struct umac_ctx *ctx , u_char *input___0 , long len ) 
{ 

  {
#line 1254
  uhash_update(& ctx->hash, input___0, len);
#line 1255
  return (1);
}
}
#line 1 "jpake.o"
#pragma merger(0,"./jpake.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 403 "/usr/include/openssl/bn.h"
extern int BN_rand_range(BIGNUM *rnd , BIGNUM *range ) ;
#line 420
extern int BN_mul(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b , BN_CTX *ctx ) ;
#line 439
extern int BN_mod_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b , BIGNUM const   *m ,
                      BN_CTX *ctx ) ;
#line 441
extern int BN_mod_mul(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b , BIGNUM const   *m ,
                      BN_CTX *ctx ) ;
#line 464
extern int BN_mod_exp(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                      BN_CTX *ctx ) ;
#line 489
extern int BN_rshift1(BIGNUM *r , BIGNUM const   *a ) ;
#line 482 "/usr/include/openssl/evp.h"
extern void EVP_MD_CTX_init(EVP_MD_CTX *ctx ) ;
#line 483
extern int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx ) ;
#line 490
extern int EVP_DigestInit_ex(EVP_MD_CTX *ctx , EVP_MD const   *type , ENGINE *impl ) ;
#line 493
extern int EVP_DigestFinal_ex(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 86 "jpake.h"
struct jpake_group *jpake_default_group(void) ;
#line 87
BIGNUM *bn_rand_range_gt_one(BIGNUM const   *high ) ;
#line 88
int hash_buffer(u_char const   *buf___1 , u_int len , EVP_MD const   *md , u_char **digestp ,
                u_int *lenp ) ;
#line 89
void ( /* format attribute */  jpake_debug3_bn)(BIGNUM const   *n___0 , char const   *fmt 
                                                , ...)  __attribute__((__nonnull__(2))) ;
#line 92
void ( /* format attribute */  jpake_debug3_buf)(u_char const   *buf___1 , u_int len ,
                                                 char const   *fmt  , ...)  __attribute__((__nonnull__(3))) ;
#line 95
void ( /* format attribute */  jpake_dump)(struct jpake_ctx *pctx , char const   *fmt 
                                           , ...)  __attribute__((__nonnull__(2))) ;
#line 98
struct jpake_ctx *jpake_new(void) ;
#line 99
void jpake_free(struct jpake_ctx *pctx ) ;
#line 101
void jpake_step1(struct jpake_group *grp , u_char **id , u_int *id_len , BIGNUM **priv1 ,
                 BIGNUM **priv2 , BIGNUM **g_priv1 , BIGNUM **g_priv2 , u_char **priv1_proof ,
                 u_int *priv1_proof_len , u_char **priv2_proof , u_int *priv2_proof_len ) ;
#line 105
void jpake_step2(struct jpake_group *grp , BIGNUM *s , BIGNUM *mypub1 , BIGNUM *theirpub1 ,
                 BIGNUM *theirpub2 , BIGNUM *mypriv2 , u_char const   *theirid , u_int theirid_len ,
                 u_char const   *myid , u_int myid_len , u_char const   *theirpub1_proof ,
                 u_int theirpub1_proof_len , u_char const   *theirpub2_proof , u_int theirpub2_proof_len ,
                 BIGNUM **newpub , u_char **newpub_exponent_proof , u_int *newpub_exponent_proof_len ) ;
#line 111
void jpake_confirm_hash(BIGNUM const   *k , u_char const   *endpoint_id , u_int endpoint_id_len ,
                        u_char const   *sess_id , u_int sess_id_len , u_char **confirm_hash ,
                        u_int *confirm_hash_len ) ;
#line 116
void jpake_key_confirm(struct jpake_group *grp , BIGNUM *s , BIGNUM *step2_val , BIGNUM *mypriv2 ,
                       BIGNUM *mypub1 , BIGNUM *mypub2 , BIGNUM *theirpub1 , BIGNUM *theirpub2 ,
                       u_char const   *my_id , u_int my_id_len , u_char const   *their_id ,
                       u_int their_id_len , u_char const   *sess_id , u_int sess_id_len ,
                       u_char const   *theirpriv2_s_proof , u_int theirpriv2_s_proof_len ,
                       BIGNUM **k , u_char **confirm_hash , u_int *confirm_hash_len ) ;
#line 122
int jpake_check_confirm(BIGNUM const   *k , u_char const   *peer_id , u_int peer_id_len ,
                        u_char const   *sess_id , u_int sess_id_len , u_char const   *peer_confirm_hash ,
                        u_int peer_confirm_hash_len ) ;
#line 126
int schnorr_sign(BIGNUM const   *grp_p , BIGNUM const   *grp_q , BIGNUM const   *grp_g ,
                 BIGNUM const   *x , BIGNUM const   *g_x , u_char const   *id , u_int idlen ,
                 u_char **sig , u_int *siglen ) ;
#line 129
int schnorr_verify(BIGNUM const   *grp_p , BIGNUM const   *grp_q , BIGNUM const   *grp_g ,
                   BIGNUM const   *g_x , u_char const   *id , u_int idlen , u_char const   *sig ,
                   u_int siglen ) ;
#line 63 "jpake.c"
struct jpake_group *jpake_default_group(void) 
{ struct jpake_group *ret___0 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 68
  tmp = xmalloc(sizeof(*ret___0));
#line 68
  ret___0 = (struct jpake_group *)tmp;
#line 69
  ret___0->g = (BIGNUM *)((void *)0);
#line 69
  ret___0->q = ret___0->g;
#line 69
  ret___0->p = ret___0->q;
#line 70
  tmp___0 = BN_hex2bn(& ret___0->p, "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF");
#line 70
  if (tmp___0 == 0) {
#line 72
    fatal("%s: BN_hex2bn", "jpake_default_group");
  } else {
#line 70
    tmp___1 = BN_hex2bn(& ret___0->g, "2");
#line 70
    if (tmp___1 == 0) {
#line 72
      fatal("%s: BN_hex2bn", "jpake_default_group");
    }
  }
#line 74
  ret___0->q = BN_new();
#line 74
  if ((unsigned int )ret___0->q == (unsigned int )((void *)0)) {
#line 75
    fatal("%s: BN_new", "jpake_default_group");
  }
#line 76
  tmp___2 = BN_rshift1(ret___0->q, (BIGNUM const   *)ret___0->p);
#line 76
  if (tmp___2 != 1) {
#line 77
    fatal("%s: BN_rshift1", "jpake_default_group");
  }
#line 79
  return (ret___0);
}
}
#line 86 "jpake.c"
BIGNUM *bn_rand_range_gt_one(BIGNUM const   *high ) 
{ BIGNUM *r ;
  BIGNUM *tmp ;
  int success ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 90
  success = -1;
#line 92
  tmp = BN_new();
#line 92
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 93
    error("%s: BN_new", "bn_rand_range_gt_one");
#line 94
    return ((BIGNUM *)((void *)0));
  }
#line 96
  r = BN_new();
#line 96
  if ((unsigned int )r == (unsigned int )((void *)0)) {
#line 97
    error("%s: BN_new failed", "bn_rand_range_gt_one");
    goto out;
  }
#line 100
  tmp___0 = BN_set_word(tmp, 2UL);
#line 100
  if (tmp___0 != 1) {
#line 101
    error("%s: BN_set_word(tmp, 2)", "bn_rand_range_gt_one");
    goto out;
  }
#line 104
  tmp___1 = BN_sub(tmp, high, (BIGNUM const   *)tmp);
#line 104
  if (tmp___1 == -1) {
#line 105
    error("%s: BN_sub failed (tmp = high - 2)", "bn_rand_range_gt_one");
    goto out;
  }
#line 108
  tmp___2 = BN_rand_range(r, tmp);
#line 108
  if (tmp___2 == -1) {
#line 109
    error("%s: BN_rand_range failed", "bn_rand_range_gt_one");
    goto out;
  }
#line 112
  tmp___3 = BN_set_word(tmp, 2UL);
#line 112
  if (tmp___3 != 1) {
#line 113
    error("%s: BN_set_word(tmp, 2)", "bn_rand_range_gt_one");
    goto out;
  }
#line 116
  tmp___4 = BN_add(r, (BIGNUM const   *)r, (BIGNUM const   *)tmp);
#line 116
  if (tmp___4 == -1) {
#line 117
    error("%s: BN_add failed (r = r + 2)", "bn_rand_range_gt_one");
    goto out;
  }
#line 120
  success = 0;
  out: 
#line 122
  BN_clear_free(tmp);
#line 123
  if (success == 0) {
#line 124
    return (r);
  }
#line 125
  BN_clear_free(r);
#line 126
  return ((BIGNUM *)((void *)0));
}
}
#line 134 "jpake.c"
int hash_buffer(u_char const   *buf___1 , u_int len , EVP_MD const   *md , u_char **digestp ,
                u_int *lenp ) 
{ u_char digest___1[64] ;
  u_int digest_len ;
  EVP_MD_CTX evp_md_ctx ;
  int success ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 141
  success = -1;
#line 143
  EVP_MD_CTX_init(& evp_md_ctx);
#line 145
  tmp = EVP_DigestInit_ex(& evp_md_ctx, md, (ENGINE *)((void *)0));
#line 145
  if (tmp != 1) {
#line 146
    error("%s: EVP_DigestInit_ex", "hash_buffer");
    goto out;
  }
#line 149
  tmp___0 = EVP_DigestUpdate(& evp_md_ctx, (void const   *)buf___1, len);
#line 149
  if (tmp___0 != 1) {
#line 150
    error("%s: EVP_DigestUpdate", "hash_buffer");
    goto out;
  }
#line 153
  tmp___1 = EVP_DigestFinal_ex(& evp_md_ctx, digest___1, & digest_len);
#line 153
  if (tmp___1 != 1) {
#line 154
    error("%s: EVP_DigestFinal_ex", "hash_buffer");
    goto out;
  }
#line 157
  tmp___2 = xmalloc(digest_len);
#line 157
  *digestp = (u_char *)tmp___2;
#line 158
  *lenp = digest_len;
#line 159
  memcpy((void * __restrict  )*digestp, (void const   * __restrict  )(digest___1),
         *lenp);
#line 160
  success = 0;
  out: 
#line 162
  EVP_MD_CTX_cleanup(& evp_md_ctx);
#line 163
  bzero((void *)(digest___1), sizeof(digest___1));
#line 164
  digest_len = 0U;
#line 165
  return (success);
}
}
#line 169
void ( /* format attribute */  jpake_debug3_bn)(BIGNUM const   *n___0 , char const   *fmt 
                                                , ...)  __attribute__((__nonnull__(2))) ;
#line 169 "jpake.c"
void ( /* format attribute */  jpake_debug3_bn)(BIGNUM const   *n___0 , char const   *fmt 
                                                , ...) 
{ char *out ;
  char *h___0 ;
  va_list args ;

  {
#line 175
  out = (char *)((void *)0);
#line 176
  __builtin_va_start(args, fmt);
#line 177
  vasprintf((char ** __restrict  )(& out), (char const   * __restrict  )fmt, args);
#line 178
  __builtin_va_end(args);
#line 179
  if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 180
    fatal("%s: vasprintf failed", "jpake_debug3_bn");
  }
#line 182
  if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 183
    debug3("%s(null)", out);
  } else {
#line 185
    h___0 = BN_bn2hex(n___0);
#line 186
    debug3("%s0x%s", out, h___0);
#line 187
    free((void *)h___0);
  }
#line 189
  free((void *)out);
#line 190
  return;
}
}
#line 193
void ( /* format attribute */  jpake_debug3_buf)(u_char const   *buf___1 , u_int len ,
                                                 char const   *fmt  , ...)  __attribute__((__nonnull__(3))) ;
#line 193 "jpake.c"
void ( /* format attribute */  jpake_debug3_buf)(u_char const   *buf___1 , u_int len ,
                                                 char const   *fmt  , ...) 
{ char *out ;
  char h___0[65] ;
  u_int i ;
  u_int j ;
  va_list args ;
  char const   *tmp ;

  {
#line 200
  out = (char *)((void *)0);
#line 201
  __builtin_va_start(args, fmt);
#line 202
  vasprintf((char ** __restrict  )(& out), (char const   * __restrict  )fmt, args);
#line 203
  __builtin_va_end(args);
#line 204
  if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 205
    fatal("%s: vasprintf failed", "jpake_debug3_buf");
  }
#line 207
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 207
    tmp = " (null)";
  } else {
#line 207
    tmp = "";
  }
#line 207
  debug3("%s length %u%s", out, len, tmp);
#line 208
  free((void *)out);
#line 209
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 210
    return;
  }
#line 212
  h___0[0] = (char )'\000';
#line 213
  j = 0U;
#line 213
  i = j;
#line 213
  while (i < len) {
#line 214
    snprintf((char * __restrict  )(h___0 + j), sizeof(h___0) - j, (char const   * __restrict  )"%02x",
             *(buf___1 + i));
#line 215
    j += 2U;
#line 216
    if (j >= sizeof(h___0) - 1U) {
#line 217
      debug3("    %s", h___0);
#line 218
      h___0[0] = (char )'\000';
#line 219
      j = 0U;
    } else {
#line 216
      if (i == len - 1U) {
#line 217
        debug3("    %s", h___0);
#line 218
        h___0[0] = (char )'\000';
#line 219
        j = 0U;
      }
    }
#line 213
    i ++;
  }
#line 222
  return;
}
}
#line 224 "jpake.c"
struct jpake_ctx *jpake_new(void) 
{ struct jpake_ctx *ret___0 ;
  void *tmp ;

  {
#line 229
  tmp = xcalloc(1U, sizeof(*ret___0));
#line 229
  ret___0 = (struct jpake_ctx *)tmp;
#line 231
  ret___0->grp = jpake_default_group();
#line 233
  ret___0->k = (BIGNUM *)((void *)0);
#line 233
  ret___0->s = ret___0->k;
#line 234
  ret___0->x4 = (BIGNUM *)((void *)0);
#line 234
  ret___0->x3 = ret___0->x4;
#line 234
  ret___0->x2 = ret___0->x3;
#line 234
  ret___0->x1 = ret___0->x2;
#line 235
  ret___0->g_x4 = (BIGNUM *)((void *)0);
#line 235
  ret___0->g_x3 = ret___0->g_x4;
#line 235
  ret___0->g_x2 = ret___0->g_x3;
#line 235
  ret___0->g_x1 = ret___0->g_x2;
#line 236
  ret___0->b = (BIGNUM *)((void *)0);
#line 236
  ret___0->a = ret___0->b;
#line 238
  ret___0->server_id = (u_char *)((void *)0);
#line 238
  ret___0->client_id = ret___0->server_id;
#line 239
  ret___0->h_k_sid_sessid = (u_char *)((void *)0);
#line 239
  ret___0->h_k_cid_sessid = ret___0->h_k_sid_sessid;
#line 241
  debug3("%s: alloc %p", "jpake_new", ret___0);
#line 243
  return (ret___0);
}
}
#line 247 "jpake.c"
void jpake_free(struct jpake_ctx *pctx ) 
{ 

  {
#line 250
  debug3("%s: free %p", "jpake_free", pctx);
#line 269
  while (1) {
#line 269
    if ((unsigned int )pctx->s != (unsigned int )((void *)0)) {
#line 269
      BN_clear_free(pctx->s);
#line 269
      pctx->s = (BIGNUM *)((void *)0);
    }
#line 269
    break;
  }
#line 270
  while (1) {
#line 270
    if ((unsigned int )pctx->k != (unsigned int )((void *)0)) {
#line 270
      BN_clear_free(pctx->k);
#line 270
      pctx->k = (BIGNUM *)((void *)0);
    }
#line 270
    break;
  }
#line 271
  while (1) {
#line 271
    if ((unsigned int )pctx->x1 != (unsigned int )((void *)0)) {
#line 271
      BN_clear_free(pctx->x1);
#line 271
      pctx->x1 = (BIGNUM *)((void *)0);
    }
#line 271
    break;
  }
#line 272
  while (1) {
#line 272
    if ((unsigned int )pctx->x2 != (unsigned int )((void *)0)) {
#line 272
      BN_clear_free(pctx->x2);
#line 272
      pctx->x2 = (BIGNUM *)((void *)0);
    }
#line 272
    break;
  }
#line 273
  while (1) {
#line 273
    if ((unsigned int )pctx->x3 != (unsigned int )((void *)0)) {
#line 273
      BN_clear_free(pctx->x3);
#line 273
      pctx->x3 = (BIGNUM *)((void *)0);
    }
#line 273
    break;
  }
#line 274
  while (1) {
#line 274
    if ((unsigned int )pctx->x4 != (unsigned int )((void *)0)) {
#line 274
      BN_clear_free(pctx->x4);
#line 274
      pctx->x4 = (BIGNUM *)((void *)0);
    }
#line 274
    break;
  }
#line 275
  while (1) {
#line 275
    if ((unsigned int )pctx->g_x1 != (unsigned int )((void *)0)) {
#line 275
      BN_clear_free(pctx->g_x1);
#line 275
      pctx->g_x1 = (BIGNUM *)((void *)0);
    }
#line 275
    break;
  }
#line 276
  while (1) {
#line 276
    if ((unsigned int )pctx->g_x2 != (unsigned int )((void *)0)) {
#line 276
      BN_clear_free(pctx->g_x2);
#line 276
      pctx->g_x2 = (BIGNUM *)((void *)0);
    }
#line 276
    break;
  }
#line 277
  while (1) {
#line 277
    if ((unsigned int )pctx->g_x3 != (unsigned int )((void *)0)) {
#line 277
      BN_clear_free(pctx->g_x3);
#line 277
      pctx->g_x3 = (BIGNUM *)((void *)0);
    }
#line 277
    break;
  }
#line 278
  while (1) {
#line 278
    if ((unsigned int )pctx->g_x4 != (unsigned int )((void *)0)) {
#line 278
      BN_clear_free(pctx->g_x4);
#line 278
      pctx->g_x4 = (BIGNUM *)((void *)0);
    }
#line 278
    break;
  }
#line 279
  while (1) {
#line 279
    if ((unsigned int )pctx->a != (unsigned int )((void *)0)) {
#line 279
      BN_clear_free(pctx->a);
#line 279
      pctx->a = (BIGNUM *)((void *)0);
    }
#line 279
    break;
  }
#line 280
  while (1) {
#line 280
    if ((unsigned int )pctx->b != (unsigned int )((void *)0)) {
#line 280
      BN_clear_free(pctx->b);
#line 280
      pctx->b = (BIGNUM *)((void *)0);
    }
#line 280
    break;
  }
#line 282
  while (1) {
#line 282
    if ((unsigned int )pctx->client_id != (unsigned int )((void *)0)) {
#line 282
      bzero((void *)pctx->client_id, pctx->client_id_len);
#line 282
      xfree((void *)pctx->client_id);
#line 282
      pctx->client_id = (u_char *)((void *)0);
#line 282
      pctx->client_id_len = 0U;
    }
#line 282
    break;
  }
#line 283
  while (1) {
#line 283
    if ((unsigned int )pctx->server_id != (unsigned int )((void *)0)) {
#line 283
      bzero((void *)pctx->server_id, pctx->server_id_len);
#line 283
      xfree((void *)pctx->server_id);
#line 283
      pctx->server_id = (u_char *)((void *)0);
#line 283
      pctx->server_id_len = 0U;
    }
#line 283
    break;
  }
#line 284
  while (1) {
#line 284
    if ((unsigned int )pctx->h_k_cid_sessid != (unsigned int )((void *)0)) {
#line 284
      bzero((void *)pctx->h_k_cid_sessid, pctx->h_k_cid_sessid_len);
#line 284
      xfree((void *)pctx->h_k_cid_sessid);
#line 284
      pctx->h_k_cid_sessid = (u_char *)((void *)0);
#line 284
      pctx->h_k_cid_sessid_len = 0U;
    }
#line 284
    break;
  }
#line 285
  while (1) {
#line 285
    if ((unsigned int )pctx->h_k_sid_sessid != (unsigned int )((void *)0)) {
#line 285
      bzero((void *)pctx->h_k_sid_sessid, pctx->h_k_sid_sessid_len);
#line 285
      xfree((void *)pctx->h_k_sid_sessid);
#line 285
      pctx->h_k_sid_sessid = (u_char *)((void *)0);
#line 285
      pctx->h_k_sid_sessid_len = 0U;
    }
#line 285
    break;
  }
#line 290
  bzero((void *)pctx, sizeof(pctx));
#line 291
  xfree((void *)pctx);
#line 292
  return;
}
}
#line 295
void ( /* format attribute */  jpake_dump)(struct jpake_ctx *pctx , char const   *fmt 
                                           , ...)  __attribute__((__nonnull__(2))) ;
#line 295 "jpake.c"
void ( /* format attribute */  jpake_dump)(struct jpake_ctx *pctx , char const   *fmt 
                                           , ...) 
{ char *out ;
  va_list args ;

  {
#line 301
  out = (char *)((void *)0);
#line 302
  __builtin_va_start(args, fmt);
#line 303
  vasprintf((char ** __restrict  )(& out), (char const   * __restrict  )fmt, args);
#line 304
  __builtin_va_end(args);
#line 305
  if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 306
    fatal("%s: vasprintf failed", "jpake_dump");
  }
#line 308
  debug3("%s: %s (ctx at %p)", "jpake_dump", out, pctx);
#line 309
  if ((unsigned int )pctx == (unsigned int )((void *)0)) {
#line 310
    free((void *)out);
#line 311
    return;
  }
#line 323
  while (1) {
#line 323
    if ((unsigned int )pctx->s != (unsigned int )((void *)0)) {

    }
#line 323
    break;
  }
#line 324
  while (1) {
#line 324
    if ((unsigned int )pctx->k != (unsigned int )((void *)0)) {

    }
#line 324
    break;
  }
#line 325
  while (1) {
#line 325
    if ((unsigned int )pctx->x1 != (unsigned int )((void *)0)) {

    }
#line 325
    break;
  }
#line 326
  while (1) {
#line 326
    if ((unsigned int )pctx->x2 != (unsigned int )((void *)0)) {

    }
#line 326
    break;
  }
#line 327
  while (1) {
#line 327
    if ((unsigned int )pctx->x3 != (unsigned int )((void *)0)) {

    }
#line 327
    break;
  }
#line 328
  while (1) {
#line 328
    if ((unsigned int )pctx->x4 != (unsigned int )((void *)0)) {

    }
#line 328
    break;
  }
#line 329
  while (1) {
#line 329
    if ((unsigned int )pctx->g_x1 != (unsigned int )((void *)0)) {

    }
#line 329
    break;
  }
#line 330
  while (1) {
#line 330
    if ((unsigned int )pctx->g_x2 != (unsigned int )((void *)0)) {

    }
#line 330
    break;
  }
#line 331
  while (1) {
#line 331
    if ((unsigned int )pctx->g_x3 != (unsigned int )((void *)0)) {

    }
#line 331
    break;
  }
#line 332
  while (1) {
#line 332
    if ((unsigned int )pctx->g_x4 != (unsigned int )((void *)0)) {

    }
#line 332
    break;
  }
#line 333
  while (1) {
#line 333
    if ((unsigned int )pctx->a != (unsigned int )((void *)0)) {

    }
#line 333
    break;
  }
#line 334
  while (1) {
#line 334
    if ((unsigned int )pctx->b != (unsigned int )((void *)0)) {

    }
#line 334
    break;
  }
#line 336
  while (1) {
#line 336
    if ((unsigned int )pctx->client_id != (unsigned int )((void *)0)) {

    }
#line 336
    break;
  }
#line 337
  while (1) {
#line 337
    if ((unsigned int )pctx->server_id != (unsigned int )((void *)0)) {

    }
#line 337
    break;
  }
#line 338
  while (1) {
#line 338
    if ((unsigned int )pctx->h_k_cid_sessid != (unsigned int )((void *)0)) {

    }
#line 338
    break;
  }
#line 339
  while (1) {
#line 339
    if ((unsigned int )pctx->h_k_sid_sessid != (unsigned int )((void *)0)) {

    }
#line 339
    break;
  }
#line 341
  debug3("%s: %s done", "jpake_dump", out);
#line 342
  free((void *)out);
#line 343
  return;
}
}
#line 346 "jpake.c"
void jpake_step1(struct jpake_group *grp , u_char **id , u_int *id_len , BIGNUM **priv1 ,
                 BIGNUM **priv2 , BIGNUM **g_priv1 , BIGNUM **g_priv2 , u_char **priv1_proof ,
                 u_int *priv1_proof_len , u_char **priv2_proof , u_int *priv2_proof_len ) 
{ BN_CTX *bn_ctx ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 355
  bn_ctx = BN_CTX_new();
#line 355
  if ((unsigned int )bn_ctx == (unsigned int )((void *)0)) {
#line 356
    fatal("%s: BN_CTX_new", "jpake_step1");
  }
#line 359
  tmp = xmalloc(16U);
#line 359
  *id = (u_char *)tmp;
#line 360
  *id_len = 16U;
#line 361
  arc4random_buf((void *)*id, *id_len);
#line 369
  *priv1 = bn_rand_range_gt_one((BIGNUM const   *)grp->q);
#line 369
  if ((unsigned int )*priv1 == (unsigned int )((void *)0)) {
#line 371
    fatal("%s: bn_rand_range_gt_one", "jpake_step1");
  } else {
#line 369
    *priv2 = bn_rand_range_gt_one((BIGNUM const   *)grp->q);
#line 369
    if ((unsigned int )*priv2 == (unsigned int )((void *)0)) {
#line 371
      fatal("%s: bn_rand_range_gt_one", "jpake_step1");
    }
  }
#line 377
  *g_priv1 = BN_new();
#line 377
  if ((unsigned int )*g_priv1 == (unsigned int )((void *)0)) {
#line 379
    fatal("%s: BN_new", "jpake_step1");
  } else {
#line 377
    *g_priv2 = BN_new();
#line 377
    if ((unsigned int )*g_priv2 == (unsigned int )((void *)0)) {
#line 379
      fatal("%s: BN_new", "jpake_step1");
    }
  }
#line 380
  tmp___0 = BN_mod_exp(*g_priv1, (BIGNUM const   *)grp->g, (BIGNUM const   *)*priv1,
                       (BIGNUM const   *)grp->p, bn_ctx);
#line 380
  if (tmp___0 == -1) {
#line 381
    fatal("%s: BN_mod_exp", "jpake_step1");
  }
#line 382
  tmp___1 = BN_mod_exp(*g_priv2, (BIGNUM const   *)grp->g, (BIGNUM const   *)*priv2,
                       (BIGNUM const   *)grp->p, bn_ctx);
#line 382
  if (tmp___1 == -1) {
#line 383
    fatal("%s: BN_mod_exp", "jpake_step1");
  }
#line 386
  tmp___2 = schnorr_sign((BIGNUM const   *)grp->p, (BIGNUM const   *)grp->q, (BIGNUM const   *)grp->g,
                         (BIGNUM const   *)*priv1, (BIGNUM const   *)*g_priv1, (u_char const   *)*id,
                         *id_len, priv1_proof, priv1_proof_len);
#line 386
  if (tmp___2 != 0) {
#line 389
    fatal("%s: schnorr_sign", "jpake_step1");
  }
#line 390
  tmp___3 = schnorr_sign((BIGNUM const   *)grp->p, (BIGNUM const   *)grp->q, (BIGNUM const   *)grp->g,
                         (BIGNUM const   *)*priv2, (BIGNUM const   *)*g_priv2, (u_char const   *)*id,
                         *id_len, priv2_proof, priv2_proof_len);
#line 390
  if (tmp___3 != 0) {
#line 393
    fatal("%s: schnorr_sign", "jpake_step1");
  }
#line 395
  BN_CTX_free(bn_ctx);
#line 396
  return;
}
}
#line 399 "jpake.c"
void jpake_step2(struct jpake_group *grp , BIGNUM *s , BIGNUM *mypub1 , BIGNUM *theirpub1 ,
                 BIGNUM *theirpub2 , BIGNUM *mypriv2 , u_char const   *theirid , u_int theirid_len ,
                 u_char const   *myid , u_int myid_len , u_char const   *theirpub1_proof ,
                 u_int theirpub1_proof_len , u_char const   *theirpub2_proof , u_int theirpub2_proof_len ,
                 BIGNUM **newpub , u_char **newpub_exponent_proof , u_int *newpub_exponent_proof_len ) 
{ BN_CTX *bn_ctx ;
  BIGNUM *tmp ;
  BIGNUM *exponent ;
  BIGNUM const   *tmp___0 ;
  int tmp___1 ;
  BIGNUM const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 413
  tmp___0 = BN_value_one();
#line 413
  tmp___1 = BN_cmp((BIGNUM const   *)theirpub1, tmp___0);
#line 413
  if (tmp___1 <= 0) {
#line 414
    fatal("%s: theirpub1 <= 1", "jpake_step2");
  }
#line 415
  tmp___2 = BN_value_one();
#line 415
  tmp___3 = BN_cmp((BIGNUM const   *)theirpub2, tmp___2);
#line 415
  if (tmp___3 <= 0) {
#line 416
    fatal("%s: theirpub2 <= 1", "jpake_step2");
  }
#line 418
  tmp___4 = schnorr_verify((BIGNUM const   *)grp->p, (BIGNUM const   *)grp->q, (BIGNUM const   *)grp->g,
                           (BIGNUM const   *)theirpub1, theirid, theirid_len, theirpub1_proof,
                           theirpub1_proof_len);
#line 418
  if (tmp___4 != 1) {
#line 420
    fatal("%s: schnorr_verify theirpub1 failed", "jpake_step2");
  }
#line 421
  tmp___5 = schnorr_verify((BIGNUM const   *)grp->p, (BIGNUM const   *)grp->q, (BIGNUM const   *)grp->g,
                           (BIGNUM const   *)theirpub2, theirid, theirid_len, theirpub2_proof,
                           theirpub2_proof_len);
#line 421
  if (tmp___5 != 1) {
#line 423
    fatal("%s: schnorr_verify theirpub2 failed", "jpake_step2");
  }
#line 425
  bn_ctx = BN_CTX_new();
#line 425
  if ((unsigned int )bn_ctx == (unsigned int )((void *)0)) {
#line 426
    fatal("%s: BN_CTX_new", "jpake_step2");
  }
#line 428
  *newpub = BN_new();
#line 428
  if ((unsigned int )*newpub == (unsigned int )((void *)0)) {
#line 431
    fatal("%s: BN_new", "jpake_step2");
  } else {
#line 428
    tmp = BN_new();
#line 428
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 431
      fatal("%s: BN_new", "jpake_step2");
    } else {
#line 428
      exponent = BN_new();
#line 428
      if ((unsigned int )exponent == (unsigned int )((void *)0)) {
#line 431
        fatal("%s: BN_new", "jpake_step2");
      }
    }
  }
#line 437
  tmp___6 = BN_mod_mul(exponent, (BIGNUM const   *)mypriv2, (BIGNUM const   *)s, (BIGNUM const   *)grp->q,
                       bn_ctx);
#line 437
  if (tmp___6 != 1) {
#line 438
    fatal("%s: BN_mod_mul (exponent = mypriv2 * s mod p)", "jpake_step2");
  }
#line 445
  tmp___7 = BN_mod_mul(tmp, (BIGNUM const   *)mypub1, (BIGNUM const   *)theirpub1,
                       (BIGNUM const   *)grp->p, bn_ctx);
#line 445
  if (tmp___7 != 1) {
#line 446
    fatal("%s: BN_mod_mul (tmp = mypub1 * theirpub1 mod p)", "jpake_step2");
  }
#line 448
  tmp___8 = BN_mod_mul(tmp, (BIGNUM const   *)tmp, (BIGNUM const   *)theirpub2, (BIGNUM const   *)grp->p,
                       bn_ctx);
#line 448
  if (tmp___8 != 1) {
#line 449
    fatal("%s: BN_mod_mul (tmp = tmp * theirpub2 mod p)", "jpake_step2");
  }
#line 455
  tmp___9 = BN_mod_exp(*newpub, (BIGNUM const   *)tmp, (BIGNUM const   *)exponent,
                       (BIGNUM const   *)grp->p, bn_ctx);
#line 455
  if (tmp___9 != 1) {
#line 456
    fatal("%s: BN_mod_mul (newpub = tmp^exponent mod p)", "jpake_step2");
  }
#line 462
  tmp___10 = schnorr_sign((BIGNUM const   *)grp->p, (BIGNUM const   *)grp->q, (BIGNUM const   *)tmp,
                          (BIGNUM const   *)exponent, (BIGNUM const   *)*newpub, myid,
                          myid_len, newpub_exponent_proof, newpub_exponent_proof_len);
#line 462
  if (tmp___10 != 0) {
#line 465
    fatal("%s: schnorr_sign newpub", "jpake_step2");
  }
#line 467
  BN_clear_free(tmp);
#line 468
  BN_clear_free(exponent);
#line 470
  BN_CTX_free(bn_ctx);
#line 471
  return;
}
}
#line 474 "jpake.c"
void jpake_confirm_hash(BIGNUM const   *k , u_char const   *endpoint_id , u_int endpoint_id_len ,
                        u_char const   *sess_id , u_int sess_id_len , u_char **confirm_hash ,
                        u_int *confirm_hash_len ) 
{ Buffer b ;
  EVP_MD const   *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 487
  buffer_init(& b);
#line 488
  buffer_put_bignum2(& b, k);
#line 489
  buffer_put_string(& b, (void const   *)endpoint_id, endpoint_id_len);
#line 490
  buffer_put_string(& b, (void const   *)sess_id, sess_id_len);
#line 491
  tmp = EVP_sha256();
#line 491
  tmp___0 = buffer_len(& b);
#line 491
  tmp___1 = buffer_ptr(& b);
#line 491
  tmp___2 = hash_buffer((u_char const   *)tmp___1, tmp___0, tmp, confirm_hash, confirm_hash_len);
#line 491
  if (tmp___2 != 0) {
#line 493
    fatal("%s: hash_buffer", "jpake_confirm_hash");
  }
#line 494
  buffer_free(& b);
#line 495
  return;
}
}
#line 498 "jpake.c"
void jpake_key_confirm(struct jpake_group *grp , BIGNUM *s , BIGNUM *step2_val , BIGNUM *mypriv2 ,
                       BIGNUM *mypub1 , BIGNUM *mypub2 , BIGNUM *theirpub1 , BIGNUM *theirpub2 ,
                       u_char const   *my_id , u_int my_id_len , u_char const   *their_id ,
                       u_int their_id_len , u_char const   *sess_id , u_int sess_id_len ,
                       u_char const   *theirpriv2_s_proof , u_int theirpriv2_s_proof_len ,
                       BIGNUM **k , u_char **confirm_hash , u_int *confirm_hash_len ) 
{ BN_CTX *bn_ctx ;
  BIGNUM *tmp ;
  BIGNUM const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 512
  bn_ctx = BN_CTX_new();
#line 512
  if ((unsigned int )bn_ctx == (unsigned int )((void *)0)) {
#line 513
    fatal("%s: BN_CTX_new", "jpake_key_confirm");
  }
#line 514
  tmp = BN_new();
#line 514
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 516
    fatal("%s: BN_new", "jpake_key_confirm");
  } else {
#line 514
    *k = BN_new();
#line 514
    if ((unsigned int )*k == (unsigned int )((void *)0)) {
#line 516
      fatal("%s: BN_new", "jpake_key_confirm");
    }
  }
#line 519
  tmp___0 = BN_value_one();
#line 519
  tmp___1 = BN_cmp((BIGNUM const   *)step2_val, tmp___0);
#line 519
  if (tmp___1 <= 0) {
#line 520
    fatal("%s: step2_val <= 1", "jpake_key_confirm");
  }
#line 527
  tmp___2 = BN_mod_mul(tmp, (BIGNUM const   *)mypub1, (BIGNUM const   *)mypub2, (BIGNUM const   *)grp->p,
                       bn_ctx);
#line 527
  if (tmp___2 != 1) {
#line 528
    fatal("%s: BN_mod_mul (tmp = mypub1 * mypub2 mod p)", "jpake_key_confirm");
  }
#line 529
  tmp___3 = BN_mod_mul(tmp, (BIGNUM const   *)tmp, (BIGNUM const   *)theirpub1, (BIGNUM const   *)grp->p,
                       bn_ctx);
#line 529
  if (tmp___3 != 1) {
#line 530
    fatal("%s: BN_mod_mul (tmp = tmp * theirpub1 mod p)", "jpake_key_confirm");
  }
#line 534
  tmp___4 = schnorr_verify((BIGNUM const   *)grp->p, (BIGNUM const   *)grp->q, (BIGNUM const   *)tmp,
                           (BIGNUM const   *)step2_val, their_id, their_id_len, theirpriv2_s_proof,
                           theirpriv2_s_proof_len);
#line 534
  if (tmp___4 != 1) {
#line 537
    fatal("%s: schnorr_verify theirpriv2_s_proof failed", "jpake_key_confirm");
  }
#line 548
  tmp___5 = BN_mul(tmp, (BIGNUM const   *)mypriv2, (BIGNUM const   *)s, bn_ctx);
#line 548
  if (tmp___5 != 1) {
#line 549
    fatal("%s: BN_mul (tmp = mypriv2 * s)", "jpake_key_confirm");
  }
#line 550
  tmp___6 = BN_mod_sub(tmp, (BIGNUM const   *)grp->q, (BIGNUM const   *)tmp, (BIGNUM const   *)grp->q,
                       bn_ctx);
#line 550
  if (tmp___6 != 1) {
#line 551
    fatal("%s: BN_mod_sub (tmp = q - tmp mod q)", "jpake_key_confirm");
  }
#line 552
  tmp___7 = BN_mod_exp(tmp, (BIGNUM const   *)theirpub2, (BIGNUM const   *)tmp, (BIGNUM const   *)grp->p,
                       bn_ctx);
#line 552
  if (tmp___7 != 1) {
#line 553
    fatal("%s: BN_mod_exp (tmp = theirpub2^tmp) mod p", "jpake_key_confirm");
  }
#line 554
  tmp___8 = BN_mod_mul(tmp, (BIGNUM const   *)tmp, (BIGNUM const   *)step2_val, (BIGNUM const   *)grp->p,
                       bn_ctx);
#line 554
  if (tmp___8 != 1) {
#line 555
    fatal("%s: BN_mod_mul (tmp = tmp * step2_val) mod p", "jpake_key_confirm");
  }
#line 556
  tmp___9 = BN_mod_exp(*k, (BIGNUM const   *)tmp, (BIGNUM const   *)mypriv2, (BIGNUM const   *)grp->p,
                       bn_ctx);
#line 556
  if (tmp___9 != 1) {
#line 557
    fatal("%s: BN_mod_exp (k = tmp^mypriv2) mod p", "jpake_key_confirm");
  }
#line 559
  BN_CTX_free(bn_ctx);
#line 560
  BN_clear_free(tmp);
#line 562
  jpake_confirm_hash((BIGNUM const   *)*k, my_id, my_id_len, sess_id, sess_id_len,
                     confirm_hash, confirm_hash_len);
#line 564
  return;
}
}
#line 570 "jpake.c"
int jpake_check_confirm(BIGNUM const   *k , u_char const   *peer_id , u_int peer_id_len ,
                        u_char const   *sess_id , u_int sess_id_len , u_char const   *peer_confirm_hash ,
                        u_int peer_confirm_hash_len ) 
{ u_char *expected_confirm_hash ;
  u_int expected_confirm_hash_len ;
  int success ;
  int tmp ;

  {
#line 578
  success = 0;
#line 581
  jpake_confirm_hash(k, peer_id, peer_id_len, sess_id, sess_id_len, & expected_confirm_hash,
                     & expected_confirm_hash_len);
#line 589
  if (peer_confirm_hash_len != expected_confirm_hash_len) {
#line 590
    error("%s: confirmation length mismatch (my %u them %u)", "jpake_check_confirm",
          expected_confirm_hash_len, peer_confirm_hash_len);
  } else {
#line 592
    tmp = memcmp((void const   *)peer_confirm_hash, (void const   *)expected_confirm_hash,
                 expected_confirm_hash_len);
#line 592
    if (tmp == 0) {
#line 594
      success = 1;
    }
  }
#line 595
  bzero((void *)expected_confirm_hash, expected_confirm_hash_len);
#line 596
  xfree((void *)expected_confirm_hash);
#line 597
  debug3("%s: success = %d", "jpake_check_confirm", success);
#line 598
  return (success);
}
}
#line 1 "schnorr.o"
#pragma merger(0,"./schnorr.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 64 "schnorr.c"
static BIGNUM *schnorr_hash(BIGNUM const   *p , BIGNUM const   *q , BIGNUM const   *g ,
                            BIGNUM const   *g_v , BIGNUM const   *g_x , u_char const   *id ,
                            u_int idlen ) 
{ u_char *digest___1 ;
  u_int digest_len ;
  BIGNUM *h___0 ;
  EVP_MD_CTX evp_md_ctx ;
  Buffer b ;
  int success ;
  EVP_MD const   *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  BIGNUM *tmp___3 ;

  {
#line 74
  success = -1;
#line 76
  h___0 = BN_new();
#line 76
  if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
#line 77
    error("%s: BN_new", "schnorr_hash");
#line 78
    return ((BIGNUM *)((void *)0));
  }
#line 81
  buffer_init(& b);
#line 82
  EVP_MD_CTX_init(& evp_md_ctx);
#line 85
  buffer_put_bignum2(& b, g);
#line 86
  buffer_put_bignum2(& b, p);
#line 87
  buffer_put_bignum2(& b, q);
#line 88
  buffer_put_bignum2(& b, g_v);
#line 89
  buffer_put_bignum2(& b, g_x);
#line 90
  buffer_put_string(& b, (void const   *)id, idlen);
#line 94
  tmp = EVP_sha256();
#line 94
  tmp___0 = buffer_len(& b);
#line 94
  tmp___1 = buffer_ptr(& b);
#line 94
  tmp___2 = hash_buffer((u_char const   *)tmp___1, tmp___0, tmp, & digest___1, & digest_len);
#line 94
  if (tmp___2 != 0) {
#line 96
    error("%s: hash_buffer", "schnorr_hash");
    goto out;
  }
#line 99
  tmp___3 = BN_bin2bn((unsigned char const   *)digest___1, (int )digest_len, h___0);
#line 99
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 100
    error("%s: BN_bin2bn", "schnorr_hash");
    goto out;
  }
#line 103
  success = 0;
  out: 
#line 106
  buffer_free(& b);
#line 107
  EVP_MD_CTX_cleanup(& evp_md_ctx);
#line 108
  bzero((void *)digest___1, digest_len);
#line 109
  xfree((void *)digest___1);
#line 110
  digest_len = 0U;
#line 111
  if (success == 0) {
#line 112
    return (h___0);
  }
#line 113
  BN_clear_free(h___0);
#line 114
  return ((BIGNUM *)((void *)0));
}
}
#line 125 "schnorr.c"
int schnorr_sign(BIGNUM const   *grp_p , BIGNUM const   *grp_q , BIGNUM const   *grp_g ,
                 BIGNUM const   *x , BIGNUM const   *g_x , u_char const   *id , u_int idlen ,
                 u_char **sig , u_int *siglen ) 
{ int success ;
  Buffer b ;
  BIGNUM *h___0 ;
  BIGNUM *tmp ;
  BIGNUM *v ;
  BIGNUM *g_v ;
  BIGNUM *r ;
  BN_CTX *bn_ctx ;
  BIGNUM const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 130
  success = -1;
#line 139
  tmp___0 = BN_value_one();
#line 139
  tmp___1 = BN_cmp(g_x, tmp___0);
#line 139
  if (tmp___1 <= 0) {
#line 140
    error("%s: g_x < 1", "schnorr_sign");
#line 141
    return (-1);
  }
#line 144
  v = (BIGNUM *)((void *)0);
#line 144
  tmp = v;
#line 144
  r = tmp;
#line 144
  g_v = r;
#line 144
  h___0 = g_v;
#line 145
  bn_ctx = BN_CTX_new();
#line 145
  if ((unsigned int )bn_ctx == (unsigned int )((void *)0)) {
#line 146
    error("%s: BN_CTX_new", "schnorr_sign");
    goto out;
  }
#line 149
  g_v = BN_new();
#line 149
  if ((unsigned int )g_v == (unsigned int )((void *)0)) {
#line 152
    error("%s: BN_new", "schnorr_sign");
    goto out;
  } else {
#line 149
    r = BN_new();
#line 149
    if ((unsigned int )r == (unsigned int )((void *)0)) {
#line 152
      error("%s: BN_new", "schnorr_sign");
      goto out;
    } else {
#line 149
      tmp = BN_new();
#line 149
      if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 152
        error("%s: BN_new", "schnorr_sign");
        goto out;
      }
    }
  }
#line 160
  v = bn_rand_range_gt_one(grp_p);
#line 160
  if ((unsigned int )v == (unsigned int )((void *)0)) {
#line 161
    error("%s: bn_rand_range2", "schnorr_sign");
    goto out;
  }
#line 167
  tmp___2 = BN_mod_exp(g_v, grp_g, (BIGNUM const   *)v, grp_p, bn_ctx);
#line 167
  if (tmp___2 == -1) {
#line 168
    error("%s: BN_mod_exp (g^v mod p)", "schnorr_sign");
    goto out;
  }
#line 174
  h___0 = schnorr_hash(grp_p, grp_q, grp_g, (BIGNUM const   *)g_v, g_x, id, idlen);
#line 174
  if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
#line 176
    error("%s: schnorr_hash failed", "schnorr_sign");
    goto out;
  }
#line 181
  tmp___3 = BN_mod_mul(tmp, x, (BIGNUM const   *)h___0, grp_q, bn_ctx);
#line 181
  if (tmp___3 == -1) {
#line 182
    error("%s: BN_mod_mul (tmp = xv mod q)", "schnorr_sign");
    goto out;
  }
#line 185
  tmp___4 = BN_mod_sub(r, (BIGNUM const   *)v, (BIGNUM const   *)tmp, grp_q, bn_ctx);
#line 185
  if (tmp___4 == -1) {
#line 186
    error("%s: BN_mod_mul (r = v - tmp)", "schnorr_sign");
    goto out;
  }
#line 192
  buffer_init(& b);
#line 194
  buffer_put_bignum2(& b, (BIGNUM const   *)g_v);
#line 195
  buffer_put_bignum2(& b, (BIGNUM const   *)r);
#line 196
  *siglen = buffer_len(& b);
#line 197
  tmp___5 = xmalloc(*siglen);
#line 197
  *sig = (u_char *)tmp___5;
#line 198
  tmp___6 = buffer_ptr(& b);
#line 198
  memcpy((void * __restrict  )*sig, (void const   * __restrict  )tmp___6, *siglen);
#line 201
  buffer_free(& b);
#line 202
  success = 0;
  out: 
#line 204
  BN_CTX_free(bn_ctx);
#line 205
  if ((unsigned int )h___0 != (unsigned int )((void *)0)) {
#line 206
    BN_clear_free(h___0);
  }
#line 207
  if ((unsigned int )v != (unsigned int )((void *)0)) {
#line 208
    BN_clear_free(v);
  }
#line 209
  BN_clear_free(r);
#line 210
  BN_clear_free(g_v);
#line 211
  BN_clear_free(tmp);
#line 213
  return (success);
}
}
#line 222 "schnorr.c"
int schnorr_verify(BIGNUM const   *grp_p , BIGNUM const   *grp_q , BIGNUM const   *grp_g ,
                   BIGNUM const   *g_x , u_char const   *id , u_int idlen , u_char const   *sig ,
                   u_int siglen ) 
{ int success ;
  Buffer b ;
  BIGNUM *g_v ;
  BIGNUM *h___0 ;
  BIGNUM *r ;
  BIGNUM *g_xh ;
  BIGNUM *g_r ;
  BIGNUM *expected ;
  BN_CTX *bn_ctx ;
  u_int rlen ;
  BIGNUM const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 227
  success = -1;
#line 236
  tmp = BN_value_one();
#line 236
  tmp___0 = BN_cmp(g_x, tmp);
#line 236
  if (tmp___0 <= 0) {
#line 237
    error("%s: g_x < 1", "schnorr_verify");
#line 238
    return (-1);
  }
#line 241
  expected = (BIGNUM *)((void *)0);
#line 241
  g_r = expected;
#line 241
  g_xh = g_r;
#line 241
  r = g_xh;
#line 241
  h___0 = r;
#line 241
  g_v = h___0;
#line 242
  bn_ctx = BN_CTX_new();
#line 242
  if ((unsigned int )bn_ctx == (unsigned int )((void *)0)) {
#line 243
    error("%s: BN_CTX_new", "schnorr_verify");
    goto out;
  }
#line 246
  g_v = BN_new();
#line 246
  if ((unsigned int )g_v == (unsigned int )((void *)0)) {
#line 251
    error("%s: BN_new", "schnorr_verify");
    goto out;
  } else {
#line 246
    r = BN_new();
#line 246
    if ((unsigned int )r == (unsigned int )((void *)0)) {
#line 251
      error("%s: BN_new", "schnorr_verify");
      goto out;
    } else {
#line 246
      g_xh = BN_new();
#line 246
      if ((unsigned int )g_xh == (unsigned int )((void *)0)) {
#line 251
        error("%s: BN_new", "schnorr_verify");
        goto out;
      } else {
#line 246
        g_r = BN_new();
#line 246
        if ((unsigned int )g_r == (unsigned int )((void *)0)) {
#line 251
          error("%s: BN_new", "schnorr_verify");
          goto out;
        } else {
#line 246
          expected = BN_new();
#line 246
          if ((unsigned int )expected == (unsigned int )((void *)0)) {
#line 251
            error("%s: BN_new", "schnorr_verify");
            goto out;
          }
        }
      }
    }
  }
#line 256
  buffer_init(& b);
#line 257
  buffer_append(& b, (void const   *)sig, siglen);
#line 260
  buffer_get_bignum2(& b, g_v);
#line 261
  buffer_get_bignum2(& b, r);
#line 262
  rlen = buffer_len(& b);
#line 263
  buffer_free(& b);
#line 264
  if (rlen != 0U) {
#line 265
    error("%s: remaining bytes in signature %d", "schnorr_verify", rlen);
    goto out;
  }
#line 268
  buffer_free(& b);
#line 273
  h___0 = schnorr_hash(grp_p, grp_q, grp_g, (BIGNUM const   *)g_v, g_x, id, idlen);
#line 273
  if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
#line 275
    error("%s: schnorr_hash failed", "schnorr_verify");
    goto out;
  }
#line 280
  tmp___1 = BN_mod_exp(g_xh, g_x, (BIGNUM const   *)h___0, grp_p, bn_ctx);
#line 280
  if (tmp___1 == -1) {
#line 281
    error("%s: BN_mod_exp (g_x^h mod p)", "schnorr_verify");
    goto out;
  }
#line 287
  tmp___2 = BN_mod_exp(g_r, grp_g, (BIGNUM const   *)r, grp_p, bn_ctx);
#line 287
  if (tmp___2 == -1) {
#line 288
    error("%s: BN_mod_exp (g_x^h mod p)", "schnorr_verify");
    goto out;
  }
#line 294
  tmp___3 = BN_mod_mul(expected, (BIGNUM const   *)g_r, (BIGNUM const   *)g_xh, grp_p,
                       bn_ctx);
#line 294
  if (tmp___3 == -1) {
#line 295
    error("%s: BN_mod_mul (expected = g_r mod p)", "schnorr_verify");
    goto out;
  }
#line 301
  tmp___4 = BN_cmp((BIGNUM const   *)expected, (BIGNUM const   *)g_v);
#line 301
  success = tmp___4 == 0;
  out: 
#line 303
  BN_CTX_free(bn_ctx);
#line 304
  if ((unsigned int )h___0 != (unsigned int )((void *)0)) {
#line 305
    BN_clear_free(h___0);
  }
#line 306
  BN_clear_free(g_v);
#line 307
  BN_clear_free(r);
#line 308
  BN_clear_free(g_xh);
#line 309
  BN_clear_free(g_r);
#line 310
  BN_clear_free(expected);
#line 311
  return (success);
}
}
#line 1 "sshd.o"
#pragma merger(0,"./sshd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 682 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 21 "platform.h"
void platform_pre_fork(void) ;
#line 22
void platform_post_fork_parent(pid_t child_pid ) ;
#line 23
void platform_post_fork_child(void) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 457 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 910
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 380 "/usr/include/openssl/crypto.h"
extern char const   *SSLeay_version(int type ) ;
#line 104 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 711 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 156 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 157
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 158
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum , int *activep , char const   *user , char const   *host ,
                               char const   *address ) ;
#line 160
void load_server_config(char const   *filename , Buffer *conf ) ;
#line 161
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ,
                         char const   *user , char const   *host , char const   *address ) ;
#line 163
void parse_server_match_config(ServerOptions *options___0 , char const   *user , char const   *host ,
                               char const   *address ) ;
#line 166
void dump_config(ServerOptions *o ) ;
#line 140 "kex.h"
void kexdh_server(Kex *kex ) ;
#line 142
void kexgex_server(Kex *kex ) ;
#line 58 "myproposal.h"
static char *myproposal[10]  = 
#line 58 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha256,diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,aes192-cbc,aes256-cbc,arcfour,rijndael-cbc@lysator.liu.se",      (char *)"aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,aes192-cbc,aes256-cbc,arcfour,rijndael-cbc@lysator.liu.se", 
        (char *)"hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib@openssh.com,zlib",      (char *)"none,zlib@openssh.com,zlib", 
        (char *)"",      (char *)""};
#line 141 "auth.h"
void do_authentication(Authctxt *authctxt___0 ) ;
#line 142
void do_authentication2(Authctxt *authctxt___0 ) ;
#line 151
void privsep_challenge_enable(void) ;
#line 180
Key *get_hostkey_by_index(int ind ) ;
#line 181
Key *get_hostkey_by_type(int type ) ;
#line 182
int get_hostkey_index(Key *key ) ;
#line 183
int ssh1_session_key(BIGNUM *session_key_int ) ;
#line 65 "session.h"
void do_authenticated(Authctxt *authctxt___0 ) ;
#line 66
void do_cleanup(Authctxt *authctxt___0 ) ;
#line 79
void do_setusercontext(struct passwd *pw___0 ) ;
#line 81 "monitor.h"
struct monitor *monitor_init(void) ;
#line 82
void monitor_reinit(struct monitor *mon ) ;
#line 83
void monitor_sync(struct monitor *pmonitor___0 ) ;
#line 86
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) ;
#line 87
void monitor_child_postauth(struct monitor *pmonitor___0 ) ;
#line 31 "monitor_wrap.h"
int use_privsep ;
#line 80
void mm_terminate(void) ;
#line 85
void mm_ssh1_session_id(u_char *session_id___0 ) ;
#line 86
int mm_ssh1_session_key(BIGNUM *num ) ;
#line 92
void monitor_apply_keystate(struct monitor *pmonitor___0 ) ;
#line 94
void mm_send_keystate(struct monitor *monitor ) ;
#line 142 "sshd.c"
ServerOptions options  ;
#line 145 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 153 "sshd.c"
int debug_flag  =    0;
#line 156 "sshd.c"
int test_flag  =    0;
#line 159 "sshd.c"
int inetd_flag  =    0;
#line 162 "sshd.c"
int no_daemon_flag  =    0;
#line 165 "sshd.c"
int log_stderr  =    0;
#line 168 "sshd.c"
char **saved_argv  ;
#line 169 "sshd.c"
int saved_argc  ;
#line 172 "sshd.c"
int rexeced_flag  =    0;
#line 173 "sshd.c"
int rexec_flag  =    1;
#line 174 "sshd.c"
int rexec_argc  =    0;
#line 175 "sshd.c"
char **rexec_argv  ;
#line 182 "sshd.c"
int listen_socks[16]  ;
#line 183 "sshd.c"
int num_listen_socks  =    0;
#line 189 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 190 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 193 "sshd.c"
Kex *xxx_kex  ;
#line 203 "sshd.c"
struct __anonstruct_sensitive_data_84 sensitive_data  ;
#line 216 "sshd.c"
static int volatile   key_do_regen  =    (sig_atomic_t volatile   )0;
#line 219 "sshd.c"
static int volatile   received_sighup  =    (sig_atomic_t volatile   )0;
#line 220 "sshd.c"
static int volatile   received_sigterm  =    (sig_atomic_t volatile   )0;
#line 223 "sshd.c"
u_char session_id[16]  ;
#line 226 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 227 "sshd.c"
u_int session_id2_len  =    (u_int )0;
#line 230 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 233 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 234 "sshd.c"
int startup_pipe  ;
#line 237 "sshd.c"
int use_privsep  =    -1;
#line 238 "sshd.c"
struct monitor *pmonitor  =    (struct monitor *)((void *)0);
#line 241 "sshd.c"
Authctxt *the_authctxt  =    (Authctxt *)((void *)0);
#line 244 "sshd.c"
Buffer cfg  ;
#line 247 "sshd.c"
Buffer loginmsg  ;
#line 250 "sshd.c"
struct passwd *privsep_pw  =    (struct passwd *)((void *)0);
#line 253
void destroy_sensitive_data(void) ;
#line 254
void demote_sensitive_data(void) ;
#line 256
static void do_ssh1_kex(void) ;
#line 257
static void do_ssh2_kex(void) ;
#line 262 "sshd.c"
static void close_listen_socks(void) 
{ int i ;

  {
#line 267
  i = 0;
#line 267
  while (i < num_listen_socks) {
#line 268
    close(listen_socks[i]);
#line 267
    i ++;
  }
#line 269
  num_listen_socks = -1;
#line 270
  return;
}
}
#line 272 "sshd.c"
static void close_startup_pipes(void) 
{ int i ;

  {
#line 277
  if (startup_pipes) {
#line 278
    i = 0;
#line 278
    while (i < options.max_startups) {
#line 279
      if (*(startup_pipes + i) != -1) {
#line 280
        close(*(startup_pipes + i));
      }
#line 278
      i ++;
    }
  }
#line 281
  return;
}
}
#line 290 "sshd.c"
static void sighup_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 293
  tmp = __errno_location();
#line 293
  save_errno = *tmp;
#line 295
  received_sighup = (int volatile   )1;
#line 296
  mysignal(1, & sighup_handler);
#line 297
  tmp___0 = __errno_location();
#line 297
  *tmp___0 = save_errno;
#line 298
  return;
}
}
#line 304 "sshd.c"
static void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 307
  logit("Received SIGHUP; restarting.");
#line 308
  close_listen_socks();
#line 309
  close_startup_pipes();
#line 310
  alarm(0U);
#line 311
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 312
  tmp = __errno_location();
#line 312
  tmp___0 = strerror(*tmp);
#line 312
  logit("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 314
  exit(1);
}
}
#line 321 "sshd.c"
static void sigterm_handler(int sig ) 
{ 

  {
#line 324
  received_sigterm = (int volatile   )sig;
#line 325
  return;
}
}
#line 332 "sshd.c"
static void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t pid ;
  int status ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 335
  tmp = __errno_location();
#line 335
  save_errno = *tmp;
#line 339
  while (1) {
#line 339
    pid = waitpid(-1, & status, 1);
#line 339
    if (! (pid > 0)) {
#line 339
      if (pid < 0) {
#line 339
        tmp___0 = __errno_location();
#line 339
        if (! (*tmp___0 == 4)) {
#line 339
          break;
        }
      } else {
#line 339
        break;
      }
    }
  }
#line 343
  mysignal(17, & main_sigchld_handler);
#line 344
  tmp___1 = __errno_location();
#line 344
  *tmp___1 = save_errno;
#line 345
  return;
}
}
#line 351 "sshd.c"
static void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 354
  if (use_privsep) {
#line 354
    if ((unsigned int )pmonitor != (unsigned int )((void *)0)) {
#line 354
      if (pmonitor->m_pid > 0) {
#line 355
        kill(pmonitor->m_pid, 14);
      }
    }
  }
#line 358
  tmp = get_remote_ipaddr();
#line 358
  sigdie("Timeout before authentication for %s", tmp);
}
}
#line 368 "sshd.c"
static void generate_ephemeral_server_key(void) 
{ char const   *tmp ;

  {
#line 371
  if (sensitive_data.server_key) {
#line 371
    tmp = "new ";
  } else {
#line 371
    tmp = "";
  }
#line 371
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 373
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 374
    key_free(sensitive_data.server_key);
  }
#line 375
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 377
  verbose("RSA key generation complete.");
#line 379
  arc4random_buf((void *)(sensitive_data.ssh1_cookie), 32U);
#line 380
  arc4random_stir();
#line 381
  return;
}
}
#line 384 "sshd.c"
static void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 387
  tmp = __errno_location();
#line 387
  save_errno = *tmp;
#line 389
  mysignal(14, (void (*)(int  ))0);
#line 390
  tmp___0 = __errno_location();
#line 390
  *tmp___0 = save_errno;
#line 391
  key_do_regen = (int volatile   )1;
#line 392
  return;
}
}
#line 394 "sshd.c"
static void sshd_exchange_identification(int sock_in , int sock_out ) 
{ u_int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char *newline ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  size_t tmp___36 ;
  char const   *tmp___37 ;

  {
#line 401
  newline = (char *)"\n";
#line 405
  if (options.protocol & 1) {
#line 405
    if (options.protocol & 4) {
#line 407
      major = 1;
#line 408
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 409
    if (options.protocol & 4) {
#line 410
      major = 2;
#line 411
      minor = 0;
#line 412
      newline = (char *)"\r\n";
    } else {
#line 414
      major = 1;
#line 415
      minor = 5;
    }
  }
#line 417
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s%s",
           major, minor, "OpenSSH_5.2", newline);
#line 419
  server_version_string = xstrdup((char const   *)(buf___1));
#line 422
  tmp___0 = strlen((char const   *)server_version_string);
#line 422
  tmp___1 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)server_version_string,
                     tmp___0);
#line 422
  tmp___2 = strlen((char const   *)server_version_string);
#line 422
  if (tmp___1 != tmp___2) {
#line 425
    tmp = get_remote_ipaddr();
#line 425
    logit("Could not write ident string to %s", tmp);
#line 426
    cleanup_exit(255);
  }
#line 430
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 431
  i = 0U;
#line 431
  while (i < sizeof(buf___1) - 1U) {
#line 432
    tmp___4 = atomicio(& read, sock_in, (void *)(& buf___1[i]), 1U);
#line 432
    if (tmp___4 != 1U) {
#line 433
      tmp___3 = get_remote_ipaddr();
#line 433
      logit("Did not receive identification string from %s", tmp___3);
#line 435
      cleanup_exit(255);
    }
#line 437
    if ((int )buf___1[i] == 13) {
#line 438
      buf___1[i] = (char)0;
#line 441
      if (i == 12U) {
#line 441
        if (0) {
#line 441
          if (0) {
#line 441
            __s1_len___0 = strlen((char const   *)(buf___1));
#line 441
            __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 441
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
              goto _L___3;
            } else {
#line 441
              if (__s1_len___0 >= 4U) {
                _L___3: /* CIL Label */ 
#line 441
                if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 441
                  tmp___28 = 1;
                } else {
#line 441
                  if (__s2_len___0 >= 4U) {
#line 441
                    tmp___28 = 1;
                  } else {
#line 441
                    tmp___28 = 0;
                  }
                }
              } else {
#line 441
                tmp___28 = 0;
              }
            }
#line 441
            if (tmp___28) {
#line 441
              tmp___24 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
            } else {
#line 441
              tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 441
              tmp___24 = tmp___27;
            }
          } else {
#line 441
            tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 441
            tmp___24 = tmp___27;
          }
#line 441
          tmp___18 = tmp___24;
        } else {
#line 441
          tmp___18 = strncmp((char const   *)(buf___1), "SSH-1.5-W1.0", 12U);
        }
#line 441
        if (tmp___18 == 0) {
#line 442
          break;
        }
      }
      goto __Cont;
    }
#line 445
    if ((int )buf___1[i] == 10) {
#line 446
      buf___1[i] = (char)0;
#line 447
      break;
    }
    __Cont: /* CIL Label */ 
#line 431
    i ++;
  }
#line 450
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 451
  client_version_string = xstrdup((char const   *)(buf___1));
#line 457
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 457
  if (tmp___33 != 3) {
#line 459
    s = (char *)"Protocol mismatch.\n";
#line 460
    tmp___31 = strlen((char const   *)s);
#line 460
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___31);
#line 461
    close(sock_in);
#line 462
    close(sock_out);
#line 463
    tmp___32 = get_remote_ipaddr();
#line 463
    logit("Bad protocol version identification \'%.100s\' from %s", client_version_string,
          tmp___32);
#line 465
    cleanup_exit(255);
  }
#line 467
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 470
  compat_datafellows((char const   *)(remote_version));
#line 472
  if (datafellows & 4194304) {
#line 473
    tmp___34 = get_remote_ipaddr();
#line 473
    logit("probed from %s with %s.  Don\'t panic.", tmp___34, client_version_string);
#line 475
    cleanup_exit(255);
  }
#line 478
  if (datafellows & 2048) {
#line 479
    tmp___35 = get_remote_ipaddr();
#line 479
    logit("scanned from %s with %s.  Don\'t panic.", tmp___35, client_version_string);
#line 481
    cleanup_exit(255);
  }
#line 484
  mismatch = 0;
#line 485
  switch (remote_major) {
  case 1: 
#line 487
  if (remote_minor == 99) {
#line 488
    if (options.protocol & 4) {
#line 489
      enable_compat20();
    } else {
#line 491
      mismatch = 1;
    }
#line 492
    break;
  }
#line 494
  if (! (options.protocol & 1)) {
#line 495
    mismatch = 1;
#line 496
    break;
  }
#line 498
  if (remote_minor < 3) {
#line 499
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 501
    if (remote_minor == 3) {
#line 503
      enable_compat13();
    }
  }
#line 505
  break;
  case 2: 
#line 507
  if (options.protocol & 4) {
#line 508
    enable_compat20();
#line 509
    break;
  }
  default: 
#line 513
  mismatch = 1;
#line 514
  break;
  }
#line 516
  chop(server_version_string);
#line 517
  debug("Local version string %.200s", server_version_string);
#line 519
  if (mismatch) {
#line 520
    s = (char *)"Protocol major versions differ.\n";
#line 521
    tmp___36 = strlen((char const   *)s);
#line 521
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___36);
#line 522
    close(sock_in);
#line 523
    close(sock_out);
#line 524
    tmp___37 = get_remote_ipaddr();
#line 524
    logit("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___37, server_version_string,
          client_version_string);
#line 527
    cleanup_exit(255);
  }
#line 529
  return;
}
}
#line 532 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 537
  if (sensitive_data.server_key) {
#line 538
    key_free(sensitive_data.server_key);
#line 539
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 541
  i = 0;
#line 541
  while (i < options.num_host_key_files) {
#line 542
    if (*(sensitive_data.host_keys + i)) {
#line 543
      key_free(*(sensitive_data.host_keys + i));
#line 544
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 541
    i ++;
  }
#line 547
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 548
  memset((void *)(sensitive_data.ssh1_cookie), 0, 32U);
#line 549
  return;
}
}
#line 552 "sshd.c"
void demote_sensitive_data(void) 
{ Key *tmp ;
  int i ;

  {
#line 558
  if (sensitive_data.server_key) {
#line 559
    tmp = key_demote((Key const   *)sensitive_data.server_key);
#line 560
    key_free(sensitive_data.server_key);
#line 561
    sensitive_data.server_key = tmp;
  }
#line 564
  i = 0;
#line 564
  while (i < options.num_host_key_files) {
#line 565
    if (*(sensitive_data.host_keys + i)) {
#line 566
      tmp = key_demote((Key const   *)*(sensitive_data.host_keys + i));
#line 567
      key_free(*(sensitive_data.host_keys + i));
#line 568
      *(sensitive_data.host_keys + i) = tmp;
#line 569
      if (tmp->type == 0) {
#line 570
        sensitive_data.ssh1_host_key = tmp;
      }
    }
#line 564
    i ++;
  }
#line 575
  return;
}
}
#line 577 "sshd.c"
static void privsep_preauth_child(void) 
{ u_int32_t rnd[256] ;
  gid_t gidset[1] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 584
  privsep_challenge_enable();
#line 586
  arc4random_stir();
#line 587
  arc4random_buf((void *)(rnd), sizeof(rnd));
#line 588
  RAND_seed((void const   *)(rnd), (int )sizeof(rnd));
#line 591
  demote_sensitive_data();
#line 594
  tmp___1 = chroot("/var/empty");
#line 594
  if (tmp___1 == -1) {
#line 595
    tmp = __errno_location();
#line 595
    tmp___0 = strerror(*tmp);
#line 595
    fatal("chroot(\"%s\"): %s", "/var/empty", tmp___0);
  }
#line 597
  tmp___4 = chdir("/");
#line 597
  if (tmp___4 == -1) {
#line 598
    tmp___2 = __errno_location();
#line 598
    tmp___3 = strerror(*tmp___2);
#line 598
    fatal("chdir(\"/\"): %s", tmp___3);
  }
#line 601
  debug3("privsep user:group %u:%u", privsep_pw->pw_uid, privsep_pw->pw_gid);
#line 607
  gidset[0] = privsep_pw->pw_gid;
#line 608
  tmp___7 = setgroups(1U, (__gid_t const   *)(gidset));
#line 608
  if (tmp___7 < 0) {
#line 609
    tmp___5 = __errno_location();
#line 609
    tmp___6 = strerror(*tmp___5);
#line 609
    fatal("setgroups: %.100s", tmp___6);
  }
#line 610
  permanently_set_uid(privsep_pw);
#line 612
  return;
}
}
#line 614 "sshd.c"
static int privsep_preauth(Authctxt *authctxt___0 ) 
{ int status ;
  pid_t pid ;
  int *tmp ;
  __pid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;

  {
#line 621
  pmonitor = monitor_init();
#line 623
  pmonitor->m_pkex = & xxx_kex;
#line 625
  pid = fork();
#line 626
  if (pid == -1) {
#line 627
    fatal("fork of unprivileged child failed");
  } else {
#line 628
    if (pid != 0) {
#line 629
      debug2("Network child is on pid %ld", (long )pid);
#line 631
      close(pmonitor->m_recvfd);
#line 632
      pmonitor->m_pid = pid;
#line 633
      monitor_child_preauth(authctxt___0, pmonitor);
#line 634
      close(pmonitor->m_sendfd);
#line 637
      monitor_sync(pmonitor);
#line 640
      while (1) {
#line 640
        tmp___0 = waitpid(pid, & status, 0);
#line 640
        if (! (tmp___0 < 0)) {
#line 640
          break;
        }
#line 641
        tmp = __errno_location();
#line 641
        if (*tmp != 4) {
#line 642
          break;
        }
      }
#line 643
      return (1);
    } else {
#line 647
      close(pmonitor->m_sendfd);
#line 650
      tmp___1 = getuid();
#line 650
      if (tmp___1 == 0U) {
#line 651
        privsep_preauth_child();
      } else {
#line 650
        tmp___2 = geteuid();
#line 650
        if (tmp___2 == 0U) {
#line 651
          privsep_preauth_child();
        }
      }
#line 652
      setproctitle("%s", "[net]");
    }
  }
#line 654
  return (0);
}
}
#line 657 "sshd.c"
static void privsep_postauth(Authctxt *authctxt___0 ) 
{ u_int32_t rnd[256] ;

  {
#line 665
  if ((authctxt___0->pw)->pw_uid == 0U) {
#line 668
    use_privsep = 0;
    goto skip;
  } else {
#line 665
    if (options.use_login) {
#line 668
      use_privsep = 0;
      goto skip;
    }
  }
#line 673
  monitor_reinit(pmonitor);
#line 675
  pmonitor->m_pid = fork();
#line 676
  if (pmonitor->m_pid == -1) {
#line 677
    fatal("fork of unprivileged child failed");
  } else {
#line 678
    if (pmonitor->m_pid != 0) {
#line 679
      verbose("User child is on pid %ld", (long )pmonitor->m_pid);
#line 680
      close(pmonitor->m_recvfd);
#line 681
      buffer_clear(& loginmsg);
#line 682
      monitor_child_postauth(pmonitor);
#line 685
      exit(0);
    }
  }
#line 688
  close(pmonitor->m_sendfd);
#line 691
  demote_sensitive_data();
#line 693
  arc4random_stir();
#line 694
  arc4random_buf((void *)(rnd), sizeof(rnd));
#line 695
  RAND_seed((void const   *)(rnd), (int )sizeof(rnd));
#line 698
  do_setusercontext(authctxt___0->pw);
  skip: 
#line 702
  monitor_apply_keystate(pmonitor);
#line 708
  packet_set_authenticated();
#line 709
  return;
}
}
#line 711 "sshd.c"
static char *list_hostkey_types(void) 
{ Buffer b ;
  char const   *p ;
  char *ret___0 ;
  int i ;
  Key *key ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 719
  buffer_init(& b);
#line 720
  i = 0;
#line 720
  while (i < options.num_host_key_files) {
#line 721
    key = *(sensitive_data.host_keys + i);
#line 722
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 724
    switch (key->type) {
    case 1: 
    case 2: 
#line 727
    tmp = buffer_len(& b);
#line 727
    if (tmp > 0U) {
#line 728
      buffer_append(& b, (void const   *)",", 1U);
    }
#line 729
    p = key_ssh_name((Key const   *)key);
#line 730
    tmp___0 = strlen(p);
#line 730
    buffer_append(& b, (void const   *)p, tmp___0);
#line 731
    break;
    }
    __Cont: /* CIL Label */ 
#line 720
    i ++;
  }
#line 734
  buffer_append(& b, (void const   *)"\000", 1U);
#line 735
  tmp___1 = buffer_ptr(& b);
#line 735
  ret___0 = xstrdup((char const   *)tmp___1);
#line 736
  buffer_free(& b);
#line 737
  debug("list_hostkey_types: %s", ret___0);
#line 738
  return (ret___0);
}
}
#line 741 "sshd.c"
Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 746
  i = 0;
#line 746
  while (i < options.num_host_key_files) {
#line 747
    key = *(sensitive_data.host_keys + i);
#line 748
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 748
      if (key->type == type) {
#line 749
        return (key);
      }
    }
#line 746
    i ++;
  }
#line 751
  return ((Key *)((void *)0));
}
}
#line 754 "sshd.c"
Key *get_hostkey_by_index(int ind ) 
{ 

  {
#line 757
  if (ind < 0) {
#line 758
    return ((Key *)((void *)0));
  } else {
#line 757
    if (ind >= options.num_host_key_files) {
#line 758
      return ((Key *)((void *)0));
    }
  }
#line 759
  return (*(sensitive_data.host_keys + ind));
}
}
#line 762 "sshd.c"
int get_hostkey_index(Key *key ) 
{ int i ;

  {
#line 767
  i = 0;
#line 767
  while (i < options.num_host_key_files) {
#line 768
    if ((unsigned int )key == (unsigned int )*(sensitive_data.host_keys + i)) {
#line 769
      return (i);
    }
#line 767
    i ++;
  }
#line 771
  return (-1);
}
}
#line 780 "sshd.c"
static int drop_connection(int startups ) 
{ int p ;
  int r ;
  u_int32_t tmp ;
  int tmp___0 ;

  {
#line 785
  if (startups < options.max_startups_begin) {
#line 786
    return (0);
  }
#line 787
  if (startups >= options.max_startups) {
#line 788
    return (1);
  }
#line 789
  if (options.max_startups_rate == 100) {
#line 790
    return (1);
  }
#line 792
  p = 100 - options.max_startups_rate;
#line 793
  p *= startups - options.max_startups_begin;
#line 794
  p /= options.max_startups - options.max_startups_begin;
#line 795
  p += options.max_startups_rate;
#line 796
  tmp = arc4random_uniform(100U);
#line 796
  r = (int )tmp;
#line 798
  debug("drop_connection: p %d, r %d", p, r);
#line 799
  if (r < p) {
#line 799
    tmp___0 = 1;
  } else {
#line 799
    tmp___0 = 0;
  }
#line 799
  return (tmp___0);
}
}
#line 802 "sshd.c"
static void usage(void) 
{ char const   *tmp ;

  {
#line 805
  tmp = SSLeay_version(0);
#line 805
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s, %s\n", "OpenSSH_5.2p1",
          tmp);
#line 807
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: sshd [-46DdeiqTt] [-b bits] [-C connection_spec] [-f config_file]\n            [-g login_grace_time] [-h host_key_file] [-k key_gen_time]\n            [-o option] [-p port] [-u len]\n");
#line 812
  exit(1);
}
}
#line 815 "sshd.c"
static void send_rexec_state(int fd , Buffer *conf ) 
{ Buffer m___0 ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 820
  tmp = buffer_len(conf);
#line 820
  debug3("%s: entering fd = %d config len %d", "send_rexec_state", fd, tmp);
#line 835
  buffer_init(& m___0);
#line 836
  tmp___0 = buffer_ptr(conf);
#line 836
  buffer_put_cstring(& m___0, (char const   *)tmp___0);
#line 838
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 838
    if ((sensitive_data.server_key)->type == 0) {
#line 840
      buffer_put_int(& m___0, 1U);
#line 841
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->e);
#line 842
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 843
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->d);
#line 844
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->iqmp);
#line 845
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->p);
#line 846
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->q);
    } else {
#line 848
      buffer_put_int(& m___0, 0U);
    }
  } else {
#line 848
    buffer_put_int(& m___0, 0U);
  }
#line 854
  tmp___1 = ssh_msg_send(fd, (unsigned char)0, & m___0);
#line 854
  if (tmp___1 == -1) {
#line 855
    fatal("%s: ssh_msg_send failed", "send_rexec_state");
  }
#line 857
  buffer_free(& m___0);
#line 859
  debug3("%s: done", "send_rexec_state");
#line 860
  return;
}
}
#line 862 "sshd.c"
static void recv_rexec_state(int fd , Buffer *conf ) 
{ Buffer m___0 ;
  char *cp ;
  u_int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;

  {
#line 869
  debug3("%s: entering fd = %d", "recv_rexec_state", fd);
#line 871
  buffer_init(& m___0);
#line 873
  tmp = ssh_msg_recv(fd, & m___0);
#line 873
  if (tmp == -1) {
#line 874
    fatal("%s: ssh_msg_recv failed", "recv_rexec_state");
  }
#line 875
  tmp___0 = buffer_get_char(& m___0);
#line 875
  if (tmp___0 != 0) {
#line 876
    fatal("%s: rexec version mismatch", "recv_rexec_state");
  }
#line 878
  tmp___1 = buffer_get_string(& m___0, & len);
#line 878
  cp = (char *)tmp___1;
#line 879
  if ((unsigned int )conf != (unsigned int )((void *)0)) {
#line 880
    buffer_append(conf, (void const   *)cp, len + 1U);
  }
#line 881
  xfree((void *)cp);
#line 883
  tmp___2 = buffer_get_int(& m___0);
#line 883
  if (tmp___2) {
#line 884
    if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 885
      key_free(sensitive_data.server_key);
    }
#line 886
    sensitive_data.server_key = key_new_private(0);
#line 887
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->e);
#line 888
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->n);
#line 889
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->d);
#line 890
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->iqmp);
#line 891
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->p);
#line 892
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->q);
#line 893
    rsa_generate_additional_parameters((sensitive_data.server_key)->rsa);
  }
#line 901
  buffer_free(& m___0);
#line 903
  debug3("%s: done", "recv_rexec_state");
#line 904
  return;
}
}
#line 907 "sshd.c"
static void server_accept_inetd(int *sock_in , int *sock_out ) 
{ int fd ;

  {
#line 912
  startup_pipe = -1;
#line 913
  if (rexeced_flag) {
#line 914
    close(5);
#line 915
    *sock_out = dup(0);
#line 915
    *sock_in = *sock_out;
#line 916
    if (! debug_flag) {
#line 917
      startup_pipe = dup(4);
#line 918
      close(4);
    }
  } else {
#line 921
    *sock_in = dup(0);
#line 922
    *sock_out = dup(1);
  }
#line 929
  fd = open("/dev/null", 2, 0);
#line 929
  if (fd != -1) {
#line 930
    dup2(fd, 0);
#line 931
    dup2(fd, 1);
#line 932
    if (fd > 1) {
#line 933
      close(fd);
    }
  }
#line 935
  debug("inetd sockets after dupping: %d, %d", *sock_in, *sock_out);
#line 936
  return;
}
}
#line 941 "sshd.c"
static void server_listen(void) 
{ int ret___0 ;
  int listen_sock ;
  int on ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 944
  on = 1;
#line 948
  ai = options.listen_addrs;
#line 948
  while (ai) {
#line 949
    if (ai->ai_family != 2) {
#line 949
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 951
    if (num_listen_socks >= 16) {
#line 952
      fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
    }
#line 954
    ret___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 954
    if (ret___0 != 0) {
#line 957
      tmp = ssh_gai_strerror(ret___0);
#line 957
      error("getnameinfo failed: %.100s", tmp);
      goto __Cont;
    }
#line 962
    listen_sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 964
    if (listen_sock < 0) {
#line 966
      tmp___0 = __errno_location();
#line 966
      tmp___1 = strerror(*tmp___0);
#line 966
      verbose("socket: %.100s", tmp___1);
      goto __Cont;
    }
#line 969
    tmp___2 = set_nonblock(listen_sock);
#line 969
    if (tmp___2 == -1) {
#line 970
      close(listen_sock);
      goto __Cont;
    }
#line 977
    tmp___5 = setsockopt(listen_sock, 1, 2, (void const   *)(& on), sizeof(on));
#line 977
    if (tmp___5 == -1) {
#line 979
      tmp___3 = __errno_location();
#line 979
      tmp___4 = strerror(*tmp___3);
#line 979
      error("setsockopt SO_REUSEADDR: %s", tmp___4);
    }
#line 983
    if (ai->ai_family == 10) {
#line 984
      tmp___8 = setsockopt(listen_sock, 41, 26, (void const   *)(& on), sizeof(on));
#line 984
      if (tmp___8 == -1) {
#line 986
        tmp___6 = __errno_location();
#line 986
        tmp___7 = strerror(*tmp___6);
#line 986
        error("setsockopt IPV6_V6ONLY: %s", tmp___7);
      }
    }
#line 991
    debug("Bind to port %s on %s.", strport, ntop);
#line 994
    tmp___11 = bind(listen_sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                    ai->ai_addrlen);
#line 994
    if (tmp___11 < 0) {
#line 995
      tmp___9 = __errno_location();
#line 995
      tmp___10 = strerror(*tmp___9);
#line 995
      error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___10);
#line 997
      close(listen_sock);
      goto __Cont;
    }
#line 1000
    listen_socks[num_listen_socks] = listen_sock;
#line 1001
    num_listen_socks ++;
#line 1004
    tmp___14 = listen(listen_sock, 128);
#line 1004
    if (tmp___14 < 0) {
#line 1005
      tmp___12 = __errno_location();
#line 1005
      tmp___13 = strerror(*tmp___12);
#line 1005
      fatal("listen on [%s]:%s: %.100s", ntop, strport, tmp___13);
    }
#line 1007
    logit("Server listening on %s port %s.", ntop, strport);
    __Cont: /* CIL Label */ 
#line 948
    ai = ai->ai_next;
  }
#line 1009
  freeaddrinfo(options.listen_addrs);
#line 1011
  if (! num_listen_socks) {
#line 1012
    fatal("Cannot bind any address.");
  }
#line 1013
  return;
}
}
#line 1019 "sshd.c"
static void server_accept_loop(int *sock_in , int *sock_out , int *newsock , int *config_s ) 
{ fd_set *fdset ;
  int i ;
  int j ;
  int ret___0 ;
  int maxfd ;
  int key_used ;
  int startups ;
  int startup_p[2] ;
  struct sockaddr_storage from ;
  socklen_t fromlen ;
  pid_t pid ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 1024
  key_used = 0;
#line 1024
  startups = 0;
#line 1025
  startup_p[0] = -1;
#line 1025
  startup_p[1] = -1;
#line 1031
  fdset = (fd_set *)((void *)0);
#line 1032
  maxfd = 0;
#line 1033
  i = 0;
#line 1033
  while (i < num_listen_socks) {
#line 1034
    if (listen_socks[i] > maxfd) {
#line 1035
      maxfd = listen_socks[i];
    }
#line 1033
    i ++;
  }
#line 1037
  tmp = xcalloc((unsigned int )options.max_startups, sizeof(int ));
#line 1037
  startup_pipes = (int *)tmp;
#line 1038
  i = 0;
#line 1038
  while (i < options.max_startups) {
#line 1039
    *(startup_pipes + i) = -1;
#line 1038
    i ++;
  }
#line 1045
  while (1) {
#line 1046
    if (received_sighup) {
#line 1047
      sighup_restart();
    }
#line 1048
    if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 1049
      xfree((void *)fdset);
    }
#line 1050
    tmp___0 = xcalloc(((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask )),
                      sizeof(fd_mask ));
#line 1050
    fdset = (fd_set *)tmp___0;
#line 1053
    i = 0;
#line 1053
    while (i < num_listen_socks) {
#line 1054
      __asm__  volatile   ("btsl %1,%0": "=m" (fdset->fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 1053
      i ++;
    }
#line 1055
    i = 0;
#line 1055
    while (i < options.max_startups) {
#line 1056
      if (*(startup_pipes + i) != -1) {
#line 1057
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 1055
      i ++;
    }
#line 1060
    ret___0 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                     (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1061
    if (ret___0 < 0) {
#line 1061
      tmp___3 = __errno_location();
#line 1061
      if (*tmp___3 != 4) {
#line 1062
        tmp___1 = __errno_location();
#line 1062
        tmp___2 = strerror(*tmp___1);
#line 1062
        error("select: %.100s", tmp___2);
      }
    }
#line 1063
    if (received_sigterm) {
#line 1064
      logit("Received signal %d; terminating.", (int )received_sigterm);
#line 1066
      close_listen_socks();
#line 1067
      unlink((char const   *)options.pid_file);
#line 1068
      exit(255);
    }
#line 1070
    if (key_used) {
#line 1070
      if (key_do_regen) {
#line 1071
        generate_ephemeral_server_key();
#line 1072
        key_used = 0;
#line 1073
        key_do_regen = (int volatile   )0;
      }
    }
#line 1075
    if (ret___0 < 0) {
      goto __Cont;
    }
#line 1078
    i = 0;
#line 1078
    while (i < options.max_startups) {
#line 1080
      if (*(startup_pipes + i) != -1) {
#line 1080
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 1080
        if (__result) {
#line 1087
          close(*(startup_pipes + i));
#line 1088
          *(startup_pipes + i) = -1;
#line 1089
          startups --;
        }
      }
#line 1078
      i ++;
    }
#line 1091
    i = 0;
#line 1091
    while (i < num_listen_socks) {
#line 1092
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                           "m" (fdset->fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 1092
      if (! __result___0) {
        goto __Cont___0;
      }
#line 1094
      fromlen = sizeof(from);
#line 1095
      *newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 1097
      if (*newsock < 0) {
#line 1098
        tmp___6 = __errno_location();
#line 1098
        if (*tmp___6 != 4) {
#line 1098
          tmp___7 = __errno_location();
#line 1098
          if (*tmp___7 != 11) {
#line 1098
            tmp___8 = __errno_location();
#line 1098
            if (*tmp___8 != 11) {
#line 1100
              tmp___4 = __errno_location();
#line 1100
              tmp___5 = strerror(*tmp___4);
#line 1100
              error("accept: %.100s", tmp___5);
            }
          }
        }
        goto __Cont___0;
      }
#line 1103
      tmp___9 = unset_nonblock(*newsock);
#line 1103
      if (tmp___9 == -1) {
#line 1104
        close(*newsock);
        goto __Cont___0;
      }
#line 1107
      tmp___10 = drop_connection(startups);
#line 1107
      if (tmp___10 == 1) {
#line 1108
        debug("drop connection #%d", startups);
#line 1109
        close(*newsock);
        goto __Cont___0;
      }
#line 1112
      tmp___11 = pipe((int *)(startup_p));
#line 1112
      if (tmp___11 == -1) {
#line 1113
        close(*newsock);
        goto __Cont___0;
      }
#line 1117
      if (rexec_flag) {
#line 1117
        tmp___14 = socketpair(1, 1, 0, (int *)config_s);
#line 1117
        if (tmp___14 == -1) {
#line 1119
          tmp___12 = __errno_location();
#line 1119
          tmp___13 = strerror(*tmp___12);
#line 1119
          error("reexec socketpair: %s", tmp___13);
#line 1121
          close(*newsock);
#line 1122
          close(startup_p[0]);
#line 1123
          close(startup_p[1]);
          goto __Cont___0;
        }
      }
#line 1127
      j = 0;
#line 1127
      while (j < options.max_startups) {
#line 1128
        if (*(startup_pipes + j) == -1) {
#line 1129
          *(startup_pipes + j) = startup_p[0];
#line 1130
          if (maxfd < startup_p[0]) {
#line 1131
            maxfd = startup_p[0];
          }
#line 1132
          startups ++;
#line 1133
          break;
        }
#line 1127
        j ++;
      }
#line 1140
      if (debug_flag) {
#line 1146
        debug("Server will not fork when running in debugging mode.");
#line 1147
        close_listen_socks();
#line 1148
        *sock_in = *newsock;
#line 1149
        *sock_out = *newsock;
#line 1150
        close(startup_p[0]);
#line 1151
        close(startup_p[1]);
#line 1152
        startup_pipe = -1;
#line 1153
        pid = getpid();
#line 1154
        if (rexec_flag) {
#line 1155
          send_rexec_state(*(config_s + 0), & cfg);
#line 1157
          close(*(config_s + 0));
        }
#line 1159
        break;
      }
#line 1167
      platform_pre_fork();
#line 1168
      pid = fork();
#line 1168
      if (pid == 0) {
#line 1177
        platform_post_fork_child();
#line 1178
        startup_pipe = startup_p[1];
#line 1179
        close_startup_pipes();
#line 1180
        close_listen_socks();
#line 1181
        *sock_in = *newsock;
#line 1182
        *sock_out = *newsock;
#line 1183
        log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1187
        if (rexec_flag) {
#line 1188
          close(*(config_s + 0));
        }
#line 1189
        break;
      }
#line 1193
      platform_post_fork_parent(pid);
#line 1194
      if (pid < 0) {
#line 1195
        tmp___15 = __errno_location();
#line 1195
        tmp___16 = strerror(*tmp___15);
#line 1195
        error("fork: %.100s", tmp___16);
      } else {
#line 1197
        debug("Forked child %ld.", (long )pid);
      }
#line 1199
      close(startup_p[1]);
#line 1201
      if (rexec_flag) {
#line 1202
        send_rexec_state(*(config_s + 0), & cfg);
#line 1203
        close(*(config_s + 0));
#line 1204
        close(*(config_s + 1));
      }
#line 1211
      if (options.protocol & 1) {
#line 1211
        if (key_used == 0) {
#line 1214
          mysignal(14, & key_regeneration_alarm);
#line 1215
          alarm((unsigned int )options.key_regeneration_time);
#line 1216
          key_used = 1;
        }
      }
#line 1219
      close(*newsock);
#line 1225
      arc4random_stir();
      __Cont___0: /* CIL Label */ 
#line 1091
      i ++;
    }
#line 1229
    if (num_listen_socks < 0) {
#line 1230
      break;
    }
    __Cont: /* CIL Label */ ;
  }
#line 1232
  return;
}
}
#line 1238 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int i ;
  int on ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  char const   *remote_ip___0 ;
  char *test_user ;
  char *test_host ;
  char *test_addr ;
  int remote_port ;
  char *line ;
  char *p ;
  char *cp ;
  int config_s[2] ;
  u_int64_t ibytes ;
  u_int64_t obytes ;
  mode_t new_umask ;
  Key *key ;
  Authctxt *authctxt___0 ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  long long tmp___4 ;
  u_int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___22 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___48 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___74 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___80 ;
  int tmp___83 ;
  int tmp___84 ;
  char *tmp___102 ;
  long long tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  char *tmp___108 ;
  char const   *tmp___109 ;
  size_t tmp___110 ;
  void *tmp___111 ;
  char const   *tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  struct stat st ;
  int tmp___116 ;
  int *tmp___117 ;
  char *tmp___118 ;
  int tmp___119 ;
  void *tmp___120 ;
  __mode_t tmp___121 ;
  int fd ;
  int *tmp___122 ;
  char *tmp___123 ;
  int tmp___124 ;
  FILE *f ;
  FILE *tmp___125 ;
  int *tmp___126 ;
  char *tmp___127 ;
  __pid_t tmp___128 ;
  int *tmp___129 ;
  char *tmp___130 ;
  __pid_t tmp___131 ;
  int fd___0 ;
  int *tmp___132 ;
  char *tmp___133 ;
  int *tmp___134 ;
  char *tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  void *tmp___138 ;
  int tmp___139 ;

  {
#line 1243
  on = 1;
#line 1244
  sock_in = -1;
#line 1244
  sock_out = -1;
#line 1244
  newsock = -1;
#line 1246
  test_user = (char *)((void *)0);
#line 1246
  test_host = (char *)((void *)0);
#line 1246
  test_addr = (char *)((void *)0);
#line 1249
  config_s[0] = -1;
#line 1249
  config_s[1] = -1;
#line 1258
  __progname = ssh_get_progname(*(av + 0));
#line 1259
  init_rng();
#line 1262
  saved_argc = ac;
#line 1263
  rexec_argc = ac;
#line 1264
  tmp = xcalloc((unsigned int )(ac + 1), sizeof(*saved_argv));
#line 1264
  saved_argv = (char **)tmp;
#line 1265
  i = 0;
#line 1265
  while (i < ac) {
#line 1266
    *(saved_argv + i) = xstrdup((char const   *)*(av + i));
#line 1265
    i ++;
  }
#line 1267
  *(saved_argv + i) = (char *)((void *)0);
#line 1271
  compat_init_setproctitle(ac, av);
#line 1272
  av = saved_argv;
#line 1275
  tmp___2 = geteuid();
#line 1275
  if (tmp___2 == 0U) {
#line 1275
    tmp___3 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 1275
    if (tmp___3 == -1) {
#line 1276
      tmp___0 = __errno_location();
#line 1276
      tmp___1 = strerror(*tmp___0);
#line 1276
      debug("setgroups(): %.200s", tmp___1);
    }
  }
#line 1279
  sanitise_stdfd();
#line 1282
  initialize_server_options(& options);
#line 1285
  while (1) {
#line 1285
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:u:o:C:dDeiqrtQRT46");
#line 1285
    if (! (opt != -1)) {
#line 1285
      break;
    }
#line 1286
    switch (opt) {
    case 52: 
#line 1288
    options.address_family = 2;
#line 1289
    break;
    case 54: 
#line 1291
    options.address_family = 10;
#line 1292
    break;
    case 102: 
#line 1294
    config_file_name = BSDoptarg;
#line 1295
    break;
    case 100: 
#line 1297
    if (debug_flag == 0) {
#line 1298
      debug_flag = 1;
#line 1299
      options.log_level = 5;
    } else {
#line 1300
      if ((int )options.log_level < 7) {
#line 1301
        options.log_level = (LogLevel )((int )options.log_level + 1);
      }
    }
#line 1302
    break;
    case 68: 
#line 1304
    no_daemon_flag = 1;
#line 1305
    break;
    case 101: 
#line 1307
    log_stderr = 1;
#line 1308
    break;
    case 105: 
#line 1310
    inetd_flag = 1;
#line 1311
    break;
    case 114: 
#line 1313
    rexec_flag = 0;
#line 1314
    break;
    case 82: 
#line 1316
    rexeced_flag = 1;
#line 1317
    inetd_flag = 1;
#line 1318
    break;
    case 81: 
#line 1321
    break;
    case 113: 
#line 1323
    options.log_level = 0;
#line 1324
    break;
    case 98: 
#line 1326
    tmp___4 = strtonum((char const   *)BSDoptarg, 256LL, 32768LL, (char const   **)((void *)0));
#line 1326
    options.server_key_bits = (int )tmp___4;
#line 1328
    break;
    case 112: 
#line 1330
    options.ports_from_cmdline = 1U;
#line 1331
    if (options.num_ports >= 256U) {
#line 1332
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 1333
      exit(1);
    }
#line 1335
    tmp___5 = options.num_ports;
#line 1335
    (options.num_ports) ++;
#line 1335
    options.ports[tmp___5] = a2port((char const   *)BSDoptarg);
#line 1336
    if (options.ports[options.num_ports - 1U] <= 0) {
#line 1337
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 1338
      exit(1);
    }
#line 1340
    break;
    case 103: 
#line 1342
    tmp___6 = convtime((char const   *)BSDoptarg);
#line 1342
    options.login_grace_time = (int )tmp___6;
#line 1342
    if (options.login_grace_time == -1) {
#line 1343
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid login grace time.\n");
#line 1344
      exit(1);
    }
#line 1346
    break;
    case 107: 
#line 1348
    tmp___7 = convtime((char const   *)BSDoptarg);
#line 1348
    options.key_regeneration_time = (int )tmp___7;
#line 1348
    if (options.key_regeneration_time == -1) {
#line 1349
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid key regeneration interval.\n");
#line 1350
      exit(1);
    }
#line 1352
    break;
    case 104: 
#line 1354
    if (options.num_host_key_files >= 256) {
#line 1355
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 1356
      exit(1);
    }
#line 1358
    tmp___8 = options.num_host_key_files;
#line 1358
    (options.num_host_key_files) ++;
#line 1358
    options.host_key_files[tmp___8] = BSDoptarg;
#line 1359
    break;
    case 116: 
#line 1361
    test_flag = 1;
#line 1362
    break;
    case 84: 
#line 1364
    test_flag = 2;
#line 1365
    break;
    case 67: 
#line 1367
    cp = BSDoptarg;
#line 1368
    while (1) {
#line 1368
      tmp___102 = __strsep_g(& cp, ",");
#line 1368
      p = tmp___102;
#line 1368
      if (p) {
#line 1368
        if (! ((int )*p != 0)) {
#line 1368
          break;
        }
      } else {
#line 1368
        break;
      }
#line 1369
      if (0) {
#line 1369
        if (0) {
#line 1369
          __s1_len___4 = strlen((char const   *)p);
#line 1369
          __s2_len___4 = strlen("addr=");
#line 1369
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
            goto _L___10;
          } else {
#line 1369
            if (__s1_len___4 >= 4U) {
              _L___10: /* CIL Label */ 
#line 1369
              if (! ((unsigned int )((void const   *)("addr=" + 1)) - (unsigned int )((void const   *)"addr=") == 1U)) {
#line 1369
                tmp___84 = 1;
              } else {
#line 1369
                if (__s2_len___4 >= 4U) {
#line 1369
                  tmp___84 = 1;
                } else {
#line 1369
                  tmp___84 = 0;
                }
              }
            } else {
#line 1369
              tmp___84 = 0;
            }
          }
#line 1369
          if (tmp___84) {
#line 1369
            tmp___80 = __builtin_strcmp((char const   *)p, "addr=");
          } else {
#line 1369
            tmp___83 = __builtin_strcmp((char const   *)p, "addr=");
#line 1369
            tmp___80 = tmp___83;
          }
        } else {
#line 1369
          tmp___83 = __builtin_strcmp((char const   *)p, "addr=");
#line 1369
          tmp___80 = tmp___83;
        }
#line 1369
        tmp___74 = tmp___80;
      } else {
#line 1369
        tmp___74 = strncmp((char const   *)p, "addr=", 5U);
      }
#line 1369
      if (tmp___74 == 0) {
#line 1370
        test_addr = xstrdup((char const   *)(p + 5));
      } else {
#line 1371
        if (0) {
#line 1371
          if (0) {
#line 1371
            __s1_len___2 = strlen((char const   *)p);
#line 1371
            __s2_len___2 = strlen("host=");
#line 1371
            if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
              goto _L___6;
            } else {
#line 1371
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 1371
                if (! ((unsigned int )((void const   *)("host=" + 1)) - (unsigned int )((void const   *)"host=") == 1U)) {
#line 1371
                  tmp___58 = 1;
                } else {
#line 1371
                  if (__s2_len___2 >= 4U) {
#line 1371
                    tmp___58 = 1;
                  } else {
#line 1371
                    tmp___58 = 0;
                  }
                }
              } else {
#line 1371
                tmp___58 = 0;
              }
            }
#line 1371
            if (tmp___58) {
#line 1371
              tmp___54 = __builtin_strcmp((char const   *)p, "host=");
            } else {
#line 1371
              tmp___57 = __builtin_strcmp((char const   *)p, "host=");
#line 1371
              tmp___54 = tmp___57;
            }
          } else {
#line 1371
            tmp___57 = __builtin_strcmp((char const   *)p, "host=");
#line 1371
            tmp___54 = tmp___57;
          }
#line 1371
          tmp___48 = tmp___54;
        } else {
#line 1371
          tmp___48 = strncmp((char const   *)p, "host=", 5U);
        }
#line 1371
        if (tmp___48 == 0) {
#line 1372
          test_host = xstrdup((char const   *)(p + 5));
        } else {
#line 1373
          if (0) {
#line 1373
            if (0) {
#line 1373
              __s1_len___0 = strlen((char const   *)p);
#line 1373
              __s2_len___0 = strlen("user=");
#line 1373
              if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
                goto _L___2;
              } else {
#line 1373
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 1373
                  if (! ((unsigned int )((void const   *)("user=" + 1)) - (unsigned int )((void const   *)"user=") == 1U)) {
#line 1373
                    tmp___32 = 1;
                  } else {
#line 1373
                    if (__s2_len___0 >= 4U) {
#line 1373
                      tmp___32 = 1;
                    } else {
#line 1373
                      tmp___32 = 0;
                    }
                  }
                } else {
#line 1373
                  tmp___32 = 0;
                }
              }
#line 1373
              if (tmp___32) {
#line 1373
                tmp___28 = __builtin_strcmp((char const   *)p, "user=");
              } else {
#line 1373
                tmp___31 = __builtin_strcmp((char const   *)p, "user=");
#line 1373
                tmp___28 = tmp___31;
              }
            } else {
#line 1373
              tmp___31 = __builtin_strcmp((char const   *)p, "user=");
#line 1373
              tmp___28 = tmp___31;
            }
#line 1373
            tmp___22 = tmp___28;
          } else {
#line 1373
            tmp___22 = strncmp((char const   *)p, "user=", 5U);
          }
#line 1373
          if (tmp___22 == 0) {
#line 1374
            test_user = xstrdup((char const   *)(p + 5));
          } else {
#line 1376
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid test mode specification %s\n",
                    p);
#line 1378
            exit(1);
          }
        }
      }
    }
#line 1381
    break;
    case 117: 
#line 1383
    tmp___103 = strtonum((char const   *)BSDoptarg, 0LL, 65LL, (char const   **)((void *)0));
#line 1383
    utmp_len = (unsigned int )tmp___103;
#line 1384
    if (utmp_len > 64U) {
#line 1385
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid utmp length.\n");
#line 1386
      exit(1);
    }
#line 1388
    break;
    case 111: 
#line 1390
    line = xstrdup((char const   *)BSDoptarg);
#line 1391
    tmp___104 = process_server_config_line(& options, line, "command-line", 0, (int *)((void *)0),
                                           (char const   *)((void *)0), (char const   *)((void *)0),
                                           (char const   *)((void *)0));
#line 1391
    if (tmp___104 != 0) {
#line 1393
      exit(1);
    }
#line 1394
    xfree((void *)line);
#line 1395
    break;
    case 63: 
    default: 
#line 1398
    usage();
#line 1399
    break;
    }
  }
#line 1402
  if (rexeced_flag) {
#line 1403
    rexec_flag = 0;
  } else {
#line 1402
    if (inetd_flag) {
#line 1403
      rexec_flag = 0;
    }
  }
#line 1404
  if (! test_flag) {
#line 1404
    if (rexec_flag) {
#line 1404
      if ((unsigned int )*(av + 0) == (unsigned int )((void *)0)) {
#line 1405
        fatal("sshd re-exec requires execution with an absolute path");
      } else {
#line 1404
        if ((int )*(*(av + 0)) != 47) {
#line 1405
          fatal("sshd re-exec requires execution with an absolute path");
        }
      }
    }
  }
#line 1406
  if (rexeced_flag) {
#line 1407
    closefrom(6);
  } else {
#line 1409
    closefrom(3);
  }
#line 1411
  OPENSSL_add_all_algorithms_noconf();
#line 1417
  if (log_stderr) {
#line 1417
    tmp___105 = 1;
  } else {
#line 1417
    if (! inetd_flag) {
#line 1417
      tmp___105 = 1;
    } else {
#line 1417
      tmp___105 = 0;
    }
  }
#line 1417
  if ((int )options.log_facility == -1) {
#line 1417
    tmp___106 = 2;
  } else {
#line 1417
    tmp___106 = (int )options.log_facility;
  }
#line 1417
  if ((int )options.log_level == -1) {
#line 1417
    tmp___107 = 3;
  } else {
#line 1417
    tmp___107 = (int )options.log_level;
  }
#line 1417
  log_init(__progname, (enum __anonenum_LogLevel_51 )tmp___107, (int )tmp___106, tmp___105);
#line 1428
  tmp___108 = getenv("KRB5CCNAME");
#line 1428
  if ((unsigned int )tmp___108 != (unsigned int )((void *)0)) {
#line 1429
    unsetenv("KRB5CCNAME");
  }
#line 1438
  sensitive_data.server_key = (Key *)((void *)0);
#line 1439
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 1440
  sensitive_data.have_ssh1_key = 0;
#line 1441
  sensitive_data.have_ssh2_key = 0;
#line 1448
  if (test_flag >= 2) {
#line 1448
    if ((unsigned int )test_user != (unsigned int )((void *)0)) {
      goto _L___11;
    } else {
#line 1448
      if ((unsigned int )test_host != (unsigned int )((void *)0)) {
        goto _L___11;
      } else {
#line 1448
        if ((unsigned int )test_addr != (unsigned int )((void *)0)) {
          _L___11: /* CIL Label */ 
#line 1448
          if ((unsigned int )test_user == (unsigned int )((void *)0)) {
#line 1451
            fatal("user, host and addr are all required when testing Match configs");
          } else {
#line 1448
            if ((unsigned int )test_host == (unsigned int )((void *)0)) {
#line 1451
              fatal("user, host and addr are all required when testing Match configs");
            } else {
#line 1448
              if ((unsigned int )test_addr == (unsigned int )((void *)0)) {
#line 1451
                fatal("user, host and addr are all required when testing Match configs");
              }
            }
          }
        }
      }
    }
  }
#line 1453
  if (test_flag < 2) {
#line 1453
    if ((unsigned int )test_user != (unsigned int )((void *)0)) {
#line 1455
      fatal("Config test connection parameter (-C) provided without test mode (-T)");
    } else {
#line 1453
      if ((unsigned int )test_host != (unsigned int )((void *)0)) {
#line 1455
        fatal("Config test connection parameter (-C) provided without test mode (-T)");
      } else {
#line 1453
        if ((unsigned int )test_addr != (unsigned int )((void *)0)) {
#line 1455
          fatal("Config test connection parameter (-C) provided without test mode (-T)");
        }
      }
    }
  }
#line 1459
  buffer_init(& cfg);
#line 1460
  if (rexeced_flag) {
#line 1461
    recv_rexec_state(5, & cfg);
  } else {
#line 1463
    load_server_config((char const   *)config_file_name, & cfg);
  }
#line 1465
  if (rexeced_flag) {
#line 1465
    tmp___109 = "rexec";
  } else {
#line 1465
    tmp___109 = (char const   *)config_file_name;
  }
#line 1465
  parse_server_config(& options, tmp___109, & cfg, (char const   *)((void *)0), (char const   *)((void *)0),
                      (char const   *)((void *)0));
#line 1468
  seed_rng();
#line 1471
  fill_default_server_options(& options);
#line 1474
  if (options.challenge_response_authentication) {
#line 1475
    options.kbd_interactive_authentication = 1;
  }
#line 1478
  channel_set_af(options.address_family);
#line 1481
  if (BSDoptind < ac) {
#line 1482
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + BSDoptind));
#line 1483
    exit(1);
  }
#line 1486
  debug("sshd version %.100s", "OpenSSH_5.2p1");
#line 1489
  privsep_pw = getpwnam("sshd");
#line 1489
  if ((unsigned int )privsep_pw == (unsigned int )((void *)0)) {
#line 1490
    if (use_privsep) {
#line 1491
      fatal("Privilege separation user %s does not exist", "sshd");
    } else {
#line 1490
      if (options.kerberos_authentication) {
#line 1491
        fatal("Privilege separation user %s does not exist", "sshd");
      }
    }
  } else {
#line 1494
    tmp___110 = strlen((char const   *)privsep_pw->pw_passwd);
#line 1494
    memset((void *)privsep_pw->pw_passwd, 0, tmp___110);
#line 1495
    privsep_pw = pwcopy(privsep_pw);
#line 1496
    xfree((void *)privsep_pw->pw_passwd);
#line 1497
    privsep_pw->pw_passwd = xstrdup("*");
  }
#line 1499
  endpwent();
#line 1502
  tmp___111 = xcalloc((unsigned int )options.num_host_key_files, sizeof(Key *));
#line 1502
  sensitive_data.host_keys = (Key **)tmp___111;
#line 1504
  i = 0;
#line 1504
  while (i < options.num_host_key_files) {
#line 1505
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 1504
    i ++;
  }
#line 1507
  i = 0;
#line 1507
  while (i < options.num_host_key_files) {
#line 1508
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
#line 1509
    *(sensitive_data.host_keys + i) = key;
#line 1510
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1511
      error("Could not load host key: %s", options.host_key_files[i]);
#line 1513
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      goto __Cont;
    }
#line 1516
    switch (key->type) {
    case 0: 
#line 1518
    sensitive_data.ssh1_host_key = key;
#line 1519
    sensitive_data.have_ssh1_key = 1;
#line 1520
    break;
    case 1: 
    case 2: 
#line 1523
    sensitive_data.have_ssh2_key = 1;
#line 1524
    break;
    }
#line 1526
    tmp___112 = key_type((Key const   *)key);
#line 1526
    debug("private host key: #%d type %d %s", i, key->type, tmp___112);
    __Cont: /* CIL Label */ 
#line 1507
    i ++;
  }
#line 1529
  if (options.protocol & 1) {
#line 1529
    if (! sensitive_data.have_ssh1_key) {
#line 1530
      logit("Disabling protocol version 1. Could not load host key");
#line 1531
      options.protocol &= -2;
    }
  }
#line 1533
  if (options.protocol & 4) {
#line 1533
    if (! sensitive_data.have_ssh2_key) {
#line 1534
      logit("Disabling protocol version 2. Could not load host key");
#line 1535
      options.protocol &= -5;
    }
  }
#line 1537
  if (! (options.protocol & 5)) {
#line 1538
    logit("sshd: no hostkeys available -- exiting.");
#line 1539
    exit(1);
  }
#line 1543
  if (options.protocol & 1) {
#line 1544
    if (options.server_key_bits < 512) {
#line 1546
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1547
      exit(1);
    } else {
#line 1544
      if (options.server_key_bits > 32768) {
#line 1546
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1547
        exit(1);
      }
    }
#line 1554
    tmp___114 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1554
    if (options.server_key_bits > tmp___114 - 128) {
#line 1554
      tmp___115 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1554
      if (options.server_key_bits < tmp___115 + 128) {
#line 1559
        tmp___113 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1559
        options.server_key_bits = tmp___113 + 128;
#line 1562
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 1567
  if (use_privsep) {
#line 1570
    tmp___116 = stat((char const   * __restrict  )"/var/empty", (struct stat * __restrict  )(& st));
#line 1570
    if (tmp___116 == -1) {
#line 1572
      fatal("Missing privilege separation directory: %s", "/var/empty");
    } else {
#line 1570
      if (((st.st_mode & 61440U) == 16384U) == 0) {
#line 1572
        fatal("Missing privilege separation directory: %s", "/var/empty");
      }
    }
#line 1580
    if (st.st_uid != 0U) {
#line 1582
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
    } else {
#line 1580
      if ((st.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
#line 1582
        fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
    }
  }
#line 1586
  if (test_flag > 1) {
#line 1587
    if ((unsigned int )test_user != (unsigned int )((void *)0)) {
#line 1587
      if ((unsigned int )test_addr != (unsigned int )((void *)0)) {
#line 1587
        if ((unsigned int )test_host != (unsigned int )((void *)0)) {
#line 1588
          parse_server_match_config(& options, (char const   *)test_user, (char const   *)test_host,
                                    (char const   *)test_addr);
        }
      }
    }
#line 1590
    dump_config(& options);
  }
#line 1594
  if (test_flag) {
#line 1595
    exit(0);
  }
#line 1604
  tmp___119 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 1604
  if (tmp___119 < 0) {
#line 1605
    tmp___117 = __errno_location();
#line 1605
    tmp___118 = strerror(*tmp___117);
#line 1605
    debug("setgroups() failed: %.200s", tmp___118);
  }
#line 1607
  if (rexec_flag) {
#line 1608
    tmp___120 = xcalloc((unsigned int )(rexec_argc + 2), sizeof(char *));
#line 1608
    rexec_argv = (char **)tmp___120;
#line 1609
    i = 0;
#line 1609
    while (i < rexec_argc) {
#line 1610
      debug("rexec_argv[%d]=\'%s\'", i, *(saved_argv + i));
#line 1611
      *(rexec_argv + i) = *(saved_argv + i);
#line 1609
      i ++;
    }
#line 1613
    *(rexec_argv + rexec_argc) = (char *)"-R";
#line 1614
    *(rexec_argv + (rexec_argc + 1)) = (char *)((void *)0);
  }
#line 1618
  tmp___121 = umask(63U);
#line 1618
  new_umask = tmp___121 | 18U;
#line 1619
  umask(new_umask);
#line 1622
  if (debug_flag) {
#line 1622
    if (! inetd_flag) {
#line 1623
      log_stderr = 1;
    } else {
#line 1622
      if (rexeced_flag) {
#line 1623
        log_stderr = 1;
      }
    }
  }
#line 1624
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1631
  if (! debug_flag) {
#line 1631
    if (! inetd_flag) {
#line 1631
      if (! no_daemon_flag) {
#line 1635
        tmp___124 = daemon(0, 0);
#line 1635
        if (tmp___124 < 0) {
#line 1636
          tmp___122 = __errno_location();
#line 1636
          tmp___123 = strerror(*tmp___122);
#line 1636
          fatal("daemon() failed: %.200s", tmp___123);
        }
#line 1640
        fd = open("/dev/tty", 258);
#line 1641
        if (fd >= 0) {
#line 1642
          ioctl(fd, 21538UL, (void *)0);
#line 1643
          close(fd);
        }
      }
    }
  }
#line 1648
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1651
  arc4random_stir();
#line 1655
  chdir("/");
#line 1658
  mysignal(13, (void (*)(int  ))1);
#line 1661
  if (inetd_flag) {
#line 1662
    server_accept_inetd(& sock_in, & sock_out);
  } else {
#line 1664
    server_listen();
#line 1666
    if (options.protocol & 1) {
#line 1667
      generate_ephemeral_server_key();
    }
#line 1669
    mysignal(1, & sighup_handler);
#line 1670
    mysignal(17, & main_sigchld_handler);
#line 1671
    mysignal(15, & sigterm_handler);
#line 1672
    mysignal(3, & sigterm_handler);
#line 1678
    if (! debug_flag) {
#line 1679
      tmp___125 = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"w");
#line 1679
      f = tmp___125;
#line 1681
      if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 1682
        tmp___126 = __errno_location();
#line 1682
        tmp___127 = strerror(*tmp___126);
#line 1682
        error("Couldn\'t create pid file \"%s\": %s", options.pid_file, tmp___127);
      } else {
#line 1685
        tmp___128 = getpid();
#line 1685
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%ld\n", (long )tmp___128);
#line 1686
        fclose(f);
      }
    }
#line 1691
    server_accept_loop(& sock_in, & sock_out, & newsock, config_s);
  }
#line 1696
  setproctitle("%s", "[accepted]");
#line 1709
  if (! debug_flag) {
#line 1709
    if (! inetd_flag) {
#line 1709
      tmp___131 = setsid();
#line 1709
      if (tmp___131 < 0) {
#line 1710
        tmp___129 = __errno_location();
#line 1710
        tmp___130 = strerror(*tmp___129);
#line 1710
        error("setsid: %.100s", tmp___130);
      }
    }
  }
#line 1713
  if (rexec_flag) {
#line 1716
    debug("rexec start in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
#line 1718
    dup2(newsock, 0);
#line 1719
    dup2(0, 1);
#line 1720
    if (startup_pipe == -1) {
#line 1721
      close(4);
    } else {
#line 1723
      dup2(startup_pipe, 4);
    }
#line 1725
    dup2(config_s[1], 5);
#line 1726
    close(config_s[1]);
#line 1727
    if (startup_pipe != -1) {
#line 1728
      close(startup_pipe);
    }
#line 1730
    execv((char const   *)*(rexec_argv + 0), (char * const  *)rexec_argv);
#line 1733
    tmp___132 = __errno_location();
#line 1733
    tmp___133 = strerror(*tmp___132);
#line 1733
    error("rexec of %s failed: %s", *(rexec_argv + 0), tmp___133);
#line 1734
    recv_rexec_state(5, (Buffer *)((void *)0));
#line 1735
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1739
    startup_pipe = 4;
#line 1740
    close(config_s[1]);
#line 1741
    close(5);
#line 1742
    sock_in = dup(0);
#line 1742
    sock_out = sock_in;
#line 1742
    newsock = sock_out;
#line 1743
    fd___0 = open("/dev/null", 2, 0);
#line 1743
    if (fd___0 != -1) {
#line 1744
      dup2(fd___0, 0);
#line 1745
      dup2(fd___0, 1);
#line 1746
      if (fd___0 > 2) {
#line 1747
        close(fd___0);
      }
    }
#line 1749
    debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
  }
#line 1758
  alarm(0U);
#line 1759
  mysignal(14, (void (*)(int  ))0);
#line 1760
  mysignal(1, (void (*)(int  ))0);
#line 1761
  mysignal(15, (void (*)(int  ))0);
#line 1762
  mysignal(3, (void (*)(int  ))0);
#line 1763
  mysignal(17, (void (*)(int  ))0);
#line 1764
  mysignal(2, (void (*)(int  ))0);
#line 1770
  packet_set_connection(sock_in, sock_out);
#line 1771
  packet_set_server();
#line 1774
  if (options.tcp_keep_alive) {
#line 1774
    tmp___136 = packet_connection_is_on_socket();
#line 1774
    if (tmp___136) {
#line 1774
      tmp___137 = setsockopt(sock_in, 1, 9, (void const   *)(& on), sizeof(on));
#line 1774
      if (tmp___137 < 0) {
#line 1776
        tmp___134 = __errno_location();
#line 1776
        tmp___135 = strerror(*tmp___134);
#line 1776
        error("setsockopt SO_KEEPALIVE: %.100s", tmp___135);
      }
    }
  }
#line 1778
  remote_port = get_remote_port();
#line 1778
  if (remote_port < 0) {
#line 1779
    debug("get_remote_port failed");
#line 1780
    cleanup_exit(255);
  }
#line 1787
  get_canonical_hostname(0);
#line 1793
  remote_ip___0 = get_remote_ipaddr();
#line 1818
  verbose("Connection from %.500s port %d", remote_ip___0, remote_port);
#line 1828
  mysignal(14, & grace_alarm_handler);
#line 1829
  if (! debug_flag) {
#line 1830
    alarm((unsigned int )options.login_grace_time);
  }
#line 1832
  sshd_exchange_identification(sock_in, sock_out);
#line 1835
  if (! compat20) {
#line 1835
    if (inetd_flag) {
#line 1835
      if ((unsigned int )sensitive_data.server_key == (unsigned int )((void *)0)) {
#line 1836
        generate_ephemeral_server_key();
      }
    }
  }
#line 1838
  packet_set_nonblocking();
#line 1841
  tmp___138 = xcalloc(1U, sizeof(*authctxt___0));
#line 1841
  authctxt___0 = (Authctxt *)tmp___138;
#line 1843
  authctxt___0->loginmsg = & loginmsg;
#line 1846
  the_authctxt = authctxt___0;
#line 1849
  buffer_init(& loginmsg);
#line 1851
  if (use_privsep) {
#line 1852
    tmp___139 = privsep_preauth(authctxt___0);
#line 1852
    if (tmp___139 == 1) {
      goto authenticated;
    }
  }
#line 1857
  if (compat20) {
#line 1858
    do_ssh2_kex();
#line 1859
    do_authentication2(authctxt___0);
  } else {
#line 1861
    do_ssh1_kex();
#line 1862
    do_authentication(authctxt___0);
  }
#line 1868
  if (use_privsep) {
#line 1869
    mm_send_keystate(pmonitor);
#line 1870
    exit(0);
  }
  authenticated: 
#line 1878
  alarm(0U);
#line 1879
  mysignal(14, (void (*)(int  ))0);
#line 1880
  authctxt___0->authenticated = 1;
#line 1881
  if (startup_pipe != -1) {
#line 1882
    close(startup_pipe);
#line 1883
    startup_pipe = -1;
  }
#line 1908
  if (use_privsep) {
#line 1909
    privsep_postauth(authctxt___0);
#line 1911
    if (! compat20) {
#line 1912
      destroy_sensitive_data();
    }
  }
#line 1915
  packet_set_timeout(options.client_alive_interval, options.client_alive_count_max);
#line 1919
  do_authenticated(authctxt___0);
#line 1922
  packet_get_state(0, (u_int32_t *)((void *)0), (u_int64_t *)((void *)0), (u_int32_t *)((void *)0),
                   & ibytes);
#line 1923
  packet_get_state(1, (u_int32_t *)((void *)0), (u_int64_t *)((void *)0), (u_int32_t *)((void *)0),
                   & obytes);
#line 1924
  verbose("Transferred: sent %llu, received %llu bytes", obytes, ibytes);
#line 1926
  verbose("Closing connection to %.500s port %d", remote_ip___0, remote_port);
#line 1937
  packet_close();
#line 1939
  if (use_privsep) {
#line 1940
    mm_terminate();
  }
#line 1942
  exit(0);
}
}
#line 1949 "sshd.c"
int ssh1_session_key(BIGNUM *session_key_int ) 
{ int rsafail ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1952
  rsafail = 0;
#line 1954
  tmp___13 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1954
  if (tmp___13 > 0) {
#line 1957
    tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1957
    tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1957
    if (tmp___2 < tmp___3 + 128) {
#line 1960
      tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1960
      tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1960
      tmp___1 = get_remote_ipaddr();
#line 1960
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___1, tmp___0, tmp, 128);
    }
#line 1967
    tmp___4 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1967
    if (tmp___4 <= 0) {
#line 1969
      rsafail ++;
    }
#line 1970
    tmp___5 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1970
    if (tmp___5 <= 0) {
#line 1972
      rsafail ++;
    }
  } else {
#line 1975
    tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1975
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1975
    if (tmp___9 < tmp___10 + 128) {
#line 1978
      tmp___6 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1978
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1978
      tmp___8 = get_remote_ipaddr();
#line 1978
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___8, tmp___7, tmp___6, 128);
    }
#line 1985
    tmp___11 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1985
    if (tmp___11 < 0) {
#line 1987
      rsafail ++;
    }
#line 1988
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1988
    if (tmp___12 < 0) {
#line 1990
      rsafail ++;
    }
  }
#line 1992
  return (rsafail);
}
}
#line 1997 "sshd.c"
static void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _len ;
  int tmp___7 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int bytes ;
  int tmp___12 ;
  u_char *buf___1 ;
  void *tmp___13 ;
  MD5_CTX md ;

  {
#line 2001
  rsafail = 0;
#line 2016
  arc4random_buf((void *)(cookie), sizeof(cookie));
#line 2023
  packet_start((unsigned char)2);
#line 2024
  i = 0;
#line 2024
  while (i < 8) {
#line 2025
    packet_put_char((int )cookie[i]);
#line 2024
    i ++;
  }
#line 2028
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 2028
  packet_put_int((unsigned int )tmp);
#line 2029
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 2030
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 2033
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 2033
  packet_put_int((unsigned int )tmp___0);
#line 2034
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 2035
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 2038
  packet_put_int(2U);
#line 2041
  tmp___1 = cipher_mask_ssh1(0);
#line 2041
  packet_put_int(tmp___1);
#line 2044
  auth_mask = 0U;
#line 2045
  if (options.rhosts_rsa_authentication) {
#line 2046
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 2047
  if (options.rsa_authentication) {
#line 2048
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 2049
  if (options.challenge_response_authentication == 1) {
#line 2050
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 2051
  if (options.password_authentication) {
#line 2052
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 2053
  packet_put_int(auth_mask);
#line 2056
  packet_send();
#line 2057
  packet_write_wait();
#line 2059
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 2059
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 2059
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 2064
  packet_read_expect(3);
#line 2067
  cipher_type = packet_get_char();
#line 2069
  tmp___4 = cipher_mask_ssh1(0);
#line 2069
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
#line 2070
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 2074
  i = 0;
#line 2074
  while (i < 8) {
#line 2075
    tmp___5 = packet_get_char();
#line 2075
    if ((u_int )cookie[i] != tmp___5) {
#line 2076
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 2074
    i ++;
  }
#line 2078
  tmp___6 = cipher_name((int )cipher_type);
#line 2078
  debug("Encryption type: %.200s", tmp___6);
#line 2081
  session_key_int = BN_new();
#line 2081
  if ((unsigned int )session_key_int == (unsigned int )((void *)0)) {
#line 2082
    fatal("do_ssh1_kex: BN_new failed");
  }
#line 2083
  packet_get_bignum(session_key_int);
#line 2085
  protocol_flags = packet_get_int();
#line 2086
  packet_set_protocol_flags(protocol_flags);
#line 2087
  while (1) {
#line 2087
    tmp___7 = packet_remaining();
#line 2087
    _len = tmp___7;
#line 2087
    if (_len > 0) {
#line 2087
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "sshd.c",
            2087);
#line 2087
      packet_disconnect("Packet integrity error.");
    }
#line 2087
    break;
  }
#line 2090
  if (use_privsep) {
#line 2090
    rsafail = mm_ssh1_session_key(session_key_int);
  } else {
#line 2090
    rsafail = ssh1_session_key(session_key_int);
  }
#line 2097
  if (! rsafail) {
#line 2098
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 2099
    tmp___10 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 2099
    len = (tmp___10 + 7) / 8;
#line 2100
    if (len < 0) {
#line 2101
      tmp___11 = get_remote_ipaddr();
#line 2101
      error("do_ssh1_kex: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, (unsigned long )sizeof(session_key));
#line 2104
      rsafail ++;
    } else {
#line 2100
      if ((unsigned int )len > sizeof(session_key)) {
#line 2101
        tmp___11 = get_remote_ipaddr();
#line 2101
        error("do_ssh1_kex: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___11, len, (unsigned long )sizeof(session_key));
#line 2104
        rsafail ++;
      } else {
#line 2106
        memset((void *)(session_key), 0, sizeof(session_key));
#line 2107
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 2110
        derive_ssh1_session_id(((sensitive_data.ssh1_host_key)->rsa)->n, ((sensitive_data.server_key)->rsa)->n,
                               (u_int8_t *)(cookie), (u_int8_t *)(session_id));
#line 2118
        i = 0;
#line 2118
        while (i < 16) {
#line 2119
          session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 2118
          i ++;
        }
      }
    }
  }
#line 2122
  if (rsafail) {
#line 2123
    tmp___12 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 2123
    bytes = (tmp___12 + 7) / 8;
#line 2124
    tmp___13 = xmalloc((unsigned int )bytes);
#line 2124
    buf___1 = (u_char *)tmp___13;
#line 2127
    logit("do_connection: generating a fake encryption key");
#line 2128
    BN_bn2bin((BIGNUM const   *)session_key_int, buf___1);
#line 2129
    MD5_Init(& md);
#line 2130
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 2131
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 2132
    MD5_Final(session_key, & md);
#line 2133
    MD5_Init(& md);
#line 2134
    MD5_Update(& md, (void const   *)(session_key), 16U);
#line 2135
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 2136
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 2137
    MD5_Final(session_key + 16, & md);
#line 2138
    memset((void *)buf___1, 0, (unsigned int )bytes);
#line 2139
    xfree((void *)buf___1);
#line 2140
    i = 0;
#line 2140
    while (i < 16) {
#line 2141
      session_id[i] = (unsigned char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 2140
      i ++;
    }
  }
#line 2144
  destroy_sensitive_data();
#line 2146
  if (use_privsep) {
#line 2147
    mm_ssh1_session_id(session_id);
  }
#line 2150
  BN_clear_free(session_key_int);
#line 2153
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type);
#line 2156
  memset((void *)(session_key), 0, sizeof(session_key));
#line 2158
  debug("Received session key; encryption turned on.");
#line 2161
  packet_start((unsigned char)14);
#line 2162
  packet_send();
#line 2163
  packet_write_wait();
#line 2164
  return;
}
}
#line 2169 "sshd.c"
static void do_ssh2_kex(void) 
{ Kex *kex ;

  {
#line 2174
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 2175
    myproposal[3] = options.ciphers;
#line 2175
    myproposal[2] = myproposal[3];
  }
#line 2178
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
#line 2180
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
#line 2183
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 2184
    myproposal[5] = options.macs;
#line 2184
    myproposal[4] = myproposal[5];
  }
#line 2187
  if (options.compression == 0) {
#line 2188
    myproposal[7] = (char *)"none";
#line 2188
    myproposal[6] = myproposal[7];
  } else {
#line 2190
    if (options.compression == 2) {
#line 2191
      myproposal[7] = (char *)"none,zlib@openssh.com";
#line 2191
      myproposal[6] = myproposal[7];
    }
  }
#line 2195
  myproposal[1] = list_hostkey_types();
#line 2198
  kex = kex_setup((char **)(myproposal));
#line 2199
  kex->kex[0] = & kexdh_server;
#line 2200
  kex->kex[1] = & kexdh_server;
#line 2201
  kex->kex[2] = & kexgex_server;
#line 2202
  kex->kex[3] = & kexgex_server;
#line 2203
  kex->server = 1;
#line 2204
  kex->client_version_string = client_version_string;
#line 2205
  kex->server_version_string = server_version_string;
#line 2206
  kex->load_host_key = & get_hostkey_by_type;
#line 2207
  kex->host_key_index = & get_hostkey_index;
#line 2209
  xxx_kex = kex;
#line 2211
  dispatch_run(0, (sig_atomic_t volatile   *)(& kex->done), (void *)kex);
#line 2213
  session_id2 = kex->session_id;
#line 2214
  session_id2_len = kex->session_id_len;
#line 2223
  debug("KEX done");
#line 2224
  return;
}
}
#line 1 "auth-rhosts.o"
#pragma merger(0,"./auth-rhosts.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 106 "auth.h"
int auth_rhosts(struct passwd *pw___0 , char const   *client_user___0 ) ;
#line 107
int auth_rhosts2(struct passwd *pw___0 , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 186
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) ;
#line 187
void auth_debug_send(void) ;
#line 188
void auth_debug_reset(void) ;
#line 54 "auth-rhosts.c"
static int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                             char const   *client_user___0 , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  int fd ;
  struct stat st ;
  int tmp ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;

  {
#line 65
  fd = open(filename, 2048);
#line 65
  if (fd == -1) {
#line 66
    return (0);
  }
#line 67
  tmp = fstat(fd, & st);
#line 67
  if (tmp == -1) {
#line 68
    close(fd);
#line 69
    return (0);
  }
#line 71
  if (! ((st.st_mode & 61440U) == 32768U)) {
#line 72
    logit("User %s hosts file %s is not a regular file", server_user, filename);
#line 74
    close(fd);
#line 75
    return (0);
  }
#line 77
  unset_nonblock(fd);
#line 78
  f = fdopen(fd, "r");
#line 78
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 79
    close(fd);
#line 80
    return (0);
  }
#line 82
  while (1) {
#line 82
    tmp___51 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 82
    if (! tmp___51) {
#line 82
      break;
    }
#line 87
    cp = buf___1;
#line 87
    while (1) {
#line 87
      if (! ((int )*cp == 32)) {
#line 87
        if (! ((int )*cp == 9)) {
#line 87
          break;
        }
      }
#line 87
      cp ++;
    }
#line 89
    if ((int )*cp == 35) {
#line 90
      continue;
    } else {
#line 89
      if ((int )*cp == 10) {
#line 90
        continue;
      } else {
#line 89
        if (! *cp) {
#line 90
          continue;
        }
      }
    }
#line 96
    if (0) {
#line 96
      if (0) {
#line 96
        __s1_len___0 = strlen((char const   *)cp);
#line 96
        __s2_len___0 = strlen("NO_PLUS");
#line 96
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 96
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 96
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 96
              tmp___23 = 1;
            } else {
#line 96
              if (__s2_len___0 >= 4U) {
#line 96
                tmp___23 = 1;
              } else {
#line 96
                tmp___23 = 0;
              }
            }
          } else {
#line 96
            tmp___23 = 0;
          }
        }
#line 96
        if (tmp___23) {
#line 96
          tmp___19 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 96
          tmp___22 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 96
          tmp___19 = tmp___22;
        }
      } else {
#line 96
        tmp___22 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 96
        tmp___19 = tmp___22;
      }
#line 96
      tmp___13 = tmp___19;
    } else {
#line 96
      tmp___13 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 96
    if (tmp___13 == 0) {
#line 97
      continue;
    }
#line 103
    tmp___26 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%1023s %1023s %1023s",
                      hostbuf, userbuf, dummy);
#line 103
    switch (tmp___26) {
    case 0: 
#line 106
    auth_debug_add("Found empty line in %.100s.", filename);
#line 107
    continue;
    case 1: 
#line 110
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 111
    break;
    case 2: 
#line 114
    break;
    case 3: 
#line 116
    auth_debug_add("Found garbage in %.100s.", filename);
#line 117
    continue;
    default: ;
#line 120
    continue;
    }
#line 123
    host = hostbuf;
#line 124
    user = userbuf;
#line 125
    negated = 0;
#line 128
    if ((int )*(host + 0) == 45) {
#line 129
      negated = 1;
#line 130
      host ++;
    } else {
#line 131
      if ((int )*(host + 0) == 43) {
#line 132
        host ++;
      }
    }
#line 134
    if ((int )*(user + 0) == 45) {
#line 135
      negated = 1;
#line 136
      user ++;
    } else {
#line 137
      if ((int )*(user + 0) == 43) {
#line 138
        user ++;
      }
    }
#line 141
    if (! *(host + 0)) {
#line 143
      auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 145
      continue;
    } else {
#line 141
      if (! *(user + 0)) {
#line 143
        auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 145
        continue;
      }
    }
#line 148
    if ((int )*(host + 0) == 64) {
#line 149
      tmp___27 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 149
      if (! tmp___27) {
#line 149
        tmp___28 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 149
        if (! tmp___28) {
#line 151
          continue;
        }
      }
    } else {
#line 152
      tmp___29 = strcasecmp((char const   *)host, hostname);
#line 152
      if (tmp___29) {
#line 152
        if (0) {
#line 152
          __s1_len___1 = strlen((char const   *)host);
#line 152
          __s2_len___1 = strlen(ipaddr);
#line 152
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 152
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 152
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 152
                tmp___39 = 1;
              } else {
#line 152
                if (__s2_len___1 >= 4U) {
#line 152
                  tmp___39 = 1;
                } else {
#line 152
                  tmp___39 = 0;
                }
              }
            } else {
#line 152
              tmp___39 = 0;
            }
          }
#line 152
          if (tmp___39) {
#line 152
            tmp___35 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 152
            tmp___38 = __builtin_strcmp((char const   *)host, ipaddr);
#line 152
            tmp___35 = tmp___38;
          }
        } else {
#line 152
          tmp___38 = __builtin_strcmp((char const   *)host, ipaddr);
#line 152
          tmp___35 = tmp___38;
        }
#line 152
        if (tmp___35 != 0) {
#line 153
          continue;
        }
      }
    }
#line 156
    if ((int )*(user + 0) == 64) {
#line 157
      tmp___40 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user___0, (char const   *)((void *)0));
#line 157
      if (! tmp___40) {
#line 158
        continue;
      }
    } else {
#line 159
      if (0) {
#line 159
        __s1_len___2 = strlen((char const   *)user);
#line 159
        __s2_len___2 = strlen(client_user___0);
#line 159
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 159
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 159
            if (! ((unsigned int )((void const   *)(client_user___0 + 1)) - (unsigned int )((void const   *)client_user___0) == 1U)) {
#line 159
              tmp___50 = 1;
            } else {
#line 159
              if (__s2_len___2 >= 4U) {
#line 159
                tmp___50 = 1;
              } else {
#line 159
                tmp___50 = 0;
              }
            }
          } else {
#line 159
            tmp___50 = 0;
          }
        }
#line 159
        if (tmp___50) {
#line 159
          tmp___46 = __builtin_strcmp((char const   *)user, client_user___0);
        } else {
#line 159
          tmp___49 = __builtin_strcmp((char const   *)user, client_user___0);
#line 159
          tmp___46 = tmp___49;
        }
      } else {
#line 159
        tmp___49 = __builtin_strcmp((char const   *)user, client_user___0);
#line 159
        tmp___46 = tmp___49;
      }
#line 159
      if (tmp___46 != 0) {
#line 160
        continue;
      }
    }
#line 163
    fclose(f);
#line 166
    if (negated) {
#line 167
      auth_debug_add("Matched negative entry in %.100s.", filename);
#line 169
      return (0);
    }
#line 172
    return (1);
  }
#line 176
  fclose(f);
#line 177
  return (0);
}
}
#line 186 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw___0 , char const   *client_user___0 ) 
{ char const   *hostname ;
  char const   *ipaddr ;
  int tmp ;

  {
#line 191
  hostname = get_canonical_hostname(options.use_dns);
#line 192
  ipaddr = get_remote_ipaddr();
#line 193
  tmp = auth_rhosts2(pw___0, client_user___0, hostname, ipaddr);
#line 193
  return (tmp);
}
}
#line 202
static int auth_rhosts2_raw(struct passwd *pw___0 , char const   *client_user___0 ,
                            char const   *hostname , char const   *ipaddr ) ;
#line 202 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 196 "auth-rhosts.c"
static int auth_rhosts2_raw(struct passwd *pw___0 , char const   *client_user___0 ,
                            char const   *hostname , char const   *ipaddr ) 
{ char buf___1[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 205
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user___0, hostname,
         ipaddr);
#line 209
  temporarily_use_uid(pw___0);
#line 215
  rhosts_file_index = 0U;
#line 215
  while (rhosts_files[rhosts_file_index]) {
#line 218
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw___0->pw_dir, rhosts_files[rhosts_file_index]);
#line 220
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 220
    if (tmp >= 0) {
#line 221
      break;
    }
#line 215
    rhosts_file_index ++;
  }
#line 224
  restore_uid();
#line 227
  if (! rhosts_files[rhosts_file_index]) {
#line 227
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 227
    if (tmp___0 < 0) {
#line 227
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 227
      if (tmp___1 < 0) {
#line 230
        return (0);
      }
    }
  }
#line 233
  if (pw___0->pw_uid != 0U) {
#line 234
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw___0->pw_name);
#line 234
    if (tmp___2) {
#line 236
      auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                     ipaddr);
#line 238
      return (1);
    }
#line 240
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw___0->pw_name);
#line 240
    if (tmp___3) {
#line 242
      auth_debug_add("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                     "/usr/local/etc/shosts.equiv");
#line 244
      return (1);
    }
  }
#line 251
  tmp___4 = stat((char const   * __restrict  )pw___0->pw_dir, (struct stat * __restrict  )(& st));
#line 251
  if (tmp___4 < 0) {
#line 252
    logit("Rhosts authentication refused for %.100s: no home directory %.200s", pw___0->pw_name,
          pw___0->pw_dir);
#line 254
    auth_debug_add("Rhosts authentication refused for %.100s: no home directory %.200s",
                   pw___0->pw_name, pw___0->pw_dir);
#line 256
    return (0);
  }
#line 258
  if (options.strict_modes) {
#line 258
    if (st.st_uid != 0U) {
#line 258
      if (st.st_uid != pw___0->pw_uid) {
#line 261
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw___0->pw_name);
#line 263
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw___0->pw_name);
#line 265
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 258
      if ((st.st_mode & 18U) != 0U) {
#line 261
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw___0->pw_name);
#line 263
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw___0->pw_name);
#line 265
        return (0);
      }
    }
  }
#line 268
  temporarily_use_uid(pw___0);
#line 271
  rhosts_file_index = 0U;
#line 271
  while (rhosts_files[rhosts_file_index]) {
#line 274
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw___0->pw_dir, rhosts_files[rhosts_file_index]);
#line 276
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 276
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 285
    if (options.strict_modes) {
#line 285
      if (st.st_uid != 0U) {
#line 285
        if (st.st_uid != pw___0->pw_uid) {
#line 288
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw___0->pw_name, buf___1);
#line 290
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 285
        if ((st.st_mode & 18U) != 0U) {
#line 288
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw___0->pw_name, buf___1);
#line 290
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 294
    if (options.ignore_rhosts) {
#line 295
      auth_debug_add("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 300
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user___0,
                                (char const   *)pw___0->pw_name);
#line 300
    if (tmp___6) {
#line 301
      auth_debug_add("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 304
      restore_uid();
#line 305
      auth_debug_add("Accepted host %s ip %s client_user %s server_user %s", hostname,
                     ipaddr, client_user___0, pw___0->pw_name);
#line 307
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 271
    rhosts_file_index ++;
  }
#line 312
  restore_uid();
#line 313
  return (0);
}
}
#line 316 "auth-rhosts.c"
int auth_rhosts2(struct passwd *pw___0 , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) 
{ int ret___0 ;

  {
#line 322
  auth_debug_reset();
#line 323
  ret___0 = auth_rhosts2_raw(pw___0, client_user___0, hostname, ipaddr);
#line 324
  if (! use_privsep) {
#line 325
    auth_debug_send();
  }
#line 326
  return (ret___0);
}
}
#line 1 "auth-passwd.o"
#pragma merger(0,"./auth-passwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 111 "auth.h"
int auth_password(Authctxt *authctxt___0 , char const   *password ) ;
#line 132
int auth_shadow_pwexpired(Authctxt *ctxt ) ;
#line 139
void disable_forwarding(void) ;
#line 192
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) ;
#line 25 "auth-options.h"
int no_port_forwarding_flag ;
#line 26
int no_agent_forwarding_flag ;
#line 27
int no_x11_forwarding_flag ;
#line 68 "auth-passwd.c"
void disable_forwarding(void) 
{ 

  {
#line 71
  no_port_forwarding_flag = 1;
#line 72
  no_agent_forwarding_flag = 1;
#line 73
  no_x11_forwarding_flag = 1;
#line 74
  return;
}
}
#line 86 "auth-passwd.c"
static int expire_checked  =    0;
#line 80 "auth-passwd.c"
int auth_password(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw___0 ;
  int result ;
  int ok ;
  int tmp ;
  int tmp___0 ;

  {
#line 83
  pw___0 = authctxt___0->pw;
#line 84
  ok = authctxt___0->valid;
#line 90
  if (pw___0->pw_uid == 0U) {
#line 90
    if (options.permit_root_login != 3) {
#line 91
      ok = 0;
    }
  }
#line 93
  if ((int const   )*password == 0) {
#line 93
    if (options.permit_empty_passwd == 0) {
#line 94
      return (0);
    }
  }
#line 119
  if (! expire_checked) {
#line 120
    expire_checked = 1;
#line 121
    tmp = auth_shadow_pwexpired(authctxt___0);
#line 121
    if (tmp) {
#line 122
      authctxt___0->force_pwchange = 1;
    }
  }
#line 125
  result = sys_auth_passwd(authctxt___0, password);
#line 126
  if (authctxt___0->force_pwchange) {
#line 127
    disable_forwarding();
  }
#line 128
  if (result) {
#line 128
    if (ok) {
#line 128
      tmp___0 = 1;
    } else {
#line 128
      tmp___0 = 0;
    }
  } else {
#line 128
    tmp___0 = 0;
  }
#line 128
  return (tmp___0);
}
}
#line 191 "auth-passwd.c"
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw___0 ;
  char *encrypted_password ;
  char *pw_password ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 194
  pw___0 = authctxt___0->pw;
#line 198
  if (authctxt___0->valid) {
#line 198
    tmp___0 = shadow_pw(pw___0);
  } else {
#line 198
    tmp___0 = pw___0->pw_passwd;
  }
#line 198
  pw_password = tmp___0;
#line 201
  if (0) {
#line 201
    __s1_len = strlen((char const   *)pw_password);
#line 201
    __s2_len = strlen("");
#line 201
    if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
      goto _L___0;
    } else {
#line 201
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 201
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 201
          tmp___10 = 1;
        } else {
#line 201
          if (__s2_len >= 4U) {
#line 201
            tmp___10 = 1;
          } else {
#line 201
            tmp___10 = 0;
          }
        }
      } else {
#line 201
        tmp___10 = 0;
      }
    }
#line 201
    if (tmp___10) {
#line 201
      tmp___6 = __builtin_strcmp((char const   *)pw_password, "");
    } else {
#line 201
      tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 201
      tmp___6 = tmp___9;
    }
  } else {
#line 201
    tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 201
    tmp___6 = tmp___9;
  }
#line 201
  if (tmp___6 == 0) {
#line 201
    if (0) {
#line 201
      __s1_len___0 = strlen(password);
#line 201
      __s2_len___0 = strlen("");
#line 201
      if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
        goto _L___2;
      } else {
#line 201
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 201
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 201
            tmp___20 = 1;
          } else {
#line 201
            if (__s2_len___0 >= 4U) {
#line 201
              tmp___20 = 1;
            } else {
#line 201
              tmp___20 = 0;
            }
          }
        } else {
#line 201
          tmp___20 = 0;
        }
      }
#line 201
      if (tmp___20) {
#line 201
        tmp___16 = __builtin_strcmp(password, "");
      } else {
#line 201
        tmp___19 = __builtin_strcmp(password, "");
#line 201
        tmp___16 = tmp___19;
      }
    } else {
#line 201
      tmp___19 = __builtin_strcmp(password, "");
#line 201
      tmp___16 = tmp___19;
    }
#line 201
    if (tmp___16 == 0) {
#line 202
      return (1);
    }
  }
#line 205
  if (*(pw_password + 0)) {
#line 205
    if (*(pw_password + 1)) {
#line 205
      tmp___21 = (char const   *)pw_password;
    } else {
#line 205
      tmp___21 = "xx";
    }
  } else {
#line 205
    tmp___21 = "xx";
  }
#line 205
  encrypted_password = xcrypt(password, tmp___21);
#line 212
  if (0) {
#line 212
    __s1_len___1 = strlen((char const   *)encrypted_password);
#line 212
    __s2_len___1 = strlen((char const   *)pw_password);
#line 212
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___4;
    } else {
#line 212
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 212
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 212
          tmp___31 = 1;
        } else {
#line 212
          if (__s2_len___1 >= 4U) {
#line 212
            tmp___31 = 1;
          } else {
#line 212
            tmp___31 = 0;
          }
        }
      } else {
#line 212
        tmp___31 = 0;
      }
    }
#line 212
    if (tmp___31) {
#line 212
      tmp___27 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 212
      tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 212
      tmp___27 = tmp___30;
    }
  } else {
#line 212
    tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 212
    tmp___27 = tmp___30;
  }
#line 212
  return (tmp___27 == 0);
}
}
#line 1 "auth-rsa.o"
#pragma merger(0,"./auth-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 34 "auth-options.h"
int auth_parse_options(struct passwd *pw___0 , char *opts , char *file___0 , u_long linenum ) ;
#line 35
void auth_clear_options(void) ;
#line 112 "auth.h"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) ;
#line 113
int auth_rsa_challenge_dialog(Key *key ) ;
#line 114
BIGNUM *auth_rsa_generate_challenge(Key *key ) ;
#line 115
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) ;
#line 116
int auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) ;
#line 170
char *authorized_keys_file(struct passwd *pw___0 ) ;
#line 173
FILE *auth_openkeyfile(char const   *file___0 , struct passwd *pw___0 , int strict_modes ) ;
#line 52 "monitor_wrap.h"
int mm_auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) ;
#line 53
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) ;
#line 54
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) ;
#line 70 "auth-rsa.c"
BIGNUM *auth_rsa_generate_challenge(Key *key ) 
{ BIGNUM *challenge ;
  BN_CTX *ctx ;
  int tmp ;
  int tmp___0 ;

  {
#line 76
  challenge = BN_new();
#line 76
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 77
    fatal("auth_rsa_generate_challenge: BN_new() failed");
  }
#line 79
  tmp = BN_rand(challenge, 256, 0, 0);
#line 79
  if (tmp == 0) {
#line 80
    fatal("auth_rsa_generate_challenge: BN_rand failed");
  }
#line 81
  ctx = BN_CTX_new();
#line 81
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 82
    fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
  }
#line 83
  tmp___0 = BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge,
                   (BIGNUM const   *)(key->rsa)->n, ctx);
#line 83
  if (tmp___0 == 0) {
#line 84
    fatal("auth_rsa_generate_challenge: BN_mod failed");
  }
#line 85
  BN_CTX_free(ctx);
#line 87
  return (challenge);
}
}
#line 90 "auth-rsa.c"
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) 
{ u_char buf___1[32] ;
  u_char mdbuf[16] ;
  MD5_CTX md ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 98
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 98
  if (tmp___0 < 768) {
#line 99
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 99
    error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
          tmp, 768);
#line 101
    return (0);
  }
#line 105
  tmp___1 = BN_num_bits((BIGNUM const   *)challenge);
#line 105
  len = (tmp___1 + 7) / 8;
#line 106
  if (len <= 0) {
#line 107
    fatal("auth_rsa_verify_response: bad challenge length %d", len);
  } else {
#line 106
    if (len > 32) {
#line 107
      fatal("auth_rsa_verify_response: bad challenge length %d", len);
    }
  }
#line 108
  memset((void *)(buf___1), 0, 32U);
#line 109
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 110
  MD5_Init(& md);
#line 111
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 112
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 113
  MD5_Final(mdbuf, & md);
#line 116
  tmp___2 = memcmp((void const   *)response, (void const   *)(mdbuf), 16U);
#line 116
  if (tmp___2 != 0) {
#line 118
    return (0);
  }
#line 121
  return (1);
}
}
#line 130 "auth-rsa.c"
int auth_rsa_challenge_dialog(Key *key ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  u_char response[16] ;
  int i ;
  int success ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 137
  encrypted_challenge = BN_new();
#line 137
  if ((unsigned int )encrypted_challenge == (unsigned int )((void *)0)) {
#line 138
    fatal("auth_rsa_challenge_dialog: BN_new() failed");
  }
#line 140
  if (use_privsep) {
#line 140
    challenge = mm_auth_rsa_generate_challenge(key);
  } else {
#line 140
    challenge = auth_rsa_generate_challenge(key);
  }
#line 143
  rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
#line 146
  packet_start((unsigned char)7);
#line 147
  packet_put_bignum(encrypted_challenge);
#line 148
  packet_send();
#line 149
  BN_clear_free(encrypted_challenge);
#line 150
  packet_write_wait();
#line 153
  packet_read_expect(8);
#line 154
  i = 0;
#line 154
  while (i < 16) {
#line 155
    tmp___1 = packet_get_char();
#line 155
    response[i] = (unsigned char )tmp___1;
#line 154
    i ++;
  }
#line 156
  while (1) {
#line 156
    tmp___2 = packet_remaining();
#line 156
    _len = tmp___2;
#line 156
    if (_len > 0) {
#line 156
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth-rsa.c",
            156);
#line 156
      packet_disconnect("Packet integrity error.");
    }
#line 156
    break;
  }
#line 158
  if (use_privsep) {
#line 158
    success = mm_auth_rsa_verify_response(key, challenge, response);
  } else {
#line 158
    success = auth_rsa_verify_response(key, challenge, (u_char *)(response));
  }
#line 159
  BN_clear_free(challenge);
#line 160
  return (success);
}
}
#line 168 "auth-rsa.c"
int auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) 
{ char line[8192] ;
  char *file___0 ;
  int allowed ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  Key *key ;
  char *cp ;
  char *key_options ;
  int keybits ;
  int quoted ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 172
  allowed = 0;
#line 175
  linenum = (u_long )0;
#line 179
  temporarily_use_uid(pw___0);
#line 182
  file___0 = authorized_keys_file(pw___0);
#line 183
  debug("trying public RSA key file %s", file___0);
#line 184
  f = auth_openkeyfile((char const   *)file___0, pw___0, options.strict_modes);
#line 185
  if (! f) {
#line 186
    xfree((void *)file___0);
#line 187
    restore_uid();
#line 188
    return (0);
  }
#line 192
  allowed = 0;
#line 194
  key = key_new(0);
#line 201
  while (1) {
#line 201
    tmp___3 = read_keyfile_line(f, (char const   *)file___0, line, sizeof(line), & linenum);
#line 201
    if (! (tmp___3 != -1)) {
#line 201
      break;
    }
#line 207
    cp = line;
#line 207
    while (1) {
#line 207
      if (! ((int )*cp == 32)) {
#line 207
        if (! ((int )*cp == 9)) {
#line 207
          break;
        }
      }
#line 207
      cp ++;
    }
#line 209
    if (! *cp) {
#line 210
      continue;
    } else {
#line 209
      if ((int )*cp == 10) {
#line 210
        continue;
      } else {
#line 209
        if ((int )*cp == 35) {
#line 210
          continue;
        }
      }
    }
#line 218
    if ((int )*cp < 48) {
      goto _L___0;
    } else {
#line 218
      if ((int )*cp > 57) {
        _L___0: /* CIL Label */ 
#line 219
        quoted = 0;
#line 220
        key_options = cp;
#line 221
        while (1) {
#line 221
          if (*cp) {
#line 221
            if (! quoted) {
#line 221
              if ((int )*cp != 32) {
#line 221
                if (! ((int )*cp != 9)) {
#line 221
                  break;
                }
              } else {
#line 221
                break;
              }
            }
          } else {
#line 221
            break;
          }
#line 222
          if ((int )*cp == 92) {
#line 222
            if ((int )*(cp + 1) == 34) {
#line 223
              cp ++;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 224
            if ((int )*cp == 34) {
#line 225
              quoted = ! quoted;
            }
          }
#line 221
          cp ++;
        }
      } else {
#line 228
        key_options = (char *)((void *)0);
      }
    }
#line 231
    tmp = hostfile_read_key(& cp, & bits, key);
#line 231
    if (tmp == 0) {
#line 232
      debug("%.100s, line %lu: non ssh1 key syntax", file___0, linenum);
#line 234
      continue;
    }
#line 239
    tmp___0 = BN_cmp((BIGNUM const   *)(key->rsa)->n, (BIGNUM const   *)client_n);
#line 239
    if (tmp___0 != 0) {
#line 240
      continue;
    }
#line 243
    keybits = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 244
    if (keybits < 0) {
#line 245
      tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 245
      logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
            file___0, linenum, tmp___1, bits);
    } else {
#line 244
      if (bits != (unsigned int )keybits) {
#line 245
        tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 245
        logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
              file___0, linenum, tmp___1, bits);
      }
    }
#line 254
    tmp___2 = auth_parse_options(pw___0, key_options, file___0, linenum);
#line 254
    if (! tmp___2) {
#line 255
      continue;
    }
#line 258
    allowed = 1;
#line 259
    break;
  }
#line 263
  restore_uid();
#line 266
  xfree((void *)file___0);
#line 267
  fclose(f);
#line 270
  if (allowed) {
#line 270
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 271
      *rkey = key;
    } else {
#line 273
      key_free(key);
    }
  } else {
#line 273
    key_free(key);
  }
#line 274
  return (allowed);
}
}
#line 282 "auth-rsa.c"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) 
{ Key *key ;
  char *fp ;
  struct passwd *pw___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 287
  pw___0 = authctxt___0->pw;
#line 290
  if (! authctxt___0->valid) {
#line 291
    return (0);
  }
#line 293
  if (use_privsep) {
#line 293
    tmp___1 = mm_auth_rsa_key_allowed(pw___0, client_n, & key);
  } else {
#line 293
    tmp___1 = auth_rsa_key_allowed(pw___0, client_n, & key);
  }
#line 293
  if (! tmp___1) {
#line 294
    auth_clear_options();
#line 295
    return (0);
  }
#line 299
  tmp___2 = auth_rsa_challenge_dialog(key);
#line 299
  if (! tmp___2) {
#line 301
    verbose("Wrong response to RSA authentication challenge.");
#line 302
    packet_send_debug("Wrong response to RSA authentication challenge.");
#line 307
    key_free(key);
#line 308
    return (0);
  }
#line 316
  fp = key_fingerprint((Key const   *)key, 1, 0);
#line 317
  tmp___3 = key_type((Key const   *)key);
#line 317
  verbose("Found matching %s key: %s", tmp___3, fp);
#line 319
  xfree((void *)fp);
#line 320
  key_free(key);
#line 322
  packet_send_debug("RSA authentication accepted.");
#line 323
  return (1);
}
}
#line 1 "auth-rh-rsa.o"
#pragma merger(0,"./auth-rh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 110 "auth.h"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) ;
#line 118
int auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *cuser , char *chost ,
                                Key *client_host_key ) ;
#line 175
HostStatus check_key_in_hostfiles(struct passwd *pw___0 , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) ;
#line 50 "monitor_wrap.h"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *user , char *host ,
                                   Key *key ) ;
#line 41 "auth-rh-rsa.c"
int auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *cuser , char *chost ,
                                Key *client_host_key ) 
{ HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 48
  tmp = auth_rhosts(pw___0, (char const   *)cuser);
#line 48
  if (! tmp) {
#line 49
    return (0);
  }
#line 51
  if (options.ignore_user_known_hosts) {
#line 51
    tmp___0 = (char const   *)((void *)0);
  } else {
#line 51
    tmp___0 = "~/.ssh/known_hosts";
  }
#line 51
  host_status = check_key_in_hostfiles(pw___0, client_host_key, (char const   *)chost,
                                       "/usr/local/etc/ssh_known_hosts", tmp___0);
#line 55
  return ((int )host_status == 0);
}
}
#line 62 "auth-rh-rsa.c"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) 
{ char *chost ;
  struct passwd *pw___0 ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 66
  pw___0 = authctxt___0->pw;
#line 68
  debug("Trying rhosts with RSA host authentication for client user %.100s", cuser);
#line 71
  if (! authctxt___0->valid) {
#line 73
    return (0);
  } else {
#line 71
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 73
      return (0);
    } else {
#line 71
      if ((unsigned int )client_host_key->rsa == (unsigned int )((void *)0)) {
#line 73
        return (0);
      }
    }
  }
#line 75
  tmp = get_canonical_hostname(options.use_dns);
#line 75
  chost = (char *)tmp;
#line 76
  debug("Rhosts RSA authentication: canonical host %.900s", chost);
#line 78
  if (use_privsep) {
#line 78
    tmp___2 = mm_auth_rhosts_rsa_key_allowed(pw___0, cuser, chost, client_host_key);
  } else {
#line 78
    tmp___2 = auth_rhosts_rsa_key_allowed(pw___0, cuser, chost, client_host_key);
  }
#line 78
  if (! tmp___2) {
#line 79
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 80
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 81
    return (0);
  }
#line 86
  tmp___3 = auth_rsa_challenge_dialog(client_host_key);
#line 86
  if (! tmp___3) {
#line 87
    logit("Client on %.800s failed to respond correctly to host authentication.",
          chost);
#line 89
    return (0);
  }
#line 96
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw___0->pw_name, cuser, chost);
#line 98
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 99
  return (1);
}
}
#line 1 "sshpty.o"
#pragma merger(0,"./sshpty.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 23 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) ;
#line 24
void pty_release(char const   *tty ) ;
#line 25
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) ;
#line 26
void pty_change_window_size(int ptyfd , u_int row , u_int col , u_int xpixel , u_int ypixel ) ;
#line 27
void pty_setowner(struct passwd *pw___0 , char const   *tty ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 63 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 70
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 71
  if (i < 0) {
#line 72
    tmp = __errno_location();
#line 72
    tmp___0 = strerror(*tmp);
#line 72
    error("openpty: %.100s", tmp___0);
#line 73
    return (0);
  }
#line 75
  name = ttyname(*ttyfd);
#line 76
  if (! name) {
#line 77
    fatal("openpty returns device for which ttyname fails.");
  }
#line 79
  strlcpy(namebuf, (char const   *)name, namebuflen);
#line 80
  return (1);
}
}
#line 85 "sshpty.c"
void pty_release(char const   *tty ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 89
  tmp___1 = chown(tty, 0U, 0U);
#line 89
  if (tmp___1 < 0) {
#line 90
    tmp = __errno_location();
#line 90
    tmp___0 = strerror(*tmp);
#line 90
    error("chown %.100s 0 0 failed: %.100s", tty, tmp___0);
  }
#line 91
  tmp___4 = chmod(tty, 438U);
#line 91
  if (tmp___4 < 0) {
#line 92
    tmp___2 = __errno_location();
#line 92
    tmp___3 = strerror(*tmp___2);
#line 92
    error("chmod %.100s 0666 failed: %.100s", tty, tmp___3);
  }
#line 94
  return;
}
}
#line 98 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void (*tmp___5)(int  ) ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 132
  fd = open("/dev/tty", 258);
#line 133
  if (fd >= 0) {
#line 134
    ioctl(fd, 21538UL, (void *)0);
#line 135
    close(fd);
  }
#line 138
  tmp___1 = setsid();
#line 138
  if (tmp___1 < 0) {
#line 139
    tmp = __errno_location();
#line 139
    tmp___0 = strerror(*tmp);
#line 139
    error("setsid: %.100s", tmp___0);
  }
#line 145
  fd = open("/dev/tty", 258);
#line 146
  if (fd >= 0) {
#line 147
    error("Failed to disconnect from controlling tty.");
#line 148
    close(fd);
  }
#line 152
  debug("Setting controlling tty using TIOCSCTTY.");
#line 153
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 153
  if (tmp___4 < 0) {
#line 154
    tmp___2 = __errno_location();
#line 154
    tmp___3 = strerror(*tmp___2);
#line 154
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 161
  tmp___5 = mysignal(1, (void (*)(int  ))1);
#line 161
  old = (void *)tmp___5;
#line 162
  vhangup();
#line 163
  mysignal(1, (void (*)(int  ))old);
#line 165
  fd = open(tty, 2);
#line 166
  if (fd < 0) {
#line 167
    tmp___6 = __errno_location();
#line 167
    tmp___7 = strerror(*tmp___6);
#line 167
    error("%.100s: %.100s", tty, tmp___7);
  } else {
#line 170
    close(*ttyfd);
#line 171
    *ttyfd = fd;
  }
#line 177
  fd = open("/dev/tty", 1);
#line 178
  if (fd < 0) {
#line 179
    tmp___8 = __errno_location();
#line 179
    tmp___9 = strerror(*tmp___8);
#line 179
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 182
    close(fd);
  }
#line 184
  return;
}
}
#line 188 "sshpty.c"
void pty_change_window_size(int ptyfd , u_int row , u_int col , u_int xpixel , u_int ypixel ) 
{ struct winsize w ;

  {
#line 195
  w.ws_row = (unsigned short )row;
#line 196
  w.ws_col = (unsigned short )col;
#line 197
  w.ws_xpixel = (unsigned short )xpixel;
#line 198
  w.ws_ypixel = (unsigned short )ypixel;
#line 199
  ioctl(ptyfd, 21524UL, & w);
#line 200
  return;
}
}
#line 202 "sshpty.c"
void pty_setowner(struct passwd *pw___0 , char const   *tty ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 211
  grp = getgrnam("tty");
#line 212
  if (grp) {
#line 213
    gid = grp->gr_gid;
#line 214
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 216
    gid = pw___0->pw_gid;
#line 217
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 225
  tmp___1 = stat((char const   * __restrict  )tty, (struct stat * __restrict  )(& st));
#line 225
  if (tmp___1) {
#line 226
    tmp = __errno_location();
#line 226
    tmp___0 = strerror(*tmp);
#line 226
    fatal("stat(%.100s) failed: %.100s", tty, tmp___0);
  }
#line 233
  if (st.st_uid != pw___0->pw_uid) {
    goto _L;
  } else {
#line 233
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 234
      tmp___7 = chown(tty, pw___0->pw_uid, gid);
#line 234
      if (tmp___7 < 0) {
#line 235
        tmp___6 = __errno_location();
#line 235
        if (*tmp___6 == 30) {
#line 235
          if (st.st_uid == pw___0->pw_uid) {
#line 237
            tmp___2 = __errno_location();
#line 237
            tmp___3 = strerror(*tmp___2);
#line 237
            debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                  tmp___3);
          } else {
#line 235
            if (st.st_uid == 0U) {
#line 237
              tmp___2 = __errno_location();
#line 237
              tmp___3 = strerror(*tmp___2);
#line 237
              debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                    tmp___3);
            } else {
#line 241
              tmp___4 = __errno_location();
#line 241
              tmp___5 = strerror(*tmp___4);
#line 241
              fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                    tmp___5);
            }
          }
        } else {
#line 241
          tmp___4 = __errno_location();
#line 241
          tmp___5 = strerror(*tmp___4);
#line 241
          fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                tmp___5);
        }
      }
    }
  }
#line 247
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 248
    tmp___13 = chmod(tty, mode);
#line 248
    if (tmp___13 < 0) {
#line 249
      tmp___12 = __errno_location();
#line 249
      if (*tmp___12 == 30) {
#line 249
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 251
          tmp___8 = __errno_location();
#line 251
          tmp___9 = strerror(*tmp___8);
#line 251
          debug("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___9);
        } else {
#line 254
          tmp___10 = __errno_location();
#line 254
          tmp___11 = strerror(*tmp___10);
#line 254
          fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
        }
      } else {
#line 254
        tmp___10 = __errno_location();
#line 254
        tmp___11 = strerror(*tmp___10);
#line 254
        fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
      }
    }
  }
#line 258
  return;
}
}
#line 1 "sshlogin.o"
#pragma merger(0,"./sshlogin.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 89 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 92
void login_free_entry(struct logininfo *li ) ;
#line 100
int login_login(struct logininfo *li ) ;
#line 101
int login_logout(struct logininfo *li ) ;
#line 113
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 120
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 71 "sshlogin.c"
time_t get_last_login_time(uid_t uid , char const   *logname , char *buf___1 , size_t bufsize ) 
{ struct logininfo li ;

  {
#line 77
  login_get_lastlog(& li, (int )uid);
#line 78
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 79
  return ((long )li.tv_sec);
}
}
#line 86 "sshlogin.c"
static void store_lastlog_message(char const   *user , uid_t uid ) 
{ char *time_string ;
  char hostname[64] ;
  char buf___1[512] ;
  time_t last_login_time ;
  unsigned int tmp___31 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t tmp___42 ;

  {
#line 89
  hostname[0] = (char )'\000';
#line 93
  if (! options.print_lastlog) {
#line 94
    return;
  }
#line 96
  last_login_time = get_last_login_time(uid, user, hostname, sizeof(hostname));
#line 99
  if (last_login_time != 0L) {
#line 100
    time_string = ctime((time_t const   *)(& last_login_time));
#line 101
    tmp___31 = __builtin_strcspn((char const   *)time_string, "\n");
#line 101
    *(time_string + tmp___31) = (char )'\000';
#line 102
    if (0) {
#line 102
      __s1_len = strlen((char const   *)(hostname));
#line 102
      __s2_len = strlen("");
#line 102
      if (! ((unsigned int )((void const   *)(hostname + 1)) - (unsigned int )((void const   *)(hostname)) == 1U)) {
        goto _L___0;
      } else {
#line 102
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 102
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 102
            tmp___41 = 1;
          } else {
#line 102
            if (__s2_len >= 4U) {
#line 102
              tmp___41 = 1;
            } else {
#line 102
              tmp___41 = 0;
            }
          }
        } else {
#line 102
          tmp___41 = 0;
        }
      }
#line 102
      if (tmp___41) {
#line 102
        tmp___37 = __builtin_strcmp((char const   *)(hostname), "");
      } else {
#line 102
        tmp___40 = __builtin_strcmp((char const   *)(hostname), "");
#line 102
        tmp___37 = tmp___40;
      }
    } else {
#line 102
      tmp___40 = __builtin_strcmp((char const   *)(hostname), "");
#line 102
      tmp___37 = tmp___40;
    }
#line 102
    if (tmp___37 == 0) {
#line 103
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Last login: %s\r\n",
               time_string);
    } else {
#line 106
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Last login: %s from %s\r\n",
               time_string, hostname);
    }
#line 108
    tmp___42 = strlen((char const   *)(buf___1));
#line 108
    buffer_append(& loginmsg, (void const   *)(buf___1), tmp___42);
  }
#line 111
  return;
}
}
#line 117 "sshlogin.c"
void record_login(pid_t pid , char const   *tty , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr , socklen_t addrlen ) 
{ struct logininfo *li ;

  {
#line 124
  store_lastlog_message(user, uid);
#line 126
  li = login_alloc_entry(pid, user, host, tty);
#line 127
  login_set_addr(li, (struct sockaddr  const  *)addr, addrlen);
#line 128
  login_login(li);
#line 129
  login_free_entry(li);
#line 130
  return;
}
}
#line 147 "sshlogin.c"
void record_logout(pid_t pid , char const   *tty , char const   *user ) 
{ struct logininfo *li ;

  {
#line 152
  li = login_alloc_entry(pid, user, (char const   *)((void *)0), tty);
#line 153
  login_logout(li);
#line 154
  login_free_entry(li);
#line 155
  return;
}
}
#line 1 "servconf.o"
#pragma merger(0,"./servconf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 165 "servconf.h"
void copy_set_server_options(ServerOptions *dst , ServerOptions *src , int preauth ) ;
#line 30 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 32
int ga_match_pattern_list(char const   *group_pattern ) ;
#line 33
void ga_free(void) ;
#line 45 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , int port___0 ) ;
#line 46
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , int port___0 ) ;
#line 54 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 57
  memset((void *)options___0, 0, sizeof(*options___0));
#line 60
  options___0->use_pam = -1;
#line 63
  options___0->num_ports = 0U;
#line 64
  options___0->ports_from_cmdline = 0U;
#line 65
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 66
  options___0->address_family = -1;
#line 67
  options___0->num_host_key_files = 0;
#line 68
  options___0->pid_file = (char *)((void *)0);
#line 69
  options___0->server_key_bits = -1;
#line 70
  options___0->login_grace_time = -1;
#line 71
  options___0->key_regeneration_time = -1;
#line 72
  options___0->permit_root_login = -1;
#line 73
  options___0->ignore_rhosts = -1;
#line 74
  options___0->ignore_user_known_hosts = -1;
#line 75
  options___0->print_motd = -1;
#line 76
  options___0->print_lastlog = -1;
#line 77
  options___0->x11_forwarding = -1;
#line 78
  options___0->x11_display_offset = -1;
#line 79
  options___0->x11_use_localhost = -1;
#line 80
  options___0->xauth_location = (char *)((void *)0);
#line 81
  options___0->strict_modes = -1;
#line 82
  options___0->tcp_keep_alive = -1;
#line 83
  options___0->log_facility = -1;
#line 84
  options___0->log_level = -1;
#line 85
  options___0->rhosts_rsa_authentication = -1;
#line 86
  options___0->hostbased_authentication = -1;
#line 87
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 88
  options___0->rsa_authentication = -1;
#line 89
  options___0->pubkey_authentication = -1;
#line 90
  options___0->kerberos_authentication = -1;
#line 91
  options___0->kerberos_or_local_passwd = -1;
#line 92
  options___0->kerberos_ticket_cleanup = -1;
#line 93
  options___0->kerberos_get_afs_token = -1;
#line 94
  options___0->gss_authentication = -1;
#line 95
  options___0->gss_cleanup_creds = -1;
#line 96
  options___0->password_authentication = -1;
#line 97
  options___0->kbd_interactive_authentication = -1;
#line 98
  options___0->challenge_response_authentication = -1;
#line 99
  options___0->permit_empty_passwd = -1;
#line 100
  options___0->permit_user_env = -1;
#line 101
  options___0->use_login = -1;
#line 102
  options___0->compression = -1;
#line 103
  options___0->allow_tcp_forwarding = -1;
#line 104
  options___0->allow_agent_forwarding = -1;
#line 105
  options___0->num_allow_users = 0U;
#line 106
  options___0->num_deny_users = 0U;
#line 107
  options___0->num_allow_groups = 0U;
#line 108
  options___0->num_deny_groups = 0U;
#line 109
  options___0->ciphers = (char *)((void *)0);
#line 110
  options___0->macs = (char *)((void *)0);
#line 111
  options___0->protocol = 0;
#line 112
  options___0->gateway_ports = -1;
#line 113
  options___0->num_subsystems = 0U;
#line 114
  options___0->max_startups_begin = -1;
#line 115
  options___0->max_startups_rate = -1;
#line 116
  options___0->max_startups = -1;
#line 117
  options___0->max_authtries = -1;
#line 118
  options___0->max_sessions = -1;
#line 119
  options___0->banner = (char *)((void *)0);
#line 120
  options___0->use_dns = -1;
#line 121
  options___0->client_alive_interval = -1;
#line 122
  options___0->client_alive_count_max = -1;
#line 123
  options___0->authorized_keys_file = (char *)((void *)0);
#line 124
  options___0->authorized_keys_file2 = (char *)((void *)0);
#line 125
  options___0->num_accept_env = 0U;
#line 126
  options___0->permit_tun = -1;
#line 127
  options___0->num_permitted_opens = -1;
#line 128
  options___0->adm_forced_command = (char *)((void *)0);
#line 129
  options___0->chroot_directory = (char *)((void *)0);
#line 130
  options___0->zero_knowledge_password_authentication = -1;
#line 131
  return;
}
}
#line 133 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;

  {
#line 137
  if (options___0->use_pam == -1) {
#line 138
    options___0->use_pam = 0;
  }
#line 141
  if (options___0->protocol == 0) {
#line 142
    options___0->protocol = 5;
  }
#line 143
  if (options___0->num_host_key_files == 0) {
#line 145
    if (options___0->protocol & 1) {
#line 146
      tmp = options___0->num_host_key_files;
#line 146
      (options___0->num_host_key_files) ++;
#line 146
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 148
    if (options___0->protocol & 4) {
#line 149
      tmp___0 = options___0->num_host_key_files;
#line 149
      (options___0->num_host_key_files) ++;
#line 149
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_rsa_key";
#line 151
      tmp___1 = options___0->num_host_key_files;
#line 151
      (options___0->num_host_key_files) ++;
#line 151
      options___0->host_key_files[tmp___1] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 155
  if (options___0->num_ports == 0U) {
#line 156
    tmp___2 = options___0->num_ports;
#line 156
    (options___0->num_ports) ++;
#line 156
    options___0->ports[tmp___2] = 22;
  }
#line 157
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 158
    add_listen_addr(options___0, (char *)((void *)0), 0);
  }
#line 159
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 160
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 161
  if (options___0->server_key_bits == -1) {
#line 162
    options___0->server_key_bits = 1024;
  }
#line 163
  if (options___0->login_grace_time == -1) {
#line 164
    options___0->login_grace_time = 120;
  }
#line 165
  if (options___0->key_regeneration_time == -1) {
#line 166
    options___0->key_regeneration_time = 3600;
  }
#line 167
  if (options___0->permit_root_login == -1) {
#line 168
    options___0->permit_root_login = 3;
  }
#line 169
  if (options___0->ignore_rhosts == -1) {
#line 170
    options___0->ignore_rhosts = 1;
  }
#line 171
  if (options___0->ignore_user_known_hosts == -1) {
#line 172
    options___0->ignore_user_known_hosts = 0;
  }
#line 173
  if (options___0->print_motd == -1) {
#line 174
    options___0->print_motd = 1;
  }
#line 175
  if (options___0->print_lastlog == -1) {
#line 176
    options___0->print_lastlog = 1;
  }
#line 177
  if (options___0->x11_forwarding == -1) {
#line 178
    options___0->x11_forwarding = 0;
  }
#line 179
  if (options___0->x11_display_offset == -1) {
#line 180
    options___0->x11_display_offset = 10;
  }
#line 181
  if (options___0->x11_use_localhost == -1) {
#line 182
    options___0->x11_use_localhost = 1;
  }
#line 183
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 184
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 185
  if (options___0->strict_modes == -1) {
#line 186
    options___0->strict_modes = 1;
  }
#line 187
  if (options___0->tcp_keep_alive == -1) {
#line 188
    options___0->tcp_keep_alive = 1;
  }
#line 189
  if ((int )options___0->log_facility == -1) {
#line 190
    options___0->log_facility = 2;
  }
#line 191
  if ((int )options___0->log_level == -1) {
#line 192
    options___0->log_level = 3;
  }
#line 193
  if (options___0->rhosts_rsa_authentication == -1) {
#line 194
    options___0->rhosts_rsa_authentication = 0;
  }
#line 195
  if (options___0->hostbased_authentication == -1) {
#line 196
    options___0->hostbased_authentication = 0;
  }
#line 197
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 198
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 199
  if (options___0->rsa_authentication == -1) {
#line 200
    options___0->rsa_authentication = 1;
  }
#line 201
  if (options___0->pubkey_authentication == -1) {
#line 202
    options___0->pubkey_authentication = 1;
  }
#line 203
  if (options___0->kerberos_authentication == -1) {
#line 204
    options___0->kerberos_authentication = 0;
  }
#line 205
  if (options___0->kerberos_or_local_passwd == -1) {
#line 206
    options___0->kerberos_or_local_passwd = 1;
  }
#line 207
  if (options___0->kerberos_ticket_cleanup == -1) {
#line 208
    options___0->kerberos_ticket_cleanup = 1;
  }
#line 209
  if (options___0->kerberos_get_afs_token == -1) {
#line 210
    options___0->kerberos_get_afs_token = 0;
  }
#line 211
  if (options___0->gss_authentication == -1) {
#line 212
    options___0->gss_authentication = 0;
  }
#line 213
  if (options___0->gss_cleanup_creds == -1) {
#line 214
    options___0->gss_cleanup_creds = 1;
  }
#line 215
  if (options___0->password_authentication == -1) {
#line 216
    options___0->password_authentication = 1;
  }
#line 217
  if (options___0->kbd_interactive_authentication == -1) {
#line 218
    options___0->kbd_interactive_authentication = 0;
  }
#line 219
  if (options___0->challenge_response_authentication == -1) {
#line 220
    options___0->challenge_response_authentication = 1;
  }
#line 221
  if (options___0->permit_empty_passwd == -1) {
#line 222
    options___0->permit_empty_passwd = 0;
  }
#line 223
  if (options___0->permit_user_env == -1) {
#line 224
    options___0->permit_user_env = 0;
  }
#line 225
  if (options___0->use_login == -1) {
#line 226
    options___0->use_login = 0;
  }
#line 227
  if (options___0->compression == -1) {
#line 228
    options___0->compression = 2;
  }
#line 229
  if (options___0->allow_tcp_forwarding == -1) {
#line 230
    options___0->allow_tcp_forwarding = 1;
  }
#line 231
  if (options___0->allow_agent_forwarding == -1) {
#line 232
    options___0->allow_agent_forwarding = 1;
  }
#line 233
  if (options___0->gateway_ports == -1) {
#line 234
    options___0->gateway_ports = 0;
  }
#line 235
  if (options___0->max_startups == -1) {
#line 236
    options___0->max_startups = 10;
  }
#line 237
  if (options___0->max_startups_rate == -1) {
#line 238
    options___0->max_startups_rate = 100;
  }
#line 239
  if (options___0->max_startups_begin == -1) {
#line 240
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 241
  if (options___0->max_authtries == -1) {
#line 242
    options___0->max_authtries = 6;
  }
#line 243
  if (options___0->max_sessions == -1) {
#line 244
    options___0->max_sessions = 10;
  }
#line 245
  if (options___0->use_dns == -1) {
#line 246
    options___0->use_dns = 1;
  }
#line 247
  if (options___0->client_alive_interval == -1) {
#line 248
    options___0->client_alive_interval = 0;
  }
#line 249
  if (options___0->client_alive_count_max == -1) {
#line 250
    options___0->client_alive_count_max = 3;
  }
#line 251
  if ((unsigned int )options___0->authorized_keys_file2 == (unsigned int )((void *)0)) {
#line 253
    if ((unsigned int )options___0->authorized_keys_file != (unsigned int )((void *)0)) {
#line 254
      options___0->authorized_keys_file2 = options___0->authorized_keys_file;
    } else {
#line 256
      options___0->authorized_keys_file2 = (char *)".ssh/authorized_keys2";
    }
  }
#line 258
  if ((unsigned int )options___0->authorized_keys_file == (unsigned int )((void *)0)) {
#line 259
    options___0->authorized_keys_file = (char *)".ssh/authorized_keys";
  }
#line 260
  if (options___0->permit_tun == -1) {
#line 261
    options___0->permit_tun = 0;
  }
#line 262
  if (options___0->zero_knowledge_password_authentication == -1) {
#line 263
    options___0->zero_knowledge_password_authentication = 0;
  }
#line 266
  if (use_privsep == -1) {
#line 267
    use_privsep = 1;
  }
#line 278
  return;
}
}
#line 317 "servconf.c"
static struct __anonstruct_keywords_80 keywords[80]  = 
#line 317
  {      {"usepam", 71, (u_int )1}, 
        {"pamauthenticationviakbdint", 70, (u_int )1}, 
        {"port", 2, (u_int )1}, 
        {"hostkey", 3, (u_int )1}, 
        {"hostdsakey", 3, (u_int )1}, 
        {"pidfile", 43, (u_int )1}, 
        {"serverkeybits", 4, (u_int )1}, 
        {"logingracetime", 5, (u_int )1}, 
        {"keyregenerationinterval", 6, (u_int )1}, 
        {"permitrootlogin", 7, (u_int )3}, 
        {"syslogfacility", 8, (u_int )1}, 
        {"loglevel", 9, (u_int )1}, 
        {"rhostsauthentication", 70, (u_int )1}, 
        {"rhostsrsaauthentication", 10, (u_int )3}, 
        {"hostbasedauthentication", 53, (u_int )3}, 
        {"hostbasedusesnamefrompacketonly", 54, (u_int )1}, 
        {"rsaauthentication", 11, (u_int )3}, 
        {"pubkeyauthentication", 45, (u_int )3}, 
        {"dsaauthentication", 45, (u_int )1}, 
        {"kerberosauthentication", 71, (u_int )3}, 
        {"kerberosorlocalpasswd", 71, (u_int )1}, 
        {"kerberosticketcleanup", 71, (u_int )1}, 
        {"kerberosgetafstoken", 71, (u_int )1}, 
        {"kerberostgtpassing", 71, (u_int )1}, 
        {"afstokenpassing", 71, (u_int )1}, 
        {"gssapiauthentication", 71, (u_int )3}, 
        {"gssapicleanupcredentials", 71, (u_int )1}, 
        {"passwordauthentication", 18, (u_int )3}, 
        {"kbdinteractiveauthentication", 19, (u_int )3}, 
        {"challengeresponseauthentication", 17, (u_int )1}, 
        {"skeyauthentication", 17, (u_int )1}, 
        {"zeroknowledgepasswordauthentication", 71, (u_int )3}, 
        {"checkmail", 70, (u_int )1}, 
        {"listenaddress", 20, (u_int )1}, 
        {"addressfamily", 21, (u_int )1}, 
        {"printmotd", 22, (u_int )1}, 
        {"printlastlog", 23, (u_int )1}, 
        {"ignorerhosts", 24, (u_int )1}, 
        {"ignoreuserknownhosts", 39, (u_int )1}, 
        {"x11forwarding", 25, (u_int )3}, 
        {"x11displayoffset", 26, (u_int )3}, 
        {"x11uselocalhost", 27, (u_int )3}, 
        {"xauthlocation", 46, (u_int )1}, 
        {"strictmodes", 28, (u_int )1}, 
        {"permitemptypasswords", 29, (u_int )3}, 
        {"permituserenvironment", 31, (u_int )1}, 
        {"uselogin", 32, (u_int )1}, 
        {"compression", 34, (u_int )1}, 
        {"tcpkeepalive", 30, (u_int )1}, 
        {"keepalive", 30, (u_int )1}, 
        {"allowtcpforwarding", 33, (u_int )3}, 
        {"allowagentforwarding", 68, (u_int )3}, 
        {"allowusers", 35, (u_int )1}, 
        {"denyusers", 36, (u_int )1}, 
        {"allowgroups", 37, (u_int )1}, 
        {"denygroups", 38, (u_int )1}, 
        {"ciphers", 40, (u_int )1}, 
        {"macs", 41, (u_int )1}, 
        {"protocol", 42, (u_int )1}, 
        {"gatewayports", 44, (u_int )3}, 
        {"subsystem", 47, (u_int )1}, 
        {"maxstartups", 48, (u_int )1}, 
        {"maxauthtries", 49, (u_int )3}, 
        {"maxsessions", 50, (u_int )3}, 
        {"banner", 51, (u_int )3}, 
        {"usedns", 52, (u_int )1}, 
        {"verifyreversemapping", 70, (u_int )1}, 
        {"reversemappingcheck", 70, (u_int )1}, 
        {"clientaliveinterval", 55, (u_int )1}, 
        {"clientalivecountmax", 56, (u_int )1}, 
        {"authorizedkeysfile", 57, (u_int )1}, 
        {"authorizedkeysfile2", 58, (u_int )1}, 
        {"useprivilegeseparation", 67, (u_int )1}, 
        {"acceptenv", 61, (u_int )1}, 
        {"permittunnel", 62, (u_int )1}, 
        {"match", 63, (u_int )3}, 
        {"permitopen", 64, (u_int )3}, 
        {"forcecommand", 65, (u_int )3}, 
        {"chrootdirectory", 66, (u_int )3}, 
        {(char const   *)((void *)0), 0, (u_int )0}};
#line 430 "servconf.c"
static struct __anonstruct_tunmode_desc_81 tunmode_desc[5]  = {      {0, (char *)"no"}, 
        {1, (char *)"point-to-point"}, 
        {2, (char *)"ethernet"}, 
        {3, (char *)"yes"}, 
        {-1, (char *)((void *)0)}};
#line 445 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ,
                                 u_int *flags ) 
{ u_int i ;
  int tmp ;

  {
#line 451
  i = 0U;
#line 451
  while (keywords[i].name) {
#line 452
    tmp = strcasecmp(cp, keywords[i].name);
#line 452
    if (tmp == 0) {
#line 453
      *flags = keywords[i].flags;
#line 454
      return (keywords[i].opcode);
    }
#line 451
    i ++;
  }
#line 457
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
#line 459
  return (0);
}
}
#line 462 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , int port___0 ) 
{ u_int i ;
  u_int tmp ;

  {
#line 467
  if (options___0->num_ports == 0U) {
#line 468
    tmp = options___0->num_ports;
#line 468
    (options___0->num_ports) ++;
#line 468
    options___0->ports[tmp] = 22;
  }
#line 469
  if (options___0->address_family == -1) {
#line 470
    options___0->address_family = 0;
  }
#line 471
  if (port___0 == 0) {
#line 472
    i = 0U;
#line 472
    while (i < options___0->num_ports) {
#line 473
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
#line 472
      i ++;
    }
  } else {
#line 475
    add_one_listen_addr(options___0, addr, port___0);
  }
#line 476
  return;
}
}
#line 478 "servconf.c"
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , int port___0 ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 485
  memset((void *)(& hints), 0, sizeof(hints));
#line 486
  hints.ai_family = options___0->address_family;
#line 487
  hints.ai_socktype = 1;
#line 488
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 488
    hints.ai_flags = 1;
  } else {
#line 488
    hints.ai_flags = 0;
  }
#line 489
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port___0);
#line 490
  gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 490
  if (gaierr != 0) {
#line 491
    tmp = ssh_gai_strerror(gaierr);
#line 491
    if (addr) {
#line 491
      tmp___0 = (char const   *)addr;
    } else {
#line 491
      tmp___0 = "<NULL>";
    }
#line 491
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
  }
#line 494
  ai = aitop;
#line 494
  while (ai->ai_next) {
#line 494
    ai = ai->ai_next;
  }
#line 496
  ai->ai_next = options___0->listen_addrs;
#line 497
  options___0->listen_addrs = aitop;
#line 498
  return;
}
}
#line 533 "servconf.c"
static int match_cfg_line_group(char const   *grps , int line , char const   *user ) 
{ int result ;
  struct passwd *pw___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 536
  result = 0;
#line 539
  if ((unsigned int )user == (unsigned int )((void *)0)) {
    goto out;
  }
#line 542
  pw___0 = getpwnam(user);
#line 542
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 543
    debug("Can\'t match group at line %d because user %.100s does not exist", line,
          user);
  } else {
#line 545
    tmp___0 = ga_init((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 545
    if (tmp___0 == 0) {
#line 546
      debug("Can\'t Match group because user %.100s not in any group at line %d",
            user, line);
    } else {
#line 548
      tmp = ga_match_pattern_list(grps);
#line 548
      if (tmp != 1) {
#line 549
        debug("user %.100s does not match group list %.100s at line %d", user, grps,
              line);
      } else {
#line 552
        debug("user %.100s matched group list %.100s at line %d", user, grps, line);
#line 554
        result = 1;
      }
    }
  }
  out: 
#line 557
  ga_free();
#line 558
  return (result);
}
}
#line 561 "servconf.c"
static int match_cfg_line(char **condition , int line , char const   *user , char const   *host ,
                          char const   *address ) 
{ int result ;
  char *arg ;
  char *attrib ;
  char *cp ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;

  {
#line 565
  result = 1;
#line 566
  cp = *condition;
#line 569
  if ((unsigned int )user == (unsigned int )((void *)0)) {
#line 570
    debug3("checking syntax for \'Match %s\'", cp);
  } else {
#line 572
    if (address) {
#line 572
      tmp = address;
    } else {
#line 572
      tmp = "(null)";
    }
#line 572
    if (host) {
#line 572
      tmp___0 = host;
    } else {
#line 572
      tmp___0 = "(null)";
    }
#line 572
    if (user) {
#line 572
      tmp___1 = user;
    } else {
#line 572
      tmp___1 = "(null)";
    }
#line 572
    debug3("checking match for \'%s\' user %s host %s addr %s", cp, tmp___1, tmp___0,
           tmp);
  }
#line 576
  while (1) {
#line 576
    attrib = strdelim(& cp);
#line 576
    if (attrib) {
#line 576
      if (! ((int )*attrib != 0)) {
#line 576
        break;
      }
    } else {
#line 576
      break;
    }
#line 577
    arg = strdelim(& cp);
#line 577
    if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 578
      error("Missing Match criteria for %s", attrib);
#line 579
      return (-1);
    } else {
#line 577
      if ((int )*arg == 0) {
#line 578
        error("Missing Match criteria for %s", attrib);
#line 579
        return (-1);
      }
    }
#line 581
    len = strlen((char const   *)arg);
#line 582
    tmp___9 = strcasecmp((char const   *)attrib, "user");
#line 582
    if (tmp___9 == 0) {
#line 583
      if (! user) {
#line 584
        result = 0;
#line 585
        continue;
      }
#line 587
      tmp___2 = match_pattern_list(user, (char const   *)arg, len, 0);
#line 587
      if (tmp___2 != 1) {
#line 588
        result = 0;
      } else {
#line 590
        debug("user %.100s matched \'User %.100s\' at line %d", user, arg, line);
      }
    } else {
#line 592
      tmp___8 = strcasecmp((char const   *)attrib, "group");
#line 592
      if (tmp___8 == 0) {
#line 593
        tmp___3 = match_cfg_line_group((char const   *)arg, line, user);
#line 593
        switch (tmp___3) {
        case -1: 
#line 595
        return (-1);
        case 0: 
#line 597
        result = 0;
        }
      } else {
#line 599
        tmp___7 = strcasecmp((char const   *)attrib, "host");
#line 599
        if (tmp___7 == 0) {
#line 600
          if (! host) {
#line 601
            result = 0;
#line 602
            continue;
          }
#line 604
          tmp___4 = match_hostname(host, (char const   *)arg, len);
#line 604
          if (tmp___4 != 1) {
#line 605
            result = 0;
          } else {
#line 607
            debug("connection from %.100s matched \'Host %.100s\' at line %d", host,
                  arg, line);
          }
        } else {
#line 609
          tmp___6 = strcasecmp((char const   *)attrib, "address");
#line 609
          if (tmp___6 == 0) {
#line 610
            tmp___5 = addr_match_list(address, (char const   *)arg);
#line 610
            switch (tmp___5) {
            case 1: 
#line 612
            debug("connection from %.100s matched \'Address %.100s\' at line %d",
                  address, arg, line);
#line 614
            break;
            case 0: 
            case -1: 
#line 617
            result = 0;
#line 618
            break;
            case -2: 
#line 620
            return (-1);
            }
          } else {
#line 623
            error("Unsupported Match attribute %s", attrib);
#line 624
            return (-1);
          }
        }
      }
    }
  }
#line 627
  if ((unsigned int )user != (unsigned int )((void *)0)) {
#line 628
    if (result) {
#line 628
      tmp___10 = "";
    } else {
#line 628
      tmp___10 = "not ";
    }
#line 628
    debug3("match %sfound", tmp___10);
  }
#line 629
  *condition = cp;
#line 630
  return (result);
}
}
#line 635 "servconf.c"
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum , int *activep , char const   *user , char const   *host ,
                               char const   *address ) 
{ char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int cmdline ;
  int *intptr ;
  int value ;
  int n___0 ;
  SyslogFacility *log_facility_ptr ;
  LogLevel *log_level_ptr ;
  ServerOpCodes opcode ;
  int port___0 ;
  u_int i ;
  u_int flags ;
  size_t len ;
  u_int tmp ;
  long tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  __uid_t tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___56 ;
  int tmp___59 ;
  int tmp___60 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___66 ;
  int tmp___69 ;
  int tmp___70 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___76 ;
  int tmp___79 ;
  int tmp___80 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___86 ;
  int tmp___89 ;
  int tmp___90 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___96 ;
  int tmp___99 ;
  int tmp___100 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___106 ;
  int tmp___109 ;
  int tmp___110 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___116 ;
  int tmp___119 ;
  int tmp___120 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___126 ;
  int tmp___129 ;
  int tmp___130 ;
  SyslogFacility tmp___131 ;
  char const   *tmp___132 ;
  LogLevel tmp___133 ;
  char const   *tmp___134 ;
  u_int tmp___135 ;
  u_int tmp___136 ;
  u_int tmp___137 ;
  u_int tmp___138 ;
  char const   *tmp___139 ;
  int tmp___140 ;
  char const   *tmp___141 ;
  int tmp___142 ;
  char const   *tmp___143 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___149 ;
  int tmp___152 ;
  int tmp___153 ;
  size_t tmp___154 ;
  size_t tmp___155 ;
  void *tmp___156 ;
  char *tmp___158 ;
  u_int tmp___159 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___165 ;
  int tmp___168 ;
  int tmp___169 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___175 ;
  int tmp___178 ;
  int tmp___179 ;
  unsigned int tmp___211 ;

  {
#line 641
  cmdline = 0;
#line 646
  flags = (u_int )0;
#line 649
  cp = line;
#line 650
  arg = strdelim(& cp);
#line 650
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 651
    return (0);
  }
#line 653
  if ((int )*arg == 0) {
#line 654
    arg = strdelim(& cp);
  }
#line 655
  if (! arg) {
#line 656
    return (0);
  } else {
#line 655
    if (! *arg) {
#line 656
      return (0);
    } else {
#line 655
      if ((int )*arg == 35) {
#line 656
        return (0);
      }
    }
  }
#line 657
  intptr = (int *)((void *)0);
#line 658
  charptr = (char **)((void *)0);
#line 659
  opcode = parse_token((char const   *)arg, filename, linenum, & flags);
#line 661
  if ((unsigned int )activep == (unsigned int )((void *)0)) {
#line 662
    cmdline = 1;
#line 663
    activep = & cmdline;
  }
#line 665
  if (*activep) {
#line 665
    if ((int )opcode != 63) {
#line 666
      debug3("%s:%d setting %s %s", filename, linenum, arg, cp);
    }
  }
#line 667
  if (*activep == 0) {
#line 667
    if (! (flags & 2U)) {
#line 668
      if ((unsigned int )user == (unsigned int )((void *)0)) {
#line 669
        fatal("%s line %d: Directive \'%s\' is not allowed within a Match block",
              filename, linenum, arg);
      } else {
#line 672
        while (arg) {
#line 673
          arg = strdelim(& cp);
        }
#line 674
        return (0);
      }
    }
  }
#line 678
  switch ((int )opcode) {
  case 1: 
#line 681
  intptr = & options___0->use_pam;
  goto parse_flag;
  case 0: 
#line 686
  return (-1);
  case 2: 
#line 689
  if (options___0->ports_from_cmdline) {
#line 690
    return (0);
  }
#line 691
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 692
    fatal("%s line %d: ports must be specified before ListenAddress.", filename, linenum);
  }
#line 694
  if (options___0->num_ports >= 256U) {
#line 695
    fatal("%s line %d: too many ports.", filename, linenum);
  }
#line 697
  arg = strdelim(& cp);
#line 698
  if (! arg) {
#line 699
    fatal("%s line %d: missing port number.", filename, linenum);
  } else {
#line 698
    if ((int )*arg == 0) {
#line 699
      fatal("%s line %d: missing port number.", filename, linenum);
    }
  }
#line 701
  tmp = options___0->num_ports;
#line 701
  (options___0->num_ports) ++;
#line 701
  options___0->ports[tmp] = a2port((char const   *)arg);
#line 702
  if (options___0->ports[options___0->num_ports - 1U] <= 0) {
#line 703
    fatal("%s line %d: Badly formatted port number.", filename, linenum);
  }
#line 705
  break;
  case 4: 
#line 708
  intptr = & options___0->server_key_bits;
  parse_int: 
#line 710
  arg = strdelim(& cp);
#line 711
  if (! arg) {
#line 712
    fatal("%s line %d: missing integer value.", filename, linenum);
  } else {
#line 711
    if ((int )*arg == 0) {
#line 712
      fatal("%s line %d: missing integer value.", filename, linenum);
    }
  }
#line 714
  value = atoi((char const   *)arg);
#line 715
  if (*activep) {
#line 715
    if (*intptr == -1) {
#line 716
      *intptr = value;
    }
  }
#line 717
  break;
  case 5: 
#line 720
  intptr = & options___0->login_grace_time;
  parse_time: 
#line 722
  arg = strdelim(& cp);
#line 723
  if (! arg) {
#line 724
    fatal("%s line %d: missing time value.", filename, linenum);
  } else {
#line 723
    if ((int )*arg == 0) {
#line 724
      fatal("%s line %d: missing time value.", filename, linenum);
    }
  }
#line 726
  tmp___0 = convtime((char const   *)arg);
#line 726
  value = (int )tmp___0;
#line 726
  if (value == -1) {
#line 727
    fatal("%s line %d: invalid time value.", filename, linenum);
  }
#line 729
  if (*intptr == -1) {
#line 730
    *intptr = value;
  }
#line 731
  break;
  case 6: 
#line 734
  intptr = & options___0->key_regeneration_time;
  goto parse_time;
  case 20: 
#line 738
  arg = strdelim(& cp);
#line 739
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 740
    fatal("%s line %d: missing address", filename, linenum);
  } else {
#line 739
    if ((int )*arg == 0) {
#line 740
      fatal("%s line %d: missing address", filename, linenum);
    }
  }
#line 743
  tmp___2 = __builtin_strchr(arg, '[');
#line 743
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 743
    tmp___4 = __builtin_strchr(arg, ':');
#line 743
    p = tmp___4;
#line 743
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 743
      tmp___6 = __builtin_strchr(p + 1, ':');
#line 743
      if ((unsigned int )tmp___6 != (unsigned int )((void *)0)) {
#line 745
        add_listen_addr(options___0, arg, 0);
#line 746
        break;
      }
    }
  }
#line 748
  p = hpdelim(& arg);
#line 749
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 750
    fatal("%s line %d: bad address:port usage", filename, linenum);
  }
#line 752
  p = cleanhostname(p);
#line 753
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 754
    port___0 = 0;
  } else {
#line 755
    port___0 = a2port((char const   *)arg);
#line 755
    if (port___0 <= 0) {
#line 756
      fatal("%s line %d: bad port number", filename, linenum);
    }
  }
#line 758
  add_listen_addr(options___0, p, port___0);
#line 760
  break;
  case 21: 
#line 763
  arg = strdelim(& cp);
#line 764
  if (! arg) {
#line 765
    fatal("%s line %d: missing address family.", filename, linenum);
  } else {
#line 764
    if ((int )*arg == 0) {
#line 765
      fatal("%s line %d: missing address family.", filename, linenum);
    }
  }
#line 767
  intptr = & options___0->address_family;
#line 768
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 769
    fatal("%s line %d: address family must be specified before ListenAddress.", filename,
          linenum);
  }
#line 771
  tmp___9 = strcasecmp((char const   *)arg, "inet");
#line 771
  if (tmp___9 == 0) {
#line 772
    value = 2;
  } else {
#line 773
    tmp___8 = strcasecmp((char const   *)arg, "inet6");
#line 773
    if (tmp___8 == 0) {
#line 774
      value = 10;
    } else {
#line 775
      tmp___7 = strcasecmp((char const   *)arg, "any");
#line 775
      if (tmp___7 == 0) {
#line 776
        value = 0;
      } else {
#line 778
        fatal("%s line %d: unsupported address family \"%s\".", filename, linenum,
              arg);
      }
    }
  }
#line 780
  if (*intptr == -1) {
#line 781
    *intptr = value;
  }
#line 782
  break;
  case 3: 
#line 785
  intptr = & options___0->num_host_key_files;
#line 786
  if (*intptr >= 256) {
#line 787
    fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
          256);
  }
#line 789
  charptr = & options___0->host_key_files[*intptr];
  parse_filename: 
#line 791
  arg = strdelim(& cp);
#line 792
  if (! arg) {
#line 793
    fatal("%s line %d: missing file name.", filename, linenum);
  } else {
#line 792
    if ((int )*arg == 0) {
#line 793
      fatal("%s line %d: missing file name.", filename, linenum);
    }
  }
#line 795
  if (*activep) {
#line 795
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 796
      tmp___10 = getuid();
#line 796
      *charptr = tilde_expand_filename((char const   *)arg, tmp___10);
#line 798
      if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 799
        (*intptr) ++;
      }
    }
  }
#line 801
  break;
  case 43: 
#line 804
  charptr = & options___0->pid_file;
  goto parse_filename;
  case 7: 
#line 808
  intptr = & options___0->permit_root_login;
#line 809
  arg = strdelim(& cp);
#line 810
  if (! arg) {
#line 811
    fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
          filename, linenum);
  } else {
#line 810
    if ((int )*arg == 0) {
#line 811
      fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
            filename, linenum);
    }
  }
#line 814
  value = 0;
#line 815
  if (0) {
#line 815
    __s1_len___2 = strlen((char const   *)arg);
#line 815
    __s2_len___2 = strlen("without-password");
#line 815
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___6;
    } else {
#line 815
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 815
        if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 815
          tmp___50 = 1;
        } else {
#line 815
          if (__s2_len___2 >= 4U) {
#line 815
            tmp___50 = 1;
          } else {
#line 815
            tmp___50 = 0;
          }
        }
      } else {
#line 815
        tmp___50 = 0;
      }
    }
#line 815
    if (tmp___50) {
#line 815
      tmp___46 = __builtin_strcmp((char const   *)arg, "without-password");
    } else {
#line 815
      tmp___49 = __builtin_strcmp((char const   *)arg, "without-password");
#line 815
      tmp___46 = tmp___49;
    }
  } else {
#line 815
    tmp___49 = __builtin_strcmp((char const   *)arg, "without-password");
#line 815
    tmp___46 = tmp___49;
  }
#line 815
  if (tmp___46 == 0) {
#line 816
    value = 2;
  } else {
#line 817
    if (0) {
#line 817
      __s1_len___1 = strlen((char const   *)arg);
#line 817
      __s2_len___1 = strlen("forced-commands-only");
#line 817
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___4;
      } else {
#line 817
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 817
          if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 817
            tmp___40 = 1;
          } else {
#line 817
            if (__s2_len___1 >= 4U) {
#line 817
              tmp___40 = 1;
            } else {
#line 817
              tmp___40 = 0;
            }
          }
        } else {
#line 817
          tmp___40 = 0;
        }
      }
#line 817
      if (tmp___40) {
#line 817
        tmp___36 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
      } else {
#line 817
        tmp___39 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 817
        tmp___36 = tmp___39;
      }
    } else {
#line 817
      tmp___39 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 817
      tmp___36 = tmp___39;
    }
#line 817
    if (tmp___36 == 0) {
#line 818
      value = 1;
    } else {
#line 819
      if (0) {
#line 819
        __s1_len___0 = strlen((char const   *)arg);
#line 819
        __s2_len___0 = strlen("yes");
#line 819
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___2;
        } else {
#line 819
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 819
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 819
              tmp___30 = 1;
            } else {
#line 819
              if (__s2_len___0 >= 4U) {
#line 819
                tmp___30 = 1;
              } else {
#line 819
                tmp___30 = 0;
              }
            }
          } else {
#line 819
            tmp___30 = 0;
          }
        }
#line 819
        if (tmp___30) {
#line 819
          tmp___26 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 819
          tmp___29 = __builtin_strcmp((char const   *)arg, "yes");
#line 819
          tmp___26 = tmp___29;
        }
      } else {
#line 819
        tmp___29 = __builtin_strcmp((char const   *)arg, "yes");
#line 819
        tmp___26 = tmp___29;
      }
#line 819
      if (tmp___26 == 0) {
#line 820
        value = 3;
      } else {
#line 821
        if (0) {
#line 821
          __s1_len = strlen((char const   *)arg);
#line 821
          __s2_len = strlen("no");
#line 821
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___0;
          } else {
#line 821
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 821
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 821
                tmp___20 = 1;
              } else {
#line 821
                if (__s2_len >= 4U) {
#line 821
                  tmp___20 = 1;
                } else {
#line 821
                  tmp___20 = 0;
                }
              }
            } else {
#line 821
              tmp___20 = 0;
            }
          }
#line 821
          if (tmp___20) {
#line 821
            tmp___16 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 821
            tmp___19 = __builtin_strcmp((char const   *)arg, "no");
#line 821
            tmp___16 = tmp___19;
          }
        } else {
#line 821
          tmp___19 = __builtin_strcmp((char const   *)arg, "no");
#line 821
          tmp___16 = tmp___19;
        }
#line 821
        if (tmp___16 == 0) {
#line 822
          value = 0;
        } else {
#line 824
          fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                filename, linenum, arg);
        }
      }
    }
  }
#line 827
  if (*activep) {
#line 827
    if (*intptr == -1) {
#line 828
      *intptr = value;
    }
  }
#line 829
  break;
  case 24: 
#line 832
  intptr = & options___0->ignore_rhosts;
  parse_flag: 
#line 834
  arg = strdelim(& cp);
#line 835
  if (! arg) {
#line 836
    fatal("%s line %d: missing yes/no argument.", filename, linenum);
  } else {
#line 835
    if ((int )*arg == 0) {
#line 836
      fatal("%s line %d: missing yes/no argument.", filename, linenum);
    }
  }
#line 838
  value = 0;
#line 839
  if (0) {
#line 839
    __s1_len___4 = strlen((char const   *)arg);
#line 839
    __s2_len___4 = strlen("yes");
#line 839
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___10;
    } else {
#line 839
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 839
        if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 839
          tmp___70 = 1;
        } else {
#line 839
          if (__s2_len___4 >= 4U) {
#line 839
            tmp___70 = 1;
          } else {
#line 839
            tmp___70 = 0;
          }
        }
      } else {
#line 839
        tmp___70 = 0;
      }
    }
#line 839
    if (tmp___70) {
#line 839
      tmp___66 = __builtin_strcmp((char const   *)arg, "yes");
    } else {
#line 839
      tmp___69 = __builtin_strcmp((char const   *)arg, "yes");
#line 839
      tmp___66 = tmp___69;
    }
  } else {
#line 839
    tmp___69 = __builtin_strcmp((char const   *)arg, "yes");
#line 839
    tmp___66 = tmp___69;
  }
#line 839
  if (tmp___66 == 0) {
#line 840
    value = 1;
  } else {
#line 841
    if (0) {
#line 841
      __s1_len___3 = strlen((char const   *)arg);
#line 841
      __s2_len___3 = strlen("no");
#line 841
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 841
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 841
          if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 841
            tmp___60 = 1;
          } else {
#line 841
            if (__s2_len___3 >= 4U) {
#line 841
              tmp___60 = 1;
            } else {
#line 841
              tmp___60 = 0;
            }
          }
        } else {
#line 841
          tmp___60 = 0;
        }
      }
#line 841
      if (tmp___60) {
#line 841
        tmp___56 = __builtin_strcmp((char const   *)arg, "no");
      } else {
#line 841
        tmp___59 = __builtin_strcmp((char const   *)arg, "no");
#line 841
        tmp___56 = tmp___59;
      }
    } else {
#line 841
      tmp___59 = __builtin_strcmp((char const   *)arg, "no");
#line 841
      tmp___56 = tmp___59;
    }
#line 841
    if (tmp___56 == 0) {
#line 842
      value = 0;
    } else {
#line 844
      fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
    }
  }
#line 846
  if (*activep) {
#line 846
    if (*intptr == -1) {
#line 847
      *intptr = value;
    }
  }
#line 848
  break;
  case 39: 
#line 851
  intptr = & options___0->ignore_user_known_hosts;
  goto parse_flag;
  case 10: 
#line 855
  intptr = & options___0->rhosts_rsa_authentication;
  goto parse_flag;
  case 53: 
#line 859
  intptr = & options___0->hostbased_authentication;
  goto parse_flag;
  case 54: 
#line 863
  intptr = & options___0->hostbased_uses_name_from_packet_only;
  goto parse_flag;
  case 11: 
#line 867
  intptr = & options___0->rsa_authentication;
  goto parse_flag;
  case 45: 
#line 871
  intptr = & options___0->pubkey_authentication;
  goto parse_flag;
  case 12: 
#line 875
  intptr = & options___0->kerberos_authentication;
  goto parse_flag;
  case 13: 
#line 879
  intptr = & options___0->kerberos_or_local_passwd;
  goto parse_flag;
  case 14: 
#line 883
  intptr = & options___0->kerberos_ticket_cleanup;
  goto parse_flag;
  case 15: 
#line 887
  intptr = & options___0->kerberos_get_afs_token;
  goto parse_flag;
  case 59: 
#line 891
  intptr = & options___0->gss_authentication;
  goto parse_flag;
  case 60: 
#line 895
  intptr = & options___0->gss_cleanup_creds;
  goto parse_flag;
  case 18: 
#line 899
  intptr = & options___0->password_authentication;
  goto parse_flag;
  case 69: 
#line 903
  intptr = & options___0->zero_knowledge_password_authentication;
  goto parse_flag;
  case 19: 
#line 907
  intptr = & options___0->kbd_interactive_authentication;
  goto parse_flag;
  case 17: 
#line 911
  intptr = & options___0->challenge_response_authentication;
  goto parse_flag;
  case 22: 
#line 915
  intptr = & options___0->print_motd;
  goto parse_flag;
  case 23: 
#line 919
  intptr = & options___0->print_lastlog;
  goto parse_flag;
  case 25: 
#line 923
  intptr = & options___0->x11_forwarding;
  goto parse_flag;
  case 26: 
#line 927
  intptr = & options___0->x11_display_offset;
  goto parse_int;
  case 27: 
#line 931
  intptr = & options___0->x11_use_localhost;
  goto parse_flag;
  case 46: 
#line 935
  charptr = & options___0->xauth_location;
  goto parse_filename;
  case 28: 
#line 939
  intptr = & options___0->strict_modes;
  goto parse_flag;
  case 30: 
#line 943
  intptr = & options___0->tcp_keep_alive;
  goto parse_flag;
  case 29: 
#line 947
  intptr = & options___0->permit_empty_passwd;
  goto parse_flag;
  case 31: 
#line 951
  intptr = & options___0->permit_user_env;
  goto parse_flag;
  case 32: 
#line 955
  intptr = & options___0->use_login;
  goto parse_flag;
  case 34: 
#line 959
  intptr = & options___0->compression;
#line 960
  arg = strdelim(& cp);
#line 961
  if (! arg) {
#line 962
    fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
  } else {
#line 961
    if ((int )*arg == 0) {
#line 962
      fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
    }
  }
#line 964
  value = 0;
#line 965
  if (0) {
#line 965
    __s1_len___7 = strlen((char const   *)arg);
#line 965
    __s2_len___7 = strlen("delayed");
#line 965
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___16;
    } else {
#line 965
      if (__s1_len___7 >= 4U) {
        _L___16: /* CIL Label */ 
#line 965
        if (! ((unsigned int )((void const   *)("delayed" + 1)) - (unsigned int )((void const   *)"delayed") == 1U)) {
#line 965
          tmp___100 = 1;
        } else {
#line 965
          if (__s2_len___7 >= 4U) {
#line 965
            tmp___100 = 1;
          } else {
#line 965
            tmp___100 = 0;
          }
        }
      } else {
#line 965
        tmp___100 = 0;
      }
    }
#line 965
    if (tmp___100) {
#line 965
      tmp___96 = __builtin_strcmp((char const   *)arg, "delayed");
    } else {
#line 965
      tmp___99 = __builtin_strcmp((char const   *)arg, "delayed");
#line 965
      tmp___96 = tmp___99;
    }
  } else {
#line 965
    tmp___99 = __builtin_strcmp((char const   *)arg, "delayed");
#line 965
    tmp___96 = tmp___99;
  }
#line 965
  if (tmp___96 == 0) {
#line 966
    value = 2;
  } else {
#line 967
    if (0) {
#line 967
      __s1_len___6 = strlen((char const   *)arg);
#line 967
      __s2_len___6 = strlen("yes");
#line 967
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___14;
      } else {
#line 967
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 967
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 967
            tmp___90 = 1;
          } else {
#line 967
            if (__s2_len___6 >= 4U) {
#line 967
              tmp___90 = 1;
            } else {
#line 967
              tmp___90 = 0;
            }
          }
        } else {
#line 967
          tmp___90 = 0;
        }
      }
#line 967
      if (tmp___90) {
#line 967
        tmp___86 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 967
        tmp___89 = __builtin_strcmp((char const   *)arg, "yes");
#line 967
        tmp___86 = tmp___89;
      }
    } else {
#line 967
      tmp___89 = __builtin_strcmp((char const   *)arg, "yes");
#line 967
      tmp___86 = tmp___89;
    }
#line 967
    if (tmp___86 == 0) {
#line 968
      value = 1;
    } else {
#line 969
      if (0) {
#line 969
        __s1_len___5 = strlen((char const   *)arg);
#line 969
        __s2_len___5 = strlen("no");
#line 969
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___12;
        } else {
#line 969
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 969
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 969
              tmp___80 = 1;
            } else {
#line 969
              if (__s2_len___5 >= 4U) {
#line 969
                tmp___80 = 1;
              } else {
#line 969
                tmp___80 = 0;
              }
            }
          } else {
#line 969
            tmp___80 = 0;
          }
        }
#line 969
        if (tmp___80) {
#line 969
          tmp___76 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 969
          tmp___79 = __builtin_strcmp((char const   *)arg, "no");
#line 969
          tmp___76 = tmp___79;
        }
      } else {
#line 969
        tmp___79 = __builtin_strcmp((char const   *)arg, "no");
#line 969
        tmp___76 = tmp___79;
      }
#line 969
      if (tmp___76 == 0) {
#line 970
        value = 0;
      } else {
#line 972
        fatal("%s line %d: Bad yes/no/delayed argument: %s", filename, linenum, arg);
      }
    }
  }
#line 974
  if (*intptr == -1) {
#line 975
    *intptr = value;
  }
#line 976
  break;
  case 44: 
#line 979
  intptr = & options___0->gateway_ports;
#line 980
  arg = strdelim(& cp);
#line 981
  if (! arg) {
#line 982
    fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
  } else {
#line 981
    if ((int )*arg == 0) {
#line 982
      fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
    }
  }
#line 984
  value = 0;
#line 985
  if (0) {
#line 985
    __s1_len___10 = strlen((char const   *)arg);
#line 985
    __s2_len___10 = strlen("clientspecified");
#line 985
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___22;
    } else {
#line 985
      if (__s1_len___10 >= 4U) {
        _L___22: /* CIL Label */ 
#line 985
        if (! ((unsigned int )((void const   *)("clientspecified" + 1)) - (unsigned int )((void const   *)"clientspecified") == 1U)) {
#line 985
          tmp___130 = 1;
        } else {
#line 985
          if (__s2_len___10 >= 4U) {
#line 985
            tmp___130 = 1;
          } else {
#line 985
            tmp___130 = 0;
          }
        }
      } else {
#line 985
        tmp___130 = 0;
      }
    }
#line 985
    if (tmp___130) {
#line 985
      tmp___126 = __builtin_strcmp((char const   *)arg, "clientspecified");
    } else {
#line 985
      tmp___129 = __builtin_strcmp((char const   *)arg, "clientspecified");
#line 985
      tmp___126 = tmp___129;
    }
  } else {
#line 985
    tmp___129 = __builtin_strcmp((char const   *)arg, "clientspecified");
#line 985
    tmp___126 = tmp___129;
  }
#line 985
  if (tmp___126 == 0) {
#line 986
    value = 2;
  } else {
#line 987
    if (0) {
#line 987
      __s1_len___9 = strlen((char const   *)arg);
#line 987
      __s2_len___9 = strlen("yes");
#line 987
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___20;
      } else {
#line 987
        if (__s1_len___9 >= 4U) {
          _L___20: /* CIL Label */ 
#line 987
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 987
            tmp___120 = 1;
          } else {
#line 987
            if (__s2_len___9 >= 4U) {
#line 987
              tmp___120 = 1;
            } else {
#line 987
              tmp___120 = 0;
            }
          }
        } else {
#line 987
          tmp___120 = 0;
        }
      }
#line 987
      if (tmp___120) {
#line 987
        tmp___116 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 987
        tmp___119 = __builtin_strcmp((char const   *)arg, "yes");
#line 987
        tmp___116 = tmp___119;
      }
    } else {
#line 987
      tmp___119 = __builtin_strcmp((char const   *)arg, "yes");
#line 987
      tmp___116 = tmp___119;
    }
#line 987
    if (tmp___116 == 0) {
#line 988
      value = 1;
    } else {
#line 989
      if (0) {
#line 989
        __s1_len___8 = strlen((char const   *)arg);
#line 989
        __s2_len___8 = strlen("no");
#line 989
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___18;
        } else {
#line 989
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 989
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 989
              tmp___110 = 1;
            } else {
#line 989
              if (__s2_len___8 >= 4U) {
#line 989
                tmp___110 = 1;
              } else {
#line 989
                tmp___110 = 0;
              }
            }
          } else {
#line 989
            tmp___110 = 0;
          }
        }
#line 989
        if (tmp___110) {
#line 989
          tmp___106 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 989
          tmp___109 = __builtin_strcmp((char const   *)arg, "no");
#line 989
          tmp___106 = tmp___109;
        }
      } else {
#line 989
        tmp___109 = __builtin_strcmp((char const   *)arg, "no");
#line 989
        tmp___106 = tmp___109;
      }
#line 989
      if (tmp___106 == 0) {
#line 990
        value = 0;
      } else {
#line 992
        fatal("%s line %d: Bad yes/no/clientspecified argument: %s", filename, linenum,
              arg);
      }
    }
  }
#line 994
  if (*activep) {
#line 994
    if (*intptr == -1) {
#line 995
      *intptr = value;
    }
  }
#line 996
  break;
  case 52: 
#line 999
  intptr = & options___0->use_dns;
  goto parse_flag;
  case 8: 
#line 1003
  log_facility_ptr = & options___0->log_facility;
#line 1004
  arg = strdelim(& cp);
#line 1005
  tmp___131 = log_facility_number(arg);
#line 1005
  value = (int )tmp___131;
#line 1006
  if (value == -1) {
#line 1007
    if (arg) {
#line 1007
      tmp___132 = (char const   *)arg;
    } else {
#line 1007
      tmp___132 = "<NONE>";
    }
#line 1007
    fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum, tmp___132);
  }
#line 1009
  if ((int )*log_facility_ptr == -1) {
#line 1010
    *log_facility_ptr = (int )value;
  }
#line 1011
  break;
  case 9: 
#line 1014
  log_level_ptr = & options___0->log_level;
#line 1015
  arg = strdelim(& cp);
#line 1016
  tmp___133 = log_level_number(arg);
#line 1016
  value = (int )tmp___133;
#line 1017
  if (value == -1) {
#line 1018
    if (arg) {
#line 1018
      tmp___134 = (char const   *)arg;
    } else {
#line 1018
      tmp___134 = "<NONE>";
    }
#line 1018
    fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___134);
  }
#line 1020
  if ((int )*log_level_ptr == -1) {
#line 1021
    *log_level_ptr = (enum __anonenum_LogLevel_51 )value;
  }
#line 1022
  break;
  case 33: 
#line 1025
  intptr = & options___0->allow_tcp_forwarding;
  goto parse_flag;
  case 68: 
#line 1029
  intptr = & options___0->allow_agent_forwarding;
  goto parse_flag;
  case 67: 
#line 1033
  intptr = & use_privsep;
  goto parse_flag;
  case 35: 
#line 1037
  while (1) {
#line 1037
    arg = strdelim(& cp);
#line 1037
    if (arg) {
#line 1037
      if (! ((int )*arg != 0)) {
#line 1037
        break;
      }
    } else {
#line 1037
      break;
    }
#line 1038
    if (options___0->num_allow_users >= 256U) {
#line 1039
      fatal("%s line %d: too many allow users.", filename, linenum);
    }
#line 1041
    tmp___135 = options___0->num_allow_users;
#line 1041
    (options___0->num_allow_users) ++;
#line 1041
    options___0->allow_users[tmp___135] = xstrdup((char const   *)arg);
  }
#line 1044
  break;
  case 36: 
#line 1047
  while (1) {
#line 1047
    arg = strdelim(& cp);
#line 1047
    if (arg) {
#line 1047
      if (! ((int )*arg != 0)) {
#line 1047
        break;
      }
    } else {
#line 1047
      break;
    }
#line 1048
    if (options___0->num_deny_users >= 256U) {
#line 1049
      fatal("%s line %d: too many deny users.", filename, linenum);
    }
#line 1051
    tmp___136 = options___0->num_deny_users;
#line 1051
    (options___0->num_deny_users) ++;
#line 1051
    options___0->deny_users[tmp___136] = xstrdup((char const   *)arg);
  }
#line 1054
  break;
  case 37: 
#line 1057
  while (1) {
#line 1057
    arg = strdelim(& cp);
#line 1057
    if (arg) {
#line 1057
      if (! ((int )*arg != 0)) {
#line 1057
        break;
      }
    } else {
#line 1057
      break;
    }
#line 1058
    if (options___0->num_allow_groups >= 256U) {
#line 1059
      fatal("%s line %d: too many allow groups.", filename, linenum);
    }
#line 1061
    tmp___137 = options___0->num_allow_groups;
#line 1061
    (options___0->num_allow_groups) ++;
#line 1061
    options___0->allow_groups[tmp___137] = xstrdup((char const   *)arg);
  }
#line 1064
  break;
  case 38: 
#line 1067
  while (1) {
#line 1067
    arg = strdelim(& cp);
#line 1067
    if (arg) {
#line 1067
      if (! ((int )*arg != 0)) {
#line 1067
        break;
      }
    } else {
#line 1067
      break;
    }
#line 1068
    if (options___0->num_deny_groups >= 256U) {
#line 1069
      fatal("%s line %d: too many deny groups.", filename, linenum);
    }
#line 1071
    tmp___138 = options___0->num_deny_groups;
#line 1071
    (options___0->num_deny_groups) ++;
#line 1071
    options___0->deny_groups[tmp___138] = xstrdup((char const   *)arg);
  }
#line 1073
  break;
  case 40: 
#line 1076
  arg = strdelim(& cp);
#line 1077
  if (! arg) {
#line 1078
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 1077
    if ((int )*arg == 0) {
#line 1078
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 1079
  tmp___140 = ciphers_valid((char const   *)arg);
#line 1079
  if (! tmp___140) {
#line 1080
    if (arg) {
#line 1080
      tmp___139 = (char const   *)arg;
    } else {
#line 1080
      tmp___139 = "<NONE>";
    }
#line 1080
    fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___139);
  }
#line 1082
  if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 1083
    options___0->ciphers = xstrdup((char const   *)arg);
  }
#line 1084
  break;
  case 41: 
#line 1087
  arg = strdelim(& cp);
#line 1088
  if (! arg) {
#line 1089
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 1088
    if ((int )*arg == 0) {
#line 1089
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 1090
  tmp___142 = mac_valid((char const   *)arg);
#line 1090
  if (! tmp___142) {
#line 1091
    if (arg) {
#line 1091
      tmp___141 = (char const   *)arg;
    } else {
#line 1091
      tmp___141 = "<NONE>";
    }
#line 1091
    fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___141);
  }
#line 1093
  if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 1094
    options___0->macs = xstrdup((char const   *)arg);
  }
#line 1095
  break;
  case 42: 
#line 1098
  intptr = & options___0->protocol;
#line 1099
  arg = strdelim(& cp);
#line 1100
  if (! arg) {
#line 1101
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 1100
    if ((int )*arg == 0) {
#line 1101
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 1102
  value = proto_spec((char const   *)arg);
#line 1103
  if (value == 0) {
#line 1104
    if (arg) {
#line 1104
      tmp___143 = (char const   *)arg;
    } else {
#line 1104
      tmp___143 = "<NONE>";
    }
#line 1104
    fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___143);
  }
#line 1106
  if (*intptr == 0) {
#line 1107
    *intptr = value;
  }
#line 1108
  break;
  case 47: 
#line 1111
  if (options___0->num_subsystems >= 256U) {
#line 1112
    fatal("%s line %d: too many subsystems defined.", filename, linenum);
  }
#line 1115
  arg = strdelim(& cp);
#line 1116
  if (! arg) {
#line 1117
    fatal("%s line %d: Missing subsystem name.", filename, linenum);
  } else {
#line 1116
    if ((int )*arg == 0) {
#line 1117
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    }
  }
#line 1119
  if (! *activep) {
#line 1120
    arg = strdelim(& cp);
#line 1121
    break;
  }
#line 1123
  i = 0U;
#line 1123
  while (i < options___0->num_subsystems) {
#line 1124
    if (0) {
#line 1124
      __s1_len___11 = strlen((char const   *)arg);
#line 1124
      __s2_len___11 = strlen((char const   *)options___0->subsystem_name[i]);
#line 1124
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___24;
      } else {
#line 1124
        if (__s1_len___11 >= 4U) {
          _L___24: /* CIL Label */ 
#line 1124
          if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 1124
            tmp___153 = 1;
          } else {
#line 1124
            if (__s2_len___11 >= 4U) {
#line 1124
              tmp___153 = 1;
            } else {
#line 1124
              tmp___153 = 0;
            }
          }
        } else {
#line 1124
          tmp___153 = 0;
        }
      }
#line 1124
      if (tmp___153) {
#line 1124
        tmp___149 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
      } else {
#line 1124
        tmp___152 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 1124
        tmp___149 = tmp___152;
      }
    } else {
#line 1124
      tmp___152 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 1124
      tmp___149 = tmp___152;
    }
#line 1124
    if (tmp___149 == 0) {
#line 1125
      fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum, arg);
    }
#line 1123
    i ++;
  }
#line 1127
  options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 1128
  arg = strdelim(& cp);
#line 1129
  if (! arg) {
#line 1130
    fatal("%s line %d: Missing subsystem command.", filename, linenum);
  } else {
#line 1129
    if ((int )*arg == 0) {
#line 1130
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    }
  }
#line 1132
  options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 1135
  p = xstrdup((char const   *)arg);
#line 1136
  tmp___154 = strlen((char const   *)p);
#line 1136
  len = tmp___154 + 1U;
#line 1137
  while (1) {
#line 1137
    arg = strdelim(& cp);
#line 1137
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 1137
      if (! ((int )*arg != 0)) {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1138
    tmp___155 = strlen((char const   *)arg);
#line 1138
    len += 1U + tmp___155;
#line 1139
    tmp___156 = xrealloc((void *)p, 1U, len);
#line 1139
    p = (char *)tmp___156;
#line 1140
    strlcat(p, " ", len);
#line 1141
    strlcat(p, (char const   *)arg, len);
  }
#line 1143
  options___0->subsystem_args[options___0->num_subsystems] = p;
#line 1144
  (options___0->num_subsystems) ++;
#line 1145
  break;
  case 48: 
#line 1148
  arg = strdelim(& cp);
#line 1149
  if (! arg) {
#line 1150
    fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
  } else {
#line 1149
    if ((int )*arg == 0) {
#line 1150
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    }
  }
#line 1152
  n___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                 & options___0->max_startups_begin, & options___0->max_startups_rate,
                 & options___0->max_startups);
#line 1152
  if (n___0 == 3) {
#line 1156
    if (options___0->max_startups_begin > options___0->max_startups) {
#line 1160
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 1156
      if (options___0->max_startups_rate > 100) {
#line 1160
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 1156
        if (options___0->max_startups_rate < 1) {
#line 1160
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        }
      }
    }
  } else {
#line 1162
    if (n___0 != 1) {
#line 1163
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 1166
      options___0->max_startups = options___0->max_startups_begin;
    }
  }
#line 1167
  break;
  case 49: 
#line 1170
  intptr = & options___0->max_authtries;
  goto parse_int;
  case 50: 
#line 1174
  intptr = & options___0->max_sessions;
  goto parse_int;
  case 51: 
#line 1178
  charptr = & options___0->banner;
  goto parse_filename;
  case 57: 
  case 58: 
#line 1189
  if ((int )opcode == 57) {
#line 1189
    charptr = & options___0->authorized_keys_file;
  } else {
#line 1189
    charptr = & options___0->authorized_keys_file2;
  }
  goto parse_filename;
  case 55: 
#line 1195
  intptr = & options___0->client_alive_interval;
  goto parse_time;
  case 56: 
#line 1199
  intptr = & options___0->client_alive_count_max;
  goto parse_int;
  case 61: 
#line 1203
  while (1) {
#line 1203
    arg = strdelim(& cp);
#line 1203
    if (arg) {
#line 1203
      if (! ((int )*arg != 0)) {
#line 1203
        break;
      }
    } else {
#line 1203
      break;
    }
#line 1204
    tmp___158 = __builtin_strchr(arg, '=');
#line 1204
    if ((unsigned int )tmp___158 != (unsigned int )((void *)0)) {
#line 1205
      fatal("%s line %d: Invalid environment name.", filename, linenum);
    }
#line 1207
    if (options___0->num_accept_env >= 256U) {
#line 1208
      fatal("%s line %d: too many allow env.", filename, linenum);
    }
#line 1210
    if (! *activep) {
#line 1211
      break;
    }
#line 1212
    tmp___159 = options___0->num_accept_env;
#line 1212
    (options___0->num_accept_env) ++;
#line 1212
    options___0->accept_env[tmp___159] = xstrdup((char const   *)arg);
  }
#line 1215
  break;
  case 62: 
#line 1218
  intptr = & options___0->permit_tun;
#line 1219
  arg = strdelim(& cp);
#line 1220
  if (! arg) {
#line 1221
    fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
          linenum);
  } else {
#line 1220
    if ((int )*arg == 0) {
#line 1221
      fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
            linenum);
    }
  }
#line 1223
  value = -1;
#line 1224
  i = 0U;
#line 1224
  while (tunmode_desc[i].val != -1) {
#line 1225
    if (0) {
#line 1225
      __s1_len___12 = strlen((char const   *)tunmode_desc[i].text);
#line 1225
      __s2_len___12 = strlen((char const   *)arg);
#line 1225
      if (! ((unsigned int )((void const   *)(tunmode_desc[i].text + 1)) - (unsigned int )((void const   *)tunmode_desc[i].text) == 1U)) {
        goto _L___26;
      } else {
#line 1225
        if (__s1_len___12 >= 4U) {
          _L___26: /* CIL Label */ 
#line 1225
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
#line 1225
            tmp___169 = 1;
          } else {
#line 1225
            if (__s2_len___12 >= 4U) {
#line 1225
              tmp___169 = 1;
            } else {
#line 1225
              tmp___169 = 0;
            }
          }
        } else {
#line 1225
          tmp___169 = 0;
        }
      }
#line 1225
      if (tmp___169) {
#line 1225
        tmp___165 = __builtin_strcmp((char const   *)tunmode_desc[i].text, (char const   *)arg);
      } else {
#line 1225
        tmp___168 = __builtin_strcmp((char const   *)tunmode_desc[i].text, (char const   *)arg);
#line 1225
        tmp___165 = tmp___168;
      }
    } else {
#line 1225
      tmp___168 = __builtin_strcmp((char const   *)tunmode_desc[i].text, (char const   *)arg);
#line 1225
      tmp___165 = tmp___168;
    }
#line 1225
    if (tmp___165 == 0) {
#line 1226
      value = tunmode_desc[i].val;
#line 1227
      break;
    }
#line 1224
    i ++;
  }
#line 1229
  if (value == -1) {
#line 1230
    fatal("%s line %d: Bad yes/point-to-point/ethernet/no argument: %s", filename,
          linenum, arg);
  }
#line 1232
  if (*intptr == -1) {
#line 1233
    *intptr = value;
  }
#line 1234
  break;
  case 63: 
#line 1237
  if (cmdline) {
#line 1238
    fatal("Match directive not supported as a command-line option");
  }
#line 1240
  value = match_cfg_line(& cp, linenum, user, host, address);
#line 1241
  if (value < 0) {
#line 1242
    fatal("%s line %d: Bad Match condition", filename, linenum);
  }
#line 1244
  *activep = value;
#line 1245
  break;
  case 64: 
#line 1248
  arg = strdelim(& cp);
#line 1249
  if (! arg) {
#line 1250
    fatal("%s line %d: missing PermitOpen specification", filename, linenum);
  } else {
#line 1249
    if ((int )*arg == 0) {
#line 1250
      fatal("%s line %d: missing PermitOpen specification", filename, linenum);
    }
  }
#line 1252
  n___0 = options___0->num_permitted_opens;
#line 1253
  if (0) {
#line 1253
    __s1_len___13 = strlen((char const   *)arg);
#line 1253
    __s2_len___13 = strlen("any");
#line 1253
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___28;
    } else {
#line 1253
      if (__s1_len___13 >= 4U) {
        _L___28: /* CIL Label */ 
#line 1253
        if (! ((unsigned int )((void const   *)("any" + 1)) - (unsigned int )((void const   *)"any") == 1U)) {
#line 1253
          tmp___179 = 1;
        } else {
#line 1253
          if (__s2_len___13 >= 4U) {
#line 1253
            tmp___179 = 1;
          } else {
#line 1253
            tmp___179 = 0;
          }
        }
      } else {
#line 1253
        tmp___179 = 0;
      }
    }
#line 1253
    if (tmp___179) {
#line 1253
      tmp___175 = __builtin_strcmp((char const   *)arg, "any");
    } else {
#line 1253
      tmp___178 = __builtin_strcmp((char const   *)arg, "any");
#line 1253
      tmp___175 = tmp___178;
    }
  } else {
#line 1253
    tmp___178 = __builtin_strcmp((char const   *)arg, "any");
#line 1253
    tmp___175 = tmp___178;
  }
#line 1253
  if (tmp___175 == 0) {
#line 1254
    if (*activep) {
#line 1254
      if (n___0 == -1) {
#line 1255
        channel_clear_adm_permitted_opens();
#line 1256
        options___0->num_permitted_opens = 0;
      }
    }
#line 1258
    break;
  }
#line 1260
  if (*activep) {
#line 1260
    if (n___0 == -1) {
#line 1261
      channel_clear_adm_permitted_opens();
    }
  }
#line 1262
  while (1) {
#line 1262
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 1262
      if (! ((int )*arg != 0)) {
#line 1262
        break;
      }
    } else {
#line 1262
      break;
    }
#line 1263
    p = hpdelim(& arg);
#line 1264
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1265
      fatal("%s line %d: missing host in PermitOpen", filename, linenum);
    }
#line 1267
    p = cleanhostname(p);
#line 1268
    if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 1269
      fatal("%s line %d: bad port number in PermitOpen", filename, linenum);
    } else {
#line 1268
      port___0 = a2port((char const   *)arg);
#line 1268
      if (port___0 <= 0) {
#line 1269
        fatal("%s line %d: bad port number in PermitOpen", filename, linenum);
      }
    }
#line 1271
    if (*activep) {
#line 1271
      if (n___0 == -1) {
#line 1272
        options___0->num_permitted_opens = channel_add_adm_permitted_opens(p, port___0);
      }
    }
#line 1262
    arg = strdelim(& cp);
  }
#line 1275
  break;
  case 65: 
#line 1278
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1279
    fatal("%.200s line %d: Missing argument.", filename, linenum);
  }
#line 1281
  tmp___211 = __builtin_strspn((char const   *)cp, " \t\r\n");
#line 1281
  len = tmp___211;
#line 1282
  if (*activep) {
#line 1282
    if ((unsigned int )options___0->adm_forced_command == (unsigned int )((void *)0)) {
#line 1283
      options___0->adm_forced_command = xstrdup((char const   *)(cp + len));
    }
  }
#line 1284
  return (0);
  case 66: 
#line 1287
  charptr = & options___0->chroot_directory;
#line 1289
  arg = strdelim(& cp);
#line 1290
  if (! arg) {
#line 1291
    fatal("%s line %d: missing file name.", filename, linenum);
  } else {
#line 1290
    if ((int )*arg == 0) {
#line 1291
      fatal("%s line %d: missing file name.", filename, linenum);
    }
  }
#line 1293
  if (*activep) {
#line 1293
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 1294
      *charptr = xstrdup((char const   *)arg);
    }
  }
#line 1295
  break;
  case 70: 
#line 1298
  logit("%s line %d: Deprecated option %s", filename, linenum, arg);
#line 1300
  while (arg) {
#line 1301
    arg = strdelim(& cp);
  }
#line 1302
  break;
  case 71: 
#line 1305
  logit("%s line %d: Unsupported option %s", filename, linenum, arg);
#line 1307
  while (arg) {
#line 1308
    arg = strdelim(& cp);
  }
#line 1309
  break;
  default: 
#line 1312
  fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
        opcode);
  }
#line 1315
  arg = strdelim(& cp);
#line 1315
  if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 1315
    if ((int )*arg != 0) {
#line 1316
      fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
            arg);
    }
  }
#line 1318
  return (0);
}
}
#line 1323 "servconf.c"
void load_server_config(char const   *filename , Buffer *conf ) 
{ char line[1024] ;
  char *cp ;
  FILE *f ;
  char *tmp___0 ;
  unsigned int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  u_int tmp___35 ;

  {
#line 1329
  debug2("%s: filename %s", "load_server_config", filename);
#line 1330
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 1330
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 1331
    perror(filename);
#line 1332
    exit(1);
  }
#line 1334
  buffer_clear(conf);
#line 1335
  while (1) {
#line 1335
    tmp___34 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 1335
    if (! tmp___34) {
#line 1335
      break;
    }
#line 1341
    tmp___0 = __builtin_strchr(line, '#');
#line 1341
    cp = tmp___0;
#line 1341
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1342
      memcpy((void * __restrict  )cp, (void const   * __restrict  )"\n", 2U);
    }
#line 1343
    tmp___32 = __builtin_strspn((char const   *)(line), " \t\r");
#line 1343
    cp = line + tmp___32;
#line 1345
    tmp___33 = strlen((char const   *)cp);
#line 1345
    buffer_append(conf, (void const   *)cp, tmp___33);
  }
#line 1347
  buffer_append(conf, (void const   *)"\000", 1U);
#line 1348
  fclose(f);
#line 1349
  tmp___35 = buffer_len(conf);
#line 1349
  debug2("%s: done config len = %d", "load_server_config", tmp___35);
#line 1350
  return;
}
}
#line 1352 "servconf.c"
void parse_server_match_config(ServerOptions *options___0 , char const   *user , char const   *host ,
                               char const   *address ) 
{ ServerOptions mo ;

  {
#line 1358
  initialize_server_options(& mo);
#line 1359
  parse_server_config(& mo, "reprocess config", & cfg, user, host, address);
#line 1360
  copy_set_server_options(options___0, & mo, 0);
#line 1361
  return;
}
}
#line 1383 "servconf.c"
void copy_set_server_options(ServerOptions *dst , ServerOptions *src , int preauth ) 
{ 

  {
#line 1386
  while (1) {
#line 1386
    if (src->password_authentication != -1) {
#line 1386
      dst->password_authentication = src->password_authentication;
    }
#line 1386
    break;
  }
#line 1387
  while (1) {
#line 1387
    if (src->gss_authentication != -1) {
#line 1387
      dst->gss_authentication = src->gss_authentication;
    }
#line 1387
    break;
  }
#line 1388
  while (1) {
#line 1388
    if (src->rsa_authentication != -1) {
#line 1388
      dst->rsa_authentication = src->rsa_authentication;
    }
#line 1388
    break;
  }
#line 1389
  while (1) {
#line 1389
    if (src->pubkey_authentication != -1) {
#line 1389
      dst->pubkey_authentication = src->pubkey_authentication;
    }
#line 1389
    break;
  }
#line 1390
  while (1) {
#line 1390
    if (src->kerberos_authentication != -1) {
#line 1390
      dst->kerberos_authentication = src->kerberos_authentication;
    }
#line 1390
    break;
  }
#line 1391
  while (1) {
#line 1391
    if (src->hostbased_authentication != -1) {
#line 1391
      dst->hostbased_authentication = src->hostbased_authentication;
    }
#line 1391
    break;
  }
#line 1392
  while (1) {
#line 1392
    if (src->kbd_interactive_authentication != -1) {
#line 1392
      dst->kbd_interactive_authentication = src->kbd_interactive_authentication;
    }
#line 1392
    break;
  }
#line 1393
  while (1) {
#line 1393
    if (src->zero_knowledge_password_authentication != -1) {
#line 1393
      dst->zero_knowledge_password_authentication = src->zero_knowledge_password_authentication;
    }
#line 1393
    break;
  }
#line 1394
  while (1) {
#line 1394
    if (src->permit_root_login != -1) {
#line 1394
      dst->permit_root_login = src->permit_root_login;
    }
#line 1394
    break;
  }
#line 1395
  while (1) {
#line 1395
    if (src->permit_empty_passwd != -1) {
#line 1395
      dst->permit_empty_passwd = src->permit_empty_passwd;
    }
#line 1395
    break;
  }
#line 1397
  while (1) {
#line 1397
    if (src->allow_tcp_forwarding != -1) {
#line 1397
      dst->allow_tcp_forwarding = src->allow_tcp_forwarding;
    }
#line 1397
    break;
  }
#line 1398
  while (1) {
#line 1398
    if (src->allow_agent_forwarding != -1) {
#line 1398
      dst->allow_agent_forwarding = src->allow_agent_forwarding;
    }
#line 1398
    break;
  }
#line 1399
  while (1) {
#line 1399
    if (src->gateway_ports != -1) {
#line 1399
      dst->gateway_ports = src->gateway_ports;
    }
#line 1399
    break;
  }
#line 1400
  while (1) {
#line 1400
    if (src->x11_display_offset != -1) {
#line 1400
      dst->x11_display_offset = src->x11_display_offset;
    }
#line 1400
    break;
  }
#line 1401
  while (1) {
#line 1401
    if (src->x11_forwarding != -1) {
#line 1401
      dst->x11_forwarding = src->x11_forwarding;
    }
#line 1401
    break;
  }
#line 1402
  while (1) {
#line 1402
    if (src->x11_use_localhost != -1) {
#line 1402
      dst->x11_use_localhost = src->x11_use_localhost;
    }
#line 1402
    break;
  }
#line 1403
  while (1) {
#line 1403
    if (src->max_sessions != -1) {
#line 1403
      dst->max_sessions = src->max_sessions;
    }
#line 1403
    break;
  }
#line 1404
  while (1) {
#line 1404
    if (src->max_authtries != -1) {
#line 1404
      dst->max_authtries = src->max_authtries;
    }
#line 1404
    break;
  }
#line 1406
  while (1) {
#line 1406
    if ((unsigned int )src->banner != (unsigned int )((void *)0)) {
#line 1406
      if ((unsigned int )dst->banner != (unsigned int )((void *)0)) {
#line 1406
        xfree((void *)dst->banner);
      }
#line 1406
      dst->banner = src->banner;
    }
#line 1406
    break;
  }
#line 1407
  if (preauth) {
#line 1408
    return;
  }
#line 1409
  while (1) {
#line 1409
    if ((unsigned int )src->adm_forced_command != (unsigned int )((void *)0)) {
#line 1409
      if ((unsigned int )dst->adm_forced_command != (unsigned int )((void *)0)) {
#line 1409
        xfree((void *)dst->adm_forced_command);
      }
#line 1409
      dst->adm_forced_command = src->adm_forced_command;
    }
#line 1409
    break;
  }
#line 1410
  while (1) {
#line 1410
    if ((unsigned int )src->chroot_directory != (unsigned int )((void *)0)) {
#line 1410
      if ((unsigned int )dst->chroot_directory != (unsigned int )((void *)0)) {
#line 1410
        xfree((void *)dst->chroot_directory);
      }
#line 1410
      dst->chroot_directory = src->chroot_directory;
    }
#line 1410
    break;
  }
#line 1411
  return;
}
}
#line 1416 "servconf.c"
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ,
                         char const   *user , char const   *host , char const   *address ) 
{ int active ;
  int linenum ;
  int bad_options ;
  char *cp ;
  char *obuf ;
  char *cbuf ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___18 ;

  {
#line 1420
  bad_options = 0;
#line 1423
  tmp = buffer_len(conf);
#line 1423
  debug2("%s: config %s len %d", "parse_server_config", filename, tmp);
#line 1425
  tmp___0 = buffer_ptr(conf);
#line 1425
  cbuf = xstrdup((char const   *)tmp___0);
#line 1425
  obuf = cbuf;
#line 1426
  if (user) {
#line 1426
    active = 0;
  } else {
#line 1426
    active = 1;
  }
#line 1427
  linenum = 1;
#line 1428
  while (1) {
#line 1428
    tmp___18 = __strsep_g(& cbuf, "\n");
#line 1428
    cp = tmp___18;
#line 1428
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 1428
      break;
    }
#line 1429
    tmp___1 = linenum;
#line 1429
    linenum ++;
#line 1429
    tmp___2 = process_server_config_line(options___0, cp, filename, tmp___1, & active,
                                         user, host, address);
#line 1429
    if (tmp___2 != 0) {
#line 1431
      bad_options ++;
    }
  }
#line 1433
  xfree((void *)obuf);
#line 1434
  if (bad_options > 0) {
#line 1435
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
  }
#line 1437
  return;
}
}
#line 1439 "servconf.c"
static char const   *fmt_intarg(ServerOpCodes code , int val ) 
{ 

  {
#line 1442
  if ((int )code == 21) {
#line 1443
    switch (val) {
    case 2: 
#line 1445
    return ("inet");
    case 10: 
#line 1447
    return ("inet6");
    case 0: 
#line 1449
    return ("any");
    default: ;
#line 1451
    return ("UNKNOWN");
    }
  }
#line 1454
  if ((int )code == 7) {
#line 1455
    switch (val) {
    case 2: 
#line 1457
    return ("without-password");
    case 1: 
#line 1459
    return ("forced-commands-only");
    case 3: 
#line 1461
    return ("yes");
    }
  }
#line 1464
  if ((int )code == 42) {
#line 1465
    switch (val) {
    case 1: 
#line 1467
    return ("1");
    case 4: 
#line 1469
    return ("2");
    case 5: 
#line 1471
    return ("2,1");
    default: ;
#line 1473
    return ("UNKNOWN");
    }
  }
#line 1476
  if ((int )code == 44) {
#line 1476
    if (val == 2) {
#line 1477
      return ("clientspecified");
    }
  }
#line 1478
  if ((int )code == 34) {
#line 1478
    if (val == 2) {
#line 1479
      return ("delayed");
    }
  }
#line 1480
  switch (val) {
  case -1: 
#line 1482
  return ("unset");
  case 0: 
#line 1484
  return ("no");
  case 1: 
#line 1486
  return ("yes");
  }
#line 1488
  return ("UNKNOWN");
}
}
#line 1491 "servconf.c"
static char const   *lookup_opcode_name(ServerOpCodes code ) 
{ u_int i ;

  {
#line 1496
  i = 0U;
#line 1496
  while ((unsigned int )keywords[i].name != (unsigned int )((void *)0)) {
#line 1497
    if ((int )keywords[i].opcode == (int )code) {
#line 1498
      return (keywords[i].name);
    }
#line 1496
    i ++;
  }
#line 1499
  return ("UNKNOWN");
}
}
#line 1502 "servconf.c"
static void dump_cfg_int(ServerOpCodes code , int val ) 
{ char const   *tmp ;

  {
#line 1505
  tmp = lookup_opcode_name(code);
#line 1505
  printf((char const   * __restrict  )"%s %d\n", tmp, val);
#line 1506
  return;
}
}
#line 1508 "servconf.c"
static void dump_cfg_fmtint(ServerOpCodes code , int val ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1511
  tmp = fmt_intarg(code, val);
#line 1511
  tmp___0 = lookup_opcode_name(code);
#line 1511
  printf((char const   * __restrict  )"%s %s\n", tmp___0, tmp);
#line 1512
  return;
}
}
#line 1514 "servconf.c"
static void dump_cfg_string(ServerOpCodes code , char const   *val ) 
{ char const   *tmp ;

  {
#line 1517
  if ((unsigned int )val == (unsigned int )((void *)0)) {
#line 1518
    return;
  }
#line 1519
  tmp = lookup_opcode_name(code);
#line 1519
  printf((char const   * __restrict  )"%s %s\n", tmp, val);
#line 1520
  return;
}
}
#line 1522 "servconf.c"
static void dump_cfg_strarray(ServerOpCodes code , u_int count , char **vals ) 
{ u_int i ;
  char const   *tmp ;

  {
#line 1527
  i = 0U;
#line 1527
  while (i < count) {
#line 1528
    tmp = lookup_opcode_name(code);
#line 1528
    printf((char const   * __restrict  )"%s %s\n", tmp, *(vals + i));
#line 1527
    i ++;
  }
#line 1529
  return;
}
}
#line 1531 "servconf.c"
void dump_config(ServerOptions *o ) 
{ u_int i ;
  int ret___0 ;
  struct addrinfo *ai ;
  char addr[1025] ;
  char port___0[32] ;
  char *s ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 1537
  s = (char *)((void *)0);
#line 1540
  i = 0U;
#line 1540
  while (i < o->num_ports) {
#line 1541
    printf((char const   * __restrict  )"port %d\n", o->ports[i]);
#line 1540
    i ++;
  }
#line 1542
  dump_cfg_fmtint(42, o->protocol);
#line 1543
  dump_cfg_fmtint(21, o->address_family);
#line 1546
  ai = o->listen_addrs;
#line 1546
  while (ai) {
#line 1547
    ret___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(addr), sizeof(addr), (char * __restrict  )(port___0),
                          sizeof(port___0), 3U);
#line 1547
    if (ret___0 != 0) {
#line 1550
      if (ret___0 != -11) {
#line 1550
        tmp___2 = gai_strerror(ret___0);
      } else {
#line 1550
        tmp___3 = __errno_location();
#line 1550
        tmp___4 = strerror(*tmp___3);
#line 1550
        tmp___2 = (char const   *)tmp___4;
      }
#line 1550
      error("getnameinfo failed: %.100s", tmp___2);
    } else {
#line 1554
      if (ai->ai_family == 10) {
#line 1555
        printf((char const   * __restrict  )"listenaddress [%s]:%s\n", addr, port___0);
      } else {
#line 1557
        printf((char const   * __restrict  )"listenaddress %s:%s\n", addr, port___0);
      }
    }
#line 1546
    ai = ai->ai_next;
  }
#line 1565
  dump_cfg_int(4, o->server_key_bits);
#line 1566
  dump_cfg_int(5, o->login_grace_time);
#line 1567
  dump_cfg_int(6, o->key_regeneration_time);
#line 1568
  dump_cfg_int(26, o->x11_display_offset);
#line 1569
  dump_cfg_int(49, o->max_authtries);
#line 1570
  dump_cfg_int(50, o->max_sessions);
#line 1571
  dump_cfg_int(55, o->client_alive_interval);
#line 1572
  dump_cfg_int(56, o->client_alive_count_max);
#line 1575
  dump_cfg_fmtint(7, o->permit_root_login);
#line 1576
  dump_cfg_fmtint(24, o->ignore_rhosts);
#line 1577
  dump_cfg_fmtint(39, o->ignore_user_known_hosts);
#line 1578
  dump_cfg_fmtint(10, o->rhosts_rsa_authentication);
#line 1579
  dump_cfg_fmtint(53, o->hostbased_authentication);
#line 1580
  dump_cfg_fmtint(54, o->hostbased_uses_name_from_packet_only);
#line 1582
  dump_cfg_fmtint(11, o->rsa_authentication);
#line 1583
  dump_cfg_fmtint(45, o->pubkey_authentication);
#line 1600
  dump_cfg_fmtint(18, o->password_authentication);
#line 1601
  dump_cfg_fmtint(19, o->kbd_interactive_authentication);
#line 1603
  dump_cfg_fmtint(17, o->challenge_response_authentication);
#line 1605
  dump_cfg_fmtint(22, o->print_motd);
#line 1606
  dump_cfg_fmtint(23, o->print_lastlog);
#line 1607
  dump_cfg_fmtint(25, o->x11_forwarding);
#line 1608
  dump_cfg_fmtint(27, o->x11_use_localhost);
#line 1609
  dump_cfg_fmtint(28, o->strict_modes);
#line 1610
  dump_cfg_fmtint(30, o->tcp_keep_alive);
#line 1611
  dump_cfg_fmtint(29, o->permit_empty_passwd);
#line 1612
  dump_cfg_fmtint(31, o->permit_user_env);
#line 1613
  dump_cfg_fmtint(32, o->use_login);
#line 1614
  dump_cfg_fmtint(34, o->compression);
#line 1615
  dump_cfg_fmtint(44, o->gateway_ports);
#line 1616
  dump_cfg_fmtint(52, o->use_dns);
#line 1617
  dump_cfg_fmtint(33, o->allow_tcp_forwarding);
#line 1618
  dump_cfg_fmtint(67, use_privsep);
#line 1621
  dump_cfg_string(43, (char const   *)o->pid_file);
#line 1622
  dump_cfg_string(46, (char const   *)o->xauth_location);
#line 1623
  dump_cfg_string(40, (char const   *)o->ciphers);
#line 1624
  dump_cfg_string(41, (char const   *)o->macs);
#line 1625
  dump_cfg_string(51, (char const   *)o->banner);
#line 1626
  dump_cfg_string(57, (char const   *)o->authorized_keys_file);
#line 1627
  dump_cfg_string(58, (char const   *)o->authorized_keys_file2);
#line 1628
  dump_cfg_string(65, (char const   *)o->adm_forced_command);
#line 1631
  tmp___5 = log_level_name(o->log_level);
#line 1631
  dump_cfg_string(9, tmp___5);
#line 1632
  tmp___6 = log_facility_name(o->log_facility);
#line 1632
  dump_cfg_string(8, tmp___6);
#line 1635
  dump_cfg_strarray(3, (unsigned int )o->num_host_key_files, o->host_key_files);
#line 1637
  dump_cfg_strarray(35, o->num_allow_users, o->allow_users);
#line 1638
  dump_cfg_strarray(36, o->num_deny_users, o->deny_users);
#line 1639
  dump_cfg_strarray(37, o->num_allow_groups, o->allow_groups);
#line 1640
  dump_cfg_strarray(38, o->num_deny_groups, o->deny_groups);
#line 1641
  dump_cfg_strarray(61, o->num_accept_env, o->accept_env);
#line 1644
  i = 0U;
#line 1644
  while (i < o->num_subsystems) {
#line 1645
    printf((char const   * __restrict  )"subsystem %s %s\n", o->subsystem_name[i],
           o->subsystem_args[i]);
#line 1644
    i ++;
  }
#line 1648
  printf((char const   * __restrict  )"maxstartups %d:%d:%d\n", o->max_startups_begin,
         o->max_startups_rate, o->max_startups);
#line 1651
  i = 0U;
#line 1651
  while (tunmode_desc[i].val != -1) {
#line 1652
    if (tunmode_desc[i].val == o->permit_tun) {
#line 1653
      s = tunmode_desc[i].text;
#line 1654
      break;
    }
#line 1651
    i ++;
  }
#line 1656
  dump_cfg_string(62, (char const   *)s);
#line 1658
  channel_print_adm_permitted_opens();
#line 1659
  return;
}
}
#line 1 "serverloop.o"
#pragma merger(0,"./serverloop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 68 "session.h"
int session_open(Authctxt *authctxt___0 , int chanid ) ;
#line 70
int session_input_channel_req(Channel *c , char const   *rtype ) ;
#line 71
void session_close_by_pid(pid_t pid , int status ) ;
#line 72
void session_close_by_channel(int id , void *arg ) ;
#line 73
void session_destroy_all(void (*closefunc)(Session * ) ) ;
#line 32 "auth-options.h"
int forced_tun_device ;
#line 24 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 25
void server_loop2(Authctxt *authctxt___0 ) ;
#line 89 "serverloop.c"
static Buffer stdin_buffer  ;
#line 90 "serverloop.c"
static Buffer stdout_buffer  ;
#line 91 "serverloop.c"
static Buffer stderr_buffer  ;
#line 92 "serverloop.c"
static int fdin  ;
#line 93 "serverloop.c"
static int fdout  ;
#line 95 "serverloop.c"
static int fderr  ;
#line 96 "serverloop.c"
static long stdin_bytes  =    0L;
#line 97 "serverloop.c"
static long stdout_bytes  =    0L;
#line 98 "serverloop.c"
static long stderr_bytes  =    0L;
#line 99 "serverloop.c"
static long fdout_bytes  =    0L;
#line 100 "serverloop.c"
static int stdin_eof  =    0;
#line 101 "serverloop.c"
static int fdout_eof  =    0;
#line 102 "serverloop.c"
static int fderr_eof  =    0;
#line 103 "serverloop.c"
static int fdin_is_tty  =    0;
#line 104 "serverloop.c"
static int connection_in___0  ;
#line 105 "serverloop.c"
static int connection_out___0  ;
#line 106 "serverloop.c"
static int connection_closed  =    0;
#line 107 "serverloop.c"
static u_int buffer_high  ;
#line 108 "serverloop.c"
static int no_more_sessions  =    0;
#line 115 "serverloop.c"
static int volatile   child_terminated  =    (sig_atomic_t volatile   )0;
#line 118 "serverloop.c"
static int volatile   received_sigterm___0  =    (sig_atomic_t volatile   )0;
#line 121
static void server_init_dispatch(void) ;
#line 127 "serverloop.c"
static int notify_pipe[2]  ;
#line 128 "serverloop.c"
static void notify_setup(void) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 131
  tmp___5 = pipe((int *)(notify_pipe));
#line 131
  if (tmp___5 < 0) {
#line 132
    tmp = __errno_location();
#line 132
    tmp___0 = strerror(*tmp);
#line 132
    error("pipe(notify_pipe) failed %s", tmp___0);
  } else {
#line 133
    tmp___3 = fcntl(notify_pipe[0], 2, 1);
#line 133
    if (tmp___3 == -1) {
#line 135
      tmp___1 = __errno_location();
#line 135
      tmp___2 = strerror(*tmp___1);
#line 135
      error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 136
      close(notify_pipe[0]);
#line 137
      close(notify_pipe[1]);
    } else {
#line 133
      tmp___4 = fcntl(notify_pipe[1], 2, 1);
#line 133
      if (tmp___4 == -1) {
#line 135
        tmp___1 = __errno_location();
#line 135
        tmp___2 = strerror(*tmp___1);
#line 135
        error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 136
        close(notify_pipe[0]);
#line 137
        close(notify_pipe[1]);
      } else {
#line 139
        set_nonblock(notify_pipe[0]);
#line 140
        set_nonblock(notify_pipe[1]);
#line 141
        return;
      }
    }
  }
#line 143
  notify_pipe[0] = -1;
#line 144
  notify_pipe[1] = -1;
#line 145
  return;
}
}
#line 146 "serverloop.c"
static void notify_parent(void) 
{ 

  {
#line 149
  if (notify_pipe[1] != -1) {
#line 150
    write(notify_pipe[1], (void const   *)"", 1U);
  }
#line 151
  return;
}
}
#line 152 "serverloop.c"
static void notify_prepare(fd_set *readset ) 
{ 

  {
#line 155
  if (notify_pipe[0] != -1) {
#line 156
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 157
  return;
}
}
#line 158 "serverloop.c"
static void notify_done(fd_set *readset ) 
{ char c ;
  ssize_t tmp ;
  register char __result ;

  {
#line 163
  if (notify_pipe[0] != -1) {
#line 163
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "cc");
#line 163
    if (__result) {
#line 164
      while (1) {
#line 164
        tmp = read(notify_pipe[0], (void *)(& c), 1U);
#line 164
        if (! (tmp != -1)) {
#line 164
          break;
        }
#line 165
        debug2("notify_done: reading");
      }
    }
  }
#line 166
  return;
}
}
#line 169 "serverloop.c"
static void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 172
  tmp = __errno_location();
#line 172
  save_errno = *tmp;
#line 173
  child_terminated = (int volatile   )1;
#line 175
  mysignal(17, & sigchld_handler);
#line 177
  notify_parent();
#line 178
  tmp___0 = __errno_location();
#line 178
  *tmp___0 = save_errno;
#line 179
  return;
}
}
#line 182 "serverloop.c"
static void sigterm_handler___0(int sig ) 
{ 

  {
#line 185
  received_sigterm___0 = (int volatile   )sig;
#line 186
  return;
}
}
#line 192 "serverloop.c"
static void make_packets_from_stderr_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 198
  while (1) {
#line 198
    tmp___1 = buffer_len(& stderr_buffer);
#line 198
    if (tmp___1 > 0U) {
#line 198
      tmp___2 = packet_not_very_much_data_to_write();
#line 198
      if (! tmp___2) {
#line 198
        break;
      }
    } else {
#line 198
      break;
    }
#line 200
    len = buffer_len(& stderr_buffer);
#line 201
    tmp = packet_is_interactive();
#line 201
    if (tmp) {
#line 202
      if (len > 512U) {
#line 203
        len = 512U;
      }
    } else {
#line 206
      if (len > max_packet_size) {
#line 207
        len = max_packet_size;
      }
    }
#line 209
    packet_start((unsigned char)18);
#line 210
    tmp___0 = buffer_ptr(& stderr_buffer);
#line 210
    packet_put_string((void const   *)tmp___0, len);
#line 211
    packet_send();
#line 212
    buffer_consume(& stderr_buffer, len);
#line 213
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )len);
  }
#line 215
  return;
}
}
#line 221 "serverloop.c"
static void make_packets_from_stdout_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 227
  while (1) {
#line 227
    tmp___1 = buffer_len(& stdout_buffer);
#line 227
    if (tmp___1 > 0U) {
#line 227
      tmp___2 = packet_not_very_much_data_to_write();
#line 227
      if (! tmp___2) {
#line 227
        break;
      }
    } else {
#line 227
      break;
    }
#line 229
    len = buffer_len(& stdout_buffer);
#line 230
    tmp = packet_is_interactive();
#line 230
    if (tmp) {
#line 231
      if (len > 512U) {
#line 232
        len = 512U;
      }
    } else {
#line 235
      if (len > max_packet_size) {
#line 236
        len = max_packet_size;
      }
    }
#line 238
    packet_start((unsigned char)17);
#line 239
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 239
    packet_put_string((void const   *)tmp___0, len);
#line 240
    packet_send();
#line 241
    buffer_consume(& stdout_buffer, len);
#line 242
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )len);
  }
#line 244
  return;
}
}
#line 246 "serverloop.c"
static void client_alive_check(void) 
{ int channel_id ;

  {
#line 252
  keep_alive_timeouts ++;
#line 252
  if (keep_alive_timeouts > options.client_alive_count_max) {
#line 253
    logit("Timeout, client not responding.");
#line 254
    cleanup_exit(255);
  }
#line 261
  channel_id = channel_find_open();
#line 261
  if (channel_id == -1) {
#line 262
    packet_start((unsigned char)80);
#line 263
    packet_put_cstring("keepalive@openssh.com");
#line 264
    packet_put_char(1);
  } else {
#line 266
    channel_request_start(channel_id, (char *)"keepalive@openssh.com", 1);
  }
#line 268
  packet_send();
#line 269
  return;
}
}
#line 277 "serverloop.c"
static void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                        u_int *nallocp , u_int max_time_milliseconds ) 
{ struct timeval tv___0 ;
  struct timeval *tvp ;
  int ret___0 ;
  int client_alive_scheduled ;
  int program_alive_scheduled ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
#line 283
  client_alive_scheduled = 0;
#line 284
  program_alive_scheduled = 0;
#line 294
  if (compat20) {
#line 294
    if (max_time_milliseconds == 0U) {
#line 294
      if (options.client_alive_interval) {
#line 296
        client_alive_scheduled = 1;
#line 297
        max_time_milliseconds = (unsigned int )(options.client_alive_interval * 1000);
      }
    }
  }
#line 301
  channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
#line 303
  if (compat20) {
#line 308
    __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  } else {
#line 314
    tmp = buffer_len(& stdin_buffer);
#line 314
    if (tmp < buffer_high) {
#line 314
      tmp___0 = channel_not_very_much_buffered_data();
#line 314
      if (tmp___0) {
#line 316
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 321
    tmp___1 = packet_not_very_much_data_to_write();
#line 321
    if (tmp___1) {
#line 322
      program_alive_scheduled = (int )child_terminated;
#line 323
      if (! fdout_eof) {
#line 324
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 325
      if (! fderr_eof) {
#line 326
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 332
    if (fdin != -1) {
#line 332
      tmp___2 = buffer_len(& stdin_buffer);
#line 332
      if (tmp___2 > 0U) {
#line 333
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 335
  notify_prepare(*readsetp);
#line 341
  tmp___3 = packet_have_data_to_write();
#line 341
  if (tmp___3) {
#line 342
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 348
  if (child_terminated) {
#line 348
    tmp___4 = packet_not_very_much_data_to_write();
#line 348
    if (tmp___4) {
#line 349
      if (max_time_milliseconds == 0U) {
#line 350
        max_time_milliseconds = 100U;
      } else {
#line 349
        if (client_alive_scheduled) {
#line 350
          max_time_milliseconds = 100U;
        }
      }
    }
  }
#line 352
  if (max_time_milliseconds == 0U) {
#line 353
    tvp = (struct timeval *)((void *)0);
  } else {
#line 355
    tv___0.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 356
    tv___0.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 357
    tvp = & tv___0;
  }
#line 361
  ret___0 = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 363
  if (ret___0 == -1) {
#line 364
    memset((void *)*readsetp, 0, *nallocp);
#line 365
    memset((void *)*writesetp, 0, *nallocp);
#line 366
    tmp___7 = __errno_location();
#line 366
    if (*tmp___7 != 4) {
#line 367
      tmp___5 = __errno_location();
#line 367
      tmp___6 = strerror(*tmp___5);
#line 367
      error("select: %.100s", tmp___6);
    }
  } else {
#line 369
    if (ret___0 == 0) {
#line 369
      if (client_alive_scheduled) {
#line 370
        client_alive_check();
      }
    }
#line 371
    if (! compat20) {
#line 371
      if (program_alive_scheduled) {
#line 371
        if (fdin_is_tty) {
#line 372
          if (! fdout_eof) {
#line 373
            __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                                 "memory");
          }
#line 374
          if (! fderr_eof) {
#line 375
            __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                                 "memory");
          }
        }
      }
    }
  }
#line 379
  notify_done(*readsetp);
#line 380
  return;
}
}
#line 386 "serverloop.c"
static void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  register char __result ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  register char __result___0 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  register char __result___1 ;

  {
#line 393
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 393
  if (__result) {
#line 394
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 395
    if (len == 0) {
#line 396
      tmp = get_remote_ipaddr();
#line 396
      verbose("Connection closed by %.100s", tmp);
#line 398
      connection_closed = 1;
#line 399
      if (compat20) {
#line 400
        return;
      }
#line 401
      cleanup_exit(255);
    } else {
#line 402
      if (len < 0) {
#line 403
        tmp___3 = __errno_location();
#line 403
        if (*tmp___3 != 4) {
#line 403
          tmp___4 = __errno_location();
#line 403
          if (*tmp___4 != 11) {
#line 403
            tmp___5 = __errno_location();
#line 403
            if (*tmp___5 != 11) {
#line 405
              tmp___0 = __errno_location();
#line 405
              tmp___1 = strerror(*tmp___0);
#line 405
              tmp___2 = get_remote_ipaddr();
#line 405
              verbose("Read error from remote host %.100s: %.100s", tmp___2, tmp___1);
#line 408
              cleanup_exit(255);
            }
          }
        }
      } else {
#line 412
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 415
  if (compat20) {
#line 416
    return;
  }
#line 419
  if (! fdout_eof) {
#line 419
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 419
    if (__result___0) {
#line 420
      tmp___6 = __errno_location();
#line 420
      *tmp___6 = 0;
#line 421
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 422
      if (len < 0) {
#line 422
        tmp___7 = __errno_location();
#line 422
        if (! (*tmp___7 == 4)) {
#line 422
          tmp___8 = __errno_location();
#line 422
          if (*tmp___8 == 11) {
            goto _L___0;
          } else {
#line 422
            tmp___9 = __errno_location();
#line 422
            if (*tmp___9 == 11) {
              _L___0: /* CIL Label */ 
#line 422
              if (! (! child_terminated)) {
                goto _L;
              }
            } else {
              goto _L;
            }
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 426
        if (len <= 0) {
#line 431
          fdout_eof = 1;
        } else {
#line 433
          buffer_append(& stdout_buffer, (void const   *)(buf___1), (unsigned int )len);
#line 434
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 438
  if (! fderr_eof) {
#line 438
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 438
    if (__result___1) {
#line 439
      tmp___10 = __errno_location();
#line 439
      *tmp___10 = 0;
#line 440
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 441
      if (len < 0) {
#line 441
        tmp___11 = __errno_location();
#line 441
        if (! (*tmp___11 == 4)) {
#line 441
          tmp___12 = __errno_location();
#line 441
          if (*tmp___12 == 11) {
            goto _L___2;
          } else {
#line 441
            tmp___13 = __errno_location();
#line 441
            if (*tmp___13 == 11) {
              _L___2: /* CIL Label */ 
#line 441
              if (! (! child_terminated)) {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          }
        }
      } else {
        _L___1: /* CIL Label */ 
#line 445
        if (len <= 0) {
#line 450
          fderr_eof = 1;
        } else {
#line 452
          buffer_append(& stderr_buffer, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 455
  return;
}
}
#line 460 "serverloop.c"
static void process_output(fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  register char __result ;
  register char __result___0 ;

  {
#line 469
  if (! compat20) {
#line 469
    if (fdin != -1) {
#line 469
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 469
      if (__result) {
#line 470
        tmp = buffer_ptr(& stdin_buffer);
#line 470
        data = (u_char *)tmp;
#line 471
        dlen = buffer_len(& stdin_buffer);
#line 472
        len = write(fdin, (void const   *)data, dlen);
#line 473
        if (len < 0) {
#line 473
          tmp___1 = __errno_location();
#line 473
          if (! (*tmp___1 == 4)) {
#line 473
            tmp___2 = __errno_location();
#line 473
            if (! (*tmp___2 == 11)) {
#line 473
              tmp___3 = __errno_location();
#line 473
              if (! (*tmp___3 == 11)) {
                goto _L;
              }
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 476
          if (len <= 0) {
#line 477
            if (fdin != fdout) {
#line 478
              close(fdin);
            } else {
#line 480
              shutdown(fdin, 1);
            }
#line 481
            fdin = -1;
          } else {
#line 484
            if (fdin_is_tty) {
#line 484
              if (dlen >= 1U) {
#line 484
                if ((int )*(data + 0) != 13) {
#line 484
                  tmp___0 = tcgetattr(fdin, & tio);
#line 484
                  if (tmp___0 == 0) {
#line 484
                    if (! (tio.c_lflag & 8U)) {
#line 484
                      if (tio.c_lflag & 2U) {
#line 491
                        packet_send_ignore(len);
#line 492
                        packet_send();
                      }
                    }
                  }
                }
              }
            }
#line 495
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 497
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 501
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 501
  if (__result___0) {
#line 502
    packet_write_poll();
  }
#line 503
  return;
}
}
#line 509 "serverloop.c"
static void drain_output(void) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 513
  tmp___2 = buffer_len(& stdout_buffer);
#line 513
  if (tmp___2 > 0U) {
#line 514
    packet_start((unsigned char)17);
#line 515
    tmp = buffer_len(& stdout_buffer);
#line 515
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 515
    packet_put_string((void const   *)tmp___0, tmp);
#line 517
    packet_send();
#line 519
    tmp___1 = buffer_len(& stdout_buffer);
#line 519
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 522
  tmp___6 = buffer_len(& stderr_buffer);
#line 522
  if (tmp___6 > 0U) {
#line 523
    packet_start((unsigned char)18);
#line 524
    tmp___3 = buffer_len(& stderr_buffer);
#line 524
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 524
    packet_put_string((void const   *)tmp___4, tmp___3);
#line 526
    packet_send();
#line 528
    tmp___5 = buffer_len(& stderr_buffer);
#line 528
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 531
  packet_write_wait();
#line 532
  return;
}
}
#line 534 "serverloop.c"
static void process_buffered_input_packets(void) 
{ Kex *tmp ;

  {
#line 537
  if (compat20) {
#line 537
    tmp = xxx_kex;
  } else {
#line 537
    tmp = (Kex *)((void *)0);
  }
#line 537
  dispatch_run(1, (sig_atomic_t volatile   *)((void *)0), (void *)tmp);
#line 538
  return;
}
}
#line 547 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  u_int nalloc ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  union __anonunion___u_83 __u ;
  union __anonunion___u_84 __u___0 ;
  union __anonunion___u_85 __u___1 ;
  union __anonunion___u_86 __u___2 ;
  union __anonunion___u_87 __u___3 ;

  {
#line 550
  readset = (fd_set *)((void *)0);
#line 550
  writeset = (fd_set *)((void *)0);
#line 551
  max_fd = 0;
#line 552
  nalloc = (u_int )0;
#line 555
  waiting_termination = 0;
#line 561
  debug("Entering interactive session.");
#line 564
  child_terminated = (int volatile   )0;
#line 565
  mysignal(17, & sigchld_handler);
#line 567
  if (! use_privsep) {
#line 568
    mysignal(15, & sigterm_handler___0);
#line 569
    mysignal(2, & sigterm_handler___0);
#line 570
    mysignal(3, & sigterm_handler___0);
  }
#line 574
  fdin = fdin_arg;
#line 575
  fdout = fdout_arg;
#line 576
  fderr = fderr_arg;
#line 579
  set_nonblock(fdin);
#line 580
  set_nonblock(fdout);
#line 582
  if (fderr != -1) {
#line 583
    set_nonblock(fderr);
  }
#line 585
  if (! (datafellows & 256)) {
#line 585
    tmp = isatty(fdin);
#line 585
    if (tmp) {
#line 586
      fdin_is_tty = 1;
    }
  }
#line 588
  connection_in___0 = packet_get_connection_in();
#line 589
  connection_out___0 = packet_get_connection_out();
#line 591
  notify_setup();
#line 593
  previous_stdout_buffer_bytes = 0U;
#line 596
  tmp___0 = packet_is_interactive();
#line 596
  if (tmp___0) {
#line 597
    buffer_high = 4096U;
  } else {
#line 599
    buffer_high = 65536U;
  }
#line 611
  buffer_init(& stdin_buffer);
#line 612
  buffer_init(& stdout_buffer);
#line 613
  buffer_init(& stderr_buffer);
#line 621
  if (fderr == -1) {
#line 622
    fderr_eof = 1;
  }
#line 624
  server_init_dispatch();
#line 627
  while (1) {
#line 630
    process_buffered_input_packets();
#line 636
    if (stdin_eof) {
#line 636
      if (fdin != -1) {
#line 636
        tmp___1 = buffer_len(& stdin_buffer);
#line 636
        if (tmp___1 == 0U) {
#line 637
          if (fdin != fdout) {
#line 638
            close(fdin);
          } else {
#line 640
            shutdown(fdin, 1);
          }
#line 641
          fdin = -1;
        }
      }
    }
#line 644
    make_packets_from_stderr_data();
#line 653
    max_time_milliseconds = 0U;
#line 654
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 655
    if (stdout_buffer_bytes != 0U) {
#line 655
      if (stdout_buffer_bytes < 256U) {
#line 655
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 658
          max_time_milliseconds = 10U;
        } else {
#line 661
          make_packets_from_stdout_data();
        }
      } else {
#line 661
        make_packets_from_stdout_data();
      }
    } else {
#line 661
      make_packets_from_stdout_data();
    }
#line 663
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 666
    tmp___2 = packet_not_very_much_data_to_write();
#line 666
    if (tmp___2) {
#line 667
      channel_output_poll();
    }
#line 674
    if (fdout_eof) {
#line 674
      if (fderr_eof) {
#line 674
        tmp___6 = packet_have_data_to_write();
#line 674
        if (! tmp___6) {
#line 674
          tmp___7 = buffer_len(& stdout_buffer);
#line 674
          if (tmp___7 == 0U) {
#line 674
            tmp___8 = buffer_len(& stderr_buffer);
#line 674
            if (tmp___8 == 0U) {
#line 676
              tmp___3 = channel_still_open();
#line 676
              if (! tmp___3) {
#line 677
                break;
              }
#line 678
              if (! waiting_termination) {
#line 679
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 681
                waiting_termination = 1;
#line 682
                tmp___4 = strlen(s);
#line 682
                buffer_append(& stderr_buffer, (void const   *)s, tmp___4);
#line 685
                cp = channel_open_message();
#line 686
                tmp___5 = strlen((char const   *)cp);
#line 686
                buffer_append(& stderr_buffer, (void const   *)cp, tmp___5);
#line 687
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 690
    if (connection_in___0 > connection_out___0) {
#line 690
      max_fd = connection_in___0;
    } else {
#line 690
      max_fd = connection_out___0;
    }
#line 691
    if (max_fd > fdin) {
#line 691
      max_fd = max_fd;
    } else {
#line 691
      max_fd = fdin;
    }
#line 692
    if (max_fd > fdout) {
#line 692
      max_fd = max_fd;
    } else {
#line 692
      max_fd = fdout;
    }
#line 693
    if (max_fd > fderr) {
#line 693
      max_fd = max_fd;
    } else {
#line 693
      max_fd = fderr;
    }
#line 694
    if (max_fd > notify_pipe[0]) {
#line 694
      max_fd = max_fd;
    } else {
#line 694
      max_fd = notify_pipe[0];
    }
#line 697
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, max_time_milliseconds);
#line 700
    if (received_sigterm___0) {
#line 701
      logit("Exiting on signal %d", received_sigterm___0);
#line 703
      cleanup_exit(255);
    }
#line 707
    channel_after_select(readset, writeset);
#line 710
    process_input(readset);
#line 713
    process_output(writeset);
  }
#line 715
  if (readset) {
#line 716
    xfree((void *)readset);
  }
#line 717
  if (writeset) {
#line 718
    xfree((void *)writeset);
  }
#line 723
  drain_output();
#line 725
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 729
  buffer_free(& stdin_buffer);
#line 730
  buffer_free(& stdout_buffer);
#line 731
  buffer_free(& stderr_buffer);
#line 734
  if (fdout != -1) {
#line 735
    close(fdout);
  }
#line 736
  fdout = -1;
#line 737
  fdout_eof = 1;
#line 738
  if (fderr != -1) {
#line 739
    close(fderr);
  }
#line 740
  fderr = -1;
#line 741
  fderr_eof = 1;
#line 742
  if (fdin != -1) {
#line 743
    close(fdin);
  }
#line 744
  fdin = -1;
#line 746
  channel_free_all();
#line 749
  mysignal(17, (void (*)(int  ))0);
#line 751
  while (1) {
#line 751
    wait_pid = waitpid(-1, & wait_status, 0);
#line 751
    if (! (wait_pid < 0)) {
#line 751
      break;
    }
#line 752
    tmp___11 = __errno_location();
#line 752
    if (*tmp___11 != 4) {
#line 753
      tmp___9 = __errno_location();
#line 753
      tmp___10 = strerror(*tmp___9);
#line 753
      packet_disconnect("wait: %.100s", tmp___10);
    }
  }
#line 754
  if (wait_pid != pid) {
#line 755
    error("Strange, wait returned pid %ld, expected %ld", (long )wait_pid, (long )pid);
  }
#line 759
  __u___1.__in = wait_status;
#line 759
  if ((__u___1.__i & 127) == 0) {
#line 761
    __u.__in = wait_status;
#line 761
    debug("Command exited with status %d.", (__u.__i & 65280) >> 8);
#line 762
    packet_start((unsigned char)20);
#line 763
    __u___0.__in = wait_status;
#line 763
    packet_put_int((unsigned int )((__u___0.__i & 65280) >> 8));
#line 764
    packet_send();
#line 765
    packet_write_wait();
#line 774
    while (1) {
#line 775
      type = packet_read();
#line 774
      if (! (type != 33)) {
#line 774
        break;
      }
    }
#line 779
    debug("Received exit confirmation.");
#line 780
    return;
  }
#line 783
  __u___3.__in = wait_status;
#line 783
  if ((int )((signed char )((__u___3.__i & 127) + 1)) >> 1 > 0) {
#line 785
    __u___2.__in = wait_status;
#line 785
    packet_disconnect("Command terminated on signal %d.", __u___2.__i & 127);
  }
#line 788
  packet_disconnect("wait returned status %04x.", wait_status);
#line 790
  return;
}
}
#line 792 "serverloop.c"
static void collect_children(void) 
{ pid_t pid ;
  sigset_t oset ;
  sigset_t nset ;
  int status ;
  int *tmp ;

  {
#line 800
  sigemptyset(& nset);
#line 801
  sigaddset(& nset, 17);
#line 802
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 803
  if (child_terminated) {
#line 804
    debug("Received SIGCHLD.");
#line 805
    while (1) {
#line 805
      pid = waitpid(-1, & status, 1);
#line 805
      if (! (pid > 0)) {
#line 805
        if (pid < 0) {
#line 805
          tmp = __errno_location();
#line 805
          if (! (*tmp == 4)) {
#line 805
            break;
          }
        } else {
#line 805
          break;
        }
      }
#line 807
      if (pid > 0) {
#line 808
        session_close_by_pid(pid, status);
      }
    }
#line 809
    child_terminated = (int volatile   )0;
  }
#line 811
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 812
  return;
}
}
#line 814 "serverloop.c"
void server_loop2(Authctxt *authctxt___0 ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int rekeying___0 ;
  int max_fd ;
  int nalloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 817
  readset = (fd_set *)((void *)0);
#line 817
  writeset = (fd_set *)((void *)0);
#line 818
  rekeying___0 = 0;
#line 818
  nalloc = 0;
#line 820
  debug("Entering interactive session for SSH2.");
#line 822
  mysignal(17, & sigchld_handler);
#line 823
  child_terminated = (int volatile   )0;
#line 824
  connection_in___0 = packet_get_connection_in();
#line 825
  connection_out___0 = packet_get_connection_out();
#line 827
  if (! use_privsep) {
#line 828
    mysignal(15, & sigterm_handler___0);
#line 829
    mysignal(2, & sigterm_handler___0);
#line 830
    mysignal(3, & sigterm_handler___0);
  }
#line 833
  notify_setup();
#line 835
  if (connection_in___0 > connection_out___0) {
#line 835
    max_fd = connection_in___0;
  } else {
#line 835
    max_fd = connection_out___0;
  }
#line 836
  if (max_fd > notify_pipe[0]) {
#line 836
    max_fd = max_fd;
  } else {
#line 836
    max_fd = notify_pipe[0];
  }
#line 838
  server_init_dispatch();
#line 840
  while (1) {
#line 841
    process_buffered_input_packets();
#line 843
    if ((unsigned int )xxx_kex != (unsigned int )((void *)0)) {
#line 843
      if (! xxx_kex->done) {
#line 843
        tmp = 1;
      } else {
#line 843
        tmp = 0;
      }
    } else {
#line 843
      tmp = 0;
    }
#line 843
    rekeying___0 = tmp;
#line 845
    if (! rekeying___0) {
#line 845
      tmp___0 = packet_not_very_much_data_to_write();
#line 845
      if (tmp___0) {
#line 846
        channel_output_poll();
      }
    }
#line 847
    wait_until_can_do_something(& readset, & writeset, & max_fd, (u_int *)(& nalloc),
                                0U);
#line 850
    if (received_sigterm___0) {
#line 851
      logit("Exiting on signal %d", received_sigterm___0);
#line 853
      cleanup_exit(255);
    }
#line 856
    collect_children();
#line 857
    if (! rekeying___0) {
#line 858
      channel_after_select(readset, writeset);
#line 859
      tmp___1 = packet_need_rekeying();
#line 859
      if (tmp___1) {
#line 860
        debug("need rekeying");
#line 861
        xxx_kex->done = 0;
#line 862
        kex_send_kexinit(xxx_kex);
      }
    }
#line 865
    process_input(readset);
#line 866
    if (connection_closed) {
#line 867
      break;
    }
#line 868
    process_output(writeset);
  }
#line 870
  collect_children();
#line 872
  if (readset) {
#line 873
    xfree((void *)readset);
  }
#line 874
  if (writeset) {
#line 875
    xfree((void *)writeset);
  }
#line 878
  channel_free_all();
#line 881
  session_destroy_all((void (*)(Session * ))((void *)0));
#line 882
  return;
}
}
#line 884 "serverloop.c"
static void server_input_keep_alive(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 887
  debug("Got %d/%u for keepalive", type, seq);
#line 893
  keep_alive_timeouts = 0;
#line 894
  return;
}
}
#line 896 "serverloop.c"
static void server_input_stdin_data(int type , u_int32_t seq , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 904
  if (fdin == -1) {
#line 905
    return;
  }
#line 906
  tmp = packet_get_string(& data_len);
#line 906
  data = (char *)tmp;
#line 907
  while (1) {
#line 907
    tmp___0 = packet_remaining();
#line 907
    _len = tmp___0;
#line 907
    if (_len > 0) {
#line 907
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            907);
#line 907
      packet_disconnect("Packet integrity error.");
    }
#line 907
    break;
  }
#line 908
  buffer_append(& stdin_buffer, (void const   *)data, data_len);
#line 909
  memset((void *)data, 0, data_len);
#line 910
  xfree((void *)data);
#line 911
  return;
}
}
#line 913 "serverloop.c"
static void server_input_eof(int type , u_int32_t seq , void *ctxt ) 
{ int _len ;
  int tmp ;

  {
#line 921
  debug("EOF received for stdin.");
#line 922
  while (1) {
#line 922
    tmp = packet_remaining();
#line 922
    _len = tmp;
#line 922
    if (_len > 0) {
#line 922
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            922);
#line 922
      packet_disconnect("Packet integrity error.");
    }
#line 922
    break;
  }
#line 923
  stdin_eof = 1;
#line 924
  return;
}
}
#line 926 "serverloop.c"
static void server_input_window_size(int type , u_int32_t seq , void *ctxt ) 
{ u_int row ;
  u_int tmp ;
  u_int col ;
  u_int tmp___0 ;
  u_int xpixel ;
  u_int tmp___1 ;
  u_int ypixel ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 929
  tmp = packet_get_int();
#line 929
  row = tmp;
#line 930
  tmp___0 = packet_get_int();
#line 930
  col = tmp___0;
#line 931
  tmp___1 = packet_get_int();
#line 931
  xpixel = tmp___1;
#line 932
  tmp___2 = packet_get_int();
#line 932
  ypixel = tmp___2;
#line 934
  debug("Window change received.");
#line 935
  while (1) {
#line 935
    tmp___3 = packet_remaining();
#line 935
    _len = tmp___3;
#line 935
    if (_len > 0) {
#line 935
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            935);
#line 935
      packet_disconnect("Packet integrity error.");
    }
#line 935
    break;
  }
#line 936
  if (fdin != -1) {
#line 937
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 938
  return;
}
}
#line 940 "serverloop.c"
static Channel *server_request_direct_tcpip(void) 
{ Channel *c ;
  char *target ;
  char *originator ;
  u_short target_port ;
  u_short originator_port ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 947
  tmp = packet_get_string((u_int *)((void *)0));
#line 947
  target = (char *)tmp;
#line 948
  tmp___0 = packet_get_int();
#line 948
  target_port = (unsigned short )tmp___0;
#line 949
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 949
  originator = (char *)tmp___1;
#line 950
  tmp___2 = packet_get_int();
#line 950
  originator_port = (unsigned short )tmp___2;
#line 951
  while (1) {
#line 951
    tmp___3 = packet_remaining();
#line 951
    _len = tmp___3;
#line 951
    if (_len > 0) {
#line 951
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            951);
#line 951
      packet_disconnect("Packet integrity error.");
    }
#line 951
    break;
  }
#line 953
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 957
  c = channel_connect_to((char const   *)target, target_port, (char *)"direct-tcpip",
                         (char *)"direct-tcpip");
#line 960
  xfree((void *)originator);
#line 961
  xfree((void *)target);
#line 963
  return (c);
}
}
#line 966 "serverloop.c"
static Channel *server_request_tun(void) 
{ Channel *c ;
  int mode ;
  int tun ;
  int sock ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 969
  c = (Channel *)((void *)0);
#line 973
  tmp = packet_get_int();
#line 973
  mode = (int )tmp;
#line 974
  switch (mode) {
  case 1: 
  case 2: 
#line 977
  break;
  default: 
#line 979
  packet_send_debug("Unsupported tunnel device mode.");
#line 980
  return ((Channel *)((void *)0));
  }
#line 982
  if ((options.permit_tun & mode) == 0) {
#line 983
    packet_send_debug("Server has rejected tunnel device forwarding");
#line 985
    return ((Channel *)((void *)0));
  }
#line 988
  tmp___0 = packet_get_int();
#line 988
  tun = (int )tmp___0;
#line 989
  if (forced_tun_device != -1) {
#line 990
    if (tun != 2147483647) {
#line 990
      if (forced_tun_device != tun) {
        goto done;
      }
    }
#line 992
    tun = forced_tun_device;
  }
#line 994
  sock = tun_open(tun, mode);
#line 995
  if (sock < 0) {
    goto done;
  }
#line 997
  c = channel_new((char *)"tun", 4, sock, sock, -1, 2097152U, 32768U, 0, (char *)"tun",
                  1);
#line 999
  c->datagram = 1;
#line 1001
  if (mode == 1) {
#line 1002
    channel_register_filter(c->self, & sys_tun_infilter, & sys_tun_outfilter, (channel_filter_cleanup_fn *)((void *)0),
                            (void *)0);
  }
  done: 
#line 1007
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1008
    packet_send_debug("Failed to open the tunnel device.");
  }
#line 1009
  return (c);
}
}
#line 1012 "serverloop.c"
static Channel *server_request_session(void) 
{ Channel *c ;
  int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1017
  debug("input_session_request");
#line 1018
  while (1) {
#line 1018
    tmp = packet_remaining();
#line 1018
    _len = tmp;
#line 1018
    if (_len > 0) {
#line 1018
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            1018);
#line 1018
      packet_disconnect("Packet integrity error.");
    }
#line 1018
    break;
  }
#line 1020
  if (no_more_sessions) {
#line 1021
    packet_disconnect("Possible attack: attempt to open a session after additional sessions disabled");
  }
#line 1031
  c = channel_new((char *)"session", 10, -1, -1, -1, 0U, 32768U, 0, (char *)"server-session",
                  1);
#line 1034
  tmp___0 = session_open(the_authctxt, c->self);
#line 1034
  if (tmp___0 != 1) {
#line 1035
    debug("session open failed, free channel %d", c->self);
#line 1036
    channel_free(c);
#line 1037
    return ((Channel *)((void *)0));
  }
#line 1039
  channel_register_cleanup(c->self, & session_close_by_channel, 0);
#line 1040
  return (c);
}
}
#line 1043 "serverloop.c"
static void server_input_channel_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  int rchan ;
  u_int rmaxpack ;
  u_int rwindow ;
  u_int len ;
  void *tmp ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 1046
  c = (Channel *)((void *)0);
#line 1051
  tmp = packet_get_string(& len);
#line 1051
  ctype = (char *)tmp;
#line 1052
  tmp___0 = packet_get_int();
#line 1052
  rchan = (int )tmp___0;
#line 1053
  rwindow = packet_get_int();
#line 1054
  rmaxpack = packet_get_int();
#line 1056
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 1059
  if (0) {
#line 1059
    __s1_len___1 = strlen((char const   *)ctype);
#line 1059
    __s2_len___1 = strlen("session");
#line 1059
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___4;
    } else {
#line 1059
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1059
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 1059
          tmp___30 = 1;
        } else {
#line 1059
          if (__s2_len___1 >= 4U) {
#line 1059
            tmp___30 = 1;
          } else {
#line 1059
            tmp___30 = 0;
          }
        }
      } else {
#line 1059
        tmp___30 = 0;
      }
    }
#line 1059
    if (tmp___30) {
#line 1059
      tmp___26 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 1059
      tmp___29 = __builtin_strcmp((char const   *)ctype, "session");
#line 1059
      tmp___26 = tmp___29;
    }
  } else {
#line 1059
    tmp___29 = __builtin_strcmp((char const   *)ctype, "session");
#line 1059
    tmp___26 = tmp___29;
  }
#line 1059
  if (tmp___26 == 0) {
#line 1060
    c = server_request_session();
  } else {
#line 1061
    if (0) {
#line 1061
      __s1_len___0 = strlen((char const   *)ctype);
#line 1061
      __s2_len___0 = strlen("direct-tcpip");
#line 1061
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___2;
      } else {
#line 1061
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1061
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1061
            tmp___20 = 1;
          } else {
#line 1061
            if (__s2_len___0 >= 4U) {
#line 1061
              tmp___20 = 1;
            } else {
#line 1061
              tmp___20 = 0;
            }
          }
        } else {
#line 1061
          tmp___20 = 0;
        }
      }
#line 1061
      if (tmp___20) {
#line 1061
        tmp___16 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 1061
        tmp___19 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 1061
        tmp___16 = tmp___19;
      }
    } else {
#line 1061
      tmp___19 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 1061
      tmp___16 = tmp___19;
    }
#line 1061
    if (tmp___16 == 0) {
#line 1062
      c = server_request_direct_tcpip();
    } else {
#line 1063
      if (0) {
#line 1063
        __s1_len = strlen((char const   *)ctype);
#line 1063
        __s2_len = strlen("tun@openssh.com");
#line 1063
        if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
          goto _L___0;
        } else {
#line 1063
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 1063
            if (! ((unsigned int )((void const   *)("tun@openssh.com" + 1)) - (unsigned int )((void const   *)"tun@openssh.com") == 1U)) {
#line 1063
              tmp___10 = 1;
            } else {
#line 1063
              if (__s2_len >= 4U) {
#line 1063
                tmp___10 = 1;
              } else {
#line 1063
                tmp___10 = 0;
              }
            }
          } else {
#line 1063
            tmp___10 = 0;
          }
        }
#line 1063
        if (tmp___10) {
#line 1063
          tmp___6 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
        } else {
#line 1063
          tmp___9 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
#line 1063
          tmp___6 = tmp___9;
        }
      } else {
#line 1063
        tmp___9 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
#line 1063
        tmp___6 = tmp___9;
      }
#line 1063
      if (tmp___6 == 0) {
#line 1064
        c = server_request_tun();
      }
    }
  }
#line 1066
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 1067
    debug("server_input_channel_open: confirm %s", ctype);
#line 1068
    c->remote_id = rchan;
#line 1069
    c->remote_window = rwindow;
#line 1070
    c->remote_maxpacket = rmaxpack;
#line 1071
    if (c->type != 12) {
#line 1072
      packet_start((unsigned char)91);
#line 1073
      packet_put_int((unsigned int )c->remote_id);
#line 1074
      packet_put_int((unsigned int )c->self);
#line 1075
      packet_put_int(c->local_window);
#line 1076
      packet_put_int(c->local_maxpacket);
#line 1077
      packet_send();
    }
  } else {
#line 1080
    debug("server_input_channel_open: failure %s", ctype);
#line 1081
    packet_start((unsigned char)92);
#line 1082
    packet_put_int((unsigned int )rchan);
#line 1083
    packet_put_int(1U);
#line 1084
    if (! (datafellows & 131072)) {
#line 1085
      packet_put_cstring("open failed");
#line 1086
      packet_put_cstring("");
    }
#line 1088
    packet_send();
  }
#line 1090
  xfree((void *)ctype);
#line 1091
  return;
}
}
#line 1093 "serverloop.c"
static void server_input_global_request(int type , u_int32_t seq , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  int allocated_listen_port ;
  void *tmp ;
  u_int tmp___0 ;
  struct passwd *pw___0 ;
  char *listen_address ;
  u_short listen_port ;
  void *tmp___1 ;
  u_int tmp___2 ;
  char *cancel_address ;
  u_short cancel_port ;
  void *tmp___3 ;
  u_int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 1098
  success = 0;
#line 1098
  allocated_listen_port = 0;
#line 1100
  tmp = packet_get_string((u_int *)((void *)0));
#line 1100
  rtype = (char *)tmp;
#line 1101
  tmp___0 = packet_get_char();
#line 1101
  want_reply = (int )tmp___0;
#line 1102
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 1105
  if (0) {
#line 1105
    __s1_len___1 = strlen((char const   *)rtype);
#line 1105
    __s2_len___1 = strlen("tcpip-forward");
#line 1105
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___5;
    } else {
#line 1105
      if (__s1_len___1 >= 4U) {
        _L___5: /* CIL Label */ 
#line 1105
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 1105
          tmp___34 = 1;
        } else {
#line 1105
          if (__s2_len___1 >= 4U) {
#line 1105
            tmp___34 = 1;
          } else {
#line 1105
            tmp___34 = 0;
          }
        }
      } else {
#line 1105
        tmp___34 = 0;
      }
    }
#line 1105
    if (tmp___34) {
#line 1105
      tmp___30 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 1105
      tmp___33 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 1105
      tmp___30 = tmp___33;
    }
  } else {
#line 1105
    tmp___33 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 1105
    tmp___30 = tmp___33;
  }
#line 1105
  if (tmp___30 == 0) {
#line 1110
    pw___0 = the_authctxt->pw;
#line 1111
    if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 1112
      fatal("server_input_global_request: no/invalid user");
    } else {
#line 1111
      if (! the_authctxt->valid) {
#line 1112
        fatal("server_input_global_request: no/invalid user");
      }
    }
#line 1113
    tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1113
    listen_address = (char *)tmp___1;
#line 1114
    tmp___2 = packet_get_int();
#line 1114
    listen_port = (unsigned short )tmp___2;
#line 1115
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 1119
    if (! options.allow_tcp_forwarding) {
#line 1126
      success = 0;
#line 1127
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 1119
      if (no_port_forwarding_flag) {
#line 1126
        success = 0;
#line 1127
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 1119
        if (! want_reply) {
#line 1119
          if ((int )listen_port == 0) {
#line 1126
            success = 0;
#line 1127
            packet_send_debug("Server has disabled port forwarding.");
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 1119
          if ((int )listen_port < 1024) {
#line 1119
            if (pw___0->pw_uid != 0U) {
#line 1126
              success = 0;
#line 1127
              packet_send_debug("Server has disabled port forwarding.");
            } else {
#line 1130
              success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                          listen_port, & allocated_listen_port,
                                                          options.gateway_ports);
            }
          } else {
#line 1130
            success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                        listen_port, & allocated_listen_port,
                                                        options.gateway_ports);
          }
        }
      }
    }
#line 1134
    xfree((void *)listen_address);
  } else {
#line 1135
    if (0) {
#line 1135
      __s1_len___0 = strlen((char const   *)rtype);
#line 1135
      __s2_len___0 = strlen("cancel-tcpip-forward");
#line 1135
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___3;
      } else {
#line 1135
        if (__s1_len___0 >= 4U) {
          _L___3: /* CIL Label */ 
#line 1135
          if (! ((unsigned int )((void const   *)("cancel-tcpip-forward" + 1)) - (unsigned int )((void const   *)"cancel-tcpip-forward") == 1U)) {
#line 1135
            tmp___24 = 1;
          } else {
#line 1135
            if (__s2_len___0 >= 4U) {
#line 1135
              tmp___24 = 1;
            } else {
#line 1135
              tmp___24 = 0;
            }
          }
        } else {
#line 1135
          tmp___24 = 0;
        }
      }
#line 1135
      if (tmp___24) {
#line 1135
        tmp___20 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
      } else {
#line 1135
        tmp___23 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
#line 1135
        tmp___20 = tmp___23;
      }
    } else {
#line 1135
      tmp___23 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
#line 1135
      tmp___20 = tmp___23;
    }
#line 1135
    if (tmp___20 == 0) {
#line 1139
      tmp___3 = packet_get_string((u_int *)((void *)0));
#line 1139
      cancel_address = (char *)tmp___3;
#line 1140
      tmp___4 = packet_get_int();
#line 1140
      cancel_port = (unsigned short )tmp___4;
#line 1141
      debug("%s: cancel-tcpip-forward addr %s port %d", "server_input_global_request",
            cancel_address, cancel_port);
#line 1144
      success = channel_cancel_rport_listener((char const   *)cancel_address, cancel_port);
#line 1146
      xfree((void *)cancel_address);
    } else {
#line 1147
      if (0) {
#line 1147
        __s1_len = strlen((char const   *)rtype);
#line 1147
        __s2_len = strlen("no-more-sessions@openssh.com");
#line 1147
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___1;
        } else {
#line 1147
          if (__s1_len >= 4U) {
            _L___1: /* CIL Label */ 
#line 1147
            if (! ((unsigned int )((void const   *)("no-more-sessions@openssh.com" + 1)) - (unsigned int )((void const   *)"no-more-sessions@openssh.com") == 1U)) {
#line 1147
              tmp___14 = 1;
            } else {
#line 1147
              if (__s2_len >= 4U) {
#line 1147
                tmp___14 = 1;
              } else {
#line 1147
                tmp___14 = 0;
              }
            }
          } else {
#line 1147
            tmp___14 = 0;
          }
        }
#line 1147
        if (tmp___14) {
#line 1147
          tmp___10 = __builtin_strcmp((char const   *)rtype, "no-more-sessions@openssh.com");
        } else {
#line 1147
          tmp___13 = __builtin_strcmp((char const   *)rtype, "no-more-sessions@openssh.com");
#line 1147
          tmp___10 = tmp___13;
        }
      } else {
#line 1147
        tmp___13 = __builtin_strcmp((char const   *)rtype, "no-more-sessions@openssh.com");
#line 1147
        tmp___10 = tmp___13;
      }
#line 1147
      if (tmp___10 == 0) {
#line 1148
        no_more_sessions = 1;
#line 1149
        success = 1;
      }
    }
  }
#line 1151
  if (want_reply) {
#line 1152
    if (success) {
#line 1152
      tmp___35 = 81;
    } else {
#line 1152
      tmp___35 = 82;
    }
#line 1152
    packet_start((unsigned char )tmp___35);
#line 1154
    if (success) {
#line 1154
      if (allocated_listen_port > 0) {
#line 1155
        packet_put_int((unsigned int )allocated_listen_port);
      }
    }
#line 1156
    packet_send();
#line 1157
    packet_write_wait();
  }
#line 1159
  xfree((void *)rtype);
#line 1160
  return;
}
}
#line 1162 "serverloop.c"
static void server_input_channel_req(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  int reply ;
  int success ;
  char *rtype ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 1166
  success = 0;
#line 1169
  tmp = packet_get_int();
#line 1169
  id = (int )tmp;
#line 1170
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1170
  rtype = (char *)tmp___0;
#line 1171
  tmp___1 = packet_get_char();
#line 1171
  reply = (int )tmp___1;
#line 1173
  debug("server_input_channel_req: channel %d request %s reply %d", id, rtype, reply);
#line 1176
  c = channel_lookup(id);
#line 1176
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1177
    packet_disconnect("server_input_channel_req: unknown channel %d", id);
  }
#line 1179
  if (0) {
#line 1179
    __s1_len___0 = strlen((char const   *)rtype);
#line 1179
    __s2_len___0 = strlen("eow@openssh.com");
#line 1179
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___3;
    } else {
#line 1179
      if (__s1_len___0 >= 4U) {
        _L___3: /* CIL Label */ 
#line 1179
        if (! ((unsigned int )((void const   *)("eow@openssh.com" + 1)) - (unsigned int )((void const   *)"eow@openssh.com") == 1U)) {
#line 1179
          tmp___22 = 1;
        } else {
#line 1179
          if (__s2_len___0 >= 4U) {
#line 1179
            tmp___22 = 1;
          } else {
#line 1179
            tmp___22 = 0;
          }
        }
      } else {
#line 1179
        tmp___22 = 0;
      }
    }
#line 1179
    if (tmp___22) {
#line 1179
      tmp___18 = __builtin_strcmp((char const   *)rtype, "eow@openssh.com");
    } else {
#line 1179
      tmp___21 = __builtin_strcmp((char const   *)rtype, "eow@openssh.com");
#line 1179
      tmp___18 = tmp___21;
    }
  } else {
#line 1179
    tmp___21 = __builtin_strcmp((char const   *)rtype, "eow@openssh.com");
#line 1179
    tmp___18 = tmp___21;
  }
#line 1179
  if (tmp___18) {
#line 1183
    if (c->type == 10) {
      goto _L___1;
    } else {
#line 1183
      if (c->type == 4) {
        _L___1: /* CIL Label */ 
#line 1183
        if (0) {
#line 1183
          __s1_len = strlen((char const   *)c->ctype);
#line 1183
          __s2_len = strlen("session");
#line 1183
          if (! ((unsigned int )((void const   *)(c->ctype + 1)) - (unsigned int )((void const   *)c->ctype) == 1U)) {
            goto _L___0;
          } else {
#line 1183
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1183
              if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 1183
                tmp___12 = 1;
              } else {
#line 1183
                if (__s2_len >= 4U) {
#line 1183
                  tmp___12 = 1;
                } else {
#line 1183
                  tmp___12 = 0;
                }
              }
            } else {
#line 1183
              tmp___12 = 0;
            }
          }
#line 1183
          if (tmp___12) {
#line 1183
            tmp___8 = __builtin_strcmp((char const   *)c->ctype, "session");
          } else {
#line 1183
            tmp___11 = __builtin_strcmp((char const   *)c->ctype, "session");
#line 1183
            tmp___8 = tmp___11;
          }
        } else {
#line 1183
          tmp___11 = __builtin_strcmp((char const   *)c->ctype, "session");
#line 1183
          tmp___8 = tmp___11;
        }
#line 1183
        if (tmp___8 == 0) {
#line 1184
          success = session_input_channel_req(c, (char const   *)rtype);
        }
      }
    }
  } else {
#line 1180
    while (1) {
#line 1180
      tmp___2 = packet_remaining();
#line 1180
      _len = tmp___2;
#line 1180
      if (_len > 0) {
#line 1180
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
              1180);
#line 1180
        packet_disconnect("Packet integrity error.");
      }
#line 1180
      break;
    }
#line 1181
    chan_rcvd_eow(c);
  }
#line 1185
  if (reply) {
#line 1186
    if (success) {
#line 1186
      tmp___23 = 99;
    } else {
#line 1186
      tmp___23 = 100;
    }
#line 1186
    packet_start((unsigned char )tmp___23);
#line 1188
    packet_put_int((unsigned int )c->remote_id);
#line 1189
    packet_send();
  }
#line 1191
  xfree((void *)rtype);
#line 1192
  return;
}
}
#line 1194 "serverloop.c"
static void server_init_dispatch_20(void) 
{ 

  {
#line 1197
  debug("server_init_dispatch_20");
#line 1198
  dispatch_init(& dispatch_protocol_error);
#line 1199
  dispatch_set(97, & channel_input_oclose);
#line 1200
  dispatch_set(94, & channel_input_data);
#line 1201
  dispatch_set(96, & channel_input_ieof);
#line 1202
  dispatch_set(95, & channel_input_extended_data);
#line 1203
  dispatch_set(90, & server_input_channel_open);
#line 1204
  dispatch_set(91, & channel_input_open_confirmation);
#line 1205
  dispatch_set(92, & channel_input_open_failure);
#line 1206
  dispatch_set(98, & server_input_channel_req);
#line 1207
  dispatch_set(93, & channel_input_window_adjust);
#line 1208
  dispatch_set(80, & server_input_global_request);
#line 1210
  dispatch_set(99, & server_input_keep_alive);
#line 1211
  dispatch_set(100, & server_input_keep_alive);
#line 1212
  dispatch_set(81, & server_input_keep_alive);
#line 1213
  dispatch_set(82, & server_input_keep_alive);
#line 1215
  dispatch_set(20, & kex_input_kexinit);
#line 1216
  return;
}
}
#line 1217 "serverloop.c"
static void server_init_dispatch_13(void) 
{ 

  {
#line 1220
  debug("server_init_dispatch_13");
#line 1221
  dispatch_init((dispatch_fn *)((void *)0));
#line 1222
  dispatch_set(19, & server_input_eof);
#line 1223
  dispatch_set(16, & server_input_stdin_data);
#line 1224
  dispatch_set(11, & server_input_window_size);
#line 1225
  dispatch_set(24, & channel_input_close);
#line 1226
  dispatch_set(25, & channel_input_close_confirmation);
#line 1227
  dispatch_set(23, & channel_input_data);
#line 1228
  dispatch_set(21, & channel_input_open_confirmation);
#line 1229
  dispatch_set(22, & channel_input_open_failure);
#line 1230
  dispatch_set(29, & channel_input_port_open);
#line 1231
  return;
}
}
#line 1232 "serverloop.c"
static void server_init_dispatch_15(void) 
{ 

  {
#line 1235
  server_init_dispatch_13();
#line 1236
  debug("server_init_dispatch_15");
#line 1237
  dispatch_set(24, & channel_input_ieof);
#line 1238
  dispatch_set(25, & channel_input_oclose);
#line 1239
  return;
}
}
#line 1240 "serverloop.c"
static void server_init_dispatch(void) 
{ 

  {
#line 1243
  if (compat20) {
#line 1244
    server_init_dispatch_20();
  } else {
#line 1245
    if (compat13) {
#line 1246
      server_init_dispatch_13();
    } else {
#line 1248
      server_init_dispatch_15();
    }
  }
#line 1249
  return;
}
}
#line 1 "auth.o"
#pragma merger(0,"./auth.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 756 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 31 "groupaccess.h"
int ga_match(char * const  *groups , int n___0 ) ;
#line 131 "auth.h"
int auth_shadow_acctexpired(struct spwd *spw ) ;
#line 144
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) ;
#line 147
int auth_root_allowed(char *method ) ;
#line 163
int allowed_user(struct passwd *pw___0 ) ;
#line 164
struct passwd *getpwnamallow(char const   *user ) ;
#line 171
char *authorized_keys_file2(struct passwd *pw___0 ) ;
#line 190
struct passwd *fakepw(void) ;
#line 30 "auth-options.h"
char *forced_command ;
#line 129 "loginrec.h"
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) ;
#line 40 "monitor_wrap.h"
int mm_is_monitor(void) ;
#line 81 "auth.c"
Buffer auth_debug  ;
#line 82 "auth.c"
int auth_debug_init  ;
#line 93 "auth.c"
int allowed_user(struct passwd *pw___0 ) 
{ struct stat st ;
  char const   *hostname ;
  char const   *ipaddr ;
  char const   *passwd ;
  char *shell ;
  u_int i ;
  struct spwd *spw ;
  int tmp ;
  int locked ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
#line 97
  hostname = (char const   *)((void *)0);
#line 97
  ipaddr = (char const   *)((void *)0);
#line 97
  passwd = (char const   *)((void *)0);
#line 101
  spw = (struct spwd *)((void *)0);
#line 105
  if (! pw___0) {
#line 106
    return (0);
  } else {
#line 105
    if (! pw___0->pw_name) {
#line 106
      return (0);
    }
  }
#line 109
  if (! options.use_pam) {
#line 110
    spw = getspnam((char const   *)pw___0->pw_name);
  }
#line 112
  if (! options.use_pam) {
#line 112
    if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 112
      tmp = auth_shadow_acctexpired(spw);
#line 112
      if (tmp) {
#line 113
        return (0);
      }
    }
  }
#line 118
  passwd = (char const   *)pw___0->pw_passwd;
#line 120
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 124
    passwd = (char const   *)spw->sp_pwdp;
  }
#line 129
  if (! options.use_pam) {
#line 129
    if (passwd) {
#line 129
      if (*passwd) {
#line 130
        locked = 0;
#line 137
        if (0) {
#line 137
          if (0) {
#line 137
            __s1_len___0 = strlen(passwd);
#line 137
            __s2_len___0 = strlen("!");
#line 137
            if (! ((unsigned int )((void const   *)(passwd + 1)) - (unsigned int )((void const   *)passwd) == 1U)) {
              goto _L___2;
            } else {
#line 137
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 137
                if (! ((unsigned int )((void const   *)("!" + 1)) - (unsigned int )((void const   *)"!") == 1U)) {
#line 137
                  tmp___27 = 1;
                } else {
#line 137
                  if (__s2_len___0 >= 4U) {
#line 137
                    tmp___27 = 1;
                  } else {
#line 137
                    tmp___27 = 0;
                  }
                }
              } else {
#line 137
                tmp___27 = 0;
              }
            }
#line 137
            if (tmp___27) {
#line 137
              tmp___23 = __builtin_strcmp(passwd, "!");
            } else {
#line 137
              tmp___26 = __builtin_strcmp(passwd, "!");
#line 137
              tmp___23 = tmp___26;
            }
          } else {
#line 137
            tmp___26 = __builtin_strcmp(passwd, "!");
#line 137
            tmp___23 = tmp___26;
          }
#line 137
          tmp___17 = tmp___23;
        } else {
#line 137
          tmp___28 = strlen("!");
#line 137
          tmp___17 = strncmp(passwd, "!", tmp___28);
        }
#line 137
        if (tmp___17 == 0) {
#line 139
          locked = 1;
        }
#line 148
        if (locked) {
#line 149
          logit("User %.100s not allowed because account is locked", pw___0->pw_name);
#line 151
          return (0);
        }
      }
    }
  }
#line 159
  if ((int )*(pw___0->pw_shell + 0) == 0) {
#line 159
    shell = (char *)"/bin/sh";
  } else {
#line 159
    shell = pw___0->pw_shell;
  }
#line 162
  tmp___34 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 162
  if (tmp___34 != 0) {
#line 163
    logit("User %.100s not allowed because shell %.100s does not exist", pw___0->pw_name,
          shell);
#line 165
    return (0);
  }
#line 167
  if (((st.st_mode & 61440U) == 32768U) == 0) {
#line 169
    logit("User %.100s not allowed because shell %.100s is not executable", pw___0->pw_name,
          shell);
#line 171
    return (0);
  } else {
#line 167
    if ((st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3))) == 0U) {
#line 169
      logit("User %.100s not allowed because shell %.100s is not executable", pw___0->pw_name,
            shell);
#line 171
      return (0);
    }
  }
#line 174
  if (options.num_deny_users > 0U) {
#line 176
    hostname = get_canonical_hostname(options.use_dns);
#line 177
    ipaddr = get_remote_ipaddr();
  } else {
#line 174
    if (options.num_allow_users > 0U) {
#line 176
      hostname = get_canonical_hostname(options.use_dns);
#line 177
      ipaddr = get_remote_ipaddr();
    } else {
#line 174
      if (options.num_deny_groups > 0U) {
#line 176
        hostname = get_canonical_hostname(options.use_dns);
#line 177
        ipaddr = get_remote_ipaddr();
      } else {
#line 174
        if (options.num_allow_groups > 0U) {
#line 176
          hostname = get_canonical_hostname(options.use_dns);
#line 177
          ipaddr = get_remote_ipaddr();
        }
      }
    }
  }
#line 181
  if (options.num_deny_users > 0U) {
#line 182
    i = 0U;
#line 182
    while (i < options.num_deny_users) {
#line 183
      tmp___35 = match_user((char const   *)pw___0->pw_name, hostname, ipaddr, (char const   *)options.deny_users[i]);
#line 183
      if (tmp___35) {
#line 185
        logit("User %.100s from %.100s not allowed because listed in DenyUsers", pw___0->pw_name,
              hostname);
#line 188
        return (0);
      }
#line 182
      i ++;
    }
  }
#line 192
  if (options.num_allow_users > 0U) {
#line 193
    i = 0U;
#line 193
    while (i < options.num_allow_users) {
#line 194
      tmp___36 = match_user((char const   *)pw___0->pw_name, hostname, ipaddr, (char const   *)options.allow_users[i]);
#line 194
      if (tmp___36) {
#line 196
        break;
      }
#line 193
      i ++;
    }
#line 198
    if (i >= options.num_allow_users) {
#line 199
      logit("User %.100s from %.100s not allowed because not listed in AllowUsers",
            pw___0->pw_name, hostname);
#line 201
      return (0);
    }
  }
#line 204
  if (options.num_deny_groups > 0U) {
    goto _L___3;
  } else {
#line 204
    if (options.num_allow_groups > 0U) {
      _L___3: /* CIL Label */ 
#line 206
      tmp___37 = ga_init((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 206
      if (tmp___37 == 0) {
#line 207
        logit("User %.100s from %.100s not allowed because not in any group", pw___0->pw_name,
              hostname);
#line 209
        return (0);
      }
#line 213
      if (options.num_deny_groups > 0U) {
#line 214
        tmp___38 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 214
        if (tmp___38) {
#line 216
          ga_free();
#line 217
          logit("User %.100s from %.100s not allowed because a group is listed in DenyGroups",
                pw___0->pw_name, hostname);
#line 220
          return (0);
        }
      }
#line 226
      if (options.num_allow_groups > 0U) {
#line 227
        tmp___39 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 227
        if (! tmp___39) {
#line 229
          ga_free();
#line 230
          logit("User %.100s from %.100s not allowed because none of user\'s groups are listed in AllowGroups",
                pw___0->pw_name, hostname);
#line 233
          return (0);
        }
      }
#line 235
      ga_free();
    }
  }
#line 244
  return (1);
}
}
#line 247 "auth.c"
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___37 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;

  {
#line 250
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 253
  if (use_privsep) {
#line 253
    tmp = mm_is_monitor();
#line 253
    if (! tmp) {
#line 253
      if (! authctxt___0->postponed) {
#line 254
        return;
      }
    }
  }
#line 260
  if (authenticated == 1) {
#line 261
    authlog = (void (*)(char const   *fmt  , ...))(& logit);
  } else {
#line 260
    if (! authctxt___0->valid) {
#line 261
      authlog = (void (*)(char const   *fmt  , ...))(& logit);
    } else {
#line 260
      if (authctxt___0->failures >= options.max_authtries / 2) {
#line 261
        authlog = (void (*)(char const   *fmt  , ...))(& logit);
      } else {
#line 260
        if (0) {
#line 260
          __s1_len = strlen((char const   *)method);
#line 260
          __s2_len = strlen("password");
#line 260
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 260
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 260
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 260
                tmp___9 = 1;
              } else {
#line 260
                if (__s2_len >= 4U) {
#line 260
                  tmp___9 = 1;
                } else {
#line 260
                  tmp___9 = 0;
                }
              }
            } else {
#line 260
              tmp___9 = 0;
            }
          }
#line 260
          if (tmp___9) {
#line 260
            tmp___5 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 260
            tmp___8 = __builtin_strcmp((char const   *)method, "password");
#line 260
            tmp___5 = tmp___8;
          }
        } else {
#line 260
          tmp___8 = __builtin_strcmp((char const   *)method, "password");
#line 260
          tmp___5 = tmp___8;
        }
#line 260
        if (tmp___5 == 0) {
#line 261
          authlog = (void (*)(char const   *fmt  , ...))(& logit);
        }
      }
    }
  }
#line 263
  if (authctxt___0->postponed) {
#line 264
    authmsg = (char *)"Postponed";
  } else {
#line 266
    if (authenticated) {
#line 266
      authmsg = (char *)"Accepted";
    } else {
#line 266
      authmsg = (char *)"Failed";
    }
  }
#line 268
  tmp___10 = get_remote_port();
#line 268
  tmp___11 = get_remote_ipaddr();
#line 268
  if (authctxt___0->valid) {
#line 268
    tmp___12 = "";
  } else {
#line 268
    tmp___12 = "invalid user ";
  }
#line 268
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___12,
             authctxt___0->user, tmp___11, tmp___10, info);
#line 281
  if (authenticated == 0) {
#line 281
    if (! authctxt___0->postponed) {
#line 279
      if (0) {
#line 279
        __s1_len___0 = strlen((char const   *)method);
#line 279
        __s2_len___0 = strlen("password");
#line 279
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___2;
        } else {
#line 279
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 279
            if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 279
              tmp___23 = 1;
            } else {
#line 279
              if (__s2_len___0 >= 4U) {
#line 279
                tmp___23 = 1;
              } else {
#line 279
                tmp___23 = 0;
              }
            }
          } else {
#line 279
            tmp___23 = 0;
          }
        }
#line 279
        if (tmp___23) {
#line 279
          tmp___19 = __builtin_strcmp((char const   *)method, "password");
        } else {
#line 279
          tmp___22 = __builtin_strcmp((char const   *)method, "password");
#line 279
          tmp___19 = tmp___22;
        }
      } else {
#line 279
        tmp___22 = __builtin_strcmp((char const   *)method, "password");
#line 279
        tmp___19 = tmp___22;
      }
#line 281
      if (tmp___19 == 0) {
#line 282
        tmp___13 = get_canonical_hostname(options.use_dns);
#line 282
        record_failed_login((char const   *)authctxt___0->user, tmp___13, "ssh");
      } else {
#line 280
        if (0) {
#line 280
          if (0) {
#line 280
            __s1_len___2 = strlen((char const   *)method);
#line 280
            __s2_len___2 = strlen("keyboard-interactive");
#line 280
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___6;
            } else {
#line 280
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 280
                if (! ((unsigned int )((void const   *)("keyboard-interactive" + 1)) - (unsigned int )((void const   *)"keyboard-interactive") == 1U)) {
#line 280
                  tmp___47 = 1;
                } else {
#line 280
                  if (__s2_len___2 >= 4U) {
#line 280
                    tmp___47 = 1;
                  } else {
#line 280
                    tmp___47 = 0;
                  }
                }
              } else {
#line 280
                tmp___47 = 0;
              }
            }
#line 280
            if (tmp___47) {
#line 280
              tmp___43 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
            } else {
#line 280
              tmp___46 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
#line 280
              tmp___43 = tmp___46;
            }
          } else {
#line 280
            tmp___46 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
#line 280
            tmp___43 = tmp___46;
          }
#line 280
          tmp___37 = tmp___43;
        } else {
#line 280
          tmp___37 = strncmp((char const   *)method, "keyboard-interactive", 20U);
        }
#line 281
        if (tmp___37 == 0) {
#line 282
          tmp___13 = get_canonical_hostname(options.use_dns);
#line 282
          record_failed_login((char const   *)authctxt___0->user, tmp___13, "ssh");
        } else {
#line 281
          if (0) {
#line 281
            __s1_len___3 = strlen((char const   *)method);
#line 281
            __s2_len___3 = strlen("challenge-response");
#line 281
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___8;
            } else {
#line 281
              if (__s1_len___3 >= 4U) {
                _L___8: /* CIL Label */ 
#line 281
                if (! ((unsigned int )((void const   *)("challenge-response" + 1)) - (unsigned int )((void const   *)"challenge-response") == 1U)) {
#line 281
                  tmp___59 = 1;
                } else {
#line 281
                  if (__s2_len___3 >= 4U) {
#line 281
                    tmp___59 = 1;
                  } else {
#line 281
                    tmp___59 = 0;
                  }
                }
              } else {
#line 281
                tmp___59 = 0;
              }
            }
#line 281
            if (tmp___59) {
#line 281
              tmp___55 = __builtin_strcmp((char const   *)method, "challenge-response");
            } else {
#line 281
              tmp___58 = __builtin_strcmp((char const   *)method, "challenge-response");
#line 281
              tmp___55 = tmp___58;
            }
          } else {
#line 281
            tmp___58 = __builtin_strcmp((char const   *)method, "challenge-response");
#line 281
            tmp___55 = tmp___58;
          }
#line 281
          if (tmp___55 == 0) {
#line 282
            tmp___13 = get_canonical_hostname(options.use_dns);
#line 282
            record_failed_login((char const   *)authctxt___0->user, tmp___13, "ssh");
          }
        }
      }
    }
  }
#line 294
  return;
}
}
#line 299 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 302
  switch (options.permit_root_login) {
  case 3: 
#line 304
  return (1);
  case 2: 
#line 306
  if (0) {
#line 306
    __s1_len = strlen((char const   *)method);
#line 306
    __s2_len = strlen("password");
#line 306
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 306
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 306
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 306
          tmp___8 = 1;
        } else {
#line 306
          if (__s2_len >= 4U) {
#line 306
            tmp___8 = 1;
          } else {
#line 306
            tmp___8 = 0;
          }
        }
      } else {
#line 306
        tmp___8 = 0;
      }
    }
#line 306
    if (tmp___8) {
#line 306
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 306
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 306
      tmp___4 = tmp___7;
    }
  } else {
#line 306
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 306
    tmp___4 = tmp___7;
  }
#line 306
  if (tmp___4 != 0) {
#line 307
    return (1);
  }
#line 308
  break;
  case 1: 
#line 310
  if (forced_command) {
#line 311
    logit("Root login accepted for forced command.");
#line 312
    return (1);
  }
#line 314
  break;
  }
#line 316
  tmp___9 = get_remote_ipaddr();
#line 316
  logit("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 317
  return (0);
}
}
#line 328 "auth.c"
static char *expand_authorized_keys(char const   *filename , struct passwd *pw___0 ) 
{ char *file___0 ;
  char ret___0[4096] ;
  int i ;
  char *tmp ;

  {
#line 334
  file___0 = percent_expand(filename, "h", pw___0->pw_dir, "u", pw___0->pw_name, (char *)((void *)0));
#line 341
  if ((int )*file___0 == 47) {
#line 342
    return (file___0);
  }
#line 344
  i = snprintf((char * __restrict  )(ret___0), sizeof(ret___0), (char const   * __restrict  )"%s/%s",
               pw___0->pw_dir, file___0);
#line 345
  if (i < 0) {
#line 346
    fatal("expand_authorized_keys: path too long");
  } else {
#line 345
    if ((unsigned int )i >= sizeof(ret___0)) {
#line 346
      fatal("expand_authorized_keys: path too long");
    }
  }
#line 347
  xfree((void *)file___0);
#line 348
  tmp = xstrdup((char const   *)(ret___0));
#line 348
  return (tmp);
}
}
#line 351 "auth.c"
char *authorized_keys_file(struct passwd *pw___0 ) 
{ char *tmp ;

  {
#line 354
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file, pw___0);
#line 354
  return (tmp);
}
}
#line 357 "auth.c"
char *authorized_keys_file2(struct passwd *pw___0 ) 
{ char *tmp ;

  {
#line 360
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file2, pw___0);
#line 360
  return (tmp);
}
}
#line 364 "auth.c"
HostStatus check_key_in_hostfiles(struct passwd *pw___0 , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) 
{ Key *found ;
  char *user_hostfile ;
  struct stat st ;
  HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 374
  found = key_new(key->type);
#line 375
  host_status = check_host_in_hostfile(sysfile, host, (Key const   *)key, found, (int *)((void *)0));
#line 377
  if ((int )host_status != 0) {
#line 377
    if ((unsigned int )userfile != (unsigned int )((void *)0)) {
#line 378
      user_hostfile = tilde_expand_filename(userfile, pw___0->pw_uid);
#line 379
      if (options.strict_modes) {
#line 379
        tmp = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 379
        if (tmp == 0) {
#line 379
          if (st.st_uid != 0U) {
#line 379
            if (st.st_uid != pw___0->pw_uid) {
#line 383
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw___0->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 379
            if ((st.st_mode & 18U) != 0U) {
#line 383
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw___0->pw_name, user_hostfile);
            } else {
#line 387
              temporarily_use_uid(pw___0);
#line 388
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   host, (Key const   *)key, found,
                                                   (int *)((void *)0));
#line 390
              restore_uid();
            }
          }
        } else {
#line 387
          temporarily_use_uid(pw___0);
#line 388
          host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                               (Key const   *)key, found, (int *)((void *)0));
#line 390
          restore_uid();
        }
      } else {
#line 387
        temporarily_use_uid(pw___0);
#line 388
        host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                             (Key const   *)key, found, (int *)((void *)0));
#line 390
        restore_uid();
      }
#line 392
      xfree((void *)user_hostfile);
    }
  }
#line 394
  key_free(found);
#line 396
  if ((int )host_status == 0) {
#line 396
    tmp___0 = "ok";
  } else {
#line 396
    tmp___0 = "not found";
  }
#line 396
  debug2("check_key_in_hostfiles: key %s for %s", tmp___0, host);
#line 398
  return (host_status);
}
}
#line 414 "auth.c"
static int secure_filename(FILE *f , char const   *file___0 , struct passwd *pw___0 ,
                           char *err , size_t errlen ) 
{ uid_t uid ;
  char buf___1[4096] ;
  char homedir[4096] ;
  char *cp ;
  int comparehome ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 418
  uid = pw___0->pw_uid;
#line 421
  comparehome = 0;
#line 424
  tmp___1 = realpath((char const   * __restrict  )file___0, (char * __restrict  )(buf___1));
#line 424
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 425
    tmp = __errno_location();
#line 425
    tmp___0 = strerror(*tmp);
#line 425
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"realpath %s failed: %s",
             file___0, tmp___0);
#line 427
    return (-1);
  }
#line 429
  tmp___2 = realpath((char const   * __restrict  )pw___0->pw_dir, (char * __restrict  )(homedir));
#line 429
  if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 430
    comparehome = 1;
  }
#line 433
  tmp___3 = fileno(f);
#line 433
  tmp___4 = fstat(tmp___3, & st);
#line 433
  if (tmp___4 < 0) {
#line 436
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
             buf___1);
#line 438
    return (-1);
  } else {
#line 433
    if (st.st_uid != 0U) {
#line 433
      if (st.st_uid != uid) {
#line 436
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 438
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 433
      if ((st.st_mode & 18U) != 0U) {
#line 436
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 438
        return (-1);
      }
    }
  }
#line 442
  while (1) {
#line 443
    cp = dirname(buf___1);
#line 443
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 444
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"dirname() failed");
#line 445
      return (-1);
    }
#line 447
    strlcpy(buf___1, (char const   *)cp, sizeof(buf___1));
#line 449
    debug3("secure_filename: checking \'%s\'", buf___1);
#line 450
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 450
    if (tmp___5 < 0) {
#line 453
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
               buf___1);
#line 455
      return (-1);
    } else {
#line 450
      if (st.st_uid != 0U) {
#line 450
        if (st.st_uid != uid) {
#line 453
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 455
          return (-1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 450
        if ((st.st_mode & 18U) != 0U) {
#line 453
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 455
          return (-1);
        }
      }
    }
#line 459
    if (comparehome) {
#line 459
      if (0) {
#line 459
        __s1_len = strlen((char const   *)(homedir));
#line 459
        __s2_len = strlen((char const   *)(buf___1));
#line 459
        if (! ((unsigned int )((void const   *)(homedir + 1)) - (unsigned int )((void const   *)(homedir)) == 1U)) {
          goto _L___2;
        } else {
#line 459
          if (__s1_len >= 4U) {
            _L___2: /* CIL Label */ 
#line 459
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 459
              tmp___15 = 1;
            } else {
#line 459
              if (__s2_len >= 4U) {
#line 459
                tmp___15 = 1;
              } else {
#line 459
                tmp___15 = 0;
              }
            }
          } else {
#line 459
            tmp___15 = 0;
          }
        }
#line 459
        if (tmp___15) {
#line 459
          tmp___11 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
        } else {
#line 459
          tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 459
          tmp___11 = tmp___14;
        }
      } else {
#line 459
        tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 459
        tmp___11 = tmp___14;
      }
#line 459
      if (tmp___11 == 0) {
#line 460
        debug3("secure_filename: terminating check at \'%s\'", buf___1);
#line 462
        break;
      }
    }
#line 468
    if (0) {
#line 468
      __s1_len___0 = strlen("/");
#line 468
      __s2_len___0 = strlen((char const   *)(buf___1));
#line 468
      if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
        goto _L___4;
      } else {
#line 468
        if (__s1_len___0 >= 4U) {
          _L___4: /* CIL Label */ 
#line 468
          if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 468
            tmp___25 = 1;
          } else {
#line 468
            if (__s2_len___0 >= 4U) {
#line 468
              tmp___25 = 1;
            } else {
#line 468
              tmp___25 = 0;
            }
          }
        } else {
#line 468
          tmp___25 = 0;
        }
      }
#line 468
      if (tmp___25) {
#line 468
        tmp___21 = __builtin_strcmp("/", (char const   *)(buf___1));
      } else {
#line 468
        tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 468
        tmp___21 = tmp___24;
      }
    } else {
#line 468
      tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 468
      tmp___21 = tmp___24;
    }
#line 468
    if (tmp___21 == 0) {
#line 469
      break;
    } else {
#line 468
      if (0) {
#line 468
        __s1_len___1 = strlen(".");
#line 468
        __s2_len___1 = strlen((char const   *)(buf___1));
#line 468
        if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
          goto _L___6;
        } else {
#line 468
          if (__s1_len___1 >= 4U) {
            _L___6: /* CIL Label */ 
#line 468
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 468
              tmp___35 = 1;
            } else {
#line 468
              if (__s2_len___1 >= 4U) {
#line 468
                tmp___35 = 1;
              } else {
#line 468
                tmp___35 = 0;
              }
            }
          } else {
#line 468
            tmp___35 = 0;
          }
        }
#line 468
        if (tmp___35) {
#line 468
          tmp___31 = __builtin_strcmp(".", (char const   *)(buf___1));
        } else {
#line 468
          tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 468
          tmp___31 = tmp___34;
        }
      } else {
#line 468
        tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 468
        tmp___31 = tmp___34;
      }
#line 468
      if (tmp___31 == 0) {
#line 469
        break;
      }
    }
  }
#line 471
  return (0);
}
}
#line 474 "auth.c"
FILE *auth_openkeyfile(char const   *file___0 , struct passwd *pw___0 , int strict_modes ) 
{ char line[1024] ;
  struct stat st ;
  int fd ;
  FILE *f ;
  int tmp ;
  int tmp___0 ;

  {
#line 486
  fd = open(file___0, 2048);
#line 486
  if (fd == -1) {
#line 487
    return ((FILE *)((void *)0));
  }
#line 489
  tmp = fstat(fd, & st);
#line 489
  if (tmp < 0) {
#line 490
    close(fd);
#line 491
    return ((FILE *)((void *)0));
  }
#line 493
  if (! ((st.st_mode & 61440U) == 32768U)) {
#line 494
    logit("User %s authorized keys %s is not a regular file", pw___0->pw_name, file___0);
#line 496
    close(fd);
#line 497
    return ((FILE *)((void *)0));
  }
#line 499
  unset_nonblock(fd);
#line 500
  f = fdopen(fd, "r");
#line 500
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 501
    close(fd);
#line 502
    return ((FILE *)((void *)0));
  }
#line 504
  if (options.strict_modes) {
#line 504
    tmp___0 = secure_filename(f, file___0, pw___0, line, sizeof(line));
#line 504
    if (tmp___0 != 0) {
#line 506
      fclose(f);
#line 507
      logit("Authentication refused: %s", line);
#line 508
      return ((FILE *)((void *)0));
    }
  }
#line 511
  return (f);
}
}
#line 514 "auth.c"
struct passwd *getpwnamallow(char const   *user ) 
{ struct passwd *pw___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  struct passwd *tmp___4 ;

  {
#line 525
  tmp = get_remote_ipaddr();
#line 525
  tmp___0 = get_canonical_hostname(options.use_dns);
#line 525
  parse_server_match_config(& options, user, tmp___0, tmp);
#line 528
  pw___0 = getpwnam(user);
#line 529
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 530
    tmp___1 = get_remote_ipaddr();
#line 530
    logit("Invalid user %.100s from %.100s", user, tmp___1);
#line 533
    tmp___2 = get_canonical_hostname(options.use_dns);
#line 533
    record_failed_login(user, tmp___2, "ssh");
#line 539
    return ((struct passwd *)((void *)0));
  }
#line 541
  tmp___3 = allowed_user(pw___0);
#line 541
  if (! tmp___3) {
#line 542
    return ((struct passwd *)((void *)0));
  }
#line 558
  if ((unsigned int )pw___0 != (unsigned int )((void *)0)) {
#line 559
    tmp___4 = pwcopy(pw___0);
#line 559
    return (tmp___4);
  }
#line 560
  return ((struct passwd *)((void *)0));
}
}
#line 563 "auth.c"
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 569
  if (! auth_debug_init) {
#line 570
    return;
  }
#line 572
  __builtin_va_start(args, fmt);
#line 573
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 574
  __builtin_va_end(args);
#line 575
  buffer_put_cstring(& auth_debug, (char const   *)(buf___1));
#line 576
  return;
}
}
#line 578 "auth.c"
void auth_debug_send(void) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 583
  if (! auth_debug_init) {
#line 584
    return;
  }
#line 585
  while (1) {
#line 585
    tmp___0 = buffer_len(& auth_debug);
#line 585
    if (! tmp___0) {
#line 585
      break;
    }
#line 586
    tmp = buffer_get_string(& auth_debug, (u_int *)((void *)0));
#line 586
    msg = (char *)tmp;
#line 587
    packet_send_debug("%s", msg);
#line 588
    xfree((void *)msg);
  }
#line 590
  return;
}
}
#line 592 "auth.c"
void auth_debug_reset(void) 
{ 

  {
#line 595
  if (auth_debug_init) {
#line 596
    buffer_clear(& auth_debug);
  } else {
#line 598
    buffer_init(& auth_debug);
#line 599
    auth_debug_init = 1;
  }
#line 601
  return;
}
}
#line 606 "auth.c"
static struct passwd fake  ;
#line 603 "auth.c"
struct passwd *fakepw(void) 
{ 

  {
#line 608
  memset((void *)(& fake), 0, sizeof(fake));
#line 609
  fake.pw_name = (char *)"NOUSER";
#line 610
  fake.pw_passwd = (char *)"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
#line 612
  fake.pw_gecos = (char *)"NOUSER";
#line 613
  if ((unsigned int )privsep_pw == (unsigned int )((void *)0)) {
#line 613
    fake.pw_uid = 4294967295U;
  } else {
#line 613
    fake.pw_uid = privsep_pw->pw_uid;
  }
#line 614
  if ((unsigned int )privsep_pw == (unsigned int )((void *)0)) {
#line 614
    fake.pw_gid = 4294967295U;
  } else {
#line 614
    fake.pw_gid = privsep_pw->pw_gid;
  }
#line 618
  fake.pw_dir = (char *)"/nonexist";
#line 619
  fake.pw_shell = (char *)"/nonexist";
#line 621
  return (& fake);
}
}
#line 1 "auth1.o"
#pragma merger(0,"./auth1.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 166 "auth.h"
char *get_challenge(Authctxt *authctxt___0 ) ;
#line 167
int verify_response(Authctxt *authctxt___0 , char const   *response ) ;
#line 168
void abandon_challenge_response(Authctxt *authctxt___0 ) ;
#line 44 "monitor_wrap.h"
struct passwd *mm_getpwnamallow(char const   *username ) ;
#line 46
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) ;
#line 48 "auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 49
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 50
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 51
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 52
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 54 "auth1.c"
static char *client_user  =    (char *)((void *)0);
#line 63 "auth1.c"
struct AuthMethod1  const  auth1_methods[6]  = {      {9, (char *)"password", & options.password_authentication, & auth1_process_password}, 
        {6,
      (char *)"rsa", & options.rsa_authentication, & auth1_process_rsa}, 
        {35, (char *)"rhosts-rsa", & options.rhosts_rsa_authentication, & auth1_process_rhosts_rsa}, 
        {39,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_challenge}, 
        {41,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_response}, 
        {-1,
      (char *)((void *)0), (int *)((void *)0), (int (*)(Authctxt * , char * , size_t  ))((void *)0)}};
#line 89 "auth1.c"
static struct AuthMethod1  const  *lookup_authmethod1(int type ) 
{ int i ;

  {
#line 94
  i = 0;
#line 94
  while ((unsigned int )auth1_methods[i].name != (unsigned int )((void *)0)) {
#line 95
    if (auth1_methods[i].type == (int const   )type) {
#line 96
      return (& auth1_methods[i]);
    }
#line 94
    i ++;
  }
#line 98
  return ((struct AuthMethod1  const  *)((void *)0));
}
}
#line 105 "auth1.c"
static char buf[64]  ;
#line 101 "auth1.c"
static char *get_authname(int type ) 
{ struct AuthMethod1  const  *a___0 ;

  {
#line 107
  a___0 = lookup_authmethod1(type);
#line 107
  if ((unsigned int )a___0 != (unsigned int )((void *)0)) {
#line 108
    return ((char *)a___0->name);
  }
#line 109
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 110
  return (buf);
}
}
#line 114 "auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  char *password ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 117
  authenticated = 0;
#line 126
  tmp = packet_get_string(& dlen);
#line 126
  password = (char *)tmp;
#line 127
  while (1) {
#line 127
    tmp___0 = packet_remaining();
#line 127
    _len = tmp___0;
#line 127
    if (_len > 0) {
#line 127
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            127);
#line 127
      packet_disconnect("Packet integrity error.");
    }
#line 127
    break;
  }
#line 130
  if (use_privsep) {
#line 130
    authenticated = mm_auth_password(authctxt___0, password);
  } else {
#line 130
    authenticated = auth_password(authctxt___0, (char const   *)password);
  }
#line 132
  memset((void *)password, 0, dlen);
#line 133
  xfree((void *)password);
#line 135
  return (authenticated);
}
}
#line 139 "auth1.c"
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  BIGNUM *n___0 ;
  int _len ;
  int tmp ;

  {
#line 142
  authenticated = 0;
#line 146
  n___0 = BN_new();
#line 146
  if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 147
    fatal("do_authloop: BN_new failed");
  }
#line 148
  packet_get_bignum(n___0);
#line 149
  while (1) {
#line 149
    tmp = packet_remaining();
#line 149
    _len = tmp;
#line 149
    if (_len > 0) {
#line 149
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            149);
#line 149
      packet_disconnect("Packet integrity error.");
    }
#line 149
    break;
  }
#line 150
  authenticated = auth_rsa(authctxt___0, n___0);
#line 151
  BN_clear_free(n___0);
#line 153
  return (authenticated);
}
}
#line 157 "auth1.c"
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int keybits ;
  int authenticated ;
  u_int bits ;
  Key *client_host_key ;
  u_int ulen ;
  void *tmp ;
  int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 160
  authenticated = 0;
#line 170
  tmp = packet_get_string(& ulen);
#line 170
  client_user = (char *)tmp;
#line 173
  client_host_key = key_new(0);
#line 174
  bits = packet_get_int();
#line 175
  packet_get_bignum((client_host_key->rsa)->e);
#line 176
  packet_get_bignum((client_host_key->rsa)->n);
#line 178
  keybits = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 179
  if (keybits < 0) {
#line 180
    tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 180
    verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
            tmp___0, bits);
  } else {
#line 179
    if (bits != (unsigned int )keybits) {
#line 180
      tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 180
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___0, bits);
    }
  }
#line 184
  while (1) {
#line 184
    tmp___1 = packet_remaining();
#line 184
    _len = tmp___1;
#line 184
    if (_len > 0) {
#line 184
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            184);
#line 184
      packet_disconnect("Packet integrity error.");
    }
#line 184
    break;
  }
#line 186
  authenticated = auth_rhosts_rsa(authctxt___0, client_user, client_host_key);
#line 188
  key_free(client_host_key);
#line 190
  snprintf((char * __restrict  )info, infolen, (char const   * __restrict  )" ruser %.100s",
           client_user);
#line 192
  return (authenticated);
}
}
#line 196 "auth1.c"
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ char *challenge ;

  {
#line 201
  challenge = get_challenge(authctxt___0);
#line 201
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 202
    return (0);
  }
#line 204
  debug("sending challenge \'%s\'", challenge);
#line 205
  packet_start((unsigned char)40);
#line 206
  packet_put_cstring((char const   *)challenge);
#line 207
  xfree((void *)challenge);
#line 208
  packet_send();
#line 209
  packet_write_wait();
#line 211
  return (-1);
}
}
#line 215 "auth1.c"
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  char *response ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 218
  authenticated = 0;
#line 222
  tmp = packet_get_string(& dlen);
#line 222
  response = (char *)tmp;
#line 223
  while (1) {
#line 223
    tmp___0 = packet_remaining();
#line 223
    _len = tmp___0;
#line 223
    if (_len > 0) {
#line 223
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            223);
#line 223
      packet_disconnect("Packet integrity error.");
    }
#line 223
    break;
  }
#line 224
  authenticated = verify_response(authctxt___0, (char const   *)response);
#line 225
  memset((void *)response, 'r', dlen);
#line 226
  xfree((void *)response);
#line 228
  return (authenticated);
}
}
#line 235 "auth1.c"
static void do_authloop(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char info[1024] ;
  int prev ;
  int type ;
  struct AuthMethod1  const  *meth ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 238
  authenticated = 0;
#line 240
  prev = 0;
#line 240
  type = 0;
#line 243
  if (authctxt___0->valid) {
#line 243
    tmp = "";
  } else {
#line 243
    tmp = "invalid user ";
  }
#line 243
  debug("Attempting authentication for %s%.100s.", tmp, authctxt___0->user);
#line 247
  if (options.password_authentication) {
#line 247
    if (use_privsep) {
#line 247
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 247
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 247
    if (tmp___2) {
#line 256
      auth_log(authctxt___0, 1, (char *)"without authentication", (char *)"");
#line 257
      return;
    }
  }
#line 262
  packet_start((unsigned char)15);
#line 263
  packet_send();
#line 264
  packet_write_wait();
#line 266
  while (1) {
#line 268
    authenticated = 0;
#line 270
    info[0] = (char )'\000';
#line 273
    prev = type;
#line 274
    type = packet_read();
#line 283
    if (prev == 39) {
#line 283
      if (type != 41) {
#line 285
        abandon_challenge_response(authctxt___0);
      }
    }
#line 287
    if (authctxt___0->failures >= options.max_authtries) {
      goto skip;
    }
#line 289
    meth = lookup_authmethod1(type);
#line 289
    if ((unsigned int )meth == (unsigned int )((void *)0)) {
#line 290
      logit("Unknown message during authentication: type %d", type);
      goto skip;
    }
#line 295
    if (! *(meth->enabled)) {
#line 296
      verbose("%s authentication disabled.", meth->name);
      goto skip;
    }
#line 300
    authenticated = (*(meth->method))(authctxt___0, info, sizeof(info));
#line 301
    if (authenticated == -1) {
      goto __Cont;
    }
#line 310
    if (! authctxt___0->valid) {
#line 310
      if (authenticated) {
#line 311
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
      }
    }
#line 331
    if (authenticated) {
#line 331
      if ((authctxt___0->pw)->pw_uid == 0U) {
#line 331
        tmp___3 = auth_root_allowed((char *)meth->name);
#line 331
        if (! tmp___3) {
#line 333
          authenticated = 0;
        }
      }
    }
    skip: 
#line 363
    tmp___4 = get_authname(type);
#line 363
    auth_log(authctxt___0, authenticated, tmp___4, info);
#line 365
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 366
      xfree((void *)client_user);
#line 367
      client_user = (char *)((void *)0);
    }
#line 370
    if (authenticated) {
#line 371
      return;
    }
#line 373
    (authctxt___0->failures) ++;
#line 373
    if (authctxt___0->failures >= options.max_authtries) {
#line 377
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 380
    packet_start((unsigned char)15);
#line 381
    packet_send();
#line 382
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 390 "auth1.c"
void do_authentication(Authctxt *authctxt___0 ) 
{ u_int ulen ;
  char *user ;
  char *style ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;

  {
#line 394
  style = (char *)((void *)0);
#line 397
  packet_read_expect(4);
#line 400
  tmp = packet_get_string(& ulen);
#line 400
  user = (char *)tmp;
#line 401
  while (1) {
#line 401
    tmp___0 = packet_remaining();
#line 401
    _len = tmp___0;
#line 401
    if (_len > 0) {
#line 401
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            401);
#line 401
      packet_disconnect("Packet integrity error.");
    }
#line 401
    break;
  }
#line 403
  tmp___3 = __builtin_strchr(user, ':');
#line 403
  style = tmp___3;
#line 403
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 404
    tmp___1 = style;
#line 404
    style ++;
#line 404
    *tmp___1 = (char )'\000';
  }
#line 406
  authctxt___0->user = user;
#line 407
  authctxt___0->style = style;
#line 410
  if (use_privsep) {
#line 410
    authctxt___0->pw = mm_getpwnamallow((char const   *)user);
  } else {
#line 410
    authctxt___0->pw = getpwnamallow((char const   *)user);
  }
#line 410
  if ((unsigned int )authctxt___0->pw != (unsigned int )((void *)0)) {
#line 411
    authctxt___0->valid = 1;
  } else {
#line 413
    debug("do_authentication: invalid user %s", user);
#line 414
    authctxt___0->pw = fakepw();
  }
#line 417
  if (use_privsep) {
#line 417
    tmp___6 = " [net]";
  } else {
#line 417
    tmp___6 = "";
  }
#line 417
  if (authctxt___0->valid) {
#line 417
    tmp___7 = (char const   *)user;
  } else {
#line 417
    tmp___7 = "unknown";
  }
#line 417
  setproctitle("%s%s", tmp___7, tmp___6);
#line 430
  if (! use_privsep) {
#line 430
    tmp___8 = getuid();
#line 430
    if (tmp___8 != 0U) {
#line 430
      if (authctxt___0->pw) {
#line 430
        tmp___9 = getuid();
#line 430
        if ((authctxt___0->pw)->pw_uid != tmp___9) {
#line 432
          packet_disconnect("Cannot change user when server not running as root.");
        }
      }
    }
  }
#line 439
  do_authloop(authctxt___0);
#line 442
  packet_start((unsigned char)14);
#line 443
  packet_send();
#line 444
  packet_write_wait();
#line 445
  return;
}
}
#line 1 "auth2.o"
#pragma merger(0,"./auth2.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 145 "auth.h"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) ;
#line 146
void userauth_send_banner(char const   *msg ) ;
#line 149
char *auth2_read_banner(void) ;
#line 154
void auth2_challenge_stop(Authctxt *authctxt___0 ) ;
#line 43 "monitor_wrap.h"
void mm_inform_authserv(char *service , char *style ) ;
#line 45
char *mm_auth2_read_banner(void) ;
#line 66 "auth2.c"
Authmethod method_none ;
#line 67
Authmethod method_pubkey ;
#line 68
Authmethod method_passwd ;
#line 69
Authmethod method_kbdint ;
#line 70
Authmethod method_hostbased ;
#line 78 "auth2.c"
Authmethod *authmethods[6]  = {      & method_none,      & method_pubkey,      & method_passwd,      & method_kbdint, 
        & method_hostbased,      (Authmethod *)((void *)0)};
#line 95
static void input_service_request(int type , u_int32_t seq , void *ctxt ) ;
#line 96
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) ;
#line 99
static Authmethod *authmethod_lookup(char const   *name ) ;
#line 100
static char *authmethods_get(void) ;
#line 102 "auth2.c"
char *auth2_read_banner(void) 
{ struct stat st ;
  char *banner ;
  size_t len ;
  size_t n___0 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;

  {
#line 106
  banner = (char *)((void *)0);
#line 110
  fd = open((char const   *)options.banner, 0);
#line 110
  if (fd == -1) {
#line 111
    return ((char *)((void *)0));
  }
#line 112
  tmp = fstat(fd, & st);
#line 112
  if (tmp == -1) {
#line 113
    close(fd);
#line 114
    return ((char *)((void *)0));
  }
#line 116
  if (st.st_size > 1048576LL) {
#line 117
    close(fd);
#line 118
    return ((char *)((void *)0));
  }
#line 121
  len = (unsigned int )st.st_size;
#line 122
  tmp___0 = xmalloc(len + 1U);
#line 122
  banner = (char *)tmp___0;
#line 123
  n___0 = atomicio(& read, fd, (void *)banner, len);
#line 124
  close(fd);
#line 126
  if (n___0 != len) {
#line 127
    xfree((void *)banner);
#line 128
    return ((char *)((void *)0));
  }
#line 130
  *(banner + n___0) = (char )'\000';
#line 132
  return (banner);
}
}
#line 135 "auth2.c"
void userauth_send_banner(char const   *msg ) 
{ 

  {
#line 138
  if (datafellows & 128) {
#line 139
    return;
  }
#line 141
  packet_start((unsigned char)53);
#line 142
  packet_put_cstring(msg);
#line 143
  packet_put_cstring("");
#line 144
  packet_send();
#line 145
  debug("%s: sent", "userauth_send_banner");
#line 146
  return;
}
}
#line 148 "auth2.c"
static void userauth_banner(void) 
{ char *banner ;
  int tmp ;

  {
#line 151
  banner = (char *)((void *)0);
#line 153
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 156
    return;
  } else {
#line 153
    tmp = strcasecmp((char const   *)options.banner, "none");
#line 153
    if (tmp == 0) {
#line 156
      return;
    } else {
#line 153
      if ((datafellows & 128) != 0) {
#line 156
        return;
      }
    }
  }
#line 158
  if (use_privsep) {
#line 158
    banner = mm_auth2_read_banner();
  } else {
#line 158
    banner = auth2_read_banner();
  }
#line 158
  if ((unsigned int )banner == (unsigned int )((void *)0)) {
    goto done;
  }
#line 160
  userauth_send_banner((char const   *)banner);
  done: 
#line 163
  if (banner) {
#line 164
    xfree((void *)banner);
  }
#line 165
  return;
}
}
#line 170 "auth2.c"
void do_authentication2(Authctxt *authctxt___0 ) 
{ 

  {
#line 173
  dispatch_init(& dispatch_protocol_error);
#line 174
  dispatch_set(5, & input_service_request);
#line 175
  dispatch_run(0, (sig_atomic_t volatile   *)(& authctxt___0->success), (void *)authctxt___0);
#line 176
  return;
}
}
#line 179 "auth2.c"
static void input_service_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  u_int len ;
  int acceptit ;
  char *service ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 182
  authctxt___0 = (Authctxt *)ctxt;
#line 184
  acceptit = 0;
#line 185
  tmp = packet_get_string(& len);
#line 185
  service = (char *)tmp;
#line 186
  while (1) {
#line 186
    tmp___0 = packet_remaining();
#line 186
    _len = tmp___0;
#line 186
    if (_len > 0) {
#line 186
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
            186);
#line 186
      packet_disconnect("Packet integrity error.");
    }
#line 186
    break;
  }
#line 188
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 189
    fatal("input_service_request: no authctxt");
  }
#line 191
  if (0) {
#line 191
    __s1_len = strlen((char const   *)service);
#line 191
    __s2_len = strlen("ssh-userauth");
#line 191
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 191
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 191
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 191
          tmp___10 = 1;
        } else {
#line 191
          if (__s2_len >= 4U) {
#line 191
            tmp___10 = 1;
          } else {
#line 191
            tmp___10 = 0;
          }
        }
      } else {
#line 191
        tmp___10 = 0;
      }
    }
#line 191
    if (tmp___10) {
#line 191
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 191
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 191
      tmp___6 = tmp___9;
    }
  } else {
#line 191
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 191
    tmp___6 = tmp___9;
  }
#line 191
  if (tmp___6 == 0) {
#line 192
    if (! authctxt___0->success) {
#line 193
      acceptit = 1;
#line 195
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 200
  if (acceptit) {
#line 201
    packet_start((unsigned char)6);
#line 202
    packet_put_cstring((char const   *)service);
#line 203
    packet_send();
#line 204
    packet_write_wait();
  } else {
#line 206
    debug("bad service request %s", service);
#line 207
    packet_disconnect("bad service request %s", service);
  }
#line 209
  xfree((void *)service);
#line 210
  return;
}
}
#line 213 "auth2.c"
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
#line 216
  authctxt___0 = (Authctxt *)ctxt;
#line 217
  m___0 = (Authmethod *)((void *)0);
#line 218
  style = (char *)((void *)0);
#line 219
  authenticated = 0;
#line 221
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 222
    fatal("input_userauth_request: no authctxt");
  }
#line 224
  tmp = packet_get_string((u_int *)((void *)0));
#line 224
  user = (char *)tmp;
#line 225
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 225
  service = (char *)tmp___0;
#line 226
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 226
  method = (char *)tmp___1;
#line 227
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 228
  debug("attempt %d failures %d", authctxt___0->attempt, authctxt___0->failures);
#line 230
  tmp___4 = __builtin_strchr(user, ':');
#line 230
  style = tmp___4;
#line 230
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 231
    tmp___2 = style;
#line 231
    style ++;
#line 231
    *tmp___2 = (char)0;
  }
#line 233
  tmp___40 = authctxt___0->attempt;
#line 233
  (authctxt___0->attempt) ++;
#line 233
  if (tmp___40 == 0) {
#line 235
    if (use_privsep) {
#line 235
      authctxt___0->pw = mm_getpwnamallow((char const   *)user);
    } else {
#line 235
      authctxt___0->pw = getpwnamallow((char const   *)user);
    }
#line 236
    authctxt___0->user = xstrdup((char const   *)user);
#line 237
    if (authctxt___0->pw) {
#line 237
      if (0) {
#line 237
        __s1_len = strlen((char const   *)service);
#line 237
        __s2_len = strlen("ssh-connection");
#line 237
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___0;
        } else {
#line 237
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 237
            if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 237
              tmp___16 = 1;
            } else {
#line 237
              if (__s2_len >= 4U) {
#line 237
                tmp___16 = 1;
              } else {
#line 237
                tmp___16 = 0;
              }
            }
          } else {
#line 237
            tmp___16 = 0;
          }
        }
#line 237
        if (tmp___16) {
#line 237
          tmp___12 = __builtin_strcmp((char const   *)service, "ssh-connection");
        } else {
#line 237
          tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 237
          tmp___12 = tmp___15;
        }
      } else {
#line 237
        tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 237
        tmp___12 = tmp___15;
      }
#line 237
      if (tmp___12 == 0) {
#line 238
        authctxt___0->valid = 1;
#line 239
        debug2("input_userauth_request: setting up authctxt for %s", user);
      } else {
#line 241
        logit("input_userauth_request: invalid user %s", user);
#line 242
        authctxt___0->pw = fakepw();
      }
    } else {
#line 241
      logit("input_userauth_request: invalid user %s", user);
#line 242
      authctxt___0->pw = fakepw();
    }
#line 251
    if (use_privsep) {
#line 251
      tmp___17 = " [net]";
    } else {
#line 251
      tmp___17 = "";
    }
#line 251
    if (authctxt___0->valid) {
#line 251
      tmp___18 = (char const   *)user;
    } else {
#line 251
      tmp___18 = "unknown";
    }
#line 251
    setproctitle("%s%s", tmp___18, tmp___17);
#line 253
    authctxt___0->service = xstrdup((char const   *)service);
#line 254
    if (style) {
#line 254
      authctxt___0->style = xstrdup((char const   *)style);
    } else {
#line 254
      authctxt___0->style = (char *)((void *)0);
    }
#line 255
    if (use_privsep) {
#line 256
      mm_inform_authserv(service, style);
    }
#line 257
    userauth_banner();
  } else {
#line 258
    if (0) {
#line 258
      __s1_len___0 = strlen((char const   *)user);
#line 258
      __s2_len___0 = strlen((char const   *)authctxt___0->user);
#line 258
      if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
        goto _L___2;
      } else {
#line 258
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 258
          if (! ((unsigned int )((void const   *)(authctxt___0->user + 1)) - (unsigned int )((void const   *)authctxt___0->user) == 1U)) {
#line 258
            tmp___29 = 1;
          } else {
#line 258
            if (__s2_len___0 >= 4U) {
#line 258
              tmp___29 = 1;
            } else {
#line 258
              tmp___29 = 0;
            }
          }
        } else {
#line 258
          tmp___29 = 0;
        }
      }
#line 258
      if (tmp___29) {
#line 258
        tmp___25 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
      } else {
#line 258
        tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 258
        tmp___25 = tmp___28;
      }
    } else {
#line 258
      tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 258
      tmp___25 = tmp___28;
    }
#line 259
    if (tmp___25 != 0) {
#line 260
      packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                        authctxt___0->user, authctxt___0->service, user, service);
    } else {
#line 259
      if (0) {
#line 259
        __s1_len___1 = strlen((char const   *)service);
#line 259
        __s2_len___1 = strlen((char const   *)authctxt___0->service);
#line 259
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___4;
        } else {
#line 259
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 259
            if (! ((unsigned int )((void const   *)(authctxt___0->service + 1)) - (unsigned int )((void const   *)authctxt___0->service) == 1U)) {
#line 259
              tmp___39 = 1;
            } else {
#line 259
              if (__s2_len___1 >= 4U) {
#line 259
                tmp___39 = 1;
              } else {
#line 259
                tmp___39 = 0;
              }
            }
          } else {
#line 259
            tmp___39 = 0;
          }
        }
#line 259
        if (tmp___39) {
#line 259
          tmp___35 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
        } else {
#line 259
          tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 259
          tmp___35 = tmp___38;
        }
      } else {
#line 259
        tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 259
        tmp___35 = tmp___38;
      }
#line 259
      if (tmp___35 != 0) {
#line 260
        packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                          authctxt___0->user, authctxt___0->service, user, service);
      }
    }
  }
#line 265
  auth2_challenge_stop(authctxt___0);
#line 276
  authctxt___0->postponed = 0;
#line 279
  m___0 = authmethod_lookup((char const   *)method);
#line 280
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 280
    if (authctxt___0->failures < options.max_authtries) {
#line 281
      debug2("input_userauth_request: try method %s", method);
#line 282
      authenticated = (*(m___0->userauth))(authctxt___0);
    }
  }
#line 284
  userauth_finish(authctxt___0, authenticated, method);
#line 286
  xfree((void *)service);
#line 287
  xfree((void *)user);
#line 288
  xfree((void *)method);
#line 289
  return;
}
}
#line 291 "auth2.c"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) 
{ char *methods ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 296
  if (! authctxt___0->valid) {
#line 296
    if (authenticated) {
#line 297
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
    }
  }
#line 301
  if (authenticated) {
#line 301
    if ((authctxt___0->pw)->pw_uid == 0U) {
#line 301
      tmp = auth_root_allowed(method);
#line 301
      if (! tmp) {
#line 303
        authenticated = 0;
      }
    }
  }
#line 332
  auth_log(authctxt___0, authenticated, method, (char *)" ssh2");
#line 334
  if (authctxt___0->postponed) {
#line 335
    return;
  }
#line 338
  if (authenticated == 1) {
#line 340
    dispatch_set(50, & dispatch_protocol_ignore);
#line 341
    packet_start((unsigned char)52);
#line 342
    packet_send();
#line 343
    packet_write_wait();
#line 345
    authctxt___0->success = 1;
  } else {
#line 349
    if (authctxt___0->attempt > 1) {
#line 350
      (authctxt___0->failures) ++;
    } else {
#line 349
      if (0) {
#line 349
        __s1_len = strlen((char const   *)method);
#line 349
        __s2_len = strlen("none");
#line 349
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___0;
        } else {
#line 349
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 349
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 349
              tmp___9 = 1;
            } else {
#line 349
              if (__s2_len >= 4U) {
#line 349
                tmp___9 = 1;
              } else {
#line 349
                tmp___9 = 0;
              }
            }
          } else {
#line 349
            tmp___9 = 0;
          }
        }
#line 349
        if (tmp___9) {
#line 349
          tmp___5 = __builtin_strcmp((char const   *)method, "none");
        } else {
#line 349
          tmp___8 = __builtin_strcmp((char const   *)method, "none");
#line 349
          tmp___5 = tmp___8;
        }
      } else {
#line 349
        tmp___8 = __builtin_strcmp((char const   *)method, "none");
#line 349
        tmp___5 = tmp___8;
      }
#line 349
      if (tmp___5 != 0) {
#line 350
        (authctxt___0->failures) ++;
      }
    }
#line 351
    if (authctxt___0->failures >= options.max_authtries) {
#line 355
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 357
    methods = authmethods_get();
#line 358
    packet_start((unsigned char)51);
#line 359
    packet_put_cstring((char const   *)methods);
#line 360
    packet_put_char(0);
#line 361
    packet_send();
#line 362
    packet_write_wait();
#line 363
    xfree((void *)methods);
  }
#line 365
  return;
}
}
#line 367 "auth2.c"
static char *authmethods_get(void) 
{ Buffer b ;
  char *list ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;

  {
#line 374
  buffer_init(& b);
#line 375
  i = 0;
#line 375
  while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 376
    if (0) {
#line 376
      __s1_len = strlen((char const   *)(authmethods[i])->name);
#line 376
      __s2_len = strlen("none");
#line 376
      if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
        goto _L___0;
      } else {
#line 376
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 376
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 376
            tmp___8 = 1;
          } else {
#line 376
            if (__s2_len >= 4U) {
#line 376
              tmp___8 = 1;
            } else {
#line 376
              tmp___8 = 0;
            }
          }
        } else {
#line 376
          tmp___8 = 0;
        }
      }
#line 376
      if (tmp___8) {
#line 376
        tmp___4 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
      } else {
#line 376
        tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 376
        tmp___4 = tmp___7;
      }
    } else {
#line 376
      tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 376
      tmp___4 = tmp___7;
    }
#line 376
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 378
    if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 378
      if (*((authmethods[i])->enabled) != 0) {
#line 380
        tmp___9 = buffer_len(& b);
#line 380
        if (tmp___9 > 0U) {
#line 381
          buffer_append(& b, (void const   *)",", 1U);
        }
#line 382
        tmp___10 = strlen((char const   *)(authmethods[i])->name);
#line 382
        buffer_append(& b, (void const   *)(authmethods[i])->name, tmp___10);
      }
    }
    __Cont: /* CIL Label */ 
#line 375
    i ++;
  }
#line 386
  buffer_append(& b, (void const   *)"\000", 1U);
#line 387
  tmp___11 = buffer_ptr(& b);
#line 387
  list = xstrdup((char const   *)tmp___11);
#line 388
  buffer_free(& b);
#line 389
  return (list);
}
}
#line 392 "auth2.c"
static Authmethod *authmethod_lookup(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 397
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 398
    i = 0;
#line 398
    while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 401
      if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 401
        if (*((authmethods[i])->enabled) != 0) {
#line 401
          if (0) {
#line 401
            __s1_len = strlen(name);
#line 401
            __s2_len = strlen((char const   *)(authmethods[i])->name);
#line 401
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 401
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 401
                if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
#line 401
                  tmp___8 = 1;
                } else {
#line 401
                  if (__s2_len >= 4U) {
#line 401
                    tmp___8 = 1;
                  } else {
#line 401
                    tmp___8 = 0;
                  }
                }
              } else {
#line 401
                tmp___8 = 0;
              }
            }
#line 401
            if (tmp___8) {
#line 401
              tmp___4 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
            } else {
#line 401
              tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 401
              tmp___4 = tmp___7;
            }
          } else {
#line 401
            tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 401
            tmp___4 = tmp___7;
          }
#line 401
          if (tmp___4 == 0) {
#line 402
            return (authmethods[i]);
          }
        }
      }
#line 398
      i ++;
    }
  }
#line 403
  if (name) {
#line 403
    tmp___9 = name;
  } else {
#line 403
    tmp___9 = "NULL";
  }
#line 403
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 405
  return ((Authmethod *)((void *)0));
}
}
#line 1 "auth-options.o"
#pragma merger(0,"./auth-options.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 58 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 28 "auth-options.h"
int no_pty_flag ;
#line 29
int no_user_rc ;
#line 31
struct envstring *custom_environment ;
#line 42 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 43 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 44 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 45 "auth-options.c"
int no_pty_flag  =    0;
#line 46 "auth-options.c"
int no_user_rc  =    0;
#line 49 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 52 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 55 "auth-options.c"
int forced_tun_device  =    -1;
#line 59 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 62
  no_agent_forwarding_flag = 0;
#line 63
  no_port_forwarding_flag = 0;
#line 64
  no_pty_flag = 0;
#line 65
  no_x11_forwarding_flag = 0;
#line 66
  no_user_rc = 0;
#line 67
  while (custom_environment) {
#line 68
    ce = custom_environment;
#line 69
    custom_environment = ce->next;
#line 70
    xfree((void *)ce->s);
#line 71
    xfree((void *)ce);
  }
#line 73
  if (forced_command) {
#line 74
    xfree((void *)forced_command);
#line 75
    forced_command = (char *)((void *)0);
  }
#line 77
  forced_tun_device = -1;
#line 78
  channel_clear_permitted_opens();
#line 79
  auth_debug_reset();
#line 80
  return;
}
}
#line 86 "auth-options.c"
int auth_parse_options(struct passwd *pw___0 , char *opts , char *file___0 , u_long linenum ) 
{ char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  char const   *remote_ip___0 ;
  char const   *tmp___31 ;
  char const   *remote_host ;
  char const   *tmp___32 ;
  char *patterns ;
  size_t tmp___33 ;
  void *tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  char *host ;
  char *p ;
  int port___0 ;
  char *patterns___0 ;
  size_t tmp___42 ;
  void *tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  size_t tmp___48 ;
  char const   *tmp___49 ;
  size_t tmp___50 ;
  int tmp___51 ;
  char *tun ;
  size_t tmp___52 ;
  size_t tmp___53 ;
  void *tmp___54 ;
  int tmp___55 ;
  char *tmp___56 ;
  size_t tmp___57 ;
  int tmp___58 ;

  {
#line 93
  auth_clear_options();
#line 95
  if (! opts) {
#line 96
    return (1);
  }
#line 98
  while (1) {
#line 98
    if (*opts) {
#line 98
      if ((int )*opts != 32) {
#line 98
        if (! ((int )*opts != 9)) {
#line 98
          break;
        }
      } else {
#line 98
        break;
      }
    } else {
#line 98
      break;
    }
#line 99
    cp = "no-port-forwarding";
#line 100
    tmp___0 = strlen(cp);
#line 100
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 100
    if (tmp___1 == 0) {
#line 101
      auth_debug_add("Port forwarding disabled.");
#line 102
      no_port_forwarding_flag = 1;
#line 103
      tmp = strlen(cp);
#line 103
      opts += tmp;
      goto next_option;
    }
#line 106
    cp = "no-agent-forwarding";
#line 107
    tmp___3 = strlen(cp);
#line 107
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 107
    if (tmp___4 == 0) {
#line 108
      auth_debug_add("Agent forwarding disabled.");
#line 109
      no_agent_forwarding_flag = 1;
#line 110
      tmp___2 = strlen(cp);
#line 110
      opts += tmp___2;
      goto next_option;
    }
#line 113
    cp = "no-X11-forwarding";
#line 114
    tmp___6 = strlen(cp);
#line 114
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 114
    if (tmp___7 == 0) {
#line 115
      auth_debug_add("X11 forwarding disabled.");
#line 116
      no_x11_forwarding_flag = 1;
#line 117
      tmp___5 = strlen(cp);
#line 117
      opts += tmp___5;
      goto next_option;
    }
#line 120
    cp = "no-pty";
#line 121
    tmp___9 = strlen(cp);
#line 121
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 121
    if (tmp___10 == 0) {
#line 122
      auth_debug_add("Pty allocation disabled.");
#line 123
      no_pty_flag = 1;
#line 124
      tmp___8 = strlen(cp);
#line 124
      opts += tmp___8;
      goto next_option;
    }
#line 127
    cp = "no-user-rc";
#line 128
    tmp___12 = strlen(cp);
#line 128
    tmp___13 = strncasecmp((char const   *)opts, cp, tmp___12);
#line 128
    if (tmp___13 == 0) {
#line 129
      auth_debug_add("User rc file execution disabled.");
#line 130
      no_user_rc = 1;
#line 131
      tmp___11 = strlen(cp);
#line 131
      opts += tmp___11;
      goto next_option;
    }
#line 134
    cp = "command=\"";
#line 135
    tmp___20 = strlen(cp);
#line 135
    tmp___21 = strncasecmp((char const   *)opts, cp, tmp___20);
#line 135
    if (tmp___21 == 0) {
#line 136
      tmp___14 = strlen(cp);
#line 136
      opts += tmp___14;
#line 137
      tmp___15 = strlen((char const   *)opts);
#line 137
      tmp___16 = xmalloc(tmp___15 + 1U);
#line 137
      forced_command = (char *)tmp___16;
#line 138
      i = 0;
#line 139
      while (*opts) {
#line 140
        if ((int )*opts == 34) {
#line 141
          break;
        }
#line 142
        if ((int )*opts == 92) {
#line 142
          if ((int )*(opts + 1) == 34) {
#line 143
            opts += 2;
#line 144
            tmp___17 = i;
#line 144
            i ++;
#line 144
            *(forced_command + tmp___17) = (char )'\"';
#line 145
            continue;
          }
        }
#line 147
        tmp___18 = i;
#line 147
        i ++;
#line 147
        tmp___19 = opts;
#line 147
        opts ++;
#line 147
        *(forced_command + tmp___18) = *tmp___19;
      }
#line 149
      if (! *opts) {
#line 150
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 152
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 154
        xfree((void *)forced_command);
#line 155
        forced_command = (char *)((void *)0);
        goto bad_option;
      }
#line 158
      *(forced_command + i) = (char )'\000';
#line 159
      auth_debug_add("Forced command: %.900s", forced_command);
#line 160
      opts ++;
      goto next_option;
    }
#line 163
    cp = "environment=\"";
#line 164
    if (options.permit_user_env) {
#line 164
      tmp___29 = strlen(cp);
#line 164
      tmp___30 = strncasecmp((char const   *)opts, cp, tmp___29);
#line 164
      if (tmp___30 == 0) {
#line 169
        tmp___22 = strlen(cp);
#line 169
        opts += tmp___22;
#line 170
        tmp___23 = strlen((char const   *)opts);
#line 170
        tmp___24 = xmalloc(tmp___23 + 1U);
#line 170
        s = (char *)tmp___24;
#line 171
        i = 0;
#line 172
        while (*opts) {
#line 173
          if ((int )*opts == 34) {
#line 174
            break;
          }
#line 175
          if ((int )*opts == 92) {
#line 175
            if ((int )*(opts + 1) == 34) {
#line 176
              opts += 2;
#line 177
              tmp___25 = i;
#line 177
              i ++;
#line 177
              *(s + tmp___25) = (char )'\"';
#line 178
              continue;
            }
          }
#line 180
          tmp___26 = i;
#line 180
          i ++;
#line 180
          tmp___27 = opts;
#line 180
          opts ++;
#line 180
          *(s + tmp___26) = *tmp___27;
        }
#line 182
        if (! *opts) {
#line 183
          debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 185
          auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 187
          xfree((void *)s);
          goto bad_option;
        }
#line 190
        *(s + i) = (char )'\000';
#line 191
        auth_debug_add("Adding to environment: %.900s", s);
#line 192
        debug("Adding to environment: %.900s", s);
#line 193
        opts ++;
#line 194
        tmp___28 = xmalloc(sizeof(struct envstring ));
#line 194
        new_envstring = (struct envstring *)tmp___28;
#line 195
        new_envstring->s = s;
#line 196
        new_envstring->next = custom_environment;
#line 197
        custom_environment = new_envstring;
        goto next_option;
      }
    }
#line 200
    cp = "from=\"";
#line 201
    tmp___40 = strlen(cp);
#line 201
    tmp___41 = strncasecmp((char const   *)opts, cp, tmp___40);
#line 201
    if (tmp___41 == 0) {
#line 202
      tmp___31 = get_remote_ipaddr();
#line 202
      remote_ip___0 = tmp___31;
#line 203
      tmp___32 = get_canonical_hostname(options.use_dns);
#line 203
      remote_host = tmp___32;
#line 205
      tmp___33 = strlen((char const   *)opts);
#line 205
      tmp___34 = xmalloc(tmp___33 + 1U);
#line 205
      patterns = (char *)tmp___34;
#line 207
      tmp___35 = strlen(cp);
#line 207
      opts += tmp___35;
#line 208
      i = 0;
#line 209
      while (*opts) {
#line 210
        if ((int )*opts == 34) {
#line 211
          break;
        }
#line 212
        if ((int )*opts == 92) {
#line 212
          if ((int )*(opts + 1) == 34) {
#line 213
            opts += 2;
#line 214
            tmp___36 = i;
#line 214
            i ++;
#line 214
            *(patterns + tmp___36) = (char )'\"';
#line 215
            continue;
          }
        }
#line 217
        tmp___37 = i;
#line 217
        i ++;
#line 217
        tmp___38 = opts;
#line 217
        opts ++;
#line 217
        *(patterns + tmp___37) = *tmp___38;
      }
#line 219
      if (! *opts) {
#line 220
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 222
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 224
        xfree((void *)patterns);
        goto bad_option;
      }
#line 227
      *(patterns + i) = (char )'\000';
#line 228
      opts ++;
#line 229
      tmp___39 = match_host_and_ip(remote_host, remote_ip___0, (char const   *)patterns);
#line 229
      switch (tmp___39) {
      case 1: 
#line 232
      xfree((void *)patterns);
      goto next_option;
      case -1: 
#line 236
      debug("%.100s, line %lu: invalid criteria", file___0, linenum);
#line 238
      auth_debug_add("%.100s, line %lu: invalid criteria", file___0, linenum);
      case 0: 
#line 242
      xfree((void *)patterns);
#line 243
      logit("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
            pw___0->pw_name, remote_host, remote_ip___0);
#line 247
      auth_debug_add("Your host \'%.200s\' is not permitted to use this key for login.",
                     remote_host);
#line 250
      break;
      }
#line 253
      return (0);
    }
#line 255
    cp = "permitopen=\"";
#line 256
    tmp___50 = strlen(cp);
#line 256
    tmp___51 = strncasecmp((char const   *)opts, cp, tmp___50);
#line 256
    if (tmp___51 == 0) {
#line 259
      tmp___42 = strlen((char const   *)opts);
#line 259
      tmp___43 = xmalloc(tmp___42 + 1U);
#line 259
      patterns___0 = (char *)tmp___43;
#line 261
      tmp___44 = strlen(cp);
#line 261
      opts += tmp___44;
#line 262
      i = 0;
#line 263
      while (*opts) {
#line 264
        if ((int )*opts == 34) {
#line 265
          break;
        }
#line 266
        if ((int )*opts == 92) {
#line 266
          if ((int )*(opts + 1) == 34) {
#line 267
            opts += 2;
#line 268
            tmp___45 = i;
#line 268
            i ++;
#line 268
            *(patterns___0 + tmp___45) = (char )'\"';
#line 269
            continue;
          }
        }
#line 271
        tmp___46 = i;
#line 271
        i ++;
#line 271
        tmp___47 = opts;
#line 271
        opts ++;
#line 271
        *(patterns___0 + tmp___46) = *tmp___47;
      }
#line 273
      if (! *opts) {
#line 274
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 276
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 278
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 281
      *(patterns___0 + i) = (char )'\000';
#line 282
      opts ++;
#line 283
      p = patterns___0;
#line 284
      host = hpdelim(& p);
#line 285
      if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 286
        debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file___0,
              linenum, patterns___0);
#line 289
        auth_debug_add("%.100s, line %lu: Bad permitopen specification", file___0,
                       linenum);
#line 292
        xfree((void *)patterns___0);
        goto bad_option;
      } else {
#line 285
        tmp___48 = strlen((char const   *)host);
#line 285
        if (tmp___48 >= 1025U) {
#line 286
          debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file___0,
                linenum, patterns___0);
#line 289
          auth_debug_add("%.100s, line %lu: Bad permitopen specification", file___0,
                         linenum);
#line 292
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 295
      host = cleanhostname(host);
#line 296
      if ((unsigned int )p == (unsigned int )((void *)0)) {
        goto _L;
      } else {
#line 296
        port___0 = a2port((char const   *)p);
#line 296
        if (port___0 <= 0) {
          _L: /* CIL Label */ 
#line 297
          if (p) {
#line 297
            tmp___49 = (char const   *)p;
          } else {
#line 297
            tmp___49 = "";
          }
#line 297
          debug("%.100s, line %lu: Bad permitopen port <%.100s>", file___0, linenum,
                tmp___49);
#line 299
          auth_debug_add("%.100s, line %lu: Bad permitopen port", file___0, linenum);
#line 301
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 304
      if (options.allow_tcp_forwarding) {
#line 305
        channel_add_permitted_opens(host, port___0);
      }
#line 306
      xfree((void *)patterns___0);
      goto next_option;
    }
#line 309
    cp = "tunnel=\"";
#line 310
    tmp___57 = strlen(cp);
#line 310
    tmp___58 = strncasecmp((char const   *)opts, cp, tmp___57);
#line 310
    if (tmp___58 == 0) {
#line 311
      tun = (char *)((void *)0);
#line 312
      tmp___52 = strlen(cp);
#line 312
      opts += tmp___52;
#line 313
      tmp___53 = strlen((char const   *)opts);
#line 313
      tmp___54 = xmalloc(tmp___53 + 1U);
#line 313
      tun = (char *)tmp___54;
#line 314
      i = 0;
#line 315
      while (*opts) {
#line 316
        if ((int )*opts == 34) {
#line 317
          break;
        }
#line 318
        tmp___55 = i;
#line 318
        i ++;
#line 318
        tmp___56 = opts;
#line 318
        opts ++;
#line 318
        *(tun + tmp___55) = *tmp___56;
      }
#line 320
      if (! *opts) {
#line 321
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 323
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 325
        xfree((void *)tun);
#line 326
        forced_tun_device = -1;
        goto bad_option;
      }
#line 329
      *(tun + i) = (char )'\000';
#line 330
      forced_tun_device = a2tun((char const   *)tun, (int *)((void *)0));
#line 331
      xfree((void *)tun);
#line 332
      if (forced_tun_device == 2147483646) {
#line 333
        debug("%.100s, line %lu: invalid tun device", file___0, linenum);
#line 335
        auth_debug_add("%.100s, line %lu: invalid tun device", file___0, linenum);
#line 337
        forced_tun_device = -1;
        goto bad_option;
      }
#line 340
      auth_debug_add("Forced tun device: %d", forced_tun_device);
#line 341
      opts ++;
      goto next_option;
    }
    next_option: 
#line 349
    if (! *opts) {
#line 350
      fatal("Bugs in auth-options.c option processing.");
    }
#line 351
    if ((int )*opts == 32) {
#line 352
      break;
    } else {
#line 351
      if ((int )*opts == 9) {
#line 352
        break;
      }
    }
#line 353
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 355
    opts ++;
  }
#line 359
  if (! use_privsep) {
#line 360
    auth_debug_send();
  }
#line 363
  return (1);
  bad_option: 
#line 366
  logit("Bad options in %.100s file, line %lu: %.50s", file___0, linenum, opts);
#line 368
  auth_debug_add("Bad options in %.100s file, line %lu: %.50s", file___0, linenum,
                 opts);
#line 371
  if (! use_privsep) {
#line 372
    auth_debug_send();
  }
#line 375
  return (0);
}
}
#line 1 "session.o"
#pragma merger(0,"./session.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 81 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 590 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 199
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 69 "session.h"
void session_unused(int id ) ;
#line 74
void session_pty_cleanup2(Session *s ) ;
#line 76
Session *session_new(void) ;
#line 77
Session *session_by_tty(char *tty ) ;
#line 78
void session_close(Session *s ) ;
#line 80
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) ;
#line 81 "monitor_wrap.h"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) ;
#line 82
void mm_session_pty_cleanup2(struct Session *s ) ;
#line 100 "sftp.h"
int sftp_server_main(int argc , char **argv , struct passwd *user_pw ) ;
#line 107 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 , int is_tty ) ;
#line 108
void session_pty_cleanup(Session *s ) ;
#line 109
void session_proctitle(Session *s ) ;
#line 110
int session_setup_x11fwd(Session *s ) ;
#line 111
int do_exec_pty(Session *s , char const   *command ) ;
#line 112
int do_exec_no_pty(Session *s , char const   *command ) ;
#line 113
int do_exec(Session *s , char const   *command ) ;
#line 114
void do_login(Session *s , char const   *command ) ;
#line 118
void do_child(Session *s , char const   *command ) ;
#line 119
void do_motd(void) ;
#line 120
int check_quietlogin(Session *s , char const   *command ) ;
#line 122
static void do_authenticated1(Authctxt *authctxt___0 ) ;
#line 123
static void do_authenticated2(Authctxt *authctxt___0 ) ;
#line 125
static int session_pty_req(Session *s ) ;
#line 138 "session.c"
char const   *original_command  =    (char const   *)((void *)0);
#line 141 "session.c"
static int sessions_first_unused  =    -1;
#line 142 "session.c"
static int sessions_nalloc  =    0;
#line 143 "session.c"
static Session *sessions  =    (Session *)((void *)0);
#line 153 "session.c"
static int is_child  =    0;
#line 156 "session.c"
static char *auth_sock_name  =    (char *)((void *)0);
#line 157 "session.c"
static char *auth_sock_dir  =    (char *)((void *)0);
#line 161 "session.c"
static void auth_sock_cleanup_proc(struct passwd *pw___0 ) 
{ 

  {
#line 164
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 165
    temporarily_use_uid(pw___0);
#line 166
    unlink((char const   *)auth_sock_name);
#line 167
    rmdir((char const   *)auth_sock_dir);
#line 168
    auth_sock_name = (char *)((void *)0);
#line 169
    restore_uid();
  }
#line 171
  return;
}
}
#line 173 "session.c"
static int auth_input_request_forwarding(struct passwd *pw___0 ) 
{ Channel *nc ;
  int sock ;
  struct sockaddr_un sunaddr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 177
  sock = -1;
#line 180
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 181
    error("authentication forwarding requested twice.");
#line 182
    return (0);
  }
#line 186
  temporarily_use_uid(pw___0);
#line 189
  auth_sock_dir = xstrdup("/tmp/ssh-XXXXXXXXXX");
#line 192
  tmp___1 = mkdtemp(auth_sock_dir);
#line 192
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___0);
#line 195
    restore_uid();
#line 196
    xfree((void *)auth_sock_dir);
#line 197
    auth_sock_dir = (char *)((void *)0);
    goto authsock_err;
  }
#line 201
  tmp___2 = getpid();
#line 201
  xasprintf(& auth_sock_name, "%s/agent.%ld", auth_sock_dir, (long )tmp___2);
#line 205
  sock = socket(1, 1, 0);
#line 206
  if (sock < 0) {
#line 207
    tmp___3 = __errno_location();
#line 207
    tmp___4 = strerror(*tmp___3);
#line 207
    error("socket: %.100s", tmp___4);
#line 208
    restore_uid();
    goto authsock_err;
  }
#line 213
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 214
  sunaddr.sun_family = (unsigned short)1;
#line 215
  strlcpy(sunaddr.sun_path, (char const   *)auth_sock_name, sizeof(sunaddr.sun_path));
#line 217
  tmp___7 = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                 sizeof(sunaddr));
#line 217
  if (tmp___7 < 0) {
#line 218
    tmp___5 = __errno_location();
#line 218
    tmp___6 = strerror(*tmp___5);
#line 218
    error("bind: %.100s", tmp___6);
#line 219
    restore_uid();
    goto authsock_err;
  }
#line 224
  restore_uid();
#line 227
  tmp___10 = listen(sock, 128);
#line 227
  if (tmp___10 < 0) {
#line 228
    tmp___8 = __errno_location();
#line 228
    tmp___9 = strerror(*tmp___8);
#line 228
    error("listen: %.100s", tmp___9);
    goto authsock_err;
  }
#line 233
  nc = channel_new((char *)"auth socket", 6, sock, sock, -1, 65536U, 16384U, 0, (char *)"auth socket",
                   1);
#line 237
  nc->path = xstrdup((char const   *)auth_sock_name);
#line 238
  return (1);
  authsock_err: 
#line 241
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 242
    xfree((void *)auth_sock_name);
  }
#line 243
  if ((unsigned int )auth_sock_dir != (unsigned int )((void *)0)) {
#line 244
    rmdir((char const   *)auth_sock_dir);
#line 245
    xfree((void *)auth_sock_dir);
  }
#line 247
  if (sock != -1) {
#line 248
    close(sock);
  }
#line 249
  auth_sock_name = (char *)((void *)0);
#line 250
  auth_sock_dir = (char *)((void *)0);
#line 251
  return (0);
}
}
#line 254 "session.c"
static void display_loginmsg(void) 
{ void *tmp ;
  u_int tmp___0 ;

  {
#line 257
  tmp___0 = buffer_len(& loginmsg);
#line 257
  if (tmp___0 > 0U) {
#line 258
    buffer_append(& loginmsg, (void const   *)"\000", 1U);
#line 259
    tmp = buffer_ptr(& loginmsg);
#line 259
    printf((char const   * __restrict  )"%s", (char *)tmp);
#line 260
    buffer_clear(& loginmsg);
  }
#line 262
  return;
}
}
#line 264 "session.c"
void do_authenticated(Authctxt *authctxt___0 ) 
{ 

  {
#line 267
  setproctitle("%s", (authctxt___0->pw)->pw_name);
#line 270
  if (! no_port_forwarding_flag) {
#line 270
    if (options.allow_tcp_forwarding) {
#line 271
      channel_permit_all_opens();
    }
  }
#line 273
  if (compat20) {
#line 274
    do_authenticated2(authctxt___0);
  } else {
#line 276
    do_authenticated1(authctxt___0);
  }
#line 278
  do_cleanup(authctxt___0);
#line 279
  return;
}
}
#line 287 "session.c"
static void do_authenticated1(Authctxt *authctxt___0 ) 
{ Session *s ;
  char *command ;
  int success ;
  int type ;
  int screen_flag ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  u_int compression_level ;
  int _len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int _len___1 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 293
  enable_compression_after_reply = 0;
#line 294
  compression_level = (u_int )0;
#line 296
  s = session_new();
#line 297
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 298
    error("no more sessions");
#line 299
    return;
  }
#line 301
  s->authctxt = authctxt___0;
#line 302
  s->pw = authctxt___0->pw;
#line 308
  while (1) {
#line 309
    success = 0;
#line 312
    type = packet_read();
#line 315
    switch (type) {
    case 37: 
#line 317
    compression_level = packet_get_int();
#line 318
    while (1) {
#line 318
      tmp = packet_remaining();
#line 318
      _len = tmp;
#line 318
      if (_len > 0) {
#line 318
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
              318);
#line 318
        packet_disconnect("Packet integrity error.");
      }
#line 318
      break;
    }
#line 319
    if (compression_level < 1U) {
#line 320
      packet_send_debug("Received invalid compression level %d.", compression_level);
#line 322
      break;
    } else {
#line 319
      if (compression_level > 9U) {
#line 320
        packet_send_debug("Received invalid compression level %d.", compression_level);
#line 322
        break;
      }
    }
#line 324
    if (options.compression == 0) {
#line 325
      debug2("compression disabled");
#line 326
      break;
    }
#line 329
    enable_compression_after_reply = 1;
#line 330
    success = 1;
#line 331
    break;
    case 10: 
#line 334
    success = session_pty_req(s);
#line 335
    break;
    case 34: 
#line 338
    tmp___0 = packet_get_string(& proto_len);
#line 338
    s->auth_proto = (char *)tmp___0;
#line 339
    tmp___1 = packet_get_string(& data_len);
#line 339
    s->auth_data = (char *)tmp___1;
#line 341
    tmp___2 = packet_get_protocol_flags();
#line 341
    screen_flag = (int )(tmp___2 & 1U);
#line 343
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 345
    tmp___3 = packet_remaining();
#line 345
    if (tmp___3 == 4) {
#line 346
      if (! screen_flag) {
#line 347
        debug2("Buggy client: X11 screen flag missing");
      }
#line 349
      s->screen = packet_get_int();
    } else {
#line 351
      s->screen = 0U;
    }
#line 353
    while (1) {
#line 353
      tmp___4 = packet_remaining();
#line 353
      _len___0 = tmp___4;
#line 353
      if (_len___0 > 0) {
#line 353
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "session.c",
              353);
#line 353
        packet_disconnect("Packet integrity error.");
      }
#line 353
      break;
    }
#line 354
    success = session_setup_x11fwd(s);
#line 355
    if (! success) {
#line 356
      xfree((void *)s->auth_proto);
#line 357
      xfree((void *)s->auth_data);
#line 358
      s->auth_proto = (char *)((void *)0);
#line 359
      s->auth_data = (char *)((void *)0);
    }
#line 361
    break;
    case 30: 
#line 364
    if (! options.allow_agent_forwarding) {
#line 366
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 367
      break;
    } else {
#line 364
      if (no_agent_forwarding_flag) {
#line 366
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 367
        break;
      } else {
#line 364
        if (compat13) {
#line 366
          debug("Authentication agent forwarding not permitted for this authentication.");
#line 367
          break;
        }
      }
    }
#line 369
    debug("Received authentication agent forwarding request.");
#line 370
    success = auth_input_request_forwarding(s->pw);
#line 371
    break;
    case 28: 
#line 374
    if (no_port_forwarding_flag) {
#line 375
      debug("Port forwarding not permitted for this authentication.");
#line 376
      break;
    }
#line 378
    if (! options.allow_tcp_forwarding) {
#line 379
      debug("Port forwarding not permitted.");
#line 380
      break;
    }
#line 382
    debug("Received TCP/IP port forwarding request.");
#line 383
    tmp___5 = channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
#line 383
    if (tmp___5 < 0) {
#line 385
      debug("Port forwarding failed.");
#line 386
      break;
    }
#line 388
    success = 1;
#line 389
    break;
    case 38: 
#line 392
    tmp___6 = packet_get_int();
#line 392
    tmp___7 = packet_set_maxsize(tmp___6);
#line 392
    if (tmp___7 > 0) {
#line 393
      success = 1;
    }
#line 394
    break;
    case 12: 
    case 13: 
#line 398
    if (type == 13) {
#line 399
      tmp___8 = packet_get_string(& dlen);
#line 399
      command = (char *)tmp___8;
#line 400
      debug("Exec command \'%.500s\'", command);
#line 401
      tmp___9 = do_exec(s, (char const   *)command);
#line 401
      if (tmp___9 != 0) {
#line 402
        packet_disconnect("command execution failed");
      }
#line 404
      xfree((void *)command);
    } else {
#line 406
      tmp___10 = do_exec(s, (char const   *)((void *)0));
#line 406
      if (tmp___10 != 0) {
#line 407
        packet_disconnect("shell execution failed");
      }
    }
#line 410
    while (1) {
#line 410
      tmp___11 = packet_remaining();
#line 410
      _len___1 = tmp___11;
#line 410
      if (_len___1 > 0) {
#line 410
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "session.c",
              410);
#line 410
        packet_disconnect("Packet integrity error.");
      }
#line 410
      break;
    }
#line 411
    session_close(s);
#line 412
    return;
    default: 
#line 419
    logit("Unknown packet type received after authentication: %d", type);
    }
#line 421
    if (success) {
#line 421
      tmp___12 = 14;
    } else {
#line 421
      tmp___12 = 15;
    }
#line 421
    packet_start((unsigned char )tmp___12);
#line 422
    packet_send();
#line 423
    packet_write_wait();
#line 426
    if (enable_compression_after_reply) {
#line 427
      enable_compression_after_reply = 0;
#line 428
      packet_start_compression((int )compression_level);
    }
  }
}
}
#line 439 "session.c"
int do_exec_no_pty(Session *s , char const   *command ) 
{ pid_t pid ;
  int pin[2] ;
  int pout[2] ;
  int perr[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  __pid_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 448
  tmp___1 = pipe((int *)(pin));
#line 448
  if (tmp___1 < 0) {
#line 449
    tmp = __errno_location();
#line 449
    tmp___0 = strerror(*tmp);
#line 449
    error("%s: pipe in: %.100s", "do_exec_no_pty", tmp___0);
#line 450
    return (-1);
  }
#line 452
  tmp___4 = pipe((int *)(pout));
#line 452
  if (tmp___4 < 0) {
#line 453
    tmp___2 = __errno_location();
#line 453
    tmp___3 = strerror(*tmp___2);
#line 453
    error("%s: pipe out: %.100s", "do_exec_no_pty", tmp___3);
#line 454
    close(pin[0]);
#line 455
    close(pin[1]);
#line 456
    return (-1);
  }
#line 458
  tmp___7 = pipe((int *)(perr));
#line 458
  if (tmp___7 < 0) {
#line 459
    tmp___5 = __errno_location();
#line 459
    tmp___6 = strerror(*tmp___5);
#line 459
    error("%s: pipe err: %.100s", "do_exec_no_pty", tmp___6);
#line 460
    close(pin[0]);
#line 461
    close(pin[1]);
#line 462
    close(pout[0]);
#line 463
    close(pout[1]);
#line 464
    return (-1);
  }
#line 482
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 483
    fatal("do_exec_no_pty: no session");
  }
#line 485
  session_proctitle(s);
#line 488
  pid = fork();
#line 488
  switch (pid) {
  case -1: 
#line 490
  tmp___8 = __errno_location();
#line 490
  tmp___9 = strerror(*tmp___8);
#line 490
  error("%s: fork: %.100s", "do_exec_no_pty", tmp___9);
#line 492
  close(pin[0]);
#line 493
  close(pin[1]);
#line 494
  close(pout[0]);
#line 495
  close(pout[1]);
#line 496
  close(perr[0]);
#line 497
  close(perr[1]);
#line 504
  return (-1);
  case 0: 
#line 506
  is_child = 1;
#line 509
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 516
  tmp___12 = setsid();
#line 516
  if (tmp___12 < 0) {
#line 517
    tmp___10 = __errno_location();
#line 517
    tmp___11 = strerror(*tmp___10);
#line 517
    error("setsid failed: %.100s", tmp___11);
  }
#line 524
  close(pin[1]);
#line 525
  tmp___13 = dup2(pin[0], 0);
#line 525
  if (tmp___13 < 0) {
#line 526
    perror("dup2 stdin");
  }
#line 527
  close(pin[0]);
#line 530
  close(pout[0]);
#line 531
  tmp___14 = dup2(pout[1], 1);
#line 531
  if (tmp___14 < 0) {
#line 532
    perror("dup2 stdout");
  }
#line 533
  close(pout[1]);
#line 536
  close(perr[0]);
#line 537
  tmp___15 = dup2(perr[1], 2);
#line 537
  if (tmp___15 < 0) {
#line 538
    perror("dup2 stderr");
  }
#line 539
  close(perr[1]);
#line 564
  do_child(s, command);
  default: ;
#line 567
  break;
  }
#line 578
  s->pid = pid;
#line 580
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 587
  buffer_clear(& loginmsg);
#line 591
  close(pin[0]);
#line 592
  close(pout[1]);
#line 593
  close(perr[1]);
#line 595
  if (compat20) {
#line 596
    if (s->is_subsystem) {
#line 597
      close(perr[0]);
#line 598
      perr[0] = -1;
    }
#line 600
    session_set_fds(s, pin[1], pout[0], perr[0], 0);
  } else {
#line 603
    server_loop(pid, pin[1], pout[0], perr[0]);
  }
#line 625
  return (0);
}
}
#line 634 "session.c"
int do_exec_pty(Session *s , char const   *command ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 640
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 641
    fatal("do_exec_pty: no session");
  }
#line 642
  ptyfd = s->ptyfd;
#line 643
  ttyfd = s->ttyfd;
#line 652
  fdout___0 = dup(ptyfd);
#line 652
  if (fdout___0 < 0) {
#line 653
    tmp = __errno_location();
#line 653
    tmp___0 = strerror(*tmp);
#line 653
    error("%s: dup #1: %s", "do_exec_pty", tmp___0);
#line 654
    close(ttyfd);
#line 655
    close(ptyfd);
#line 656
    return (-1);
  }
#line 659
  ptymaster = dup(ptyfd);
#line 659
  if (ptymaster < 0) {
#line 660
    tmp___1 = __errno_location();
#line 660
    tmp___2 = strerror(*tmp___1);
#line 660
    error("%s: dup #2: %s", "do_exec_pty", tmp___2);
#line 661
    close(ttyfd);
#line 662
    close(ptyfd);
#line 663
    close(fdout___0);
#line 664
    return (-1);
  }
#line 668
  pid = fork();
#line 668
  switch (pid) {
  case -1: 
#line 670
  tmp___3 = __errno_location();
#line 670
  tmp___4 = strerror(*tmp___3);
#line 670
  error("%s: fork: %.100s", "do_exec_pty", tmp___4);
#line 671
  close(fdout___0);
#line 672
  close(ptymaster);
#line 673
  close(ttyfd);
#line 674
  close(ptyfd);
#line 675
  return (-1);
  case 0: 
#line 677
  is_child = 1;
#line 679
  close(fdout___0);
#line 680
  close(ptymaster);
#line 683
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 686
  close(ptyfd);
#line 689
  pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 692
  tmp___7 = dup2(ttyfd, 0);
#line 692
  if (tmp___7 < 0) {
#line 693
    tmp___5 = __errno_location();
#line 693
    tmp___6 = strerror(*tmp___5);
#line 693
    error("dup2 stdin: %s", tmp___6);
  }
#line 694
  tmp___10 = dup2(ttyfd, 1);
#line 694
  if (tmp___10 < 0) {
#line 695
    tmp___8 = __errno_location();
#line 695
    tmp___9 = strerror(*tmp___8);
#line 695
    error("dup2 stdout: %s", tmp___9);
  }
#line 696
  tmp___13 = dup2(ttyfd, 2);
#line 696
  if (tmp___13 < 0) {
#line 697
    tmp___11 = __errno_location();
#line 697
    tmp___12 = strerror(*tmp___11);
#line 697
    error("dup2 stderr: %s", tmp___12);
  }
#line 700
  close(ttyfd);
#line 704
  if (options.use_login) {
#line 704
    if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 708
      do_login(s, command);
    }
  } else {
#line 708
    do_login(s, command);
  }
#line 719
  do_child(s, command);
  default: ;
#line 722
  break;
  }
#line 733
  s->pid = pid;
#line 736
  close(ttyfd);
#line 739
  s->ptymaster = ptymaster;
#line 740
  packet_set_interactive(1);
#line 741
  if (compat20) {
#line 742
    session_set_fds(s, ptyfd, fdout___0, -1, 1);
  } else {
#line 744
    server_loop(pid, ptyfd, fdout___0, -1);
  }
#line 747
  return (0);
}
}
#line 782 "session.c"
int do_exec(Session *s , char const   *command ) 
{ int ret___0 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 787
  if (options.adm_forced_command) {
#line 788
    original_command = command;
#line 789
    command = (char const   *)options.adm_forced_command;
#line 790
    if (0) {
#line 790
      if (0) {
#line 790
        __s1_len___0 = strlen(command);
#line 790
        __s2_len___0 = strlen("internal-sftp");
#line 790
        if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) == 1U)) {
          goto _L___2;
        } else {
#line 790
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 790
            if (! ((unsigned int )((void const   *)("internal-sftp" + 1)) - (unsigned int )((void const   *)"internal-sftp") == 1U)) {
#line 790
              tmp___22 = 1;
            } else {
#line 790
              if (__s2_len___0 >= 4U) {
#line 790
                tmp___22 = 1;
              } else {
#line 790
                tmp___22 = 0;
              }
            }
          } else {
#line 790
            tmp___22 = 0;
          }
        }
#line 790
        if (tmp___22) {
#line 790
          tmp___18 = __builtin_strcmp(command, "internal-sftp");
        } else {
#line 790
          tmp___21 = __builtin_strcmp(command, "internal-sftp");
#line 790
          tmp___18 = tmp___21;
        }
      } else {
#line 790
        tmp___21 = __builtin_strcmp(command, "internal-sftp");
#line 790
        tmp___18 = tmp___21;
      }
#line 790
      tmp___12 = tmp___18;
    } else {
#line 790
      tmp___12 = strncmp(command, "internal-sftp", sizeof("internal-sftp") - 1U);
    }
#line 790
    if (tmp___12) {
      _L___3: /* CIL Label */ 
#line 792
      if (s->is_subsystem) {
#line 793
        s->is_subsystem = 1;
      }
    } else {
#line 790
      if ((int const   )*(command + (sizeof("internal-sftp") - 1U)) == 0) {
#line 791
        s->is_subsystem = 2;
      } else {
#line 790
        if ((int const   )*(command + (sizeof("internal-sftp") - 1U)) == 32) {
#line 791
          s->is_subsystem = 2;
        } else {
#line 790
          if ((int const   )*(command + (sizeof("internal-sftp") - 1U)) == 9) {
#line 791
            s->is_subsystem = 2;
          } else {
            goto _L___3;
          }
        }
      }
    }
#line 794
    debug("Forced command (config) \'%.900s\'", command);
  } else {
#line 795
    if (forced_command) {
#line 796
      original_command = command;
#line 797
      command = (char const   *)forced_command;
#line 798
      if (0) {
#line 798
        if (0) {
#line 798
          __s1_len___2 = strlen(command);
#line 798
          __s2_len___2 = strlen("internal-sftp");
#line 798
          if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) == 1U)) {
            goto _L___7;
          } else {
#line 798
            if (__s1_len___2 >= 4U) {
              _L___7: /* CIL Label */ 
#line 798
              if (! ((unsigned int )((void const   *)("internal-sftp" + 1)) - (unsigned int )((void const   *)"internal-sftp") == 1U)) {
#line 798
                tmp___48 = 1;
              } else {
#line 798
                if (__s2_len___2 >= 4U) {
#line 798
                  tmp___48 = 1;
                } else {
#line 798
                  tmp___48 = 0;
                }
              }
            } else {
#line 798
              tmp___48 = 0;
            }
          }
#line 798
          if (tmp___48) {
#line 798
            tmp___44 = __builtin_strcmp(command, "internal-sftp");
          } else {
#line 798
            tmp___47 = __builtin_strcmp(command, "internal-sftp");
#line 798
            tmp___44 = tmp___47;
          }
        } else {
#line 798
          tmp___47 = __builtin_strcmp(command, "internal-sftp");
#line 798
          tmp___44 = tmp___47;
        }
#line 798
        tmp___38 = tmp___44;
      } else {
#line 798
        tmp___38 = strncmp(command, "internal-sftp", sizeof("internal-sftp") - 1U);
      }
#line 798
      if (tmp___38) {
        _L___8: /* CIL Label */ 
#line 800
        if (s->is_subsystem) {
#line 801
          s->is_subsystem = 1;
        }
      } else {
#line 798
        if ((int const   )*(command + (sizeof("internal-sftp") - 1U)) == 0) {
#line 799
          s->is_subsystem = 2;
        } else {
#line 798
          if ((int const   )*(command + (sizeof("internal-sftp") - 1U)) == 32) {
#line 799
            s->is_subsystem = 2;
          } else {
#line 798
            if ((int const   )*(command + (sizeof("internal-sftp") - 1U)) == 9) {
#line 799
              s->is_subsystem = 2;
            } else {
              goto _L___8;
            }
          }
        }
      }
#line 802
      debug("Forced command (key option) \'%.900s\'", command);
    }
  }
#line 816
  if (s->ttyfd != -1) {
#line 817
    ret___0 = do_exec_pty(s, command);
  } else {
#line 819
    ret___0 = do_exec_no_pty(s, command);
  }
#line 821
  original_command = (char const   *)((void *)0);
#line 828
  buffer_clear(& loginmsg);
#line 830
  return (ret___0);
}
}
#line 834 "session.c"
void do_login(Session *s , char const   *command ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct passwd *pw___0 ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 839
  pw___0 = s->pw;
#line 840
  tmp = getpid();
#line 840
  pid = tmp;
#line 846
  memset((void *)(& from), 0, sizeof(from));
#line 847
  fromlen = sizeof(from);
#line 848
  tmp___4 = packet_connection_is_on_socket();
#line 848
  if (tmp___4) {
#line 849
    tmp___2 = packet_get_connection_in();
#line 849
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 849
    if (tmp___3 < 0) {
#line 851
      tmp___0 = __errno_location();
#line 851
      tmp___1 = strerror(*tmp___0);
#line 851
      debug("getpeername: %.100s", tmp___1);
#line 852
      cleanup_exit(255);
    }
  }
#line 857
  if (! use_privsep) {
#line 858
    tmp___5 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 858
    record_login(pid, (char const   *)(s->tty), (char const   *)pw___0->pw_name, pw___0->pw_uid,
                 tmp___5, (struct sockaddr *)(& from), fromlen);
  }
#line 876
  tmp___6 = check_quietlogin(s, command);
#line 876
  if (tmp___6) {
#line 877
    return;
  }
#line 879
  display_loginmsg();
#line 881
  do_motd();
#line 882
  return;
}
}
#line 887 "session.c"
void do_motd(void) 
{ FILE *f ;
  char buf___1[256] ;
  char *tmp ;

  {
#line 893
  if (options.print_motd) {
#line 898
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 900
    if (f) {
#line 901
      while (1) {
#line 901
        tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 901
        if (! tmp) {
#line 901
          break;
        }
#line 902
        fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stdout);
      }
#line 903
      fclose(f);
    }
  }
#line 906
  return;
}
}
#line 912 "session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ char buf___1[256] ;
  struct passwd *pw___0 ;
  struct stat st ;
  int tmp ;

  {
#line 916
  pw___0 = s->pw;
#line 920
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 921
    return (1);
  }
#line 922
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.hushlogin",
           pw___0->pw_dir);
#line 927
  tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 927
  if (tmp >= 0) {
#line 928
    return (1);
  }
#line 930
  return (0);
}
}
#line 937 "session.c"
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ char **env ;
  u_int envsize ;
  u_int i ;
  u_int namelen ;
  void *tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;

  {
#line 949
  if ((unsigned int )*envp == (unsigned int )((void *)0)) {
#line 949
    if (*envsizep == 0U) {
#line 950
      tmp = xmalloc(sizeof(char *));
#line 950
      *envp = (char **)tmp;
#line 951
      *(*(envp + 0)) = (char *)((void *)0);
#line 952
      *envsizep = 1U;
    }
  }
#line 960
  env = *envp;
#line 961
  namelen = strlen(name);
#line 962
  i = 0U;
#line 962
  while (*(env + i)) {
#line 963
    if (0) {
#line 963
      if (0) {
#line 963
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 963
        __s2_len___0 = strlen(name);
#line 963
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 963
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 963
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 963
              tmp___23 = 1;
            } else {
#line 963
              if (__s2_len___0 >= 4U) {
#line 963
                tmp___23 = 1;
              } else {
#line 963
                tmp___23 = 0;
              }
            }
          } else {
#line 963
            tmp___23 = 0;
          }
        }
#line 963
        if (tmp___23) {
#line 963
          tmp___19 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 963
          tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 963
          tmp___19 = tmp___22;
        }
      } else {
#line 963
        tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 963
        tmp___19 = tmp___22;
      }
#line 963
      tmp___13 = tmp___19;
    } else {
#line 963
      tmp___13 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 963
    if (tmp___13 == 0) {
#line 963
      if ((int )*(*(env + i) + namelen) == 61) {
#line 964
        break;
      }
    }
#line 962
    i ++;
  }
#line 965
  if (*(env + i)) {
#line 967
    xfree((void *)*(env + i));
  } else {
#line 970
    envsize = *envsizep;
#line 971
    if (i >= envsize - 1U) {
#line 972
      if (envsize >= 1000U) {
#line 973
        fatal("child_set_env: too many env vars");
      }
#line 974
      envsize += 50U;
#line 975
      tmp___26 = xrealloc((void *)env, envsize, sizeof(char *));
#line 975
      *envp = (char **)tmp___26;
#line 975
      env = *envp;
#line 976
      *envsizep = envsize;
    }
#line 979
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 983
  tmp___27 = strlen(name);
#line 983
  tmp___28 = strlen(value);
#line 983
  tmp___29 = xmalloc(((tmp___27 + 1U) + tmp___28) + 1U);
#line 983
  *(env + i) = (char *)tmp___29;
#line 984
  tmp___30 = strlen(name);
#line 984
  tmp___31 = strlen(value);
#line 984
  snprintf((char * __restrict  )*(env + i), ((tmp___30 + 1U) + tmp___31) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 985
  return;
}
}
#line 993 "session.c"
static void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  u_int lineno ;
  unsigned int tmp___31 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
#line 1000
  lineno = (u_int )0;
#line 1002
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 1003
  if (! f) {
#line 1004
    return;
  }
#line 1006
  while (1) {
#line 1006
    tmp___34 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 1006
    if (! tmp___34) {
#line 1006
      break;
    }
#line 1007
    lineno ++;
#line 1007
    if (lineno > 1000U) {
#line 1008
      fatal("Too many lines in environment file %s", filename);
    }
#line 1009
    cp = buf___1;
#line 1009
    while (1) {
#line 1009
      if (! ((int )*cp == 32)) {
#line 1009
        if (! ((int )*cp == 9)) {
#line 1009
          break;
        }
      }
#line 1009
      cp ++;
    }
#line 1011
    if (! *cp) {
#line 1012
      continue;
    } else {
#line 1011
      if ((int )*cp == 35) {
#line 1012
        continue;
      } else {
#line 1011
        if ((int )*cp == 10) {
#line 1012
          continue;
        }
      }
    }
#line 1014
    tmp___31 = __builtin_strcspn((char const   *)cp, "\n");
#line 1014
    *(cp + tmp___31) = (char )'\000';
#line 1016
    tmp___33 = __builtin_strchr(cp, '=');
#line 1016
    value = tmp___33;
#line 1017
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 1018
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line %u in %.100s\n",
              lineno, filename);
#line 1020
      continue;
    }
#line 1026
    *value = (char )'\000';
#line 1027
    value ++;
#line 1028
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 1030
  fclose(f);
#line 1031
  return;
}
}
#line 1088 "session.c"
void copy_environment(char **source , char ***env , u_int *envsize ) 
{ char *var_name ;
  char *var_val ;
  int i ;
  char *tmp ;

  {
#line 1094
  if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 1095
    return;
  }
#line 1097
  i = 0;
#line 1097
  while ((unsigned int )*(source + i) != (unsigned int )((void *)0)) {
#line 1098
    var_name = xstrdup((char const   *)*(source + i));
#line 1099
    var_val = strstr((char const   *)var_name, "=");
#line 1099
    if ((unsigned int )var_val == (unsigned int )((void *)0)) {
#line 1100
      xfree((void *)var_name);
      goto __Cont;
    }
#line 1103
    tmp = var_val;
#line 1103
    var_val ++;
#line 1103
    *tmp = (char )'\000';
#line 1105
    debug3("Copy environment: %s=%s", var_name, var_val);
#line 1106
    child_set_env(env, envsize, (char const   *)var_name, (char const   *)var_val);
#line 1108
    xfree((void *)var_name);
    __Cont: /* CIL Label */ 
#line 1097
    i ++;
  }
#line 1110
  return;
}
}
#line 1112 "session.c"
static char **do_setup_env(Session *s , char const   *shell ) 
{ char buf___1[256] ;
  u_int i ;
  u_int envsize ;
  char **env ;
  char *laddr ;
  struct passwd *pw___0 ;
  char *path ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct envstring *ce ;
  char *str ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *cp ;
  char const   *tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 1118
  pw___0 = s->pw;
#line 1120
  path = (char *)((void *)0);
#line 1124
  envsize = 100U;
#line 1125
  tmp = xcalloc(envsize, sizeof(char *));
#line 1125
  env = (char **)tmp;
#line 1126
  *(env + 0) = (char *)((void *)0);
#line 1149
  if (! options.use_login) {
#line 1151
    i = 0U;
#line 1151
    while (i < s->num_env) {
#line 1152
      child_set_env(& env, & envsize, (char const   *)(s->env + i)->name, (char const   *)(s->env + i)->val);
#line 1151
      i ++;
    }
#line 1155
    child_set_env(& env, & envsize, "USER", (char const   *)pw___0->pw_name);
#line 1156
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw___0->pw_name);
#line 1160
    child_set_env(& env, & envsize, "HOME", (char const   *)pw___0->pw_dir);
#line 1178
    if ((unsigned int )path == (unsigned int )((void *)0)) {
      goto _L;
    } else {
#line 1178
      if ((int )*path == 0) {
        _L: /* CIL Label */ 
#line 1179
        if ((s->pw)->pw_uid == 0U) {
#line 1179
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        } else {
#line 1179
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        }
#line 1179
        child_set_env(& env, & envsize, "PATH", tmp___0);
      }
    }
#line 1186
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw___0->pw_name);
#line 1188
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 1191
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1193
  tmp___2 = getenv("TZ");
#line 1193
  if (tmp___2) {
#line 1194
    tmp___1 = getenv("TZ");
#line 1194
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___1);
  }
#line 1197
  if (! options.use_login) {
#line 1198
    while (custom_environment) {
#line 1199
      ce = custom_environment;
#line 1200
      str = ce->s;
#line 1202
      i = 0U;
#line 1202
      while (1) {
#line 1202
        if ((int )*(str + i) != 61) {
#line 1202
          if (! *(str + i)) {
#line 1202
            break;
          }
        } else {
#line 1202
          break;
        }
#line 1202
        i ++;
      }
#line 1204
      if ((int )*(str + i) == 61) {
#line 1205
        *(str + i) = (char)0;
#line 1206
        child_set_env(& env, & envsize, (char const   *)str, (char const   *)((str + i) + 1));
      }
#line 1208
      custom_environment = ce->next;
#line 1209
      xfree((void *)ce->s);
#line 1210
      xfree((void *)ce);
    }
  }
#line 1215
  tmp___3 = get_local_port();
#line 1215
  tmp___4 = get_remote_port();
#line 1215
  tmp___5 = get_remote_ipaddr();
#line 1215
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___5, tmp___4, tmp___3);
#line 1217
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1219
  tmp___6 = packet_get_connection_in();
#line 1219
  laddr = get_local_ipaddr(tmp___6);
#line 1220
  tmp___7 = get_local_port();
#line 1220
  tmp___8 = get_remote_port();
#line 1220
  tmp___9 = get_remote_ipaddr();
#line 1220
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %.50s %d",
           tmp___9, tmp___8, laddr, tmp___7);
#line 1222
  xfree((void *)laddr);
#line 1223
  child_set_env(& env, & envsize, "SSH_CONNECTION", (char const   *)(buf___1));
#line 1225
  if (s->ttyfd != -1) {
#line 1226
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
  }
#line 1227
  if (s->term) {
#line 1228
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
  }
#line 1229
  if (s->display) {
#line 1230
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
  }
#line 1231
  if (original_command) {
#line 1232
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", original_command);
  }
#line 1248
  cp = getenv("KRB5CCNAME");
#line 1248
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1249
    child_set_env(& env, & envsize, "KRB5CCNAME", (char const   *)cp);
  }
#line 1284
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 1285
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)auth_sock_name);
  }
#line 1289
  if (options.permit_user_env) {
#line 1289
    if (! options.use_login) {
#line 1291
      if (0) {
#line 1291
        __s1_len___0 = strlen((char const   *)pw___0->pw_dir);
#line 1291
        __s2_len___0 = strlen("/");
#line 1291
        if (! ((unsigned int )((void const   *)(pw___0->pw_dir + 1)) - (unsigned int )((void const   *)pw___0->pw_dir) == 1U)) {
          goto _L___3;
        } else {
#line 1291
          if (__s1_len___0 >= 4U) {
            _L___3: /* CIL Label */ 
#line 1291
            if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 1291
              tmp___30 = 1;
            } else {
#line 1291
              if (__s2_len___0 >= 4U) {
#line 1291
                tmp___30 = 1;
              } else {
#line 1291
                tmp___30 = 0;
              }
            }
          } else {
#line 1291
            tmp___30 = 0;
          }
        }
#line 1291
        if (tmp___30) {
#line 1291
          tmp___26 = __builtin_strcmp((char const   *)pw___0->pw_dir, "/");
        } else {
#line 1291
          tmp___29 = __builtin_strcmp((char const   *)pw___0->pw_dir, "/");
#line 1291
          tmp___26 = tmp___29;
        }
      } else {
#line 1291
        tmp___29 = __builtin_strcmp((char const   *)pw___0->pw_dir, "/");
#line 1291
        tmp___26 = tmp___29;
      }
#line 1291
      if (tmp___26) {
#line 1291
        tmp___20 = (char const   *)pw___0->pw_dir;
      } else {
#line 1291
        tmp___20 = "";
      }
#line 1291
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
               tmp___20);
#line 1292
      read_environment_file(& env, & envsize, (char const   *)(buf___1));
    }
  }
#line 1294
  if (debug_flag) {
#line 1296
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1297
    i = 0U;
#line 1297
    while (*(env + i)) {
#line 1298
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1297
      i ++;
    }
  }
#line 1300
  return (env);
}
}
#line 1307 "session.c"
static void do_rc_files(Session *s , char const   *shell ) 
{ FILE *f ;
  char cmd[1024] ;
  int do_xauth ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1310
  f = (FILE *)((void *)0);
#line 1315
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1315
    if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1315
      if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1315
        tmp = 1;
      } else {
#line 1315
        tmp = 0;
      }
    } else {
#line 1315
      tmp = 0;
    }
  } else {
#line 1315
    tmp = 0;
  }
#line 1315
  do_xauth = tmp;
#line 1319
  if (! s->is_subsystem) {
#line 1319
    if ((unsigned int )options.adm_forced_command == (unsigned int )((void *)0)) {
#line 1319
      if (! no_user_rc) {
#line 1319
        tmp___1 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1319
        if (tmp___1 >= 0) {
#line 1321
          snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -c \'%s %s\'",
                   shell, "/bin/sh", ".ssh/rc");
#line 1323
          if (debug_flag) {
#line 1324
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s\n",
                    cmd);
          }
#line 1325
          f = popen((char const   *)(cmd), "w");
#line 1326
          if (f) {
#line 1327
            if (do_xauth) {
#line 1328
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      s->auth_proto, s->auth_data);
            }
#line 1330
            pclose(f);
          } else {
#line 1332
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                    ".ssh/rc");
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1334
    tmp___0 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1334
    if (tmp___0 >= 0) {
#line 1335
      if (debug_flag) {
#line 1336
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                "/bin/sh", "/usr/local/etc/sshrc");
      }
#line 1338
      f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1339
      if (f) {
#line 1340
        if (do_xauth) {
#line 1341
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1343
        pclose(f);
      } else {
#line 1345
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                "/usr/local/etc/sshrc");
      }
    } else {
#line 1347
      if (do_xauth) {
#line 1347
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1349
          if (debug_flag) {
#line 1350
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.500s remove %.100s\n",
                    options.xauth_location, s->auth_display);
#line 1353
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%.500s add %.100s %.100s %.100s\n",
                    options.xauth_location, s->auth_display, s->auth_proto, s->auth_data);
          }
#line 1358
          snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                   options.xauth_location);
#line 1360
          f = popen((char const   *)(cmd), "w");
#line 1361
          if (f) {
#line 1362
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"remove %s\n",
                    s->auth_display);
#line 1364
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                    s->auth_display, s->auth_proto, s->auth_data);
#line 1367
            pclose(f);
          } else {
#line 1369
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                    cmd);
          }
        }
      }
    }
  }
#line 1373
  return;
}
}
#line 1375 "session.c"
static void do_nologin(struct passwd *pw___0 ) 
{ FILE *f ;
  char buf___1[1024] ;
  char *tmp ;

  {
#line 1378
  f = (FILE *)((void *)0);
#line 1386
  if (pw___0->pw_uid) {
#line 1387
    f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
  }
#line 1389
  if (f) {
#line 1391
    logit("User %.100s not allowed because %s exists", pw___0->pw_name, "/etc/nologin");
#line 1393
    while (1) {
#line 1393
      tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 1393
      if (! tmp) {
#line 1393
        break;
      }
#line 1394
      fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stderr);
    }
#line 1395
    fclose(f);
#line 1396
    fflush((FILE *)((void *)0));
#line 1397
    exit(254);
  }
#line 1399
  return;
}
}
#line 1405 "session.c"
static void safely_chroot(char const   *path , uid_t uid ) 
{ char const   *cp ;
  char component[4096] ;
  struct stat st ;
  size_t tmp ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 1412
  if ((int const   )*path != 47) {
#line 1413
    fatal("chroot path does not begin at root");
  }
#line 1414
  tmp = strlen(path);
#line 1414
  if (tmp >= sizeof(component)) {
#line 1415
    fatal("chroot path too long");
  }
#line 1421
  cp = path;
#line 1421
  while ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1422
    tmp___1 = __builtin_strchr((char *)cp, '/');
#line 1422
    cp = (char const   *)tmp___1;
#line 1422
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1423
      strlcpy(component, path, sizeof(component));
    } else {
#line 1425
      cp ++;
#line 1426
      memcpy((void * __restrict  )(component), (void const   * __restrict  )path,
             (unsigned int )(cp - path));
#line 1427
      component[cp - path] = (char )'\000';
    }
#line 1430
    debug3("%s: checking \'%s\'", "safely_chroot", component);
#line 1432
    tmp___4 = stat((char const   * __restrict  )(component), (struct stat * __restrict  )(& st));
#line 1432
    if (tmp___4 != 0) {
#line 1433
      tmp___2 = __errno_location();
#line 1433
      tmp___3 = strerror(*tmp___2);
#line 1433
      fatal("%s: stat(\"%s\"): %s", "safely_chroot", component, tmp___3);
    }
#line 1435
    if (st.st_uid != 0U) {
      goto _L;
    } else {
#line 1435
      if ((st.st_mode & 18U) != 0U) {
        _L: /* CIL Label */ 
#line 1436
        if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1436
          tmp___5 = "";
        } else {
#line 1436
          tmp___5 = "component ";
        }
#line 1436
        fatal("bad ownership or modes for chroot directory %s\"%s\"", tmp___5, component);
      }
    }
#line 1439
    if (! ((st.st_mode & 61440U) == 16384U)) {
#line 1440
      if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1440
        tmp___6 = "";
      } else {
#line 1440
        tmp___6 = "component ";
      }
#line 1440
      fatal("chroot path %s\"%s\" is not a directory", tmp___6, component);
    }
  }
#line 1445
  tmp___9 = chdir(path);
#line 1445
  if (tmp___9 == -1) {
#line 1446
    tmp___7 = __errno_location();
#line 1446
    tmp___8 = strerror(*tmp___7);
#line 1446
    fatal("Unable to chdir to chroot path \"%s\": %s", path, tmp___8);
  }
#line 1448
  tmp___12 = chroot(path);
#line 1448
  if (tmp___12 == -1) {
#line 1449
    tmp___10 = __errno_location();
#line 1449
    tmp___11 = strerror(*tmp___10);
#line 1449
    fatal("chroot(\"%s\"): %s", path, tmp___11);
  }
#line 1450
  tmp___15 = chdir("/");
#line 1450
  if (tmp___15 == -1) {
#line 1451
    tmp___13 = __errno_location();
#line 1451
    tmp___14 = strerror(*tmp___13);
#line 1451
    fatal("%s: chdir(/) after chroot: %s", "safely_chroot", tmp___14);
  }
#line 1453
  verbose("Changed root directory to \"%s\"", path);
#line 1454
  return;
}
}
#line 1457 "session.c"
void do_setusercontext(struct passwd *pw___0 ) 
{ char *chroot_path ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;

  {
#line 1468
  tmp___6 = getuid();
#line 1468
  if (tmp___6 == 0U) {
    goto _L;
  } else {
#line 1468
    tmp___7 = geteuid();
#line 1468
    if (tmp___7 == 0U) {
      _L: /* CIL Label */ 
#line 1497
      tmp___2 = setlogin((char const   *)pw___0->pw_name);
#line 1497
      if (tmp___2 < 0) {
#line 1498
        tmp___0 = __errno_location();
#line 1498
        tmp___1 = strerror(*tmp___0);
#line 1498
        error("setlogin failed: %s", tmp___1);
      }
#line 1499
      tmp___3 = setgid(pw___0->pw_gid);
#line 1499
      if (tmp___3 < 0) {
#line 1500
        perror("setgid");
#line 1501
        exit(1);
      }
#line 1504
      tmp___4 = initgroups((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 1504
      if (tmp___4 < 0) {
#line 1505
        perror("initgroups");
#line 1506
        exit(1);
      }
#line 1508
      endgrent();
#line 1532
      if ((unsigned int )options.chroot_directory != (unsigned int )((void *)0)) {
#line 1532
        tmp___5 = strcasecmp((char const   *)options.chroot_directory, "none");
#line 1532
        if (tmp___5 != 0) {
#line 1534
          tmp = tilde_expand_filename((char const   *)options.chroot_directory, pw___0->pw_uid);
#line 1536
          chroot_path = percent_expand((char const   *)tmp, "h", pw___0->pw_dir, "u",
                                       pw___0->pw_name, (char *)((void *)0));
#line 1538
          safely_chroot((char const   *)chroot_path, pw___0->pw_uid);
#line 1539
          free((void *)tmp);
#line 1540
          free((void *)chroot_path);
        }
      }
#line 1550
      permanently_set_uid(pw___0);
    }
  }
#line 1557
  tmp___8 = getuid();
#line 1557
  if (tmp___8 != pw___0->pw_uid) {
#line 1558
    fatal("Failed to set uids to %u.", pw___0->pw_uid);
  } else {
#line 1557
    tmp___9 = geteuid();
#line 1557
    if (tmp___9 != pw___0->pw_uid) {
#line 1558
      fatal("Failed to set uids to %u.", pw___0->pw_uid);
    }
  }
#line 1563
  return;
}
}
#line 1565 "session.c"
static void do_pwchange(Session *s ) 
{ 

  {
#line 1568
  fflush((FILE *)((void *)0));
#line 1569
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Your password has expired.\n");
#line 1570
  if (s->ttyfd != -1) {
#line 1571
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"You must change your password now and login again!\n");
#line 1577
    execl("/usr/bin//passwd", "passwd", (char *)((void *)0));
#line 1579
    perror("passwd");
  } else {
#line 1581
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Password change required but no TTY available.\n");
  }
#line 1584
  exit(1);
}
}
#line 1587 "session.c"
static void launch_login(struct passwd *pw___0 , char const   *hostname ) 
{ 

  {
#line 1592
  execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw___0->pw_name,
        (char *)((void *)0));
#line 1604
  perror("login");
#line 1605
  exit(1);
}
}
#line 1608 "session.c"
static void child_close_fds(void) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1613
  tmp___2 = packet_get_connection_in();
#line 1613
  tmp___3 = packet_get_connection_out();
#line 1613
  if (tmp___2 == tmp___3) {
#line 1614
    tmp = packet_get_connection_in();
#line 1614
    close(tmp);
  } else {
#line 1616
    tmp___0 = packet_get_connection_in();
#line 1616
    close(tmp___0);
#line 1617
    tmp___1 = packet_get_connection_out();
#line 1617
    close(tmp___1);
  }
#line 1624
  channel_close_all();
#line 1630
  endpwent();
#line 1638
  i = 3;
#line 1638
  while (i < 64) {
#line 1639
    close(i);
#line 1638
    i ++;
  }
#line 1640
  return;
}
}
#line 1648 "session.c"
void do_child(Session *s , char const   *command ) 
{ char **env ;
  char *argv[10] ;
  char const   *shell ;
  char const   *shell0 ;
  char const   *hostname ;
  struct passwd *pw___0 ;
  int r ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int i ;
  char *p ;
  char *args ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char argv0___0[256] ;
  int *tmp___7 ;
  size_t tmp___8 ;

  {
#line 1654
  hostname = (char const   *)((void *)0);
#line 1655
  pw___0 = s->pw;
#line 1656
  r = 0;
#line 1659
  destroy_sensitive_data();
#line 1662
  if ((s->authctxt)->force_pwchange) {
#line 1663
    do_setusercontext(pw___0);
#line 1664
    child_close_fds();
#line 1665
    do_pwchange(s);
#line 1666
    exit(1);
  }
#line 1670
  if (options.use_login) {
#line 1670
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1671
      options.use_login = 0;
    }
  }
#line 1681
  if (! options.use_login) {
#line 1688
    if (! options.use_pam) {
#line 1689
      do_nologin(pw___0);
    }
#line 1690
    do_setusercontext(pw___0);
#line 1696
    tmp = check_quietlogin(s, command);
#line 1696
    if (! tmp) {
#line 1697
      display_loginmsg();
    }
  }
#line 1713
  if ((int )*(pw___0->pw_shell + 0) == 0) {
#line 1713
    shell = "/bin/sh";
  } else {
#line 1713
    shell = (char const   *)pw___0->pw_shell;
  }
#line 1719
  env = do_setup_env(s, shell);
#line 1726
  if (options.use_login) {
#line 1727
    hostname = get_remote_name_or_ip(utmp_len, options.use_dns);
  }
#line 1736
  child_close_fds();
#line 1742
  environ = env;
#line 1771
  tmp___2 = chdir((char const   *)pw___0->pw_dir);
#line 1771
  if (tmp___2 < 0) {
#line 1776
    if (r) {
#line 1777
      tmp___0 = __errno_location();
#line 1777
      tmp___1 = strerror(*tmp___0);
#line 1777
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
              pw___0->pw_dir, tmp___1);
    } else {
#line 1776
      if ((unsigned int )options.chroot_directory == (unsigned int )((void *)0)) {
#line 1777
        tmp___0 = __errno_location();
#line 1777
        tmp___1 = strerror(*tmp___0);
#line 1777
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
                pw___0->pw_dir, tmp___1);
      }
    }
#line 1780
    if (r) {
#line 1781
      exit(1);
    }
  }
#line 1784
  closefrom(3);
#line 1786
  if (! options.use_login) {
#line 1787
    do_rc_files(s, shell);
  }
#line 1790
  mysignal(13, (void (*)(int  ))0);
#line 1792
  if (s->is_subsystem == 2) {
#line 1797
    setproctitle("%s@internal-sftp-server", (s->pw)->pw_name);
#line 1798
    if (command) {
#line 1798
      tmp___3 = command;
    } else {
#line 1798
      tmp___3 = "sftp-server";
    }
#line 1798
    args = xstrdup(tmp___3);
#line 1799
    i = 0;
#line 1799
    p = strtok((char * __restrict  )args, (char const   * __restrict  )" ");
#line 1799
    while (p) {
#line 1800
      if (i < 9) {
#line 1801
        tmp___4 = i;
#line 1801
        i ++;
#line 1801
        argv[tmp___4] = p;
      }
#line 1799
      p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" ");
    }
#line 1802
    argv[i] = (char *)((void *)0);
#line 1803
    BSDoptreset = 1;
#line 1803
    BSDoptind = BSDoptreset;
#line 1804
    __progname = argv[0];
#line 1805
    tmp___5 = sftp_server_main(i, argv, s->pw);
#line 1805
    exit(tmp___5);
  }
#line 1808
  if (options.use_login) {
#line 1809
    launch_login(pw___0, hostname);
  }
#line 1814
  tmp___6 = strrchr(shell, '/');
#line 1814
  shell0 = (char const   *)tmp___6;
#line 1814
  if ((unsigned int )shell0 != (unsigned int )((void *)0)) {
#line 1815
    shell0 ++;
  } else {
#line 1817
    shell0 = shell;
  }
#line 1824
  if (! command) {
#line 1828
    argv0___0[0] = (char )'-';
#line 1830
    tmp___8 = strlcpy(argv0___0 + 1, shell0, sizeof(argv0___0) - 1U);
#line 1830
    if (tmp___8 >= sizeof(argv0___0) - 1U) {
#line 1832
      tmp___7 = __errno_location();
#line 1832
      *tmp___7 = 22;
#line 1833
      perror(shell);
#line 1834
      exit(1);
    }
#line 1838
    argv[0] = argv0___0;
#line 1839
    argv[1] = (char *)((void *)0);
#line 1840
    execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1843
    perror(shell);
#line 1844
    exit(1);
  }
#line 1850
  argv[0] = (char *)shell0;
#line 1851
  argv[1] = (char *)"-c";
#line 1852
  argv[2] = (char *)command;
#line 1853
  argv[3] = (char *)((void *)0);
#line 1854
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1855
  perror(shell);
#line 1856
  exit(1);
}
}
#line 1859 "session.c"
void session_unused(int id ) 
{ 

  {
#line 1862
  debug3("%s: session id %d unused", "session_unused", id);
#line 1863
  if (id >= options.max_sessions) {
#line 1865
    fatal("%s: insane session id %d (max %d nalloc %d)", "session_unused", id, options.max_sessions,
          sessions_nalloc);
  } else {
#line 1863
    if (id >= sessions_nalloc) {
#line 1865
      fatal("%s: insane session id %d (max %d nalloc %d)", "session_unused", id, options.max_sessions,
            sessions_nalloc);
    }
  }
#line 1868
  bzero((void *)(sessions + id), sizeof(*sessions));
#line 1869
  (sessions + id)->self = id;
#line 1870
  (sessions + id)->used = 0;
#line 1871
  (sessions + id)->chanid = -1;
#line 1872
  (sessions + id)->ptyfd = -1;
#line 1873
  (sessions + id)->ttyfd = -1;
#line 1874
  (sessions + id)->ptymaster = -1;
#line 1875
  (sessions + id)->x11_chanids = (int *)((void *)0);
#line 1876
  (sessions + id)->next_unused = sessions_first_unused;
#line 1877
  sessions_first_unused = id;
#line 1878
  return;
}
}
#line 1880 "session.c"
Session *session_new(void) 
{ Session *s ;
  Session *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1885
  if (sessions_first_unused == -1) {
#line 1886
    if (sessions_nalloc >= options.max_sessions) {
#line 1887
      return ((Session *)((void *)0));
    }
#line 1888
    debug2("%s: allocate (allocated %d max %d)", "session_new", sessions_nalloc, options.max_sessions);
#line 1890
    tmp___0 = xrealloc((void *)sessions, (unsigned int )(sessions_nalloc + 1), sizeof(*sessions));
#line 1890
    tmp = (Session *)tmp___0;
#line 1892
    if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 1893
      error("%s: cannot allocate %d sessions", "session_new", sessions_nalloc + 1);
#line 1895
      return ((Session *)((void *)0));
    }
#line 1897
    sessions = tmp;
#line 1898
    tmp___1 = sessions_nalloc;
#line 1898
    sessions_nalloc ++;
#line 1898
    session_unused(tmp___1);
  }
#line 1901
  if (sessions_first_unused >= sessions_nalloc) {
#line 1903
    fatal("%s: insane first_unused %d max %d nalloc %d", "session_new", sessions_first_unused,
          options.max_sessions, sessions_nalloc);
  } else {
#line 1901
    if (sessions_first_unused < 0) {
#line 1903
      fatal("%s: insane first_unused %d max %d nalloc %d", "session_new", sessions_first_unused,
            options.max_sessions, sessions_nalloc);
    }
  }
#line 1908
  s = sessions + sessions_first_unused;
#line 1909
  if (s->used) {
#line 1910
    fatal("%s: session %d already used", "session_new", sessions_first_unused);
  }
#line 1913
  sessions_first_unused = s->next_unused;
#line 1914
  s->used = 1;
#line 1915
  s->next_unused = -1;
#line 1916
  debug("session_new: session %d", s->self);
#line 1918
  return (s);
}
}
#line 1921 "session.c"
static void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1925
  i = 0;
#line 1925
  while (i < sessions_nalloc) {
#line 1926
    s = sessions + i;
#line 1928
    debug("dump: used %d next_unused %d session %d %p channel %d pid %ld", s->used,
          s->next_unused, s->self, s, s->chanid, (long )s->pid);
#line 1925
    i ++;
  }
#line 1937
  return;
}
}
#line 1939 "session.c"
int session_open(Authctxt *authctxt___0 , int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1942
  tmp = session_new();
#line 1942
  s = tmp;
#line 1943
  debug("session_open: channel %d", chanid);
#line 1944
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1945
    error("no more sessions");
#line 1946
    return (0);
  }
#line 1948
  s->authctxt = authctxt___0;
#line 1949
  s->pw = authctxt___0->pw;
#line 1950
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1951
    fatal("no user for session %d", s->self);
  } else {
#line 1950
    if (! authctxt___0->valid) {
#line 1951
      fatal("no user for session %d", s->self);
    }
  }
#line 1952
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1953
  s->chanid = chanid;
#line 1954
  return (1);
}
}
#line 1957 "session.c"
Session *session_by_tty(char *tty ) 
{ int i ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1961
  i = 0;
#line 1961
  while (i < sessions_nalloc) {
#line 1962
    s = sessions + i;
#line 1963
    if (s->used) {
#line 1963
      if (s->ttyfd != -1) {
#line 1963
        if (0) {
#line 1963
          __s1_len = strlen((char const   *)(s->tty));
#line 1963
          __s2_len = strlen((char const   *)tty);
#line 1963
          if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
            goto _L___0;
          } else {
#line 1963
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1963
              if (! ((unsigned int )((void const   *)(tty + 1)) - (unsigned int )((void const   *)tty) == 1U)) {
#line 1963
                tmp___8 = 1;
              } else {
#line 1963
                if (__s2_len >= 4U) {
#line 1963
                  tmp___8 = 1;
                } else {
#line 1963
                  tmp___8 = 0;
                }
              }
            } else {
#line 1963
              tmp___8 = 0;
            }
          }
#line 1963
          if (tmp___8) {
#line 1963
            tmp___4 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
          } else {
#line 1963
            tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1963
            tmp___4 = tmp___7;
          }
        } else {
#line 1963
          tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1963
          tmp___4 = tmp___7;
        }
#line 1963
        if (tmp___4 == 0) {
#line 1964
          debug("session_by_tty: session %d tty %s", i, tty);
#line 1965
          return (s);
        }
      }
    }
#line 1961
    i ++;
  }
#line 1968
  debug("session_by_tty: unknown tty %.100s", tty);
#line 1969
  session_dump();
#line 1970
  return ((Session *)((void *)0));
}
}
#line 1973 "session.c"
static Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1977
  i = 0;
#line 1977
  while (i < sessions_nalloc) {
#line 1978
    s = sessions + i;
#line 1979
    if (s->used) {
#line 1979
      if (s->chanid == id) {
#line 1980
        debug("session_by_channel: session %d channel %d", i, id);
#line 1982
        return (s);
      }
    }
#line 1977
    i ++;
  }
#line 1985
  debug("session_by_channel: unknown channel %d", id);
#line 1986
  session_dump();
#line 1987
  return ((Session *)((void *)0));
}
}
#line 1990 "session.c"
static Session *session_by_x11_channel(int id ) 
{ int i ;
  int j ;
  Session *s ;

  {
#line 1995
  i = 0;
#line 1995
  while (i < sessions_nalloc) {
#line 1996
    s = sessions + i;
#line 1998
    if ((unsigned int )s->x11_chanids == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 1998
      if (! s->used) {
        goto __Cont;
      }
    }
#line 2000
    j = 0;
#line 2000
    while (*(s->x11_chanids + j) != -1) {
#line 2001
      if (*(s->x11_chanids + j) == id) {
#line 2002
        debug("session_by_x11_channel: session %d channel %d", s->self, id);
#line 2004
        return (s);
      }
#line 2000
      j ++;
    }
    __Cont: /* CIL Label */ 
#line 1995
    i ++;
  }
#line 2008
  debug("session_by_x11_channel: unknown channel %d", id);
#line 2009
  session_dump();
#line 2010
  return ((Session *)((void *)0));
}
}
#line 2013 "session.c"
static Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 2017
  debug("session_by_pid: pid %ld", (long )pid);
#line 2018
  i = 0;
#line 2018
  while (i < sessions_nalloc) {
#line 2019
    s = sessions + i;
#line 2020
    if (s->used) {
#line 2020
      if (s->pid == pid) {
#line 2021
        return (s);
      }
    }
#line 2018
    i ++;
  }
#line 2023
  error("session_by_pid: unknown pid %ld", (long )pid);
#line 2024
  session_dump();
#line 2025
  return ((Session *)((void *)0));
}
}
#line 2028 "session.c"
static int session_window_change_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 2031
  s->col = packet_get_int();
#line 2032
  s->row = packet_get_int();
#line 2033
  s->xpixel = packet_get_int();
#line 2034
  s->ypixel = packet_get_int();
#line 2035
  while (1) {
#line 2035
    tmp = packet_remaining();
#line 2035
    _len = tmp;
#line 2035
    if (_len > 0) {
#line 2035
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2035);
#line 2035
      packet_disconnect("Packet integrity error.");
    }
#line 2035
    break;
  }
#line 2036
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 2037
  return (1);
}
}
#line 2040 "session.c"
static int session_pty_req(Session *s ) 
{ u_int len ;
  int n_bytes ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___12 ;
  int _len ;
  int tmp___13 ;

  {
#line 2046
  if (no_pty_flag) {
#line 2047
    debug("Allocating a pty not permitted for this authentication.");
#line 2048
    return (0);
  }
#line 2050
  if (s->ttyfd != -1) {
#line 2051
    packet_disconnect("Protocol error: you already have a pty.");
#line 2052
    return (0);
  }
#line 2055
  tmp = packet_get_string(& len);
#line 2055
  s->term = (char *)tmp;
#line 2057
  if (compat20) {
#line 2058
    s->col = packet_get_int();
#line 2059
    s->row = packet_get_int();
  } else {
#line 2061
    s->row = packet_get_int();
#line 2062
    s->col = packet_get_int();
  }
#line 2064
  s->xpixel = packet_get_int();
#line 2065
  s->ypixel = packet_get_int();
#line 2067
  if (0) {
#line 2067
    __s1_len = strlen((char const   *)s->term);
#line 2067
    __s2_len = strlen("");
#line 2067
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 2067
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 2067
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 2067
          tmp___9 = 1;
        } else {
#line 2067
          if (__s2_len >= 4U) {
#line 2067
            tmp___9 = 1;
          } else {
#line 2067
            tmp___9 = 0;
          }
        }
      } else {
#line 2067
        tmp___9 = 0;
      }
    }
#line 2067
    if (tmp___9) {
#line 2067
      tmp___5 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 2067
      tmp___8 = __builtin_strcmp((char const   *)s->term, "");
#line 2067
      tmp___5 = tmp___8;
    }
  } else {
#line 2067
    tmp___8 = __builtin_strcmp((char const   *)s->term, "");
#line 2067
    tmp___5 = tmp___8;
  }
#line 2067
  if (tmp___5 == 0) {
#line 2068
    xfree((void *)s->term);
#line 2069
    s->term = (char *)((void *)0);
  }
#line 2073
  debug("Allocating pty.");
#line 2074
  if (use_privsep) {
#line 2074
    tmp___12 = mm_pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, sizeof(s->tty));
  } else {
#line 2074
    tmp___12 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, sizeof(s->tty));
  }
#line 2074
  if (! tmp___12) {
#line 2076
    if (s->term) {
#line 2077
      xfree((void *)s->term);
    }
#line 2078
    s->term = (char *)((void *)0);
#line 2079
    s->ptyfd = -1;
#line 2080
    s->ttyfd = -1;
#line 2081
    error("session_pty_req: session %d alloc failed", s->self);
#line 2082
    return (0);
  }
#line 2084
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 2087
  if (! compat20) {
#line 2088
    n_bytes = packet_remaining();
  }
#line 2089
  tty_parse_modes(s->ttyfd, & n_bytes);
#line 2091
  if (! use_privsep) {
#line 2092
    pty_setowner(s->pw, (char const   *)(s->tty));
  }
#line 2095
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 2097
  while (1) {
#line 2097
    tmp___13 = packet_remaining();
#line 2097
    _len = tmp___13;
#line 2097
    if (_len > 0) {
#line 2097
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2097);
#line 2097
      packet_disconnect("Packet integrity error.");
    }
#line 2097
    break;
  }
#line 2098
  session_proctitle(s);
#line 2099
  return (1);
}
}
#line 2102 "session.c"
static int session_subsystem_req(Session *s ) 
{ struct stat st ;
  u_int len ;
  int success ;
  char *prog ;
  char *cmd ;
  char *subsys ;
  void *tmp ;
  u_int i ;
  int _len ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 2107
  success = 0;
#line 2108
  tmp = packet_get_string(& len);
#line 2108
  subsys = (char *)tmp;
#line 2111
  while (1) {
#line 2111
    tmp___0 = packet_remaining();
#line 2111
    _len = tmp___0;
#line 2111
    if (_len > 0) {
#line 2111
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2111);
#line 2111
      packet_disconnect("Packet integrity error.");
    }
#line 2111
    break;
  }
#line 2112
  logit("subsystem request for %.100s", subsys);
#line 2114
  i = 0U;
#line 2114
  while (i < options.num_subsystems) {
#line 2115
    if (0) {
#line 2115
      __s1_len___0 = strlen((char const   *)subsys);
#line 2115
      __s2_len___0 = strlen((char const   *)options.subsystem_name[i]);
#line 2115
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___2;
      } else {
#line 2115
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2115
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 2115
            tmp___24 = 1;
          } else {
#line 2115
            if (__s2_len___0 >= 4U) {
#line 2115
              tmp___24 = 1;
            } else {
#line 2115
              tmp___24 = 0;
            }
          }
        } else {
#line 2115
          tmp___24 = 0;
        }
      }
#line 2115
      if (tmp___24) {
#line 2115
        tmp___20 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 2115
        tmp___23 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 2115
        tmp___20 = tmp___23;
      }
    } else {
#line 2115
      tmp___23 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 2115
      tmp___20 = tmp___23;
    }
#line 2115
    if (tmp___20 == 0) {
#line 2116
      prog = options.subsystem_command[i];
#line 2117
      cmd = options.subsystem_args[i];
#line 2118
      if (0) {
#line 2118
        __s1_len = strlen("internal-sftp");
#line 2118
        __s2_len = strlen((char const   *)prog);
#line 2118
        if (! ((unsigned int )((void const   *)("internal-sftp" + 1)) - (unsigned int )((void const   *)"internal-sftp") == 1U)) {
          goto _L___0;
        } else {
#line 2118
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 2118
            if (! ((unsigned int )((void const   *)(prog + 1)) - (unsigned int )((void const   *)prog) == 1U)) {
#line 2118
              tmp___13 = 1;
            } else {
#line 2118
              if (__s2_len >= 4U) {
#line 2118
                tmp___13 = 1;
              } else {
#line 2118
                tmp___13 = 0;
              }
            }
          } else {
#line 2118
            tmp___13 = 0;
          }
        }
#line 2118
        if (tmp___13) {
#line 2118
          tmp___9 = __builtin_strcmp("internal-sftp", (char const   *)prog);
        } else {
#line 2118
          tmp___12 = __builtin_strcmp("internal-sftp", (char const   *)prog);
#line 2118
          tmp___9 = tmp___12;
        }
      } else {
#line 2118
        tmp___12 = __builtin_strcmp("internal-sftp", (char const   *)prog);
#line 2118
        tmp___9 = tmp___12;
      }
#line 2118
      if (tmp___9) {
#line 2120
        tmp___3 = stat((char const   * __restrict  )prog, (struct stat * __restrict  )(& st));
#line 2120
        if (tmp___3 < 0) {
#line 2121
          tmp___1 = __errno_location();
#line 2121
          tmp___2 = strerror(*tmp___1);
#line 2121
          error("subsystem: cannot stat %s: %s", prog, tmp___2);
#line 2123
          break;
        } else {
#line 2125
          s->is_subsystem = 1;
        }
      } else {
#line 2119
        s->is_subsystem = 2;
      }
#line 2127
      debug("subsystem: exec() %s", cmd);
#line 2128
      tmp___14 = do_exec(s, (char const   *)cmd);
#line 2128
      success = tmp___14 == 0;
#line 2129
      break;
    }
#line 2114
    i ++;
  }
#line 2133
  if (! success) {
#line 2134
    logit("subsystem request for %.100s failed, subsystem not found", subsys);
  }
#line 2137
  xfree((void *)subsys);
#line 2138
  return (success);
}
}
#line 2141 "session.c"
static int session_x11_req(Session *s ) 
{ int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 2146
  if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 2147
    error("session_x11_req: session %d: x11 forwarding already active", s->self);
#line 2149
    return (0);
  } else {
#line 2146
    if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 2147
      error("session_x11_req: session %d: x11 forwarding already active", s->self);
#line 2149
      return (0);
    }
  }
#line 2151
  tmp = packet_get_char();
#line 2151
  s->single_connection = (int )tmp;
#line 2152
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2152
  s->auth_proto = (char *)tmp___0;
#line 2153
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 2153
  s->auth_data = (char *)tmp___1;
#line 2154
  s->screen = packet_get_int();
#line 2155
  while (1) {
#line 2155
    tmp___2 = packet_remaining();
#line 2155
    _len = tmp___2;
#line 2155
    if (_len > 0) {
#line 2155
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2155);
#line 2155
      packet_disconnect("Packet integrity error.");
    }
#line 2155
    break;
  }
#line 2157
  success = session_setup_x11fwd(s);
#line 2158
  if (! success) {
#line 2159
    xfree((void *)s->auth_proto);
#line 2160
    xfree((void *)s->auth_data);
#line 2161
    s->auth_proto = (char *)((void *)0);
#line 2162
    s->auth_data = (char *)((void *)0);
  }
#line 2164
  return (success);
}
}
#line 2167 "session.c"
static int session_shell_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 2170
  while (1) {
#line 2170
    tmp = packet_remaining();
#line 2170
    _len = tmp;
#line 2170
    if (_len > 0) {
#line 2170
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2170);
#line 2170
      packet_disconnect("Packet integrity error.");
    }
#line 2170
    break;
  }
#line 2171
  tmp___0 = do_exec(s, (char const   *)((void *)0));
#line 2171
  return (tmp___0 == 0);
}
}
#line 2174 "session.c"
static int session_exec_req(Session *s ) 
{ u_int len ;
  u_int success ;
  char *command ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2179
  tmp = packet_get_string(& len);
#line 2179
  command = (char *)tmp;
#line 2180
  while (1) {
#line 2180
    tmp___0 = packet_remaining();
#line 2180
    _len = tmp___0;
#line 2180
    if (_len > 0) {
#line 2180
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2180);
#line 2180
      packet_disconnect("Packet integrity error.");
    }
#line 2180
    break;
  }
#line 2181
  tmp___1 = do_exec(s, (char const   *)command);
#line 2181
  success = (unsigned int )(tmp___1 == 0);
#line 2182
  xfree((void *)command);
#line 2183
  return ((int )success);
}
}
#line 2186 "session.c"
static int session_break_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 2190
  packet_get_int();
#line 2191
  while (1) {
#line 2191
    tmp = packet_remaining();
#line 2191
    _len = tmp;
#line 2191
    if (_len > 0) {
#line 2191
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2191);
#line 2191
      packet_disconnect("Packet integrity error.");
    }
#line 2191
    break;
  }
#line 2193
  if (s->ttyfd == -1) {
#line 2194
    return (0);
  } else {
#line 2193
    tmp___0 = tcsendbreak(s->ttyfd, 0);
#line 2193
    if (tmp___0 < 0) {
#line 2194
      return (0);
    }
  }
#line 2195
  return (1);
}
}
#line 2198 "session.c"
static int session_env_req(Session *s ) 
{ char *name ;
  char *val ;
  u_int name_len ;
  u_int val_len ;
  u_int i ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2204
  tmp = packet_get_string(& name_len);
#line 2204
  name = (char *)tmp;
#line 2205
  tmp___0 = packet_get_string(& val_len);
#line 2205
  val = (char *)tmp___0;
#line 2206
  while (1) {
#line 2206
    tmp___1 = packet_remaining();
#line 2206
    _len = tmp___1;
#line 2206
    if (_len > 0) {
#line 2206
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2206);
#line 2206
      packet_disconnect("Packet integrity error.");
    }
#line 2206
    break;
  }
#line 2209
  if (s->num_env > 128U) {
#line 2210
    debug2("Ignoring env request %s: too many env vars", name);
    goto fail;
  }
#line 2214
  i = 0U;
#line 2214
  while (i < options.num_accept_env) {
#line 2215
    tmp___3 = match_pattern((char const   *)name, (char const   *)options.accept_env[i]);
#line 2215
    if (tmp___3) {
#line 2216
      debug2("Setting env %d: %s=%s", s->num_env, name, val);
#line 2217
      tmp___2 = xrealloc((void *)s->env, s->num_env + 1U, sizeof(*(s->env)));
#line 2217
      s->env = (struct __anonstruct_env_81 *)tmp___2;
#line 2219
      (s->env + s->num_env)->name = name;
#line 2220
      (s->env + s->num_env)->val = val;
#line 2221
      (s->num_env) ++;
#line 2222
      return (1);
    }
#line 2214
    i ++;
  }
#line 2225
  debug2("Ignoring env request %s: disallowed name", name);
  fail: 
#line 2228
  xfree((void *)name);
#line 2229
  xfree((void *)val);
#line 2230
  return (0);
}
}
#line 2236
static int session_auth_agent_req(Session *s ) ;
#line 2236 "session.c"
static int called___1  =    0;
#line 2233 "session.c"
static int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 2237
  while (1) {
#line 2237
    tmp = packet_remaining();
#line 2237
    _len = tmp;
#line 2237
    if (_len > 0) {
#line 2237
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2237);
#line 2237
      packet_disconnect("Packet integrity error.");
    }
#line 2237
    break;
  }
#line 2238
  if (no_agent_forwarding_flag) {
#line 2239
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 2240
    return (0);
  } else {
#line 2238
    if (! options.allow_agent_forwarding) {
#line 2239
      debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 2240
      return (0);
    }
  }
#line 2242
  if (called___1) {
#line 2243
    return (0);
  } else {
#line 2245
    called___1 = 1;
#line 2246
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 2246
    return (tmp___0);
  }
}
}
#line 2250 "session.c"
int session_input_channel_req(Channel *c , char const   *rtype ) 
{ int success ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;

  {
#line 2253
  success = 0;
#line 2256
  s = session_by_channel(c->self);
#line 2256
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2257
    logit("session_input_channel_req: no session %d req %.100s", c->self, rtype);
#line 2259
    return (0);
  }
#line 2261
  debug("session_input_channel_req: session %d req %s", s->self, rtype);
#line 2267
  if (c->type == 10) {
#line 2268
    if (0) {
#line 2268
      __s1_len___5 = strlen(rtype);
#line 2268
      __s2_len___5 = strlen("shell");
#line 2268
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___12;
      } else {
#line 2268
        if (__s1_len___5 >= 4U) {
          _L___12: /* CIL Label */ 
#line 2268
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 2268
            tmp___68 = 1;
          } else {
#line 2268
            if (__s2_len___5 >= 4U) {
#line 2268
              tmp___68 = 1;
            } else {
#line 2268
              tmp___68 = 0;
            }
          }
        } else {
#line 2268
          tmp___68 = 0;
        }
      }
#line 2268
      if (tmp___68) {
#line 2268
        tmp___64 = __builtin_strcmp(rtype, "shell");
      } else {
#line 2268
        tmp___67 = __builtin_strcmp(rtype, "shell");
#line 2268
        tmp___64 = tmp___67;
      }
    } else {
#line 2268
      tmp___67 = __builtin_strcmp(rtype, "shell");
#line 2268
      tmp___64 = tmp___67;
    }
#line 2268
    if (tmp___64 == 0) {
#line 2269
      success = session_shell_req(s);
    } else {
#line 2270
      if (0) {
#line 2270
        __s1_len___4 = strlen(rtype);
#line 2270
        __s2_len___4 = strlen("exec");
#line 2270
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___10;
        } else {
#line 2270
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 2270
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 2270
              tmp___58 = 1;
            } else {
#line 2270
              if (__s2_len___4 >= 4U) {
#line 2270
                tmp___58 = 1;
              } else {
#line 2270
                tmp___58 = 0;
              }
            }
          } else {
#line 2270
            tmp___58 = 0;
          }
        }
#line 2270
        if (tmp___58) {
#line 2270
          tmp___54 = __builtin_strcmp(rtype, "exec");
        } else {
#line 2270
          tmp___57 = __builtin_strcmp(rtype, "exec");
#line 2270
          tmp___54 = tmp___57;
        }
      } else {
#line 2270
        tmp___57 = __builtin_strcmp(rtype, "exec");
#line 2270
        tmp___54 = tmp___57;
      }
#line 2270
      if (tmp___54 == 0) {
#line 2271
        success = session_exec_req(s);
      } else {
#line 2272
        if (0) {
#line 2272
          __s1_len___3 = strlen(rtype);
#line 2272
          __s2_len___3 = strlen("pty-req");
#line 2272
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___8;
          } else {
#line 2272
            if (__s1_len___3 >= 4U) {
              _L___8: /* CIL Label */ 
#line 2272
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 2272
                tmp___48 = 1;
              } else {
#line 2272
                if (__s2_len___3 >= 4U) {
#line 2272
                  tmp___48 = 1;
                } else {
#line 2272
                  tmp___48 = 0;
                }
              }
            } else {
#line 2272
              tmp___48 = 0;
            }
          }
#line 2272
          if (tmp___48) {
#line 2272
            tmp___44 = __builtin_strcmp(rtype, "pty-req");
          } else {
#line 2272
            tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 2272
            tmp___44 = tmp___47;
          }
        } else {
#line 2272
          tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 2272
          tmp___44 = tmp___47;
        }
#line 2272
        if (tmp___44 == 0) {
#line 2273
          success = session_pty_req(s);
        } else {
#line 2274
          if (0) {
#line 2274
            __s1_len___2 = strlen(rtype);
#line 2274
            __s2_len___2 = strlen("x11-req");
#line 2274
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___6;
            } else {
#line 2274
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 2274
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 2274
                  tmp___38 = 1;
                } else {
#line 2274
                  if (__s2_len___2 >= 4U) {
#line 2274
                    tmp___38 = 1;
                  } else {
#line 2274
                    tmp___38 = 0;
                  }
                }
              } else {
#line 2274
                tmp___38 = 0;
              }
            }
#line 2274
            if (tmp___38) {
#line 2274
              tmp___34 = __builtin_strcmp(rtype, "x11-req");
            } else {
#line 2274
              tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 2274
              tmp___34 = tmp___37;
            }
          } else {
#line 2274
            tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 2274
            tmp___34 = tmp___37;
          }
#line 2274
          if (tmp___34 == 0) {
#line 2275
            success = session_x11_req(s);
          } else {
#line 2276
            if (0) {
#line 2276
              __s1_len___1 = strlen(rtype);
#line 2276
              __s2_len___1 = strlen("auth-agent-req@openssh.com");
#line 2276
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___4;
              } else {
#line 2276
                if (__s1_len___1 >= 4U) {
                  _L___4: /* CIL Label */ 
#line 2276
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 2276
                    tmp___28 = 1;
                  } else {
#line 2276
                    if (__s2_len___1 >= 4U) {
#line 2276
                      tmp___28 = 1;
                    } else {
#line 2276
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 2276
                  tmp___28 = 0;
                }
              }
#line 2276
              if (tmp___28) {
#line 2276
                tmp___24 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
              } else {
#line 2276
                tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 2276
                tmp___24 = tmp___27;
              }
            } else {
#line 2276
              tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 2276
              tmp___24 = tmp___27;
            }
#line 2276
            if (tmp___24 == 0) {
#line 2277
              success = session_auth_agent_req(s);
            } else {
#line 2278
              if (0) {
#line 2278
                __s1_len___0 = strlen(rtype);
#line 2278
                __s2_len___0 = strlen("subsystem");
#line 2278
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___2;
                } else {
#line 2278
                  if (__s1_len___0 >= 4U) {
                    _L___2: /* CIL Label */ 
#line 2278
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 2278
                      tmp___18 = 1;
                    } else {
#line 2278
                      if (__s2_len___0 >= 4U) {
#line 2278
                        tmp___18 = 1;
                      } else {
#line 2278
                        tmp___18 = 0;
                      }
                    }
                  } else {
#line 2278
                    tmp___18 = 0;
                  }
                }
#line 2278
                if (tmp___18) {
#line 2278
                  tmp___14 = __builtin_strcmp(rtype, "subsystem");
                } else {
#line 2278
                  tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 2278
                  tmp___14 = tmp___17;
                }
              } else {
#line 2278
                tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 2278
                tmp___14 = tmp___17;
              }
#line 2278
              if (tmp___14 == 0) {
#line 2279
                success = session_subsystem_req(s);
              } else {
#line 2280
                if (0) {
#line 2280
                  __s1_len = strlen(rtype);
#line 2280
                  __s2_len = strlen("env");
#line 2280
                  if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                    goto _L___0;
                  } else {
#line 2280
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 2280
                      if (! ((unsigned int )((void const   *)("env" + 1)) - (unsigned int )((void const   *)"env") == 1U)) {
#line 2280
                        tmp___8 = 1;
                      } else {
#line 2280
                        if (__s2_len >= 4U) {
#line 2280
                          tmp___8 = 1;
                        } else {
#line 2280
                          tmp___8 = 0;
                        }
                      }
                    } else {
#line 2280
                      tmp___8 = 0;
                    }
                  }
#line 2280
                  if (tmp___8) {
#line 2280
                    tmp___4 = __builtin_strcmp(rtype, "env");
                  } else {
#line 2280
                    tmp___7 = __builtin_strcmp(rtype, "env");
#line 2280
                    tmp___4 = tmp___7;
                  }
                } else {
#line 2280
                  tmp___7 = __builtin_strcmp(rtype, "env");
#line 2280
                  tmp___4 = tmp___7;
                }
#line 2280
                if (tmp___4 == 0) {
#line 2281
                  success = session_env_req(s);
                }
              }
            }
          }
        }
      }
    }
  }
#line 2284
  if (0) {
#line 2284
    __s1_len___7 = strlen(rtype);
#line 2284
    __s2_len___7 = strlen("window-change");
#line 2284
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___16;
    } else {
#line 2284
      if (__s1_len___7 >= 4U) {
        _L___16: /* CIL Label */ 
#line 2284
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 2284
          tmp___88 = 1;
        } else {
#line 2284
          if (__s2_len___7 >= 4U) {
#line 2284
            tmp___88 = 1;
          } else {
#line 2284
            tmp___88 = 0;
          }
        }
      } else {
#line 2284
        tmp___88 = 0;
      }
    }
#line 2284
    if (tmp___88) {
#line 2284
      tmp___84 = __builtin_strcmp(rtype, "window-change");
    } else {
#line 2284
      tmp___87 = __builtin_strcmp(rtype, "window-change");
#line 2284
      tmp___84 = tmp___87;
    }
  } else {
#line 2284
    tmp___87 = __builtin_strcmp(rtype, "window-change");
#line 2284
    tmp___84 = tmp___87;
  }
#line 2284
  if (tmp___84 == 0) {
#line 2285
    success = session_window_change_req(s);
  } else {
#line 2286
    if (0) {
#line 2286
      __s1_len___6 = strlen(rtype);
#line 2286
      __s2_len___6 = strlen("break");
#line 2286
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___14;
      } else {
#line 2286
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 2286
          if (! ((unsigned int )((void const   *)("break" + 1)) - (unsigned int )((void const   *)"break") == 1U)) {
#line 2286
            tmp___78 = 1;
          } else {
#line 2286
            if (__s2_len___6 >= 4U) {
#line 2286
              tmp___78 = 1;
            } else {
#line 2286
              tmp___78 = 0;
            }
          }
        } else {
#line 2286
          tmp___78 = 0;
        }
      }
#line 2286
      if (tmp___78) {
#line 2286
        tmp___74 = __builtin_strcmp(rtype, "break");
      } else {
#line 2286
        tmp___77 = __builtin_strcmp(rtype, "break");
#line 2286
        tmp___74 = tmp___77;
      }
    } else {
#line 2286
      tmp___77 = __builtin_strcmp(rtype, "break");
#line 2286
      tmp___74 = tmp___77;
    }
#line 2286
    if (tmp___74 == 0) {
#line 2287
      success = session_break_req(s);
    }
  }
#line 2290
  return (success);
}
}
#line 2293 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 , int is_tty ) 
{ int tmp ;

  {
#line 2296
  if (! compat20) {
#line 2297
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 2302
  if (s->chanid == -1) {
#line 2303
    fatal("no channel for session %d", s->self);
  }
#line 2304
  if (fderr___0 == -1) {
#line 2304
    tmp = 0;
  } else {
#line 2304
    tmp = 1;
  }
#line 2304
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1, is_tty, 2097152U);
#line 2308
  return;
}
}
#line 2314 "session.c"
void session_pty_cleanup2(Session *s ) 
{ __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 2317
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2318
    error("session_pty_cleanup: no session");
#line 2319
    return;
  }
#line 2321
  if (s->ttyfd == -1) {
#line 2322
    return;
  }
#line 2324
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 2327
  if (s->pid != 0) {
#line 2328
    record_logout(s->pid, (char const   *)(s->tty), (char const   *)(s->pw)->pw_name);
  }
#line 2331
  tmp = getuid();
#line 2331
  if (tmp == 0U) {
#line 2332
    pty_release((char const   *)(s->tty));
  }
#line 2339
  if (s->ptymaster != -1) {
#line 2339
    tmp___2 = close(s->ptymaster);
#line 2339
    if (tmp___2 < 0) {
#line 2340
      tmp___0 = __errno_location();
#line 2340
      tmp___1 = strerror(*tmp___0);
#line 2340
      error("close(s->ptymaster/%d): %s", s->ptymaster, tmp___1);
    }
  }
#line 2344
  s->ttyfd = -1;
#line 2345
  return;
}
}
#line 2347 "session.c"
void session_pty_cleanup(Session *s ) 
{ 

  {
#line 2350
  if (use_privsep) {
#line 2350
    mm_session_pty_cleanup2(s);
  } else {
#line 2350
    session_pty_cleanup2(s);
  }
#line 2351
  return;
}
}
#line 2353 "session.c"
static char *sig2name(int sig ) 
{ 

  {
#line 2357
  if (sig == 6) {
#line 2357
    return ((char *)"ABRT");
  }
#line 2358
  if (sig == 14) {
#line 2358
    return ((char *)"ALRM");
  }
#line 2359
  if (sig == 8) {
#line 2359
    return ((char *)"FPE");
  }
#line 2360
  if (sig == 1) {
#line 2360
    return ((char *)"HUP");
  }
#line 2361
  if (sig == 4) {
#line 2361
    return ((char *)"ILL");
  }
#line 2362
  if (sig == 2) {
#line 2362
    return ((char *)"INT");
  }
#line 2363
  if (sig == 9) {
#line 2363
    return ((char *)"KILL");
  }
#line 2364
  if (sig == 13) {
#line 2364
    return ((char *)"PIPE");
  }
#line 2365
  if (sig == 3) {
#line 2365
    return ((char *)"QUIT");
  }
#line 2366
  if (sig == 11) {
#line 2366
    return ((char *)"SEGV");
  }
#line 2367
  if (sig == 15) {
#line 2367
    return ((char *)"TERM");
  }
#line 2368
  if (sig == 10) {
#line 2368
    return ((char *)"USR1");
  }
#line 2369
  if (sig == 12) {
#line 2369
    return ((char *)"USR2");
  }
#line 2371
  return ((char *)"SIG@openssh.com");
}
}
#line 2374 "session.c"
static void session_close_x11(int id ) 
{ Channel *c ;

  {
#line 2379
  c = channel_by_id(id);
#line 2379
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2380
    debug("session_close_x11: x11 channel %d missing", id);
  } else {
#line 2383
    debug("session_close_x11: detach x11 channel %d", id);
#line 2384
    channel_cancel_cleanup(id);
#line 2385
    if (c->ostate != 3U) {
#line 2386
      chan_mark_dead(c);
    }
  }
#line 2388
  return;
}
}
#line 2390 "session.c"
static void session_close_single_x11(int id , void *arg ) 
{ Session *s ;
  u_int i ;

  {
#line 2396
  debug3("session_close_single_x11: channel %d", id);
#line 2397
  channel_cancel_cleanup(id);
#line 2398
  s = session_by_x11_channel(id);
#line 2398
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2399
    fatal("session_close_single_x11: no x11 channel %d", id);
  }
#line 2400
  i = 0U;
#line 2400
  while (*(s->x11_chanids + i) != -1) {
#line 2401
    debug("session_close_single_x11: session %d: closing channel %d", s->self, *(s->x11_chanids + i));
#line 2407
    if (*(s->x11_chanids + i) != id) {
#line 2408
      session_close_x11(*(s->x11_chanids + i));
    }
#line 2400
    i ++;
  }
#line 2410
  xfree((void *)s->x11_chanids);
#line 2411
  s->x11_chanids = (int *)((void *)0);
#line 2412
  if (s->display) {
#line 2413
    xfree((void *)s->display);
#line 2414
    s->display = (char *)((void *)0);
  }
#line 2416
  if (s->auth_proto) {
#line 2417
    xfree((void *)s->auth_proto);
#line 2418
    s->auth_proto = (char *)((void *)0);
  }
#line 2420
  if (s->auth_data) {
#line 2421
    xfree((void *)s->auth_data);
#line 2422
    s->auth_data = (char *)((void *)0);
  }
#line 2424
  if (s->auth_display) {
#line 2425
    xfree((void *)s->auth_display);
#line 2426
    s->auth_display = (char *)((void *)0);
  }
#line 2428
  return;
}
}
#line 2430 "session.c"
static void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion___u_82 __u ;
  union __anonunion___u_83___0 __u___0 ;
  char *tmp ;
  int tmp___0 ;
  union __anonunion___u_85___0 __u___2 ;
  union __anonunion___u_86___0 __u___3 ;
  union __anonunion___u_87___0 __u___4 ;

  {
#line 2435
  c = channel_lookup(s->chanid);
#line 2435
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2436
    fatal("session_exit_message: session %d: no channel %d", s->self, s->chanid);
  }
#line 2438
  debug("session_exit_message: session %d channel %d pid %ld", s->self, s->chanid,
        (long )s->pid);
#line 2441
  __u___4.__in = status;
#line 2441
  if ((__u___4.__i & 127) == 0) {
#line 2442
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 2443
    __u.__in = status;
#line 2443
    packet_put_int((unsigned int )((__u.__i & 65280) >> 8));
#line 2444
    packet_send();
  } else {
#line 2445
    __u___3.__in = status;
#line 2445
    if ((int )((signed char )((__u___3.__i & 127) + 1)) >> 1 > 0) {
#line 2446
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 2447
      __u___0.__in = status;
#line 2447
      tmp = sig2name(__u___0.__i & 127);
#line 2447
      packet_put_cstring((char const   *)tmp);
#line 2449
      __u___2.__in = status;
#line 2449
      if (__u___2.__i & 128) {
#line 2449
        tmp___0 = 1;
      } else {
#line 2449
        tmp___0 = 0;
      }
#line 2449
      packet_put_char(tmp___0);
#line 2453
      packet_put_cstring("");
#line 2454
      packet_put_cstring("");
#line 2455
      packet_send();
    } else {
#line 2458
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 2462
  debug("session_exit_message: release channel %d", s->chanid);
#line 2469
  channel_register_cleanup(c->self, & session_close_by_channel, 1);
#line 2477
  if (c->ostate != 3U) {
#line 2478
    chan_write_failed(c);
  }
#line 2479
  return;
}
}
#line 2481 "session.c"
void session_close(Session *s ) 
{ u_int i ;

  {
#line 2486
  debug("session_close: session %d pid %ld", s->self, (long )s->pid);
#line 2487
  if (s->ttyfd != -1) {
#line 2488
    session_pty_cleanup(s);
  }
#line 2489
  if (s->term) {
#line 2490
    xfree((void *)s->term);
  }
#line 2491
  if (s->display) {
#line 2492
    xfree((void *)s->display);
  }
#line 2493
  if (s->x11_chanids) {
#line 2494
    xfree((void *)s->x11_chanids);
  }
#line 2495
  if (s->auth_display) {
#line 2496
    xfree((void *)s->auth_display);
  }
#line 2497
  if (s->auth_data) {
#line 2498
    xfree((void *)s->auth_data);
  }
#line 2499
  if (s->auth_proto) {
#line 2500
    xfree((void *)s->auth_proto);
  }
#line 2501
  if ((unsigned int )s->env != (unsigned int )((void *)0)) {
#line 2502
    i = 0U;
#line 2502
    while (i < s->num_env) {
#line 2503
      xfree((void *)(s->env + i)->name);
#line 2504
      xfree((void *)(s->env + i)->val);
#line 2502
      i ++;
    }
#line 2506
    xfree((void *)s->env);
  }
#line 2508
  session_proctitle(s);
#line 2509
  session_unused(s->self);
#line 2510
  return;
}
}
#line 2512 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 2515
  tmp = session_by_pid(pid);
#line 2515
  s = tmp;
#line 2516
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2517
    debug("session_close_by_pid: no session for pid %ld", (long )pid);
#line 2519
    return;
  }
#line 2521
  if (s->chanid != -1) {
#line 2522
    session_exit_message(s, status);
  }
#line 2523
  if (s->ttyfd != -1) {
#line 2524
    session_pty_cleanup(s);
  }
#line 2525
  s->pid = 0;
#line 2526
  return;
}
}
#line 2532 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  u_int i ;

  {
#line 2535
  tmp = session_by_channel(id);
#line 2535
  s = tmp;
#line 2538
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2539
    debug("session_close_by_channel: no session for id %d", id);
#line 2540
    return;
  }
#line 2542
  debug("session_close_by_channel: channel %d child %ld", id, (long )s->pid);
#line 2544
  if (s->pid != 0) {
#line 2545
    debug("session_close_by_channel: channel %d: has child", id);
#line 2550
    if (s->ttyfd != -1) {
#line 2551
      session_pty_cleanup(s);
    }
#line 2552
    return;
  }
#line 2555
  channel_cancel_cleanup(s->chanid);
#line 2558
  if ((unsigned int )s->x11_chanids != (unsigned int )((void *)0)) {
#line 2559
    i = 0U;
#line 2559
    while (*(s->x11_chanids + i) != -1) {
#line 2560
      session_close_x11(*(s->x11_chanids + i));
#line 2561
      *(s->x11_chanids + i) = -1;
#line 2559
      i ++;
    }
  }
#line 2565
  s->chanid = -1;
#line 2566
  session_close(s);
#line 2567
  return;
}
}
#line 2569 "session.c"
void session_destroy_all(void (*closefunc)(Session * ) ) 
{ int i ;
  Session *s ;

  {
#line 2573
  i = 0;
#line 2573
  while (i < sessions_nalloc) {
#line 2574
    s = sessions + i;
#line 2575
    if (s->used) {
#line 2576
      if ((unsigned int )closefunc != (unsigned int )((void *)0)) {
#line 2577
        (*closefunc)(s);
      } else {
#line 2579
        session_close(s);
      }
    }
#line 2573
    i ++;
  }
#line 2582
  return;
}
}
#line 2587 "session.c"
static char buf___0[1024]  ;
#line 2584 "session.c"
static char *session_tty_list(void) 
{ int i ;
  char *cp ;
  Session *s ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 2591
  buf___0[0] = (char )'\000';
#line 2592
  i = 0;
#line 2592
  while (i < sessions_nalloc) {
#line 2593
    s = sessions + i;
#line 2594
    if (s->used) {
#line 2594
      if (s->ttyfd != -1) {
#line 2596
        if (0) {
#line 2596
          if (0) {
#line 2596
            __s1_len___0 = strlen((char const   *)(s->tty));
#line 2596
            __s2_len___0 = strlen("/dev/");
#line 2596
            if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
              goto _L___2;
            } else {
#line 2596
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2596
                if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 2596
                  tmp___22 = 1;
                } else {
#line 2596
                  if (__s2_len___0 >= 4U) {
#line 2596
                    tmp___22 = 1;
                  } else {
#line 2596
                    tmp___22 = 0;
                  }
                }
              } else {
#line 2596
                tmp___22 = 0;
              }
            }
#line 2596
            if (tmp___22) {
#line 2596
              tmp___18 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
            } else {
#line 2596
              tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2596
              tmp___18 = tmp___21;
            }
          } else {
#line 2596
            tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2596
            tmp___18 = tmp___21;
          }
#line 2596
          tmp___12 = tmp___18;
        } else {
#line 2596
          tmp___12 = strncmp((char const   *)(s->tty), "/dev/", 5U);
        }
#line 2596
        if (tmp___12 != 0) {
#line 2597
          cp = strrchr((char const   *)(s->tty), '/');
#line 2598
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 2598
            cp = s->tty;
          } else {
#line 2598
            cp ++;
          }
        } else {
#line 2600
          cp = s->tty + 5;
        }
#line 2602
        if ((int )buf___0[0] != 0) {
#line 2603
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 2604
        strlcat(buf___0, (char const   *)cp, sizeof(buf___0));
      }
    }
#line 2592
    i ++;
  }
#line 2607
  if ((int )buf___0[0] == 0) {
#line 2608
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 2609
  return (buf___0);
}
}
#line 2612 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 2615
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 2616
    error("no user for session %d", s->self);
  } else {
#line 2618
    tmp = session_tty_list();
#line 2618
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 2619
  return;
}
}
#line 2621 "session.c"
int session_setup_x11fwd(Session *s ) 
{ struct stat st ;
  char display[512] ;
  char auth_display[512] ;
  char hostname[64] ;
  u_int i ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 2629
  if (no_x11_forwarding_flag) {
#line 2630
    packet_send_debug("X11 forwarding disabled in user configuration file.");
#line 2631
    return (0);
  }
#line 2633
  if (! options.x11_forwarding) {
#line 2634
    debug("X11 forwarding disabled in server configuration file.");
#line 2635
    return (0);
  }
#line 2637
  if (! options.xauth_location) {
#line 2639
    packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2640
    return (0);
  } else {
#line 2637
    tmp = stat((char const   * __restrict  )options.xauth_location, (struct stat * __restrict  )(& st));
#line 2637
    if (tmp == -1) {
#line 2639
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2640
      return (0);
    }
  }
#line 2642
  if (options.use_login) {
#line 2643
    packet_send_debug("X11 forwarding disabled; not compatible with UseLogin=yes.");
#line 2645
    return (0);
  }
#line 2647
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 2648
    debug("X11 display already set.");
#line 2649
    return (0);
  }
#line 2651
  tmp___0 = x11_create_display_inet(options.x11_display_offset, options.x11_use_localhost,
                                    s->single_connection, & s->display_number, & s->x11_chanids);
#line 2651
  if (tmp___0 == -1) {
#line 2654
    debug("x11_create_display_inet failed.");
#line 2655
    return (0);
  }
#line 2657
  i = 0U;
#line 2657
  while (*(s->x11_chanids + i) != -1) {
#line 2658
    channel_register_cleanup(*(s->x11_chanids + i), & session_close_single_x11, 0);
#line 2657
    i ++;
  }
#line 2663
  tmp___3 = gethostname(hostname, sizeof(hostname));
#line 2663
  if (tmp___3 < 0) {
#line 2664
    tmp___1 = __errno_location();
#line 2664
    tmp___2 = strerror(*tmp___1);
#line 2664
    fatal("gethostname: %.100s", tmp___2);
  }
#line 2670
  if (options.x11_use_localhost) {
#line 2671
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"localhost:%u.%u",
             s->display_number, s->screen);
#line 2673
    snprintf((char * __restrict  )(auth_display), sizeof(auth_display), (char const   * __restrict  )"unix:%u.%u",
             s->display_number, s->screen);
#line 2675
    s->display = xstrdup((char const   *)(display));
#line 2676
    s->auth_display = xstrdup((char const   *)(auth_display));
  } else {
#line 2692
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%u.%u",
             hostname, s->display_number, s->screen);
#line 2695
    s->display = xstrdup((char const   *)(display));
#line 2696
    s->auth_display = xstrdup((char const   *)(display));
  }
#line 2699
  return (1);
}
}
#line 2702 "session.c"
static void do_authenticated2(Authctxt *authctxt___0 ) 
{ 

  {
#line 2705
  server_loop2(authctxt___0);
#line 2706
  return;
}
}
#line 2711 "session.c"
static int called___2  =    0;
#line 2708 "session.c"
void do_cleanup(Authctxt *authctxt___0 ) 
{ int tmp ;

  {
#line 2713
  debug("do_cleanup");
#line 2716
  if (is_child) {
#line 2717
    return;
  }
#line 2720
  if (called___2) {
#line 2721
    return;
  }
#line 2722
  called___2 = 1;
#line 2724
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 2725
    return;
  }
#line 2734
  if (! authctxt___0->authenticated) {
#line 2735
    return;
  }
#line 2749
  auth_sock_cleanup_proc(authctxt___0->pw);
#line 2755
  if (! use_privsep) {
#line 2756
    session_destroy_all(& session_pty_cleanup2);
  } else {
#line 2755
    tmp = mm_is_monitor();
#line 2755
    if (tmp) {
#line 2756
      session_destroy_all(& session_pty_cleanup2);
    }
  }
#line 2757
  return;
}
}
#line 1 "auth-chall.o"
#pragma merger(0,"./auth-chall.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 41 "auth-chall.c"
KbdintDevice *devices[1] ;
#line 42 "auth-chall.c"
static KbdintDevice *device  ;
#line 45 "auth-chall.c"
char *get_challenge(Authctxt *authctxt___0 ) 
{ char *challenge ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int tmp ;

  {
#line 57
  device = devices[0];
#line 58
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 59
    return ((char *)((void *)0));
  }
#line 60
  authctxt___0->kbdintctxt = (*(device->init_ctx))(authctxt___0);
#line 60
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 61
    return ((char *)((void *)0));
  }
#line 62
  tmp = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                           & prompts, & echo_on);
#line 62
  if (tmp) {
#line 64
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 65
    authctxt___0->kbdintctxt = (void *)0;
#line 66
    return ((char *)((void *)0));
  }
#line 68
  if (numprompts < 1U) {
#line 69
    fatal("get_challenge: numprompts < 1");
  }
#line 70
  challenge = xstrdup((char const   *)*(prompts + 0));
#line 71
  i = 0U;
#line 71
  while (i < numprompts) {
#line 72
    xfree((void *)*(prompts + i));
#line 71
    i ++;
  }
#line 73
  xfree((void *)prompts);
#line 74
  xfree((void *)name);
#line 75
  xfree((void *)echo_on);
#line 76
  xfree((void *)info);
#line 78
  return (challenge);
}
}
#line 80 "auth-chall.c"
int verify_response(Authctxt *authctxt___0 , char const   *response ) 
{ char *resp[1] ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int authenticated ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 85
  authenticated = 0;
#line 87
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 88
    return (0);
  }
#line 89
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 90
    return (0);
  }
#line 91
  resp[0] = (char *)response;
#line 92
  tmp = (*(device->respond))(authctxt___0->kbdintctxt, 1U, resp);
#line 92
  switch (tmp) {
  case 0: 
#line 94
  authenticated = 1;
#line 95
  break;
  case 1: 
#line 97
  tmp___0 = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                               & prompts, & echo_on);
#line 97
  if (tmp___0 != 0) {
#line 99
    break;
  }
#line 100
  if (numprompts == 0U) {
#line 100
    tmp___1 = (*(device->respond))(authctxt___0->kbdintctxt, 0U, resp);
#line 100
    if (tmp___1 == 0) {
#line 102
      authenticated = 1;
    }
  }
#line 104
  i = 0U;
#line 104
  while (i < numprompts) {
#line 105
    xfree((void *)*(prompts + i));
#line 104
    i ++;
  }
#line 106
  xfree((void *)prompts);
#line 107
  xfree((void *)name);
#line 108
  xfree((void *)echo_on);
#line 109
  xfree((void *)info);
#line 110
  break;
  }
#line 112
  (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 113
  authctxt___0->kbdintctxt = (void *)0;
#line 114
  return (authenticated);
}
}
#line 116 "auth-chall.c"
void abandon_challenge_response(Authctxt *authctxt___0 ) 
{ 

  {
#line 119
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 120
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 121
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 123
  return;
}
}
#line 1 "auth2-chall.o"
#pragma merger(0,"./auth2-chall.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 153 "auth.h"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) ;
#line 49 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) ;
#line 50
static int send_userauth_info_request(Authctxt *authctxt___0 ) ;
#line 51
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) ;
#line 64 "auth2-chall.c"
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
#line 102 "auth2-chall.c"
static KbdintAuthctxt *kbdint_alloc(char const   *devs ) 
{ KbdintAuthctxt *kbdintctxt ;
  Buffer b ;
  int i ;
  void *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 114
  tmp = xmalloc(sizeof(KbdintAuthctxt ));
#line 114
  kbdintctxt = (KbdintAuthctxt *)tmp;
#line 115
  if (0) {
#line 115
    __s1_len = strlen(devs);
#line 115
    __s2_len = strlen("");
#line 115
    if (! ((unsigned int )((void const   *)(devs + 1)) - (unsigned int )((void const   *)devs) == 1U)) {
      goto _L___0;
    } else {
#line 115
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 115
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 115
          tmp___12 = 1;
        } else {
#line 115
          if (__s2_len >= 4U) {
#line 115
            tmp___12 = 1;
          } else {
#line 115
            tmp___12 = 0;
          }
        }
      } else {
#line 115
        tmp___12 = 0;
      }
    }
#line 115
    if (tmp___12) {
#line 115
      tmp___8 = __builtin_strcmp(devs, "");
    } else {
#line 115
      tmp___11 = __builtin_strcmp(devs, "");
#line 115
      tmp___8 = tmp___11;
    }
  } else {
#line 115
    tmp___11 = __builtin_strcmp(devs, "");
#line 115
    tmp___8 = tmp___11;
  }
#line 115
  if (tmp___8 == 0) {
#line 116
    buffer_init(& b);
#line 117
    i = 0;
#line 117
    while (devices[i]) {
#line 118
      tmp___0 = buffer_len(& b);
#line 118
      if (tmp___0 > 0U) {
#line 119
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 120
      tmp___1 = strlen((devices[i])->name);
#line 120
      buffer_append(& b, (void const   *)(devices[i])->name, tmp___1);
#line 117
      i ++;
    }
#line 123
    buffer_append(& b, (void const   *)"\000", 1U);
#line 124
    tmp___2 = buffer_ptr(& b);
#line 124
    kbdintctxt->devices = xstrdup((char const   *)tmp___2);
#line 125
    buffer_free(& b);
  } else {
#line 127
    kbdintctxt->devices = xstrdup(devs);
  }
#line 129
  debug("kbdint_alloc: devices \'%s\'", kbdintctxt->devices);
#line 130
  kbdintctxt->ctxt = (void *)0;
#line 131
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 132
  kbdintctxt->nreq = 0U;
#line 134
  return (kbdintctxt);
}
}
#line 136 "auth2-chall.c"
static void kbdint_reset_device(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 139
  if (kbdintctxt->ctxt) {
#line 140
    (*((kbdintctxt->device)->free_ctx))(kbdintctxt->ctxt);
#line 141
    kbdintctxt->ctxt = (void *)0;
  }
#line 143
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 144
  return;
}
}
#line 145 "auth2-chall.c"
static void kbdint_free(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 148
  if (kbdintctxt->device) {
#line 149
    kbdint_reset_device(kbdintctxt);
  }
#line 150
  if (kbdintctxt->devices) {
#line 151
    xfree((void *)kbdintctxt->devices);
#line 152
    kbdintctxt->devices = (char *)((void *)0);
  }
#line 154
  xfree((void *)kbdintctxt);
#line 155
  return;
}
}
#line 157 "auth2-chall.c"
static int kbdint_next_device(KbdintAuthctxt *kbdintctxt ) 
{ size_t len ;
  char *t ;
  int i ;
  unsigned int tmp___64 ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  char const   *tmp___92 ;
  int tmp___93 ;

  {
#line 164
  if (kbdintctxt->device) {
#line 165
    kbdint_reset_device(kbdintctxt);
  }
#line 166
  while (1) {
#line 168
    if (kbdintctxt->devices) {
#line 168
      tmp___64 = __builtin_strcspn((char const   *)kbdintctxt->devices, ",");
#line 168
      len = tmp___64;
    } else {
#line 168
      len = 0U;
    }
#line 170
    if (len == 0U) {
#line 171
      break;
    }
#line 172
    i = 0;
#line 172
    while (devices[i]) {
#line 173
      if (0) {
#line 173
        if (0) {
#line 173
          __s1_len___0 = strlen((char const   *)kbdintctxt->devices);
#line 173
          __s2_len___0 = strlen((devices[i])->name);
#line 173
          if (! ((unsigned int )((void const   *)(kbdintctxt->devices + 1)) - (unsigned int )((void const   *)kbdintctxt->devices) == 1U)) {
            goto _L___2;
          } else {
#line 173
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 173
              if (! ((unsigned int )((void const   *)((devices[i])->name + 1)) - (unsigned int )((void const   *)(devices[i])->name) == 1U)) {
#line 173
                tmp___88 = 1;
              } else {
#line 173
                if (__s2_len___0 >= 4U) {
#line 173
                  tmp___88 = 1;
                } else {
#line 173
                  tmp___88 = 0;
                }
              }
            } else {
#line 173
              tmp___88 = 0;
            }
          }
#line 173
          if (tmp___88) {
#line 173
            tmp___84 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
          } else {
#line 173
            tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 173
            tmp___84 = tmp___87;
          }
        } else {
#line 173
          tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 173
          tmp___84 = tmp___87;
        }
#line 173
        tmp___78 = tmp___84;
      } else {
#line 173
        tmp___78 = strncmp((char const   *)kbdintctxt->devices, (devices[i])->name,
                           len);
      }
#line 173
      if (tmp___78 == 0) {
#line 174
        kbdintctxt->device = devices[i];
      }
#line 172
      i ++;
    }
#line 175
    t = kbdintctxt->devices;
#line 176
    if (*(t + len)) {
#line 176
      kbdintctxt->devices = xstrdup((char const   *)((t + len) + 1));
    } else {
#line 176
      kbdintctxt->devices = (char *)((void *)0);
    }
#line 177
    xfree((void *)t);
#line 178
    if (kbdintctxt->devices) {
#line 178
      tmp___92 = (char const   *)kbdintctxt->devices;
    } else {
#line 178
      tmp___92 = "<empty>";
    }
#line 178
    debug2("kbdint_next_device: devices %s", tmp___92);
#line 166
    if (kbdintctxt->devices) {
#line 166
      if (! (! kbdintctxt->device)) {
#line 166
        break;
      }
    } else {
#line 166
      break;
    }
  }
#line 182
  if (kbdintctxt->device) {
#line 182
    tmp___93 = 1;
  } else {
#line 182
    tmp___93 = 0;
  }
#line 182
  return (tmp___93);
}
}
#line 189 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  KbdintAuthctxt *tmp___1 ;
  int tmp___2 ;

  {
#line 192
  if (devs) {
#line 192
    tmp = (char const   *)devs;
  } else {
#line 192
    tmp = "<no devs>";
  }
#line 192
  if (authctxt___0->user) {
#line 192
    tmp___0 = (char const   *)authctxt___0->user;
  } else {
#line 192
    tmp___0 = "<nouser>";
  }
#line 192
  debug("auth2_challenge: user=%s devs=%s", tmp___0, tmp);
#line 196
  if ((unsigned int )authctxt___0->user == (unsigned int )((void *)0)) {
#line 197
    return (0);
  } else {
#line 196
    if (! devs) {
#line 197
      return (0);
    }
  }
#line 198
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 199
    tmp___1 = kbdint_alloc((char const   *)devs);
#line 199
    authctxt___0->kbdintctxt = (void *)tmp___1;
  }
#line 200
  tmp___2 = auth2_challenge_start(authctxt___0);
#line 200
  return (tmp___2);
}
}
#line 204 "auth2-chall.c"
void auth2_challenge_stop(Authctxt *authctxt___0 ) 
{ 

  {
#line 208
  dispatch_set(61, (dispatch_fn *)((void *)0));
#line 209
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 210
    kbdint_free((KbdintAuthctxt *)authctxt___0->kbdintctxt);
#line 211
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 213
  return;
}
}
#line 216 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 219
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 221
  if (kbdintctxt->devices) {
#line 221
    tmp = (char const   *)kbdintctxt->devices;
  } else {
#line 221
    tmp = "<empty>";
  }
#line 221
  debug2("auth2_challenge_start: devices %s", tmp);
#line 224
  tmp___0 = kbdint_next_device(kbdintctxt);
#line 224
  if (tmp___0 == 0) {
#line 225
    auth2_challenge_stop(authctxt___0);
#line 226
    return (0);
  }
#line 228
  debug("auth2_challenge_start: trying authentication method \'%s\'", (kbdintctxt->device)->name);
#line 231
  kbdintctxt->ctxt = (*((kbdintctxt->device)->init_ctx))(authctxt___0);
#line 231
  if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 232
    auth2_challenge_stop(authctxt___0);
#line 233
    return (0);
  }
#line 235
  tmp___1 = send_userauth_info_request(authctxt___0);
#line 235
  if (tmp___1 == 0) {
#line 236
    auth2_challenge_stop(authctxt___0);
#line 237
    return (0);
  }
#line 239
  dispatch_set(61, & input_userauth_info_response);
#line 242
  authctxt___0->postponed = 1;
#line 243
  return (0);
}
}
#line 246 "auth2-chall.c"
static int send_userauth_info_request(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char *name ;
  char *instr ;
  char **prompts ;
  u_int i ;
  u_int *echo_on ;
  int tmp ;

  {
#line 253
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 254
  tmp = (*((kbdintctxt->device)->query))(kbdintctxt->ctxt, & name, & instr, & kbdintctxt->nreq,
                                         & prompts, & echo_on);
#line 254
  if (tmp) {
#line 256
    return (0);
  }
#line 258
  packet_start((unsigned char)60);
#line 259
  packet_put_cstring((char const   *)name);
#line 260
  packet_put_cstring((char const   *)instr);
#line 261
  packet_put_cstring("");
#line 262
  packet_put_int(kbdintctxt->nreq);
#line 263
  i = 0U;
#line 263
  while (i < kbdintctxt->nreq) {
#line 264
    packet_put_cstring((char const   *)*(prompts + i));
#line 265
    packet_put_char((int )*(echo_on + i));
#line 263
    i ++;
  }
#line 267
  packet_send();
#line 268
  packet_write_wait();
#line 270
  i = 0U;
#line 270
  while (i < kbdintctxt->nreq) {
#line 271
    xfree((void *)*(prompts + i));
#line 270
    i ++;
  }
#line 272
  xfree((void *)prompts);
#line 273
  xfree((void *)echo_on);
#line 274
  xfree((void *)name);
#line 275
  xfree((void *)instr);
#line 276
  return (1);
}
}
#line 279 "auth2-chall.c"
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  KbdintAuthctxt *kbdintctxt ;
  int authenticated ;
  int res ;
  u_int i ;
  u_int nresp ;
  char **response ;
  char *method ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 282
  authctxt___0 = (Authctxt *)ctxt;
#line 284
  authenticated = 0;
#line 286
  response = (char **)((void *)0);
#line 288
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 289
    fatal("input_userauth_info_response: no authctxt");
  }
#line 290
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 291
  if ((unsigned int )kbdintctxt == (unsigned int )((void *)0)) {
#line 292
    fatal("input_userauth_info_response: no kbdintctxt");
  } else {
#line 291
    if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 292
      fatal("input_userauth_info_response: no kbdintctxt");
    }
  }
#line 293
  if ((unsigned int )kbdintctxt->device == (unsigned int )((void *)0)) {
#line 294
    fatal("input_userauth_info_response: no device");
  }
#line 296
  authctxt___0->postponed = 0;
#line 297
  nresp = packet_get_int();
#line 298
  if (nresp != kbdintctxt->nreq) {
#line 299
    fatal("input_userauth_info_response: wrong number of replies");
  }
#line 300
  if (nresp > 100U) {
#line 301
    fatal("input_userauth_info_response: too many replies");
  }
#line 302
  if (nresp > 0U) {
#line 303
    tmp = xcalloc(nresp, sizeof(char *));
#line 303
    response = (char **)tmp;
#line 304
    i = 0U;
#line 304
    while (i < nresp) {
#line 305
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 305
      *(response + i) = (char *)tmp___0;
#line 304
      i ++;
    }
  }
#line 307
  while (1) {
#line 307
    tmp___1 = packet_remaining();
#line 307
    _len = tmp___1;
#line 307
    if (_len > 0) {
#line 307
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
            307);
#line 307
      packet_disconnect("Packet integrity error.");
    }
#line 307
    break;
  }
#line 309
  res = (*((kbdintctxt->device)->respond))(kbdintctxt->ctxt, nresp, response);
#line 311
  i = 0U;
#line 311
  while (i < nresp) {
#line 312
    tmp___2 = strlen((char const   *)*(response + i));
#line 312
    memset((void *)*(response + i), 'r', tmp___2);
#line 313
    xfree((void *)*(response + i));
#line 311
    i ++;
  }
#line 315
  if (response) {
#line 316
    xfree((void *)response);
  }
#line 318
  switch (res) {
  case 0: 
#line 321
  if (authctxt___0->valid) {
#line 321
    authenticated = 1;
  } else {
#line 321
    authenticated = 0;
  }
#line 322
  break;
  case 1: 
#line 325
  tmp___3 = send_userauth_info_request(authctxt___0);
#line 325
  if (tmp___3 == 1) {
#line 326
    authctxt___0->postponed = 1;
  }
#line 327
  break;
  default: ;
#line 330
  break;
  }
#line 333
  xasprintf(& method, "keyboard-interactive/%s", (kbdintctxt->device)->name);
#line 335
  if (! authctxt___0->postponed) {
#line 336
    if (authenticated) {
#line 337
      auth2_challenge_stop(authctxt___0);
    } else {
#line 341
      auth2_challenge_start(authctxt___0);
    }
  }
#line 344
  userauth_finish(authctxt___0, authenticated, method);
#line 345
  xfree((void *)method);
#line 346
  return;
}
}
#line 348 "auth2-chall.c"
void privsep_challenge_enable(void) 
{ 

  {
#line 374
  return;
}
}
#line 1 "groupaccess.o"
#pragma merger(0,"./groupaccess.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 41 "groupaccess.c"
static int ngroups  ;
#line 42 "groupaccess.c"
static char **groups_byname  ;
#line 48 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t *groups_bygid ;
  int i ;
  int j ;
  struct group *gr ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 55
  if (ngroups > 0) {
#line 56
    ga_free();
  }
#line 58
  ngroups = 65536;
#line 60
  tmp___2 = sysconf(3);
#line 60
  if (65536L > tmp___2) {
#line 60
    ngroups = 65536;
  } else {
#line 60
    tmp___1 = sysconf(3);
#line 60
    ngroups = (int )tmp___1;
  }
#line 63
  tmp___3 = xcalloc((unsigned int )ngroups, sizeof(*groups_bygid));
#line 63
  groups_bygid = (gid_t *)tmp___3;
#line 64
  tmp___4 = xcalloc((unsigned int )ngroups, sizeof(*groups_byname));
#line 64
  groups_byname = (char **)tmp___4;
#line 66
  tmp___5 = getgrouplist(user, base, groups_bygid, & ngroups);
#line 66
  if (tmp___5 == -1) {
#line 67
    logit("getgrouplist: groups list too small");
  }
#line 68
  i = 0;
#line 68
  j = 0;
#line 68
  while (i < ngroups) {
#line 69
    gr = getgrgid(*(groups_bygid + i));
#line 69
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 70
      tmp___6 = j;
#line 70
      j ++;
#line 70
      *(groups_byname + tmp___6) = xstrdup((char const   *)gr->gr_name);
    }
#line 68
    i ++;
  }
#line 71
  xfree((void *)groups_bygid);
#line 72
  ngroups = j;
#line 72
  return (ngroups);
}
}
#line 79 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 84
  i = 0;
#line 84
  while (i < ngroups) {
#line 85
    j = 0;
#line 85
    while (j < n___0) {
#line 86
      tmp = match_pattern((char const   *)*(groups_byname + i), (char const   *)*(groups + j));
#line 86
      if (tmp) {
#line 87
        return (1);
      }
#line 85
      j ++;
    }
#line 84
    i ++;
  }
#line 88
  return (0);
}
}
#line 95 "groupaccess.c"
int ga_match_pattern_list(char const   *group_pattern ) 
{ int i ;
  int found ;
  size_t len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 98
  found = 0;
#line 99
  tmp = strlen(group_pattern);
#line 99
  len = tmp;
#line 101
  i = 0;
#line 101
  while (i < ngroups) {
#line 102
    tmp___0 = match_pattern_list((char const   *)*(groups_byname + i), group_pattern,
                                 len, 0);
#line 102
    switch (tmp___0) {
    case -1: 
#line 105
    return (0);
    case 0: 
    goto __Cont;
    case 1: 
#line 109
    found = 1;
    }
    __Cont: /* CIL Label */ 
#line 101
    i ++;
  }
#line 112
  return (found);
}
}
#line 118 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 123
  if (ngroups > 0) {
#line 124
    i = 0;
#line 124
    while (i < ngroups) {
#line 125
      xfree((void *)*(groups_byname + i));
#line 124
      i ++;
    }
#line 126
    ngroups = 0;
#line 127
    xfree((void *)groups_byname);
  }
#line 129
  return;
}
}
#line 1 "auth-skey.o"
#pragma merger(0,"./auth-skey.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-bsdauth.o"
#pragma merger(0,"./auth-bsdauth.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth2-hostbased.o"
#pragma merger(0,"./auth2-hostbased.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 119 "auth.h"
int hostbased_key_allowed(struct passwd *pw___0 , char const   *cuser , char *chost ,
                          Key *key ) ;
#line 49 "monitor_wrap.h"
int mm_hostbased_key_allowed(struct passwd *pw___0 , char *user , char *host , Key *key ) ;
#line 51
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) ;
#line 56 "auth2-hostbased.c"
static int userauth_hostbased(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___6 ;
  int tmp___13 ;
  u_int tmp___14 ;
  void *tmp___15 ;
  u_int tmp___16 ;
  void *tmp___17 ;

  {
#line 60
  key = (Key *)((void *)0);
#line 65
  authenticated = 0;
#line 67
  if (! authctxt___0->valid) {
#line 68
    debug2("userauth_hostbased: disabled because of invalid user");
#line 69
    return (0);
  }
#line 71
  tmp = packet_get_string(& alen);
#line 71
  pkalg = (char *)tmp;
#line 72
  tmp___0 = packet_get_string(& blen);
#line 72
  pkblob = (u_char *)tmp___0;
#line 73
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 73
  chost = (char *)tmp___1;
#line 74
  tmp___2 = packet_get_string((u_int *)((void *)0));
#line 74
  cuser = (char *)tmp___2;
#line 75
  tmp___3 = packet_get_string(& slen);
#line 75
  sig = (u_char *)tmp___3;
#line 77
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
#line 86
  pktype = key_type_from_name(pkalg);
#line 87
  if (pktype == 3) {
#line 89
    logit("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 93
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 94
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 95
    error("userauth_hostbased: cannot decode key: %s", pkalg);
    goto done;
  }
#line 98
  if (key->type != pktype) {
#line 99
    error("userauth_hostbased: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 103
  if (datafellows & 65536) {
#line 103
    service = (char *)"ssh-userauth";
  } else {
#line 103
    service = authctxt___0->service;
  }
#line 105
  buffer_init(& b);
#line 106
  buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
#line 108
  buffer_put_char(& b, 50);
#line 109
  buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 110
  buffer_put_cstring(& b, (char const   *)service);
#line 111
  buffer_put_cstring(& b, "hostbased");
#line 112
  buffer_put_string(& b, (void const   *)pkalg, alen);
#line 113
  buffer_put_string(& b, (void const   *)pkblob, blen);
#line 114
  buffer_put_cstring(& b, (char const   *)chost);
#line 115
  buffer_put_cstring(& b, (char const   *)cuser);
#line 120
  authenticated = 0;
#line 121
  if (use_privsep) {
#line 121
    tmp___6 = mm_hostbased_key_allowed(authctxt___0->pw, cuser, chost, key);
  } else {
#line 121
    tmp___6 = hostbased_key_allowed(authctxt___0->pw, (char const   *)cuser, chost,
                                    key);
  }
#line 121
  if (tmp___6) {
#line 121
    if (use_privsep) {
#line 121
      tmp___14 = buffer_len(& b);
#line 121
      tmp___15 = buffer_ptr(& b);
#line 121
      tmp___13 = mm_key_verify(key, sig, slen, (u_char *)tmp___15, tmp___14);
    } else {
#line 121
      tmp___16 = buffer_len(& b);
#line 121
      tmp___17 = buffer_ptr(& b);
#line 121
      tmp___13 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___17,
                            tmp___16);
    }
#line 121
    if (tmp___13 == 1) {
#line 124
      authenticated = 1;
    }
  }
#line 126
  buffer_free(& b);
  done: 
#line 128
  debug2("userauth_hostbased: authenticated %d", authenticated);
#line 129
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 130
    key_free(key);
  }
#line 131
  xfree((void *)pkalg);
#line 132
  xfree((void *)pkblob);
#line 133
  xfree((void *)cuser);
#line 134
  xfree((void *)chost);
#line 135
  xfree((void *)sig);
#line 136
  return (authenticated);
}
}
#line 140 "auth2-hostbased.c"
int hostbased_key_allowed(struct passwd *pw___0 , char const   *cuser , char *chost ,
                          Key *key ) 
{ char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  HostStatus host_status ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 148
  resolvedname = get_canonical_hostname(options.use_dns);
#line 149
  ipaddr = get_remote_ipaddr();
#line 151
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
#line 154
  tmp = strlen((char const   *)chost);
#line 154
  len = (int )tmp;
#line 154
  if (len > 0) {
#line 154
    if ((int )*(chost + (len - 1)) == 46) {
#line 155
      debug2("stripping trailing dot from chost %s", chost);
#line 156
      *(chost + (len - 1)) = (char )'\000';
    }
  }
#line 159
  if (options.hostbased_uses_name_from_packet_only) {
#line 160
    tmp___0 = auth_rhosts2(pw___0, cuser, (char const   *)chost, (char const   *)chost);
#line 160
    if (tmp___0 == 0) {
#line 161
      return (0);
    }
#line 162
    lookup = (char const   *)chost;
  } else {
#line 164
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
#line 164
    if (tmp___1 != 0) {
#line 165
      logit("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
            chost, ipaddr, resolvedname);
    }
#line 168
    tmp___2 = auth_rhosts2(pw___0, cuser, resolvedname, ipaddr);
#line 168
    if (tmp___2 == 0) {
#line 169
      return (0);
    }
#line 170
    lookup = resolvedname;
  }
#line 172
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
#line 174
  if (options.ignore_user_known_hosts) {
#line 174
    tmp___3 = (char const   *)((void *)0);
  } else {
#line 174
    tmp___3 = "~/.ssh/known_hosts";
  }
#line 174
  host_status = check_key_in_hostfiles(pw___0, key, lookup, "/usr/local/etc/ssh_known_hosts",
                                       tmp___3);
#line 179
  if ((int )host_status == 1) {
#line 180
    if (options.ignore_user_known_hosts) {
#line 180
      tmp___4 = (char const   *)((void *)0);
    } else {
#line 180
      tmp___4 = "~/.ssh/known_hosts2";
    }
#line 180
    host_status = check_key_in_hostfiles(pw___0, key, lookup, "/usr/local/etc/ssh_known_hosts2",
                                         tmp___4);
  }
#line 185
  return ((int )host_status == 0);
}
}
#line 188 "auth2-hostbased.c"
Authmethod method_hostbased  =    {(char *)"hostbased", & userauth_hostbased, & options.hostbased_authentication};
#line 1 "auth2-kbdint.o"
#pragma merger(0,"./auth2-kbdint.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 44 "auth2-kbdint.c"
static int userauth_kbdint(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 47
  authenticated = 0;
#line 50
  tmp = packet_get_string((u_int *)((void *)0));
#line 50
  lang = (char *)tmp;
#line 51
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 51
  devs = (char *)tmp___0;
#line 52
  while (1) {
#line 52
    tmp___1 = packet_remaining();
#line 52
    _len = tmp___1;
#line 52
    if (_len > 0) {
#line 52
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-kbdint.c",
            52);
#line 52
      packet_disconnect("Packet integrity error.");
    }
#line 52
    break;
  }
#line 54
  debug("keyboard-interactive devs %s", devs);
#line 56
  if (options.challenge_response_authentication) {
#line 57
    authenticated = auth2_challenge(authctxt___0, devs);
  }
#line 59
  xfree((void *)devs);
#line 60
  xfree((void *)lang);
#line 65
  return (authenticated);
}
}
#line 68 "auth2-kbdint.c"
Authmethod method_kbdint  =    {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication};
#line 1 "auth2-none.o"
#pragma merger(0,"./auth2-none.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 57 "auth2-none.c"
static int none_enabled  =    1;
#line 59 "auth2-none.c"
static int userauth_none(Authctxt *authctxt___0 ) 
{ int _len ;
  int tmp ;
  int tmp___2 ;

  {
#line 62
  none_enabled = 0;
#line 63
  while (1) {
#line 63
    tmp = packet_remaining();
#line 63
    _len = tmp;
#line 63
    if (_len > 0) {
#line 63
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-none.c",
            63);
#line 63
      packet_disconnect("Packet integrity error.");
    }
#line 63
    break;
  }
#line 68
  if (options.password_authentication) {
#line 69
    if (use_privsep) {
#line 69
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 69
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 69
    return (tmp___2);
  }
#line 70
  return (0);
}
}
#line 73 "auth2-none.c"
Authmethod method_none  =    {(char *)"none", & userauth_none, & none_enabled};
#line 1 "auth2-passwd.o"
#pragma merger(0,"./auth2-passwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "auth2-passwd.c"
static int userauth_passwd(Authctxt *authctxt___0 ) 
{ char *password ;
  char *newpass ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int newlen ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___5 ;

  {
#line 53
  authenticated = 0;
#line 57
  tmp = packet_get_char();
#line 57
  change = (int )tmp;
#line 58
  tmp___0 = packet_get_string(& len);
#line 58
  password = (char *)tmp___0;
#line 59
  if (change) {
#line 61
    tmp___1 = packet_get_string(& newlen);
#line 61
    newpass = (char *)tmp___1;
#line 62
    memset((void *)newpass, 0, newlen);
#line 63
    xfree((void *)newpass);
  }
#line 65
  while (1) {
#line 65
    tmp___2 = packet_remaining();
#line 65
    _len = tmp___2;
#line 65
    if (_len > 0) {
#line 65
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-passwd.c",
            65);
#line 65
      packet_disconnect("Packet integrity error.");
    }
#line 65
    break;
  }
#line 67
  if (change) {
#line 68
    logit("password change not supported");
  } else {
#line 69
    if (use_privsep) {
#line 69
      tmp___5 = mm_auth_password(authctxt___0, password);
    } else {
#line 69
      tmp___5 = auth_password(authctxt___0, (char const   *)password);
    }
#line 69
    if (tmp___5 == 1) {
#line 70
      authenticated = 1;
    }
  }
#line 75
  memset((void *)password, 0, len);
#line 76
  xfree((void *)password);
#line 77
  return (authenticated);
}
}
#line 80 "auth2-passwd.c"
Authmethod method_passwd  =    {(char *)"password", & userauth_passwd, & options.password_authentication};
#line 1 "auth2-pubkey.o"
#pragma merger(0,"./auth2-pubkey.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 120 "auth.h"
int user_key_allowed(struct passwd *pw___0 , Key *key ) ;
#line 48 "monitor_wrap.h"
int mm_user_key_allowed(struct passwd *pw___0 , Key *key ) ;
#line 63 "auth2-pubkey.c"
static int userauth_pubkey(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int _len ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___9 ;
  int tmp___16 ;
  u_int tmp___17 ;
  void *tmp___18 ;
  u_int tmp___19 ;
  void *tmp___20 ;
  int _len___0 ;
  int tmp___21 ;
  int tmp___24 ;

  {
#line 67
  key = (Key *)((void *)0);
#line 72
  authenticated = 0;
#line 74
  if (! authctxt___0->valid) {
#line 75
    debug2("userauth_pubkey: disabled because of invalid user");
#line 76
    return (0);
  }
#line 78
  tmp = packet_get_char();
#line 78
  have_sig = (int )tmp;
#line 79
  if (datafellows & 32) {
#line 80
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 82
    tmp___0 = packet_get_string(& blen);
#line 82
    pkblob = (u_char *)tmp___0;
#line 83
    buffer_init(& b);
#line 84
    buffer_append(& b, (void const   *)pkblob, blen);
#line 86
    tmp___1 = buffer_get_string(& b, & alen);
#line 86
    pkalg = (char *)tmp___1;
#line 87
    buffer_free(& b);
  } else {
#line 89
    tmp___2 = packet_get_string(& alen);
#line 89
    pkalg = (char *)tmp___2;
#line 90
    tmp___3 = packet_get_string(& blen);
#line 90
    pkblob = (u_char *)tmp___3;
  }
#line 92
  pktype = key_type_from_name(pkalg);
#line 93
  if (pktype == 3) {
#line 95
    logit("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 99
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 100
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 101
    error("userauth_pubkey: cannot decode key: %s", pkalg);
    goto done;
  }
#line 104
  if (key->type != pktype) {
#line 105
    error("userauth_pubkey: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 109
  if (have_sig) {
#line 110
    tmp___4 = packet_get_string(& slen);
#line 110
    sig = (u_char *)tmp___4;
#line 111
    while (1) {
#line 111
      tmp___5 = packet_remaining();
#line 111
      _len = tmp___5;
#line 111
      if (_len > 0) {
#line 111
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-pubkey.c",
              111);
#line 111
        packet_disconnect("Packet integrity error.");
      }
#line 111
      break;
    }
#line 112
    buffer_init(& b);
#line 113
    if (datafellows & 16) {
#line 114
      buffer_append(& b, (void const   *)session_id2, session_id2_len);
    } else {
#line 116
      buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
    }
#line 119
    buffer_put_char(& b, 50);
#line 120
    buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 121
    if (datafellows & 2) {
#line 121
      tmp___6 = "ssh-userauth";
    } else {
#line 121
      tmp___6 = (char const   *)authctxt___0->service;
    }
#line 121
    buffer_put_cstring(& b, tmp___6);
#line 125
    if (datafellows & 32) {
#line 126
      buffer_put_char(& b, have_sig);
    } else {
#line 128
      buffer_put_cstring(& b, "publickey");
#line 129
      buffer_put_char(& b, have_sig);
#line 130
      buffer_put_cstring(& b, (char const   *)pkalg);
    }
#line 132
    buffer_put_string(& b, (void const   *)pkblob, blen);
#line 137
    authenticated = 0;
#line 138
    if (use_privsep) {
#line 138
      tmp___9 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 138
      tmp___9 = user_key_allowed(authctxt___0->pw, key);
    }
#line 138
    if (tmp___9) {
#line 138
      if (use_privsep) {
#line 138
        tmp___17 = buffer_len(& b);
#line 138
        tmp___18 = buffer_ptr(& b);
#line 138
        tmp___16 = mm_key_verify(key, sig, slen, (u_char *)tmp___18, tmp___17);
      } else {
#line 138
        tmp___19 = buffer_len(& b);
#line 138
        tmp___20 = buffer_ptr(& b);
#line 138
        tmp___16 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___20,
                              tmp___19);
      }
#line 138
      if (tmp___16 == 1) {
#line 141
        authenticated = 1;
      }
    }
#line 142
    buffer_free(& b);
#line 143
    xfree((void *)sig);
  } else {
#line 145
    debug("test whether pkalg/pkblob are acceptable");
#line 146
    while (1) {
#line 146
      tmp___21 = packet_remaining();
#line 146
      _len___0 = tmp___21;
#line 146
      if (_len___0 > 0) {
#line 146
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2-pubkey.c",
              146);
#line 146
        packet_disconnect("Packet integrity error.");
      }
#line 146
      break;
    }
#line 156
    if (use_privsep) {
#line 156
      tmp___24 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 156
      tmp___24 = user_key_allowed(authctxt___0->pw, key);
    }
#line 156
    if (tmp___24) {
#line 157
      packet_start((unsigned char)60);
#line 158
      packet_put_string((void const   *)pkalg, alen);
#line 159
      packet_put_string((void const   *)pkblob, blen);
#line 160
      packet_send();
#line 161
      packet_write_wait();
#line 162
      authctxt___0->postponed = 1;
    }
  }
#line 165
  if (authenticated != 1) {
#line 166
    auth_clear_options();
  }
  done: 
#line 168
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 169
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 170
    key_free(key);
  }
#line 171
  xfree((void *)pkalg);
#line 172
  xfree((void *)pkblob);
#line 177
  return (authenticated);
}
}
#line 181 "auth2-pubkey.c"
static int user_key_allowed2(struct passwd *pw___0 , Key *key , char *file___0 ) 
{ char line[8192] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  Key *found ;
  char *fp ;
  char *cp ;
  char *key_options ;
  int quoted ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 185
  found_key = 0;
#line 187
  linenum = (u_long )0;
#line 192
  temporarily_use_uid(pw___0);
#line 194
  debug("trying public key file %s", file___0);
#line 195
  f = auth_openkeyfile((char const   *)file___0, pw___0, options.strict_modes);
#line 197
  if (! f) {
#line 198
    restore_uid();
#line 199
    return (0);
  }
#line 202
  found_key = 0;
#line 203
  found = key_new(key->type);
#line 205
  while (1) {
#line 205
    tmp___4 = read_keyfile_line(f, (char const   *)file___0, line, sizeof(line), & linenum);
#line 205
    if (! (tmp___4 != -1)) {
#line 205
      break;
    }
#line 206
    key_options = (char *)((void *)0);
#line 209
    cp = line;
#line 209
    while (1) {
#line 209
      if (! ((int )*cp == 32)) {
#line 209
        if (! ((int )*cp == 9)) {
#line 209
          break;
        }
      }
#line 209
      cp ++;
    }
#line 211
    if (! *cp) {
#line 212
      continue;
    } else {
#line 211
      if ((int )*cp == 10) {
#line 212
        continue;
      } else {
#line 211
        if ((int )*cp == 35) {
#line 212
          continue;
        }
      }
    }
#line 214
    tmp___0 = key_read(found, & cp);
#line 214
    if (tmp___0 != 1) {
#line 216
      quoted = 0;
#line 217
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 218
      key_options = cp;
#line 219
      while (1) {
#line 219
        if (*cp) {
#line 219
          if (! quoted) {
#line 219
            if ((int )*cp != 32) {
#line 219
              if (! ((int )*cp != 9)) {
#line 219
                break;
              }
            } else {
#line 219
              break;
            }
          }
        } else {
#line 219
          break;
        }
#line 220
        if ((int )*cp == 92) {
#line 220
          if ((int )*(cp + 1) == 34) {
#line 221
            cp ++;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 222
          if ((int )*cp == 34) {
#line 223
            quoted = ! quoted;
          }
        }
#line 219
        cp ++;
      }
#line 226
      while (1) {
#line 226
        if (! ((int )*cp == 32)) {
#line 226
          if (! ((int )*cp == 9)) {
#line 226
            break;
          }
        }
#line 226
        cp ++;
      }
#line 228
      tmp = key_read(found, & cp);
#line 228
      if (tmp != 1) {
#line 229
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 231
        continue;
      }
    }
#line 234
    tmp___2 = key_equal((Key const   *)found, (Key const   *)key);
#line 234
    if (tmp___2) {
#line 234
      tmp___3 = auth_parse_options(pw___0, key_options, file___0, linenum);
#line 234
      if (tmp___3 == 1) {
#line 236
        found_key = 1;
#line 237
        debug("matching key found: file %s, line %lu", file___0, linenum);
#line 239
        fp = key_fingerprint((Key const   *)found, 1, 0);
#line 240
        tmp___1 = key_type((Key const   *)found);
#line 240
        verbose("Found matching %s key: %s", tmp___1, fp);
#line 242
        xfree((void *)fp);
#line 243
        break;
      }
    }
  }
#line 246
  restore_uid();
#line 247
  fclose(f);
#line 248
  key_free(found);
#line 249
  if (! found_key) {
#line 250
    debug2("key not found");
  }
#line 251
  return (found_key);
}
}
#line 255 "auth2-pubkey.c"
int user_key_allowed(struct passwd *pw___0 , Key *key ) 
{ int success ;
  char *file___0 ;

  {
#line 261
  file___0 = authorized_keys_file(pw___0);
#line 262
  success = user_key_allowed2(pw___0, key, file___0);
#line 263
  xfree((void *)file___0);
#line 264
  if (success) {
#line 265
    return (success);
  }
#line 268
  file___0 = authorized_keys_file2(pw___0);
#line 269
  success = user_key_allowed2(pw___0, key, file___0);
#line 270
  xfree((void *)file___0);
#line 271
  return (success);
}
}
#line 274 "auth2-pubkey.c"
Authmethod method_pubkey  =    {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication};
#line 1 "auth2-jpake.o"
#pragma merger(0,"./auth2-jpake.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "monitor_mm.o"
#pragma merger(0,"./monitor_mm.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 77 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 46 "monitor_mm.h"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) ;
#line 46
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) ;
#line 46
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) ;
#line 46
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) ;
#line 46
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) ;
#line 46
struct mm_share *mmtree_RB_NEXT(struct mm_share *elm ) ;
#line 46
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) ;
#line 52
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) ;
#line 53
void mm_destroy(struct mm_master *mm ) ;
#line 55
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) ;
#line 57
void *mm_malloc(struct mm_master *mm , size_t size ) ;
#line 58
void *mm_xmalloc(struct mm_master *mm , size_t size ) ;
#line 59
void mm_free(struct mm_master *mm , void *address ) ;
#line 61
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) ;
#line 45 "monitor_mm.c"
static int mm_compare(struct mm_share *a___0 , struct mm_share *b ) 
{ long diff ;

  {
#line 48
  diff = (long )((char *)a___0->address - (char *)b->address);
#line 50
  if (diff == 0L) {
#line 51
    return (0);
  } else {
#line 52
    if (diff < 0L) {
#line 53
      return (-1);
    } else {
#line 55
      return (1);
    }
  }
}
}
#line 58 "monitor_mm.c"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *parent ;
  struct mm_share *gparent ;
  struct mm_share *tmp ;

  {
#line 58
  while (1) {
#line 58
    parent = elm->next.rbe_parent;
#line 58
    if (parent) {
#line 58
      if (! (parent->next.rbe_color == 1)) {
#line 58
        break;
      }
    } else {
#line 58
      break;
    }
#line 58
    gparent = parent->next.rbe_parent;
#line 58
    if ((unsigned int )parent == (unsigned int )gparent->next.rbe_left) {
#line 58
      tmp = gparent->next.rbe_right;
#line 58
      if (tmp) {
#line 58
        if (tmp->next.rbe_color == 1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          while (1) {
#line 58
            parent->next.rbe_color = 0;
#line 58
            gparent->next.rbe_color = 1;
#line 58
            break;
          }
#line 58
          elm = gparent;
#line 58
          continue;
        }
      }
#line 58
      if ((unsigned int )parent->next.rbe_right == (unsigned int )elm) {
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_right;
#line 58
          parent->next.rbe_right = tmp->next.rbe_left;
#line 58
          if (parent->next.rbe_right) {
#line 58
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_left = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent;
#line 58
        parent = elm;
#line 58
        elm = tmp;
      }
#line 58
      while (1) {
#line 58
        parent->next.rbe_color = 0;
#line 58
        gparent->next.rbe_color = 1;
#line 58
        break;
      }
#line 58
      while (1) {
#line 58
        tmp = gparent->next.rbe_left;
#line 58
        gparent->next.rbe_left = tmp->next.rbe_right;
#line 58
        if (gparent->next.rbe_left) {
#line 58
          (tmp->next.rbe_right)->next.rbe_parent = gparent;
        }
#line 58
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 58
        if (tmp->next.rbe_parent) {
#line 58
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 58
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 58
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 58
          head->rbh_root = tmp;
        }
#line 58
        tmp->next.rbe_right = gparent;
#line 58
        gparent->next.rbe_parent = tmp;
#line 58
        if (tmp->next.rbe_parent) {

        }
#line 58
        break;
      }
    } else {
#line 58
      tmp = gparent->next.rbe_left;
#line 58
      if (tmp) {
#line 58
        if (tmp->next.rbe_color == 1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          while (1) {
#line 58
            parent->next.rbe_color = 0;
#line 58
            gparent->next.rbe_color = 1;
#line 58
            break;
          }
#line 58
          elm = gparent;
#line 58
          continue;
        }
      }
#line 58
      if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_left;
#line 58
          parent->next.rbe_left = tmp->next.rbe_right;
#line 58
          if (parent->next.rbe_left) {
#line 58
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_right = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent;
#line 58
        parent = elm;
#line 58
        elm = tmp;
      }
#line 58
      while (1) {
#line 58
        parent->next.rbe_color = 0;
#line 58
        gparent->next.rbe_color = 1;
#line 58
        break;
      }
#line 58
      while (1) {
#line 58
        tmp = gparent->next.rbe_right;
#line 58
        gparent->next.rbe_right = tmp->next.rbe_left;
#line 58
        if (gparent->next.rbe_right) {
#line 58
          (tmp->next.rbe_left)->next.rbe_parent = gparent;
        }
#line 58
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 58
        if (tmp->next.rbe_parent) {
#line 58
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 58
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 58
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 58
          head->rbh_root = tmp;
        }
#line 58
        tmp->next.rbe_left = gparent;
#line 58
        gparent->next.rbe_parent = tmp;
#line 58
        if (tmp->next.rbe_parent) {

        }
#line 58
        break;
      }
    }
  }
#line 58
  (head->rbh_root)->next.rbe_color = 0;
#line 58
  return;
}
}
#line 58 "monitor_mm.c"
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *oleft ;
  struct mm_share *oright ;

  {
#line 58
  while (1) {
#line 58
    if ((unsigned int )elm == (unsigned int )((void *)0)) {
      goto _L___5;
    } else {
#line 58
      if (elm->next.rbe_color == 0) {
        _L___5: /* CIL Label */ 
#line 58
        if (! ((unsigned int )elm != (unsigned int )head->rbh_root)) {
#line 58
          break;
        }
      } else {
#line 58
        break;
      }
    }
#line 58
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
      tmp = parent->next.rbe_right;
#line 58
      if (tmp->next.rbe_color == 1) {
#line 58
        while (1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          parent->next.rbe_color = 1;
#line 58
          break;
        }
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_right;
#line 58
          parent->next.rbe_right = tmp->next.rbe_left;
#line 58
          if (parent->next.rbe_right) {
#line 58
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_left = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent->next.rbe_right;
      }
#line 58
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___1;
      } else {
#line 58
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___1: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 58
            tmp->next.rbe_color = 1;
#line 58
            elm = parent;
#line 58
            parent = elm->next.rbe_parent;
          } else {
#line 58
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 58
              tmp->next.rbe_color = 1;
#line 58
              elm = parent;
#line 58
              parent = elm->next.rbe_parent;
            } else {
              goto _L___0;
            }
          }
        } else {
          _L___0: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
            goto _L;
          } else {
#line 58
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
              _L: /* CIL Label */ 
#line 58
              oleft = tmp->next.rbe_left;
#line 58
              if (oleft) {
#line 58
                oleft->next.rbe_color = 0;
              }
#line 58
              tmp->next.rbe_color = 1;
#line 58
              while (1) {
#line 58
                oleft = tmp->next.rbe_left;
#line 58
                tmp->next.rbe_left = oleft->next.rbe_right;
#line 58
                if (tmp->next.rbe_left) {
#line 58
                  (oleft->next.rbe_right)->next.rbe_parent = tmp;
                }
#line 58
                oleft->next.rbe_parent = tmp->next.rbe_parent;
#line 58
                if (oleft->next.rbe_parent) {
#line 58
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_left = oleft;
                  } else {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_right = oleft;
                  }
                } else {
#line 58
                  head->rbh_root = oleft;
                }
#line 58
                oleft->next.rbe_right = tmp;
#line 58
                tmp->next.rbe_parent = oleft;
#line 58
                if (oleft->next.rbe_parent) {

                }
#line 58
                break;
              }
#line 58
              tmp = parent->next.rbe_right;
            }
          }
#line 58
          tmp->next.rbe_color = parent->next.rbe_color;
#line 58
          parent->next.rbe_color = 0;
#line 58
          if (tmp->next.rbe_right) {
#line 58
            (tmp->next.rbe_right)->next.rbe_color = 0;
          }
#line 58
          while (1) {
#line 58
            tmp = parent->next.rbe_right;
#line 58
            parent->next.rbe_right = tmp->next.rbe_left;
#line 58
            if (parent->next.rbe_right) {
#line 58
              (tmp->next.rbe_left)->next.rbe_parent = parent;
            }
#line 58
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
            if (tmp->next.rbe_parent) {
#line 58
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 58
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 58
              head->rbh_root = tmp;
            }
#line 58
            tmp->next.rbe_left = parent;
#line 58
            parent->next.rbe_parent = tmp;
#line 58
            if (tmp->next.rbe_parent) {

            }
#line 58
            break;
          }
#line 58
          elm = head->rbh_root;
#line 58
          break;
        }
      }
    } else {
#line 58
      tmp = parent->next.rbe_left;
#line 58
      if (tmp->next.rbe_color == 1) {
#line 58
        while (1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          parent->next.rbe_color = 1;
#line 58
          break;
        }
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_left;
#line 58
          parent->next.rbe_left = tmp->next.rbe_right;
#line 58
          if (parent->next.rbe_left) {
#line 58
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_right = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent->next.rbe_left;
      }
#line 58
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___4;
      } else {
#line 58
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___4: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 58
            tmp->next.rbe_color = 1;
#line 58
            elm = parent;
#line 58
            parent = elm->next.rbe_parent;
          } else {
#line 58
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 58
              tmp->next.rbe_color = 1;
#line 58
              elm = parent;
#line 58
              parent = elm->next.rbe_parent;
            } else {
              goto _L___3;
            }
          }
        } else {
          _L___3: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
            goto _L___2;
          } else {
#line 58
            if ((tmp->next.rbe_left)->next.rbe_color == 0) {
              _L___2: /* CIL Label */ 
#line 58
              oright = tmp->next.rbe_right;
#line 58
              if (oright) {
#line 58
                oright->next.rbe_color = 0;
              }
#line 58
              tmp->next.rbe_color = 1;
#line 58
              while (1) {
#line 58
                oright = tmp->next.rbe_right;
#line 58
                tmp->next.rbe_right = oright->next.rbe_left;
#line 58
                if (tmp->next.rbe_right) {
#line 58
                  (oright->next.rbe_left)->next.rbe_parent = tmp;
                }
#line 58
                oright->next.rbe_parent = tmp->next.rbe_parent;
#line 58
                if (oright->next.rbe_parent) {
#line 58
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_left = oright;
                  } else {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_right = oright;
                  }
                } else {
#line 58
                  head->rbh_root = oright;
                }
#line 58
                oright->next.rbe_left = tmp;
#line 58
                tmp->next.rbe_parent = oright;
#line 58
                if (oright->next.rbe_parent) {

                }
#line 58
                break;
              }
#line 58
              tmp = parent->next.rbe_left;
            }
          }
#line 58
          tmp->next.rbe_color = parent->next.rbe_color;
#line 58
          parent->next.rbe_color = 0;
#line 58
          if (tmp->next.rbe_left) {
#line 58
            (tmp->next.rbe_left)->next.rbe_color = 0;
          }
#line 58
          while (1) {
#line 58
            tmp = parent->next.rbe_left;
#line 58
            parent->next.rbe_left = tmp->next.rbe_right;
#line 58
            if (parent->next.rbe_left) {
#line 58
              (tmp->next.rbe_right)->next.rbe_parent = parent;
            }
#line 58
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
            if (tmp->next.rbe_parent) {
#line 58
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 58
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 58
              head->rbh_root = tmp;
            }
#line 58
            tmp->next.rbe_right = parent;
#line 58
            parent->next.rbe_parent = tmp;
#line 58
            if (tmp->next.rbe_parent) {

            }
#line 58
            break;
          }
#line 58
          elm = head->rbh_root;
#line 58
          break;
        }
      }
    }
  }
#line 58
  if (elm) {
#line 58
    elm->next.rbe_color = 0;
  }
#line 58
  return;
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *child ;
  struct mm_share *parent ;
  struct mm_share *old ;
  int color ;
  struct mm_share *left ;

  {
#line 58
  old = elm;
#line 58
  if ((unsigned int )elm->next.rbe_left == (unsigned int )((void *)0)) {
#line 58
    child = elm->next.rbe_right;
  } else {
#line 58
    if ((unsigned int )elm->next.rbe_right == (unsigned int )((void *)0)) {
#line 58
      child = elm->next.rbe_left;
    } else {
#line 58
      elm = elm->next.rbe_right;
#line 58
      while (1) {
#line 58
        left = elm->next.rbe_left;
#line 58
        if (! left) {
#line 58
          break;
        }
#line 58
        elm = left;
      }
#line 58
      child = elm->next.rbe_right;
#line 58
      parent = elm->next.rbe_parent;
#line 58
      color = elm->next.rbe_color;
#line 58
      if (child) {
#line 58
        child->next.rbe_parent = parent;
      }
#line 58
      if (parent) {
#line 58
        if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
          parent->next.rbe_left = child;
        } else {
#line 58
          parent->next.rbe_right = child;
        }
      } else {
#line 58
        head->rbh_root = child;
      }
#line 58
      if ((unsigned int )elm->next.rbe_parent == (unsigned int )old) {
#line 58
        parent = elm;
      }
#line 58
      elm->next = old->next;
#line 58
      if (old->next.rbe_parent) {
#line 58
        if ((unsigned int )(old->next.rbe_parent)->next.rbe_left == (unsigned int )old) {
#line 58
          (old->next.rbe_parent)->next.rbe_left = elm;
        } else {
#line 58
          (old->next.rbe_parent)->next.rbe_right = elm;
        }
      } else {
#line 58
        head->rbh_root = elm;
      }
#line 58
      (old->next.rbe_left)->next.rbe_parent = elm;
#line 58
      if (old->next.rbe_right) {
#line 58
        (old->next.rbe_right)->next.rbe_parent = elm;
      }
#line 58
      if (parent) {
#line 58
        left = parent;
#line 58
        while (1) {
#line 58
          left = left->next.rbe_parent;
#line 58
          if (! left) {
#line 58
            break;
          }
        }
      }
      goto color;
    }
  }
#line 58
  parent = elm->next.rbe_parent;
#line 58
  color = elm->next.rbe_color;
#line 58
  if (child) {
#line 58
    child->next.rbe_parent = parent;
  }
#line 58
  if (parent) {
#line 58
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
      parent->next.rbe_left = child;
    } else {
#line 58
      parent->next.rbe_right = child;
    }
  } else {
#line 58
    head->rbh_root = child;
  }
  color: 
#line 58
  if (color == 0) {
#line 58
    mmtree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 58
  return (old);
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;
  int comp ;

  {
#line 58
  parent = (struct mm_share *)((void *)0);
#line 58
  comp = 0;
#line 58
  tmp = head->rbh_root;
#line 58
  while (tmp) {
#line 58
    parent = tmp;
#line 58
    comp = mm_compare(elm, parent);
#line 58
    if (comp < 0) {
#line 58
      tmp = tmp->next.rbe_left;
    } else {
#line 58
      if (comp > 0) {
#line 58
        tmp = tmp->next.rbe_right;
      } else {
#line 58
        return (tmp);
      }
    }
  }
#line 58
  while (1) {
#line 58
    elm->next.rbe_parent = parent;
#line 58
    elm->next.rbe_right = (struct mm_share *)((void *)0);
#line 58
    elm->next.rbe_left = elm->next.rbe_right;
#line 58
    elm->next.rbe_color = 1;
#line 58
    break;
  }
#line 58
  if ((unsigned int )parent != (unsigned int )((void *)0)) {
#line 58
    if (comp < 0) {
#line 58
      parent->next.rbe_left = elm;
    } else {
#line 58
      parent->next.rbe_right = elm;
    }
  } else {
#line 58
    head->rbh_root = elm;
  }
#line 58
  mmtree_RB_INSERT_COLOR(head, elm);
#line 58
  return ((struct mm_share *)((void *)0));
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  int comp ;

  {
#line 58
  tmp = head->rbh_root;
#line 58
  while (tmp) {
#line 58
    comp = mm_compare(elm, tmp);
#line 58
    if (comp < 0) {
#line 58
      tmp = tmp->next.rbe_left;
    } else {
#line 58
      if (comp > 0) {
#line 58
        tmp = tmp->next.rbe_right;
      } else {
#line 58
        return (tmp);
      }
    }
  }
#line 58
  return ((struct mm_share *)((void *)0));
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_NEXT(struct mm_share *elm ) 
{ 

  {
#line 58
  if (elm->next.rbe_right) {
#line 58
    elm = elm->next.rbe_right;
#line 58
    while (elm->next.rbe_left) {
#line 58
      elm = elm->next.rbe_left;
    }
  } else {
#line 58
    if (elm->next.rbe_parent) {
#line 58
      if ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_left) {
#line 58
        elm = elm->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 58
      while (1) {
#line 58
        if (elm->next.rbe_parent) {
#line 58
          if (! ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_right)) {
#line 58
            break;
          }
        } else {
#line 58
          break;
        }
#line 58
        elm = elm->next.rbe_parent;
      }
#line 58
      elm = elm->next.rbe_parent;
    }
  }
#line 58
  return (elm);
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;

  {
#line 58
  tmp = head->rbh_root;
#line 58
  parent = (struct mm_share *)((void *)0);
#line 58
  while (tmp) {
#line 58
    parent = tmp;
#line 58
    if (val < 0) {
#line 58
      tmp = tmp->next.rbe_left;
    } else {
#line 58
      tmp = tmp->next.rbe_right;
    }
  }
#line 58
  return (parent);
}
}
#line 60 "monitor_mm.c"
static struct mm_share *mm_make_entry(struct mm_master *mm , struct mmtree *head ,
                                      void *address , size_t size ) 
{ struct mm_share *tmp ;
  struct mm_share *tmp2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 66
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 67
    tmp___0 = xmalloc(sizeof(struct mm_share ));
#line 67
    tmp = (struct mm_share *)tmp___0;
  } else {
#line 69
    tmp___1 = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share ));
#line 69
    tmp = (struct mm_share *)tmp___1;
  }
#line 70
  tmp->address = address;
#line 71
  tmp->size = size;
#line 73
  tmp2 = mmtree_RB_INSERT(head, tmp);
#line 74
  if ((unsigned int )tmp2 != (unsigned int )((void *)0)) {
#line 75
    fatal("mm_make_entry(%p): double address %p->%p(%lu)", mm, tmp2, address, (unsigned long )size);
  }
#line 78
  return (tmp);
}
}
#line 83 "monitor_mm.c"
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) 
{ void *address ;
  struct mm_master *mm ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 89
  if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 90
    tmp = xmalloc(sizeof(struct mm_master ));
#line 90
    mm = (struct mm_master *)tmp;
  } else {
#line 92
    tmp___0 = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 92
    mm = (struct mm_master *)tmp___0;
  }
#line 99
  mm->mmalloc = mmalloc;
#line 101
  address = xmmap(size);
#line 102
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 103
    tmp___1 = __errno_location();
#line 103
    tmp___2 = strerror(*tmp___1);
#line 103
    fatal("mmap(%lu): %s", (unsigned long )size, tmp___2);
  }
#line 105
  mm->address = address;
#line 106
  mm->size = size;
#line 108
  while (1) {
#line 108
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 108
    break;
  }
#line 109
  while (1) {
#line 109
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 109
    break;
  }
#line 111
  mm_make_entry(mm, & mm->rb_free, address, size);
#line 113
  return (mm);
}
}
#line 118 "monitor_mm.c"
static void mm_freelist(struct mm_master *mmalloc , struct mmtree *head ) 
{ struct mm_share *mms ;
  struct mm_share *next ;

  {
#line 123
  mms = head->rbh_root;
#line 123
  while (mms) {
#line 124
    next = mmtree_RB_NEXT(mms);
#line 125
    mmtree_RB_REMOVE(head, mms);
#line 126
    if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 127
      xfree((void *)mms);
    } else {
#line 129
      mm_free(mmalloc, (void *)mms);
    }
#line 123
    mms = next;
  }
#line 131
  return;
}
}
#line 135 "monitor_mm.c"
void mm_destroy(struct mm_master *mm ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 138
  mm_freelist(mm->mmalloc, & mm->rb_free);
#line 139
  mm_freelist(mm->mmalloc, & mm->rb_allocated);
#line 142
  tmp___1 = munmap(mm->address, mm->size);
#line 142
  if (tmp___1 == -1) {
#line 143
    tmp = __errno_location();
#line 143
    tmp___0 = strerror(*tmp);
#line 143
    fatal("munmap(%p, %lu): %s", mm->address, (unsigned long )mm->size, tmp___0);
  }
#line 149
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 150
    xfree((void *)mm);
  } else {
#line 152
    mm_free(mm->mmalloc, (void *)mm);
  }
#line 153
  return;
}
}
#line 155 "monitor_mm.c"
void *mm_xmalloc(struct mm_master *mm , size_t size ) 
{ void *address ;

  {
#line 160
  address = mm_malloc(mm, size);
#line 161
  if ((unsigned int )address == (unsigned int )((void *)0)) {
#line 162
    fatal("%s: mm_malloc(%lu)", "mm_xmalloc", (unsigned long )size);
  }
#line 163
  return (address);
}
}
#line 169 "monitor_mm.c"
void *mm_malloc(struct mm_master *mm , size_t size ) 
{ struct mm_share *mms ;
  struct mm_share *tmp ;

  {
#line 174
  if (size == 0U) {
#line 175
    fatal("mm_malloc: try to allocate 0 space");
  }
#line 176
  if ((unsigned long )size > 4294967168UL) {
#line 177
    fatal("mm_malloc: size too big");
  }
#line 179
  size = ((size + 127U) / 128U) * 128U;
#line 181
  mms = mmtree_RB_MINMAX(& mm->rb_free, -1);
#line 181
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 182
    if (mms->size >= size) {
#line 183
      break;
    }
#line 181
    mms = mmtree_RB_NEXT(mms);
  }
#line 186
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 187
    return ((void *)0);
  }
#line 190
  memset(mms->address, 208, size);
#line 192
  tmp = mm_make_entry(mm, & mm->rb_allocated, mms->address, size);
#line 195
  mms->size -= size;
#line 196
  mms->address = (void *)((u_char *)mms->address + size);
#line 198
  if (mms->size == 0U) {
#line 199
    mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 200
    if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 201
      xfree((void *)mms);
    } else {
#line 203
      mm_free(mm->mmalloc, (void *)mms);
    }
  }
#line 206
  return (tmp->address);
}
}
#line 211 "monitor_mm.c"
void mm_free(struct mm_master *mm , void *address ) 
{ struct mm_share *mms ;
  struct mm_share *prev ;
  struct mm_share tmp ;
  struct mm_share *tmp___0 ;

  {
#line 216
  tmp.address = address;
#line 217
  mms = mmtree_RB_FIND(& mm->rb_allocated, & tmp);
#line 218
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 219
    fatal("mm_free(%p): can not find %p", mm, address);
  }
#line 222
  memset(mms->address, 208, mms->size);
#line 225
  mmtree_RB_REMOVE(& mm->rb_allocated, mms);
#line 226
  tmp___0 = mmtree_RB_INSERT(& mm->rb_free, mms);
#line 226
  if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 227
    fatal("mm_free(%p): double address %p", mm, address);
  }
#line 230
  prev = mms;
#line 231
  if (prev->next.rbe_left) {
#line 232
    prev = prev->next.rbe_left;
#line 233
    while (prev->next.rbe_right) {
#line 234
      prev = prev->next.rbe_right;
    }
  } else {
#line 236
    if (prev->next.rbe_parent) {
#line 236
      if ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_right) {
#line 238
        prev = prev->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 240
      while (1) {
#line 240
        if (prev->next.rbe_parent) {
#line 240
          if (! ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_left)) {
#line 240
            break;
          }
        } else {
#line 240
          break;
        }
#line 242
        prev = prev->next.rbe_parent;
      }
#line 243
      prev = prev->next.rbe_parent;
    }
  }
#line 248
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 248
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )address) {
#line 249
      fatal("mm_free: memory corruption: %p(%lu) > %p", prev->address, (unsigned long )prev->size,
            address);
    }
  }
#line 253
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 253
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) == (unsigned int )address) {
#line 254
      prev->size += mms->size;
#line 255
      mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 256
      if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 257
        xfree((void *)mms);
      } else {
#line 259
        mm_free(mm->mmalloc, (void *)mms);
      }
    } else {
#line 261
      prev = mms;
    }
  } else {
#line 261
    prev = mms;
  }
#line 263
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 264
    return;
  }
#line 267
  mms = mmtree_RB_NEXT(prev);
#line 268
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 269
    return;
  }
#line 271
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )mms->address) {
#line 272
    fatal("mm_free: memory corruption: %p < %p(%lu)", mms->address, prev->address,
          (unsigned long )prev->size);
  }
#line 274
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) != (unsigned int )mms->address) {
#line 275
    return;
  }
#line 277
  prev->size += mms->size;
#line 278
  mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 280
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 281
    xfree((void *)mms);
  } else {
#line 283
    mm_free(mm->mmalloc, (void *)mms);
  }
#line 284
  return;
}
}
#line 286 "monitor_mm.c"
static void mm_sync_list(struct mmtree *oldtree , struct mmtree *newtree , struct mm_master *mm ,
                         struct mm_master *mmold ) 
{ struct mm_master *mmalloc ;
  struct mm_share *mms ;
  struct mm_share *new ;
  void *tmp ;

  {
#line 290
  mmalloc = mm->mmalloc;
#line 294
  mms = mmtree_RB_MINMAX(oldtree, -1);
#line 294
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 296
    mm_memvalid(mmold, (void *)mms, sizeof(struct mm_share ));
#line 297
    mm_memvalid(mm, mms->address, mms->size);
#line 299
    tmp = mm_xmalloc(mmalloc, sizeof(struct mm_share ));
#line 299
    new = (struct mm_share *)tmp;
#line 300
    memcpy((void * __restrict  )new, (void const   * __restrict  )mms, sizeof(struct mm_share ));
#line 301
    mmtree_RB_INSERT(newtree, new);
#line 294
    mms = mmtree_RB_NEXT(mms);
  }
#line 303
  return;
}
}
#line 305 "monitor_mm.c"
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) 
{ struct mm_master *mm ;
  struct mm_master *mmalloc ;
  struct mm_master *mmold ;
  struct mmtree rb_free ;
  struct mmtree rb_allocated ;
  void *tmp ;

  {
#line 313
  debug3("%s: Share sync", "mm_share_sync");
#line 315
  mm = *pmm;
#line 316
  mmold = mm->mmalloc;
#line 317
  mm_memvalid(mmold, (void *)mm, sizeof(*mm));
#line 319
  mmalloc = mm_create((struct mm_master *)((void *)0), mm->size);
#line 320
  tmp = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 320
  mm = (struct mm_master *)tmp;
#line 321
  memcpy((void * __restrict  )mm, (void const   * __restrict  )*pmm, sizeof(struct mm_master ));
#line 322
  mm->mmalloc = mmalloc;
#line 324
  rb_free = mm->rb_free;
#line 325
  rb_allocated = mm->rb_allocated;
#line 327
  while (1) {
#line 327
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 327
    break;
  }
#line 328
  while (1) {
#line 328
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 328
    break;
  }
#line 330
  mm_sync_list(& rb_free, & mm->rb_free, mm, mmold);
#line 331
  mm_sync_list(& rb_allocated, & mm->rb_allocated, mm, mmold);
#line 333
  mm_destroy(mmold);
#line 335
  *pmm = mm;
#line 336
  *pmmalloc = mmalloc;
#line 338
  debug3("%s: Share sync end", "mm_share_sync");
#line 339
  return;
}
}
#line 341 "monitor_mm.c"
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) 
{ void *end ;

  {
#line 344
  end = (void *)((u_char *)address + size);
#line 346
  if ((unsigned int )address < (unsigned int )mm->address) {
#line 347
    fatal("mm_memvalid: address too small: %p", address);
  }
#line 348
  if ((unsigned int )end < (unsigned int )address) {
#line 349
    fatal("mm_memvalid: end < address: %p < %p", end, address);
  }
#line 350
  if ((unsigned int )end > (unsigned int )((void *)((u_char *)mm->address + mm->size))) {
#line 351
    fatal("mm_memvalid: address too large: %p", address);
  }
#line 352
  return;
}
}
#line 1 "monitor.o"
#pragma merger(0,"./monitor.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 90 "monitor.h"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) ;
#line 93
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 94
void mm_request_receive(int sock , Buffer *m___0 ) ;
#line 95
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 89 "monitor_wrap.h"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) ;
#line 93
void mm_get_keystate(struct monitor *pmonitor___0 ) ;
#line 126
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) ;
#line 127
void mm_zfree(struct mm_master *mm , void *address ) ;
#line 128
void mm_init_compression(struct mm_master *mm ) ;
#line 110 "monitor.c"
struct __anonstruct_child_state_83 child_state  ;
#line 133
int mm_answer_moduli(int sock , Buffer *m___0 ) ;
#line 134
int mm_answer_sign(int sock , Buffer *m___0 ) ;
#line 135
int mm_answer_pwnamallow(int sock , Buffer *m___0 ) ;
#line 136
int mm_answer_auth2_read_banner(int sock , Buffer *m___0 ) ;
#line 137
int mm_answer_authserv(int sock , Buffer *m___0 ) ;
#line 138
int mm_answer_authpassword(int sock , Buffer *m___0 ) ;
#line 143
int mm_answer_keyallowed(int sock , Buffer *m___0 ) ;
#line 144
int mm_answer_keyverify(int sock , Buffer *m___0 ) ;
#line 145
int mm_answer_pty(int sock , Buffer *m___0 ) ;
#line 146
int mm_answer_pty_cleanup(int sock , Buffer *m___0 ) ;
#line 147
int mm_answer_term(int sock , Buffer *req ) ;
#line 148
int mm_answer_rsa_keyallowed(int sock , Buffer *m___0 ) ;
#line 149
int mm_answer_rsa_challenge(int sock , Buffer *m___0 ) ;
#line 150
int mm_answer_rsa_response(int sock , Buffer *m___0 ) ;
#line 151
int mm_answer_sesskey(int sock , Buffer *m___0 ) ;
#line 152
int mm_answer_sessid(int sock , Buffer *m___0 ) ;
#line 180 "monitor.c"
static Authctxt *authctxt  ;
#line 181 "monitor.c"
static BIGNUM *ssh1_challenge  =    (BIGNUM *)((void *)0);
#line 184 "monitor.c"
static u_char *key_blob  =    (u_char *)((void *)0);
#line 185 "monitor.c"
static u_int key_bloblen  =    (u_int )0;
#line 186 "monitor.c"
static int key_blobtype  =    0;
#line 187 "monitor.c"
static char *hostbased_cuser  =    (char *)((void *)0);
#line 188 "monitor.c"
static char *hostbased_chost  =    (char *)((void *)0);
#line 189 "monitor.c"
static char *auth_method  =    (char *)"unknown";
#line 190 "monitor.c"
static u_int session_id2_len___0  =    (u_int )0;
#line 191 "monitor.c"
static u_char *session_id2___0  =    (u_char *)((void *)0);
#line 192 "monitor.c"
static pid_t monitor_child_pid  ;
#line 209 "monitor.c"
struct mon_table mon_dispatch_proto20[9]  = 
#line 209
  {      {0, 16, & mm_answer_moduli}, 
        {4, 16, & mm_answer_sign}, 
        {6, 16, & mm_answer_pwnamallow}, 
        {3, 16, & mm_answer_authserv}, 
        {8, 16, & mm_answer_auth2_read_banner}, 
        {10, 12, & mm_answer_authpassword}, 
        {20, 4, & mm_answer_keyallowed}, 
        {22, 12, & mm_answer_keyverify}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 253 "monitor.c"
struct mon_table mon_dispatch_postauth20[6]  = {      {0, 0, & mm_answer_moduli}, 
        {4, 0, & mm_answer_sign}, 
        {25, 0, & mm_answer_pty}, 
        {27, 0, & mm_answer_pty_cleanup}, 
        {58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 266 "monitor.c"
struct mon_table mon_dispatch_proto15[9]  = 
#line 266
  {      {6, 16, & mm_answer_pwnamallow}, 
        {28, 16, & mm_answer_sesskey}, 
        {30, 16, & mm_answer_sessid}, 
        {10, 12, & mm_answer_authpassword}, 
        {31, 36, & mm_answer_rsa_keyallowed}, 
        {20, 36, & mm_answer_keyallowed}, 
        {33, 16, & mm_answer_rsa_challenge}, 
        {35, 24, & mm_answer_rsa_response}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 297 "monitor.c"
struct mon_table mon_dispatch_postauth15[4]  = {      {25, 16, & mm_answer_pty}, 
        {27, 16, & mm_answer_pty_cleanup}, 
        {58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 308 "monitor.c"
struct mon_table *mon_dispatch  ;
#line 312 "monitor.c"
static void monitor_permit(struct mon_table *ent , enum monitor_reqtype type , int permit ) 
{ int tmp ;

  {
#line 315
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 316
    if ((int )ent->type == (int )type) {
#line 317
      ent->flags &= -4097;
#line 318
      if (permit) {
#line 318
        tmp = 4096;
      } else {
#line 318
        tmp = 0;
      }
#line 318
      ent->flags |= tmp;
#line 319
      return;
    }
#line 321
    ent ++;
  }
#line 323
  return;
}
}
#line 325 "monitor.c"
static void monitor_permit_authentications(int permit ) 
{ struct mon_table *ent ;
  int tmp ;

  {
#line 328
  ent = mon_dispatch;
#line 330
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 331
    if (ent->flags & 12) {
#line 332
      ent->flags &= -4097;
#line 333
      if (permit) {
#line 333
        tmp = 4096;
      } else {
#line 333
        tmp = 0;
      }
#line 333
      ent->flags |= tmp;
    }
#line 335
    ent ++;
  }
#line 337
  return;
}
}
#line 339 "monitor.c"
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) 
{ struct mon_table *ent ;
  int authenticated ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 343
  authenticated = 0;
#line 345
  debug3("preauth child monitor started");
#line 347
  authctxt = _authctxt;
#line 348
  memset((void *)authctxt, 0, sizeof(*authctxt));
#line 350
  authctxt->loginmsg = & loginmsg;
#line 352
  if (compat20) {
#line 353
    mon_dispatch = mon_dispatch_proto20;
#line 356
    monitor_permit(mon_dispatch, 0, 1);
#line 357
    monitor_permit(mon_dispatch, 4, 1);
  } else {
#line 359
    mon_dispatch = mon_dispatch_proto15;
#line 361
    monitor_permit(mon_dispatch, 28, 1);
  }
#line 365
  while (! authenticated) {
#line 366
    auth_method = (char *)"unknown";
#line 367
    tmp = monitor_read(pmonitor___0, mon_dispatch, & ent);
#line 367
    authenticated = tmp == 1;
#line 368
    if (authenticated) {
#line 369
      if (! (ent->flags & 8)) {
#line 370
        fatal("%s: unexpected authentication from %d", "monitor_child_preauth", ent->type);
      }
#line 372
      if ((authctxt->pw)->pw_uid == 0U) {
#line 372
        tmp___0 = auth_root_allowed(auth_method);
#line 372
        if (! tmp___0) {
#line 374
          authenticated = 0;
        }
      }
    }
#line 389
    if (ent->flags & 40) {
#line 390
      if (compat20) {
#line 390
        tmp___1 = " ssh2";
      } else {
#line 390
        tmp___1 = "";
      }
#line 390
      auth_log(authctxt, authenticated, auth_method, (char *)tmp___1);
#line 392
      if (! authenticated) {
#line 393
        (authctxt->failures) ++;
      }
    }
  }
#line 406
  if (! authctxt->valid) {
#line 407
    fatal("%s: authenticated invalid user", "monitor_child_preauth");
  }
#line 408
  if (0) {
#line 408
    __s1_len = strlen((char const   *)auth_method);
#line 408
    __s2_len = strlen("unknown");
#line 408
    if (! ((unsigned int )((void const   *)(auth_method + 1)) - (unsigned int )((void const   *)auth_method) == 1U)) {
      goto _L___0;
    } else {
#line 408
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 408
        if (! ((unsigned int )((void const   *)("unknown" + 1)) - (unsigned int )((void const   *)"unknown") == 1U)) {
#line 408
          tmp___11 = 1;
        } else {
#line 408
          if (__s2_len >= 4U) {
#line 408
            tmp___11 = 1;
          } else {
#line 408
            tmp___11 = 0;
          }
        }
      } else {
#line 408
        tmp___11 = 0;
      }
    }
#line 408
    if (tmp___11) {
#line 408
      tmp___7 = __builtin_strcmp((char const   *)auth_method, "unknown");
    } else {
#line 408
      tmp___10 = __builtin_strcmp((char const   *)auth_method, "unknown");
#line 408
      tmp___7 = tmp___10;
    }
  } else {
#line 408
    tmp___10 = __builtin_strcmp((char const   *)auth_method, "unknown");
#line 408
    tmp___7 = tmp___10;
  }
#line 408
  if (tmp___7 == 0) {
#line 409
    fatal("%s: authentication method name unknown", "monitor_child_preauth");
  }
#line 411
  debug("%s: %s has been authenticated by privileged process", "monitor_child_preauth",
        authctxt->user);
#line 414
  mm_get_keystate(pmonitor___0);
#line 415
  return;
}
}
#line 417 "monitor.c"
static void monitor_set_child_handler(pid_t pid ) 
{ 

  {
#line 420
  monitor_child_pid = pid;
#line 421
  return;
}
}
#line 423 "monitor.c"
static void monitor_child_handler(int sig ) 
{ 

  {
#line 426
  kill(monitor_child_pid, sig);
#line 427
  return;
}
}
#line 429 "monitor.c"
void monitor_child_postauth(struct monitor *pmonitor___0 ) 
{ 

  {
#line 432
  monitor_set_child_handler(pmonitor___0->m_pid);
#line 433
  mysignal(1, & monitor_child_handler);
#line 434
  mysignal(15, & monitor_child_handler);
#line 435
  mysignal(2, & monitor_child_handler);
#line 437
  if (compat20) {
#line 438
    mon_dispatch = mon_dispatch_postauth20;
#line 441
    monitor_permit(mon_dispatch, 0, 1);
#line 442
    monitor_permit(mon_dispatch, 4, 1);
#line 443
    monitor_permit(mon_dispatch, 58, 1);
  } else {
#line 445
    mon_dispatch = mon_dispatch_postauth15;
#line 446
    monitor_permit(mon_dispatch, 58, 1);
  }
#line 448
  if (! no_pty_flag) {
#line 449
    monitor_permit(mon_dispatch, 25, 1);
#line 450
    monitor_permit(mon_dispatch, 27, 1);
  }
#line 453
  while (1) {
#line 454
    monitor_read(pmonitor___0, mon_dispatch, (struct mon_table **)((void *)0));
  }
}
}
#line 457 "monitor.c"
void monitor_sync(struct monitor *pmonitor___0 ) 
{ 

  {
#line 460
  if (options.compression) {
#line 462
    mm_share_sync(& pmonitor___0->m_zlib, & pmonitor___0->m_zback);
  }
#line 464
  return;
}
}
#line 466 "monitor.c"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) 
{ Buffer m___0 ;
  int ret___0 ;
  u_char type ;
  int tmp ;

  {
#line 474
  buffer_init(& m___0);
#line 476
  mm_request_receive(pmonitor___0->m_sendfd, & m___0);
#line 477
  tmp = buffer_get_char(& m___0);
#line 477
  type = (unsigned char )tmp;
#line 479
  debug3("%s: checking request %d", "monitor_read", type);
#line 481
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 482
    if ((int )ent->type == (int )type) {
#line 483
      break;
    }
#line 484
    ent ++;
  }
#line 487
  if ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 488
    if (! (ent->flags & 4096)) {
#line 489
      fatal("%s: unpermitted request %d", "monitor_read", type);
    }
#line 491
    ret___0 = (*(ent->f))(pmonitor___0->m_sendfd, & m___0);
#line 492
    buffer_free(& m___0);
#line 495
    if (ent->flags & 16) {
#line 496
      debug2("%s: %d used once, disabling now", "monitor_read", type);
#line 498
      ent->flags &= -4097;
    }
#line 501
    if ((unsigned int )pent != (unsigned int )((void *)0)) {
#line 502
      *pent = ent;
    }
#line 504
    return (ret___0);
  }
#line 507
  fatal("%s: unsupported request: %d", "monitor_read", type);
#line 510
  return (-1);
}
}
#line 514 "monitor.c"
static int monitor_allowed_key(u_char *blob , u_int bloblen ) 
{ int tmp ;

  {
#line 518
  if ((unsigned int )key_blob == (unsigned int )((void *)0)) {
#line 520
    return (0);
  } else {
#line 518
    if (key_bloblen != bloblen) {
#line 520
      return (0);
    } else {
#line 518
      tmp = memcmp((void const   *)key_blob, (void const   *)blob, key_bloblen);
#line 518
      if (tmp) {
#line 520
        return (0);
      }
    }
  }
#line 521
  return (1);
}
}
#line 524 "monitor.c"
static void monitor_reset_key_state(void) 
{ 

  {
#line 528
  if ((unsigned int )key_blob != (unsigned int )((void *)0)) {
#line 529
    xfree((void *)key_blob);
  }
#line 530
  if ((unsigned int )hostbased_cuser != (unsigned int )((void *)0)) {
#line 531
    xfree((void *)hostbased_cuser);
  }
#line 532
  if ((unsigned int )hostbased_chost != (unsigned int )((void *)0)) {
#line 533
    xfree((void *)hostbased_chost);
  }
#line 534
  key_blob = (u_char *)((void *)0);
#line 535
  key_bloblen = 0U;
#line 536
  key_blobtype = 0;
#line 537
  hostbased_cuser = (char *)((void *)0);
#line 538
  hostbased_chost = (char *)((void *)0);
#line 539
  return;
}
}
#line 541 "monitor.c"
int mm_answer_moduli(int sock , Buffer *m___0 ) 
{ DH *dh ;
  int min ;
  int want ;
  int max ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 547
  tmp = buffer_get_int(m___0);
#line 547
  min = (int )tmp;
#line 548
  tmp___0 = buffer_get_int(m___0);
#line 548
  want = (int )tmp___0;
#line 549
  tmp___1 = buffer_get_int(m___0);
#line 549
  max = (int )tmp___1;
#line 551
  debug3("%s: got parameters: %d %d %d", "mm_answer_moduli", min, want, max);
#line 554
  if (max < min) {
#line 555
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
  } else {
#line 554
    if (want < min) {
#line 555
      fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    } else {
#line 554
      if (max < want) {
#line 555
        fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
      }
    }
  }
#line 558
  buffer_clear(m___0);
#line 560
  dh = choose_dh(min, want, max);
#line 561
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 562
    buffer_put_char(m___0, 0);
#line 563
    return (0);
  } else {
#line 566
    buffer_put_char(m___0, 1);
#line 567
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->p);
#line 568
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->g);
#line 570
    DH_free(dh);
  }
#line 572
  mm_request_send(sock, 1, m___0);
#line 573
  return (0);
}
}
#line 576 "monitor.c"
int mm_answer_sign(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *p ;
  u_char *signature ;
  u_int siglen ;
  u_int datlen ;
  int keyid ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 585
  debug3("%s", "mm_answer_sign");
#line 587
  tmp = buffer_get_int(m___0);
#line 587
  keyid = (int )tmp;
#line 588
  tmp___0 = buffer_get_string(m___0, & datlen);
#line 588
  p = (u_char *)tmp___0;
#line 594
  if (datlen != 20U) {
#line 594
    if (datlen != 32U) {
#line 595
      fatal("%s: data length incorrect: %u", "mm_answer_sign", datlen);
    }
  }
#line 598
  if (session_id2_len___0 == 0U) {
#line 599
    session_id2_len___0 = datlen;
#line 600
    tmp___1 = xmalloc(session_id2_len___0);
#line 600
    session_id2___0 = (u_char *)tmp___1;
#line 601
    memcpy((void * __restrict  )session_id2___0, (void const   * __restrict  )p, session_id2_len___0);
  }
#line 604
  key = get_hostkey_by_index(keyid);
#line 604
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 605
    fatal("%s: no hostkey from index %d", "mm_answer_sign", keyid);
  }
#line 606
  tmp___2 = key_sign((Key const   *)key, & signature, & siglen, (u_char const   *)p,
                     datlen);
#line 606
  if (tmp___2 < 0) {
#line 607
    fatal("%s: key_sign failed", "mm_answer_sign");
  }
#line 609
  debug3("%s: signature %p(%u)", "mm_answer_sign", signature, siglen);
#line 611
  buffer_clear(m___0);
#line 612
  buffer_put_string(m___0, (void const   *)signature, siglen);
#line 614
  xfree((void *)p);
#line 615
  xfree((void *)signature);
#line 617
  mm_request_send(sock, 5, m___0);
#line 620
  monitor_permit(mon_dispatch, 6, 1);
#line 622
  return (0);
}
}
#line 627 "monitor.c"
int mm_answer_pwnamallow(int sock , Buffer *m___0 ) 
{ char *username ;
  struct passwd *pwent ;
  int allowed ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 632
  allowed = 0;
#line 634
  debug3("%s", "mm_answer_pwnamallow");
#line 636
  tmp = authctxt->attempt;
#line 636
  (authctxt->attempt) ++;
#line 636
  if (tmp != 0) {
#line 637
    fatal("%s: multiple attempts for getpwnam", "mm_answer_pwnamallow");
  }
#line 639
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 639
  username = (char *)tmp___0;
#line 641
  pwent = getpwnamallow((char const   *)username);
#line 643
  authctxt->user = xstrdup((char const   *)username);
#line 644
  if (pwent) {
#line 644
    tmp___1 = (char const   *)username;
  } else {
#line 644
    tmp___1 = "unknown";
  }
#line 644
  setproctitle("%s [priv]", tmp___1);
#line 645
  xfree((void *)username);
#line 647
  buffer_clear(m___0);
#line 649
  if ((unsigned int )pwent == (unsigned int )((void *)0)) {
#line 650
    buffer_put_char(m___0, 0);
#line 651
    authctxt->pw = fakepw();
    goto out;
  }
#line 655
  allowed = 1;
#line 656
  authctxt->pw = pwent;
#line 657
  authctxt->valid = 1;
#line 659
  buffer_put_char(m___0, 1);
#line 660
  buffer_put_string(m___0, (void const   *)pwent, sizeof(struct passwd ));
#line 661
  buffer_put_cstring(m___0, (char const   *)pwent->pw_name);
#line 662
  buffer_put_cstring(m___0, "*");
#line 663
  buffer_put_cstring(m___0, (char const   *)pwent->pw_gecos);
#line 667
  buffer_put_cstring(m___0, (char const   *)pwent->pw_dir);
#line 668
  buffer_put_cstring(m___0, (char const   *)pwent->pw_shell);
  out: 
#line 671
  buffer_put_string(m___0, (void const   *)(& options), sizeof(options));
#line 672
  if ((unsigned int )options.banner != (unsigned int )((void *)0)) {
#line 673
    buffer_put_cstring(m___0, (char const   *)options.banner);
  }
#line 674
  debug3("%s: sending MONITOR_ANS_PWNAM: %d", "mm_answer_pwnamallow", allowed);
#line 675
  mm_request_send(sock, 7, m___0);
#line 678
  if (! compat20) {
#line 679
    monitor_permit_authentications(1);
  } else {
#line 682
    monitor_permit(mon_dispatch, 3, 1);
#line 683
    monitor_permit(mon_dispatch, 8, 1);
  }
#line 691
  return (0);
}
}
#line 694 "monitor.c"
int mm_answer_auth2_read_banner(int sock , Buffer *m___0 ) 
{ char *banner ;
  char const   *tmp ;

  {
#line 698
  buffer_clear(m___0);
#line 699
  banner = auth2_read_banner();
#line 700
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 700
    tmp = (char const   *)banner;
  } else {
#line 700
    tmp = "";
  }
#line 700
  buffer_put_cstring(m___0, tmp);
#line 701
  mm_request_send(sock, 9, m___0);
#line 703
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 704
    xfree((void *)banner);
  }
#line 706
  return (0);
}
}
#line 709 "monitor.c"
int mm_answer_authserv(int sock , Buffer *m___0 ) 
{ void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 712
  monitor_permit_authentications(1);
#line 714
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 714
  authctxt->service = (char *)tmp;
#line 715
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 715
  authctxt->style = (char *)tmp___0;
#line 716
  debug3("%s: service=%s, style=%s", "mm_answer_authserv", authctxt->service, authctxt->style);
#line 719
  tmp___1 = strlen((char const   *)authctxt->style);
#line 719
  if (tmp___1 == 0U) {
#line 720
    xfree((void *)authctxt->style);
#line 721
    authctxt->style = (char *)((void *)0);
  }
#line 724
  return (0);
}
}
#line 730 "monitor.c"
static int call_count  ;
#line 727 "monitor.c"
int mm_answer_authpassword(int sock , Buffer *m___0 ) 
{ char *passwd ;
  int authenticated ;
  u_int plen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 735
  tmp = buffer_get_string(m___0, & plen);
#line 735
  passwd = (char *)tmp;
#line 737
  if (options.password_authentication) {
#line 737
    tmp___0 = auth_password(authctxt, (char const   *)passwd);
#line 737
    if (tmp___0) {
#line 737
      tmp___1 = 1;
    } else {
#line 737
      tmp___1 = 0;
    }
  } else {
#line 737
    tmp___1 = 0;
  }
#line 737
  authenticated = tmp___1;
#line 739
  tmp___2 = strlen((char const   *)passwd);
#line 739
  memset((void *)passwd, 0, tmp___2);
#line 740
  xfree((void *)passwd);
#line 742
  buffer_clear(m___0);
#line 743
  buffer_put_int(m___0, (unsigned int )authenticated);
#line 745
  debug3("%s: sending result %d", "mm_answer_authpassword", authenticated);
#line 746
  mm_request_send(sock, 11, m___0);
#line 748
  call_count ++;
#line 749
  if (plen == 0U) {
#line 749
    if (call_count == 1) {
#line 750
      auth_method = (char *)"none";
    } else {
#line 752
      auth_method = (char *)"password";
    }
  } else {
#line 752
    auth_method = (char *)"password";
  }
#line 755
  return (authenticated);
}
}
#line 998 "monitor.c"
static void mm_append_debug(Buffer *m___0 ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 1001
  if (auth_debug_init) {
#line 1001
    tmp___1 = buffer_len(& auth_debug);
#line 1001
    if (tmp___1) {
#line 1002
      debug3("%s: Appending debug messages for child", "mm_append_debug");
#line 1003
      tmp = buffer_len(& auth_debug);
#line 1003
      tmp___0 = buffer_ptr(& auth_debug);
#line 1003
      buffer_append(m___0, (void const   *)tmp___0, tmp);
#line 1005
      buffer_clear(& auth_debug);
    }
  }
#line 1007
  return;
}
}
#line 1009 "monitor.c"
int mm_answer_keyallowed(int sock , Buffer *m___0 ) 
{ Key *key ;
  char *cuser ;
  char *chost ;
  u_char *blob ;
  u_int bloblen ;
  enum mm_keytype type ;
  int allowed ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 1016
  type = (enum mm_keytype )0;
#line 1017
  allowed = 0;
#line 1019
  debug3("%s entering", "mm_answer_keyallowed");
#line 1021
  tmp = buffer_get_int(m___0);
#line 1021
  type = (enum mm_keytype )tmp;
#line 1022
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1022
  cuser = (char *)tmp___0;
#line 1023
  tmp___1 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1023
  chost = (char *)tmp___1;
#line 1024
  tmp___2 = buffer_get_string(m___0, & bloblen);
#line 1024
  blob = (u_char *)tmp___2;
#line 1026
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 1028
  if (compat20) {
#line 1028
    if ((int )type == 3) {
#line 1030
      fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1028
    if (! compat20) {
#line 1028
      if ((int )type != 3) {
#line 1030
        fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
      }
    }
  }
#line 1032
  debug3("%s: key_from_blob: %p", "mm_answer_keyallowed", key);
#line 1034
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1034
    if (authctxt->valid) {
#line 1035
      switch ((int )type) {
      case 2: 
#line 1037
      if (options.pubkey_authentication) {
#line 1037
        tmp___3 = user_key_allowed(authctxt->pw, key);
#line 1037
        if (tmp___3) {
#line 1037
          tmp___4 = 1;
        } else {
#line 1037
          tmp___4 = 0;
        }
      } else {
#line 1037
        tmp___4 = 0;
      }
#line 1037
      allowed = tmp___4;
#line 1039
      auth_method = (char *)"publickey";
#line 1040
      if (options.pubkey_authentication) {
#line 1040
        if (allowed != 1) {
#line 1041
          auth_clear_options();
        }
      }
#line 1042
      break;
      case 1: 
#line 1044
      if (options.hostbased_authentication) {
#line 1044
        tmp___5 = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, chost,
                                        key);
#line 1044
        if (tmp___5) {
#line 1044
          tmp___6 = 1;
        } else {
#line 1044
          tmp___6 = 0;
        }
      } else {
#line 1044
        tmp___6 = 0;
      }
#line 1044
      allowed = tmp___6;
#line 1047
      auth_method = (char *)"hostbased";
#line 1048
      break;
      case 3: 
#line 1050
      key->type = 0;
#line 1051
      if (options.rhosts_rsa_authentication) {
#line 1051
        tmp___7 = auth_rhosts_rsa_key_allowed(authctxt->pw, cuser, chost, key);
#line 1051
        if (tmp___7) {
#line 1051
          tmp___8 = 1;
        } else {
#line 1051
          tmp___8 = 0;
        }
      } else {
#line 1051
        tmp___8 = 0;
      }
#line 1051
      allowed = tmp___8;
#line 1054
      if (options.rhosts_rsa_authentication) {
#line 1054
        if (allowed != 1) {
#line 1055
          auth_clear_options();
        }
      }
#line 1056
      auth_method = (char *)"rsa";
#line 1057
      break;
      default: 
#line 1059
      fatal("%s: unknown key type %d", "mm_answer_keyallowed", type);
#line 1060
      break;
      }
    }
  }
#line 1063
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1064
    key_free(key);
  }
#line 1067
  monitor_reset_key_state();
#line 1069
  if (allowed) {
#line 1071
    key_blob = blob;
#line 1072
    key_bloblen = bloblen;
#line 1073
    key_blobtype = (int )type;
#line 1074
    hostbased_cuser = cuser;
#line 1075
    hostbased_chost = chost;
  } else {
#line 1078
    if (compat20) {
#line 1078
      tmp___9 = " ssh2";
    } else {
#line 1078
      tmp___9 = "";
    }
#line 1078
    auth_log(authctxt, 0, auth_method, (char *)tmp___9);
#line 1079
    xfree((void *)blob);
#line 1080
    xfree((void *)cuser);
#line 1081
    xfree((void *)chost);
  }
#line 1084
  if (allowed) {
#line 1084
    tmp___10 = "allowed";
  } else {
#line 1084
    tmp___10 = "not allowed";
  }
#line 1084
  debug3("%s: key %p is %s", "mm_answer_keyallowed", key, tmp___10);
#line 1087
  buffer_clear(m___0);
#line 1088
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1089
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 1091
  mm_append_debug(m___0);
#line 1093
  mm_request_send(sock, 21, m___0);
#line 1095
  if ((int )type == 3) {
#line 1096
    monitor_permit(mon_dispatch, 33, allowed);
  }
#line 1098
  return (0);
}
}
#line 1101 "monitor.c"
static int monitor_valid_userblob(u_char *data , u_int datalen ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  u_int l ;
  u_int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  u_int l___0 ;
  u_int tmp___29 ;
  u_int l___1 ;
  u_int tmp___30 ;
  u_int tmp___31 ;

  {
#line 1107
  fail = 0;
#line 1109
  buffer_init(& b);
#line 1110
  buffer_append(& b, (void const   *)data, datalen);
#line 1112
  if (datafellows & 16) {
#line 1113
    tmp = buffer_ptr(& b);
#line 1113
    p = (char *)tmp;
#line 1114
    len = buffer_len(& b);
#line 1115
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1118
      fail ++;
    } else {
#line 1115
      if (len < session_id2_len___0) {
#line 1118
        fail ++;
      } else {
#line 1115
        tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1115
        if (tmp___0 != 0) {
#line 1118
          fail ++;
        }
      }
    }
#line 1119
    buffer_consume(& b, session_id2_len___0);
  } else {
#line 1121
    tmp___1 = buffer_get_string(& b, & len);
#line 1121
    p = (char *)tmp___1;
#line 1122
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1125
      fail ++;
    } else {
#line 1122
      if (len != session_id2_len___0) {
#line 1125
        fail ++;
      } else {
#line 1122
        tmp___2 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1122
        if (tmp___2 != 0) {
#line 1125
          fail ++;
        }
      }
    }
#line 1126
    xfree((void *)p);
  }
#line 1128
  tmp___3 = buffer_get_char(& b);
#line 1128
  if (tmp___3 != 50) {
#line 1129
    fail ++;
  }
#line 1130
  tmp___4 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1130
  p = (char *)tmp___4;
#line 1131
  if (0) {
#line 1131
    __s1_len = strlen((char const   *)authctxt->user);
#line 1131
    __s2_len = strlen((char const   *)p);
#line 1131
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1131
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1131
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1131
          tmp___14 = 1;
        } else {
#line 1131
          if (__s2_len >= 4U) {
#line 1131
            tmp___14 = 1;
          } else {
#line 1131
            tmp___14 = 0;
          }
        }
      } else {
#line 1131
        tmp___14 = 0;
      }
    }
#line 1131
    if (tmp___14) {
#line 1131
      tmp___10 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1131
      tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1131
      tmp___10 = tmp___13;
    }
  } else {
#line 1131
    tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1131
    tmp___10 = tmp___13;
  }
#line 1131
  if (tmp___10 != 0) {
#line 1132
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1134
    fail ++;
  }
#line 1136
  xfree((void *)p);
#line 1137
  while (1) {
#line 1137
    tmp___15 = buffer_get_int(& b);
#line 1137
    l = tmp___15;
#line 1137
    buffer_consume(& b, l);
#line 1137
    break;
  }
#line 1138
  if (datafellows & 32) {
#line 1139
    tmp___16 = buffer_get_char(& b);
#line 1139
    if (! tmp___16) {
#line 1140
      fail ++;
    }
  } else {
#line 1142
    tmp___17 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1142
    p = (char *)tmp___17;
#line 1143
    if (0) {
#line 1143
      __s1_len___0 = strlen("publickey");
#line 1143
      __s2_len___0 = strlen((char const   *)p);
#line 1143
      if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
        goto _L___2;
      } else {
#line 1143
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1143
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1143
            tmp___27 = 1;
          } else {
#line 1143
            if (__s2_len___0 >= 4U) {
#line 1143
              tmp___27 = 1;
            } else {
#line 1143
              tmp___27 = 0;
            }
          }
        } else {
#line 1143
          tmp___27 = 0;
        }
      }
#line 1143
      if (tmp___27) {
#line 1143
        tmp___23 = __builtin_strcmp("publickey", (char const   *)p);
      } else {
#line 1143
        tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1143
        tmp___23 = tmp___26;
      }
    } else {
#line 1143
      tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1143
      tmp___23 = tmp___26;
    }
#line 1143
    if (tmp___23 != 0) {
#line 1144
      fail ++;
    }
#line 1145
    xfree((void *)p);
#line 1146
    tmp___28 = buffer_get_char(& b);
#line 1146
    if (! tmp___28) {
#line 1147
      fail ++;
    }
#line 1148
    while (1) {
#line 1148
      tmp___29 = buffer_get_int(& b);
#line 1148
      l___0 = tmp___29;
#line 1148
      buffer_consume(& b, l___0);
#line 1148
      break;
    }
  }
#line 1150
  while (1) {
#line 1150
    tmp___30 = buffer_get_int(& b);
#line 1150
    l___1 = tmp___30;
#line 1150
    buffer_consume(& b, l___1);
#line 1150
    break;
  }
#line 1151
  tmp___31 = buffer_len(& b);
#line 1151
  if (tmp___31 != 0U) {
#line 1152
    fail ++;
  }
#line 1153
  buffer_free(& b);
#line 1154
  return (fail == 0);
}
}
#line 1157 "monitor.c"
static int monitor_valid_hostbasedblob(u_char *data , u_int datalen , char *cuser ,
                                       char *chost ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  u_int l ;
  u_int tmp___13 ;
  void *tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  u_int l___0 ;
  u_int tmp___25 ;
  u_int l___1 ;
  u_int tmp___26 ;
  void *tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  u_int tmp___49 ;

  {
#line 1164
  fail = 0;
#line 1166
  buffer_init(& b);
#line 1167
  buffer_append(& b, (void const   *)data, datalen);
#line 1169
  tmp = buffer_get_string(& b, & len);
#line 1169
  p = (char *)tmp;
#line 1170
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1173
    fail ++;
  } else {
#line 1170
    if (len != session_id2_len___0) {
#line 1173
      fail ++;
    } else {
#line 1170
      tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1170
      if (tmp___0 != 0) {
#line 1173
        fail ++;
      }
    }
  }
#line 1174
  xfree((void *)p);
#line 1176
  tmp___1 = buffer_get_char(& b);
#line 1176
  if (tmp___1 != 50) {
#line 1177
    fail ++;
  }
#line 1178
  tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1178
  p = (char *)tmp___2;
#line 1179
  if (0) {
#line 1179
    __s1_len = strlen((char const   *)authctxt->user);
#line 1179
    __s2_len = strlen((char const   *)p);
#line 1179
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1179
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1179
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1179
          tmp___12 = 1;
        } else {
#line 1179
          if (__s2_len >= 4U) {
#line 1179
            tmp___12 = 1;
          } else {
#line 1179
            tmp___12 = 0;
          }
        }
      } else {
#line 1179
        tmp___12 = 0;
      }
    }
#line 1179
    if (tmp___12) {
#line 1179
      tmp___8 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1179
      tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1179
      tmp___8 = tmp___11;
    }
  } else {
#line 1179
    tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1179
    tmp___8 = tmp___11;
  }
#line 1179
  if (tmp___8 != 0) {
#line 1180
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1182
    fail ++;
  }
#line 1184
  xfree((void *)p);
#line 1185
  while (1) {
#line 1185
    tmp___13 = buffer_get_int(& b);
#line 1185
    l = tmp___13;
#line 1185
    buffer_consume(& b, l);
#line 1185
    break;
  }
#line 1186
  tmp___14 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1186
  p = (char *)tmp___14;
#line 1187
  if (0) {
#line 1187
    __s1_len___0 = strlen((char const   *)p);
#line 1187
    __s2_len___0 = strlen("hostbased");
#line 1187
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___2;
    } else {
#line 1187
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 1187
        if (! ((unsigned int )((void const   *)("hostbased" + 1)) - (unsigned int )((void const   *)"hostbased") == 1U)) {
#line 1187
          tmp___24 = 1;
        } else {
#line 1187
          if (__s2_len___0 >= 4U) {
#line 1187
            tmp___24 = 1;
          } else {
#line 1187
            tmp___24 = 0;
          }
        }
      } else {
#line 1187
        tmp___24 = 0;
      }
    }
#line 1187
    if (tmp___24) {
#line 1187
      tmp___20 = __builtin_strcmp((char const   *)p, "hostbased");
    } else {
#line 1187
      tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1187
      tmp___20 = tmp___23;
    }
  } else {
#line 1187
    tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1187
    tmp___20 = tmp___23;
  }
#line 1187
  if (tmp___20 != 0) {
#line 1188
    fail ++;
  }
#line 1189
  xfree((void *)p);
#line 1190
  while (1) {
#line 1190
    tmp___25 = buffer_get_int(& b);
#line 1190
    l___0 = tmp___25;
#line 1190
    buffer_consume(& b, l___0);
#line 1190
    break;
  }
#line 1191
  while (1) {
#line 1191
    tmp___26 = buffer_get_int(& b);
#line 1191
    l___1 = tmp___26;
#line 1191
    buffer_consume(& b, l___1);
#line 1191
    break;
  }
#line 1194
  tmp___27 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1194
  p = (char *)tmp___27;
#line 1195
  len = strlen((char const   *)p);
#line 1195
  if (len > 0U) {
#line 1195
    if ((int )*(p + (len - 1U)) == 46) {
#line 1196
      *(p + (len - 1U)) = (char )'\000';
    }
  }
#line 1197
  if (0) {
#line 1197
    __s1_len___1 = strlen((char const   *)p);
#line 1197
    __s2_len___1 = strlen((char const   *)chost);
#line 1197
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___4;
    } else {
#line 1197
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1197
        if (! ((unsigned int )((void const   *)(chost + 1)) - (unsigned int )((void const   *)chost) == 1U)) {
#line 1197
          tmp___37 = 1;
        } else {
#line 1197
          if (__s2_len___1 >= 4U) {
#line 1197
            tmp___37 = 1;
          } else {
#line 1197
            tmp___37 = 0;
          }
        }
      } else {
#line 1197
        tmp___37 = 0;
      }
    }
#line 1197
    if (tmp___37) {
#line 1197
      tmp___33 = __builtin_strcmp((char const   *)p, (char const   *)chost);
    } else {
#line 1197
      tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1197
      tmp___33 = tmp___36;
    }
  } else {
#line 1197
    tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1197
    tmp___33 = tmp___36;
  }
#line 1197
  if (tmp___33 != 0) {
#line 1198
    fail ++;
  }
#line 1199
  xfree((void *)p);
#line 1202
  tmp___38 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1202
  p = (char *)tmp___38;
#line 1203
  if (0) {
#line 1203
    __s1_len___2 = strlen((char const   *)p);
#line 1203
    __s2_len___2 = strlen((char const   *)cuser);
#line 1203
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___6;
    } else {
#line 1203
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 1203
        if (! ((unsigned int )((void const   *)(cuser + 1)) - (unsigned int )((void const   *)cuser) == 1U)) {
#line 1203
          tmp___48 = 1;
        } else {
#line 1203
          if (__s2_len___2 >= 4U) {
#line 1203
            tmp___48 = 1;
          } else {
#line 1203
            tmp___48 = 0;
          }
        }
      } else {
#line 1203
        tmp___48 = 0;
      }
    }
#line 1203
    if (tmp___48) {
#line 1203
      tmp___44 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
    } else {
#line 1203
      tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1203
      tmp___44 = tmp___47;
    }
  } else {
#line 1203
    tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1203
    tmp___44 = tmp___47;
  }
#line 1203
  if (tmp___44 != 0) {
#line 1204
    fail ++;
  }
#line 1205
  xfree((void *)p);
#line 1207
  tmp___49 = buffer_len(& b);
#line 1207
  if (tmp___49 != 0U) {
#line 1208
    fail ++;
  }
#line 1209
  buffer_free(& b);
#line 1210
  return (fail == 0);
}
}
#line 1213 "monitor.c"
int mm_answer_keyverify(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *signature ;
  u_char *data ;
  u_char *blob ;
  u_int signaturelen ;
  u_int datalen ;
  u_int bloblen ;
  int verified ;
  int valid_data ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1219
  verified = 0;
#line 1220
  valid_data = 0;
#line 1222
  tmp = buffer_get_string(m___0, & bloblen);
#line 1222
  blob = (u_char *)tmp;
#line 1223
  tmp___0 = buffer_get_string(m___0, & signaturelen);
#line 1223
  signature = (u_char *)tmp___0;
#line 1224
  tmp___1 = buffer_get_string(m___0, & datalen);
#line 1224
  data = (u_char *)tmp___1;
#line 1226
  if ((unsigned int )hostbased_cuser == (unsigned int )((void *)0)) {
#line 1228
    fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
  } else {
#line 1226
    if ((unsigned int )hostbased_chost == (unsigned int )((void *)0)) {
#line 1228
      fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
    } else {
#line 1226
      tmp___2 = monitor_allowed_key(blob, bloblen);
#line 1226
      if (! tmp___2) {
#line 1228
        fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
      }
    }
  }
#line 1230
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 1231
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1232
    fatal("%s: bad public key blob", "mm_answer_keyverify");
  }
#line 1234
  switch (key_blobtype) {
  case 2: 
#line 1236
  valid_data = monitor_valid_userblob(data, datalen);
#line 1237
  break;
  case 1: 
#line 1239
  valid_data = monitor_valid_hostbasedblob(data, datalen, hostbased_cuser, hostbased_chost);
#line 1241
  break;
  default: 
#line 1243
  valid_data = 0;
#line 1244
  break;
  }
#line 1246
  if (! valid_data) {
#line 1247
    fatal("%s: bad signature data blob", "mm_answer_keyverify");
  }
#line 1249
  verified = key_verify((Key const   *)key, (u_char const   *)signature, signaturelen,
                        (u_char const   *)data, datalen);
#line 1250
  if (verified == 1) {
#line 1250
    tmp___3 = "verified";
  } else {
#line 1250
    tmp___3 = "unverified";
  }
#line 1250
  debug3("%s: key %p signature %s", "mm_answer_keyverify", key, tmp___3);
#line 1253
  key_free(key);
#line 1254
  xfree((void *)blob);
#line 1255
  xfree((void *)signature);
#line 1256
  xfree((void *)data);
#line 1258
  if (key_blobtype == 2) {
#line 1258
    auth_method = (char *)"publickey";
  } else {
#line 1258
    auth_method = (char *)"hostbased";
  }
#line 1260
  monitor_reset_key_state();
#line 1262
  buffer_clear(m___0);
#line 1263
  buffer_put_int(m___0, (unsigned int )verified);
#line 1264
  mm_request_send(sock, 23, m___0);
#line 1266
  return (verified == 1);
}
}
#line 1269 "monitor.c"
static void mm_record_login(Session *s , struct passwd *pw___0 ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1279
  memset((void *)(& from), 0, sizeof(from));
#line 1280
  fromlen = sizeof(from);
#line 1281
  tmp___3 = packet_connection_is_on_socket();
#line 1281
  if (tmp___3) {
#line 1282
    tmp___1 = packet_get_connection_in();
#line 1282
    tmp___2 = getpeername(tmp___1, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1282
    if (tmp___2 < 0) {
#line 1284
      tmp = __errno_location();
#line 1284
      tmp___0 = strerror(*tmp);
#line 1284
      debug("getpeername: %.100s", tmp___0);
#line 1285
      cleanup_exit(255);
    }
  }
#line 1289
  tmp___4 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 1289
  record_login(s->pid, (char const   *)(s->tty), (char const   *)pw___0->pw_name,
               pw___0->pw_uid, tmp___4, (struct sockaddr *)(& from), fromlen);
#line 1292
  return;
}
}
#line 1294 "monitor.c"
static void mm_session_close(Session *s ) 
{ 

  {
#line 1297
  debug3("%s: session %d pid %ld", "mm_session_close", s->self, (long )s->pid);
#line 1298
  if (s->ttyfd != -1) {
#line 1299
    debug3("%s: tty %s ptyfd %d", "mm_session_close", s->tty, s->ptyfd);
#line 1300
    session_pty_cleanup2(s);
  }
#line 1302
  session_unused(s->self);
#line 1303
  return;
}
}
#line 1305 "monitor.c"
int mm_answer_pty(int sock , Buffer *m___0 ) 
{ Session *s ;
  int res ;
  int fd0 ;
  int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 1312
  debug3("%s entering", "mm_answer_pty");
#line 1314
  buffer_clear(m___0);
#line 1315
  s = session_new();
#line 1316
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    goto error;
  }
#line 1318
  s->authctxt = authctxt;
#line 1319
  s->pw = authctxt->pw;
#line 1320
  s->pid = pmonitor->m_pid;
#line 1321
  res = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, sizeof(s->tty));
#line 1322
  if (res == 0) {
    goto error;
  }
#line 1324
  pty_setowner(authctxt->pw, (char const   *)(s->tty));
#line 1326
  buffer_put_int(m___0, 1U);
#line 1327
  buffer_put_cstring(m___0, (char const   *)(s->tty));
#line 1330
  tmp = dup2(s->ttyfd, 0);
#line 1330
  if (tmp == -1) {
#line 1331
    fatal("%s: dup2", "mm_answer_pty");
  }
#line 1333
  mm_record_login(s, authctxt->pw);
#line 1336
  close(0);
#line 1339
  tmp___0 = buffer_len(& loginmsg);
#line 1339
  tmp___1 = buffer_ptr(& loginmsg);
#line 1339
  buffer_put_string(m___0, (void const   *)tmp___1, tmp___0);
#line 1340
  buffer_clear(& loginmsg);
#line 1342
  mm_request_send(sock, 26, m___0);
#line 1344
  tmp___2 = mm_send_fd(sock, s->ptyfd);
#line 1344
  if (tmp___2 == -1) {
#line 1346
    fatal("%s: send fds failed", "mm_answer_pty");
  } else {
#line 1344
    tmp___3 = mm_send_fd(sock, s->ttyfd);
#line 1344
    if (tmp___3 == -1) {
#line 1346
      fatal("%s: send fds failed", "mm_answer_pty");
    }
  }
#line 1349
  fd0 = open("/dev/null", 0);
#line 1349
  if (fd0 < 0) {
#line 1350
    tmp___4 = __errno_location();
#line 1350
    tmp___5 = strerror(*tmp___4);
#line 1350
    fatal("%s: open(/dev/null): %s", "mm_answer_pty", tmp___5);
  }
#line 1351
  if (fd0 != 0) {
#line 1352
    error("%s: fd0 %d != 0", "mm_answer_pty", fd0);
  }
#line 1355
  close(s->ttyfd);
#line 1356
  s->ttyfd = s->ptyfd;
#line 1358
  s->ptymaster = s->ptyfd;
#line 1360
  debug3("%s: tty %s ptyfd %d", "mm_answer_pty", s->tty, s->ttyfd);
#line 1362
  return (0);
  error: 
#line 1365
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1366
    mm_session_close(s);
  }
#line 1367
  buffer_put_int(m___0, 0U);
#line 1368
  mm_request_send(sock, 26, m___0);
#line 1369
  return (0);
}
}
#line 1372 "monitor.c"
int mm_answer_pty_cleanup(int sock , Buffer *m___0 ) 
{ Session *s ;
  char *tty ;
  void *tmp ;

  {
#line 1378
  debug3("%s entering", "mm_answer_pty_cleanup");
#line 1380
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1380
  tty = (char *)tmp;
#line 1381
  s = session_by_tty(tty);
#line 1381
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1382
    mm_session_close(s);
  }
#line 1383
  buffer_clear(m___0);
#line 1384
  xfree((void *)tty);
#line 1385
  return (0);
}
}
#line 1388 "monitor.c"
int mm_answer_sesskey(int sock , Buffer *m___0 ) 
{ BIGNUM *p ;
  int rsafail ;

  {
#line 1395
  monitor_permit(mon_dispatch, 28, 0);
#line 1397
  p = BN_new();
#line 1397
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1398
    fatal("%s: BN_new", "mm_answer_sesskey");
  }
#line 1400
  buffer_get_bignum2(m___0, p);
#line 1402
  rsafail = ssh1_session_key(p);
#line 1404
  buffer_clear(m___0);
#line 1405
  buffer_put_int(m___0, (unsigned int )rsafail);
#line 1406
  buffer_put_bignum2(m___0, (BIGNUM const   *)p);
#line 1408
  BN_clear_free(p);
#line 1410
  mm_request_send(sock, 29, m___0);
#line 1413
  monitor_permit(mon_dispatch, 30, 1);
#line 1415
  return (0);
}
}
#line 1418 "monitor.c"
int mm_answer_sessid(int sock , Buffer *m___0 ) 
{ int i ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 1423
  debug3("%s entering", "mm_answer_sessid");
#line 1425
  tmp = buffer_len(m___0);
#line 1425
  if (tmp != 16U) {
#line 1426
    fatal("%s: bad ssh1 session id", "mm_answer_sessid");
  }
#line 1427
  i = 0;
#line 1427
  while (i < 16) {
#line 1428
    tmp___0 = buffer_get_char(m___0);
#line 1428
    session_id[i] = (unsigned char )tmp___0;
#line 1427
    i ++;
  }
#line 1431
  monitor_permit(mon_dispatch, 6, 1);
#line 1433
  return (0);
}
}
#line 1436 "monitor.c"
int mm_answer_rsa_keyallowed(int sock , Buffer *m___0 ) 
{ BIGNUM *client_n ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int tmp ;

  {
#line 1440
  key = (Key *)((void *)0);
#line 1441
  blob = (u_char *)((void *)0);
#line 1442
  blen = (u_int )0;
#line 1443
  allowed = 0;
#line 1445
  debug3("%s entering", "mm_answer_rsa_keyallowed");
#line 1447
  auth_method = (char *)"rsa";
#line 1448
  if (options.rsa_authentication) {
#line 1448
    if (authctxt->valid) {
#line 1449
      client_n = BN_new();
#line 1449
      if ((unsigned int )client_n == (unsigned int )((void *)0)) {
#line 1450
        fatal("%s: BN_new", "mm_answer_rsa_keyallowed");
      }
#line 1451
      buffer_get_bignum2(m___0, client_n);
#line 1452
      allowed = auth_rsa_key_allowed(authctxt->pw, client_n, & key);
#line 1453
      BN_clear_free(client_n);
    }
  }
#line 1455
  buffer_clear(m___0);
#line 1456
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1457
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 1460
  monitor_reset_key_state();
#line 1462
  if (allowed) {
#line 1462
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1463
      key->type = 1;
#line 1464
      tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1464
      if (tmp == 0) {
#line 1465
        fatal("%s: key_to_blob failed", "mm_answer_rsa_keyallowed");
      }
#line 1466
      buffer_put_string(m___0, (void const   *)blob, blen);
#line 1469
      key_blob = blob;
#line 1470
      key_bloblen = blen;
#line 1471
      key_blobtype = 4;
    }
  }
#line 1473
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1474
    key_free(key);
  }
#line 1476
  mm_append_debug(m___0);
#line 1478
  mm_request_send(sock, 32, m___0);
#line 1480
  monitor_permit(mon_dispatch, 33, allowed);
#line 1481
  monitor_permit(mon_dispatch, 35, 0);
#line 1482
  return (0);
}
}
#line 1485 "monitor.c"
int mm_answer_rsa_challenge(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_int blen ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1488
  key = (Key *)((void *)0);
#line 1492
  debug3("%s entering", "mm_answer_rsa_challenge");
#line 1494
  if (! authctxt->valid) {
#line 1495
    fatal("%s: authctxt not valid", "mm_answer_rsa_challenge");
  }
#line 1496
  tmp = buffer_get_string(m___0, & blen);
#line 1496
  blob = (u_char *)tmp;
#line 1497
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1497
  if (! tmp___0) {
#line 1498
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_challenge");
  }
#line 1499
  if (key_blobtype != 4) {
#line 1499
    if (key_blobtype != 3) {
#line 1500
      fatal("%s: key type mismatch", "mm_answer_rsa_challenge");
    }
  }
#line 1501
  key = key_from_blob((u_char const   *)blob, blen);
#line 1501
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1502
    fatal("%s: received bad key", "mm_answer_rsa_challenge");
  }
#line 1503
  if (key->type != 1) {
#line 1504
    fatal("%s: received bad key type %d", "mm_answer_rsa_challenge", key->type);
  }
#line 1505
  key->type = 0;
#line 1506
  if (ssh1_challenge) {
#line 1507
    BN_clear_free(ssh1_challenge);
  }
#line 1508
  ssh1_challenge = auth_rsa_generate_challenge(key);
#line 1510
  buffer_clear(m___0);
#line 1511
  buffer_put_bignum2(m___0, (BIGNUM const   *)ssh1_challenge);
#line 1513
  debug3("%s sending reply", "mm_answer_rsa_challenge");
#line 1514
  mm_request_send(sock, 34, m___0);
#line 1516
  monitor_permit(mon_dispatch, 35, 1);
#line 1518
  xfree((void *)blob);
#line 1519
  key_free(key);
#line 1520
  return (0);
}
}
#line 1523 "monitor.c"
int mm_answer_rsa_response(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_char *response ;
  u_int blen ;
  u_int len ;
  int success ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1526
  key = (Key *)((void *)0);
#line 1531
  debug3("%s entering", "mm_answer_rsa_response");
#line 1533
  if (! authctxt->valid) {
#line 1534
    fatal("%s: authctxt not valid", "mm_answer_rsa_response");
  }
#line 1535
  if ((unsigned int )ssh1_challenge == (unsigned int )((void *)0)) {
#line 1536
    fatal("%s: no ssh1_challenge", "mm_answer_rsa_response");
  }
#line 1538
  tmp = buffer_get_string(m___0, & blen);
#line 1538
  blob = (u_char *)tmp;
#line 1539
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1539
  if (! tmp___0) {
#line 1540
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_response");
  }
#line 1541
  if (key_blobtype != 4) {
#line 1541
    if (key_blobtype != 3) {
#line 1542
      fatal("%s: key type mismatch: %d", "mm_answer_rsa_response", key_blobtype);
    }
  }
#line 1543
  key = key_from_blob((u_char const   *)blob, blen);
#line 1543
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1544
    fatal("%s: received bad key", "mm_answer_rsa_response");
  }
#line 1545
  tmp___1 = buffer_get_string(m___0, & len);
#line 1545
  response = (u_char *)tmp___1;
#line 1546
  if (len != 16U) {
#line 1547
    fatal("%s: received bad response to challenge", "mm_answer_rsa_response");
  }
#line 1548
  success = auth_rsa_verify_response(key, ssh1_challenge, response);
#line 1550
  xfree((void *)blob);
#line 1551
  key_free(key);
#line 1552
  xfree((void *)response);
#line 1554
  if (key_blobtype == 4) {
#line 1554
    auth_method = (char *)"rsa";
  } else {
#line 1554
    auth_method = (char *)"rhosts-rsa";
  }
#line 1557
  BN_clear_free(ssh1_challenge);
#line 1558
  ssh1_challenge = (BIGNUM *)((void *)0);
#line 1559
  monitor_reset_key_state();
#line 1561
  buffer_clear(m___0);
#line 1562
  buffer_put_int(m___0, (unsigned int )success);
#line 1563
  mm_request_send(sock, 36, m___0);
#line 1565
  return (success);
}
}
#line 1568 "monitor.c"
int mm_answer_term(int sock , Buffer *req ) 
{ int res ;
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  union __anonunion___u_86___1 __u___1 ;
  union __anonunion___u_87___1 __u___2 ;

  {
#line 1574
  debug3("%s: tearing down sessions", "mm_answer_term");
#line 1577
  session_destroy_all(& mm_session_close);
#line 1584
  while (1) {
#line 1584
    tmp___0 = waitpid(pmonitor->m_pid, & status, 0);
#line 1584
    if (! (tmp___0 == -1)) {
#line 1584
      break;
    }
#line 1585
    tmp = __errno_location();
#line 1585
    if (*tmp != 4) {
#line 1586
      exit(1);
    }
  }
#line 1588
  __u___2.__in = status;
#line 1588
  if ((__u___2.__i & 127) == 0) {
#line 1588
    __u___1.__in = status;
#line 1588
    res = (__u___1.__i & 65280) >> 8;
  } else {
#line 1588
    res = 1;
  }
#line 1591
  exit(res);
}
}
#line 1636 "monitor.c"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) 
{ 

  {
#line 1639
  if (compat20) {
#line 1640
    set_newkeys(0);
#line 1641
    set_newkeys(1);
  } else {
#line 1643
    packet_set_protocol_flags((unsigned int )child_state.ssh1protoflags);
#line 1644
    packet_set_encryption_key((u_char const   *)child_state.ssh1key, child_state.ssh1keylen,
                              child_state.ssh1cipher);
#line 1646
    xfree((void *)child_state.ssh1key);
  }
#line 1650
  packet_set_keycontext(1, child_state.keyout);
#line 1651
  xfree((void *)child_state.keyout);
#line 1652
  packet_set_keycontext(0, child_state.keyin);
#line 1653
  xfree((void *)child_state.keyin);
#line 1655
  if (! compat20) {
#line 1656
    packet_set_iv(1, child_state.ivout);
#line 1657
    xfree((void *)child_state.ivout);
#line 1658
    packet_set_iv(0, child_state.ivin);
#line 1659
    xfree((void *)child_state.ivin);
  }
#line 1662
  memcpy((void * __restrict  )(& incoming_stream), (void const   * __restrict  )(& child_state.incoming),
         sizeof(incoming_stream));
#line 1664
  memcpy((void * __restrict  )(& outgoing_stream), (void const   * __restrict  )(& child_state.outgoing),
         sizeof(outgoing_stream));
#line 1668
  if (options.compression) {
#line 1669
    mm_init_compression(pmonitor___0->m_zlib);
  }
#line 1673
  buffer_clear(& input);
#line 1674
  buffer_append(& input, (void const   *)child_state.input, child_state.ilen);
#line 1675
  memset((void *)child_state.input, 0, child_state.ilen);
#line 1676
  xfree((void *)child_state.input);
#line 1678
  buffer_clear(& output);
#line 1679
  buffer_append(& output, (void const   *)child_state.output, child_state.olen);
#line 1680
  memset((void *)child_state.output, 0, child_state.olen);
#line 1681
  xfree((void *)child_state.output);
#line 1682
  return;
}
}
#line 1684 "monitor.c"
static Kex *mm_get_kex(Buffer *m___0 ) 
{ Kex *kex ;
  void *blob ;
  u_int bloblen ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 1691
  tmp = xcalloc(1U, sizeof(*kex));
#line 1691
  kex = (Kex *)tmp;
#line 1692
  tmp___0 = buffer_get_string(m___0, & kex->session_id_len);
#line 1692
  kex->session_id = (u_char *)tmp___0;
#line 1693
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1696
    fatal("mm_get_get: internal error: bad session id");
  } else {
#line 1693
    if (kex->session_id_len != session_id2_len___0) {
#line 1696
      fatal("mm_get_get: internal error: bad session id");
    } else {
#line 1693
      tmp___1 = memcmp((void const   *)kex->session_id, (void const   *)session_id2___0,
                       session_id2_len___0);
#line 1693
      if (tmp___1 != 0) {
#line 1696
        fatal("mm_get_get: internal error: bad session id");
      }
    }
  }
#line 1697
  kex->we_need = buffer_get_int(m___0);
#line 1698
  kex->kex[0] = & kexdh_server;
#line 1699
  kex->kex[1] = & kexdh_server;
#line 1700
  kex->kex[2] = & kexgex_server;
#line 1701
  kex->kex[3] = & kexgex_server;
#line 1702
  kex->server = 1;
#line 1703
  tmp___2 = buffer_get_int(m___0);
#line 1703
  kex->hostkey_type = (int )tmp___2;
#line 1704
  tmp___3 = buffer_get_int(m___0);
#line 1704
  kex->kex_type = (int )tmp___3;
#line 1705
  blob = buffer_get_string(m___0, & bloblen);
#line 1706
  buffer_init(& kex->my);
#line 1707
  buffer_append(& kex->my, (void const   *)blob, bloblen);
#line 1708
  xfree(blob);
#line 1709
  blob = buffer_get_string(m___0, & bloblen);
#line 1710
  buffer_init(& kex->peer);
#line 1711
  buffer_append(& kex->peer, (void const   *)blob, bloblen);
#line 1712
  xfree(blob);
#line 1713
  kex->done = 1;
#line 1714
  tmp___4 = buffer_get_int(m___0);
#line 1714
  kex->flags = (int )tmp___4;
#line 1715
  tmp___5 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1715
  kex->client_version_string = (char *)tmp___5;
#line 1716
  tmp___6 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1716
  kex->server_version_string = (char *)tmp___6;
#line 1717
  kex->load_host_key = & get_hostkey_by_type;
#line 1718
  kex->host_key_index = & get_hostkey_index;
#line 1720
  return (kex);
}
}
#line 1725 "monitor.c"
void mm_get_keystate(struct monitor *pmonitor___0 ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_int64_t bytes ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 1734
  debug3("%s: Waiting for new keys", "mm_get_keystate");
#line 1736
  buffer_init(& m___0);
#line 1737
  mm_request_receive_expect(pmonitor___0->m_sendfd, 24, & m___0);
#line 1738
  if (! compat20) {
#line 1739
    tmp = buffer_get_int(& m___0);
#line 1739
    child_state.ssh1protoflags = (int )tmp;
#line 1740
    tmp___0 = buffer_get_int(& m___0);
#line 1740
    child_state.ssh1cipher = (int )tmp___0;
#line 1741
    tmp___1 = buffer_get_string(& m___0, & child_state.ssh1keylen);
#line 1741
    child_state.ssh1key = (u_char *)tmp___1;
#line 1743
    tmp___2 = buffer_get_string(& m___0, & child_state.ivoutlen);
#line 1743
    child_state.ivout = (u_char *)tmp___2;
#line 1745
    tmp___3 = buffer_get_string(& m___0, & child_state.ivinlen);
#line 1745
    child_state.ivin = (u_char *)tmp___3;
    goto skip;
  } else {
#line 1749
    *(pmonitor___0->m_pkex) = mm_get_kex(& m___0);
  }
#line 1752
  tmp___4 = buffer_get_string(& m___0, & bloblen);
#line 1752
  blob = (u_char *)tmp___4;
#line 1753
  current_keys[1] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1754
  xfree((void *)blob);
#line 1756
  debug3("%s: Waiting for second key", "mm_get_keystate");
#line 1757
  tmp___5 = buffer_get_string(& m___0, & bloblen);
#line 1757
  blob = (u_char *)tmp___5;
#line 1758
  current_keys[0] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1759
  xfree((void *)blob);
#line 1762
  seqnr = buffer_get_int(& m___0);
#line 1763
  blocks = buffer_get_int64(& m___0);
#line 1764
  packets = buffer_get_int(& m___0);
#line 1765
  bytes = buffer_get_int64(& m___0);
#line 1766
  packet_set_state(1, seqnr, blocks, packets, bytes);
#line 1767
  seqnr = buffer_get_int(& m___0);
#line 1768
  blocks = buffer_get_int64(& m___0);
#line 1769
  packets = buffer_get_int(& m___0);
#line 1770
  bytes = buffer_get_int64(& m___0);
#line 1771
  packet_set_state(0, seqnr, blocks, packets, bytes);
  skip: 
#line 1775
  tmp___6 = buffer_get_string(& m___0, & child_state.keyoutlen);
#line 1775
  child_state.keyout = (u_char *)tmp___6;
#line 1776
  tmp___7 = buffer_get_string(& m___0, & child_state.keyinlen);
#line 1776
  child_state.keyin = (u_char *)tmp___7;
#line 1778
  debug3("%s: Getting compression state", "mm_get_keystate");
#line 1780
  tmp___8 = buffer_get_string(& m___0, & plen);
#line 1780
  p = (u_char *)tmp___8;
#line 1781
  if (plen != sizeof(child_state.outgoing)) {
#line 1782
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1783
  memcpy((void * __restrict  )(& child_state.outgoing), (void const   * __restrict  )p,
         sizeof(child_state.outgoing));
#line 1784
  xfree((void *)p);
#line 1786
  tmp___9 = buffer_get_string(& m___0, & plen);
#line 1786
  p = (u_char *)tmp___9;
#line 1787
  if (plen != sizeof(child_state.incoming)) {
#line 1788
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1789
  memcpy((void * __restrict  )(& child_state.incoming), (void const   * __restrict  )p,
         sizeof(child_state.incoming));
#line 1790
  xfree((void *)p);
#line 1793
  debug3("%s: Getting Network I/O buffers", "mm_get_keystate");
#line 1794
  tmp___10 = buffer_get_string(& m___0, & child_state.ilen);
#line 1794
  child_state.input = (u_char *)tmp___10;
#line 1795
  tmp___11 = buffer_get_string(& m___0, & child_state.olen);
#line 1795
  child_state.output = (u_char *)tmp___11;
#line 1797
  buffer_free(& m___0);
#line 1798
  return;
}
}
#line 1802 "monitor.c"
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) 
{ size_t len ;
  void *address ;

  {
#line 1805
  len = size * ncount;
#line 1808
  if (len == 0U) {
#line 1809
    fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
  } else {
#line 1808
    if ((unsigned long )ncount > 4294967295UL / (unsigned long )size) {
#line 1809
      fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
    }
  }
#line 1811
  address = mm_malloc(mm, len);
#line 1813
  return (address);
}
}
#line 1816 "monitor.c"
void mm_zfree(struct mm_master *mm , void *address ) 
{ 

  {
#line 1819
  mm_free(mm, address);
#line 1820
  return;
}
}
#line 1822 "monitor.c"
void mm_init_compression(struct mm_master *mm ) 
{ 

  {
#line 1825
  outgoing_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1826
  outgoing_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1827
  outgoing_stream.opaque = (void *)mm;
#line 1829
  incoming_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1830
  incoming_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1831
  incoming_stream.opaque = (void *)mm;
#line 1832
  return;
}
}
#line 1841 "monitor.c"
static void monitor_socketpair(int *pair ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1845
  tmp = socketpair(1, 1, 0, (int *)pair);
#line 1845
  if (tmp == -1) {
#line 1846
    fatal("%s: socketpair", "monitor_socketpair");
  }
#line 1851
  while (1) {
#line 1851
    tmp___0 = fcntl(*(pair + 0), 2, 1);
#line 1851
    if (tmp___0 == -1) {
#line 1851
      fatal("fcntl(%d, F_SETFD)", *(pair + 0));
    }
#line 1851
    break;
  }
#line 1852
  while (1) {
#line 1852
    tmp___1 = fcntl(*(pair + 1), 2, 1);
#line 1852
    if (tmp___1 == -1) {
#line 1852
      fatal("fcntl(%d, F_SETFD)", *(pair + 1));
    }
#line 1852
    break;
  }
#line 1853
  return;
}
}
#line 1857 "monitor.c"
struct monitor *monitor_init(void) 
{ struct monitor *mon ;
  int pair[2] ;
  void *tmp ;

  {
#line 1863
  tmp = xcalloc(1U, sizeof(*mon));
#line 1863
  mon = (struct monitor *)tmp;
#line 1865
  monitor_socketpair(pair);
#line 1867
  mon->m_recvfd = pair[0];
#line 1868
  mon->m_sendfd = pair[1];
#line 1871
  if (options.compression) {
#line 1872
    mon->m_zback = mm_create((struct mm_master *)((void *)0), 65536U);
#line 1873
    mon->m_zlib = mm_create(mon->m_zback, 1310720U);
#line 1876
    mm_init_compression(mon->m_zlib);
  }
#line 1879
  return (mon);
}
}
#line 1882 "monitor.c"
void monitor_reinit(struct monitor *mon ) 
{ int pair[2] ;

  {
#line 1887
  monitor_socketpair(pair);
#line 1889
  mon->m_recvfd = pair[0];
#line 1890
  mon->m_sendfd = pair[1];
#line 1891
  return;
}
}
#line 1 "monitor_wrap.o"
#pragma merger(0,"./monitor_wrap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 41 "monitor_wrap.h"
DH *mm_choose_dh(int min , int nbits , int max ) ;
#line 42
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 47
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) ;
#line 90
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) ;
#line 97
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) ;
#line 98
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 90 "monitor_wrap.c"
int mm_is_monitor(void) 
{ int tmp ;

  {
#line 97
  if (pmonitor) {
#line 97
    if (pmonitor->m_pid > 0) {
#line 97
      tmp = 1;
    } else {
#line 97
      tmp = 0;
    }
  } else {
#line 97
    tmp = 0;
  }
#line 97
  return (tmp);
}
}
#line 100 "monitor_wrap.c"
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_int mlen ;
  u_int tmp ;
  u_char buf___1[5] ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 103
  tmp = buffer_len(m___0);
#line 103
  mlen = tmp;
#line 106
  debug3("%s entering: type %d", "mm_request_send", type);
#line 108
  put_u32((void *)(buf___1), mlen + 1U);
#line 109
  buf___1[4] = (unsigned char )type;
#line 110
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, (void *)(buf___1),
                     sizeof(buf___1));
#line 110
  if (tmp___2 != sizeof(buf___1)) {
#line 111
    tmp___0 = __errno_location();
#line 111
    tmp___1 = strerror(*tmp___0);
#line 111
    fatal("%s: write: %s", "mm_request_send", tmp___1);
  }
#line 112
  tmp___5 = buffer_ptr(m___0);
#line 112
  tmp___6 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, tmp___5,
                     mlen);
#line 112
  if (tmp___6 != mlen) {
#line 113
    tmp___3 = __errno_location();
#line 113
    tmp___4 = strerror(*tmp___3);
#line 113
    fatal("%s: write: %s", "mm_request_send", tmp___4);
  }
#line 114
  return;
}
}
#line 116 "monitor_wrap.c"
void mm_request_receive(int sock , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  u_int msg_len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 122
  debug3("%s entering", "mm_request_receive");
#line 124
  tmp___2 = atomicio(& read, sock, (void *)(buf___1), sizeof(buf___1));
#line 124
  if (tmp___2 != sizeof(buf___1)) {
#line 125
    tmp = __errno_location();
#line 125
    if (*tmp == 32) {
#line 126
      cleanup_exit(255);
    }
#line 127
    tmp___0 = __errno_location();
#line 127
    tmp___1 = strerror(*tmp___0);
#line 127
    fatal("%s: read: %s", "mm_request_receive", tmp___1);
  }
#line 129
  msg_len = get_u32((void const   *)(buf___1));
#line 130
  if (msg_len > 262144U) {
#line 131
    fatal("%s: read: bad msg_len %d", "mm_request_receive", msg_len);
  }
#line 132
  buffer_clear(m___0);
#line 133
  buffer_append_space(m___0, msg_len);
#line 134
  tmp___5 = buffer_ptr(m___0);
#line 134
  tmp___6 = atomicio(& read, sock, tmp___5, msg_len);
#line 134
  if (tmp___6 != msg_len) {
#line 135
    tmp___3 = __errno_location();
#line 135
    tmp___4 = strerror(*tmp___3);
#line 135
    fatal("%s: read: %s", "mm_request_receive", tmp___4);
  }
#line 136
  return;
}
}
#line 138 "monitor_wrap.c"
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_char rtype ;
  int tmp ;

  {
#line 143
  debug3("%s entering: type %d", "mm_request_receive_expect", type);
#line 145
  mm_request_receive(sock, m___0);
#line 146
  tmp = buffer_get_char(m___0);
#line 146
  rtype = (unsigned char )tmp;
#line 147
  if ((int )rtype != (int )type) {
#line 148
    fatal("%s: read: rtype %d != type %d", "mm_request_receive_expect", rtype, type);
  }
#line 150
  return;
}
}
#line 152 "monitor_wrap.c"
DH *mm_choose_dh(int min , int nbits , int max ) 
{ BIGNUM *p ;
  BIGNUM *g ;
  int success ;
  Buffer m___0 ;
  u_int tmp ;
  DH *tmp___0 ;

  {
#line 156
  success = 0;
#line 159
  buffer_init(& m___0);
#line 160
  buffer_put_int(& m___0, (unsigned int )min);
#line 161
  buffer_put_int(& m___0, (unsigned int )nbits);
#line 162
  buffer_put_int(& m___0, (unsigned int )max);
#line 164
  mm_request_send(pmonitor->m_recvfd, 0, & m___0);
#line 166
  debug3("%s: waiting for MONITOR_ANS_MODULI", "mm_choose_dh");
#line 167
  mm_request_receive_expect(pmonitor->m_recvfd, 1, & m___0);
#line 169
  success = buffer_get_char(& m___0);
#line 170
  if (success == 0) {
#line 171
    fatal("%s: MONITOR_ANS_MODULI failed", "mm_choose_dh");
  }
#line 173
  p = BN_new();
#line 173
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 174
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 175
  g = BN_new();
#line 175
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 176
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 177
  buffer_get_bignum2(& m___0, p);
#line 178
  buffer_get_bignum2(& m___0, g);
#line 180
  tmp = buffer_len(& m___0);
#line 180
  debug3("%s: remaining %d", "mm_choose_dh", tmp);
#line 181
  buffer_free(& m___0);
#line 183
  tmp___0 = dh_new_group(g, p);
#line 183
  return (tmp___0);
}
}
#line 186 "monitor_wrap.c"
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ Kex *kex ;
  Buffer m___0 ;
  int tmp ;
  void *tmp___0 ;

  {
#line 189
  kex = *(pmonitor->m_pkex);
#line 192
  debug3("%s entering", "mm_key_sign");
#line 194
  buffer_init(& m___0);
#line 195
  tmp = (*(kex->host_key_index))(key);
#line 195
  buffer_put_int(& m___0, (unsigned int )tmp);
#line 196
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 198
  mm_request_send(pmonitor->m_recvfd, 4, & m___0);
#line 200
  debug3("%s: waiting for MONITOR_ANS_SIGN", "mm_key_sign");
#line 201
  mm_request_receive_expect(pmonitor->m_recvfd, 5, & m___0);
#line 202
  tmp___0 = buffer_get_string(& m___0, lenp);
#line 202
  *sigp = (u_char *)tmp___0;
#line 203
  buffer_free(& m___0);
#line 205
  return (0);
}
}
#line 208 "monitor_wrap.c"
struct passwd *mm_getpwnamallow(char const   *username ) 
{ Buffer m___0 ;
  struct passwd *pw___0 ;
  u_int len ;
  ServerOptions *newopts ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 216
  debug3("%s entering", "mm_getpwnamallow");
#line 218
  buffer_init(& m___0);
#line 219
  buffer_put_cstring(& m___0, username);
#line 221
  mm_request_send(pmonitor->m_recvfd, 6, & m___0);
#line 223
  debug3("%s: waiting for MONITOR_ANS_PWNAM", "mm_getpwnamallow");
#line 224
  mm_request_receive_expect(pmonitor->m_recvfd, 7, & m___0);
#line 226
  tmp = buffer_get_char(& m___0);
#line 226
  if (tmp == 0) {
#line 227
    pw___0 = (struct passwd *)((void *)0);
    goto out;
  }
#line 230
  tmp___0 = buffer_get_string(& m___0, & len);
#line 230
  pw___0 = (struct passwd *)tmp___0;
#line 231
  if (len != sizeof(struct passwd )) {
#line 232
    fatal("%s: struct passwd size mismatch", "mm_getpwnamallow");
  }
#line 233
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 233
  pw___0->pw_name = (char *)tmp___1;
#line 234
  tmp___2 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 234
  pw___0->pw_passwd = (char *)tmp___2;
#line 235
  tmp___3 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 235
  pw___0->pw_gecos = (char *)tmp___3;
#line 239
  tmp___4 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 239
  pw___0->pw_dir = (char *)tmp___4;
#line 240
  tmp___5 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 240
  pw___0->pw_shell = (char *)tmp___5;
  out: 
#line 244
  tmp___6 = buffer_get_string(& m___0, & len);
#line 244
  newopts = (ServerOptions *)tmp___6;
#line 245
  if (len != sizeof(*newopts)) {
#line 246
    fatal("%s: option block size mismatch", "mm_getpwnamallow");
  }
#line 247
  if ((unsigned int )newopts->banner != (unsigned int )((void *)0)) {
#line 248
    tmp___7 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 248
    newopts->banner = (char *)tmp___7;
  }
#line 249
  copy_set_server_options(& options, newopts, 1);
#line 250
  xfree((void *)newopts);
#line 252
  buffer_free(& m___0);
#line 254
  return (pw___0);
}
}
#line 257 "monitor_wrap.c"
char *mm_auth2_read_banner(void) 
{ Buffer m___0 ;
  char *banner ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 263
  debug3("%s entering", "mm_auth2_read_banner");
#line 265
  buffer_init(& m___0);
#line 266
  mm_request_send(pmonitor->m_recvfd, 8, & m___0);
#line 267
  buffer_clear(& m___0);
#line 269
  mm_request_receive_expect(pmonitor->m_recvfd, 9, & m___0);
#line 271
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 271
  banner = (char *)tmp;
#line 272
  buffer_free(& m___0);
#line 275
  tmp___0 = strlen((char const   *)banner);
#line 275
  if (tmp___0 == 0U) {
#line 276
    xfree((void *)banner);
#line 277
    banner = (char *)((void *)0);
  }
#line 279
  return (banner);
}
}
#line 284 "monitor_wrap.c"
void mm_inform_authserv(char *service , char *style ) 
{ Buffer m___0 ;
  char const   *tmp ;

  {
#line 289
  debug3("%s entering", "mm_inform_authserv");
#line 291
  buffer_init(& m___0);
#line 292
  buffer_put_cstring(& m___0, (char const   *)service);
#line 293
  if (style) {
#line 293
    tmp = (char const   *)style;
  } else {
#line 293
    tmp = "";
  }
#line 293
  buffer_put_cstring(& m___0, tmp);
#line 295
  mm_request_send(pmonitor->m_recvfd, 3, & m___0);
#line 297
  buffer_free(& m___0);
#line 298
  return;
}
}
#line 301 "monitor_wrap.c"
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) 
{ Buffer m___0 ;
  int authenticated ;
  u_int tmp ;
  char const   *tmp___0 ;

  {
#line 305
  authenticated = 0;
#line 307
  debug3("%s entering", "mm_auth_password");
#line 309
  buffer_init(& m___0);
#line 310
  buffer_put_cstring(& m___0, (char const   *)password);
#line 311
  mm_request_send(pmonitor->m_recvfd, 10, & m___0);
#line 313
  debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", "mm_auth_password");
#line 314
  mm_request_receive_expect(pmonitor->m_recvfd, 11, & m___0);
#line 316
  tmp = buffer_get_int(& m___0);
#line 316
  authenticated = (int )tmp;
#line 318
  buffer_free(& m___0);
#line 320
  if (authenticated) {
#line 320
    tmp___0 = "";
  } else {
#line 320
    tmp___0 = "not ";
  }
#line 320
  debug3("%s: user %sauthenticated", "mm_auth_password", tmp___0);
#line 322
  return (authenticated);
}
}
#line 325 "monitor_wrap.c"
int mm_user_key_allowed(struct passwd *pw___0 , Key *key ) 
{ int tmp ;

  {
#line 328
  tmp = mm_key_allowed(2, (char *)((void *)0), (char *)((void *)0), key);
#line 328
  return (tmp);
}
}
#line 331 "monitor_wrap.c"
int mm_hostbased_key_allowed(struct passwd *pw___0 , char *user , char *host , Key *key ) 
{ int tmp ;

  {
#line 335
  tmp = mm_key_allowed(1, user, host, key);
#line 335
  return (tmp);
}
}
#line 338 "monitor_wrap.c"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *user , char *host ,
                                   Key *key ) 
{ int ret___0 ;

  {
#line 344
  key->type = 1;
#line 345
  ret___0 = mm_key_allowed(3, user, host, key);
#line 346
  key->type = 0;
#line 347
  return (ret___0);
}
}
#line 350 "monitor_wrap.c"
static void mm_send_debug(Buffer *m___0 ) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 355
  while (1) {
#line 355
    tmp___0 = buffer_len(m___0);
#line 355
    if (! tmp___0) {
#line 355
      break;
    }
#line 356
    tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 356
    msg = (char *)tmp;
#line 357
    debug3("%s: Sending debug: %s", "mm_send_debug", msg);
#line 358
    packet_send_debug("%s", msg);
#line 359
    xfree((void *)msg);
  }
#line 361
  return;
}
}
#line 363 "monitor_wrap.c"
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int allowed ;
  int have_forced ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;

  {
#line 369
  allowed = 0;
#line 369
  have_forced = 0;
#line 371
  debug3("%s entering", "mm_key_allowed");
#line 374
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 374
  if (! tmp) {
#line 375
    return (0);
  }
#line 377
  buffer_init(& m___0);
#line 378
  buffer_put_int(& m___0, (unsigned int )type);
#line 379
  if (user) {
#line 379
    tmp___0 = (char const   *)user;
  } else {
#line 379
    tmp___0 = "";
  }
#line 379
  buffer_put_cstring(& m___0, tmp___0);
#line 380
  if (host) {
#line 380
    tmp___1 = (char const   *)host;
  } else {
#line 380
    tmp___1 = "";
  }
#line 380
  buffer_put_cstring(& m___0, tmp___1);
#line 381
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 382
  xfree((void *)blob);
#line 384
  mm_request_send(pmonitor->m_recvfd, 20, & m___0);
#line 386
  debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", "mm_key_allowed");
#line 387
  mm_request_receive_expect(pmonitor->m_recvfd, 21, & m___0);
#line 389
  tmp___2 = buffer_get_int(& m___0);
#line 389
  allowed = (int )tmp___2;
#line 392
  auth_clear_options();
#line 393
  tmp___3 = buffer_get_int(& m___0);
#line 393
  have_forced = (int )tmp___3;
#line 394
  if (have_forced) {
#line 394
    forced_command = xstrdup("true");
  } else {
#line 394
    forced_command = (char *)((void *)0);
  }
#line 397
  mm_send_debug(& m___0);
#line 399
  buffer_free(& m___0);
#line 401
  return (allowed);
}
}
#line 410 "monitor_wrap.c"
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int verified ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 416
  verified = 0;
#line 418
  debug3("%s entering", "mm_key_verify");
#line 421
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 421
  if (! tmp) {
#line 422
    return (0);
  }
#line 424
  buffer_init(& m___0);
#line 425
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 426
  buffer_put_string(& m___0, (void const   *)sig, siglen);
#line 427
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 428
  xfree((void *)blob);
#line 430
  mm_request_send(pmonitor->m_recvfd, 22, & m___0);
#line 432
  debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", "mm_key_verify");
#line 433
  mm_request_receive_expect(pmonitor->m_recvfd, 23, & m___0);
#line 435
  tmp___0 = buffer_get_int(& m___0);
#line 435
  verified = (int )tmp___0;
#line 437
  buffer_free(& m___0);
#line 439
  return (verified);
}
}
#line 443 "monitor_wrap.c"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) 
{ Buffer b ;
  u_int len ;
  Newkeys *newkey ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  void *tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Cipher *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;

  {
#line 448
  newkey = (Newkeys *)((void *)0);
#line 453
  debug3("%s: %p(%d)", "mm_newkeys_from_blob", blob, blen);
#line 457
  buffer_init(& b);
#line 458
  buffer_append(& b, (void const   *)blob, (unsigned int )blen);
#line 460
  tmp = xmalloc(sizeof(*newkey));
#line 460
  newkey = (Newkeys *)tmp;
#line 461
  enc = & newkey->enc;
#line 462
  mac = & newkey->mac;
#line 463
  comp = & newkey->comp;
#line 466
  tmp___0 = buffer_get_string(& b, (u_int *)((void *)0));
#line 466
  enc->name = (char *)tmp___0;
#line 467
  buffer_get(& b, (void *)(& enc->cipher), sizeof(enc->cipher));
#line 468
  tmp___1 = buffer_get_int(& b);
#line 468
  enc->enabled = (int )tmp___1;
#line 469
  enc->block_size = buffer_get_int(& b);
#line 470
  tmp___2 = buffer_get_string(& b, & enc->key_len);
#line 470
  enc->key = (u_char *)tmp___2;
#line 471
  tmp___3 = buffer_get_string(& b, & len);
#line 471
  enc->iv = (u_char *)tmp___3;
#line 472
  if (len != enc->block_size) {
#line 473
    fatal("%s: bad ivlen: expected %u != %u", "mm_newkeys_from_blob", enc->block_size,
          len);
  }
#line 476
  if ((unsigned int )enc->name == (unsigned int )((void *)0)) {
#line 477
    fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
          enc->cipher);
  } else {
#line 476
    tmp___4 = cipher_by_name((char const   *)enc->name);
#line 476
    if ((unsigned int )tmp___4 != (unsigned int )enc->cipher) {
#line 477
      fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
            enc->cipher);
    }
  }
#line 481
  tmp___5 = buffer_get_string(& b, (u_int *)((void *)0));
#line 481
  mac->name = (char *)tmp___5;
#line 482
  if ((unsigned int )mac->name == (unsigned int )((void *)0)) {
#line 483
    fatal("%s: can not setup mac %s", "mm_newkeys_from_blob", mac->name);
  } else {
#line 482
    tmp___6 = mac_setup(mac, mac->name);
#line 482
    if (tmp___6 == -1) {
#line 483
      fatal("%s: can not setup mac %s", "mm_newkeys_from_blob", mac->name);
    }
  }
#line 484
  tmp___7 = buffer_get_int(& b);
#line 484
  mac->enabled = (int )tmp___7;
#line 485
  tmp___8 = buffer_get_string(& b, & len);
#line 485
  mac->key = (u_char *)tmp___8;
#line 486
  if (len > mac->key_len) {
#line 487
    fatal("%s: bad mac key length: %u > %d", "mm_newkeys_from_blob", len, mac->key_len);
  }
#line 489
  mac->key_len = len;
#line 492
  tmp___9 = buffer_get_int(& b);
#line 492
  comp->type = (int )tmp___9;
#line 493
  tmp___10 = buffer_get_int(& b);
#line 493
  comp->enabled = (int )tmp___10;
#line 494
  tmp___11 = buffer_get_string(& b, (u_int *)((void *)0));
#line 494
  comp->name = (char *)tmp___11;
#line 496
  len = buffer_len(& b);
#line 497
  if (len != 0U) {
#line 498
    error("newkeys_from_blob: remaining bytes in blob %u", len);
  }
#line 499
  buffer_free(& b);
#line 500
  return (newkey);
}
}
#line 503 "monitor_wrap.c"
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  Newkeys *newkey ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 511
  newkey = newkeys[mode];
#line 513
  debug3("%s: converting %p", "mm_newkeys_to_blob", newkey);
#line 515
  if ((unsigned int )newkey == (unsigned int )((void *)0)) {
#line 516
    error("%s: newkey == NULL", "mm_newkeys_to_blob");
#line 517
    return (0);
  }
#line 519
  enc = & newkey->enc;
#line 520
  mac = & newkey->mac;
#line 521
  comp = & newkey->comp;
#line 523
  buffer_init(& b);
#line 525
  buffer_put_cstring(& b, (char const   *)enc->name);
#line 527
  buffer_append(& b, (void const   *)(& enc->cipher), sizeof(enc->cipher));
#line 528
  buffer_put_int(& b, (unsigned int )enc->enabled);
#line 529
  buffer_put_int(& b, enc->block_size);
#line 530
  buffer_put_string(& b, (void const   *)enc->key, enc->key_len);
#line 531
  packet_get_keyiv(mode, enc->iv, enc->block_size);
#line 532
  buffer_put_string(& b, (void const   *)enc->iv, enc->block_size);
#line 535
  buffer_put_cstring(& b, (char const   *)mac->name);
#line 536
  buffer_put_int(& b, (unsigned int )mac->enabled);
#line 537
  buffer_put_string(& b, (void const   *)mac->key, mac->key_len);
#line 540
  buffer_put_int(& b, (unsigned int )comp->type);
#line 541
  buffer_put_int(& b, (unsigned int )comp->enabled);
#line 542
  buffer_put_cstring(& b, (char const   *)comp->name);
#line 544
  tmp = buffer_len(& b);
#line 544
  len = (int )tmp;
#line 545
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 546
    *lenp = (unsigned int )len;
  }
#line 547
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 548
    tmp___0 = xmalloc((unsigned int )len);
#line 548
    *blobp = (u_char *)tmp___0;
#line 549
    tmp___1 = buffer_ptr(& b);
#line 549
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___1, (unsigned int )len);
  }
#line 551
  tmp___2 = buffer_ptr(& b);
#line 551
  memset(tmp___2, 0, (unsigned int )len);
#line 552
  buffer_free(& b);
#line 553
  return (len);
}
}
#line 556 "monitor_wrap.c"
static void mm_send_kex(Buffer *m___0 , Kex *kex ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 559
  buffer_put_string(m___0, (void const   *)kex->session_id, kex->session_id_len);
#line 560
  buffer_put_int(m___0, kex->we_need);
#line 561
  buffer_put_int(m___0, (unsigned int )kex->hostkey_type);
#line 562
  buffer_put_int(m___0, (unsigned int )kex->kex_type);
#line 563
  tmp = buffer_len(& kex->my);
#line 563
  tmp___0 = buffer_ptr(& kex->my);
#line 563
  buffer_put_string(m___0, (void const   *)tmp___0, tmp);
#line 564
  tmp___1 = buffer_len(& kex->peer);
#line 564
  tmp___2 = buffer_ptr(& kex->peer);
#line 564
  buffer_put_string(m___0, (void const   *)tmp___2, tmp___1);
#line 565
  buffer_put_int(m___0, (unsigned int )kex->flags);
#line 566
  buffer_put_cstring(m___0, (char const   *)kex->client_version_string);
#line 567
  buffer_put_cstring(m___0, (char const   *)kex->server_version_string);
#line 568
  return;
}
}
#line 570 "monitor_wrap.c"
void mm_send_keystate(struct monitor *monitor ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_int64_t bytes ;
  u_char iv[24] ;
  u_char *key ;
  u_int ivlen ;
  u_int keylen ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  u_int tmp___12 ;
  void *tmp___13 ;

  {
#line 579
  buffer_init(& m___0);
#line 581
  if (! compat20) {
#line 586
    tmp = packet_get_protocol_flags();
#line 586
    buffer_put_int(& m___0, tmp);
#line 588
    tmp___0 = packet_get_ssh1_cipher();
#line 588
    buffer_put_int(& m___0, (unsigned int )tmp___0);
#line 590
    debug3("%s: Sending ssh1 KEY+IV", "mm_send_keystate");
#line 591
    keylen = packet_get_encryption_key((u_char *)((void *)0));
#line 592
    tmp___1 = xmalloc(keylen + 1U);
#line 592
    key = (u_char *)tmp___1;
#line 593
    keylen = packet_get_encryption_key(key);
#line 594
    buffer_put_string(& m___0, (void const   *)key, keylen);
#line 595
    memset((void *)key, 0, keylen);
#line 596
    xfree((void *)key);
#line 598
    tmp___2 = packet_get_keyiv_len(1);
#line 598
    ivlen = (unsigned int )tmp___2;
#line 599
    packet_get_keyiv(1, iv, ivlen);
#line 600
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
#line 601
    tmp___3 = packet_get_keyiv_len(1);
#line 601
    ivlen = (unsigned int )tmp___3;
#line 602
    packet_get_keyiv(0, iv, ivlen);
#line 603
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
    goto skip;
  } else {
#line 607
    mm_send_kex(& m___0, *(monitor->m_pkex));
  }
#line 610
  debug3("%s: Sending new keys: %p %p", "mm_send_keystate", newkeys[1], newkeys[0]);
#line 614
  tmp___4 = mm_newkeys_to_blob(1, & blob, & bloblen);
#line 614
  if (! tmp___4) {
#line 615
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 617
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 618
  xfree((void *)blob);
#line 620
  tmp___5 = mm_newkeys_to_blob(0, & blob, & bloblen);
#line 620
  if (! tmp___5) {
#line 621
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 623
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 624
  xfree((void *)blob);
#line 626
  packet_get_state(1, & seqnr, & blocks, & packets, & bytes);
#line 627
  buffer_put_int(& m___0, seqnr);
#line 628
  buffer_put_int64(& m___0, blocks);
#line 629
  buffer_put_int(& m___0, packets);
#line 630
  buffer_put_int64(& m___0, bytes);
#line 631
  packet_get_state(0, & seqnr, & blocks, & packets, & bytes);
#line 632
  buffer_put_int(& m___0, seqnr);
#line 633
  buffer_put_int64(& m___0, blocks);
#line 634
  buffer_put_int(& m___0, packets);
#line 635
  buffer_put_int64(& m___0, bytes);
#line 637
  debug3("%s: New keys have been sent", "mm_send_keystate");
  skip: 
#line 640
  tmp___6 = packet_get_keycontext(1, (u_char *)((void *)0));
#line 640
  plen = (unsigned int )tmp___6;
#line 641
  tmp___7 = xmalloc(plen + 1U);
#line 641
  p = (u_char *)tmp___7;
#line 642
  packet_get_keycontext(1, p);
#line 643
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 644
  xfree((void *)p);
#line 646
  tmp___8 = packet_get_keycontext(0, (u_char *)((void *)0));
#line 646
  plen = (unsigned int )tmp___8;
#line 647
  tmp___9 = xmalloc(plen + 1U);
#line 647
  p = (u_char *)tmp___9;
#line 648
  packet_get_keycontext(0, p);
#line 649
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 650
  xfree((void *)p);
#line 653
  debug3("%s: Sending compression state", "mm_send_keystate");
#line 654
  buffer_put_string(& m___0, (void const   *)(& outgoing_stream), sizeof(outgoing_stream));
#line 655
  buffer_put_string(& m___0, (void const   *)(& incoming_stream), sizeof(incoming_stream));
#line 658
  tmp___10 = buffer_len(& input);
#line 658
  tmp___11 = buffer_ptr(& input);
#line 658
  buffer_put_string(& m___0, (void const   *)tmp___11, tmp___10);
#line 659
  tmp___12 = buffer_len(& output);
#line 659
  tmp___13 = buffer_ptr(& output);
#line 659
  buffer_put_string(& m___0, (void const   *)tmp___13, tmp___12);
#line 661
  mm_request_send(monitor->m_recvfd, 24, & m___0);
#line 662
  debug3("%s: Finished sending state", "mm_send_keystate");
#line 664
  buffer_free(& m___0);
#line 665
  return;
}
}
#line 667 "monitor_wrap.c"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) 
{ Buffer m___0 ;
  char *p ;
  char *msg ;
  int success ;
  int tmp1 ;
  int tmp2 ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 672
  success = 0;
#line 672
  tmp1 = -1;
#line 672
  tmp2 = -1;
#line 675
  tmp1 = dup(pmonitor->m_recvfd);
#line 675
  if (tmp1 == -1) {
    goto _L;
  } else {
#line 675
    tmp2 = dup(pmonitor->m_recvfd);
#line 675
    if (tmp2 == -1) {
      _L: /* CIL Label */ 
#line 677
      error("%s: cannot allocate fds for pty", "mm_pty_allocate");
#line 678
      if (tmp1 > 0) {
#line 679
        close(tmp1);
      }
#line 680
      if (tmp2 > 0) {
#line 681
        close(tmp2);
      }
#line 682
      return (0);
    }
  }
#line 684
  close(tmp1);
#line 685
  close(tmp2);
#line 687
  buffer_init(& m___0);
#line 688
  mm_request_send(pmonitor->m_recvfd, 25, & m___0);
#line 690
  debug3("%s: waiting for MONITOR_ANS_PTY", "mm_pty_allocate");
#line 691
  mm_request_receive_expect(pmonitor->m_recvfd, 26, & m___0);
#line 693
  tmp = buffer_get_int(& m___0);
#line 693
  success = (int )tmp;
#line 694
  if (success == 0) {
#line 695
    debug3("%s: pty alloc failed", "mm_pty_allocate");
#line 696
    buffer_free(& m___0);
#line 697
    return (0);
  }
#line 699
  tmp___0 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 699
  p = (char *)tmp___0;
#line 700
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 700
  msg = (char *)tmp___1;
#line 701
  buffer_free(& m___0);
#line 703
  strlcpy(namebuf, (char const   *)p, namebuflen);
#line 704
  xfree((void *)p);
#line 706
  tmp___2 = strlen((char const   *)msg);
#line 706
  buffer_append(& loginmsg, (void const   *)msg, tmp___2);
#line 707
  xfree((void *)msg);
#line 709
  *ptyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 709
  if (*ptyfd == -1) {
#line 711
    fatal("%s: receive fds failed", "mm_pty_allocate");
  } else {
#line 709
    *ttyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 709
    if (*ttyfd == -1) {
#line 711
      fatal("%s: receive fds failed", "mm_pty_allocate");
    }
  }
#line 714
  return (1);
}
}
#line 717 "monitor_wrap.c"
void mm_session_pty_cleanup2(struct Session *s ) 
{ Buffer m___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 722
  if (s->ttyfd == -1) {
#line 723
    return;
  }
#line 724
  buffer_init(& m___0);
#line 725
  buffer_put_cstring(& m___0, (char const   *)(s->tty));
#line 726
  mm_request_send(pmonitor->m_recvfd, 27, & m___0);
#line 727
  buffer_free(& m___0);
#line 730
  if (s->ptymaster != -1) {
#line 730
    tmp___1 = close(s->ptymaster);
#line 730
    if (tmp___1 < 0) {
#line 731
      tmp = __errno_location();
#line 731
      tmp___0 = strerror(*tmp);
#line 731
      error("close(s->ptymaster/%d): %s", s->ptymaster, tmp___0);
    }
  }
#line 735
  s->ttyfd = -1;
#line 736
  return;
}
}
#line 872 "monitor_wrap.c"
void mm_terminate(void) 
{ Buffer m___0 ;

  {
#line 877
  buffer_init(& m___0);
#line 878
  mm_request_send(pmonitor->m_recvfd, 58, & m___0);
#line 879
  buffer_free(& m___0);
#line 880
  return;
}
}
#line 882 "monitor_wrap.c"
int mm_ssh1_session_key(BIGNUM *num ) 
{ int rsafail ;
  Buffer m___0 ;
  u_int tmp ;

  {
#line 888
  buffer_init(& m___0);
#line 889
  buffer_put_bignum2(& m___0, (BIGNUM const   *)num);
#line 890
  mm_request_send(pmonitor->m_recvfd, 28, & m___0);
#line 892
  mm_request_receive_expect(pmonitor->m_recvfd, 29, & m___0);
#line 894
  tmp = buffer_get_int(& m___0);
#line 894
  rsafail = (int )tmp;
#line 895
  buffer_get_bignum2(& m___0, num);
#line 897
  buffer_free(& m___0);
#line 899
  return (rsafail);
}
}
#line 902 "monitor_wrap.c"
static void mm_chall_setup(char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                           u_int **echo_on ) 
{ void *tmp ;
  void *tmp___0 ;

  {
#line 906
  *name = xstrdup("");
#line 907
  *infotxt = xstrdup("");
#line 908
  *numprompts = 1U;
#line 909
  tmp = xcalloc(*numprompts, sizeof(char *));
#line 909
  *prompts = (char **)tmp;
#line 910
  tmp___0 = xcalloc(*numprompts, sizeof(u_int ));
#line 910
  *echo_on = (u_int *)tmp___0;
#line 911
  *(*echo_on + 0) = 0U;
#line 912
  return;
}
}
#line 914 "monitor_wrap.c"
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) 
{ Buffer m___0 ;
  u_int success ;
  char *challenge ;
  void *tmp ;

  {
#line 922
  debug3("%s: entering", "mm_bsdauth_query");
#line 924
  buffer_init(& m___0);
#line 925
  mm_request_send(pmonitor->m_recvfd, 12, & m___0);
#line 927
  mm_request_receive_expect(pmonitor->m_recvfd, 13, & m___0);
#line 929
  success = buffer_get_int(& m___0);
#line 930
  if (success == 0U) {
#line 931
    debug3("%s: no challenge", "mm_bsdauth_query");
#line 932
    buffer_free(& m___0);
#line 933
    return (-1);
  }
#line 937
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 937
  challenge = (char *)tmp;
#line 938
  buffer_free(& m___0);
#line 940
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
#line 941
  *(*prompts + 0) = challenge;
#line 943
  debug3("%s: received challenge: %s", "mm_bsdauth_query", challenge);
#line 945
  return (0);
}
}
#line 948 "monitor_wrap.c"
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) 
{ Buffer m___0 ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 954
  debug3("%s: entering", "mm_bsdauth_respond");
#line 955
  if (numresponses != 1U) {
#line 956
    return (-1);
  }
#line 958
  buffer_init(& m___0);
#line 959
  buffer_put_cstring(& m___0, (char const   *)*(responses + 0));
#line 960
  mm_request_send(pmonitor->m_recvfd, 14, & m___0);
#line 962
  mm_request_receive_expect(pmonitor->m_recvfd, 15, & m___0);
#line 965
  tmp = buffer_get_int(& m___0);
#line 965
  authok = (int )tmp;
#line 966
  buffer_free(& m___0);
#line 968
  if (authok == 0) {
#line 968
    tmp___0 = -1;
  } else {
#line 968
    tmp___0 = 0;
  }
#line 968
  return (tmp___0);
}
}
#line 1032 "monitor_wrap.c"
void mm_ssh1_session_id(u_char *session_id___0 ) 
{ Buffer m___0 ;
  int i ;

  {
#line 1038
  debug3("%s entering", "mm_ssh1_session_id");
#line 1040
  buffer_init(& m___0);
#line 1041
  i = 0;
#line 1041
  while (i < 16) {
#line 1042
    buffer_put_char(& m___0, (int )*(session_id___0 + i));
#line 1041
    i ++;
  }
#line 1044
  mm_request_send(pmonitor->m_recvfd, 30, & m___0);
#line 1045
  buffer_free(& m___0);
#line 1046
  return;
}
}
#line 1048 "monitor_wrap.c"
int mm_auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) 
{ Buffer m___0 ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int have_forced ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___2 ;

  {
#line 1055
  allowed = 0;
#line 1055
  have_forced = 0;
#line 1057
  debug3("%s entering", "mm_auth_rsa_key_allowed");
#line 1059
  buffer_init(& m___0);
#line 1060
  buffer_put_bignum2(& m___0, (BIGNUM const   *)client_n);
#line 1062
  mm_request_send(pmonitor->m_recvfd, 31, & m___0);
#line 1063
  mm_request_receive_expect(pmonitor->m_recvfd, 32, & m___0);
#line 1065
  tmp = buffer_get_int(& m___0);
#line 1065
  allowed = (int )tmp;
#line 1068
  auth_clear_options();
#line 1069
  tmp___0 = buffer_get_int(& m___0);
#line 1069
  have_forced = (int )tmp___0;
#line 1070
  if (have_forced) {
#line 1070
    forced_command = xstrdup("true");
  } else {
#line 1070
    forced_command = (char *)((void *)0);
  }
#line 1072
  if (allowed) {
#line 1072
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 1073
      tmp___2 = buffer_get_string(& m___0, & blen);
#line 1073
      blob = (u_char *)tmp___2;
#line 1074
      key = key_from_blob((u_char const   *)blob, blen);
#line 1074
      if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1075
        fatal("%s: key_from_blob failed", "mm_auth_rsa_key_allowed");
      }
#line 1076
      *rkey = key;
#line 1077
      xfree((void *)blob);
    }
  }
#line 1079
  mm_send_debug(& m___0);
#line 1080
  buffer_free(& m___0);
#line 1082
  return (allowed);
}
}
#line 1085 "monitor_wrap.c"
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) 
{ Buffer m___0 ;
  BIGNUM *challenge ;
  u_char *blob ;
  u_int blen ;
  int tmp ;

  {
#line 1093
  debug3("%s entering", "mm_auth_rsa_generate_challenge");
#line 1095
  challenge = BN_new();
#line 1095
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 1096
    fatal("%s: BN_new failed", "mm_auth_rsa_generate_challenge");
  }
#line 1098
  key->type = 1;
#line 1099
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1099
  if (tmp == 0) {
#line 1100
    fatal("%s: key_to_blob failed", "mm_auth_rsa_generate_challenge");
  }
#line 1101
  key->type = 0;
#line 1103
  buffer_init(& m___0);
#line 1104
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1105
  xfree((void *)blob);
#line 1107
  mm_request_send(pmonitor->m_recvfd, 33, & m___0);
#line 1108
  mm_request_receive_expect(pmonitor->m_recvfd, 34, & m___0);
#line 1110
  buffer_get_bignum2(& m___0, challenge);
#line 1111
  buffer_free(& m___0);
#line 1113
  return (challenge);
}
}
#line 1116 "monitor_wrap.c"
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int blen ;
  int success ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 1122
  success = 0;
#line 1124
  debug3("%s entering", "mm_auth_rsa_verify_response");
#line 1126
  key->type = 1;
#line 1127
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1127
  if (tmp == 0) {
#line 1128
    fatal("%s: key_to_blob failed", "mm_auth_rsa_verify_response");
  }
#line 1129
  key->type = 0;
#line 1131
  buffer_init(& m___0);
#line 1132
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1133
  buffer_put_string(& m___0, (void const   *)response, 16U);
#line 1134
  xfree((void *)blob);
#line 1136
  mm_request_send(pmonitor->m_recvfd, 35, & m___0);
#line 1137
  mm_request_receive_expect(pmonitor->m_recvfd, 36, & m___0);
#line 1139
  tmp___0 = buffer_get_int(& m___0);
#line 1139
  success = (int )tmp___0;
#line 1140
  buffer_free(& m___0);
#line 1142
  return (success);
}
}
#line 1 "kexdhs.o"
#pragma merger(0,"./kexdhs.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 48 "kexdhs.c"
void kexdh_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int hashlen ;
  u_int slen ;
  int kout ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  BIGNUM *tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 51
  shared_secret = (BIGNUM *)((void *)0);
#line 51
  dh_client_pub = (BIGNUM *)((void *)0);
#line 54
  signature = (u_char *)((void *)0);
#line 54
  server_host_key_blob = (u_char *)((void *)0);
#line 59
  switch (kex->kex_type) {
  case 0: 
#line 61
  dh = dh_new_group1();
#line 62
  break;
  case 1: 
#line 64
  dh = dh_new_group14();
#line 65
  break;
  default: 
#line 67
  fatal("%s: Unexpected KEX type %d", "kexdh_server", kex->kex_type);
  }
#line 69
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 71
  debug("expecting SSH2_MSG_KEXDH_INIT");
#line 72
  packet_read_expect(30);
#line 74
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 75
    fatal("Cannot load hostkey");
  }
#line 76
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 77
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 78
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 81
  dh_client_pub = BN_new();
#line 81
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 82
    fatal("dh_client_pub == NULL");
  }
#line 83
  packet_get_bignum2(dh_client_pub);
#line 84
  while (1) {
#line 84
    tmp = packet_remaining();
#line 84
    _len = tmp;
#line 84
    if (_len > 0) {
#line 84
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhs.c",
            84);
#line 84
      packet_disconnect("Packet integrity error.");
    }
#line 84
    break;
  }
#line 99
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 99
  if (! tmp___0) {
#line 100
    packet_disconnect("bad client public DH value");
  }
#line 102
  tmp___1 = DH_size((DH const   *)dh);
#line 102
  klen = (unsigned int )tmp___1;
#line 103
  tmp___2 = xmalloc(klen);
#line 103
  kbuf = (u_char *)tmp___2;
#line 104
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 104
  if (kout < 0) {
#line 105
    fatal("DH_compute_key: failed");
  }
#line 109
  shared_secret = BN_new();
#line 109
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 110
    fatal("kexdh_server: BN_new failed");
  }
#line 111
  tmp___3 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 111
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 112
    fatal("kexdh_server: BN_bin2bn failed");
  }
#line 113
  memset((void *)kbuf, 0, klen);
#line 114
  xfree((void *)kbuf);
#line 116
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 119
  tmp___4 = buffer_len(& kex->my);
#line 119
  tmp___5 = buffer_ptr(& kex->my);
#line 119
  tmp___6 = buffer_len(& kex->peer);
#line 119
  tmp___7 = buffer_ptr(& kex->peer);
#line 119
  kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___7,
              (int )tmp___6, (char *)tmp___5, (int )tmp___4, server_host_key_blob,
              (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
#line 130
  BN_clear_free(dh_client_pub);
#line 133
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 134
    kex->session_id_len = hashlen;
#line 135
    tmp___8 = xmalloc(kex->session_id_len);
#line 135
    kex->session_id = (u_char *)tmp___8;
#line 136
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 140
  if (use_privsep) {
#line 140
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
  } else {
#line 140
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
  }
#line 145
  packet_start((unsigned char)31);
#line 146
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 147
  packet_put_bignum2(dh->pub_key);
#line 148
  packet_put_string((void const   *)signature, slen);
#line 149
  packet_send();
#line 151
  xfree((void *)signature);
#line 152
  xfree((void *)server_host_key_blob);
#line 154
  DH_free(dh);
#line 156
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 157
  BN_clear_free(shared_secret);
#line 158
  kex_finish(kex);
#line 159
  return;
}
}
#line 1 "kexgexs.o"
#pragma merger(0,"./kexgexs.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 51 "kexgexs.c"
void kexgex_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int slen ;
  u_int hashlen ;
  int omin ;
  int min ;
  int omax ;
  int max ;
  int onbits ;
  int nbits ;
  int type ;
  int kout ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  BIGNUM *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
#line 54
  shared_secret = (BIGNUM *)((void *)0);
#line 54
  dh_client_pub = (BIGNUM *)((void *)0);
#line 57
  signature = (u_char *)((void *)0);
#line 57
  server_host_key_blob = (u_char *)((void *)0);
#line 59
  omin = -1;
#line 59
  min = -1;
#line 59
  omax = -1;
#line 59
  max = -1;
#line 59
  onbits = -1;
#line 59
  nbits = -1;
#line 62
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 63
    fatal("Cannot load hostkey");
  }
#line 64
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 65
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 66
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 68
  type = packet_read();
#line 69
  switch (type) {
  case 34: 
#line 71
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
#line 72
  tmp = packet_get_int();
#line 72
  min = (int )tmp;
#line 72
  omin = min;
#line 73
  tmp___0 = packet_get_int();
#line 73
  nbits = (int )tmp___0;
#line 73
  onbits = nbits;
#line 74
  tmp___1 = packet_get_int();
#line 74
  max = (int )tmp___1;
#line 74
  omax = max;
#line 75
  if (1024 > min) {
#line 75
    min = 1024;
  } else {
#line 75
    min = min;
  }
#line 76
  if (8192 < max) {
#line 76
    max = 8192;
  } else {
#line 76
    max = max;
  }
#line 77
  if (1024 > nbits) {
#line 77
    nbits = 1024;
  } else {
#line 77
    nbits = nbits;
  }
#line 78
  if (8192 < nbits) {
#line 78
    nbits = 8192;
  } else {
#line 78
    nbits = nbits;
  }
#line 79
  break;
  case 30: 
#line 81
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
#line 82
  tmp___2 = packet_get_int();
#line 82
  nbits = (int )tmp___2;
#line 82
  onbits = nbits;
#line 84
  min = 1024;
#line 84
  omin = min;
#line 85
  max = 8192;
#line 85
  omax = max;
#line 86
  break;
  default: 
#line 88
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
#line 90
  while (1) {
#line 90
    tmp___3 = packet_remaining();
#line 90
    _len = tmp___3;
#line 90
    if (_len > 0) {
#line 90
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexs.c",
            90);
#line 90
      packet_disconnect("Packet integrity error.");
    }
#line 90
    break;
  }
#line 92
  if (omax < omin) {
#line 93
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", omin, onbits, omax);
  } else {
#line 92
    if (onbits < omin) {
#line 93
      fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", omin, onbits, omax);
    } else {
#line 92
      if (omax < onbits) {
#line 93
        fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", omin, onbits, omax);
      }
    }
  }
#line 97
  if (use_privsep) {
#line 97
    dh = mm_choose_dh(min, nbits, max);
  } else {
#line 97
    dh = choose_dh(min, nbits, max);
  }
#line 98
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 99
    packet_disconnect("Protocol error: no matching DH grp found");
  }
#line 101
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
#line 102
  packet_start((unsigned char)31);
#line 103
  packet_put_bignum2(dh->p);
#line 104
  packet_put_bignum2(dh->g);
#line 105
  packet_send();
#line 108
  packet_write_wait();
#line 111
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 113
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
#line 114
  packet_read_expect(32);
#line 117
  dh_client_pub = BN_new();
#line 117
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 118
    fatal("dh_client_pub == NULL");
  }
#line 119
  packet_get_bignum2(dh_client_pub);
#line 120
  while (1) {
#line 120
    tmp___6 = packet_remaining();
#line 120
    _len___0 = tmp___6;
#line 120
    if (_len___0 > 0) {
#line 120
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexs.c",
            120);
#line 120
      packet_disconnect("Packet integrity error.");
    }
#line 120
    break;
  }
#line 135
  tmp___7 = dh_pub_is_valid(dh, dh_client_pub);
#line 135
  if (! tmp___7) {
#line 136
    packet_disconnect("bad client public DH value");
  }
#line 138
  tmp___8 = DH_size((DH const   *)dh);
#line 138
  klen = (unsigned int )tmp___8;
#line 139
  tmp___9 = xmalloc(klen);
#line 139
  kbuf = (u_char *)tmp___9;
#line 140
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 140
  if (kout < 0) {
#line 141
    fatal("DH_compute_key: failed");
  }
#line 145
  shared_secret = BN_new();
#line 145
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 146
    fatal("kexgex_server: BN_new failed");
  }
#line 147
  tmp___10 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 147
  if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
#line 148
    fatal("kexgex_server: BN_bin2bn failed");
  }
#line 149
  memset((void *)kbuf, 0, klen);
#line 150
  xfree((void *)kbuf);
#line 152
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 154
  if (type == 30) {
#line 155
    max = -1;
#line 155
    omax = max;
#line 155
    min = omax;
#line 155
    omin = min;
  }
#line 158
  tmp___11 = buffer_len(& kex->my);
#line 158
  tmp___12 = buffer_ptr(& kex->my);
#line 158
  tmp___13 = buffer_len(& kex->peer);
#line 158
  tmp___14 = buffer_ptr(& kex->peer);
#line 158
  kexgex_hash(kex->evp_md, kex->client_version_string, kex->server_version_string,
              (char *)tmp___14, (int )tmp___13, (char *)tmp___12, (int )tmp___11,
              server_host_key_blob, (int )sbloblen, omin, onbits, omax, dh->p, dh->g,
              dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
#line 172
  BN_clear_free(dh_client_pub);
#line 175
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 176
    kex->session_id_len = hashlen;
#line 177
    tmp___15 = xmalloc(kex->session_id_len);
#line 177
    kex->session_id = (u_char *)tmp___15;
#line 178
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 182
  if (use_privsep) {
#line 182
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
  } else {
#line 182
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
  }
#line 187
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
#line 188
  packet_start((unsigned char)33);
#line 189
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 190
  packet_put_bignum2(dh->pub_key);
#line 191
  packet_put_string((void const   *)signature, slen);
#line 192
  packet_send();
#line 194
  xfree((void *)signature);
#line 195
  xfree((void *)server_host_key_blob);
#line 197
  DH_free(dh);
#line 199
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 200
  BN_clear_free(shared_secret);
#line 202
  kex_finish(kex);
#line 203
  return;
}
}
#line 1 "auth-krb5.o"
#pragma merger(0,"./auth-krb5.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth2-gss.o"
#pragma merger(0,"./auth2-gss.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "gss-serv.o"
#pragma merger(0,"./gss-serv.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "gss-serv-krb5.o"
#pragma merger(0,"./gss-serv-krb5.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "loginrec.o"
#pragma merger(0,"./loginrec.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 94 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 97
void login_set_current_time(struct logininfo *li ) ;
#line 109
int login_write(struct logininfo *li ) ;
#line 122
unsigned int login_get_lastlog_time(int uid ) ;
#line 125
char *line_fullname(char *dst , char const   *src , u_int dstsize ) ;
#line 126
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 127
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 192 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 193
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 205
int lastlog_write_entry(struct logininfo *li ) ;
#line 206
int syslogin_write_entry(struct logininfo *li ) ;
#line 208
int getlast_entry(struct logininfo *li ) ;
#line 209
int lastlog_get_entry(struct logininfo *li ) ;
#line 232 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 235
  li->type = (short)7;
#line 236
  tmp = login_write(li);
#line 236
  return (tmp);
}
}
#line 249 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 252
  li->type = (short)8;
#line 253
  tmp = login_write(li);
#line 253
  return (tmp);
}
}
#line 274 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 279
  tmp = login_get_lastlog(& li, uid);
#line 279
  if (tmp) {
#line 280
    return (li.tv_sec);
  } else {
#line 282
    return (0U);
  }
}
}
#line 298 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw___0 ;
  int tmp ;

  {
#line 303
  memset((void *)li, '\000', sizeof(*li));
#line 304
  li->uid = uid;
#line 311
  pw___0 = getpwuid((unsigned int )uid);
#line 312
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 313
    fatal("%s: Cannot find account for uid %i", "login_get_lastlog", uid);
  }
#line 317
  strlcpy(li->username, (char const   *)pw___0->pw_name, sizeof(li->username));
#line 319
  tmp = getlast_entry(li);
#line 319
  if (tmp) {
#line 320
    return (li);
  } else {
#line 322
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 336 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 342
  tmp = xmalloc(sizeof(*newli));
#line 342
  newli = (struct logininfo *)tmp;
#line 343
  login_init_entry(newli, pid, username, hostname, line);
#line 344
  return (newli);
}
}
#line 349 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 352
  xfree((void *)li);
#line 353
  return;
}
}
#line 364 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw___0 ;

  {
#line 370
  memset((void *)li, 0, sizeof(*li));
#line 372
  li->pid = pid;
#line 375
  if (line) {
#line 376
    line_fullname(li->line, line, sizeof(li->line));
  }
#line 378
  if (username) {
#line 379
    strlcpy(li->username, username, sizeof(li->username));
#line 380
    pw___0 = getpwnam((char const   *)(li->username));
#line 381
    if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 382
      fatal("%s: Cannot find user \"%s\"", "login_init_entry", li->username);
    }
#line 385
    li->uid = (int )pw___0->pw_uid;
  }
#line 388
  if (hostname) {
#line 389
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 391
  return (1);
}
}
#line 401 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv___0 ;

  {
#line 406
  gettimeofday((struct timeval * __restrict  )(& tv___0), (struct timezone * __restrict  )((void *)0));
#line 408
  li->tv_sec = (unsigned int )tv___0.tv_sec;
#line 409
  li->tv_usec = (unsigned int )tv___0.tv_usec;
#line 410
  return;
}
}
#line 413 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 417
  bufsize = sa_size;
#line 420
  if (sizeof(li->hostaddr) < sa_size) {
#line 421
    bufsize = sizeof(li->hostaddr);
  }
#line 423
  memcpy((void * __restrict  )(& li->hostaddr.sa), (void const   * __restrict  )sa,
         bufsize);
#line 424
  return;
}
}
#line 431 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 435
  tmp = geteuid();
#line 435
  if (tmp != 0U) {
#line 436
    logit("Attempt to write login records by non-root user (aborting)");
#line 437
    return (1);
  }
#line 442
  login_set_current_time(li);
#line 444
  syslogin_write_entry(li);
#line 447
  if ((int )li->type == 7) {
#line 448
    lastlog_write_entry(li);
  }
#line 474
  return (0);
}
}
#line 505 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 509
  tmp = lastlog_get_entry(li);
#line 509
  return (tmp);
}
}
#line 554 "loginrec.c"
char *line_fullname(char *dst , char const   *src , u_int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 557
  memset((void *)dst, '\000', dstsize);
#line 558
  if (0) {
#line 558
    if (0) {
#line 558
      __s1_len___0 = strlen(src);
#line 558
      __s2_len___0 = strlen("/dev/");
#line 558
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 558
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 558
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 558
            tmp___22 = 1;
          } else {
#line 558
            if (__s2_len___0 >= 4U) {
#line 558
              tmp___22 = 1;
            } else {
#line 558
              tmp___22 = 0;
            }
          }
        } else {
#line 558
          tmp___22 = 0;
        }
      }
#line 558
      if (tmp___22) {
#line 558
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 558
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 558
        tmp___18 = tmp___21;
      }
    } else {
#line 558
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 558
      tmp___18 = tmp___21;
    }
#line 558
    tmp___12 = tmp___18;
  } else {
#line 558
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 558
  if (tmp___12 == 0) {
#line 559
    strlcpy(dst, src, dstsize);
  } else {
#line 558
    tmp___25 = strlen(src);
#line 558
    if (dstsize < tmp___25 + 5U) {
#line 559
      strlcpy(dst, src, dstsize);
    } else {
#line 561
      strlcpy(dst, "/dev/", dstsize);
#line 562
      strlcat(dst, src, dstsize);
    }
  }
#line 564
  return (dst);
}
}
#line 568 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 571
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 572
  if (0) {
#line 572
    if (0) {
#line 572
      __s1_len___0 = strlen(src);
#line 572
      __s2_len___0 = strlen("/dev/");
#line 572
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 572
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 572
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 572
            tmp___22 = 1;
          } else {
#line 572
            if (__s2_len___0 >= 4U) {
#line 572
              tmp___22 = 1;
            } else {
#line 572
              tmp___22 = 0;
            }
          }
        } else {
#line 572
          tmp___22 = 0;
        }
      }
#line 572
      if (tmp___22) {
#line 572
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 572
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 572
        tmp___18 = tmp___21;
      }
    } else {
#line 572
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 572
      tmp___18 = tmp___21;
    }
#line 572
    tmp___12 = tmp___18;
  } else {
#line 572
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 572
  if (tmp___12 == 0) {
#line 573
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 575
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 576
  return (dst);
}
}
#line 587 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 592
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 595
  if (0) {
#line 595
    if (0) {
#line 595
      __s1_len___0 = strlen(src);
#line 595
      __s2_len___0 = strlen("/dev/");
#line 595
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 595
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 595
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 595
            tmp___22 = 1;
          } else {
#line 595
            if (__s2_len___0 >= 4U) {
#line 595
              tmp___22 = 1;
            } else {
#line 595
              tmp___22 = 0;
            }
          }
        } else {
#line 595
          tmp___22 = 0;
        }
      }
#line 595
      if (tmp___22) {
#line 595
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 595
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 595
        tmp___18 = tmp___21;
      }
    } else {
#line 595
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 595
      tmp___18 = tmp___21;
    }
#line 595
    tmp___12 = tmp___18;
  } else {
#line 595
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 595
  if (tmp___12 == 0) {
#line 596
    src += 5;
  }
#line 603
  len = strlen(src);
#line 605
  if (len > 0U) {
#line 606
    if ((int )len - dstsize > 0) {
#line 607
      src += (int )len - dstsize;
    }
#line 610
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 613
  return (dst);
}
}
#line 626 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 630
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 631
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 635
  return;
}
}
#line 637 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ struct sockaddr_in6 *sa6 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 645
  memset((void *)ut, '\000', sizeof(*ut));
#line 650
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 655
  switch ((int )li->type) {
  case 7: 
#line 657
  ut->ut_type = (short)7;
#line 661
  break;
  case 8: 
#line 663
  ut->ut_type = (short)8;
#line 667
  break;
  }
#line 670
  set_utmp_time(li, ut);
#line 672
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 675
  ut->ut_pid = li->pid;
#line 679
  if ((int )li->type == 8) {
#line 680
    return;
  }
#line 688
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 688
    tmp = sizeof(ut->ut_user);
  } else {
#line 688
    tmp = sizeof(li->username);
  }
#line 688
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 691
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 691
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 691
    tmp___0 = sizeof(li->hostname);
  }
#line 691
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 696
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 697
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 701
  if ((int )li->hostaddr.sa.sa_family == 10) {
#line 702
    sa6 = (struct sockaddr_in6 *)(& li->hostaddr.sa);
#line 703
    memcpy((void * __restrict  )(ut->ut_addr_v6), (void const   * __restrict  )(sa6->sin6_addr.in6_u.u6_addr8),
           16U);
#line 704
    if (*((uint32_t const   *)(& sa6->sin6_addr) + 0) == 0U) {
#line 704
      if (*((uint32_t const   *)(& sa6->sin6_addr) + 1) == 0U) {
#line 704
        __x = 65535U;
#line 704
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 704
        if (*((uint32_t const   *)(& sa6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 705
          ut->ut_addr_v6[0] = ut->ut_addr_v6[3];
#line 706
          ut->ut_addr_v6[1] = 0;
#line 707
          ut->ut_addr_v6[2] = 0;
#line 708
          ut->ut_addr_v6[3] = 0;
        }
      }
    }
  }
#line 712
  return;
}
}
#line 1402 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1407
  tmp = xmalloc(sizeof(*ut));
#line 1407
  ut = (struct utmp *)tmp;
#line 1408
  construct_utmp(li, ut);
#line 1409
  login((struct utmp  const  *)ut);
#line 1410
  free((void *)ut);
#line 1412
  return (1);
}
}
#line 1415 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[32] ;
  int tmp ;

  {
#line 1421
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1423
  tmp = logout((char const   *)(line));
#line 1423
  if (tmp) {
#line 1427
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1424
    logit("%s: logout() returned an error", "syslogin_perform_logout");
  }
#line 1434
  return (1);
}
}
#line 1437 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1440
  switch ((int )li->type) {
  case 7: 
#line 1442
  tmp = syslogin_perform_login(li);
#line 1442
  return (tmp);
  case 8: 
#line 1444
  tmp___0 = syslogin_perform_logout(li);
#line 1444
  return (tmp___0);
  default: 
#line 1446
  logit("%s: Invalid type field", "syslogin_write_entry");
#line 1447
  return (0);
  }
}
}
#line 1462 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  char lastlog_file[1024] ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __off64_t tmp___6 ;

  {
#line 1469
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1469
  if (tmp___1 != 0) {
#line 1470
    tmp = __errno_location();
#line 1470
    tmp___0 = strerror(*tmp);
#line 1470
    logit("%s: Couldn\'t stat %s: %s", "lastlog_openseek", "/var/log/lastlog", tmp___0);
#line 1472
    return (0);
  }
#line 1474
  if ((st.st_mode & 61440U) == 16384U) {
#line 1475
    snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
             "/var/log/lastlog", li->username);
  } else {
#line 1477
    if ((st.st_mode & 61440U) == 32768U) {
#line 1478
      strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
    } else {
#line 1480
      logit("%s: %.100s is not a file or directory!", "lastlog_openseek", "/var/log/lastlog");
#line 1482
      return (0);
    }
  }
#line 1485
  *fd = open((char const   *)(lastlog_file), filemode, 384);
#line 1486
  if (*fd < 0) {
#line 1487
    tmp___2 = __errno_location();
#line 1487
    tmp___3 = strerror(*tmp___2);
#line 1487
    debug("%s: Couldn\'t open %s: %s", "lastlog_openseek", lastlog_file, tmp___3);
#line 1489
    return (0);
  }
#line 1492
  if ((st.st_mode & 61440U) == 32768U) {
#line 1494
    offset = (long long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1496
    tmp___6 = lseek(*fd, offset, 0);
#line 1496
    if (tmp___6 != offset) {
#line 1497
      tmp___4 = __errno_location();
#line 1497
      tmp___5 = strerror(*tmp___4);
#line 1497
      logit("%s: %s->lseek(): %s", "lastlog_openseek", lastlog_file, tmp___5);
#line 1499
      return (0);
    }
  }
#line 1503
  return (1);
}
}
#line 1520 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  unsigned int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
#line 1526
  switch ((int )li->type) {
  case 7: 
#line 1529
  memset((void *)(& last), '\000', sizeof(last));
#line 1530
  line_stripname(last.ll_line, (char const   *)(li->line), (int )sizeof(last.ll_line));
#line 1531
  if (sizeof(last.ll_host) < sizeof(li->hostname)) {
#line 1531
    tmp = sizeof(last.ll_host);
  } else {
#line 1531
    tmp = sizeof(li->hostname);
  }
#line 1531
  strlcpy(last.ll_host, (char const   *)(li->hostname), tmp);
#line 1533
  last.ll_time = (long )li->tv_sec;
#line 1535
  tmp___0 = lastlog_openseek(li, & fd, 66);
#line 1535
  if (! tmp___0) {
#line 1536
    return (0);
  }
#line 1539
  tmp___3 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& last),
                     sizeof(last));
#line 1539
  if (tmp___3 != sizeof(last)) {
#line 1540
    close(fd);
#line 1541
    tmp___1 = __errno_location();
#line 1541
    tmp___2 = strerror(*tmp___1);
#line 1541
    logit("%s: Error writing to %s: %s", "lastlog_write_entry", "/var/log/lastlog",
          tmp___2);
#line 1543
    return (0);
  }
#line 1546
  close(fd);
#line 1547
  return (1);
  default: 
#line 1549
  logit("%s: Invalid type field", "lastlog_write_entry");
#line 1550
  return (0);
  }
}
}
#line 1573 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int ret___0 ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1579
  tmp = lastlog_openseek(li, & fd, 0);
#line 1579
  if (! tmp) {
#line 1580
    return (0);
  }
#line 1582
  tmp___0 = atomicio(& read, fd, (void *)(& last), sizeof(last));
#line 1582
  ret___0 = (int )tmp___0;
#line 1583
  close(fd);
#line 1585
  switch (ret___0) {
  case 0: 
#line 1587
  memset((void *)(& last), '\000', sizeof(last));
  case sizeof(last): 
#line 1590
  line_fullname(li->line, (char const   *)(last.ll_line), sizeof(li->line));
#line 1591
  if (sizeof(li->hostname) < sizeof(last.ll_host)) {
#line 1591
    tmp___1 = sizeof(li->hostname);
  } else {
#line 1591
    tmp___1 = sizeof(last.ll_host);
  }
#line 1591
  strlcpy(li->hostname, (char const   *)(last.ll_host), tmp___1);
#line 1593
  li->tv_sec = (unsigned int )last.ll_time;
#line 1594
  return (1);
  case -1: 
#line 1596
  tmp___2 = __errno_location();
#line 1596
  tmp___3 = strerror(*tmp___2);
#line 1596
  error("%s: Error reading from %s: %s", "lastlog_get_entry", "/var/log/lastlog",
        tmp___3);
#line 1598
  return (0);
  default: 
#line 1600
  error("%s: Error reading from %s: Expecting %d, got %d", "lastlog_get_entry", "/var/log/lastlog",
        (int )sizeof(last), ret___0);
#line 1602
  return (0);
  }
#line 1606
  return (0);
}
}
#line 1619 "loginrec.c"
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) 
{ int fd ;
  struct utmp ut ;
  struct sockaddr_storage from ;
  socklen_t fromlen ;
  struct sockaddr_in *a4 ;
  struct sockaddr_in6 *a6 ;
  time_t t ;
  struct stat fst ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;

  {
#line 1626
  fromlen = sizeof(from);
#line 1632
  tmp = geteuid();
#line 1632
  if (tmp != 0U) {
#line 1633
    return;
  }
#line 1634
  fd = open("/var/log/btmp", 1025);
#line 1634
  if (fd < 0) {
#line 1635
    tmp___0 = __errno_location();
#line 1635
    tmp___1 = strerror(*tmp___0);
#line 1635
    debug("Unable to open the btmp file %s: %s", "/var/log/btmp", tmp___1);
#line 1637
    return;
  }
#line 1639
  tmp___4 = fstat(fd, & fst);
#line 1639
  if (tmp___4 < 0) {
#line 1640
    tmp___2 = __errno_location();
#line 1640
    tmp___3 = strerror(*tmp___2);
#line 1640
    logit("%s: fstat of %s failed: %s", "record_failed_login", "/var/log/btmp", tmp___3);
    goto out;
  }
#line 1644
  if (fst.st_mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3))) {
#line 1645
    logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
    goto out;
  } else {
#line 1644
    if (fst.st_uid != 0U) {
#line 1645
      logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
      goto out;
    }
  }
#line 1650
  memset((void *)(& ut), 0, sizeof(ut));
#line 1652
  __builtin_strncpy(ut.ut_user, username, sizeof(ut.ut_user));
#line 1653
  strlcpy(ut.ut_line, "ssh:notty", sizeof(ut.ut_line));
#line 1655
  time(& t);
#line 1656
  ut.ut_tv.tv_sec = t;
#line 1657
  ut.ut_type = (short)6;
#line 1658
  ut.ut_pid = getpid();
#line 1661
  __builtin_strncpy(ut.ut_host, hostname, sizeof(ut.ut_host));
#line 1663
  tmp___7 = packet_connection_is_on_socket();
#line 1663
  if (tmp___7) {
#line 1663
    tmp___8 = packet_get_connection_in();
#line 1663
    tmp___9 = getpeername(tmp___8, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1663
    if (tmp___9 == 0) {
#line 1666
      ipv64_normalise_mapped(& from, & fromlen);
#line 1667
      if ((int )from.ss_family == 2) {
#line 1668
        a4 = (struct sockaddr_in *)(& from);
#line 1669
        if (sizeof(ut.ut_addr_v6[0]) < sizeof(a4->sin_addr)) {
#line 1669
          tmp___5 = sizeof(ut.ut_addr_v6[0]);
        } else {
#line 1669
          tmp___5 = sizeof(a4->sin_addr);
        }
#line 1669
        memcpy((void * __restrict  )(& ut.ut_addr_v6[0]), (void const   * __restrict  )(& a4->sin_addr),
               tmp___5);
      }
#line 1673
      if ((int )from.ss_family == 10) {
#line 1674
        a6 = (struct sockaddr_in6 *)(& from);
#line 1675
        if (sizeof(ut.ut_addr_v6) < sizeof(a6->sin6_addr)) {
#line 1675
          tmp___6 = sizeof(ut.ut_addr_v6);
        } else {
#line 1675
          tmp___6 = sizeof(a6->sin6_addr);
        }
#line 1675
        memcpy((void * __restrict  )(& ut.ut_addr_v6), (void const   * __restrict  )(& a6->sin6_addr),
               tmp___6);
      }
    }
  }
#line 1681
  tmp___12 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& ut),
                      sizeof(ut));
#line 1681
  if (tmp___12 != sizeof(ut)) {
#line 1682
    tmp___10 = __errno_location();
#line 1682
    tmp___11 = strerror(*tmp___10);
#line 1682
    error("Failed to write to %s: %s", "/var/log/btmp", tmp___11);
  }
  out: 
#line 1686
  close(fd);
#line 1687
  return;
}
}
#line 1 "auth-pam.o"
#pragma merger(0,"./auth-pam.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "auth-shadow.o"
#pragma merger(0,"./auth-shadow.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 55 "auth-shadow.c"
int auth_shadow_acctexpired(struct spwd *spw ) 
{ time_t today ;
  int daysleft ;
  char buf___1[256] ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 62
  tmp = time((time_t *)((void *)0));
#line 62
  today = tmp / 86400L;
#line 63
  daysleft = (int )(spw->sp_expire - today);
#line 64
  debug3("%s: today %d sp_expire %d days left %d", "auth_shadow_acctexpired", (int )today,
         (int )spw->sp_expire, daysleft);
#line 67
  if (spw->sp_expire == -1L) {
#line 68
    debug3("account expiration disabled");
  } else {
#line 69
    if (daysleft < 0) {
#line 70
      logit("Account %.100s has expired", spw->sp_namp);
#line 71
      return (1);
    } else {
#line 72
      if ((long )daysleft <= spw->sp_warn) {
#line 73
        debug3("account will expire in %d days", daysleft);
#line 74
        if (daysleft == 1) {
#line 74
          tmp___0 = "";
        } else {
#line 74
          tmp___0 = "s";
        }
#line 74
        snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your account will expire in %d day%s.\n",
                 daysleft, tmp___0);
#line 77
        tmp___1 = strlen((char const   *)(buf___1));
#line 77
        buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
      }
    }
  }
#line 80
  return (0);
}
}
#line 87 "auth-shadow.c"
int auth_shadow_pwexpired(Authctxt *ctxt ) 
{ struct spwd *spw ;
  char const   *user ;
  char buf___1[256] ;
  time_t today ;
  int daysleft ;
  int disabled ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 90
  spw = (struct spwd *)((void *)0);
#line 91
  user = (char const   *)(ctxt->pw)->pw_name;
#line 94
  disabled = 0;
#line 96
  spw = getspnam((char const   *)((char *)user));
#line 96
  if ((unsigned int )spw == (unsigned int )((void *)0)) {
#line 97
    error("Could not get shadow information for %.100s", user);
#line 98
    return (0);
  }
#line 101
  tmp = time((time_t *)((void *)0));
#line 101
  today = tmp / 86400L;
#line 102
  debug3("%s: today %d sp_lstchg %d sp_max %d", "auth_shadow_pwexpired", (int )today,
         (int )spw->sp_lstchg, (int )spw->sp_max);
#line 121
  daysleft = (int )((spw->sp_lstchg + spw->sp_max) - today);
#line 122
  if (disabled) {
#line 123
    debug3("password expiration disabled");
  } else {
#line 124
    if (spw->sp_lstchg == 0L) {
#line 125
      logit("User %.100s password has expired (root forced)", user);
#line 126
      return (1);
    } else {
#line 127
      if (spw->sp_max == -1L) {
#line 128
        debug3("password expiration disabled");
      } else {
#line 129
        if (daysleft < 0) {
#line 130
          logit("User %.100s password has expired (password aged)", user);
#line 131
          return (1);
        } else {
#line 132
          if ((long )daysleft <= spw->sp_warn) {
#line 133
            debug3("password will expire in %d days", daysleft);
#line 134
            if (daysleft == 1) {
#line 134
              tmp___0 = "";
            } else {
#line 134
              tmp___0 = "s";
            }
#line 134
            snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your password will expire in %d day%s.\n",
                     daysleft, tmp___0);
#line 137
            tmp___1 = strlen((char const   *)(buf___1));
#line 137
            buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
          }
        }
      }
    }
  }
#line 140
  return (0);
}
}
#line 1 "auth-sia.o"
#pragma merger(0,"./auth-sia.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "md5crypt.o"
#pragma merger(0,"./md5crypt.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "audit.o"
#pragma merger(0,"./audit.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "audit-bsm.o"
#pragma merger(0,"./audit-bsm.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "platform.o"
#pragma merger(0,"./platform.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 24 "platform.c"
void platform_pre_fork(void) 
{ 

  {
#line 30
  return;
}
}
#line 32 "platform.c"
void platform_post_fork_parent(pid_t child_pid ) 
{ 

  {
#line 38
  return;
}
}
#line 40 "platform.c"
void platform_post_fork_child(void) 
{ 

  {
#line 46
  return;
}
}
#line 1 "sftp-server.o"
#pragma merger(0,"./sftp-server.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 140 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval  const  *__tvp )  __attribute__((__nonnull__(1))) ;
#line 149
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval  const  *__tvp ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 293
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 156 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 57 "/usr/include/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int statvfs(char const   * __restrict  __file ,
                                                 struct statvfs * __restrict  __buf )  __asm__("statvfs64") __attribute__((__nonnull__(1,2))) ;
#line 78
extern  __attribute__((__nothrow__)) int fstatvfs(int __fildes , struct statvfs *__buf )  __asm__("fstatvfs64") __attribute__((__nonnull__(2))) ;
#line 200 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 236
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 438 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 756
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
#line 769
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
#line 775
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   * __restrict  __path ,
                                                      char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 952
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off64_t __length )  __asm__("truncate64") __attribute__((__nonnull__(1))) ;
#line 101 "sftp.h"
 __attribute__((__noreturn__)) void sftp_server_cleanup_exit(int i ) ;
#line 44 "sftp-common.h"
void attrib_clear(Attrib *a___0 ) ;
#line 45
void stat_to_attrib(struct stat  const  *st , Attrib *a___0 ) ;
#line 47
Attrib *decode_attrib(Buffer *b ) ;
#line 48
void encode_attrib(Buffer *b , Attrib const   *a___0 ) ;
#line 49
char *ls_file(char const   *name , struct stat  const  *st , int remote___0 ) ;
#line 60 "sftp-server.c"
LogLevel log_level  =    2;
#line 63 "sftp-server.c"
struct passwd *pw  =    (struct passwd *)((void *)0);
#line 64 "sftp-server.c"
char *client_addr  =    (char *)((void *)0);
#line 67 "sftp-server.c"
Buffer iqueue  ;
#line 68 "sftp-server.c"
Buffer oqueue  ;
#line 71 "sftp-server.c"
int version  ;
#line 83 "sftp-server.c"
static int errno_to_portable(int unixerrno ) 
{ int ret___0 ;

  {
#line 86
  ret___0 = 0;
#line 88
  switch (unixerrno) {
  case 0: 
#line 90
  ret___0 = 0;
#line 91
  break;
  case 2: 
  case 20: 
  case 9: 
  case 40: 
#line 96
  ret___0 = 2;
#line 97
  break;
  case 1: 
  case 13: 
  case 14: 
#line 101
  ret___0 = 3;
#line 102
  break;
  case 36: 
  case 22: 
#line 105
  ret___0 = 5;
#line 106
  break;
  case 38: 
#line 108
  ret___0 = 8;
#line 109
  break;
  default: 
#line 111
  ret___0 = 4;
#line 112
  break;
  }
#line 114
  return (ret___0);
}
}
#line 117 "sftp-server.c"
static int flags_from_portable(int pflags ) 
{ int flags ;

  {
#line 120
  flags = 0;
#line 122
  if (pflags & 1) {
#line 122
    if (pflags & 2) {
#line 124
      flags = 2;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 125
    if (pflags & 1) {
#line 126
      flags = 0;
    } else {
#line 127
      if (pflags & 2) {
#line 128
        flags = 1;
      }
    }
  }
#line 130
  if (pflags & 8) {
#line 131
    flags |= 64;
  }
#line 132
  if (pflags & 16) {
#line 133
    flags |= 512;
  }
#line 134
  if (pflags & 32) {
#line 135
    flags |= 128;
  }
#line 136
  return (flags);
}
}
#line 142 "sftp-server.c"
static char ret[128]  ;
#line 139 "sftp-server.c"
static char const   *string_from_portable(int pflags ) 
{ 

  {
#line 144
  ret[0] = (char )'\000';
#line 152
  if (pflags & 1) {
#line 153
    if ((int )ret[0] != 0) {
#line 153
      strlcat(ret, ",", sizeof(ret));
    }
#line 153
    strlcat(ret, "READ", sizeof(ret));
  }
#line 154
  if (pflags & 2) {
#line 155
    if ((int )ret[0] != 0) {
#line 155
      strlcat(ret, ",", sizeof(ret));
    }
#line 155
    strlcat(ret, "WRITE", sizeof(ret));
  }
#line 156
  if (pflags & 8) {
#line 157
    if ((int )ret[0] != 0) {
#line 157
      strlcat(ret, ",", sizeof(ret));
    }
#line 157
    strlcat(ret, "CREATE", sizeof(ret));
  }
#line 158
  if (pflags & 16) {
#line 159
    if ((int )ret[0] != 0) {
#line 159
      strlcat(ret, ",", sizeof(ret));
    }
#line 159
    strlcat(ret, "TRUNCATE", sizeof(ret));
  }
#line 160
  if (pflags & 32) {
#line 161
    if ((int )ret[0] != 0) {
#line 161
      strlcat(ret, ",", sizeof(ret));
    }
#line 161
    strlcat(ret, "EXCL", sizeof(ret));
  }
#line 163
  return ((char const   *)(ret));
}
}
#line 166 "sftp-server.c"
static Attrib *get_attrib(void) 
{ Attrib *tmp ;

  {
#line 169
  tmp = decode_attrib(& iqueue);
#line 169
  return (tmp);
}
}
#line 190 "sftp-server.c"
Handle *handles  =    (Handle *)((void *)0);
#line 191 "sftp-server.c"
u_int num_handles  =    (u_int )0;
#line 192 "sftp-server.c"
int first_unused_handle  =    -1;
#line 194 "sftp-server.c"
static void handle_unused(int i ) 
{ 

  {
#line 196
  (handles + i)->use = 0;
#line 197
  (handles + i)->next_unused = first_unused_handle;
#line 198
  first_unused_handle = i;
#line 199
  return;
}
}
#line 201 "sftp-server.c"
static int handle_new(int use , char const   *name , int fd , DIR *dirp ) 
{ int i ;
  void *tmp ;

  {
#line 206
  if (first_unused_handle == -1) {
#line 207
    if (num_handles + 1U <= num_handles) {
#line 208
      return (-1);
    }
#line 209
    num_handles ++;
#line 210
    tmp = xrealloc((void *)handles, num_handles, sizeof(Handle ));
#line 210
    handles = (Handle *)tmp;
#line 211
    handle_unused((int )(num_handles - 1U));
  }
#line 214
  i = first_unused_handle;
#line 215
  first_unused_handle = (handles + i)->next_unused;
#line 217
  (handles + i)->use = use;
#line 218
  (handles + i)->dirp = dirp;
#line 219
  (handles + i)->fd = fd;
#line 220
  (handles + i)->name = xstrdup(name);
#line 221
  (handles + i)->bytes_write = 0ULL;
#line 221
  (handles + i)->bytes_read = (handles + i)->bytes_write;
#line 223
  return (i);
}
}
#line 226 "sftp-server.c"
static int handle_is_ok(int i , int type ) 
{ int tmp ;

  {
#line 229
  if (i >= 0) {
#line 229
    if ((unsigned int )i < num_handles) {
#line 229
      if ((handles + i)->use == type) {
#line 229
        tmp = 1;
      } else {
#line 229
        tmp = 0;
      }
    } else {
#line 229
      tmp = 0;
    }
  } else {
#line 229
    tmp = 0;
  }
#line 229
  return (tmp);
}
}
#line 232 "sftp-server.c"
static int handle_to_string(int handle , char **stringp , int *hlenp ) 
{ void *tmp ;

  {
#line 235
  if ((unsigned int )stringp == (unsigned int )((void *)0)) {
#line 236
    return (-1);
  } else {
#line 235
    if ((unsigned int )hlenp == (unsigned int )((void *)0)) {
#line 236
      return (-1);
    }
  }
#line 237
  tmp = xmalloc(sizeof(int32_t ));
#line 237
  *stringp = (char *)tmp;
#line 238
  put_u32((void *)*stringp, (unsigned int )handle);
#line 239
  *hlenp = (int )sizeof(int32_t );
#line 240
  return (0);
}
}
#line 243 "sftp-server.c"
static int handle_from_string(char const   *handle , u_int hlen ) 
{ int val ;
  u_int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 248
  if (hlen != sizeof(int32_t )) {
#line 249
    return (-1);
  }
#line 250
  tmp = get_u32((void const   *)handle);
#line 250
  val = (int )tmp;
#line 251
  tmp___0 = handle_is_ok(val, 2);
#line 251
  if (tmp___0) {
#line 253
    return (val);
  } else {
#line 251
    tmp___1 = handle_is_ok(val, 1);
#line 251
    if (tmp___1) {
#line 253
      return (val);
    }
  }
#line 254
  return (-1);
}
}
#line 257 "sftp-server.c"
static char *handle_to_name(int handle ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 260
  tmp = handle_is_ok(handle, 1);
#line 260
  if (tmp) {
#line 262
    return ((handles + handle)->name);
  } else {
#line 260
    tmp___0 = handle_is_ok(handle, 2);
#line 260
    if (tmp___0) {
#line 262
      return ((handles + handle)->name);
    }
  }
#line 263
  return ((char *)((void *)0));
}
}
#line 266 "sftp-server.c"
static DIR *handle_to_dir(int handle ) 
{ int tmp ;

  {
#line 269
  tmp = handle_is_ok(handle, 1);
#line 269
  if (tmp) {
#line 270
    return ((handles + handle)->dirp);
  }
#line 271
  return ((DIR *)((void *)0));
}
}
#line 274 "sftp-server.c"
static int handle_to_fd(int handle ) 
{ int tmp ;

  {
#line 277
  tmp = handle_is_ok(handle, 2);
#line 277
  if (tmp) {
#line 278
    return ((handles + handle)->fd);
  }
#line 279
  return (-1);
}
}
#line 282 "sftp-server.c"
static void handle_update_read(int handle , ssize_t bytes ) 
{ int tmp ;

  {
#line 285
  tmp = handle_is_ok(handle, 2);
#line 285
  if (tmp) {
#line 285
    if (bytes > 0) {
#line 286
      (handles + handle)->bytes_read += (u_int64_t )bytes;
    }
  }
#line 287
  return;
}
}
#line 289 "sftp-server.c"
static void handle_update_write(int handle , ssize_t bytes ) 
{ int tmp ;

  {
#line 292
  tmp = handle_is_ok(handle, 2);
#line 292
  if (tmp) {
#line 292
    if (bytes > 0) {
#line 293
      (handles + handle)->bytes_write += (u_int64_t )bytes;
    }
  }
#line 294
  return;
}
}
#line 296 "sftp-server.c"
static u_int64_t handle_bytes_read(int handle ) 
{ int tmp ;

  {
#line 299
  tmp = handle_is_ok(handle, 2);
#line 299
  if (tmp) {
#line 300
    return ((handles + handle)->bytes_read);
  }
#line 301
  return (0ULL);
}
}
#line 304 "sftp-server.c"
static u_int64_t handle_bytes_write(int handle ) 
{ int tmp ;

  {
#line 307
  tmp = handle_is_ok(handle, 2);
#line 307
  if (tmp) {
#line 308
    return ((handles + handle)->bytes_write);
  }
#line 309
  return (0ULL);
}
}
#line 312 "sftp-server.c"
static int handle_close(int handle ) 
{ int ret___0 ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 315
  ret___0 = -1;
#line 317
  tmp___1 = handle_is_ok(handle, 2);
#line 317
  if (tmp___1) {
#line 318
    ret___0 = close((handles + handle)->fd);
#line 319
    xfree((void *)(handles + handle)->name);
#line 320
    handle_unused(handle);
  } else {
#line 321
    tmp___0 = handle_is_ok(handle, 1);
#line 321
    if (tmp___0) {
#line 322
      ret___0 = closedir((handles + handle)->dirp);
#line 323
      xfree((void *)(handles + handle)->name);
#line 324
      handle_unused(handle);
    } else {
#line 326
      tmp = __errno_location();
#line 326
      *tmp = 2;
    }
  }
#line 328
  return (ret___0);
}
}
#line 331 "sftp-server.c"
static void handle_log_close(int handle , char *emsg ) 
{ u_int64_t tmp ;
  u_int64_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;

  {
#line 334
  tmp___7 = handle_is_ok(handle, 2);
#line 334
  if (tmp___7) {
#line 335
    tmp = handle_bytes_write(handle);
#line 335
    tmp___0 = handle_bytes_read(handle);
#line 335
    tmp___1 = handle_to_name(handle);
#line 335
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 335
      tmp___2 = "";
    } else {
#line 335
      tmp___2 = " ";
    }
#line 335
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 335
      tmp___3 = "";
    } else {
#line 335
      tmp___3 = (char const   *)emsg;
    }
#line 335
    logit("%s%sclose \"%s\" bytes read %llu written %llu", tmp___3, tmp___2, tmp___1,
          tmp___0, tmp);
  } else {
#line 341
    tmp___4 = handle_to_name(handle);
#line 341
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 341
      tmp___5 = "";
    } else {
#line 341
      tmp___5 = " ";
    }
#line 341
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 341
      tmp___6 = "";
    } else {
#line 341
      tmp___6 = (char const   *)emsg;
    }
#line 341
    logit("%s%sclosedir \"%s\"", tmp___6, tmp___5, tmp___4);
  }
#line 345
  return;
}
}
#line 347 "sftp-server.c"
static void handle_log_exit(void) 
{ u_int i ;

  {
#line 352
  i = 0U;
#line 352
  while (i < num_handles) {
#line 353
    if ((handles + i)->use != 0) {
#line 354
      handle_log_close((int )i, (char *)"forced");
    }
#line 352
    i ++;
  }
#line 355
  return;
}
}
#line 357 "sftp-server.c"
static int get_handle(void) 
{ char *handle ;
  int val ;
  u_int hlen ;
  void *tmp ;

  {
#line 361
  val = -1;
#line 364
  tmp = buffer_get_string(& iqueue, & hlen);
#line 364
  handle = (char *)tmp;
#line 365
  if (hlen < 256U) {
#line 366
    val = handle_from_string((char const   *)handle, hlen);
  }
#line 367
  xfree((void *)handle);
#line 368
  return (val);
}
}
#line 373 "sftp-server.c"
static void send_msg(Buffer *m___0 ) 
{ int mlen ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 376
  tmp = buffer_len(m___0);
#line 376
  mlen = (int )tmp;
#line 378
  buffer_put_int(& oqueue, (unsigned int )mlen);
#line 379
  tmp___0 = buffer_ptr(m___0);
#line 379
  buffer_append(& oqueue, (void const   *)tmp___0, (unsigned int )mlen);
#line 380
  buffer_consume(m___0, (unsigned int )mlen);
#line 381
  return;
}
}
#line 383 "sftp-server.c"
static char const   *status_to_message(u_int32_t status ) 
{ char const   *status_messages[10] ;
  u_int32_t tmp ;

  {
#line 386
  status_messages[0] = "Success";
#line 386
  status_messages[1] = "End of file";
#line 386
  status_messages[2] = "No such file";
#line 386
  status_messages[3] = "Permission denied";
#line 386
  status_messages[4] = "Failure";
#line 386
  status_messages[5] = "Bad message";
#line 386
  status_messages[6] = "No connection";
#line 386
  status_messages[7] = "Connection lost";
#line 386
  status_messages[8] = "Operation unsupported";
#line 386
  status_messages[9] = "Unknown error";
#line 398
  if (status < 8U) {
#line 398
    tmp = status;
  } else {
#line 398
    tmp = 8U;
  }
#line 398
  return (status_messages[tmp]);
}
}
#line 401 "sftp-server.c"
static void send_status(u_int32_t id , u_int32_t status ) 
{ Buffer msg ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 406
  debug3("request %u: sent status %u", id, status);
#line 407
  if ((int )log_level > 4) {
#line 409
    tmp = status_to_message(status);
#line 409
    logit("sent status %s", tmp);
  } else {
#line 407
    if (status != 0U) {
#line 407
      if (status != 1U) {
#line 409
        tmp = status_to_message(status);
#line 409
        logit("sent status %s", tmp);
      }
    }
  }
#line 410
  buffer_init(& msg);
#line 411
  buffer_put_char(& msg, 101);
#line 412
  buffer_put_int(& msg, id);
#line 413
  buffer_put_int(& msg, status);
#line 414
  if (version >= 3) {
#line 415
    tmp___0 = status_to_message(status);
#line 415
    buffer_put_cstring(& msg, tmp___0);
#line 416
    buffer_put_cstring(& msg, "");
  }
#line 418
  send_msg(& msg);
#line 419
  buffer_free(& msg);
#line 420
  return;
}
}
#line 421 "sftp-server.c"
static void send_data_or_handle(char type , u_int32_t id , char const   *data , int dlen ) 
{ Buffer msg ;

  {
#line 426
  buffer_init(& msg);
#line 427
  buffer_put_char(& msg, (int )type);
#line 428
  buffer_put_int(& msg, id);
#line 429
  buffer_put_string(& msg, (void const   *)data, (unsigned int )dlen);
#line 430
  send_msg(& msg);
#line 431
  buffer_free(& msg);
#line 432
  return;
}
}
#line 434 "sftp-server.c"
static void send_data(u_int32_t id , char const   *data , int dlen ) 
{ 

  {
#line 437
  debug("request %u: sent data len %d", id, dlen);
#line 438
  send_data_or_handle((char)103, id, data, dlen);
#line 439
  return;
}
}
#line 441 "sftp-server.c"
static void send_handle(u_int32_t id , int handle ) 
{ char *string ;
  int hlen ;

  {
#line 447
  handle_to_string(handle, & string, & hlen);
#line 448
  debug("request %u: sent handle handle %d", id, handle);
#line 449
  send_data_or_handle((char)102, id, (char const   *)string, hlen);
#line 450
  xfree((void *)string);
#line 451
  return;
}
}
#line 453 "sftp-server.c"
static void send_names(u_int32_t id , int count , Stat const   *stats ) 
{ Buffer msg ;
  int i ;

  {
#line 459
  buffer_init(& msg);
#line 460
  buffer_put_char(& msg, 104);
#line 461
  buffer_put_int(& msg, id);
#line 462
  buffer_put_int(& msg, (unsigned int )count);
#line 463
  debug("request %u: sent names count %d", id, count);
#line 464
  i = 0;
#line 464
  while (i < count) {
#line 465
    buffer_put_cstring(& msg, (char const   *)(stats + i)->name);
#line 466
    buffer_put_cstring(& msg, (char const   *)(stats + i)->long_name);
#line 467
    encode_attrib(& msg, & (stats + i)->attrib);
#line 464
    i ++;
  }
#line 469
  send_msg(& msg);
#line 470
  buffer_free(& msg);
#line 471
  return;
}
}
#line 473 "sftp-server.c"
static void send_attrib(u_int32_t id , Attrib const   *a___0 ) 
{ Buffer msg ;

  {
#line 478
  debug("request %u: sent attrib have 0x%x", id, a___0->flags);
#line 479
  buffer_init(& msg);
#line 480
  buffer_put_char(& msg, 105);
#line 481
  buffer_put_int(& msg, id);
#line 482
  encode_attrib(& msg, a___0);
#line 483
  send_msg(& msg);
#line 484
  buffer_free(& msg);
#line 485
  return;
}
}
#line 487 "sftp-server.c"
static void send_statvfs(u_int32_t id , struct statvfs *st ) 
{ Buffer msg ;
  u_int64_t flag ;
  int tmp ;

  {
#line 493
  if (st->f_flag & 1UL) {
#line 493
    flag = 1ULL;
  } else {
#line 493
    flag = 0ULL;
  }
#line 494
  if (st->f_flag & 2UL) {
#line 494
    tmp = 2;
  } else {
#line 494
    tmp = 0;
  }
#line 494
  flag |= (unsigned long long )tmp;
#line 496
  buffer_init(& msg);
#line 497
  buffer_put_char(& msg, 201);
#line 498
  buffer_put_int(& msg, id);
#line 499
  buffer_put_int64(& msg, (unsigned long long )st->f_bsize);
#line 500
  buffer_put_int64(& msg, (unsigned long long )st->f_frsize);
#line 501
  buffer_put_int64(& msg, st->f_blocks);
#line 502
  buffer_put_int64(& msg, st->f_bfree);
#line 503
  buffer_put_int64(& msg, st->f_bavail);
#line 504
  buffer_put_int64(& msg, st->f_files);
#line 505
  buffer_put_int64(& msg, st->f_ffree);
#line 506
  buffer_put_int64(& msg, st->f_favail);
#line 507
  buffer_put_int64(& msg, (unsigned long long )st->f_fsid);
#line 508
  buffer_put_int64(& msg, flag);
#line 509
  buffer_put_int64(& msg, (unsigned long long )st->f_namemax);
#line 510
  send_msg(& msg);
#line 511
  buffer_free(& msg);
#line 512
  return;
}
}
#line 516 "sftp-server.c"
static void process_init(void) 
{ Buffer msg ;
  u_int tmp ;

  {
#line 521
  tmp = buffer_get_int(& iqueue);
#line 521
  version = (int )tmp;
#line 522
  verbose("received client version %d", version);
#line 523
  buffer_init(& msg);
#line 524
  buffer_put_char(& msg, 2);
#line 525
  buffer_put_int(& msg, 3U);
#line 527
  buffer_put_cstring(& msg, "posix-rename@openssh.com");
#line 528
  buffer_put_cstring(& msg, "1");
#line 530
  buffer_put_cstring(& msg, "statvfs@openssh.com");
#line 531
  buffer_put_cstring(& msg, "2");
#line 533
  buffer_put_cstring(& msg, "fstatvfs@openssh.com");
#line 534
  buffer_put_cstring(& msg, "2");
#line 535
  send_msg(& msg);
#line 536
  buffer_free(& msg);
#line 537
  return;
}
}
#line 539 "sftp-server.c"
static void process_open(void) 
{ u_int32_t id ;
  u_int32_t pflags ;
  Attrib *a___0 ;
  char *name ;
  int handle ;
  int fd ;
  int flags ;
  int mode ;
  int status ;
  void *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
#line 545
  status = 4;
#line 547
  id = buffer_get_int(& iqueue);
#line 548
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 548
  name = (char *)tmp;
#line 549
  pflags = buffer_get_int(& iqueue);
#line 550
  debug3("request %u: open flags %d", id, pflags);
#line 551
  a___0 = get_attrib();
#line 552
  flags = flags_from_portable((int )pflags);
#line 553
  if (a___0->flags & 4U) {
#line 553
    mode = (int )a___0->perm;
  } else {
#line 553
    mode = 438;
  }
#line 554
  tmp___0 = string_from_portable((int )pflags);
#line 554
  logit("open \"%s\" flags %s mode 0%o", name, tmp___0, mode);
#line 556
  fd = open((char const   *)name, flags, mode);
#line 557
  if (fd < 0) {
#line 558
    tmp___1 = __errno_location();
#line 558
    status = errno_to_portable(*tmp___1);
  } else {
#line 560
    handle = handle_new(2, (char const   *)name, fd, (DIR *)((void *)0));
#line 561
    if (handle < 0) {
#line 562
      close(fd);
    } else {
#line 564
      send_handle(id, handle);
#line 565
      status = 0;
    }
  }
#line 568
  if (status != 0) {
#line 569
    send_status(id, (unsigned int )status);
  }
#line 570
  xfree((void *)name);
#line 571
  return;
}
}
#line 573 "sftp-server.c"
static void process_close(void) 
{ u_int32_t id ;
  int handle ;
  int ret___0 ;
  int status ;
  int *tmp___1 ;

  {
#line 577
  status = 4;
#line 579
  id = buffer_get_int(& iqueue);
#line 580
  handle = get_handle();
#line 581
  debug3("request %u: close handle %u", id, handle);
#line 582
  handle_log_close(handle, (char *)((void *)0));
#line 583
  ret___0 = handle_close(handle);
#line 584
  if (ret___0 == -1) {
#line 584
    tmp___1 = __errno_location();
#line 584
    status = errno_to_portable(*tmp___1);
  } else {
#line 584
    status = 0;
  }
#line 585
  send_status(id, (unsigned int )status);
#line 586
  return;
}
}
#line 588 "sftp-server.c"
static void process_read(void) 
{ char buf___1[65536] ;
  u_int32_t id ;
  u_int32_t len ;
  int handle ;
  int fd ;
  int ret___0 ;
  int status ;
  u_int64_t off ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  __off64_t tmp___2 ;

  {
#line 593
  status = 4;
#line 596
  id = buffer_get_int(& iqueue);
#line 597
  handle = get_handle();
#line 598
  off = buffer_get_int64(& iqueue);
#line 599
  len = buffer_get_int(& iqueue);
#line 601
  tmp = handle_to_name(handle);
#line 601
  debug("request %u: read \"%s\" (handle %d) off %llu len %d", id, tmp, handle, off,
        len);
#line 603
  if (len > sizeof(buf___1)) {
#line 604
    len = sizeof(buf___1);
#line 605
    debug2("read change len %d", len);
  }
#line 607
  fd = handle_to_fd(handle);
#line 608
  if (fd >= 0) {
#line 609
    tmp___2 = lseek(fd, (long long )off, 0);
#line 609
    if (tmp___2 < 0LL) {
#line 610
      error("process_read: seek failed");
#line 611
      tmp___0 = __errno_location();
#line 611
      status = errno_to_portable(*tmp___0);
    } else {
#line 613
      ret___0 = read(fd, (void *)(buf___1), len);
#line 614
      if (ret___0 < 0) {
#line 615
        tmp___1 = __errno_location();
#line 615
        status = errno_to_portable(*tmp___1);
      } else {
#line 616
        if (ret___0 == 0) {
#line 617
          status = 1;
        } else {
#line 619
          send_data(id, (char const   *)(buf___1), ret___0);
#line 620
          status = 0;
#line 621
          handle_update_read(handle, ret___0);
        }
      }
    }
  }
#line 625
  if (status != 0) {
#line 626
    send_status(id, (unsigned int )status);
  }
#line 627
  return;
}
}
#line 629 "sftp-server.c"
static void process_write(void) 
{ u_int32_t id ;
  u_int64_t off ;
  u_int len ;
  int handle ;
  int fd ;
  int ret___0 ;
  int status ;
  char *data ;
  void *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  __off64_t tmp___3 ;

  {
#line 635
  status = 4;
#line 638
  id = buffer_get_int(& iqueue);
#line 639
  handle = get_handle();
#line 640
  off = buffer_get_int64(& iqueue);
#line 641
  tmp = buffer_get_string(& iqueue, & len);
#line 641
  data = (char *)tmp;
#line 643
  tmp___0 = handle_to_name(handle);
#line 643
  debug("request %u: write \"%s\" (handle %d) off %llu len %d", id, tmp___0, handle,
        off, len);
#line 645
  fd = handle_to_fd(handle);
#line 646
  if (fd >= 0) {
#line 647
    tmp___3 = lseek(fd, (long long )off, 0);
#line 647
    if (tmp___3 < 0LL) {
#line 648
      tmp___1 = __errno_location();
#line 648
      status = errno_to_portable(*tmp___1);
#line 649
      error("process_write: seek failed");
    } else {
#line 652
      ret___0 = write(fd, (void const   *)data, len);
#line 653
      if (ret___0 < 0) {
#line 654
        error("process_write: write failed");
#line 655
        tmp___2 = __errno_location();
#line 655
        status = errno_to_portable(*tmp___2);
      } else {
#line 656
        if ((unsigned int )ret___0 == len) {
#line 657
          status = 0;
#line 658
          handle_update_write(handle, ret___0);
        } else {
#line 660
          debug2("nothing at all written");
        }
      }
    }
  }
#line 664
  send_status(id, (unsigned int )status);
#line 665
  xfree((void *)data);
#line 666
  return;
}
}
#line 668 "sftp-server.c"
static void process_do_stat(int do_lstat ) 
{ Attrib a___0 ;
  struct stat st ;
  u_int32_t id ;
  char *name ;
  int ret___0 ;
  int status ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___4 ;

  {
#line 675
  status = 4;
#line 677
  id = buffer_get_int(& iqueue);
#line 678
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 678
  name = (char *)tmp;
#line 679
  if (do_lstat) {
#line 679
    tmp___0 = "l";
  } else {
#line 679
    tmp___0 = "";
  }
#line 679
  debug3("request %u: %sstat", id, tmp___0);
#line 680
  if (do_lstat) {
#line 680
    tmp___1 = "l";
  } else {
#line 680
    tmp___1 = "";
  }
#line 680
  verbose("%sstat name \"%s\"", tmp___1, name);
#line 681
  if (do_lstat) {
#line 681
    ret___0 = lstat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
  } else {
#line 681
    ret___0 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
  }
#line 682
  if (ret___0 < 0) {
#line 683
    tmp___4 = __errno_location();
#line 683
    status = errno_to_portable(*tmp___4);
  } else {
#line 685
    stat_to_attrib((struct stat  const  *)(& st), & a___0);
#line 686
    send_attrib(id, (Attrib const   *)(& a___0));
#line 687
    status = 0;
  }
#line 689
  if (status != 0) {
#line 690
    send_status(id, (unsigned int )status);
  }
#line 691
  xfree((void *)name);
#line 692
  return;
}
}
#line 694 "sftp-server.c"
static void process_stat(void) 
{ 

  {
#line 697
  process_do_stat(0);
#line 698
  return;
}
}
#line 700 "sftp-server.c"
static void process_lstat(void) 
{ 

  {
#line 703
  process_do_stat(1);
#line 704
  return;
}
}
#line 706 "sftp-server.c"
static void process_fstat(void) 
{ Attrib a___0 ;
  struct stat st ;
  u_int32_t id ;
  int fd ;
  int ret___0 ;
  int handle ;
  int status ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 712
  status = 4;
#line 714
  id = buffer_get_int(& iqueue);
#line 715
  handle = get_handle();
#line 716
  tmp = handle_to_name(handle);
#line 716
  debug("request %u: fstat \"%s\" (handle %u)", id, tmp, handle);
#line 718
  fd = handle_to_fd(handle);
#line 719
  if (fd >= 0) {
#line 720
    ret___0 = fstat(fd, & st);
#line 721
    if (ret___0 < 0) {
#line 722
      tmp___0 = __errno_location();
#line 722
      status = errno_to_portable(*tmp___0);
    } else {
#line 724
      stat_to_attrib((struct stat  const  *)(& st), & a___0);
#line 725
      send_attrib(id, (Attrib const   *)(& a___0));
#line 726
      status = 0;
    }
  }
#line 729
  if (status != 0) {
#line 730
    send_status(id, (unsigned int )status);
  }
#line 731
  return;
}
}
#line 736 "sftp-server.c"
static struct timeval tv[2]  ;
#line 733 "sftp-server.c"
static struct timeval *attrib_to_tv(Attrib const   *a___0 ) 
{ 

  {
#line 738
  tv[0].tv_sec = (long )a___0->atime;
#line 739
  tv[0].tv_usec = 0L;
#line 740
  tv[1].tv_sec = (long )a___0->mtime;
#line 741
  tv[1].tv_usec = 0L;
#line 742
  return (tv);
}
}
#line 745 "sftp-server.c"
static void process_setstat(void) 
{ Attrib *a___0 ;
  u_int32_t id ;
  char *name ;
  int status ;
  int ret___0 ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char buf___1[64] ;
  time_t t ;
  struct tm *tmp___2 ;
  struct timeval *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 751
  status = 0;
#line 753
  id = buffer_get_int(& iqueue);
#line 754
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 754
  name = (char *)tmp;
#line 755
  a___0 = get_attrib();
#line 756
  debug("request %u: setstat name \"%s\"", id, name);
#line 757
  if (a___0->flags & 1U) {
#line 758
    logit("set \"%s\" size %llu", name, a___0->size);
#line 760
    ret___0 = truncate((char const   *)name, (long long )a___0->size);
#line 761
    if (ret___0 == -1) {
#line 762
      tmp___0 = __errno_location();
#line 762
      status = errno_to_portable(*tmp___0);
    }
  }
#line 764
  if (a___0->flags & 4U) {
#line 765
    logit("set \"%s\" mode %04o", name, a___0->perm);
#line 766
    ret___0 = chmod((char const   *)name, a___0->perm & 4095U);
#line 767
    if (ret___0 == -1) {
#line 768
      tmp___1 = __errno_location();
#line 768
      status = errno_to_portable(*tmp___1);
    }
  }
#line 770
  if (a___0->flags & 8U) {
#line 772
    t = (time_t )a___0->mtime;
#line 774
    tmp___2 = localtime((time_t const   *)(& t));
#line 774
    strftime((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%Y%m%d-%H:%M:%S",
             (struct tm  const  * __restrict  )tmp___2);
#line 776
    logit("set \"%s\" modtime %s", name, buf___1);
#line 777
    tmp___3 = attrib_to_tv((Attrib const   *)a___0);
#line 777
    ret___0 = utimes((char const   *)name, (struct timeval  const  *)tmp___3);
#line 778
    if (ret___0 == -1) {
#line 779
      tmp___4 = __errno_location();
#line 779
      status = errno_to_portable(*tmp___4);
    }
  }
#line 781
  if (a___0->flags & 2U) {
#line 782
    logit("set \"%s\" owner %lu group %lu", name, (unsigned long )a___0->uid, (unsigned long )a___0->gid);
#line 784
    ret___0 = chown((char const   *)name, a___0->uid, a___0->gid);
#line 785
    if (ret___0 == -1) {
#line 786
      tmp___5 = __errno_location();
#line 786
      status = errno_to_portable(*tmp___5);
    }
  }
#line 788
  send_status(id, (unsigned int )status);
#line 789
  xfree((void *)name);
#line 790
  return;
}
}
#line 792 "sftp-server.c"
static void process_fsetstat(void) 
{ Attrib *a___0 ;
  u_int32_t id ;
  int handle ;
  int fd ;
  int ret___0 ;
  int status ;
  char *name ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char buf___1[64] ;
  time_t t ;
  struct tm *tmp___2 ;
  struct timeval *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 798
  status = 0;
#line 800
  id = buffer_get_int(& iqueue);
#line 801
  handle = get_handle();
#line 802
  a___0 = get_attrib();
#line 803
  debug("request %u: fsetstat handle %d", id, handle);
#line 804
  fd = handle_to_fd(handle);
#line 805
  if (fd < 0) {
#line 806
    status = 4;
  } else {
#line 808
    tmp = handle_to_name(handle);
#line 808
    name = tmp;
#line 810
    if (a___0->flags & 1U) {
#line 811
      logit("set \"%s\" size %llu", name, a___0->size);
#line 813
      ret___0 = ftruncate(fd, (long long )a___0->size);
#line 814
      if (ret___0 == -1) {
#line 815
        tmp___0 = __errno_location();
#line 815
        status = errno_to_portable(*tmp___0);
      }
    }
#line 817
    if (a___0->flags & 4U) {
#line 818
      logit("set \"%s\" mode %04o", name, a___0->perm);
#line 820
      ret___0 = fchmod(fd, a___0->perm & 4095U);
#line 824
      if (ret___0 == -1) {
#line 825
        tmp___1 = __errno_location();
#line 825
        status = errno_to_portable(*tmp___1);
      }
    }
#line 827
    if (a___0->flags & 8U) {
#line 829
      t = (time_t )a___0->mtime;
#line 831
      tmp___2 = localtime((time_t const   *)(& t));
#line 831
      strftime((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%Y%m%d-%H:%M:%S",
               (struct tm  const  * __restrict  )tmp___2);
#line 833
      logit("set \"%s\" modtime %s", name, buf___1);
#line 835
      tmp___3 = attrib_to_tv((Attrib const   *)a___0);
#line 835
      ret___0 = futimes(fd, (struct timeval  const  *)tmp___3);
#line 839
      if (ret___0 == -1) {
#line 840
        tmp___4 = __errno_location();
#line 840
        status = errno_to_portable(*tmp___4);
      }
    }
#line 842
    if (a___0->flags & 2U) {
#line 843
      logit("set \"%s\" owner %lu group %lu", name, (unsigned long )a___0->uid, (unsigned long )a___0->gid);
#line 846
      ret___0 = fchown(fd, a___0->uid, a___0->gid);
#line 850
      if (ret___0 == -1) {
#line 851
        tmp___5 = __errno_location();
#line 851
        status = errno_to_portable(*tmp___5);
      }
    }
  }
#line 854
  send_status(id, (unsigned int )status);
#line 855
  return;
}
}
#line 857 "sftp-server.c"
static void process_opendir(void) 
{ DIR *dirp ;
  char *path ;
  int handle ;
  int status ;
  u_int32_t id ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 860
  dirp = (DIR *)((void *)0);
#line 862
  status = 4;
#line 865
  id = buffer_get_int(& iqueue);
#line 866
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 866
  path = (char *)tmp;
#line 867
  debug3("request %u: opendir", id);
#line 868
  logit("opendir \"%s\"", path);
#line 869
  dirp = opendir((char const   *)path);
#line 870
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 871
    tmp___0 = __errno_location();
#line 871
    status = errno_to_portable(*tmp___0);
  } else {
#line 873
    handle = handle_new(1, (char const   *)path, 0, dirp);
#line 874
    if (handle < 0) {
#line 875
      closedir(dirp);
    } else {
#line 877
      send_handle(id, handle);
#line 878
      status = 0;
    }
  }
#line 882
  if (status != 0) {
#line 883
    send_status(id, (unsigned int )status);
  }
#line 884
  xfree((void *)path);
#line 885
  return;
}
}
#line 887 "sftp-server.c"
static void process_readdir(void) 
{ DIR *dirp ;
  struct dirent *dp ;
  char *path ;
  int handle ;
  u_int32_t id ;
  char *tmp ;
  struct stat st ;
  char pathname[4096] ;
  Stat *stats ;
  int nstats ;
  int count ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 896
  id = buffer_get_int(& iqueue);
#line 897
  handle = get_handle();
#line 898
  tmp = handle_to_name(handle);
#line 898
  debug("request %u: readdir \"%s\" (handle %d)", id, tmp, handle);
#line 900
  dirp = handle_to_dir(handle);
#line 901
  path = handle_to_name(handle);
#line 902
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 903
    send_status(id, 4U);
  } else {
#line 902
    if ((unsigned int )path == (unsigned int )((void *)0)) {
#line 903
      send_status(id, 4U);
    } else {
#line 908
      nstats = 10;
#line 908
      count = 0;
#line 910
      tmp___0 = xcalloc((unsigned int )nstats, sizeof(Stat ));
#line 910
      stats = (Stat *)tmp___0;
#line 911
      while (1) {
#line 911
        dp = readdir(dirp);
#line 911
        if (! ((unsigned int )dp != (unsigned int )((void *)0))) {
#line 911
          break;
        }
#line 912
        if (count >= nstats) {
#line 913
          nstats *= 2;
#line 914
          tmp___1 = xrealloc((void *)stats, (unsigned int )nstats, sizeof(Stat ));
#line 914
          stats = (Stat *)tmp___1;
        }
#line 918
        if (0) {
#line 918
          __s1_len___0 = strlen((char const   *)path);
#line 918
          __s2_len___0 = strlen("/");
#line 918
          if (! ((unsigned int )((void const   *)(path + 1)) - (unsigned int )((void const   *)path) == 1U)) {
            goto _L___2;
          } else {
#line 918
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 918
              if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 918
                tmp___22 = 1;
              } else {
#line 918
                if (__s2_len___0 >= 4U) {
#line 918
                  tmp___22 = 1;
                } else {
#line 918
                  tmp___22 = 0;
                }
              }
            } else {
#line 918
              tmp___22 = 0;
            }
          }
#line 918
          if (tmp___22) {
#line 918
            tmp___18 = __builtin_strcmp((char const   *)path, "/");
          } else {
#line 918
            tmp___21 = __builtin_strcmp((char const   *)path, "/");
#line 918
            tmp___18 = tmp___21;
          }
        } else {
#line 918
          tmp___21 = __builtin_strcmp((char const   *)path, "/");
#line 918
          tmp___18 = tmp___21;
        }
#line 918
        if (tmp___18) {
#line 918
          tmp___12 = "/";
        } else {
#line 918
          tmp___12 = "";
        }
#line 918
        snprintf((char * __restrict  )(pathname), sizeof(pathname), (char const   * __restrict  )"%s%s%s",
                 path, tmp___12, dp->d_name);
#line 919
        tmp___23 = lstat((char const   * __restrict  )(pathname), (struct stat * __restrict  )(& st));
#line 919
        if (tmp___23 < 0) {
#line 920
          continue;
        }
#line 921
        stat_to_attrib((struct stat  const  *)(& st), & (stats + count)->attrib);
#line 922
        (stats + count)->name = xstrdup((char const   *)(dp->d_name));
#line 923
        (stats + count)->long_name = ls_file((char const   *)(dp->d_name), (struct stat  const  *)(& st),
                                             0);
#line 924
        count ++;
#line 927
        if (count == 100) {
#line 928
          break;
        }
      }
#line 930
      if (count > 0) {
#line 931
        send_names(id, count, (Stat const   *)stats);
#line 932
        i = 0;
#line 932
        while (i < count) {
#line 933
          xfree((void *)(stats + i)->name);
#line 934
          xfree((void *)(stats + i)->long_name);
#line 932
          i ++;
        }
      } else {
#line 937
        send_status(id, 1U);
      }
#line 939
      xfree((void *)stats);
    }
  }
#line 941
  return;
}
}
#line 943 "sftp-server.c"
static void process_remove(void) 
{ char *name ;
  u_int32_t id ;
  int status ;
  int ret___0 ;
  void *tmp ;
  int *tmp___2 ;

  {
#line 948
  status = 4;
#line 951
  id = buffer_get_int(& iqueue);
#line 952
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 952
  name = (char *)tmp;
#line 953
  debug3("request %u: remove", id);
#line 954
  logit("remove name \"%s\"", name);
#line 955
  ret___0 = unlink((char const   *)name);
#line 956
  if (ret___0 == -1) {
#line 956
    tmp___2 = __errno_location();
#line 956
    status = errno_to_portable(*tmp___2);
  } else {
#line 956
    status = 0;
  }
#line 957
  send_status(id, (unsigned int )status);
#line 958
  xfree((void *)name);
#line 959
  return;
}
}
#line 961 "sftp-server.c"
static void process_mkdir(void) 
{ Attrib *a___0 ;
  u_int32_t id ;
  char *name ;
  int ret___0 ;
  int mode ;
  int status ;
  void *tmp ;
  int *tmp___2 ;

  {
#line 967
  status = 4;
#line 969
  id = buffer_get_int(& iqueue);
#line 970
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 970
  name = (char *)tmp;
#line 971
  a___0 = get_attrib();
#line 972
  if (a___0->flags & 4U) {
#line 972
    mode = (int )(a___0->perm & 4095U);
  } else {
#line 972
    mode = 511;
  }
#line 974
  debug3("request %u: mkdir", id);
#line 975
  logit("mkdir name \"%s\" mode 0%o", name, mode);
#line 976
  ret___0 = mkdir((char const   *)name, (unsigned int )mode);
#line 977
  if (ret___0 == -1) {
#line 977
    tmp___2 = __errno_location();
#line 977
    status = errno_to_portable(*tmp___2);
  } else {
#line 977
    status = 0;
  }
#line 978
  send_status(id, (unsigned int )status);
#line 979
  xfree((void *)name);
#line 980
  return;
}
}
#line 982 "sftp-server.c"
static void process_rmdir(void) 
{ u_int32_t id ;
  char *name ;
  int ret___0 ;
  int status ;
  void *tmp ;
  int *tmp___2 ;

  {
#line 989
  id = buffer_get_int(& iqueue);
#line 990
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 990
  name = (char *)tmp;
#line 991
  debug3("request %u: rmdir", id);
#line 992
  logit("rmdir name \"%s\"", name);
#line 993
  ret___0 = rmdir((char const   *)name);
#line 994
  if (ret___0 == -1) {
#line 994
    tmp___2 = __errno_location();
#line 994
    status = errno_to_portable(*tmp___2);
  } else {
#line 994
    status = 0;
  }
#line 995
  send_status(id, (unsigned int )status);
#line 996
  xfree((void *)name);
#line 997
  return;
}
}
#line 999 "sftp-server.c"
static void process_realpath(void) 
{ char resolvedname[4096] ;
  u_int32_t id ;
  char *path ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  Stat s ;
  char *tmp___2 ;

  {
#line 1006
  id = buffer_get_int(& iqueue);
#line 1007
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1007
  path = (char *)tmp;
#line 1008
  if ((int )*(path + 0) == 0) {
#line 1009
    xfree((void *)path);
#line 1010
    path = xstrdup(".");
  }
#line 1012
  debug3("request %u: realpath", id);
#line 1013
  verbose("realpath \"%s\"", path);
#line 1014
  tmp___2 = realpath((char const   * __restrict  )path, (char * __restrict  )(resolvedname));
#line 1014
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 1015
    tmp___0 = __errno_location();
#line 1015
    tmp___1 = errno_to_portable(*tmp___0);
#line 1015
    send_status(id, (unsigned int )tmp___1);
  } else {
#line 1018
    attrib_clear(& s.attrib);
#line 1019
    s.long_name = resolvedname;
#line 1019
    s.name = s.long_name;
#line 1020
    send_names(id, 1, (Stat const   *)(& s));
  }
#line 1022
  xfree((void *)path);
#line 1023
  return;
}
}
#line 1025 "sftp-server.c"
static void process_rename(void) 
{ u_int32_t id ;
  char *oldpath ;
  char *newpath ;
  int status ;
  struct stat sb ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  struct stat st ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 1033
  id = buffer_get_int(& iqueue);
#line 1034
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1034
  oldpath = (char *)tmp;
#line 1035
  tmp___0 = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1035
  newpath = (char *)tmp___0;
#line 1036
  debug3("request %u: rename", id);
#line 1037
  logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
#line 1038
  status = 4;
#line 1039
  tmp___15 = lstat((char const   * __restrict  )oldpath, (struct stat * __restrict  )(& sb));
#line 1039
  if (tmp___15 == -1) {
#line 1040
    tmp___1 = __errno_location();
#line 1040
    status = errno_to_portable(*tmp___1);
  } else {
#line 1041
    if ((sb.st_mode & 61440U) == 32768U) {
#line 1043
      tmp___11 = link((char const   *)oldpath, (char const   *)newpath);
#line 1043
      if (tmp___11 == -1) {
#line 1044
        tmp___6 = __errno_location();
#line 1044
        if (*tmp___6 == 95) {
          goto _L;
        } else {
#line 1044
          tmp___7 = __errno_location();
#line 1044
          if (*tmp___7 == 18) {
            goto _L;
          } else {
#line 1044
            tmp___8 = __errno_location();
#line 1044
            if (*tmp___8 == 1) {
              _L: /* CIL Label */ 
#line 1058
              tmp___4 = stat((char const   * __restrict  )newpath, (struct stat * __restrict  )(& st));
#line 1058
              if (tmp___4 == -1) {
#line 1059
                tmp___3 = rename((char const   *)oldpath, (char const   *)newpath);
#line 1059
                if (tmp___3 == -1) {
#line 1060
                  tmp___2 = __errno_location();
#line 1060
                  status = errno_to_portable(*tmp___2);
                } else {
#line 1063
                  status = 0;
                }
              }
            } else {
#line 1066
              tmp___5 = __errno_location();
#line 1066
              status = errno_to_portable(*tmp___5);
            }
          }
        }
      } else {
#line 1068
        tmp___10 = unlink((char const   *)oldpath);
#line 1068
        if (tmp___10 == -1) {
#line 1069
          tmp___9 = __errno_location();
#line 1069
          status = errno_to_portable(*tmp___9);
#line 1071
          unlink((char const   *)newpath);
        } else {
#line 1073
          status = 0;
        }
      }
    } else {
#line 1074
      tmp___14 = stat((char const   * __restrict  )newpath, (struct stat * __restrict  )(& sb));
#line 1074
      if (tmp___14 == -1) {
#line 1075
        tmp___13 = rename((char const   *)oldpath, (char const   *)newpath);
#line 1075
        if (tmp___13 == -1) {
#line 1076
          tmp___12 = __errno_location();
#line 1076
          status = errno_to_portable(*tmp___12);
        } else {
#line 1078
          status = 0;
        }
      }
    }
  }
#line 1080
  send_status(id, (unsigned int )status);
#line 1081
  xfree((void *)oldpath);
#line 1082
  xfree((void *)newpath);
#line 1083
  return;
}
}
#line 1085 "sftp-server.c"
static void process_readlink(void) 
{ u_int32_t id ;
  int len ;
  char buf___1[4096] ;
  char *path ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  Stat s ;

  {
#line 1093
  id = buffer_get_int(& iqueue);
#line 1094
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1094
  path = (char *)tmp;
#line 1095
  debug3("request %u: readlink", id);
#line 1096
  verbose("readlink \"%s\"", path);
#line 1097
  len = readlink((char const   * __restrict  )path, (char * __restrict  )(buf___1),
                 sizeof(buf___1) - 1U);
#line 1097
  if (len == -1) {
#line 1098
    tmp___0 = __errno_location();
#line 1098
    tmp___1 = errno_to_portable(*tmp___0);
#line 1098
    send_status(id, (unsigned int )tmp___1);
  } else {
#line 1102
    buf___1[len] = (char )'\000';
#line 1103
    attrib_clear(& s.attrib);
#line 1104
    s.long_name = buf___1;
#line 1104
    s.name = s.long_name;
#line 1105
    send_names(id, 1, (Stat const   *)(& s));
  }
#line 1107
  xfree((void *)path);
#line 1108
  return;
}
}
#line 1110 "sftp-server.c"
static void process_symlink(void) 
{ u_int32_t id ;
  char *oldpath ;
  char *newpath ;
  int ret___0 ;
  int status ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___3 ;

  {
#line 1117
  id = buffer_get_int(& iqueue);
#line 1118
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1118
  oldpath = (char *)tmp;
#line 1119
  tmp___0 = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1119
  newpath = (char *)tmp___0;
#line 1120
  debug3("request %u: symlink", id);
#line 1121
  logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
#line 1123
  ret___0 = symlink((char const   *)oldpath, (char const   *)newpath);
#line 1124
  if (ret___0 == -1) {
#line 1124
    tmp___3 = __errno_location();
#line 1124
    status = errno_to_portable(*tmp___3);
  } else {
#line 1124
    status = 0;
  }
#line 1125
  send_status(id, (unsigned int )status);
#line 1126
  xfree((void *)oldpath);
#line 1127
  xfree((void *)newpath);
#line 1128
  return;
}
}
#line 1130 "sftp-server.c"
static void process_extended_posix_rename(u_int32_t id ) 
{ char *oldpath ;
  char *newpath ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1135
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1135
  oldpath = (char *)tmp;
#line 1136
  tmp___0 = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1136
  newpath = (char *)tmp___0;
#line 1137
  debug3("request %u: posix-rename", id);
#line 1138
  logit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
#line 1139
  tmp___3 = rename((char const   *)oldpath, (char const   *)newpath);
#line 1139
  if (tmp___3 == -1) {
#line 1140
    tmp___1 = __errno_location();
#line 1140
    tmp___2 = errno_to_portable(*tmp___1);
#line 1140
    send_status(id, (unsigned int )tmp___2);
  } else {
#line 1142
    send_status(id, 0U);
  }
#line 1143
  xfree((void *)oldpath);
#line 1144
  xfree((void *)newpath);
#line 1145
  return;
}
}
#line 1147 "sftp-server.c"
static void process_extended_statvfs(u_int32_t id ) 
{ char *path ;
  struct statvfs st ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1153
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1153
  path = (char *)tmp;
#line 1154
  debug3("request %u: statfs", id);
#line 1155
  logit("statfs \"%s\"", path);
#line 1157
  tmp___2 = statvfs((char const   * __restrict  )path, (struct statvfs * __restrict  )(& st));
#line 1157
  if (tmp___2 != 0) {
#line 1158
    tmp___0 = __errno_location();
#line 1158
    tmp___1 = errno_to_portable(*tmp___0);
#line 1158
    send_status(id, (unsigned int )tmp___1);
  } else {
#line 1160
    send_statvfs(id, & st);
  }
#line 1161
  xfree((void *)path);
#line 1162
  return;
}
}
#line 1164 "sftp-server.c"
static void process_extended_fstatvfs(u_int32_t id ) 
{ int handle ;
  int fd ;
  struct statvfs st ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1170
  handle = get_handle();
#line 1171
  tmp = handle_to_name(handle);
#line 1171
  debug("request %u: fstatvfs \"%s\" (handle %u)", id, tmp, handle);
#line 1173
  fd = handle_to_fd(handle);
#line 1173
  if (fd < 0) {
#line 1174
    send_status(id, 4U);
#line 1175
    return;
  }
#line 1177
  tmp___2 = fstatvfs(fd, & st);
#line 1177
  if (tmp___2 != 0) {
#line 1178
    tmp___0 = __errno_location();
#line 1178
    tmp___1 = errno_to_portable(*tmp___0);
#line 1178
    send_status(id, (unsigned int )tmp___1);
  } else {
#line 1180
    send_statvfs(id, & st);
  }
#line 1181
  return;
}
}
#line 1183 "sftp-server.c"
static void process_extended(void) 
{ u_int32_t id ;
  char *request ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 1189
  id = buffer_get_int(& iqueue);
#line 1190
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1190
  request = (char *)tmp;
#line 1191
  if (0) {
#line 1191
    __s1_len___1 = strlen((char const   *)request);
#line 1191
    __s2_len___1 = strlen("posix-rename@openssh.com");
#line 1191
    if (! ((unsigned int )((void const   *)(request + 1)) - (unsigned int )((void const   *)request) == 1U)) {
      goto _L___4;
    } else {
#line 1191
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1191
        if (! ((unsigned int )((void const   *)("posix-rename@openssh.com" + 1)) - (unsigned int )((void const   *)"posix-rename@openssh.com") == 1U)) {
#line 1191
          tmp___29 = 1;
        } else {
#line 1191
          if (__s2_len___1 >= 4U) {
#line 1191
            tmp___29 = 1;
          } else {
#line 1191
            tmp___29 = 0;
          }
        }
      } else {
#line 1191
        tmp___29 = 0;
      }
    }
#line 1191
    if (tmp___29) {
#line 1191
      tmp___25 = __builtin_strcmp((char const   *)request, "posix-rename@openssh.com");
    } else {
#line 1191
      tmp___28 = __builtin_strcmp((char const   *)request, "posix-rename@openssh.com");
#line 1191
      tmp___25 = tmp___28;
    }
  } else {
#line 1191
    tmp___28 = __builtin_strcmp((char const   *)request, "posix-rename@openssh.com");
#line 1191
    tmp___25 = tmp___28;
  }
#line 1191
  if (tmp___25 == 0) {
#line 1192
    process_extended_posix_rename(id);
  } else {
#line 1193
    if (0) {
#line 1193
      __s1_len___0 = strlen((char const   *)request);
#line 1193
      __s2_len___0 = strlen("statvfs@openssh.com");
#line 1193
      if (! ((unsigned int )((void const   *)(request + 1)) - (unsigned int )((void const   *)request) == 1U)) {
        goto _L___2;
      } else {
#line 1193
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1193
          if (! ((unsigned int )((void const   *)("statvfs@openssh.com" + 1)) - (unsigned int )((void const   *)"statvfs@openssh.com") == 1U)) {
#line 1193
            tmp___19 = 1;
          } else {
#line 1193
            if (__s2_len___0 >= 4U) {
#line 1193
              tmp___19 = 1;
            } else {
#line 1193
              tmp___19 = 0;
            }
          }
        } else {
#line 1193
          tmp___19 = 0;
        }
      }
#line 1193
      if (tmp___19) {
#line 1193
        tmp___15 = __builtin_strcmp((char const   *)request, "statvfs@openssh.com");
      } else {
#line 1193
        tmp___18 = __builtin_strcmp((char const   *)request, "statvfs@openssh.com");
#line 1193
        tmp___15 = tmp___18;
      }
    } else {
#line 1193
      tmp___18 = __builtin_strcmp((char const   *)request, "statvfs@openssh.com");
#line 1193
      tmp___15 = tmp___18;
    }
#line 1193
    if (tmp___15 == 0) {
#line 1194
      process_extended_statvfs(id);
    } else {
#line 1195
      if (0) {
#line 1195
        __s1_len = strlen((char const   *)request);
#line 1195
        __s2_len = strlen("fstatvfs@openssh.com");
#line 1195
        if (! ((unsigned int )((void const   *)(request + 1)) - (unsigned int )((void const   *)request) == 1U)) {
          goto _L___0;
        } else {
#line 1195
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 1195
            if (! ((unsigned int )((void const   *)("fstatvfs@openssh.com" + 1)) - (unsigned int )((void const   *)"fstatvfs@openssh.com") == 1U)) {
#line 1195
              tmp___9 = 1;
            } else {
#line 1195
              if (__s2_len >= 4U) {
#line 1195
                tmp___9 = 1;
              } else {
#line 1195
                tmp___9 = 0;
              }
            }
          } else {
#line 1195
            tmp___9 = 0;
          }
        }
#line 1195
        if (tmp___9) {
#line 1195
          tmp___5 = __builtin_strcmp((char const   *)request, "fstatvfs@openssh.com");
        } else {
#line 1195
          tmp___8 = __builtin_strcmp((char const   *)request, "fstatvfs@openssh.com");
#line 1195
          tmp___5 = tmp___8;
        }
      } else {
#line 1195
        tmp___8 = __builtin_strcmp((char const   *)request, "fstatvfs@openssh.com");
#line 1195
        tmp___5 = tmp___8;
      }
#line 1195
      if (tmp___5 == 0) {
#line 1196
        process_extended_fstatvfs(id);
      } else {
#line 1198
        send_status(id, 8U);
      }
    }
  }
#line 1199
  xfree((void *)request);
#line 1200
  return;
}
}
#line 1204 "sftp-server.c"
static void process(void) 
{ u_int msg_len ;
  u_int buf_len ;
  u_int consumed ;
  u_int type ;
  u_char *cp ;
  void *tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 1213
  buf_len = buffer_len(& iqueue);
#line 1214
  if (buf_len < 5U) {
#line 1215
    return;
  }
#line 1216
  tmp = buffer_ptr(& iqueue);
#line 1216
  cp = (u_char *)tmp;
#line 1217
  msg_len = get_u32((void const   *)cp);
#line 1218
  if (msg_len > 262144U) {
#line 1219
    error("bad message from %s local user %s", client_addr, pw->pw_name);
#line 1221
    sftp_server_cleanup_exit(11);
  }
#line 1223
  if (buf_len < msg_len + 4U) {
#line 1224
    return;
  }
#line 1225
  buffer_consume(& iqueue, 4U);
#line 1226
  buf_len -= 4U;
#line 1227
  tmp___0 = buffer_get_char(& iqueue);
#line 1227
  type = (unsigned int )tmp___0;
#line 1228
  switch ((int )type) {
  case 1: 
#line 1230
  process_init();
#line 1231
  break;
  case 3: 
#line 1233
  process_open();
#line 1234
  break;
  case 4: 
#line 1236
  process_close();
#line 1237
  break;
  case 5: 
#line 1239
  process_read();
#line 1240
  break;
  case 6: 
#line 1242
  process_write();
#line 1243
  break;
  case 7: 
#line 1245
  process_lstat();
#line 1246
  break;
  case 8: 
#line 1248
  process_fstat();
#line 1249
  break;
  case 9: 
#line 1251
  process_setstat();
#line 1252
  break;
  case 10: 
#line 1254
  process_fsetstat();
#line 1255
  break;
  case 11: 
#line 1257
  process_opendir();
#line 1258
  break;
  case 12: 
#line 1260
  process_readdir();
#line 1261
  break;
  case 13: 
#line 1263
  process_remove();
#line 1264
  break;
  case 14: 
#line 1266
  process_mkdir();
#line 1267
  break;
  case 15: 
#line 1269
  process_rmdir();
#line 1270
  break;
  case 16: 
#line 1272
  process_realpath();
#line 1273
  break;
  case 17: 
#line 1275
  process_stat();
#line 1276
  break;
  case 18: 
#line 1278
  process_rename();
#line 1279
  break;
  case 19: 
#line 1281
  process_readlink();
#line 1282
  break;
  case 20: 
#line 1284
  process_symlink();
#line 1285
  break;
  case 200: 
#line 1287
  process_extended();
#line 1288
  break;
  default: 
#line 1290
  error("Unknown message %d", type);
#line 1291
  break;
  }
#line 1294
  tmp___1 = buffer_len(& iqueue);
#line 1294
  if (buf_len < tmp___1) {
#line 1295
    error("iqueue grew unexpectedly");
#line 1296
    sftp_server_cleanup_exit(255);
  }
#line 1298
  tmp___2 = buffer_len(& iqueue);
#line 1298
  consumed = buf_len - tmp___2;
#line 1299
  if (msg_len < consumed) {
#line 1300
    error("msg_len %d < consumed %d", msg_len, consumed);
#line 1301
    sftp_server_cleanup_exit(255);
  }
#line 1303
  if (msg_len > consumed) {
#line 1304
    buffer_consume(& iqueue, msg_len - consumed);
  }
#line 1305
  return;
}
}
#line 1308
 __attribute__((__noreturn__)) void sftp_server_cleanup_exit(int i ) ;
#line 1308 "sftp-server.c"
void sftp_server_cleanup_exit(int i ) 
{ 

  {
#line 1311
  if ((unsigned int )pw != (unsigned int )((void *)0)) {
#line 1311
    if ((unsigned int )client_addr != (unsigned int )((void *)0)) {
#line 1312
      handle_log_exit();
#line 1313
      logit("session closed for local user %s from [%s]", pw->pw_name, client_addr);
    }
  }
#line 1316
  _exit(i);
}
}
#line 1319 "sftp-server.c"
static void sftp_server_usage(void) 
{ 

  {
#line 1324
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: %s [-he] [-l log_level] [-f log_facility]\n",
          __progname);
#line 1326
  exit(1);
}
}
#line 1329 "sftp-server.c"
int sftp_server_main(int argc , char **argv , struct passwd *user_pw ) 
{ fd_set *rset ;
  fd_set *wset ;
  int in ;
  int out ;
  int max ;
  int ch ;
  int skipargs ;
  int log_stderr___0 ;
  ssize_t len ;
  ssize_t olen ;
  ssize_t set_size ;
  SyslogFacility log_facility___0 ;
  char *cp ;
  char buf___1[16384] ;
  char *tmp ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  register char __result ;
  void *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  register char __result___0 ;
  int tmp___16 ;

  {
#line 1333
  skipargs = 0;
#line 1333
  log_stderr___0 = 0;
#line 1335
  log_facility___0 = 2;
#line 1341
  __progname = ssh_get_progname(*(argv + 0));
#line 1342
  log_init(__progname, log_level, log_facility___0, log_stderr___0);
#line 1344
  while (1) {
#line 1344
    if (! skipargs) {
#line 1344
      ch = BSDgetopt(argc, (char * const  *)argv, "C:f:l:che");
#line 1344
      if (! (ch != -1)) {
#line 1344
        break;
      }
    } else {
#line 1344
      break;
    }
#line 1345
    switch (ch) {
    case 99: 
#line 1351
    skipargs = 1;
#line 1352
    break;
    case 101: 
#line 1354
    log_stderr___0 = 1;
#line 1355
    break;
    case 108: 
#line 1357
    log_level = log_level_number(BSDoptarg);
#line 1358
    if ((int )log_level == -1) {
#line 1359
      error("Invalid log level \"%s\"", BSDoptarg);
    }
#line 1360
    break;
    case 102: 
#line 1362
    log_facility___0 = log_facility_number(BSDoptarg);
#line 1363
    if ((int )log_facility___0 == -1) {
#line 1364
      error("Invalid log facility \"%s\"", BSDoptarg);
    }
#line 1365
    break;
    case 104: 
    default: 
#line 1368
    sftp_server_usage();
    }
  }
#line 1372
  log_init(__progname, log_level, log_facility___0, log_stderr___0);
#line 1374
  cp = getenv("SSH_CONNECTION");
#line 1374
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1375
    client_addr = xstrdup((char const   *)cp);
#line 1376
    tmp___1 = __builtin_strchr(client_addr, ' ');
#line 1376
    cp = tmp___1;
#line 1376
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1377
      tmp = getenv("SSH_CONNECTION");
#line 1377
      error("Malformed SSH_CONNECTION variable: \"%s\"", tmp);
#line 1379
      sftp_server_cleanup_exit(255);
    }
#line 1381
    *cp = (char )'\000';
  } else {
#line 1383
    client_addr = xstrdup("UNKNOWN");
  }
#line 1385
  pw = pwcopy(user_pw);
#line 1387
  logit("session opened for local user %s from [%s]", pw->pw_name, client_addr);
#line 1390
  in = dup(0);
#line 1391
  out = dup(1);
#line 1398
  max = 0;
#line 1399
  if (in > max) {
#line 1400
    max = in;
  }
#line 1401
  if (out > max) {
#line 1402
    max = out;
  }
#line 1404
  buffer_init(& iqueue);
#line 1405
  buffer_init(& oqueue);
#line 1407
  set_size = (int )((((unsigned int )(max + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1408
  tmp___2 = xmalloc((unsigned int )set_size);
#line 1408
  rset = (fd_set *)tmp___2;
#line 1409
  tmp___3 = xmalloc((unsigned int )set_size);
#line 1409
  wset = (fd_set *)tmp___3;
#line 1411
  while (1) {
#line 1412
    memset((void *)rset, 0, (unsigned int )set_size);
#line 1413
    memset((void *)wset, 0, (unsigned int )set_size);
#line 1420
    tmp___4 = buffer_check_alloc(& iqueue, sizeof(buf___1));
#line 1420
    if (tmp___4) {
#line 1420
      tmp___5 = buffer_check_alloc(& oqueue, 262144U);
#line 1420
      if (tmp___5) {
#line 1422
        __asm__  volatile   ("btsl %1,%0": "=m" (rset->fds_bits[(unsigned int )in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )in % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 1424
    tmp___6 = buffer_len(& oqueue);
#line 1424
    olen = (int )tmp___6;
#line 1425
    if (olen > 0) {
#line 1426
      __asm__  volatile   ("btsl %1,%0": "=m" (wset->fds_bits[(unsigned int )out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )out % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 1428
    tmp___10 = select(max + 1, (fd_set * __restrict  )rset, (fd_set * __restrict  )wset,
                      (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1428
    if (tmp___10 < 0) {
#line 1429
      tmp___7 = __errno_location();
#line 1429
      if (*tmp___7 == 4) {
        goto __Cont;
      }
#line 1431
      tmp___8 = __errno_location();
#line 1431
      tmp___9 = strerror(*tmp___8);
#line 1431
      error("select: %s", tmp___9);
#line 1432
      sftp_server_cleanup_exit(2);
    }
#line 1436
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )in % (8U * sizeof(__fd_mask ))),
                         "m" (rset->fds_bits[(unsigned int )in / (8U * sizeof(__fd_mask ))]): "cc");
#line 1436
    if (__result) {
#line 1437
      len = read(in, (void *)(buf___1), sizeof(buf___1));
#line 1438
      if (len == 0) {
#line 1439
        debug("read eof");
#line 1440
        sftp_server_cleanup_exit(0);
      } else {
#line 1441
        if (len < 0) {
#line 1442
          tmp___11 = __errno_location();
#line 1442
          tmp___12 = strerror(*tmp___11);
#line 1442
          error("read: %s", tmp___12);
#line 1443
          sftp_server_cleanup_exit(1);
        } else {
#line 1445
          buffer_append(& iqueue, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
#line 1449
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )out % (8U * sizeof(__fd_mask ))),
                         "m" (wset->fds_bits[(unsigned int )out / (8U * sizeof(__fd_mask ))]): "cc");
#line 1449
    if (__result___0) {
#line 1450
      tmp___13 = buffer_ptr(& oqueue);
#line 1450
      len = write(out, (void const   *)tmp___13, (unsigned int )olen);
#line 1451
      if (len < 0) {
#line 1452
        tmp___14 = __errno_location();
#line 1452
        tmp___15 = strerror(*tmp___14);
#line 1452
        error("write: %s", tmp___15);
#line 1453
        sftp_server_cleanup_exit(1);
      } else {
#line 1455
        buffer_consume(& oqueue, (unsigned int )len);
      }
    }
#line 1464
    tmp___16 = buffer_check_alloc(& oqueue, 262144U);
#line 1464
    if (tmp___16) {
#line 1465
      process();
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 1 "sftp-common.o"
#pragma merger(0,"./sftp-common.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "sftp-common.h"
void attrib_to_stat(Attrib const   *a___0 , struct stat *st ) ;
#line 51
char const   *fx2txt(int status ) ;
#line 48 "sftp-common.c"
void attrib_clear(Attrib *a___0 ) 
{ 

  {
#line 51
  a___0->flags = 0U;
#line 52
  a___0->size = 0ULL;
#line 53
  a___0->uid = 0U;
#line 54
  a___0->gid = 0U;
#line 55
  a___0->perm = 0U;
#line 56
  a___0->atime = 0U;
#line 57
  a___0->mtime = 0U;
#line 58
  return;
}
}
#line 61 "sftp-common.c"
void stat_to_attrib(struct stat  const  *st , Attrib *a___0 ) 
{ 

  {
#line 64
  attrib_clear(a___0);
#line 65
  a___0->flags = 0U;
#line 66
  a___0->flags |= 1U;
#line 67
  a___0->size = (unsigned long long )st->st_size;
#line 68
  a___0->flags |= 2U;
#line 69
  a___0->uid = (unsigned int )st->st_uid;
#line 70
  a___0->gid = (unsigned int )st->st_gid;
#line 71
  a___0->flags |= 4U;
#line 72
  a___0->perm = (unsigned int )st->st_mode;
#line 73
  a___0->flags |= 8U;
#line 74
  a___0->atime = (unsigned int )st->st_atim.tv_sec;
#line 75
  a___0->mtime = (unsigned int )st->st_mtim.tv_sec;
#line 76
  return;
}
}
#line 79 "sftp-common.c"
void attrib_to_stat(Attrib const   *a___0 , struct stat *st ) 
{ 

  {
#line 82
  memset((void *)st, 0, sizeof(*st));
#line 84
  if (a___0->flags & 1U) {
#line 85
    st->st_size = (long long )a___0->size;
  }
#line 86
  if (a___0->flags & 2U) {
#line 87
    st->st_uid = (unsigned int )a___0->uid;
#line 88
    st->st_gid = (unsigned int )a___0->gid;
  }
#line 90
  if (a___0->flags & 4U) {
#line 91
    st->st_mode = (unsigned int )a___0->perm;
  }
#line 92
  if (a___0->flags & 8U) {
#line 93
    st->st_atim.tv_sec = (long )a___0->atime;
#line 94
    st->st_mtim.tv_sec = (long )a___0->mtime;
  }
#line 96
  return;
}
}
#line 102 "sftp-common.c"
static Attrib a  ;
#line 99 "sftp-common.c"
Attrib *decode_attrib(Buffer *b ) 
{ char *type ;
  char *data ;
  int i ;
  int count ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 104
  attrib_clear(& a);
#line 105
  a.flags = buffer_get_int(b);
#line 106
  if (a.flags & 1U) {
#line 107
    a.size = buffer_get_int64(b);
  }
#line 108
  if (a.flags & 2U) {
#line 109
    a.uid = buffer_get_int(b);
#line 110
    a.gid = buffer_get_int(b);
  }
#line 112
  if (a.flags & 4U) {
#line 113
    a.perm = buffer_get_int(b);
  }
#line 114
  if (a.flags & 8U) {
#line 115
    a.atime = buffer_get_int(b);
#line 116
    a.mtime = buffer_get_int(b);
  }
#line 119
  if (a.flags & 2147483648U) {
#line 123
    tmp = buffer_get_int(b);
#line 123
    count = (int )tmp;
#line 124
    i = 0;
#line 124
    while (i < count) {
#line 125
      tmp___0 = buffer_get_string(b, (u_int *)((void *)0));
#line 125
      type = (char *)tmp___0;
#line 126
      tmp___1 = buffer_get_string(b, (u_int *)((void *)0));
#line 126
      data = (char *)tmp___1;
#line 127
      debug3("Got file attribute \"%s\"", type);
#line 128
      xfree((void *)type);
#line 129
      xfree((void *)data);
#line 124
      i ++;
    }
  }
#line 132
  return (& a);
}
}
#line 136 "sftp-common.c"
void encode_attrib(Buffer *b , Attrib const   *a___0 ) 
{ 

  {
#line 139
  buffer_put_int(b, (unsigned int )a___0->flags);
#line 140
  if (a___0->flags & 1U) {
#line 141
    buffer_put_int64(b, (unsigned long long )a___0->size);
  }
#line 142
  if (a___0->flags & 2U) {
#line 143
    buffer_put_int(b, (unsigned int )a___0->uid);
#line 144
    buffer_put_int(b, (unsigned int )a___0->gid);
  }
#line 146
  if (a___0->flags & 4U) {
#line 147
    buffer_put_int(b, (unsigned int )a___0->perm);
  }
#line 148
  if (a___0->flags & 8U) {
#line 149
    buffer_put_int(b, (unsigned int )a___0->atime);
#line 150
    buffer_put_int(b, (unsigned int )a___0->mtime);
  }
#line 152
  return;
}
}
#line 155 "sftp-common.c"
char const   *fx2txt(int status ) 
{ 

  {
#line 158
  switch (status) {
  case 0: 
#line 160
  return ("No error");
  case 1: 
#line 162
  return ("End of file");
  case 2: 
#line 164
  return ("No such file or directory");
  case 3: 
#line 166
  return ("Permission denied");
  case 4: 
#line 168
  return ("Failure");
  case 5: 
#line 170
  return ("Bad message");
  case 6: 
#line 172
  return ("No connection");
  case 7: 
#line 174
  return ("Connection lost");
  case 8: 
#line 176
  return ("Operation unsupported");
  default: ;
#line 178
  return ("Unknown status");
  }
}
}
#line 186 "sftp-common.c"
char *ls_file(char const   *name , struct stat  const  *st , int remote___0 ) 
{ int ulen ;
  int glen ;
  int sz ;
  struct passwd *pw___0 ;
  struct group *gr ;
  struct tm *ltime ;
  struct tm *tmp ;
  char *user ;
  char *group ;
  char buf___1[1024] ;
  char mode[12] ;
  char tbuf[13] ;
  char ubuf[12] ;
  char gbuf[12] ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  time_t tmp___2 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;

  {
#line 189
  sz = 0;
#line 192
  tmp = localtime(& st->st_mtim.tv_sec);
#line 192
  ltime = tmp;
#line 196
  strmode((int )st->st_mode, mode);
#line 197
  if (! remote___0) {
#line 197
    pw___0 = getpwuid((unsigned int )st->st_uid);
#line 197
    if ((unsigned int )pw___0 != (unsigned int )((void *)0)) {
#line 198
      user = pw___0->pw_name;
    } else {
#line 200
      snprintf((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )"%u",
               (unsigned int )st->st_uid);
#line 201
      user = ubuf;
    }
  } else {
#line 200
    snprintf((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )"%u",
             (unsigned int )st->st_uid);
#line 201
    user = ubuf;
  }
#line 203
  if (! remote___0) {
#line 203
    gr = getgrgid((unsigned int )st->st_gid);
#line 203
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 204
      group = gr->gr_name;
    } else {
#line 206
      snprintf((char * __restrict  )(gbuf), sizeof(gbuf), (char const   * __restrict  )"%u",
               (unsigned int )st->st_gid);
#line 207
      group = gbuf;
    }
  } else {
#line 206
    snprintf((char * __restrict  )(gbuf), sizeof(gbuf), (char const   * __restrict  )"%u",
             (unsigned int )st->st_gid);
#line 207
    group = gbuf;
  }
#line 209
  if ((unsigned int )ltime != (unsigned int )((void *)0)) {
#line 210
    tmp___2 = time((time_t *)((void *)0));
#line 210
    if (tmp___2 - (time_t )st->st_mtim.tv_sec < 15768000L) {
#line 211
      tmp___0 = strftime((char * __restrict  )(tbuf), sizeof(tbuf), (char const   * __restrict  )"%b %e %H:%M",
                         (struct tm  const  * __restrict  )ltime);
#line 211
      sz = (int )tmp___0;
    } else {
#line 213
      tmp___1 = strftime((char * __restrict  )(tbuf), sizeof(tbuf), (char const   * __restrict  )"%b %e  %Y",
                         (struct tm  const  * __restrict  )ltime);
#line 213
      sz = (int )tmp___1;
    }
  }
#line 215
  if (sz == 0) {
#line 216
    tbuf[0] = (char )'\000';
  }
#line 217
  tmp___6 = strlen((char const   *)user);
#line 217
  if (tmp___6 > 8U) {
#line 217
    tmp___5 = strlen((char const   *)user);
#line 217
    ulen = (int )tmp___5;
  } else {
#line 217
    ulen = 8;
  }
#line 218
  tmp___10 = strlen((char const   *)group);
#line 218
  if (tmp___10 > 8U) {
#line 218
    tmp___9 = strlen((char const   *)group);
#line 218
    glen = (int )tmp___9;
  } else {
#line 218
    glen = 8;
  }
#line 219
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s %3u %-*s %-*s %8llu %s %s",
           mode, (unsigned int )st->st_nlink, ulen, user, glen, group, (unsigned long long )st->st_size,
           tbuf, name);
#line 222
  tmp___11 = xstrdup((char const   *)(buf___1));
#line 222
  return (tmp___11);
}
}
