/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_74 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 34 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer packet ;
   Buffer identities ;
   int howmany ;
};
#line 34 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 281 "/usr/include/openssl/crypto.h"
struct bio_st;
#line 256 "/usr/include/openssl/bio.h"
typedef struct bio_st BIO;
#line 258 "/usr/include/openssl/bio.h"
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
#line 261 "/usr/include/openssl/bio.h"
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
#line 261 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 290 "/usr/include/openssl/bio.h"
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_64 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_64 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_73 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_73 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 43 "cipher.h"
struct __anonstruct_des3_77 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 43 "cipher.h"
struct __anonstruct_bf_78 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 43 "cipher.h"
struct __anonstruct_cast_79 {
   CAST_KEY key ;
   unsigned char iv[8] ;
};
#line 43 "cipher.h"
union __anonunion_u_76 {
   struct __anonstruct_des3_77 des3 ;
   struct __anonstruct_bf_78 bf ;
   struct __anonstruct_cast_79 cast ;
   RC4_KEY rc4 ;
};
#line 43 "cipher.h"
struct __anonstruct_CipherContext_75 {
   unsigned int type ;
   union __anonunion_u_76 u ;
};
#line 43 "cipher.h"
typedef struct __anonstruct_CipherContext_75 CipherContext;
#line 4 "key.h"
struct Key;
#line 4 "key.h"
typedef struct Key Key;
#line 10 "key.h"
struct Key {
   int type ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 24 "channels.h"
typedef void channel_callback_fn(int id , void *arg );
#line 26 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *dettach_user ;
};
#line 26 "channels.h"
typedef struct Channel Channel;
#line 80 "nchan.h"
typedef void chan_event_fn(Channel *c );
#line 92 "channels.c"
struct __anonstruct_ForwardPermission_79 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 92 "channels.c"
typedef struct __anonstruct_ForwardPermission_79 ForwardPermission;
#line 311 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 89 "cipher.c"
union __anonunion_t_74 {
   u_int32_t i ;
   char c[4] ;
};
#line 60 "compat.c"
struct __anonstruct_check_74 {
   char *version ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 6 "dispatch.h"
typedef void dispatch_fn(int type , int plen );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 10 "hostfile.h"
enum __anonenum_HostStatus_74 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 10 "hostfile.h"
typedef enum __anonenum_HostStatus_74 HostStatus;
#line 122 "/usr/include/openssl/ossl_typ.h"
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 55 "kex.h"
struct Kex;
#line 55 "kex.h"
typedef struct Kex Kex;
#line 56
struct Mac;
#line 56 "kex.h"
typedef struct Mac Mac;
#line 57
struct Comp;
#line 57 "kex.h"
typedef struct Comp Comp;
#line 58
struct Enc;
#line 58 "kex.h"
typedef struct Enc Enc;
#line 60 "kex.h"
struct Enc {
   int type ;
   int enabled ;
   int block_size ;
   unsigned char *key ;
   unsigned char *iv ;
   int key_len ;
   int iv_len ;
   char *name ;
};
#line 70 "kex.h"
struct Mac {
   EVP_MD *md ;
   int enabled ;
   int mac_len ;
   unsigned char *key ;
   int key_len ;
   char *name ;
};
#line 78 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 83 "kex.h"
struct Kex {
   Enc enc[2] ;
   Mac mac[2] ;
   Comp comp[2] ;
   int we_need ;
   int server ;
   char *name ;
   char *hostkeyalg ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 429 "ssh.h"
enum __anonenum_SyslogFacility_72 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 429 "ssh.h"
typedef enum __anonenum_SyslogFacility_72 SyslogFacility;
#line 443
enum __anonenum_LogLevel_73 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG = 5
} ;
#line 443 "ssh.h"
typedef enum __anonenum_LogLevel_73 LogLevel;
#line 69 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 132 "log.c"
struct __anonstruct_log_facilities_74 {
   char const   *name ;
   SyslogFacility val ;
};
#line 150 "log.c"
struct __anonstruct_log_levels_75 {
   char const   *name ;
   LogLevel val ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 54 "bsd-misc.c"
struct __anonstruct_rc4_t_74 {
   unsigned int s[256] ;
   int i ;
   int j ;
};
#line 54 "bsd-misc.c"
typedef struct __anonstruct_rc4_t_74 rc4_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 29 "servconf.h"
struct __anonstruct_ServerOptions_74 {
   unsigned int num_ports ;
   unsigned int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_file ;
   char *host_dsa_key_file ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   char *xauth_location ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int dsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
   unsigned int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups ;
};
#line 29 "servconf.h"
typedef struct __anonstruct_ServerOptions_74 ServerOptions;
#line 116 "sshd.c"
struct __anonstruct_sensitive_data_76 {
   RSA *private_key ;
   RSA *host_key ;
   Key *dsa_host_key ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 84 "auth2.c"
struct Authctxt;
#line 84 "auth2.c"
typedef struct Authctxt Authctxt;
#line 85 "auth2.c"
struct Authctxt {
   char *user ;
   char *service ;
   struct passwd pw ;
   int valid ;
};
#line 512 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 53 "auth-pam.c"
struct pam_handle_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 53 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 73 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 168 "servconf.c"
enum __anonenum_ServerOpCodes_75 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27,
    sIgnoreUserKnownHosts = 28,
    sHostDSAKeyFile = 29,
    sCiphers = 30,
    sProtocol = 31,
    sPidFile = 32,
    sGatewayPorts = 33,
    sDSAAuthentication = 34,
    sXAuthLocation = 35,
    sSubsystem = 36,
    sMaxStartups = 37
} ;
#line 168 "servconf.c"
typedef enum __anonenum_ServerOpCodes_75 ServerOpCodes;
#line 191 "servconf.c"
struct __anonstruct_keywords_76 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 75 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 75 "serverloop.c"
union __anonunion_78 {
   int volatile   __in ;
   int __i ;
};
#line 586 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 588 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 584 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 610 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 609 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 47 "session.c"
struct Session;
#line 47 "session.c"
typedef struct Session Session;
#line 48 "session.c"
struct Session {
   int used ;
   int self ;
   int extended ;
   struct passwd *pw ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
};
#line 1663 "session.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 1668 "session.c"
union __anonunion_77___0 {
   int __in ;
   int __i ;
};
#line 1670 "session.c"
union __anonunion_78___0 {
   int __in ;
   int __i ;
};
#line 1665 "session.c"
union __anonunion_79___0 {
   int __in ;
   int __i ;
};
#line 1660 "session.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 1 "atomicio.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 520 "ssh.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 50
    tmp = __errno_location();
#line 50
    if (*tmp == 4) {
#line 54
      continue;
    } else {
#line 50
      tmp___0 = __errno_location();
#line 50
      if (*tmp___0 == 11) {
#line 54
        continue;
      } else {
#line 50
        tmp___1 = __errno_location();
#line 50
        if (*tmp___1 == 11) {
#line 54
          continue;
        }
      }
    }
    case 0: 
#line 56
    return (res);
    default: 
#line 58
    pos += res;
    }
  }
#line 61
  return (pos);
}
}
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 7 "bsd-strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 462 "ssh.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 463
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 464
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 28 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 31
void buffer_free(Buffer *buffer ) ;
#line 35
void buffer_clear(Buffer *buffer ) ;
#line 38
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 51
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 41 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 48
void ssh_close_authentication_socket(int sock ) ;
#line 56
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 62
void ssh_close_authentication_connection(AuthenticationConnection *ac ) ;
#line 70
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) ;
#line 80
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) ;
#line 86
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) ;
#line 98
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) ;
#line 107
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) ;
#line 114
int ssh_remove_all_identities(AuthenticationConnection *auth ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 33
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 36
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 39
int buffer_get_char(Buffer *buffer ) ;
#line 42
void buffer_put_char(Buffer *buffer , int value ) ;
#line 52
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 55
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 30 "authfd.c"
int ssh_agent_get_reply(AuthenticationConnection *auth ) ;
#line 34 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 41
  tmp = getenv("SSH_AUTH_SOCK");
#line 41
  authsocket = (char const   *)tmp;
#line 42
  if (! authsocket) {
#line 43
    return (-1);
  }
#line 45
  sunaddr.sun_family = (unsigned short)1;
#line 46
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 48
  sock = socket(1, 1, 0);
#line 49
  if (sock < 0) {
#line 50
    return (-1);
  }
#line 53
  tmp___0 = fcntl(sock, 2, 1);
#line 53
  if (tmp___0 == -1) {
#line 54
    close(sock);
#line 55
    return (-1);
  }
#line 57
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 57
  if (tmp___1 < 0) {
#line 58
    close(sock);
#line 59
    return (-1);
  }
#line 61
  return (sock);
}
}
#line 70 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 73
  tmp = getenv("SSH_AUTH_SOCK");
#line 73
  if (tmp) {
#line 74
    close(sock);
  }
#line 75
  return;
}
}
#line 85 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 91
  sock = ssh_get_authentication_socket();
#line 97
  if (sock < 0) {
#line 98
    return ((AuthenticationConnection *)((void *)0));
  }
#line 100
  tmp = xmalloc(sizeof(*auth));
#line 100
  auth = (AuthenticationConnection *)tmp;
#line 101
  auth->fd = sock;
#line 102
  buffer_init(& auth->packet);
#line 103
  buffer_init(& auth->identities);
#line 104
  auth->howmany = 0;
#line 106
  return (auth);
}
}
#line 114 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *ac ) 
{ 

  {
#line 117
  buffer_free(& ac->packet);
#line 118
  buffer_free(& ac->identities);
#line 119
  close(ac->fd);
#line 120
  xfree((void *)ac);
#line 121
  return;
}
}
#line 130 "authfd.c"
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) 
{ unsigned char msg[8192] ;
  int len ;
  int l ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 141
  msg[0] = (unsigned char)0;
#line 142
  msg[1] = (unsigned char)0;
#line 143
  msg[2] = (unsigned char)0;
#line 144
  msg[3] = (unsigned char)1;
#line 145
  msg[4] = (unsigned char)1;
#line 146
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(msg), 5U);
#line 146
  if (tmp___1 != 5) {
#line 147
    tmp = __errno_location();
#line 147
    tmp___0 = strerror(*tmp);
#line 147
    error("write auth->fd: %.100s", tmp___0);
#line 148
    return (0);
  }
#line 151
  len = 4;
#line 152
  while (len > 0) {
#line 153
    l = read(auth->fd, (void *)((msg + 4) - len), (unsigned int )len);
#line 154
    if (l <= 0) {
#line 155
      tmp___2 = __errno_location();
#line 155
      tmp___3 = strerror(*tmp___2);
#line 155
      error("read auth->fd: %.100s", tmp___3);
#line 156
      return (0);
    }
#line 158
    len -= l;
  }
#line 165
  len = (int )(((((unsigned long )msg[0] << 24) | ((unsigned long )msg[1] << 16)) | ((unsigned long )msg[2] << 8)) | (unsigned long )msg[3]);
#line 166
  if (len < 1) {
#line 167
    fatal("Authentication reply message too long: %d\n", len);
  } else {
#line 166
    if (len > 262144) {
#line 167
      fatal("Authentication reply message too long: %d\n", len);
    }
  }
#line 170
  buffer_clear(& auth->identities);
#line 171
  while (len > 0) {
#line 172
    l = len;
#line 173
    if ((unsigned int )l > sizeof(msg)) {
#line 174
      l = (int )sizeof(msg);
    }
#line 175
    l = read(auth->fd, (void *)(msg), (unsigned int )l);
#line 176
    if (l <= 0) {
#line 177
      fatal("Incomplete authentication reply.");
    }
#line 178
    buffer_append(& auth->identities, (char const   *)((char *)(msg)), (unsigned int )l);
#line 179
    len -= l;
  }
#line 183
  buffer_get(& auth->identities, (char *)(msg), 1U);
#line 184
  if ((int )msg[0] != 2) {
#line 185
    fatal("Bad authentication reply message type: %d", msg[0]);
  }
#line 188
  tmp___4 = buffer_get_int(& auth->identities);
#line 188
  auth->howmany = (int )tmp___4;
#line 189
  if (auth->howmany > 1024) {
#line 190
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 193
  tmp___5 = ssh_get_next_identity(auth, e, n___0, comment);
#line 193
  return (tmp___5);
}
}
#line 203 "authfd.c"
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) 
{ unsigned int bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 210
  if (auth->howmany <= 0) {
#line 211
    return (0);
  }
#line 217
  bits = buffer_get_int(& auth->identities);
#line 218
  buffer_get_bignum(& auth->identities, e);
#line 219
  buffer_get_bignum(& auth->identities, n___0);
#line 220
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 222
  tmp___0 = BN_num_bits((BIGNUM const   *)n___0);
#line 222
  if (bits != (unsigned int )tmp___0) {
#line 223
    tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 223
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 227
  (auth->howmany) --;
#line 229
  return (1);
}
}
#line 240 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 252
  if (response_type == 0U) {
#line 253
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
  }
#line 256
  buf___1[0] = (unsigned char)3;
#line 257
  buffer_init(& buffer);
#line 258
  buffer_append(& buffer, (char const   *)((char *)(buf___1)), 1U);
#line 259
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 259
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 260
  buffer_put_bignum(& buffer, e);
#line 261
  buffer_put_bignum(& buffer, n___0);
#line 262
  buffer_put_bignum(& buffer, challenge);
#line 263
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 264
  buffer_put_int(& buffer, response_type);
#line 267
  tmp___0 = buffer_len(& buffer);
#line 267
  len = (int )tmp___0;
#line 268
  while (1) {
#line 268
    buf___1[0] = (unsigned char )(len >> 24);
#line 268
    buf___1[1] = (unsigned char )(len >> 16);
#line 268
    buf___1[2] = (unsigned char )(len >> 8);
#line 268
    buf___1[3] = (unsigned char )len;
#line 268
    break;
  }
#line 271
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 271
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 271
    tmp___2 = buffer_len(& buffer);
#line 271
    tmp___3 = buffer_ptr(& buffer);
#line 271
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 271
    tmp___5 = buffer_len(& buffer);
#line 271
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 274
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 276
      buffer_free(& buffer);
#line 277
      return (0);
    }
  }
#line 283
  len = 4;
#line 284
  while (len > 0) {
#line 285
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 286
    if (l <= 0) {
#line 287
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 290
    len -= l;
  }
#line 294
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 295
  if (len > 262144) {
#line 296
    fatal("Authentication response too long: %d", len);
  }
#line 299
  buffer_clear(& buffer);
#line 300
  while (len > 0) {
#line 301
    l = len;
#line 302
    if ((unsigned int )l > sizeof(buf___1)) {
#line 303
      l = (int )sizeof(buf___1);
    }
#line 304
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 305
    if (l <= 0) {
#line 306
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 309
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 310
    len -= l;
  }
#line 314
  buffer_get(& buffer, (char *)(buf___1), 1U);
#line 317
  if ((int )buf___1[0] == 5) {
#line 318
    log("Agent admitted failure to authenticate using the key.");
    goto error_cleanup;
  }
#line 322
  if ((int )buf___1[0] != 4) {
#line 323
    fatal("Bad authentication response: %d", buf___1[0]);
  }
#line 329
  i = 0;
#line 329
  while (i < 16) {
#line 330
    tmp___6 = buffer_get_char(& buffer);
#line 330
    *(response + i) = (unsigned char )tmp___6;
#line 329
    i ++;
  }
#line 333
  buffer_free(& buffer);
#line 336
  return (1);
}
}
#line 344 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
#line 353
  buffer_init(& buffer);
#line 354
  buffer_put_char(& buffer, 7);
#line 355
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 355
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 356
  buffer_put_bignum(& buffer, key->n);
#line 357
  buffer_put_bignum(& buffer, key->e);
#line 358
  buffer_put_bignum(& buffer, key->d);
#line 360
  buffer_put_bignum(& buffer, key->iqmp);
#line 361
  buffer_put_bignum(& buffer, key->q);
#line 362
  buffer_put_bignum(& buffer, key->p);
#line 363
  tmp___0 = strlen(comment);
#line 363
  buffer_put_string(& buffer, (void const   *)comment, tmp___0);
#line 366
  tmp___1 = buffer_len(& buffer);
#line 366
  len = (int )tmp___1;
#line 367
  while (1) {
#line 367
    buf___1[0] = (unsigned char )(len >> 24);
#line 367
    buf___1[1] = (unsigned char )(len >> 16);
#line 367
    buf___1[2] = (unsigned char )(len >> 8);
#line 367
    buf___1[3] = (unsigned char )len;
#line 367
    break;
  }
#line 370
  tmp___2 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 370
  if (tmp___2 != 4) {
#line 373
    error("Error writing to authentication socket.");
#line 374
    buffer_free(& buffer);
#line 375
    return (0);
  } else {
#line 370
    tmp___3 = buffer_len(& buffer);
#line 370
    tmp___4 = buffer_ptr(& buffer);
#line 370
    tmp___5 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___4, tmp___3);
#line 370
    tmp___6 = buffer_len(& buffer);
#line 370
    if ((unsigned int )tmp___5 != tmp___6) {
#line 373
      error("Error writing to authentication socket.");
#line 374
      buffer_free(& buffer);
#line 375
      return (0);
    }
  }
#line 377
  buffer_free(& buffer);
#line 378
  tmp___7 = ssh_agent_get_reply(auth);
#line 378
  return (tmp___7);
}
}
#line 386 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) 
{ Buffer buffer ;
  unsigned char buf___1[5] ;
  int len ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 394
  buffer_init(& buffer);
#line 395
  buffer_put_char(& buffer, 8);
#line 396
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 396
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 397
  buffer_put_bignum(& buffer, key->e);
#line 398
  buffer_put_bignum(& buffer, key->n);
#line 401
  tmp___0 = buffer_len(& buffer);
#line 401
  len = (int )tmp___0;
#line 402
  while (1) {
#line 402
    buf___1[0] = (unsigned char )(len >> 24);
#line 402
    buf___1[1] = (unsigned char )(len >> 16);
#line 402
    buf___1[2] = (unsigned char )(len >> 8);
#line 402
    buf___1[3] = (unsigned char )len;
#line 402
    break;
  }
#line 405
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 405
  if (tmp___1 != 4) {
#line 408
    error("Error writing to authentication socket.");
#line 409
    buffer_free(& buffer);
#line 410
    return (0);
  } else {
#line 405
    tmp___2 = buffer_len(& buffer);
#line 405
    tmp___3 = buffer_ptr(& buffer);
#line 405
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 405
    tmp___5 = buffer_len(& buffer);
#line 405
    if ((unsigned int )tmp___4 != tmp___5) {
#line 408
      error("Error writing to authentication socket.");
#line 409
      buffer_free(& buffer);
#line 410
      return (0);
    }
  }
#line 412
  buffer_free(& buffer);
#line 413
  tmp___6 = ssh_agent_get_reply(auth);
#line 413
  return (tmp___6);
}
}
#line 421 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth ) 
{ unsigned char buf___1[5] ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 427
  while (1) {
#line 427
    buf___1[0] = (unsigned char )(1 >> 24);
#line 427
    buf___1[1] = (unsigned char )(1 >> 16);
#line 427
    buf___1[2] = (unsigned char )(1 >> 8);
#line 427
    buf___1[3] = (unsigned char)1;
#line 427
    break;
  }
#line 428
  buf___1[4] = (unsigned char)9;
#line 431
  tmp = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 5U);
#line 431
  if (tmp != 5) {
#line 432
    error("Error writing to authentication socket.");
#line 433
    return (0);
  }
#line 435
  tmp___0 = ssh_agent_get_reply(auth);
#line 435
  return (tmp___0);
}
}
#line 442 "authfd.c"
int ssh_agent_get_reply(AuthenticationConnection *auth ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int type ;

  {
#line 453
  len = 4;
#line 454
  while (len > 0) {
#line 455
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 456
    if (l <= 0) {
#line 457
      error("Error reading response length from authentication socket.");
#line 458
      buffer_free(& buffer);
#line 459
      return (0);
    }
#line 461
    len -= l;
  }
#line 465
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 466
  if (len > 262144) {
#line 467
    fatal("Response from agent too long: %d", len);
  }
#line 470
  buffer_init(& buffer);
#line 471
  while (len > 0) {
#line 472
    l = len;
#line 473
    if ((unsigned int )l > sizeof(buf___1)) {
#line 474
      l = (int )sizeof(buf___1);
    }
#line 475
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 476
    if (l <= 0) {
#line 477
      error("Error reading response from authentication socket.");
#line 478
      buffer_free(& buffer);
#line 479
      return (0);
    }
#line 481
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 482
    len -= l;
  }
#line 486
  type = buffer_get_char(& buffer);
#line 487
  buffer_free(& buffer);
#line 488
  switch (type) {
  case 5: 
#line 490
  return (0);
  case 6: 
#line 492
  return (1);
  default: 
#line 494
  fatal("Bad response from authentication agent: %d", type);
  }
#line 497
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 36 "bsd-misc.h"
unsigned int arc4random(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 560 "/usr/include/openssl/bio.h"
extern BIO_METHOD *BIO_s_file(void) ;
#line 568
extern BIO *BIO_new(BIO_METHOD *type ) ;
#line 570
extern int BIO_free(BIO *a ) ;
#line 577
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
#line 192 "/usr/include/openssl/dsa.h"
extern void DSA_free(DSA *r ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 625 "/usr/include/openssl/pem.h"
extern DSA *PEM_read_bio_DSAPrivateKey(BIO *bp , DSA **x , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 70 "cipher.h"
unsigned int cipher_mask1(void) ;
#line 74
char const   *cipher_name(int cipher ) ;
#line 101
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) ;
#line 106
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 111
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 466 "ssh.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 43 "authfile.c"
int save_private_key_rsa(char const   *filename , char const   *passphrase , RSA *key ,
                         char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___1[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 58
  if (0) {
#line 58
    __s1_len = strlen(passphrase);
#line 58
    __s2_len = strlen("");
#line 58
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 58
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 58
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 58
          tmp___8 = 1;
        } else {
#line 58
          if (__s2_len >= 4U) {
#line 58
            tmp___8 = 1;
          } else {
#line 58
            tmp___8 = 0;
          }
        }
      } else {
#line 58
        tmp___8 = 0;
      }
    }
#line 58
    if (tmp___8) {
#line 58
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 58
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
      tmp___4 = tmp___7;
    }
  } else {
#line 58
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
    tmp___4 = tmp___7;
  }
#line 58
  if (tmp___4 == 0) {
#line 59
    cipher_type___0 = 0;
  } else {
#line 61
    cipher_type___0 = 3;
  }
#line 64
  buffer_init(& buffer);
#line 67
  rand___0 = arc4random();
#line 68
  buf___1[0] = (char )(rand___0 & 255U);
#line 69
  buf___1[1] = (char )((rand___0 >> 8) & 255U);
#line 70
  buf___1[2] = buf___1[0];
#line 71
  buf___1[3] = buf___1[1];
#line 72
  buffer_append(& buffer, (char const   *)(buf___1), 4U);
#line 79
  buffer_put_bignum(& buffer, key->d);
#line 80
  buffer_put_bignum(& buffer, key->iqmp);
#line 81
  buffer_put_bignum(& buffer, key->q);
#line 82
  buffer_put_bignum(& buffer, key->p);
#line 85
  while (1) {
#line 85
    tmp___9 = buffer_len(& buffer);
#line 85
    if (! (tmp___9 % 8U != 0U)) {
#line 85
      break;
    }
#line 86
    buffer_put_char(& buffer, 0);
  }
#line 89
  buffer_init(& encrypted);
#line 92
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 93
  i = 0;
#line 93
  while (*(cp + i)) {
#line 94
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 93
    i ++;
  }
#line 95
  buffer_put_char(& encrypted, 0);
#line 98
  buffer_put_char(& encrypted, cipher_type___0);
#line 99
  buffer_put_int(& encrypted, 0U);
#line 102
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 102
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 103
  buffer_put_bignum(& encrypted, key->n);
#line 104
  buffer_put_bignum(& encrypted, key->e);
#line 105
  tmp___11 = strlen(comment);
#line 105
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 108
  tmp___12 = buffer_len(& buffer);
#line 108
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 110
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 111
  tmp___13 = buffer_len(& buffer);
#line 111
  tmp___14 = buffer_ptr(& buffer);
#line 111
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 114
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  buffer_free(& buffer);
#line 120
  fd = open(filename, 577, 384);
#line 121
  if (fd < 0) {
#line 122
    return (0);
  }
#line 123
  tmp___17 = buffer_len(& encrypted);
#line 123
  tmp___18 = buffer_ptr(& encrypted);
#line 123
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 123
  tmp___20 = buffer_len(& encrypted);
#line 123
  if ((unsigned int )tmp___19 != tmp___20) {
#line 125
    tmp___15 = __errno_location();
#line 125
    tmp___16 = strerror(*tmp___15);
#line 125
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 127
    buffer_free(& encrypted);
#line 128
    close(fd);
#line 129
    remove(filename);
#line 130
    return (0);
  }
#line 132
  close(fd);
#line 133
  buffer_free(& encrypted);
#line 134
  return (1);
}
}
#line 139 "authfile.c"
int save_private_key_dsa(char const   *filename , char const   *passphrase , DSA *dsa ,
                         char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 145
  success = 1;
#line 146
  tmp = strlen(passphrase);
#line 146
  len = (int )tmp;
#line 148
  if (len > 0) {
#line 148
    if (len <= 4) {
#line 149
      error("passphrase too short: %d bytes", len);
#line 150
      tmp___0 = __errno_location();
#line 150
      *tmp___0 = 0;
#line 151
      return (0);
    }
  }
#line 153
  fd = open(filename, 577, 384);
#line 154
  if (fd < 0) {
#line 155
    debug("open %s failed", filename);
#line 156
    return (0);
  }
#line 158
  fp = fdopen(fd, "w");
#line 159
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 160
    debug("fdopen %s failed", filename);
#line 161
    close(fd);
#line 162
    return (0);
  }
#line 164
  if (len > 0) {
#line 165
    tmp___1 = strlen(passphrase);
#line 165
    tmp___2 = EVP_des_ede3_cbc();
#line 165
    tmp___3 = PEM_write_DSAPrivateKey(fp, dsa, tmp___2, (unsigned char *)((char *)passphrase),
                                      (int )tmp___1, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 165
    if (! tmp___3) {
#line 167
      success = 0;
    }
  } else {
#line 169
    tmp___4 = PEM_write_DSAPrivateKey(fp, dsa, (EVP_CIPHER const   *)((void *)0),
                                      (unsigned char *)((void *)0), 0, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 169
    if (! tmp___4) {
#line 171
      success = 0;
    }
  }
#line 173
  fclose(fp);
#line 174
  return (success);
}
}
#line 177 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 181
  switch (key->type) {
  case 0: 
#line 183
  tmp = save_private_key_rsa(filename, passphrase, key->rsa, comment);
#line 183
  return (tmp);
#line 184
  break;
  case 1: 
#line 186
  tmp___0 = save_private_key_dsa(filename, passphrase, key->dsa, comment);
#line 186
  return (tmp___0);
#line 187
  break;
  default: ;
#line 189
  break;
  }
#line 191
  return (0);
}
}
#line 200 "authfile.c"
int load_public_key_rsa(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 208
  fd = open(filename, 0);
#line 209
  if (fd < 0) {
#line 210
    return (0);
  }
#line 211
  len = lseek(fd, 0L, 2);
#line 212
  lseek(fd, 0L, 0);
#line 214
  buffer_init(& buffer);
#line 215
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 217
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 217
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 220
    buffer_free(& buffer);
#line 221
    close(fd);
#line 222
    return (0);
  }
#line 224
  close(fd);
#line 227
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 227
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 228
    debug("Bad key file %.200s.", filename);
#line 229
    buffer_free(& buffer);
#line 230
    return (0);
  }
#line 236
  i = 0;
#line 236
  while (1) {
#line 236
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 236
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 236
      break;
    }
#line 237
    tmp___3 = buffer_get_char(& buffer);
#line 237
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 238
      debug("Bad key file %.200s.", filename);
#line 239
      buffer_free(& buffer);
#line 240
      return (0);
    }
#line 236
    i ++;
  }
#line 243
  buffer_get_char(& buffer);
#line 244
  buffer_get_int(& buffer);
#line 247
  buffer_get_int(& buffer);
#line 249
  if ((unsigned int )pub->n == (unsigned int )((void *)0)) {
#line 250
    pub->n = BN_new();
  }
#line 251
  buffer_get_bignum(& buffer, pub->n);
#line 253
  if ((unsigned int )pub->e == (unsigned int )((void *)0)) {
#line 254
    pub->e = BN_new();
  }
#line 255
  buffer_get_bignum(& buffer, pub->e);
#line 256
  if (comment_return) {
#line 257
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 260
  buffer_free(& buffer);
#line 262
  return (1);
}
}
#line 265 "authfile.c"
int load_public_key(char const   *filename , Key *key , char **comment_return ) 
{ int tmp ;

  {
#line 268
  switch (key->type) {
  case 0: 
#line 270
  tmp = load_public_key_rsa(filename, key->rsa, comment_return);
#line 270
  return (tmp);
#line 271
  break;
  case 1: 
  default: ;
#line 274
  break;
  }
#line 276
  return (0);
}
}
#line 286 "authfile.c"
int load_private_key_rsa(int fd , char const   *filename , char const   *passphrase ,
                         RSA *prv , char **comment_return ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  BIGNUM const   *tmp___23 ;
  BIGNUM const   *tmp___24 ;

  {
#line 298
  len = lseek(fd, 0L, 2);
#line 299
  lseek(fd, 0L, 0);
#line 301
  buffer_init(& buffer);
#line 302
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 304
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 304
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 305
    tmp = __errno_location();
#line 305
    tmp___0 = strerror(*tmp);
#line 305
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 307
    buffer_free(& buffer);
#line 308
    close(fd);
#line 309
    return (0);
  }
#line 311
  close(fd);
#line 314
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 314
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 315
    debug("Bad key file %.200s.", filename);
#line 316
    buffer_free(& buffer);
#line 317
    return (0);
  }
#line 323
  i = 0;
#line 323
  while (1) {
#line 323
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 323
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 323
      break;
    }
#line 324
    tmp___3 = buffer_get_char(& buffer);
#line 324
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 325
      debug("Bad key file %.200s.", filename);
#line 326
      buffer_free(& buffer);
#line 327
      return (0);
    }
#line 323
    i ++;
  }
#line 330
  cipher_type___0 = buffer_get_char(& buffer);
#line 331
  buffer_get_int(& buffer);
#line 334
  buffer_get_int(& buffer);
#line 335
  prv->n = BN_new();
#line 336
  buffer_get_bignum(& buffer, prv->n);
#line 337
  prv->e = BN_new();
#line 338
  buffer_get_bignum(& buffer, prv->e);
#line 339
  if (comment_return) {
#line 340
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 342
    tmp___5 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 342
    xfree((void *)tmp___5);
  }
#line 345
  tmp___7 = cipher_mask1();
#line 345
  if (((tmp___7 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 347
    tmp___6 = cipher_name(cipher_type___0);
#line 347
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___6, filename);
#line 349
    buffer_free(& buffer);
    goto fail;
  }
#line 353
  buffer_init(& decrypted);
#line 354
  tmp___8 = buffer_len(& buffer);
#line 354
  buffer_append_space(& decrypted, & cp, tmp___8);
#line 357
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 358
  tmp___9 = buffer_len(& buffer);
#line 358
  tmp___10 = buffer_ptr(& buffer);
#line 358
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___10),
                 tmp___9);
#line 362
  buffer_free(& buffer);
#line 364
  check1 = buffer_get_char(& decrypted);
#line 365
  check2 = buffer_get_char(& decrypted);
#line 366
  tmp___21 = buffer_get_char(& decrypted);
#line 366
  if (check1 != tmp___21) {
    goto _L___1;
  } else {
#line 366
    tmp___22 = buffer_get_char(& decrypted);
#line 366
    if (check2 != tmp___22) {
      _L___1: /* CIL Label */ 
#line 368
      if (0) {
#line 368
        __s1_len = strlen(passphrase);
#line 368
        __s2_len = strlen("");
#line 368
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 368
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 368
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 368
              tmp___20 = 1;
            } else {
#line 368
              if (__s2_len >= 4U) {
#line 368
                tmp___20 = 1;
              } else {
#line 368
                tmp___20 = 0;
              }
            }
          } else {
#line 368
            tmp___20 = 0;
          }
        }
#line 368
        if (tmp___20) {
#line 368
          tmp___16 = __builtin_strcmp(passphrase, "");
        } else {
#line 368
          tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
          tmp___16 = tmp___19;
        }
      } else {
#line 368
        tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
        tmp___16 = tmp___19;
      }
#line 368
      if (tmp___16 != 0) {
#line 369
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 371
      buffer_free(& decrypted);
      fail: 
#line 373
      BN_clear_free(prv->n);
#line 374
      prv->n = (BIGNUM *)((void *)0);
#line 375
      BN_clear_free(prv->e);
#line 376
      prv->e = (BIGNUM *)((void *)0);
#line 377
      if (comment_return) {
#line 378
        xfree((void *)*comment_return);
      }
#line 379
      return (0);
    }
  }
#line 382
  prv->d = BN_new();
#line 383
  buffer_get_bignum(& decrypted, prv->d);
#line 384
  prv->iqmp = BN_new();
#line 385
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 387
  prv->q = BN_new();
#line 388
  buffer_get_bignum(& decrypted, prv->q);
#line 389
  prv->p = BN_new();
#line 390
  buffer_get_bignum(& decrypted, prv->p);
#line 392
  ctx = BN_CTX_new();
#line 393
  aux = BN_new();
#line 395
  tmp___23 = BN_value_one();
#line 395
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___23);
#line 396
  prv->dmq1 = BN_new();
#line 397
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 399
  tmp___24 = BN_value_one();
#line 399
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___24);
#line 400
  prv->dmp1 = BN_new();
#line 401
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 403
  BN_clear_free(aux);
#line 404
  BN_CTX_free(ctx);
#line 406
  buffer_free(& decrypted);
#line 408
  return (1);
}
}
#line 411 "authfile.c"
int load_private_key_dsa(int fd , char const   *passphrase , Key *k , char **comment_return ) 
{ DSA *dsa ;
  BIO *in ;
  FILE *fp ;
  BIO_METHOD *tmp ;
  int tmp___0 ;

  {
#line 418
  tmp = BIO_s_file();
#line 418
  in = BIO_new(tmp);
#line 419
  if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 420
    error("BIO_new failed");
#line 421
    return (0);
  }
#line 423
  fp = fdopen(fd, "r");
#line 424
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 425
    error("fdopen failed");
#line 426
    return (0);
  }
#line 428
  BIO_ctrl(in, 106, 0L, (void *)((char *)fp));
#line 429
  dsa = PEM_read_bio_DSAPrivateKey(in, (DSA **)((void *)0), (pem_password_cb *)((void *)0),
                                   (void *)((char *)passphrase));
#line 430
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 431
    debug("PEM_read_bio_DSAPrivateKey failed");
  } else {
#line 434
    DSA_free(k->dsa);
#line 435
    k->dsa = dsa;
  }
#line 437
  BIO_free(in);
#line 438
  fclose(fp);
#line 439
  if (comment_return) {
#line 440
    *comment_return = xstrdup("dsa w/o comment");
  }
#line 441
  debug("read DSA private key done");
#line 445
  if ((unsigned int )dsa != (unsigned int )((void *)0)) {
#line 445
    tmp___0 = 1;
  } else {
#line 445
    tmp___0 = 0;
  }
#line 445
  return (tmp___0);
}
}
#line 448 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char **comment_return ) 
{ int fd ;
  int ret ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 453
  ret = 0;
#line 456
  fd = open(filename, 0);
#line 457
  if (fd < 0) {
#line 458
    return (0);
  }
#line 461
  tmp = fstat(fd, & st);
#line 461
  if (tmp < 0) {
    goto _L;
  } else {
#line 461
    if (st.st_uid != 0U) {
#line 461
      tmp___0 = getuid();
#line 461
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 461
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 464
        close(fd);
#line 465
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 466
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 467
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 468
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 470
        error("It is recommended that your private key files are NOT accessible by others.");
#line 471
        return (0);
      }
    }
  }
#line 473
  switch (key->type) {
  case 0: 
#line 475
  if ((unsigned int )(key->rsa)->e != (unsigned int )((void *)0)) {
#line 476
    BN_clear_free((key->rsa)->e);
#line 477
    (key->rsa)->e = (BIGNUM *)((void *)0);
  }
#line 479
  if ((unsigned int )(key->rsa)->n != (unsigned int )((void *)0)) {
#line 480
    BN_clear_free((key->rsa)->n);
#line 481
    (key->rsa)->n = (BIGNUM *)((void *)0);
  }
#line 483
  ret = load_private_key_rsa(fd, filename, passphrase, key->rsa, comment_return);
#line 485
  break;
  case 1: 
#line 487
  ret = load_private_key_dsa(fd, passphrase, key, comment_return);
  default: ;
#line 489
  break;
  }
#line 491
  close(fd);
#line 492
  return (ret);
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "aux.o"
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 490 "ssh.h"
char *chop(char *s ) ;
#line 493
char *strdelim(char **s ) ;
#line 496
void set_nonblock(int fd ) ;
#line 6 "aux.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 9
  t = s;
#line 10
  while (*t) {
#line 11
    if ((int )*t == 10) {
#line 12
      *t = (char )'\000';
#line 13
      return (s);
    } else {
#line 11
      if ((int )*t == 13) {
#line 12
        *t = (char )'\000';
#line 13
        return (s);
      }
    }
#line 15
    t ++;
  }
#line 17
  return (s);
}
}
#line 21 "aux.c"
void set_nonblock(int fd ) 
{ int val ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 25
  tmp = isatty(fd);
#line 25
  if (tmp) {
#line 27
    debug("no set_nonblock for tty fd %d", fd);
#line 28
    return;
  }
#line 30
  val = fcntl(fd, 3, 0);
#line 31
  if (val < 0) {
#line 32
    tmp___0 = __errno_location();
#line 32
    tmp___1 = strerror(*tmp___0);
#line 32
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___1);
#line 33
    return;
  }
#line 35
  if (val & 2048) {
#line 36
    return;
  }
#line 37
  debug("fd %d setting O_NONBLOCK", fd);
#line 38
  val |= 2048;
#line 39
  tmp___4 = fcntl(fd, 4, val);
#line 39
  if (tmp___4 == -1) {
#line 40
    tmp___2 = __errno_location();
#line 40
    tmp___3 = strerror(*tmp___2);
#line 40
    error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___3);
  }
#line 41
  return;
}
}
#line 46 "aux.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 50
  wspace = 0;
#line 52
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 53
    return ((char *)((void *)0));
  }
#line 55
  old = *s;
#line 57
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 57
  *s = tmp___30;
#line 58
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 59
    return (old);
  }
#line 62
  if ((int )*(*(s + 0)) == 61) {
#line 63
    wspace = 1;
  }
#line 64
  *(*(s + 0)) = (char )'\000';
#line 66
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 66
  *s += tmp___62 + 1U;
#line 67
  if ((int )*(*(s + 0)) == 61) {
#line 67
    if (! wspace) {
#line 68
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 68
      *s += tmp___94 + 1U;
    }
  }
#line 70
  return (old);
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 54 "buffer.h"
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 26 "bufaux.h"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 30
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 56
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 32 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 35
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 35
  bits = tmp;
#line 36
  bin_size = (bits + 7) / 8;
#line 37
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 37
  buf___1 = (unsigned char *)tmp___0;
#line 42
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1);
#line 43
  if (oi != bin_size) {
#line 44
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 48
  while (1) {
#line 48
    msg[0] = (char )(bits >> 8);
#line 48
    msg[1] = (char )bits;
#line 48
    break;
  }
#line 49
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 51
  buffer_append(buffer, (char const   *)((char *)buf___1), (unsigned int )oi);
#line 53
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 54
  xfree((void *)buf___1);
#line 55
  return;
}
}
#line 60 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf___1[2] ;
  unsigned char *bin ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 67
  buffer_get(buffer, (char *)(buf___1), 2U);
#line 68
  bits = (int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 70
  bytes = (bits + 7) / 8;
#line 71
  tmp = buffer_len(buffer);
#line 71
  if (tmp < (unsigned int )bytes) {
#line 72
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 73
  tmp___0 = buffer_ptr(buffer);
#line 73
  bin = (unsigned char *)tmp___0;
#line 74
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 75
  buffer_consume(buffer, (unsigned int )bytes);
#line 77
  return (2 + bytes);
}
}
#line 83 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  unsigned char *uc ;
  int tmp___1 ;

  {
#line 86
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 86
  bytes = (tmp + 7) / 8 + 1;
#line 87
  tmp___0 = xmalloc((unsigned int )bytes);
#line 87
  buf___1 = (unsigned char *)tmp___0;
#line 89
  hasnohigh = 0;
#line 90
  *(buf___1 + 0) = (unsigned char )'\000';
#line 92
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1 + 1);
#line 93
  if (oi != bytes - 1) {
#line 94
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 96
  if ((int )*(buf___1 + 1) & 128) {
#line 96
    hasnohigh = 0;
  } else {
#line 96
    hasnohigh = 1;
  }
#line 97
  if (value->neg) {
#line 100
    uc = buf___1;
#line 101
    log("negativ!");
#line 102
    i = bytes - 1;
#line 102
    carry = 1;
#line 102
    while (i >= 0) {
#line 103
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 104
      if (carry) {
#line 105
        *(uc + i) = (unsigned char )((int )*(uc + i) + 1);
#line 105
        if (*(uc + i)) {
#line 105
          tmp___1 = 0;
        } else {
#line 105
          tmp___1 = 1;
        }
#line 105
        carry = tmp___1;
      }
#line 102
      i --;
    }
  }
#line 108
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 109
  memset((void *)buf___1, 0, (unsigned int )bytes);
#line 110
  xfree((void *)buf___1);
#line 111
  return;
}
}
#line 113 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  unsigned char *bin ;
  char *tmp ;

  {
#line 118
  tmp = buffer_get_string(buffer, (unsigned int *)(& len));
#line 118
  bin = (unsigned char *)tmp;
#line 119
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 120
  xfree((void *)bin);
#line 121
  return (len);
}
}
#line 127 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf___1[4] ;

  {
#line 131
  buffer_get(buffer, (char *)(buf___1), 4U);
#line 132
  return ((unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]));
}
}
#line 138 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf___1[4] ;

  {
#line 142
  while (1) {
#line 142
    buf___1[0] = (char )(value >> 24);
#line 142
    buf___1[1] = (char )(value >> 16);
#line 142
    buf___1[2] = (char )(value >> 8);
#line 142
    buf___1[3] = (char )value;
#line 142
    break;
  }
#line 143
  buffer_append(buffer, (char const   *)(buf___1), 4U);
#line 144
  return;
}
}
#line 154 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 160
  len = buffer_get_int(buffer);
#line 161
  if (len > 262144U) {
#line 162
    fatal("Received packet with bad string length %d", len);
  }
#line 164
  tmp = xmalloc(len + 1U);
#line 164
  value = (char *)tmp;
#line 166
  buffer_get(buffer, value, len);
#line 168
  *(value + len) = (char)0;
#line 170
  if (length_ptr) {
#line 171
    *length_ptr = len;
  }
#line 172
  return (value);
}
}
#line 178 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) 
{ 

  {
#line 181
  buffer_put_int(buffer, len);
#line 182
  buffer_append(buffer, (char const   *)buf___1, len);
#line 183
  return;
}
}
#line 184 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 187
  tmp = strlen(s);
#line 187
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 188
  return;
}
}
#line 193 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 197
  buffer_get(buffer, & ch, 1U);
#line 198
  return ((int )((unsigned char )ch));
}
}
#line 204 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 207
  ch = (char )value;
#line 208
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 209
  return;
}
}
#line 1 "buffer.o"
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 57 "buffer.h"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 66
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 28
  buffer->alloc = 4096U;
#line 29
  tmp = xmalloc(buffer->alloc);
#line 29
  buffer->buf = (char *)tmp;
#line 30
  buffer->offset = 0U;
#line 31
  buffer->end = 0U;
#line 32
  return;
}
}
#line 36 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 39
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 40
  xfree((void *)buffer->buf);
#line 41
  return;
}
}
#line 48 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 51
  buffer->offset = 0U;
#line 52
  buffer->end = 0U;
#line 53
  return;
}
}
#line 57 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 61
  buffer_append_space(buffer, & cp, len);
#line 62
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 63
  return;
}
}
#line 71 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 75
  if (buffer->offset == buffer->end) {
#line 76
    buffer->offset = 0U;
#line 77
    buffer->end = 0U;
  }
  restart: 
#line 81
  if (buffer->end + len < buffer->alloc) {
#line 82
    *datap = buffer->buf + buffer->end;
#line 83
    buffer->end += len;
#line 84
    return;
  }
#line 90
  if (buffer->offset > buffer->alloc / 2U) {
#line 91
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 93
    buffer->end -= buffer->offset;
#line 94
    buffer->offset = 0U;
    goto restart;
  }
#line 98
  buffer->alloc += len + 32768U;
#line 99
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 99
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 105 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 108
  return (buffer->end - buffer->offset);
}
}
#line 113 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) 
{ 

  {
#line 116
  if (len > buffer->end - buffer->offset) {
#line 117
    fatal("buffer_get: trying to get more bytes than in buffer");
  }
#line 118
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 119
  buffer->offset += len;
#line 120
  return;
}
}
#line 124 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 127
  if (bytes > buffer->end - buffer->offset) {
#line 128
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 129
  buffer->offset += bytes;
#line 130
  return;
}
}
#line 134 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 137
  if (bytes > buffer->end - buffer->offset) {
#line 138
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 139
  buffer->end -= bytes;
#line 140
  return;
}
}
#line 144 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 147
  return (buffer->buf + buffer->offset);
}
}
#line 152 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 156
  ucp = (unsigned char *)buffer->buf;
#line 158
  i = (int )buffer->offset;
#line 158
  while ((unsigned int )i < buffer->end) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 158
    i ++;
  }
#line 160
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 161
  return;
}
}
#line 1 "canohost.o"
#line 114 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 34 "packet.h"
int packet_get_connection_in(void) ;
#line 152
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 210
int packet_connection_is_on_socket(void) ;
#line 388 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 395
char const   *get_canonical_hostname(void) ;
#line 401
char const   *get_remote_ipaddr(void) ;
#line 404
int get_peer_port(int sock ) ;
#line 407
int get_remote_port(void) ;
#line 408
int get_local_port(void) ;
#line 469
void fatal_cleanup(void) ;
#line 28 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[64] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  socklen_t option_size ;
  int ipproto ;
  struct protoent *ip ;
  int tmp___20 ;
  char *tmp___21 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 47
  if ((int )from.ss_family == 10) {
#line 48
    from6 = (struct sockaddr_in6 *)(& from);
#line 52
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 52
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 52
        __x = 65535U;
#line 52
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 52
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 53
          from4 = (struct sockaddr_in *)(& from);
#line 57
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 58
          port = from6->sin6_port;
#line 60
          memset((void *)(& from), 0, sizeof(from));
#line 62
          from4->sin_family = (unsigned short)2;
#line 63
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 64
          from4->sin_port = port;
        }
      }
    }
  }
#line 69
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 69
  if (tmp___2 != 0) {
#line 71
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                         fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                         0U, 8U);
#line 74
  if (tmp___19 == 0) {
#line 77
    name[sizeof(name) - 1U] = (char )'\000';
#line 82
    i = 0;
#line 82
    while (name[i]) {
#line 83
      tmp___6 = __ctype_b_loc();
#line 83
      if ((int const   )*(*tmp___6 + (int )name[i]) & 256) {
#line 84
        if (sizeof(name[i]) > 1U) {
#line 84
          __res = tolower((int )name[i]);
        } else {
#line 84
          tmp___5 = __ctype_tolower_loc();
#line 84
          __res = (int )*(*tmp___5 + (int )name[i]);
        }
#line 84
        name[i] = (char )__res;
      }
#line 82
      i ++;
    }
#line 95
    memset((void *)(& hints), 0, sizeof(hints));
#line 96
    hints.ai_family = (int )from.ss_family;
#line 97
    hints.ai_socktype = 1;
#line 98
    tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                          (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 98
    if (tmp___7 != 0) {
#line 99
      log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 100
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
#line 104
    ai = aitop;
#line 104
    while (ai) {
#line 105
      tmp___8 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                            (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                            0U, 1U);
#line 107
      if (tmp___8 == 0) {
#line 107
        if (0) {
#line 107
          __s1_len = strlen((char const   *)(ntop));
#line 107
          __s2_len = strlen((char const   *)(ntop2));
#line 107
          if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
            goto _L___0;
          } else {
#line 107
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 107
              if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 107
                tmp___18 = 1;
              } else {
#line 107
                if (__s2_len >= 4U) {
#line 107
                  tmp___18 = 1;
                } else {
#line 107
                  tmp___18 = 0;
                }
              }
            } else {
#line 107
              tmp___18 = 0;
            }
          }
#line 107
          if (tmp___18) {
#line 107
            tmp___14 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
          } else {
#line 107
            tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
            tmp___14 = tmp___17;
          }
        } else {
#line 107
          tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
          tmp___14 = tmp___17;
        }
#line 107
        if (tmp___14 == 0) {
#line 108
          break;
        }
      }
#line 104
      ai = ai->ai_next;
    }
#line 110
    freeaddrinfo(aitop);
#line 112
    if (! ai) {
#line 114
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          ntop, name);
#line 116
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 122
    strlcpy(name, (char const   *)(ntop), sizeof(name));
#line 123
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 140
  if ((int )from.ss_family == 2) {
#line 147
    ip = getprotobyname("ip");
#line 147
    if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 148
      ipproto = ip->p_proto;
    } else {
#line 150
      ipproto = 0;
    }
#line 151
    option_size = sizeof(options___0);
#line 152
    tmp___20 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                          (socklen_t * __restrict  )(& option_size));
#line 152
    if (tmp___20 >= 0) {
#line 152
      if (option_size != 0U) {
#line 154
        cp = text;
#line 156
        ucp = options___0;
#line 156
        while (option_size > 0U) {
#line 157
          sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x",
                  *ucp);
#line 156
          ucp ++;
#line 156
          option_size --;
#line 156
          cp += 3;
        }
#line 158
        log("Connection from %.100s with IP options:%.800s", ntop, text);
#line 160
        packet_disconnect("Connection from %.100s with IP options:%.800s", ntop, text);
      }
    }
  }
#line 165
  tmp___21 = xstrdup((char const   *)(name));
#line 165
  return (tmp___21);
}
}
#line 177 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 174 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 180
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 181
    return ((char const   *)canonical_host_name);
  }
#line 184
  tmp___0 = packet_connection_is_on_socket();
#line 184
  if (tmp___0) {
#line 185
    tmp = packet_get_connection_in();
#line 185
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 187
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 189
  return ((char const   *)canonical_host_name);
}
}
#line 200 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 197 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  int socket___0 ;
  char ntop[1025] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 207
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 208
    return ((char const   *)canonical_host_ip);
  }
#line 211
  tmp = packet_connection_is_on_socket();
#line 211
  if (! tmp) {
#line 212
    canonical_host_ip = xstrdup("UNKNOWN");
#line 213
    return ((char const   *)canonical_host_ip);
  }
#line 216
  socket___0 = packet_get_connection_in();
#line 219
  fromlen = sizeof(from);
#line 220
  memset((void *)(& from), 0, sizeof(from));
#line 221
  tmp___2 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 221
  if (tmp___2 < 0) {
#line 222
    tmp___0 = __errno_location();
#line 222
    tmp___1 = strerror(*tmp___0);
#line 222
    debug("getpeername failed: %.100s", tmp___1);
#line 223
    fatal_cleanup();
  }
#line 226
  tmp___3 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 226
  if (tmp___3 != 0) {
#line 228
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 230
  canonical_host_ip = xstrdup((char const   *)(ntop));
#line 233
  return ((char const   *)canonical_host_ip);
}
}
#line 238 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 246
  fromlen = sizeof(from);
#line 247
  memset((void *)(& from), 0, sizeof(from));
#line 248
  if (local) {
#line 249
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 249
    if (tmp___1 < 0) {
#line 250
      tmp = __errno_location();
#line 250
      tmp___0 = strerror(*tmp);
#line 250
      error("getsockname failed: %.100s", tmp___0);
#line 251
      return (0);
    }
  } else {
#line 254
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 254
    if (tmp___4 < 0) {
#line 255
      tmp___2 = __errno_location();
#line 255
      tmp___3 = strerror(*tmp___2);
#line 255
      debug("getpeername failed: %.100s", tmp___3);
#line 256
      fatal_cleanup();
    }
  }
#line 260
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 260
  if (tmp___5 != 0) {
#line 262
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 263
  tmp___6 = atoi((char const   *)(strport));
#line 263
  return (tmp___6);
}
}
#line 268 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 275
  tmp = packet_connection_is_on_socket();
#line 275
  if (! tmp) {
#line 276
    return (65535);
  }
#line 279
  tmp___0 = packet_get_connection_in();
#line 279
  tmp___1 = get_sock_port(tmp___0, local);
#line 279
  return (tmp___1);
}
}
#line 282 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 285
  tmp = get_sock_port(sock, 0);
#line 285
  return (tmp);
}
}
#line 288 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 291
  tmp = get_port(0);
#line 291
  return (tmp);
}
}
#line 294 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 297
  tmp = get_port(1);
#line 297
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 465 "ssh.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 476
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 554
int IPv4or6 ;
#line 73 "packet.h"
int packet_is_interactive(void) ;
#line 76
void packet_start(int type ) ;
#line 79
void packet_put_char(int value ) ;
#line 82
void packet_put_int(unsigned int value ) ;
#line 89
void packet_put_string(char const   *buf___1 , unsigned int len ) ;
#line 90
void packet_put_cstring(char const   *str ) ;
#line 97
void packet_send(void) ;
#line 106
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 128
unsigned int packet_get_int(void) ;
#line 144
char *packet_get_string(unsigned int *length_ptr ) ;
#line 164
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 170
void packet_write_wait(void) ;
#line 179
int max_packet_size ;
#line 217
int packet_remaining(void) ;
#line 22 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 28
void restore_uid(void) ;
#line 70 "channels.h"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) ;
#line 71
void channel_open(int id ) ;
#line 72
void channel_request(int id , char *service , int wantconfirm ) ;
#line 73
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 74
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 75
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 76
void channel_cancel_cleanup(int id ) ;
#line 77
Channel *channel_lookup(int id ) ;
#line 79
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) ;
#line 83
void channel_input_channel_request(int type , int plen ) ;
#line 84
void channel_input_close(int type , int plen ) ;
#line 85
void channel_input_close_confirmation(int type , int plen ) ;
#line 86
void channel_input_data(int type , int plen ) ;
#line 87
void channel_input_extended_data(int type , int plen ) ;
#line 88
void channel_input_ieof(int type , int plen ) ;
#line 89
void channel_input_oclose(int type , int plen ) ;
#line 90
void channel_input_open_confirmation(int type , int plen ) ;
#line 91
void channel_input_open_failure(int type , int plen ) ;
#line 92
void channel_input_port_open(int type , int plen ) ;
#line 93
void channel_input_window_adjust(int type , int plen ) ;
#line 97
void channel_set_options(int hostname_in_open ) ;
#line 104
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 107
void channel_free(int id ) ;
#line 110
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 116
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 119
void channel_output_poll(void) ;
#line 122
int channel_not_very_much_buffered_data(void) ;
#line 126
void channel_stop_listening(void) ;
#line 132
void channel_close_all(void) ;
#line 135
int channel_max_fd(void) ;
#line 138
int channel_still_open(void) ;
#line 145
char *channel_open_message(void) ;
#line 152
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) ;
#line 162
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 171
void channel_permit_all_opens(void) ;
#line 178
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 191
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 198
void x11_input_open(int type , int plen ) ;
#line 210
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 215
void auth_request_forwarding(void) ;
#line 222
char *auth_get_socket_name(void) ;
#line 228
int auth_input_request_forwarding(struct passwd *pw ) ;
#line 231
void auth_input_open_request(int type , int plen ) ;
#line 234
int channel_connect_to(char const   *host , u_short host_port ) ;
#line 235
int x11_connect_display(void) ;
#line 83 "nchan.h"
chan_event_fn *chan_rcvd_oclose ;
#line 84
chan_event_fn *chan_read_failed ;
#line 85
chan_event_fn *chan_ibuf_empty ;
#line 88
chan_event_fn *chan_rcvd_ieof ;
#line 89
chan_event_fn *chan_write_failed ;
#line 90
chan_event_fn *chan_obuf_empty ;
#line 92
chan_event_fn *chan_delete_if_full_closed ;
#line 94
void chan_init_iostates(Channel *c ) ;
#line 95
void chan_init(void) ;
#line 49 "compat.h"
int compat13 ;
#line 50
int compat20 ;
#line 51
int datafellows ;
#line 53 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 60 "channels.c"
static int channels_alloc  =    0;
#line 66 "channels.c"
static int channel_max_fd_value  =    0;
#line 69 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 70 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 73 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 76 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 77 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 83 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 84 "channels.c"
unsigned int x11_fake_data_len  ;
#line 99 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 101 "channels.c"
static int num_permitted_opens  =    0;
#line 107 "channels.c"
static int all_opens_permitted  =    0;
#line 110 "channels.c"
static int have_hostname_in_open  =    0;
#line 114 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 117
  have_hostname_in_open = hostname_in_open;
#line 118
  return;
}
}
#line 126 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 129
  all_opens_permitted = 1;
#line 130
  return;
}
}
#line 134 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 138
  if (id < 0) {
#line 139
    log("channel_lookup: %d: bad id", id);
#line 140
    return ((Channel *)((void *)0));
  } else {
#line 138
    if (id > channels_alloc) {
#line 139
      log("channel_lookup: %d: bad id", id);
#line 140
      return ((Channel *)((void *)0));
    }
  }
#line 142
  c = channels + id;
#line 143
  if (c->type == 0) {
#line 144
    log("channel_lookup: %d: bad id: channel free", id);
#line 145
    return ((Channel *)((void *)0));
  }
#line 147
  return (c);
}
}
#line 155 "channels.c"
void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ) 
{ 

  {
#line 159
  if (rfd > channel_max_fd_value) {
#line 160
    channel_max_fd_value = rfd;
  }
#line 161
  if (wfd > channel_max_fd_value) {
#line 162
    channel_max_fd_value = wfd;
  }
#line 163
  if (efd > channel_max_fd_value) {
#line 164
    channel_max_fd_value = efd;
  }
#line 167
  c->rfd = rfd;
#line 168
  c->wfd = wfd;
#line 169
  if (rfd == wfd) {
#line 169
    c->sock = rfd;
  } else {
#line 169
    c->sock = -1;
  }
#line 170
  c->efd = efd;
#line 171
  c->extended_usage = extusage;
#line 172
  if (rfd != -1) {
#line 173
    set_nonblock(rfd);
  }
#line 174
  if (wfd != -1) {
#line 175
    set_nonblock(wfd);
  }
#line 176
  if (efd != -1) {
#line 177
    set_nonblock(efd);
  }
#line 178
  return;
}
}
#line 185 "channels.c"
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 193
  if (channels_alloc == 0) {
#line 194
    chan_init();
#line 195
    channels_alloc = 10;
#line 196
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 196
    channels = (Channel *)tmp;
#line 197
    i = 0;
#line 197
    while (i < channels_alloc) {
#line 198
      (channels + i)->type = 0;
#line 197
      i ++;
    }
#line 203
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 206
  found = -1;
#line 206
  i = 0;
#line 206
  while (i < channels_alloc) {
#line 207
    if ((channels + i)->type == 0) {
#line 209
      found = i;
#line 210
      break;
    }
#line 206
    i ++;
  }
#line 212
  if (found == -1) {
#line 214
    found = channels_alloc;
#line 215
    channels_alloc += 10;
#line 216
    debug("channel: expanding %d", channels_alloc);
#line 217
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 217
    channels = (Channel *)tmp___0;
#line 218
    i = found;
#line 218
    while (i < channels_alloc) {
#line 219
      (channels + i)->type = 0;
#line 218
      i ++;
    }
  }
#line 222
  c = channels + found;
#line 223
  buffer_init(& c->input);
#line 224
  buffer_init(& c->output);
#line 225
  buffer_init(& c->extended);
#line 226
  chan_init_iostates(c);
#line 227
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 228
  c->self = found;
#line 229
  c->type = type;
#line 230
  c->ctype = ctype;
#line 231
  c->local_window = window;
#line 232
  c->local_window_max = window;
#line 233
  c->local_consumed = 0;
#line 234
  c->local_maxpacket = maxpack;
#line 235
  c->remote_id = -1;
#line 236
  c->remote_name = remote_name;
#line 237
  c->remote_window = 0;
#line 238
  c->remote_maxpacket = 0;
#line 239
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 240
  c->cb_arg = (void *)0;
#line 241
  c->cb_event = 0;
#line 242
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 243
  debug("channel %d: new [%s]", found, remote_name);
#line 244
  return (found);
}
}
#line 247 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int tmp ;

  {
#line 250
  tmp = channel_new((char *)"", type, sock, sock, -1, 0, 0, 0, remote_name);
#line 250
  return (tmp);
}
}
#line 256 "channels.c"
void channel_close_fds(Channel *c ) 
{ 

  {
#line 259
  if (c->sock != -1) {
#line 260
    close(c->sock);
#line 261
    c->sock = -1;
  }
#line 263
  if (c->rfd != -1) {
#line 264
    close(c->rfd);
#line 265
    c->rfd = -1;
  }
#line 267
  if (c->wfd != -1) {
#line 268
    close(c->wfd);
#line 269
    c->wfd = -1;
  }
#line 271
  if (c->efd != -1) {
#line 272
    close(c->efd);
#line 273
    c->efd = -1;
  }
#line 275
  return;
}
}
#line 279 "channels.c"
void channel_free(int id ) 
{ Channel *c ;
  Channel *tmp ;
  char *tmp___0 ;

  {
#line 282
  tmp = channel_lookup(id);
#line 282
  c = tmp;
#line 283
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 284
    packet_disconnect("channel free: bad local channel %d", id);
  }
#line 285
  tmp___0 = channel_open_message();
#line 285
  debug("channel_free: channel %d: status: %s", id, tmp___0);
#line 286
  if ((unsigned int )c->dettach_user != (unsigned int )((void *)0)) {
#line 287
    debug("channel_free: channel %d: dettaching channel user", id);
#line 288
    (*(c->dettach_user))(c->self, (void *)0);
  }
#line 290
  if (c->sock != -1) {
#line 291
    shutdown(c->sock, 2);
  }
#line 292
  channel_close_fds(c);
#line 293
  buffer_free(& c->input);
#line 294
  buffer_free(& c->output);
#line 295
  buffer_free(& c->extended);
#line 296
  c->type = 0;
#line 297
  if (c->remote_name) {
#line 298
    xfree((void *)c->remote_name);
#line 299
    c->remote_name = (char *)((void *)0);
  }
#line 301
  return;
}
}
#line 312 "channels.c"
chan_fn *channel_pre[11]  ;
#line 313 "channels.c"
chan_fn *channel_post[11]  ;
#line 315 "channels.c"
void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 318
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 319
  return;
}
}
#line 321 "channels.c"
void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 324
  tmp = buffer_len(& c->input);
#line 324
  if (tmp < (unsigned int )max_packet_size) {
#line 325
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 326
  tmp___0 = buffer_len(& c->output);
#line 326
  if (tmp___0 > 0U) {
#line 327
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 328
  return;
}
}
#line 330 "channels.c"
void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 334
  if (c->istate == 1) {
#line 335
    tmp = buffer_len(& c->input);
#line 335
    if (tmp < (unsigned int )max_packet_size) {
#line 336
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 337
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 337
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 339
      tmp___0 = buffer_len(& c->output);
#line 339
      if (tmp___0 > 0U) {
#line 340
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 341
        if (c->ostate == 32) {
#line 342
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 345
  return;
}
}
#line 347 "channels.c"
void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 350
  if (c->istate == 1) {
#line 350
    if (c->remote_window > 0) {
#line 350
      tmp = buffer_len(& c->input);
#line 350
      if (tmp < (unsigned int )c->remote_window) {
#line 353
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 354
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 354
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 356
      tmp___0 = buffer_len(& c->output);
#line 356
      if (tmp___0 > 0U) {
#line 357
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 358
        if (c->ostate == 32) {
#line 359
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 363
  if (c->efd != -1) {
#line 364
    if (c->extended_usage == 2) {
#line 364
      tmp___2 = buffer_len(& c->extended);
#line 364
      if (tmp___2 > 0U) {
#line 366
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 367
      if (c->extended_usage == 1) {
#line 367
        tmp___1 = buffer_len(& c->extended);
#line 367
        if (tmp___1 < (unsigned int )c->remote_window) {
#line 369
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 371
  return;
}
}
#line 373 "channels.c"
void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 376
  tmp = buffer_len(& c->input);
#line 376
  if (tmp == 0U) {
#line 377
    packet_start(24);
#line 378
    packet_put_int((unsigned int )c->remote_id);
#line 379
    packet_send();
#line 380
    c->type = 5;
#line 381
    debug("Closing channel %d after input drain.", c->self);
  }
#line 383
  return;
}
}
#line 385 "channels.c"
void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 388
  tmp = buffer_len(& c->output);
#line 388
  if (tmp == 0U) {
#line 389
    channel_free(c->self);
  } else {
#line 391
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 392
  return;
}
}
#line 402 "channels.c"
int x11_open_helper(Channel *c ) 
{ unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 409
  tmp = buffer_len(& c->output);
#line 409
  if (tmp < 12U) {
#line 410
    return (0);
  }
#line 413
  tmp___0 = buffer_ptr(& c->output);
#line 413
  ucp = (unsigned char *)tmp___0;
#line 414
  if ((int )*(ucp + 0) == 66) {
#line 415
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 416
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 417
    if ((int )*(ucp + 0) == 108) {
#line 418
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 419
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 421
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 423
      return (-1);
    }
  }
#line 427
  tmp___1 = buffer_len(& c->output);
#line 427
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 429
    return (0);
  }
#line 432
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 432
  if (proto_len != tmp___2) {
#line 434
    debug("X11 connection uses different authentication protocol.");
#line 435
    return (-1);
  } else {
#line 432
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 432
    if (tmp___3 != 0) {
#line 434
      debug("X11 connection uses different authentication protocol.");
#line 435
      return (-1);
    }
  }
#line 438
  if (data_len != x11_fake_data_len) {
#line 441
    debug("X11 auth data does not match fake data.");
#line 442
    return (-1);
  } else {
#line 438
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 438
    if (tmp___4 != 0) {
#line 441
      debug("X11 auth data does not match fake data.");
#line 442
      return (-1);
    }
  }
#line 445
  if (x11_fake_data_len != x11_saved_data_len) {
#line 446
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 448
    return (-1);
  }
#line 455
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 457
  return (1);
}
}
#line 460 "channels.c"
void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 463
  tmp = x11_open_helper(c);
#line 463
  ret = tmp;
#line 464
  if (ret == 1) {
#line 466
    c->type = 4;
#line 467
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 468
    if (ret == -1) {
#line 473
      log("X11 connection rejected because of wrong authentication.\r\n");
#line 474
      buffer_clear(& c->input);
#line 475
      buffer_clear(& c->output);
#line 476
      close(c->sock);
#line 477
      c->sock = -1;
#line 478
      c->type = 5;
#line 479
      packet_start(24);
#line 480
      packet_put_int((unsigned int )c->remote_id);
#line 481
      packet_send();
    }
  }
#line 483
  return;
}
}
#line 485 "channels.c"
void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 488
  tmp = x11_open_helper(c);
#line 488
  ret = tmp;
#line 489
  if (ret == 1) {
#line 490
    c->type = 4;
#line 491
    if (compat20) {
#line 492
      channel_pre_open_20(c, readset, writeset);
    } else {
#line 494
      channel_pre_open_15(c, readset, writeset);
    }
  } else {
#line 495
    if (ret == -1) {
#line 496
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 497
      (*chan_read_failed)(c);
#line 498
      (*chan_write_failed)(c);
#line 499
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 501
  return;
}
}
#line 504 "channels.c"
void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  register char __result ;

  {
#line 513
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 513
  if (__result) {
#line 514
    debug("X11 connection requested.");
#line 515
    addrlen = sizeof(addr);
#line 516
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 517
    if (newsock < 0) {
#line 518
      tmp = __errno_location();
#line 518
      tmp___0 = strerror(*tmp);
#line 518
      error("accept: %.100s", tmp___0);
#line 519
      return;
    }
#line 521
    remote_hostname = get_remote_hostname(newsock);
#line 522
    remote_port = get_peer_port(newsock);
#line 523
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_hostname, remote_port);
#line 526
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 526
    newch = channel_new((char *)"x11", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 530
    if (compat20) {
#line 531
      packet_start(90);
#line 532
      packet_put_cstring("x11");
#line 533
      packet_put_int((unsigned int )newch);
#line 534
      packet_put_int((unsigned int )c->local_window_max);
#line 535
      packet_put_int((unsigned int )c->local_maxpacket);
#line 537
      packet_put_cstring((char const   *)remote_hostname);
#line 538
      if (datafellows & 8) {
#line 539
        debug("ssh2 x11 bug compat mode");
      } else {
#line 541
        packet_put_int((unsigned int )remote_port);
      }
#line 543
      packet_send();
    } else {
#line 545
      packet_start(27);
#line 546
      packet_put_int((unsigned int )newch);
#line 547
      if (have_hostname_in_open) {
#line 548
        tmp___2 = strlen((char const   *)(buf___1));
#line 548
        packet_put_string((char const   *)(buf___1), tmp___2);
      }
#line 549
      packet_send();
    }
#line 551
    xfree((void *)remote_hostname);
  }
#line 553
  return;
}
}
#line 558 "channels.c"
void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[1024] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  register char __result ;

  {
#line 567
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 567
  if (__result) {
#line 568
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 571
    addrlen = sizeof(addr);
#line 572
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 573
    if (newsock < 0) {
#line 574
      tmp = __errno_location();
#line 574
      tmp___0 = strerror(*tmp);
#line 574
      error("accept: %.100s", tmp___0);
#line 575
      return;
    }
#line 577
    remote_hostname = get_remote_hostname(newsock);
#line 578
    remote_port = get_peer_port(newsock);
#line 579
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"listen port %d for %.100s port %d, connect from %.200s port %d",
             c->listening_port, c->path, c->host_port, remote_hostname, remote_port);
#line 584
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 584
    newch = channel_new((char *)"direct-tcpip", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 588
    if (compat20) {
#line 589
      packet_start(90);
#line 590
      packet_put_cstring("direct-tcpip");
#line 591
      packet_put_int((unsigned int )newch);
#line 592
      packet_put_int((unsigned int )c->local_window_max);
#line 593
      packet_put_int((unsigned int )c->local_maxpacket);
#line 595
      tmp___2 = strlen((char const   *)(c->path));
#line 595
      packet_put_string((char const   *)(c->path), tmp___2);
#line 596
      packet_put_int((unsigned int )c->host_port);
#line 598
      packet_put_cstring((char const   *)remote_hostname);
#line 599
      packet_put_int((unsigned int )remote_port);
#line 600
      packet_send();
    } else {
#line 602
      packet_start(29);
#line 603
      packet_put_int((unsigned int )newch);
#line 604
      tmp___3 = strlen((char const   *)(c->path));
#line 604
      packet_put_string((char const   *)(c->path), tmp___3);
#line 605
      packet_put_int((unsigned int )c->host_port);
#line 606
      if (have_hostname_in_open) {
#line 607
        tmp___4 = strlen((char const   *)(buf___1));
#line 607
        packet_put_string((char const   *)(buf___1), tmp___4);
      }
#line 609
      packet_send();
    }
#line 611
    xfree((void *)remote_hostname);
  }
#line 613
  return;
}
}
#line 619 "channels.c"
void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 626
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 626
  if (__result) {
#line 627
    addrlen = sizeof(addr);
#line 628
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 629
    if (newsock < 0) {
#line 630
      tmp = __errno_location();
#line 630
      tmp___0 = strerror(*tmp);
#line 630
      error("accept from auth socket: %.100s", tmp___0);
#line 631
      return;
    }
#line 633
    tmp___1 = xstrdup("accepted auth socket");
#line 633
    newch = channel_allocate(3, newsock, tmp___1);
#line 635
    packet_start(31);
#line 636
    packet_put_int((unsigned int )newch);
#line 637
    packet_send();
  }
#line 639
  return;
}
}
#line 641 "channels.c"
int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;

  {
#line 648
  if (c->rfd != -1) {
#line 648
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 648
    if (__result) {
#line 649
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 650
      if (len < 0) {
#line 650
        tmp = __errno_location();
#line 650
        if (*tmp == 4) {
#line 651
          return (1);
        } else {
#line 650
          tmp___0 = __errno_location();
#line 650
          if (*tmp___0 == 11) {
#line 651
            return (1);
          }
        }
      }
#line 652
      if (len <= 0) {
#line 653
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 655
        if (compat13) {
#line 656
          tmp___1 = buffer_len(& c->output);
#line 656
          buffer_consume(& c->output, tmp___1);
#line 657
          c->type = 8;
#line 658
          debug("Channel %d status set to input draining.", c->self);
        } else {
#line 660
          (*chan_read_failed)(c);
        }
#line 662
        return (-1);
      }
#line 664
      buffer_append(& c->input, (char const   *)(buf___1), (unsigned int )len);
    }
  }
#line 666
  return (1);
}
}
#line 668 "channels.c"
int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  register char __result ;
  unsigned int tmp___4 ;

  {
#line 675
  if (c->wfd != -1) {
#line 675
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 675
    if (__result) {
#line 675
      tmp___4 = buffer_len(& c->output);
#line 675
      if (tmp___4 > 0U) {
#line 677
        tmp = buffer_len(& c->output);
#line 677
        tmp___0 = buffer_ptr(& c->output);
#line 677
        len = write(c->wfd, (void const   *)tmp___0, tmp);
#line 679
        if (len < 0) {
#line 679
          tmp___1 = __errno_location();
#line 679
          if (*tmp___1 == 4) {
#line 680
            return (1);
          } else {
#line 679
            tmp___2 = __errno_location();
#line 679
            if (*tmp___2 == 11) {
#line 680
              return (1);
            }
          }
        }
#line 681
        if (len <= 0) {
#line 682
          if (compat13) {
#line 683
            tmp___3 = buffer_len(& c->output);
#line 683
            buffer_consume(& c->output, tmp___3);
#line 684
            debug("Channel %d status set to input draining.", c->self);
#line 685
            c->type = 8;
          } else {
#line 687
            (*chan_write_failed)(c);
          }
#line 689
          return (-1);
        }
#line 691
        buffer_consume(& c->output, (unsigned int )len);
#line 692
        if (compat20) {
#line 692
          if (len > 0) {
#line 693
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 696
  return (1);
}
}
#line 698 "channels.c"
int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;
  unsigned int tmp___1 ;

  {
#line 705
  if (c->efd != -1) {
#line 707
    if (c->extended_usage == 2) {
#line 707
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 707
      if (__result___0) {
#line 707
        tmp___1 = buffer_len(& c->extended);
#line 707
        if (tmp___1 > 0U) {
#line 709
          tmp = buffer_len(& c->extended);
#line 709
          tmp___0 = buffer_ptr(& c->extended);
#line 709
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 711
          debug("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 713
          if (len > 0) {
#line 714
            buffer_consume(& c->extended, (unsigned int )len);
#line 715
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 718
      if (c->extended_usage == 1) {
#line 718
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 718
        if (__result) {
#line 719
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 720
          debug("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 722
          if (len == 0) {
#line 723
            debug("channel %d: closing efd %d", c->self, c->efd);
#line 725
            close(c->efd);
#line 726
            c->efd = -1;
          } else {
#line 727
            if (len > 0) {
#line 728
              buffer_append(& c->extended, (char const   *)(buf___1), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 731
  return (1);
}
}
#line 733 "channels.c"
int channel_check_window(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 736
  if (! (c->flags & 3)) {
#line 736
    if (c->local_window < c->local_window_max / 2) {
#line 736
      if (c->local_consumed > 0) {
#line 739
        packet_start(93);
#line 740
        packet_put_int((unsigned int )c->remote_id);
#line 741
        packet_put_int((unsigned int )c->local_consumed);
#line 742
        packet_send();
#line 743
        debug("channel %d: window %d sent adjust %d", c->self, c->local_window, c->local_consumed);
#line 746
        c->local_window += c->local_consumed;
#line 747
        c->local_consumed = 0;
      }
    }
  }
#line 749
  return (1);
}
}
#line 752 "channels.c"
void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 755
  channel_handle_rfd(c, readset, writeset);
#line 756
  channel_handle_wfd(c, readset, writeset);
#line 757
  return;
}
}
#line 759 "channels.c"
void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 762
  channel_handle_rfd(c, readset, writeset);
#line 763
  channel_handle_wfd(c, readset, writeset);
#line 764
  channel_handle_efd(c, readset, writeset);
#line 765
  channel_check_window(c, readset, writeset);
#line 766
  return;
}
}
#line 768 "channels.c"
void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;
  unsigned int tmp___2 ;

  {
#line 773
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 773
  if (__result) {
#line 773
    tmp___2 = buffer_len(& c->output);
#line 773
    if (tmp___2 > 0U) {
#line 774
      tmp = buffer_len(& c->output);
#line 774
      tmp___0 = buffer_ptr(& c->output);
#line 774
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 776
      if (len <= 0) {
#line 777
        tmp___1 = buffer_len(& c->output);
#line 777
        buffer_consume(& c->output, tmp___1);
      } else {
#line 779
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 781
  return;
}
}
#line 783 "channels.c"
void channel_handler_init_20(void) 
{ 

  {
#line 786
  channel_pre[4] = & channel_pre_open_20;
#line 787
  channel_pre[7] = & channel_pre_x11_open;
#line 788
  channel_pre[2] = & channel_pre_listener;
#line 789
  channel_pre[1] = & channel_pre_listener;
#line 791
  channel_post[4] = & channel_post_open_2;
#line 792
  channel_post[2] = & channel_post_port_listener;
#line 793
  channel_post[1] = & channel_post_x11_listener;
#line 794
  return;
}
}
#line 796 "channels.c"
void channel_handler_init_13(void) 
{ 

  {
#line 799
  channel_pre[4] = & channel_pre_open_13;
#line 800
  channel_pre[7] = & channel_pre_x11_open_13;
#line 801
  channel_pre[1] = & channel_pre_listener;
#line 802
  channel_pre[2] = & channel_pre_listener;
#line 803
  channel_pre[6] = & channel_pre_listener;
#line 804
  channel_pre[8] = & channel_pre_input_draining;
#line 805
  channel_pre[9] = & channel_pre_output_draining;
#line 807
  channel_post[4] = & channel_post_open_1;
#line 808
  channel_post[1] = & channel_post_x11_listener;
#line 809
  channel_post[2] = & channel_post_port_listener;
#line 810
  channel_post[6] = & channel_post_auth_listener;
#line 811
  channel_post[9] = & channel_post_output_drain_13;
#line 812
  return;
}
}
#line 814 "channels.c"
void channel_handler_init_15(void) 
{ 

  {
#line 817
  channel_pre[4] = & channel_pre_open_15;
#line 818
  channel_pre[7] = & channel_pre_x11_open;
#line 819
  channel_pre[1] = & channel_pre_listener;
#line 820
  channel_pre[2] = & channel_pre_listener;
#line 821
  channel_pre[6] = & channel_pre_listener;
#line 823
  channel_post[1] = & channel_post_x11_listener;
#line 824
  channel_post[2] = & channel_post_port_listener;
#line 825
  channel_post[6] = & channel_post_auth_listener;
#line 826
  channel_post[4] = & channel_post_open_1;
#line 827
  return;
}
}
#line 829 "channels.c"
void channel_handler_init(void) 
{ int i ;

  {
#line 833
  i = 0;
#line 833
  while (i < 11) {
#line 834
    channel_pre[i] = (chan_fn *)((void *)0);
#line 835
    channel_post[i] = (chan_fn *)((void *)0);
#line 833
    i ++;
  }
#line 837
  if (compat20) {
#line 838
    channel_handler_init_20();
  } else {
#line 839
    if (compat13) {
#line 840
      channel_handler_init_13();
    } else {
#line 842
      channel_handler_init_15();
    }
  }
#line 843
  return;
}
}
#line 848
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 848 "channels.c"
static int did_init  =    0;
#line 845 "channels.c"
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 852
  if (! did_init) {
#line 853
    channel_handler_init();
#line 854
    did_init = 1;
  }
#line 856
  i = 0;
#line 856
  while (i < channels_alloc) {
#line 857
    c = channels + i;
#line 858
    if (c->type == 0) {
      goto __Cont;
    }
#line 860
    if ((unsigned int )*(ftab + c->type) == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 862
    (*(*(ftab + c->type)))(c, readset, writeset);
#line 863
    (*chan_delete_if_full_closed)(c);
    __Cont: /* CIL Label */ 
#line 856
    i ++;
  }
#line 865
  return;
}
}
#line 867 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 870
  channel_handler(channel_pre, readset, writeset);
#line 871
  return;
}
}
#line 873 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 876
  channel_handler(channel_post, readset, writeset);
#line 877
  return;
}
}
#line 881 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 887
  i = 0;
#line 887
  while (i < channels_alloc) {
#line 888
    c = channels + i;
#line 891
    if (compat13) {
#line 892
      if (c->type != 4) {
#line 892
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 896
      if (c->type != 4) {
        goto __Cont;
      }
#line 898
      if (c->istate != 1) {
#line 898
        if (c->istate != 2) {
          goto __Cont;
        }
      }
    }
#line 902
    if (compat20) {
#line 902
      if (c->flags & 3) {
#line 904
        debug("channel: %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 909
    tmp = buffer_len(& c->input);
#line 909
    len = (int )tmp;
#line 910
    if (len > 0) {
#line 912
      if (compat20) {
#line 913
        if (len > c->remote_window) {
#line 914
          len = c->remote_window;
        }
#line 915
        if (len > c->remote_maxpacket) {
#line 916
          len = c->remote_maxpacket;
        }
      } else {
#line 918
        tmp___0 = packet_is_interactive();
#line 918
        if (tmp___0) {
#line 919
          if (len > 1024) {
#line 920
            len = 512;
          }
        } else {
#line 923
          if (len > max_packet_size / 2) {
#line 924
            len = max_packet_size / 2;
          }
        }
      }
#line 927
      if (len > 0) {
#line 928
        if (compat20) {
#line 928
          tmp___1 = 94;
        } else {
#line 928
          tmp___1 = 23;
        }
#line 928
        packet_start(tmp___1);
#line 930
        packet_put_int((unsigned int )c->remote_id);
#line 931
        tmp___2 = buffer_ptr(& c->input);
#line 931
        packet_put_string((char const   *)tmp___2, (unsigned int )len);
#line 932
        packet_send();
#line 933
        buffer_consume(& c->input, (unsigned int )len);
#line 934
        c->remote_window -= len;
      }
    } else {
#line 936
      if (c->istate == 2) {
#line 937
        if (compat13) {
#line 938
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 943
        (*chan_ibuf_empty)(c);
      }
    }
#line 946
    if (compat20) {
#line 946
      if (c->remote_window > 0) {
#line 946
        tmp___4 = buffer_len(& c->extended);
#line 946
        len = (int )tmp___4;
#line 946
        if (len > 0) {
#line 946
          if (c->extended_usage == 1) {
#line 950
            if (len > c->remote_window) {
#line 951
              len = c->remote_window;
            }
#line 952
            if (len > c->remote_maxpacket) {
#line 953
              len = c->remote_maxpacket;
            }
#line 954
            packet_start(95);
#line 955
            packet_put_int((unsigned int )c->remote_id);
#line 956
            packet_put_int(1U);
#line 957
            tmp___3 = buffer_ptr(& c->extended);
#line 957
            packet_put_string((char const   *)tmp___3, (unsigned int )len);
#line 958
            packet_send();
#line 959
            buffer_consume(& c->extended, (unsigned int )len);
#line 960
            c->remote_window -= len;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 887
    i ++;
  }
#line 963
  return;
}
}
#line 971 "channels.c"
void channel_input_data(int type , int plen ) 
{ int id ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 980
  tmp = packet_get_int();
#line 980
  id = (int )tmp;
#line 981
  c = channel_lookup(id);
#line 982
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 983
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 986
  if (c->type != 4) {
#line 986
    if (c->type != 7) {
#line 988
      return;
    }
  }
#line 991
  if (! compat13) {
#line 991
    if (c->ostate != 16) {
#line 992
      return;
    }
  }
#line 995
  data = packet_get_string(& data_len);
#line 996
  while (1) {
#line 996
    tmp___0 = packet_remaining();
#line 996
    _len = tmp___0;
#line 996
    if (_len > 0) {
#line 996
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          996);
#line 996
      packet_disconnect("Packet integrity error.");
    }
#line 996
    break;
  }
#line 998
  if (compat20) {
#line 999
    if (data_len > (unsigned int )c->local_maxpacket) {
#line 1000
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1003
    if (data_len > (unsigned int )c->local_window) {
#line 1004
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1006
      xfree((void *)data);
#line 1007
      return;
    }
#line 1009
    c->local_window = (int )((unsigned int )c->local_window - data_len);
  } else {
#line 1011
    while (1) {
#line 1011
      _p = plen;
#line 1011
      _e = (int )(8U + data_len);
#line 1011
      if (_p != _e) {
#line 1011
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1011);
#line 1011
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1011
      break;
    }
  }
#line 1013
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1014
  xfree((void *)data);
#line 1015
  return;
}
}
#line 1016 "channels.c"
void channel_input_extended_data(int type , int plen ) 
{ int id ;
  int tcode ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1026
  tmp = packet_get_int();
#line 1026
  id = (int )tmp;
#line 1027
  c = channel_lookup(id);
#line 1029
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1030
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1031
  if (c->type != 4) {
#line 1032
    log("channel %d: ext data for non open", id);
#line 1033
    return;
  }
#line 1035
  tmp___0 = packet_get_int();
#line 1035
  tcode = (int )tmp___0;
#line 1036
  if (c->efd == -1) {
#line 1039
    log("channel %d: bad ext data", c->self);
#line 1040
    return;
  } else {
#line 1036
    if (c->extended_usage != 2) {
#line 1039
      log("channel %d: bad ext data", c->self);
#line 1040
      return;
    } else {
#line 1036
      if (tcode != 1) {
#line 1039
        log("channel %d: bad ext data", c->self);
#line 1040
        return;
      }
    }
  }
#line 1042
  data = packet_get_string(& data_len);
#line 1043
  while (1) {
#line 1043
    tmp___1 = packet_remaining();
#line 1043
    _len = tmp___1;
#line 1043
    if (_len > 0) {
#line 1043
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1043);
#line 1043
      packet_disconnect("Packet integrity error.");
    }
#line 1043
    break;
  }
#line 1044
  if (data_len > (unsigned int )c->local_window) {
#line 1045
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1047
    xfree((void *)data);
#line 1048
    return;
  }
#line 1050
  debug("channel %d: rcvd ext data %d", c->self, data_len);
#line 1051
  c->local_window = (int )((unsigned int )c->local_window - data_len);
#line 1052
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1053
  xfree((void *)data);
#line 1054
  return;
}
}
#line 1062 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1068
  i = 0U;
#line 1068
  while (i < (unsigned int )channels_alloc) {
#line 1069
    c = channels + i;
#line 1070
    if (c->type == 4) {
#line 1071
      if (! compat20) {
#line 1071
        tmp___0 = buffer_len(& c->input);
#line 1071
        if (tmp___0 > (unsigned int )max_packet_size) {
#line 1072
          tmp = buffer_len(& c->input);
#line 1072
          debug("channel %d: big input buffer %d", c->self, tmp);
#line 1074
          return (0);
        }
      }
#line 1076
      tmp___2 = buffer_len(& c->output);
#line 1076
      if (tmp___2 > (unsigned int )max_packet_size) {
#line 1077
        tmp___1 = buffer_len(& c->output);
#line 1077
        debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 1079
        return (0);
      }
    }
#line 1068
    i ++;
  }
#line 1083
  return (1);
}
}
#line 1086 "channels.c"
void channel_input_ieof(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 1092
  while (1) {
#line 1092
    _p = plen;
#line 1092
    _e = 4;
#line 1092
    if (_p != _e) {
#line 1092
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1092);
#line 1092
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1092
    break;
  }
#line 1094
  tmp = packet_get_int();
#line 1094
  id = (int )tmp;
#line 1095
  c = channel_lookup(id);
#line 1096
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1097
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1098
  (*chan_rcvd_ieof)(c);
#line 1099
  return;
}
}
#line 1101 "channels.c"
void channel_input_close(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1107
  while (1) {
#line 1107
    _p = plen;
#line 1107
    _e = 4;
#line 1107
    if (_p != _e) {
#line 1107
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1107);
#line 1107
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1107
    break;
  }
#line 1109
  tmp = packet_get_int();
#line 1109
  id = (int )tmp;
#line 1110
  c = channel_lookup(id);
#line 1111
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1112
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1118
  packet_start(25);
#line 1119
  packet_put_int((unsigned int )c->remote_id);
#line 1120
  packet_send();
#line 1129
  if (c->type != 5) {
#line 1134
    tmp___0 = buffer_len(& c->input);
#line 1134
    buffer_consume(& c->input, tmp___0);
#line 1135
    c->type = 9;
  }
#line 1137
  return;
}
}
#line 1140 "channels.c"
void channel_input_oclose(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1143
  tmp = packet_get_int();
#line 1143
  id = (int )tmp;
#line 1144
  tmp___0 = channel_lookup(id);
#line 1144
  c = tmp___0;
#line 1145
  while (1) {
#line 1145
    _p = plen;
#line 1145
    _e = 4;
#line 1145
    if (_p != _e) {
#line 1145
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1145);
#line 1145
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1145
    break;
  }
#line 1146
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1147
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1148
  (*chan_rcvd_oclose)(c);
#line 1149
  return;
}
}
#line 1151 "channels.c"
void channel_input_close_confirmation(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1154
  tmp = packet_get_int();
#line 1154
  id = (int )tmp;
#line 1155
  tmp___0 = channel_lookup(id);
#line 1155
  c = tmp___0;
#line 1157
  while (1) {
#line 1157
    tmp___1 = packet_remaining();
#line 1157
    _len = tmp___1;
#line 1157
    if (_len > 0) {
#line 1157
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1157);
#line 1157
      packet_disconnect("Packet integrity error.");
    }
#line 1157
    break;
  }
#line 1158
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1159
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1161
  if (c->type != 5) {
#line 1162
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1164
  channel_free(c->self);
#line 1165
  return;
}
}
#line 1167 "channels.c"
void channel_input_open_confirmation(int type , int plen ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1173
  if (! compat20) {
#line 1174
    while (1) {
#line 1174
      _p = plen;
#line 1174
      _e = 8;
#line 1174
      if (_p != _e) {
#line 1174
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1174);
#line 1174
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1174
      break;
    }
  }
#line 1176
  tmp = packet_get_int();
#line 1176
  id = (int )tmp;
#line 1177
  c = channel_lookup(id);
#line 1179
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1180
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1179
    if (c->type != 3) {
#line 1180
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1182
  tmp___0 = packet_get_int();
#line 1182
  remote_id = (int )tmp___0;
#line 1184
  c->remote_id = remote_id;
#line 1185
  c->type = 4;
#line 1187
  if (compat20) {
#line 1188
    tmp___1 = packet_get_int();
#line 1188
    c->remote_window = (int )tmp___1;
#line 1189
    tmp___2 = packet_get_int();
#line 1189
    c->remote_maxpacket = (int )tmp___2;
#line 1190
    while (1) {
#line 1190
      tmp___3 = packet_remaining();
#line 1190
      _len = tmp___3;
#line 1190
      if (_len > 0) {
#line 1190
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1190);
#line 1190
        packet_disconnect("Packet integrity error.");
      }
#line 1190
      break;
    }
#line 1191
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1191
      if (c->cb_event == type) {
#line 1192
        debug("callback start");
#line 1193
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1194
        debug("callback done");
      }
    }
#line 1196
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1199
  return;
}
}
#line 1201 "channels.c"
void channel_input_open_failure(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int reason ;
  unsigned int tmp___0 ;
  char *msg ;
  char *tmp___1 ;
  char *lang ;
  char *tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1207
  if (! compat20) {
#line 1208
    while (1) {
#line 1208
      _p = plen;
#line 1208
      _e = 4;
#line 1208
      if (_p != _e) {
#line 1208
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1208);
#line 1208
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1208
      break;
    }
  }
#line 1210
  tmp = packet_get_int();
#line 1210
  id = (int )tmp;
#line 1211
  c = channel_lookup(id);
#line 1213
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1214
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1213
    if (c->type != 3) {
#line 1214
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1216
  if (compat20) {
#line 1217
    tmp___0 = packet_get_int();
#line 1217
    reason = (int )tmp___0;
#line 1218
    tmp___1 = packet_get_string((unsigned int *)((void *)0));
#line 1218
    msg = tmp___1;
#line 1219
    tmp___2 = packet_get_string((unsigned int *)((void *)0));
#line 1219
    lang = tmp___2;
#line 1220
    log("channel_open_failure: %d: reason %d: %s", id, reason, msg);
#line 1221
    while (1) {
#line 1221
      tmp___3 = packet_remaining();
#line 1221
      _len = tmp___3;
#line 1221
      if (_len > 0) {
#line 1221
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1221);
#line 1221
        packet_disconnect("Packet integrity error.");
      }
#line 1221
      break;
    }
#line 1222
    xfree((void *)msg);
#line 1223
    xfree((void *)lang);
  }
#line 1226
  channel_free(id);
#line 1227
  return;
}
}
#line 1229 "channels.c"
void channel_input_channel_request(int type , int plen ) 
{ int id ;
  Channel *c ;
  unsigned int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1235
  tmp = packet_get_int();
#line 1235
  id = (int )tmp;
#line 1236
  c = channel_lookup(id);
#line 1238
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1240
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1238
    if (c->type != 4) {
#line 1238
      if (c->type != 10) {
#line 1240
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1242
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1242
    if (c->cb_event == type) {
#line 1243
      debug("callback start");
#line 1244
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1245
      debug("callback done");
    } else {
#line 1247
      tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1247
      service = tmp___0;
#line 1248
      debug("channel: %d rcvd request for %s", c->self, service);
#line 1249
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1250
      xfree((void *)service);
    }
  } else {
#line 1247
    tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1247
    service = tmp___0;
#line 1248
    debug("channel: %d rcvd request for %s", c->self, service);
#line 1249
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1250
    xfree((void *)service);
  }
#line 1252
  return;
}
}
#line 1254 "channels.c"
void channel_input_window_adjust(int type , int plen ) 
{ Channel *c ;
  int id ;
  int adjust ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1260
  if (! compat20) {
#line 1261
    return;
  }
#line 1264
  tmp = packet_get_int();
#line 1264
  id = (int )tmp;
#line 1265
  c = channel_lookup(id);
#line 1267
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1268
    log("Received window adjust for non-open channel %d.", id);
#line 1270
    return;
  } else {
#line 1267
    if (c->type != 4) {
#line 1268
      log("Received window adjust for non-open channel %d.", id);
#line 1270
      return;
    }
  }
#line 1272
  tmp___0 = packet_get_int();
#line 1272
  adjust = (int )tmp___0;
#line 1273
  while (1) {
#line 1273
    tmp___1 = packet_remaining();
#line 1273
    _len = tmp___1;
#line 1273
    if (_len > 0) {
#line 1273
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1273);
#line 1273
      packet_disconnect("Packet integrity error.");
    }
#line 1273
    break;
  }
#line 1274
  debug("channel %d: rcvd adjust %d", id, adjust);
#line 1275
  c->remote_window += adjust;
#line 1276
  return;
}
}
#line 1283 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 1287
  i = 0;
#line 1287
  while (i < channels_alloc) {
#line 1288
    switch ((channels + i)->type) {
    case 6: 
#line 1290
    close((channels + i)->sock);
#line 1291
    remove((char const   *)((channels + i)->path));
#line 1292
    channel_free(i);
#line 1293
    break;
    case 2: 
    case 1: 
#line 1296
    close((channels + i)->sock);
#line 1297
    channel_free(i);
#line 1298
    break;
    default: ;
#line 1300
    break;
    }
#line 1287
    i ++;
  }
#line 1303
  return;
}
}
#line 1310 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 1314
  i = 0;
#line 1314
  while (i < channels_alloc) {
#line 1315
    if ((channels + i)->type != 0) {
#line 1316
      channel_close_fds(channels + i);
    }
#line 1314
    i ++;
  }
#line 1317
  return;
}
}
#line 1321 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 1324
  return (channel_max_fd_value);
}
}
#line 1329 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 1333
  i = 0U;
#line 1333
  while (i < (unsigned int )channels_alloc) {
#line 1334
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
#line 1342
    if (! compat20) {
#line 1343
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 1348
    return (1);
    case 8: 
    case 9: 
#line 1351
    if (! compat13) {
#line 1352
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1353
    return (1);
    default: 
#line 1355
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1333
    i ++;
  }
#line 1358
  return (0);
}
}
#line 1367 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___1[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1374
  buffer_init(& buffer);
#line 1375
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 1376
  tmp = strlen((char const   *)(buf___1));
#line 1376
  buffer_append(& buffer, (char const   *)(buf___1), tmp);
#line 1377
  i = 0;
#line 1377
  while (i < channels_alloc) {
#line 1378
    c = channels + i;
#line 1379
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
    case 3: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 1392
    tmp___0 = buffer_len(& c->output);
#line 1392
    tmp___1 = buffer_len(& c->input);
#line 1392
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 1398
    tmp___2 = strlen((char const   *)(buf___1));
#line 1398
    buffer_append(& buffer, (char const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 1401
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 1377
    i ++;
  }
#line 1405
  buffer_append(& buffer, "\000", 1U);
#line 1406
  tmp___3 = buffer_ptr(& buffer);
#line 1406
  cp = xstrdup((char const   *)tmp___3);
#line 1407
  buffer_free(& buffer);
#line 1408
  return (cp);
}
}
#line 1416 "channels.c"
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1420
  on = 1;
#line 1425
  tmp = strlen(host);
#line 1425
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 1426
    packet_disconnect("Forward host name too long.");
  }
#line 1432
  memset((void *)(& hints), 0, sizeof(hints));
#line 1433
  hints.ai_family = IPv4or6;
#line 1434
  if (gateway_ports) {
#line 1434
    hints.ai_flags = 1;
  } else {
#line 1434
    hints.ai_flags = 0;
  }
#line 1435
  hints.ai_socktype = 1;
#line 1436
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 1437
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1437
  if (tmp___0 != 0) {
#line 1438
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 1440
  success = 0;
#line 1441
  ai = aitop;
#line 1441
  while (ai) {
#line 1442
    if (ai->ai_family != 2) {
#line 1442
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1444
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1444
    if (tmp___1 != 0) {
#line 1446
      error("channel_request_local_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 1450
    sock = socket(ai->ai_family, 1, 0);
#line 1451
    if (sock < 0) {
#line 1453
      tmp___2 = __errno_location();
#line 1453
      tmp___3 = strerror(*tmp___2);
#line 1453
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 1460
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 1461
    linger.l_onoff = 1;
#line 1462
    linger.l_linger = 5;
#line 1463
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1464
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 1467
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1467
    if (tmp___8 < 0) {
#line 1469
      if (! ai->ai_next) {
#line 1470
        tmp___4 = __errno_location();
#line 1470
        tmp___5 = strerror(*tmp___4);
#line 1470
        error("bind: %.100s", tmp___5);
      } else {
#line 1472
        tmp___6 = __errno_location();
#line 1472
        tmp___7 = strerror(*tmp___6);
#line 1472
        verbose("bind: %.100s", tmp___7);
      }
#line 1474
      close(sock);
      goto __Cont;
    }
#line 1478
    tmp___11 = listen(sock, 5);
#line 1478
    if (tmp___11 < 0) {
#line 1479
      tmp___9 = __errno_location();
#line 1479
      tmp___10 = strerror(*tmp___9);
#line 1479
      error("listen: %.100s", tmp___10);
#line 1480
      close(sock);
      goto __Cont;
    }
#line 1484
    tmp___12 = xstrdup("port listener");
#line 1484
    ch = channel_new((char *)"port listener", 2, sock, sock, -1, 8192, 4096, 0, tmp___12);
#line 1489
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 1490
    (channels + ch)->host_port = (int )host_port;
#line 1491
    (channels + ch)->listening_port = (int )port;
#line 1492
    success = 1;
    __Cont: /* CIL Label */ 
#line 1441
    ai = ai->ai_next;
  }
#line 1494
  if (success == 0) {
#line 1495
    packet_disconnect("cannot listen port: %d", port);
  }
#line 1496
  freeaddrinfo(aitop);
#line 1497
  return;
}
}
#line 1504 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  char const   *address_to_bind ;

  {
#line 1510
  if (num_permitted_opens >= 100) {
#line 1511
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1513
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 1514
  permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 1515
  permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 1516
  num_permitted_opens ++;
#line 1519
  if (compat20) {
#line 1520
    address_to_bind = "0.0.0.0";
#line 1521
    packet_start(80);
#line 1522
    packet_put_cstring("tcpip-forward");
#line 1523
    packet_put_char(0);
#line 1524
    packet_put_cstring(address_to_bind);
#line 1525
    packet_put_int((unsigned int )listen_port);
  } else {
#line 1527
    packet_start(28);
#line 1528
    packet_put_int((unsigned int )listen_port);
#line 1529
    packet_put_cstring(host_to_connect);
#line 1530
    packet_put_int((unsigned int )port_to_connect);
#line 1531
    packet_send();
#line 1532
    packet_write_wait();
#line 1537
    packet_read_expect(& payload_len, 14);
  }
#line 1539
  return;
}
}
#line 1547 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1554
  tmp = packet_get_int();
#line 1554
  port = (unsigned short )tmp;
#line 1555
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 1556
  tmp___0 = packet_get_int();
#line 1556
  host_port = (unsigned short )tmp___0;
#line 1562
  if ((int )port < 1024) {
#line 1562
    if (! is_root) {
#line 1563
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1568
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 1571
  xfree((void *)hostname);
#line 1572
  return;
}
}
#line 1575 "channels.c"
int channel_connect_to(char const   *host , u_short host_port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1581
  sock = -1;
#line 1583
  memset((void *)(& hints), 0, sizeof(hints));
#line 1584
  hints.ai_family = IPv4or6;
#line 1585
  hints.ai_socktype = 1;
#line 1586
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           host_port);
#line 1587
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1587
  if (gaierr != 0) {
#line 1588
    tmp = gai_strerror(gaierr);
#line 1588
    error("%.100s: unknown host (%s)", host, tmp);
#line 1589
    return (-1);
  }
#line 1591
  ai = aitop;
#line 1591
  while (ai) {
#line 1592
    if (ai->ai_family != 2) {
#line 1592
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1594
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1594
    if (tmp___0 != 0) {
#line 1596
      error("channel_connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 1600
    sock = socket(ai->ai_family, 1, 0);
#line 1601
    if (sock < 0) {
#line 1602
      tmp___1 = __errno_location();
#line 1602
      tmp___2 = strerror(*tmp___1);
#line 1602
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 1606
    tmp___5 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1606
    if (tmp___5 < 0) {
#line 1607
      tmp___3 = __errno_location();
#line 1607
      tmp___4 = strerror(*tmp___3);
#line 1607
      error("connect %.100s port %s: %.100s", ntop, strport, tmp___4);
#line 1609
      close(sock);
      goto __Cont;
    }
#line 1612
    break;
    __Cont: /* CIL Label */ 
#line 1591
    ai = ai->ai_next;
  }
#line 1615
  freeaddrinfo(aitop);
#line 1616
  if (! ai) {
#line 1617
    error("connect %.100s port %d: failed.", host, host_port);
#line 1618
    return (-1);
  }
#line 1621
  return (sock);
}
}
#line 1630 "channels.c"
void channel_input_port_open(int type , int plen ) 
{ u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  int denied ;
  unsigned int host_len ;
  unsigned int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1635
  sock = -1;
#line 1639
  tmp = packet_get_int();
#line 1639
  remote_channel = (int )tmp;
#line 1642
  host = packet_get_string(& host_len);
#line 1645
  tmp___0 = packet_get_int();
#line 1645
  host_port = (unsigned short )tmp___0;
#line 1648
  if (have_hostname_in_open) {
#line 1649
    originator_string = packet_get_string(& originator_len);
#line 1650
    originator_len += 4U;
  } else {
#line 1652
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1653
    originator_len = 0U;
  }
#line 1656
  while (1) {
#line 1656
    _p = plen;
#line 1656
    _e = (int )(((8U + host_len) + 4U) + originator_len);
#line 1656
    if (_p != _e) {
#line 1656
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1657);
#line 1656
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1656
    break;
  }
#line 1660
  denied = 0;
#line 1661
  if (! all_opens_permitted) {
#line 1663
    i = 0;
#line 1663
    while (i < num_permitted_opens) {
#line 1665
      if ((int )permitted_opens[i].port_to_connect == (int )host_port) {
#line 1665
        if (0) {
#line 1665
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 1665
          __s2_len = strlen((char const   *)host);
#line 1665
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 1665
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1665
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1665
                tmp___10 = 1;
              } else {
#line 1665
                if (__s2_len >= 4U) {
#line 1665
                  tmp___10 = 1;
                } else {
#line 1665
                  tmp___10 = 0;
                }
              }
            } else {
#line 1665
              tmp___10 = 0;
            }
          }
#line 1665
          if (tmp___10) {
#line 1665
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
          } else {
#line 1665
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
#line 1665
            tmp___6 = tmp___9;
          }
        } else {
#line 1665
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     (char const   *)host);
#line 1665
          tmp___6 = tmp___9;
        }
#line 1665
        if (tmp___6 == 0) {
#line 1666
          break;
        }
      }
#line 1663
      i ++;
    }
#line 1669
    if (i >= num_permitted_opens) {
#line 1671
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1673
      denied = 1;
    }
  }
#line 1676
  if (denied) {
#line 1676
    sock = -1;
  } else {
#line 1676
    sock = channel_connect_to((char const   *)host, host_port);
  }
#line 1677
  if (sock > 0) {
#line 1679
    newch = channel_allocate(4, sock, originator_string);
#line 1680
    (channels + newch)->remote_id = remote_channel;
#line 1682
    packet_start(21);
#line 1683
    packet_put_int((unsigned int )remote_channel);
#line 1684
    packet_put_int((unsigned int )newch);
#line 1685
    packet_send();
  } else {
#line 1687
    packet_start(22);
#line 1688
    packet_put_int((unsigned int )remote_channel);
#line 1689
    packet_send();
  }
#line 1691
  xfree((void *)host);
#line 1692
  return;
}
}
#line 1702 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1709
  num_socks = 0;
#line 1713
  display_number = x11_display_offset;
#line 1713
  while (display_number < 1000) {
#line 1716
    port = (unsigned short )(6000 + display_number);
#line 1717
    memset((void *)(& hints), 0, sizeof(hints));
#line 1718
    hints.ai_family = IPv4or6;
#line 1719
    hints.ai_flags = 1;
#line 1720
    hints.ai_socktype = 1;
#line 1721
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 1722
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1722
    if (gaierr != 0) {
#line 1723
      tmp = gai_strerror(gaierr);
#line 1723
      error("getaddrinfo: %.100s", tmp);
#line 1724
      return ((char *)((void *)0));
    }
#line 1726
    ai = aitop;
#line 1726
    while (ai) {
#line 1727
      if (ai->ai_family != 2) {
#line 1727
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 1729
      sock = socket(ai->ai_family, 1, 0);
#line 1730
      if (sock < 0) {
#line 1731
        tmp___2 = __errno_location();
#line 1731
        if (*tmp___2 != 22) {
#line 1732
          tmp___0 = __errno_location();
#line 1732
          tmp___1 = strerror(*tmp___0);
#line 1732
          error("socket: %.100s", tmp___1);
#line 1733
          return ((char *)((void *)0));
        } else {
#line 1735
          debug("Socket family %d not supported [X11 disp create]", ai->ai_family);
          goto __Cont;
        }
      }
#line 1739
      tmp___5 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1739
      if (tmp___5 < 0) {
#line 1740
        tmp___3 = __errno_location();
#line 1740
        tmp___4 = strerror(*tmp___3);
#line 1740
        debug("bind port %d: %.100s", port, tmp___4);
#line 1741
        shutdown(sock, 2);
#line 1742
        close(sock);
#line 1744
        if (ai->ai_next) {
          goto __Cont;
        }
#line 1747
        n___0 = 0;
#line 1747
        while (n___0 < num_socks) {
#line 1748
          shutdown(socks[n___0], 2);
#line 1749
          close(socks[n___0]);
#line 1747
          n___0 ++;
        }
#line 1751
        num_socks = 0;
#line 1752
        break;
      }
#line 1754
      tmp___6 = num_socks;
#line 1754
      num_socks ++;
#line 1754
      socks[tmp___6] = sock;
#line 1759
      break;
      __Cont: /* CIL Label */ 
#line 1726
      ai = ai->ai_next;
    }
#line 1762
    if (num_socks > 0) {
#line 1763
      break;
    }
#line 1713
    display_number ++;
  }
#line 1765
  if (display_number >= 1000) {
#line 1766
    error("Failed to allocate internet-domain X11 display socket.");
#line 1767
    return ((char *)((void *)0));
  }
#line 1770
  n___0 = 0;
#line 1770
  while (n___0 < num_socks) {
#line 1771
    sock = socks[n___0];
#line 1772
    tmp___9 = listen(sock, 5);
#line 1772
    if (tmp___9 < 0) {
#line 1773
      tmp___7 = __errno_location();
#line 1773
      tmp___8 = strerror(*tmp___7);
#line 1773
      error("listen: %.100s", tmp___8);
#line 1774
      shutdown(sock, 2);
#line 1775
      close(sock);
#line 1776
      return ((char *)((void *)0));
    }
#line 1770
    n___0 ++;
  }
#line 1782
  tmp___12 = gethostname(hostname, sizeof(hostname));
#line 1782
  if (tmp___12 < 0) {
#line 1783
    tmp___10 = __errno_location();
#line 1783
    tmp___11 = strerror(*tmp___10);
#line 1783
    fatal("gethostname: %.100s", tmp___11);
  }
#line 1820
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1825
  n___0 = 0;
#line 1825
  while (n___0 < num_socks) {
#line 1826
    sock = socks[n___0];
#line 1827
    tmp___13 = xstrdup("X11 inet listener");
#line 1827
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___13);
#line 1825
    n___0 ++;
  }
#line 1834
  tmp___14 = xstrdup((char const   *)(display));
#line 1834
  return (tmp___14);
}
}
#line 1845
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1845 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1841 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1855
  path = x_sockets;
#line 1855
  while (*path) {
#line 1856
    sock = socket(1, 1, 0);
#line 1857
    if (sock < 0) {
#line 1858
      tmp = __errno_location();
#line 1858
      tmp___0 = strerror(*tmp);
#line 1858
      error("socket: %.100s", tmp___0);
    }
#line 1859
    memset((void *)(& addr), 0, sizeof(addr));
#line 1860
    addr.sun_family = (unsigned short)1;
#line 1861
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1862
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1862
    if (tmp___1 == 0) {
#line 1863
      return (sock);
    }
#line 1864
    close(sock);
#line 1855
    path ++;
  }
#line 1866
  tmp___2 = __errno_location();
#line 1866
  tmp___3 = strerror(*tmp___2);
#line 1866
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1867
  return (-1);
}
}
#line 1870 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 1873
  sock = 0;
#line 1881
  tmp = getenv("DISPLAY");
#line 1881
  display = (char const   *)tmp;
#line 1882
  if (! display) {
#line 1883
    error("DISPLAY not set.");
#line 1884
    return (-1);
  }
#line 1895
  if (0) {
#line 1895
    if (0) {
#line 1895
      __s1_len___0 = strlen(display);
#line 1895
      __s2_len___0 = strlen("unix:");
#line 1895
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1895
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1895
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1895
            tmp___25 = 1;
          } else {
#line 1895
            if (__s2_len___0 >= 4U) {
#line 1895
              tmp___25 = 1;
            } else {
#line 1895
              tmp___25 = 0;
            }
          }
        } else {
#line 1895
          tmp___25 = 0;
        }
      }
#line 1895
      if (tmp___25) {
#line 1895
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 1895
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 1895
        tmp___21 = tmp___24;
      }
    } else {
#line 1895
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 1895
      tmp___21 = tmp___24;
    }
#line 1895
    tmp___15 = tmp___21;
  } else {
#line 1895
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 1895
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 1895
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1898
      tmp___0 = strrchr(display, ':');
#line 1898
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1898
      if (tmp___1 != 1) {
#line 1899
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 1901
        return (-1);
      }
#line 1904
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1905
      if (sock < 0) {
#line 1906
        return (-1);
      }
#line 1909
      return (sock);
    }
  }
#line 1915
  __builtin_strncpy(buf___1, display, sizeof(buf___1));
#line 1916
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 1917
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 1917
  cp = tmp___29;
#line 1918
  if (! cp) {
#line 1919
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 1920
    return (-1);
  }
#line 1922
  *cp = (char)0;
#line 1924
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1924
  if (tmp___30 != 1) {
#line 1925
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 1927
    return (-1);
  }
#line 1931
  memset((void *)(& hints), 0, sizeof(hints));
#line 1932
  hints.ai_family = IPv4or6;
#line 1933
  hints.ai_socktype = 1;
#line 1934
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 1935
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1935
  if (gaierr != 0) {
#line 1936
    tmp___31 = gai_strerror(gaierr);
#line 1936
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 1937
    return (-1);
  }
#line 1939
  ai = aitop;
#line 1939
  while (ai) {
#line 1941
    sock = socket(ai->ai_family, 1, 0);
#line 1942
    if (sock < 0) {
#line 1943
      tmp___32 = __errno_location();
#line 1943
      tmp___33 = strerror(*tmp___32);
#line 1943
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 1947
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1947
    if (tmp___36 < 0) {
#line 1948
      tmp___34 = __errno_location();
#line 1948
      tmp___35 = strerror(*tmp___34);
#line 1948
      debug("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 1950
      close(sock);
      goto __Cont;
    }
#line 1954
    break;
    __Cont: /* CIL Label */ 
#line 1939
    ai = ai->ai_next;
  }
#line 1956
  freeaddrinfo(aitop);
#line 1957
  if (! ai) {
#line 1958
    tmp___37 = __errno_location();
#line 1958
    tmp___38 = strerror(*tmp___37);
#line 1958
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 1960
    return (-1);
  }
#line 1962
  return (sock);
}
}
#line 1971 "channels.c"
void x11_input_open(int type , int plen ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  char *remote_host ;
  unsigned int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;

  {
#line 1974
  sock = 0;
#line 1979
  tmp = packet_get_int();
#line 1979
  remote_channel = (int )tmp;
#line 1982
  if (have_hostname_in_open) {
#line 1983
    remote_host = packet_get_string(& remote_len);
#line 1984
    remote_len += 4U;
  } else {
#line 1986
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 1987
    remote_len = 0U;
  }
#line 1990
  debug("Received X11 open request.");
#line 1991
  while (1) {
#line 1991
    _p = plen;
#line 1991
    _e = (int )(4U + remote_len);
#line 1991
    if (_p != _e) {
#line 1991
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1991);
#line 1991
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 1991
    break;
  }
#line 1994
  sock = x11_connect_display();
#line 1995
  if (sock == -1) {
#line 1997
    packet_start(22);
#line 1998
    packet_put_int((unsigned int )remote_channel);
#line 1999
    packet_send();
  } else {
#line 2002
    if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 2002
      tmp___0 = 4;
    } else {
#line 2002
      tmp___0 = 7;
    }
#line 2002
    newch = channel_allocate(tmp___0, sock, remote_host);
#line 2006
    (channels + newch)->remote_id = remote_channel;
#line 2009
    packet_start(21);
#line 2010
    packet_put_int((unsigned int )remote_channel);
#line 2011
    packet_put_int((unsigned int )newch);
#line 2012
    packet_send();
  }
#line 2014
  return;
}
}
#line 2021 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2025
  tmp = strlen(data);
#line 2025
  data_len = tmp / 2U;
#line 2030
  rand___0 = (u_int32_t )0;
#line 2032
  tmp___0 = getenv("DISPLAY");
#line 2032
  cp = (char const   *)tmp___0;
#line 2033
  if (cp) {
#line 2034
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2034
    cp = (char const   *)tmp___2;
  }
#line 2035
  if (cp) {
#line 2036
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2036
    cp = (char const   *)tmp___4;
  }
#line 2037
  if (cp) {
#line 2038
    screen_number = atoi(cp + 1);
  } else {
#line 2040
    screen_number = 0;
  }
#line 2043
  x11_saved_proto = xstrdup(proto);
#line 2049
  tmp___5 = xmalloc(data_len);
#line 2049
  x11_saved_data = (char *)tmp___5;
#line 2050
  tmp___6 = xmalloc(data_len);
#line 2050
  x11_fake_data = (char *)tmp___6;
#line 2051
  i = 0U;
#line 2051
  while (i < data_len) {
#line 2052
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2052
    if (tmp___7 != 1) {
#line 2053
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2054
    if (i % 4U == 0U) {
#line 2055
      rand___0 = arc4random();
    }
#line 2056
    *(x11_saved_data + i) = (char )value;
#line 2057
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2058
    rand___0 >>= 8;
#line 2051
    i ++;
  }
#line 2060
  x11_saved_data_len = data_len;
#line 2061
  x11_fake_data_len = data_len;
#line 2064
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 2064
  new_data = (char *)tmp___8;
#line 2065
  i = 0U;
#line 2065
  while (i < data_len) {
#line 2066
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 2065
    i ++;
  }
#line 2069
  if (compat20) {
#line 2070
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2071
    packet_put_char(0);
  } else {
#line 2073
    packet_start(34);
  }
#line 2075
  packet_put_cstring(proto);
#line 2076
  packet_put_cstring((char const   *)new_data);
#line 2077
  packet_put_int((unsigned int )screen_number);
#line 2078
  packet_send();
#line 2079
  packet_write_wait();
#line 2080
  xfree((void *)new_data);
#line 2081
  return;
}
}
#line 2085 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2088
  packet_start(30);
#line 2089
  packet_send();
#line 2090
  packet_write_wait();
#line 2091
  return;
}
}
#line 2099 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2102
  return (channel_forwarded_auth_socket_name);
}
}
#line 2107 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 2110
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 2111
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 2112
  return;
}
}
#line 2119 "channels.c"
int auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 2125
  tmp = auth_get_socket_name();
#line 2125
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2126
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 2129
  temporarily_use_uid(pw->pw_uid);
#line 2132
  tmp___0 = xmalloc(100U);
#line 2132
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 2133
  tmp___1 = xmalloc(100U);
#line 2133
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 2134
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 2137
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 2137
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2138
    tmp___2 = __errno_location();
#line 2138
    tmp___3 = strerror(*tmp___2);
#line 2138
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___3);
#line 2140
    restore_uid();
#line 2141
    xfree((void *)channel_forwarded_auth_socket_name);
#line 2142
    xfree((void *)channel_forwarded_auth_socket_dir);
#line 2143
    channel_forwarded_auth_socket_name = (char *)((void *)0);
#line 2144
    channel_forwarded_auth_socket_dir = (char *)((void *)0);
#line 2145
    return (0);
  }
#line 2147
  tmp___5 = getpid();
#line 2147
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 2150
  tmp___8 = atexit(& cleanup_socket);
#line 2150
  if (tmp___8 < 0) {
#line 2151
    tmp___6 = __errno_location();
#line 2151
    saved = *tmp___6;
#line 2152
    cleanup_socket();
#line 2153
    tmp___7 = strerror(saved);
#line 2153
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2156
  sock = socket(1, 1, 0);
#line 2157
  if (sock < 0) {
#line 2158
    tmp___9 = __errno_location();
#line 2158
    tmp___10 = strerror(*tmp___9);
#line 2158
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 2161
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2162
  sunaddr.sun_family = (unsigned short)1;
#line 2163
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 2166
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2166
  if (tmp___13 < 0) {
#line 2167
    tmp___11 = __errno_location();
#line 2167
    tmp___12 = strerror(*tmp___11);
#line 2167
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 2170
  restore_uid();
#line 2173
  tmp___16 = listen(sock, 5);
#line 2173
  if (tmp___16 < 0) {
#line 2174
    tmp___14 = __errno_location();
#line 2174
    tmp___15 = strerror(*tmp___14);
#line 2174
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 2177
  tmp___17 = xstrdup("auth socket");
#line 2177
  newch = channel_allocate(6, sock, tmp___17);
#line 2179
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 2181
  return (1);
}
}
#line 2186 "channels.c"
void auth_input_open_request(int type , int plen ) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 2192
  while (1) {
#line 2192
    _p = plen;
#line 2192
    _e = 4;
#line 2192
    if (_p != _e) {
#line 2192
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2192);
#line 2192
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2192
    break;
  }
#line 2195
  tmp = packet_get_int();
#line 2195
  remch = (int )tmp;
#line 2201
  sock = ssh_get_authentication_socket();
#line 2209
  if (sock < 0) {
#line 2210
    packet_start(22);
#line 2211
    packet_put_int((unsigned int )remch);
#line 2212
    packet_send();
#line 2213
    return;
  }
#line 2215
  debug("Forwarding authentication connection.");
#line 2222
  dummyname = xstrdup("authentication agent connection");
#line 2224
  newch = channel_allocate(4, sock, dummyname);
#line 2225
  (channels + newch)->remote_id = remch;
#line 2228
  packet_start(21);
#line 2229
  packet_put_int((unsigned int )remch);
#line 2230
  packet_put_int((unsigned int )newch);
#line 2231
  packet_send();
#line 2232
  return;
}
}
#line 2234 "channels.c"
void channel_start_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2237
  tmp = channel_lookup(id);
#line 2237
  c = tmp;
#line 2238
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2239
    log("channel_open: %d: bad id", id);
#line 2240
    return;
  }
#line 2242
  debug("send channel open %d", id);
#line 2243
  packet_start(90);
#line 2244
  packet_put_cstring((char const   *)c->ctype);
#line 2245
  packet_put_int((unsigned int )c->self);
#line 2246
  packet_put_int((unsigned int )c->local_window);
#line 2247
  packet_put_int((unsigned int )c->local_maxpacket);
#line 2248
  return;
}
}
#line 2249 "channels.c"
void channel_open(int id ) 
{ 

  {
#line 2253
  channel_start_open(id);
#line 2254
  packet_send();
#line 2255
  return;
}
}
#line 2256 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 2259
  channel_request_start(id, service, wantconfirm);
#line 2260
  packet_send();
#line 2261
  debug("channel request %d: %s", id, service);
#line 2262
  return;
}
}
#line 2263 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2266
  tmp = channel_lookup(id);
#line 2266
  c = tmp;
#line 2267
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2268
    log("channel_request: %d: bad id", id);
#line 2269
    return;
  }
#line 2271
  packet_start(98);
#line 2272
  packet_put_int((unsigned int )c->remote_id);
#line 2273
  packet_put_cstring((char const   *)service);
#line 2274
  packet_put_char(wantconfirm);
#line 2275
  return;
}
}
#line 2276 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2279
  tmp = channel_lookup(id);
#line 2279
  c = tmp;
#line 2280
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2281
    log("channel_register_callback: %d: bad id", id);
#line 2282
    return;
  }
#line 2284
  c->cb_event = mtype;
#line 2285
  c->cb_fn = fn;
#line 2286
  c->cb_arg = arg;
#line 2287
  return;
}
}
#line 2288 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2291
  tmp = channel_lookup(id);
#line 2291
  c = tmp;
#line 2292
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2293
    log("channel_register_cleanup: %d: bad id", id);
#line 2294
    return;
  }
#line 2296
  c->dettach_user = fn;
#line 2297
  return;
}
}
#line 2298 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2301
  tmp = channel_lookup(id);
#line 2301
  c = tmp;
#line 2302
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2303
    log("channel_cancel_cleanup: %d: bad id", id);
#line 2304
    return;
  }
#line 2306
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 2307
  return;
}
}
#line 2309 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2312
  tmp = channel_lookup(id);
#line 2312
  c = tmp;
#line 2313
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2314
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 2313
    if (c->type != 10) {
#line 2314
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 2316
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 2317
  c->type = 4;
#line 2319
  c->local_window_max = c->local_maxpacket / 2;
#line 2319
  c->local_window = c->local_window_max;
#line 2320
  packet_start(93);
#line 2321
  packet_put_int((unsigned int )c->remote_id);
#line 2322
  packet_put_int((unsigned int )c->local_window);
#line 2323
  packet_send();
#line 2324
  return;
}
}
#line 1 "cipher.o"
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 69 "cipher.h"
unsigned int cipher_mask(void) ;
#line 71
unsigned int cipher_mask2(void) ;
#line 80
int cipher_number(char const   *name ) ;
#line 83
int ciphers_valid(char const   *names ) ;
#line 89
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) ;
#line 92
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 37 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 46
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 48
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks1, & iv1, 1);
#line 49
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 51
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 0);
#line 52
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 54
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks3, iv3, 1);
#line 55
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 56
  return;
}
}
#line 58 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 67
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 69
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks3, iv3, 0);
#line 70
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 72
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 1);
#line 73
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 75
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks1, & iv1, 0);
#line 78
  return;
}
}
#line 84 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_74 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 88
  dst = (u_int32_t *)dst_;
#line 95
  n___0 /= 8;
#line 95
  while (n___0 > 0) {
#line 96
    tmp = src;
#line 96
    src ++;
#line 96
    t.c[3] = (char )*tmp;
#line 97
    tmp___0 = src;
#line 97
    src ++;
#line 97
    t.c[2] = (char )*tmp___0;
#line 98
    tmp___1 = src;
#line 98
    src ++;
#line 98
    t.c[1] = (char )*tmp___1;
#line 99
    tmp___2 = src;
#line 99
    src ++;
#line 99
    t.c[0] = (char )*tmp___2;
#line 100
    tmp___3 = dst;
#line 100
    dst ++;
#line 100
    *tmp___3 = t.i;
#line 102
    tmp___4 = src;
#line 102
    src ++;
#line 102
    t.c[3] = (char )*tmp___4;
#line 103
    tmp___5 = src;
#line 103
    src ++;
#line 103
    t.c[2] = (char )*tmp___5;
#line 104
    tmp___6 = src;
#line 104
    src ++;
#line 104
    t.c[1] = (char )*tmp___6;
#line 105
    tmp___7 = src;
#line 105
    src ++;
#line 105
    t.c[0] = (char )*tmp___7;
#line 106
    tmp___8 = dst;
#line 106
    dst ++;
#line 106
    *tmp___8 = t.i;
#line 95
    n___0 --;
  }
#line 108
  return;
}
}
#line 114 "cipher.c"
static char *cipher_names[12]  = 
#line 114
  {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish",      (char *)"reserved", 
        (char *)"blowfish-cbc",      (char *)"3des-cbc",      (char *)"arcfour",      (char *)"cast128-cbc"};
#line 136 "cipher.c"
unsigned int cipher_mask1(void) 
{ unsigned int mask ;

  {
#line 139
  mask = 0U;
#line 140
  mask |= (unsigned int )(1 << 3);
#line 141
  mask |= (unsigned int )(1 << 6);
#line 142
  return (mask);
}
}
#line 144 "cipher.c"
unsigned int cipher_mask2(void) 
{ unsigned int mask ;

  {
#line 147
  mask = 0U;
#line 148
  mask |= (unsigned int )(1 << 8);
#line 149
  mask |= (unsigned int )(1 << 9);
#line 150
  mask |= (unsigned int )(1 << 10);
#line 151
  mask |= (unsigned int )(1 << 11);
#line 152
  return (mask);
}
}
#line 154 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 157
  tmp = cipher_mask1();
#line 157
  tmp___0 = cipher_mask2();
#line 157
  return (tmp | tmp___0);
}
}
#line 162 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 165
  if (cipher < 0) {
#line 167
    fatal("cipher_name: bad cipher name: %d", cipher);
  } else {
#line 165
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 167
      fatal("cipher_name: bad cipher name: %d", cipher);
    } else {
#line 165
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 167
        fatal("cipher_name: bad cipher name: %d", cipher);
      }
    }
  }
#line 168
  return ((char const   *)cipher_names[cipher]);
}
}
#line 174 "cipher.c"
int ciphers_valid(char const   *names ) 
{ char *ciphers ;
  char *cp ;
  char *p ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  unsigned int tmp___41 ;

  {
#line 181
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 182
    return (0);
  } else {
#line 181
    if (0) {
#line 181
      __s1_len = strlen(names);
#line 181
      __s2_len = strlen("");
#line 181
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 181
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 181
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 181
            tmp___8 = 1;
          } else {
#line 181
            if (__s2_len >= 4U) {
#line 181
              tmp___8 = 1;
            } else {
#line 181
              tmp___8 = 0;
            }
          }
        } else {
#line 181
          tmp___8 = 0;
        }
      }
#line 181
      if (tmp___8) {
#line 181
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 181
        tmp___7 = __builtin_strcmp(names, "");
#line 181
        tmp___4 = tmp___7;
      }
    } else {
#line 181
      tmp___7 = __builtin_strcmp(names, "");
#line 181
      tmp___4 = tmp___7;
    }
#line 181
    if (tmp___4 == 0) {
#line 182
      return (0);
    }
  }
#line 183
  cp = xstrdup(names);
#line 183
  ciphers = cp;
#line 184
  tmp___24 = __strsep_g(& cp, ",");
#line 184
  p = tmp___24;
#line 184
  while (1) {
#line 184
    if (p) {
#line 184
      if (! ((int )*p != 0)) {
#line 184
        break;
      }
    } else {
#line 184
      break;
    }
#line 186
    i = cipher_number((char const   *)p);
#line 187
    if (i == -1) {
#line 188
      xfree((void *)ciphers);
#line 189
      return (0);
    } else {
#line 187
      tmp___41 = cipher_mask2();
#line 187
      if (! (tmp___41 & (unsigned int )(1 << i))) {
#line 188
        xfree((void *)ciphers);
#line 189
        return (0);
      }
    }
#line 185
    tmp___40 = __strsep_g(& cp, ",");
#line 185
    p = tmp___40;
  }
#line 192
  xfree((void *)ciphers);
#line 193
  return (1);
}
}
#line 201 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 205
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 206
    return (-1);
  }
#line 207
  i = 0;
#line 207
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 208
    if (0) {
#line 208
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 208
      __s2_len = strlen(name);
#line 208
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 208
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 208
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 208
            tmp___8 = 1;
          } else {
#line 208
            if (__s2_len >= 4U) {
#line 208
              tmp___8 = 1;
            } else {
#line 208
              tmp___8 = 0;
            }
          }
        } else {
#line 208
          tmp___8 = 0;
        }
      }
#line 208
      if (tmp___8) {
#line 208
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 208
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 208
        tmp___4 = tmp___7;
      }
    } else {
#line 208
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 208
      tmp___4 = tmp___7;
    }
#line 208
    if (tmp___4 == 0) {
#line 208
      tmp___9 = cipher_mask();
#line 208
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 210
        return (i);
      }
    }
#line 207
    i ++;
  }
#line 211
  return (-1);
}
}
#line 219 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  unsigned char digest___0[16] ;
  size_t tmp ;

  {
#line 225
  MD5_Init(& md);
#line 226
  tmp = strlen(passphrase);
#line 226
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 227
  MD5_Final(digest___0, & md);
#line 229
  cipher_set_key(context, cipher, (unsigned char const   *)(digest___0), 16);
#line 231
  memset((void *)(digest___0), 0, sizeof(digest___0));
#line 232
  memset((void *)(& md), 0, sizeof(md));
#line 233
  return;
}
}
#line 237 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 244
  context->type = (unsigned int )cipher;
#line 248
  memset((void *)(padded), 0, sizeof(padded));
#line 249
  if ((unsigned int )keylen < sizeof(padded)) {
#line 249
    tmp = (unsigned int )keylen;
  } else {
#line 249
    tmp = sizeof(padded);
  }
#line 249
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 252
  switch (cipher) {
  case 0: 
#line 258
  break;
  case 3: 
#line 266
  if (keylen < 16) {
#line 267
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 268
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 269
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 270
  if (keylen <= 16) {
#line 271
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 273
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 274
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 275
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 276
  break;
  case 6: 
#line 279
  if (keylen < 16) {
#line 280
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 281
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 282
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 283
  break;
  case 9: 
  case 8: 
  case 10: 
  case 11: 
#line 289
  tmp___0 = cipher_name(cipher);
#line 289
  fatal("cipher_set_key: illegal cipher: %s", tmp___0);
#line 290
  break;
  default: 
#line 293
  tmp___1 = cipher_name(cipher);
#line 293
  fatal("cipher_set_key: unknown cipher: %s", tmp___1);
  }
#line 295
  memset((void *)(padded), 0, sizeof(padded));
#line 296
  return;
}
}
#line 298 "cipher.c"
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 304
  context->type = (unsigned int )cipher;
#line 307
  switch (cipher) {
  case 0: 
#line 309
  break;
  case 3: 
  case 6: 
#line 313
  tmp = cipher_name(cipher);
#line 313
  fatal("cipher_set_key_iv: illegal cipher: %s", tmp);
#line 314
  break;
  case 9: 
#line 317
  if (keylen < 24) {
#line 318
    error("Key length %d is insufficient for 3des-cbc.", keylen);
  }
#line 319
  DES_set_key((const_DES_cblock *)((void *)key), & context->u.des3.key1);
#line 320
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & context->u.des3.key2);
#line 321
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & context->u.des3.key3);
#line 322
  if (ivlen < 8) {
#line 323
    error("IV length %d is insufficient for 3des-cbc.", ivlen);
  }
#line 324
  memcpy((void * __restrict  )(context->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 325
  break;
  case 8: 
#line 328
  if (keylen < 16) {
#line 329
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 330
  if (ivlen < 8) {
#line 331
    error("IV length %d is insufficient for blowfish.", ivlen);
  }
#line 332
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 333
  memcpy((void * __restrict  )(context->u.bf.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 334
  break;
  case 10: 
#line 337
  if (keylen < 16) {
#line 338
    error("Key length %d is insufficient for arcfour.", keylen);
  }
#line 339
  RC4_set_key(& context->u.rc4, keylen, (unsigned char const   *)((unsigned char *)key));
#line 340
  break;
  case 11: 
#line 343
  if (keylen < 16) {
#line 344
    error("Key length %d is insufficient for cast128.", keylen);
  }
#line 345
  if (ivlen < 8) {
#line 346
    error("IV length %d is insufficient for cast128.", ivlen);
  }
#line 347
  CAST_set_key(& context->u.cast.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 348
  memcpy((void * __restrict  )(context->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 349
  break;
  default: 
#line 352
  tmp___0 = cipher_name(cipher);
#line 352
  fatal("cipher_set_key: unknown cipher: %s", tmp___0);
  }
#line 354
  return;
}
}
#line 358 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 362
  if ((len & 7U) != 0U) {
#line 363
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 365
  switch ((int )context->type) {
  case 0: 
#line 367
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 368
  break;
  case 3: 
#line 371
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 375
  break;
  case 6: 
#line 378
  swap_bytes(src, dest, (int )len);
#line 379
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 382
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 383
  break;
  case 8: 
#line 386
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 389
  break;
  case 9: 
#line 392
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 1);
#line 395
  break;
  case 10: 
#line 398
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 399
  break;
  case 11: 
#line 402
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   1);
#line 404
  break;
  default: 
#line 407
  tmp = cipher_name((int )context->type);
#line 407
  fatal("cipher_encrypt: unknown cipher: %s", tmp);
  }
#line 409
  return;
}
}
#line 413 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 417
  if ((len & 7U) != 0U) {
#line 418
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 420
  switch ((int )context->type) {
  case 0: 
#line 422
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 423
  break;
  case 3: 
#line 426
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 430
  break;
  case 6: 
#line 433
  swap_bytes(src, dest, (int )len);
#line 434
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 437
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 438
  break;
  case 8: 
#line 441
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 444
  break;
  case 9: 
#line 447
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 0);
#line 450
  break;
  case 10: 
#line 453
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 454
  break;
  case 11: 
#line 457
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   0);
#line 459
  break;
  default: 
#line 462
  tmp = cipher_name((int )context->type);
#line 462
  fatal("cipher_decrypt: unknown cipher: %s", tmp);
  }
#line 464
  return;
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 45 "compat.h"
void enable_compat13(void) ;
#line 46
void enable_compat20(void) ;
#line 47
void compat_datafellows(char const   *version ) ;
#line 48
int proto_spec(char const   *spec ) ;
#line 38 "compat.c"
int compat13  =    0;
#line 39 "compat.c"
int compat20  =    0;
#line 40 "compat.c"
int datafellows  =    0;
#line 42 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 45
  verbose("Enabling compatibility mode for protocol 2.0");
#line 46
  compat20 = 1;
#line 47
  return;
}
}
#line 48 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 51
  verbose("Enabling compatibility mode for protocol 1.3");
#line 52
  compat13 = 1;
#line 53
  return;
}
}
#line 55 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  size_t len ;
  struct __anonstruct_check_74 check___1[4] ;
  size_t tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 60
  check___1[0].version = (char *)"2.2.0";
#line 60
  check___1[0].bugs = 20;
#line 60
  check___1[1].version = (char *)"2.1.0";
#line 60
  check___1[1].bugs = 5;
#line 60
  check___1[2].version = (char *)"2.0.1";
#line 60
  check___1[2].bugs = 15;
#line 60
  check___1[3].version = (char *)((void *)0);
#line 60
  check___1[3].bugs = 0;
#line 69
  i = 0;
#line 69
  while (check___1[i].version) {
#line 70
    len = strlen((char const   *)check___1[i].version);
#line 71
    tmp = strlen(version);
#line 72
    if (tmp >= len) {
#line 72
      if (0) {
#line 72
        if (0) {
#line 72
          __s1_len___0 = strlen(version);
#line 72
          __s2_len___0 = strlen((char const   *)check___1[i].version);
#line 72
          if (! ((unsigned int )((void const   *)(version + 1)) - (unsigned int )((void const   *)version) == 1U)) {
            goto _L___2;
          } else {
#line 72
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 72
              if (! ((unsigned int )((void const   *)(check___1[i].version + 1)) - (unsigned int )((void const   *)check___1[i].version) == 1U)) {
#line 72
                tmp___23 = 1;
              } else {
#line 72
                if (__s2_len___0 >= 4U) {
#line 72
                  tmp___23 = 1;
                } else {
#line 72
                  tmp___23 = 0;
                }
              }
            } else {
#line 72
              tmp___23 = 0;
            }
          }
#line 72
          if (tmp___23) {
#line 72
            tmp___19 = __builtin_strcmp(version, (char const   *)check___1[i].version);
          } else {
#line 72
            tmp___22 = __builtin_strcmp(version, (char const   *)check___1[i].version);
#line 72
            tmp___19 = tmp___22;
          }
        } else {
#line 72
          tmp___22 = __builtin_strcmp(version, (char const   *)check___1[i].version);
#line 72
          tmp___19 = tmp___22;
        }
#line 72
        tmp___13 = tmp___19;
      } else {
#line 72
        tmp___13 = strncmp(version, (char const   *)check___1[i].version, len);
      }
#line 72
      if (tmp___13 == 0) {
#line 73
        verbose("datafellows: %.200s", version);
#line 74
        datafellows = check___1[i].bugs;
#line 75
        return;
      }
    }
#line 69
    i ++;
  }
#line 78
  return;
}
}
#line 81 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 85
  ret = 0;
#line 87
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 88
    return (ret);
  }
#line 89
  s = xstrdup(spec);
#line 89
  q = s;
#line 90
  tmp___14 = __strsep_g(& q, ",");
#line 90
  p = tmp___14;
#line 90
  while (1) {
#line 90
    if (p) {
#line 90
      if (! ((int )*p != 0)) {
#line 90
        break;
      }
    } else {
#line 90
      break;
    }
#line 91
    tmp___31 = atoi((char const   *)p);
#line 91
    switch (tmp___31) {
    case 1: 
#line 93
    if (ret == 0) {
#line 94
      ret |= 2;
    }
#line 95
    ret |= 1;
#line 96
    break;
    case 2: 
#line 98
    ret |= 4;
#line 99
    break;
    default: 
#line 101
    log("ignoring bad proto spec: \'%s\'.", p);
#line 102
    break;
    }
#line 90
    tmp___30 = __strsep_g(& q, ",");
#line 90
    p = tmp___30;
  }
#line 105
  xfree((void *)s);
#line 106
  return (ret);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 31 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 34
  debug("Enabling compression at level %d.", level);
#line 35
  if (level < 1) {
#line 36
    fatal("Bad compression level %d.", level);
  } else {
#line 35
    if (level > 9) {
#line 36
      fatal("Bad compression level %d.", level);
    }
  }
#line 37
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 38
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 39
  return;
}
}
#line 43 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 46
  if (outgoing_stream.total_in == 0UL) {
#line 46
    tmp = 0.0;
  } else {
#line 46
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 46
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 50
  if (incoming_stream.total_out == 0UL) {
#line 50
    tmp___0 = 0.0;
  } else {
#line 50
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 50
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 54
  inflateEnd(& incoming_stream);
#line 55
  deflateEnd(& outgoing_stream);
#line 56
  return;
}
}
#line 67 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 74
  tmp = buffer_len(input_buffer);
#line 74
  if (tmp == 0U) {
#line 75
    return;
  }
#line 78
  tmp___0 = buffer_ptr(input_buffer);
#line 78
  outgoing_stream.next_in = (unsigned char *)tmp___0;
#line 79
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 82
  while (1) {
#line 84
    outgoing_stream.next_out = (unsigned char *)(buf___1);
#line 85
    outgoing_stream.avail_out = sizeof(buf___1);
#line 88
    status = deflate(& outgoing_stream, 1);
#line 89
    switch (status) {
    case 0: 
#line 92
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 94
    break;
    default: 
#line 96
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 82
    if (! (outgoing_stream.avail_out == 0U)) {
#line 82
      break;
    }
  }
#line 100
  return;
}
}
#line 111 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  char *tmp ;

  {
#line 117
  tmp = buffer_ptr(input_buffer);
#line 117
  incoming_stream.next_in = (unsigned char *)tmp;
#line 118
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 120
  while (1) {
#line 122
    incoming_stream.next_out = (unsigned char *)(buf___1);
#line 123
    incoming_stream.avail_out = sizeof(buf___1);
#line 125
    status = inflate(& incoming_stream, 1);
#line 126
    switch (status) {
    case 0: 
#line 128
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 130
    break;
    case -5: 
#line 137
    return;
    default: 
#line 139
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 25 "crc32.h"
unsigned int crc32(unsigned char const   *s , unsigned int len ) ;
#line 53 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 53 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 110 "crc32.c"
unsigned int crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 116
  crc32val = 0U;
#line 117
  i = 0U;
#line 117
  while (i < len) {
#line 118
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 117
    i ++;
  }
#line 120
  return (crc32val);
}
}
#line 1 "deattack.o"
#line 27 "deattack.h"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) ;
#line 49 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 52
  b ^= *a;
#line 53
  *a = crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 54
  return;
}
}
#line 57 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  crc = 0U;
#line 65
  if (IV) {
#line 65
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 65
    if (! tmp) {
#line 66
      crc_update(& crc, 1U);
#line 67
      crc_update(& crc, 0U);
    }
  }
#line 69
  c = buf___1;
#line 69
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 70
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 70
    if (tmp___0) {
#line 74
      crc_update(& crc, 0U);
#line 75
      crc_update(& crc, 0U);
    } else {
#line 71
      crc_update(& crc, 1U);
#line 72
      crc_update(& crc, 0U);
    }
#line 69
    c += 8;
  }
#line 78
  return (crc == 0U);
}
}
#line 86 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 87 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 83 "deattack.c"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (len > 262144U) {
#line 95
    fatal("detect_attack: bad length %d", len);
  } else {
#line 93
    if (len % 8U != 0U) {
#line 95
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 97
  l = (unsigned int )n;
#line 97
  while (l < ((len / 8U) * 3U) / 2U) {
#line 97
    l <<= 2;
  }
#line 100
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 101
    debug("Installing crc compensation attack detector.");
#line 102
    n = (unsigned short )l;
#line 103
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 103
    h = (u_int16_t *)tmp;
  } else {
#line 105
    if (l > (u_int32_t )n) {
#line 106
      n = (unsigned short )l;
#line 107
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 107
      h = (u_int16_t *)tmp___0;
    }
  }
#line 111
  if (len <= 56U) {
#line 112
    c = buf___1;
#line 112
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 113
      if (IV) {
#line 113
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 113
        if (! tmp___2) {
#line 114
          tmp___1 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 114
          if (tmp___1) {
#line 115
            return (1);
          } else {
#line 117
            break;
          }
        }
      }
#line 119
      d = buf___1;
#line 119
      while ((unsigned int )d < (unsigned int )c) {
#line 120
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 120
        if (! tmp___4) {
#line 121
          tmp___3 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 121
          if (tmp___3) {
#line 122
            return (1);
          } else {
#line 124
            break;
          }
        }
#line 119
        d += 8;
      }
#line 112
      c += 8;
    }
#line 128
    return (0);
  }
#line 130
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 132
  if (IV) {
#line 133
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 135
  c = buf___1;
#line 135
  j = 0U;
#line 135
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 136
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 136
    while ((int )*(h + i) != 65535) {
#line 138
      if ((int )*(h + i) == 65534) {
#line 139
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 139
        if (! tmp___6) {
#line 140
          tmp___5 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 140
          if (tmp___5) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
      } else {
#line 145
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 145
        if (! tmp___8) {
#line 146
          tmp___7 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 146
          if (tmp___7) {
#line 147
            return (1);
          } else {
#line 149
            break;
          }
        }
      }
#line 136
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 152
    *(h + i) = (unsigned short )j;
#line 135
    c += 8;
#line 135
    j ++;
  }
#line 154
  return (0);
}
}
#line 1 "dispatch.o"
#line 8 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 9
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 10
void dispatch_run(int mode , int *done ) ;
#line 11
void dispatch_protocol_error(int type , int plen ) ;
#line 100 "packet.h"
int packet_read(int *payload_len_ptr ) ;
#line 116
int packet_read_poll(int *payload_len_ptr ) ;
#line 38 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 40 "dispatch.c"
void dispatch_protocol_error(int type , int plen ) 
{ 

  {
#line 43
  error("Hm, dispatch protocol error: type %d plen %d", type, plen);
#line 44
  return;
}
}
#line 45 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 49
  i = 0;
#line 49
  while (i < 255) {
#line 50
    dispatch[i] = dflt;
#line 49
    i ++;
  }
#line 51
  return;
}
}
#line 52 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 55
  dispatch[type] = fn;
#line 56
  return;
}
}
#line 57 "dispatch.c"
void dispatch_run(int mode , int *done ) 
{ int plen ;
  int type ;

  {
#line 60
  while (1) {
#line 64
    if (mode == 0) {
#line 65
      type = packet_read(& plen);
    } else {
#line 67
      type = packet_read_poll(& plen);
#line 68
      if (type == 0) {
#line 69
        return;
      }
    }
#line 71
    if (type > 0) {
#line 71
      if (type < 255) {
#line 71
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 72
          (*(dispatch[type]))(type, plen);
        } else {
#line 74
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 74
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 74
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 75
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 75
      if (*done) {
#line 76
        return;
      }
    }
  }
}
}
#line 1 "dsa.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 16 "key.h"
Key *key_new(int type ) ;
#line 17
void key_free(Key *k ) ;
#line 55 "dsa.c"
Key *dsa_key_from_blob(char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  DSA *dsa ;
  Key *key ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 69
  key = key_new(1);
#line 70
  dsa = key->dsa;
#line 71
  buffer_init(& b);
#line 72
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 73
  ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 74
  if (0) {
#line 74
    __s1_len = strlen("ssh-dss");
#line 74
    __s2_len = strlen((char const   *)ktype);
#line 74
    if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
      goto _L___0;
    } else {
#line 74
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 74
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 74
          tmp___8 = 1;
        } else {
#line 74
          if (__s2_len >= 4U) {
#line 74
            tmp___8 = 1;
          } else {
#line 74
            tmp___8 = 0;
          }
        }
      } else {
#line 74
        tmp___8 = 0;
      }
    }
#line 74
    if (tmp___8) {
#line 74
      tmp___4 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
    } else {
#line 74
      tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 74
      tmp___4 = tmp___7;
    }
  } else {
#line 74
    tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 74
    tmp___4 = tmp___7;
  }
#line 74
  if (tmp___4 != 0) {
#line 75
    error("dsa_key_from_blob: cannot handle type %s", ktype);
#line 76
    key_free(key);
#line 77
    return ((Key *)((void *)0));
  }
#line 79
  buffer_get_bignum2(& b, dsa->p);
#line 80
  buffer_get_bignum2(& b, dsa->q);
#line 81
  buffer_get_bignum2(& b, dsa->g);
#line 82
  buffer_get_bignum2(& b, dsa->pub_key);
#line 83
  tmp___9 = buffer_len(& b);
#line 83
  rlen = (int )tmp___9;
#line 84
  if (rlen != 0) {
#line 85
    error("dsa_key_from_blob: remaining bytes in key blob %d", rlen);
  }
#line 86
  buffer_free(& b);
#line 88
  debug("keytype %s", ktype);
#line 92
  return (key);
}
}
#line 94 "dsa.c"
int dsa_make_key_blob(Key *key , unsigned char **blobp , unsigned int *lenp ) 
{ Buffer b ;
  int len ;
  unsigned char *buf___1 ;
  unsigned int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 101
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 102
    return (0);
  } else {
#line 101
    if (key->type != 1) {
#line 102
      return (0);
    }
  }
#line 103
  buffer_init(& b);
#line 104
  buffer_put_cstring(& b, "ssh-dss");
#line 105
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 106
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 107
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 108
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 109
  tmp = buffer_len(& b);
#line 109
  len = (int )tmp;
#line 110
  tmp___0 = xmalloc((unsigned int )len);
#line 110
  buf___1 = (unsigned char *)tmp___0;
#line 111
  tmp___1 = buffer_ptr(& b);
#line 111
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )tmp___1, (unsigned int )len);
#line 112
  tmp___2 = buffer_ptr(& b);
#line 112
  memset((void *)tmp___2, 0, (unsigned int )len);
#line 113
  buffer_free(& b);
#line 114
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 115
    *lenp = (unsigned int )len;
  }
#line 116
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 117
    *blobp = buf___1;
  }
#line 118
  return (len);
}
}
#line 120 "dsa.c"
int dsa_sign(Key *key , unsigned char **sigp , int *lenp , unsigned char *data , int datalen ) 
{ unsigned char *digest___0 ;
  unsigned char *ret ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned int rlen ;
  unsigned int slen ;
  unsigned int len ;
  unsigned char sigblob[40] ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 129
  tmp = EVP_sha1();
#line 129
  evp_md = (EVP_MD *)tmp;
#line 137
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 138
    error("dsa_sign: no DSA key");
#line 139
    return (-1);
  } else {
#line 137
    if (key->type != 1) {
#line 138
      error("dsa_sign: no DSA key");
#line 139
      return (-1);
    } else {
#line 137
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 138
        error("dsa_sign: no DSA key");
#line 139
        return (-1);
      }
    }
  }
#line 141
  tmp___0 = xmalloc((unsigned int )evp_md->md_size);
#line 141
  digest___0 = (unsigned char *)tmp___0;
#line 142
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 143
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 144
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 146
  sig = DSA_do_sign((unsigned char const   *)digest___0, evp_md->md_size, key->dsa);
#line 147
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 148
    fatal("dsa_sign: cannot sign");
  }
#line 151
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 151
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 152
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 152
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 153
  if (rlen > 20U) {
#line 154
    error("bad sig size %d %d", rlen, slen);
#line 155
    DSA_SIG_free(sig);
#line 156
    return (-1);
  } else {
#line 153
    if (slen > 20U) {
#line 154
      error("bad sig size %d %d", rlen, slen);
#line 155
      DSA_SIG_free(sig);
#line 156
      return (-1);
    }
  }
#line 158
  debug("sig size %d %d", rlen, slen);
#line 160
  memset((void *)(sigblob), 0, 40U);
#line 161
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 162
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 163
  DSA_SIG_free(sig);
#line 165
  if (datafellows & 1) {
#line 166
    debug("datafellows");
#line 167
    tmp___3 = xmalloc(40U);
#line 167
    ret = (unsigned char *)tmp___3;
#line 168
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 169
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 170
      *lenp = 40;
    }
#line 171
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 172
      *sigp = ret;
    }
  } else {
#line 175
    buffer_init(& b);
#line 176
    buffer_put_cstring(& b, "ssh-dss");
#line 177
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 178
    len = buffer_len(& b);
#line 179
    tmp___4 = xmalloc(len);
#line 179
    ret = (unsigned char *)tmp___4;
#line 180
    tmp___5 = buffer_ptr(& b);
#line 180
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 181
    buffer_free(& b);
#line 182
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 183
      *lenp = (int )len;
    }
#line 184
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 185
      *sigp = ret;
    }
  }
#line 187
  return (0);
}
}
#line 189 "dsa.c"
int dsa_verify(Key *key , unsigned char *signature , int signaturelen , unsigned char *data ,
               int datalen ) 
{ Buffer b ;
  unsigned char *digest___0 ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned char *sigblob ;
  char *txt ;
  unsigned int len ;
  int rlen ;
  int ret ;
  char *ktype ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;
  void *tmp___12 ;

  {
#line 198
  tmp = EVP_sha1();
#line 198
  evp_md = (EVP_MD *)tmp;
#line 206
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 207
    error("dsa_verify: no DSA key");
#line 208
    return (-1);
  } else {
#line 206
    if (key->type != 1) {
#line 207
      error("dsa_verify: no DSA key");
#line 208
      return (-1);
    } else {
#line 206
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 207
        error("dsa_verify: no DSA key");
#line 208
        return (-1);
      }
    }
  }
#line 211
  if (! (datafellows & 1)) {
#line 211
    if (signaturelen == 40) {
#line 213
      datafellows |= -2;
#line 214
      log("autodetect SSH_BUG_SIGBLOB");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 215
    if (datafellows & 1) {
#line 215
      if (signaturelen != 40) {
#line 217
        log("autoremove SSH_BUG_SIGBLOB");
#line 218
        datafellows &= -2;
      }
    }
  }
#line 221
  debug("len %d datafellows %d", signaturelen, datafellows);
#line 224
  if (datafellows & 1) {
#line 225
    sigblob = signature;
#line 226
    len = (unsigned int )signaturelen;
  } else {
#line 230
    buffer_init(& b);
#line 231
    buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 232
    ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 233
    if (0) {
#line 233
      __s1_len = strlen("ssh-dss");
#line 233
      __s2_len = strlen((char const   *)ktype);
#line 233
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___1;
      } else {
#line 233
        if (__s1_len >= 4U) {
          _L___1: /* CIL Label */ 
#line 233
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 233
            tmp___9 = 1;
          } else {
#line 233
            if (__s2_len >= 4U) {
#line 233
              tmp___9 = 1;
            } else {
#line 233
              tmp___9 = 0;
            }
          }
        } else {
#line 233
          tmp___9 = 0;
        }
      }
#line 233
      if (tmp___9) {
#line 233
        tmp___5 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 233
        tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 233
        tmp___5 = tmp___8;
      }
    } else {
#line 233
      tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 233
      tmp___5 = tmp___8;
    }
#line 233
    if (tmp___5 != 0) {
#line 234
      error("dsa_verify: cannot handle type %s", ktype);
#line 235
      buffer_free(& b);
#line 236
      return (-1);
    }
#line 238
    tmp___10 = buffer_get_string(& b, & len);
#line 238
    sigblob = (unsigned char *)tmp___10;
#line 239
    tmp___11 = buffer_len(& b);
#line 239
    rlen = (int )tmp___11;
#line 240
    if (rlen != 0) {
#line 241
      error("remaining bytes in signature %d", rlen);
#line 242
      buffer_free(& b);
#line 243
      return (-1);
    }
#line 245
    buffer_free(& b);
#line 246
    xfree((void *)ktype);
  }
#line 249
  if (len != 40U) {
#line 250
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 254
  sig = DSA_SIG_new();
#line 255
  sig->r = BN_new();
#line 256
  sig->s = BN_new();
#line 257
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 258
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 260
  if (! (datafellows & 1)) {
#line 261
    memset((void *)sigblob, 0, len);
#line 262
    xfree((void *)sigblob);
  }
#line 266
  tmp___12 = xmalloc((unsigned int )evp_md->md_size);
#line 266
  digest___0 = (unsigned char *)tmp___12;
#line 267
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 268
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 269
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 271
  ret = DSA_do_verify((unsigned char const   *)digest___0, evp_md->md_size, sig, key->dsa);
#line 273
  memset((void *)digest___0, 0, (unsigned int )evp_md->md_size);
#line 274
  xfree((void *)digest___0);
#line 275
  DSA_SIG_free(sig);
#line 277
  switch (ret) {
  case 1: 
#line 279
  txt = (char *)"correct";
#line 280
  break;
  case 0: 
#line 282
  txt = (char *)"incorrect";
#line 283
  break;
  case -1: 
  default: 
#line 286
  txt = (char *)"error";
#line 287
  break;
  }
#line 289
  debug("dsa_verify: signature %s", txt);
#line 290
  return (ret);
}
}
#line 293 "dsa.c"
Key *dsa_generate_key(unsigned int bits ) 
{ DSA *dsa ;
  DSA *tmp ;
  Key *k ;
  int tmp___0 ;

  {
#line 296
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 296
  dsa = tmp;
#line 298
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 299
    fatal("DSA_generate_parameters failed");
  }
#line 301
  tmp___0 = DSA_generate_key(dsa);
#line 301
  if (! tmp___0) {
#line 302
    fatal("DSA_generate_keys failed");
  }
#line 305
  k = key_new(2);
#line 306
  k->type = 1;
#line 307
  k->dsa = dsa;
#line 308
  return (k);
}
}
#line 1 "fingerprint.o"
#line 46 "fingerprint.c"
static char retval[80]  ;
#line 43 "fingerprint.c"
char *fingerprint(BIGNUM *e , BIGNUM *n___0 ) 
{ MD5_CTX md ;
  unsigned char d[16] ;
  unsigned char *buf___1 ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 52
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 52
  nlen = (tmp + 7) / 8;
#line 53
  tmp___0 = BN_num_bits((BIGNUM const   *)e);
#line 53
  elen = (tmp___0 + 7) / 8;
#line 55
  tmp___1 = xmalloc((unsigned int )(nlen + elen));
#line 55
  buf___1 = (unsigned char *)tmp___1;
#line 57
  BN_bn2bin((BIGNUM const   *)n___0, buf___1);
#line 58
  BN_bn2bin((BIGNUM const   *)e, buf___1 + nlen);
#line 60
  MD5_Init(& md);
#line 61
  MD5_Update(& md, (void const   *)buf___1, (unsigned int )(nlen + elen));
#line 62
  MD5_Final(d, & md);
#line 63
  snprintf((char * __restrict  )(retval), sizeof(retval), (char const   * __restrict  )"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
           d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11],
           d[12], d[13], d[14], d[15]);
#line 66
  memset((void *)buf___1, 0, (unsigned int )(nlen + elen));
#line 67
  xfree((void *)buf___1);
#line 68
  return (retval);
}
}
#line 1 "hmac.o"
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 47 "hmac.c"
static unsigned char m[64]  ;
#line 39 "hmac.c"
unsigned char *hmac(EVP_MD *evp_md , unsigned int seqno , unsigned char *data , int datalen ,
                    unsigned char *key , int keylen ) 
{ HMAC_CTX c ;
  unsigned char b[4] ;

  {
#line 50
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 51
    fatal("hmac: no key");
  }
#line 52
  HMAC_Init(& c, (void const   *)key, keylen, (EVP_MD const   *)evp_md);
#line 53
  while (1) {
#line 53
    b[0] = (unsigned char )(seqno >> 24);
#line 53
    b[1] = (unsigned char )(seqno >> 16);
#line 53
    b[2] = (unsigned char )(seqno >> 8);
#line 53
    b[3] = (unsigned char )seqno;
#line 53
    break;
  }
#line 54
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 55
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 56
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 57
  HMAC_CTX_cleanup(& c);
#line 58
  return (m);
}
}
#line 1 "hostfile.o"
#line 248 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 16 "match.h"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 382 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 18 "key.h"
int key_equal(Key *a , Key *b ) ;
#line 21
int key_write(Key *key , FILE *f ) ;
#line 22
unsigned int key_read(Key *ret , char **cpp ) ;
#line 13 "hostfile.h"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) ;
#line 20
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 32 "hostfile.c"
int hostfile_read_key(char **cpp , unsigned int *bitsp , Key *ret ) 
{ unsigned int bits ;
  char *cp ;

  {
#line 39
  cp = *cpp;
#line 39
  while (1) {
#line 39
    if (! ((int )*cp == 32)) {
#line 39
      if (! ((int )*cp == 9)) {
#line 39
        break;
      }
    }
#line 39
    cp ++;
  }
#line 42
  bits = key_read(ret, & cp);
#line 43
  if (bits == 0U) {
#line 44
    return (0);
  }
#line 47
  while (1) {
#line 47
    if (! ((int )*cp == 32)) {
#line 47
      if (! ((int )*cp == 9)) {
#line 47
        break;
      }
    }
#line 47
    cp ++;
  }
#line 51
  *cpp = cp;
#line 52
  *bitsp = bits;
#line 53
  return (1);
}
}
#line 56 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 59
  tmp = key_new(0);
#line 59
  k = tmp;
#line 60
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 60
  ret = tmp___0;
#line 61
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 62
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 63
  key_free(k);
#line 64
  return (ret);
}
}
#line 67 "hostfile.c"
int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                       int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 71
    return (1);
  } else {
#line 70
    if (key->type != 0) {
#line 71
      return (1);
    } else {
#line 70
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 71
        return (1);
      }
    }
  }
#line 72
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 72
  if (bits != tmp___1) {
#line 73
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 73
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 76
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 76
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 79
  return (1);
}
}
#line 89 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 94
  linenum = 0;
#line 99
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 100
    fatal("no key to look up");
  }
#line 102
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 103
  if (! f) {
#line 104
    return (1);
  }
#line 107
  hostlen = strlen(host);
#line 114
  end_return = 1;
#line 117
  while (1) {
#line 117
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 117
    if (! tmp___3) {
#line 117
      break;
    }
#line 118
    cp = line;
#line 119
    linenum ++;
#line 122
    while (1) {
#line 122
      if (! ((int )*cp == 32)) {
#line 122
        if (! ((int )*cp == 9)) {
#line 122
          break;
        }
      }
#line 122
      cp ++;
    }
#line 124
    if (! *cp) {
#line 125
      continue;
    } else {
#line 124
      if ((int )*cp == 35) {
#line 125
        continue;
      } else {
#line 124
        if ((int )*cp == 10) {
#line 125
          continue;
        }
      }
    }
#line 128
    cp2 = cp;
#line 128
    while (1) {
#line 128
      if (*cp2) {
#line 128
        if ((int )*cp2 != 32) {
#line 128
          if (! ((int )*cp2 != 9)) {
#line 128
            break;
          }
        } else {
#line 128
          break;
        }
      } else {
#line 128
        break;
      }
#line 128
      cp2 ++;
    }
#line 132
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 132
    if (tmp != 1) {
#line 133
      continue;
    }
#line 136
    cp = cp2;
#line 142
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 142
    if (! tmp___0) {
#line 143
      continue;
    }
#line 144
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 144
    if (! tmp___1) {
#line 145
      continue;
    }
#line 148
    tmp___2 = key_equal(key, found);
#line 148
    if (tmp___2) {
#line 150
      fclose(f);
#line 151
      return (0);
    }
#line 158
    end_return = 2;
  }
#line 161
  fclose(f);
#line 167
  return (end_return);
}
}
#line 175 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 179
  success = 0;
#line 180
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 181
    return (1);
  }
#line 182
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 183
  if (! f) {
#line 184
    return (0);
  }
#line 185
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 186
  tmp = key_write(key, f);
#line 186
  if (tmp) {
#line 187
    success = 1;
  } else {
#line 189
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 191
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 192
  fclose(f);
#line 193
  return (success);
}
}
#line 1 "key.o"
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 7 "bsd-strlcat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 19 "key.h"
char *key_fingerprint(Key *k ) ;
#line 20
char *key_type(Key *k ) ;
#line 3 "uuencode.h"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) ;
#line 4
int uudecode(char const   *src , unsigned char *target , size_t targsize ) ;
#line 48 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 54
  tmp = xmalloc(sizeof(*k));
#line 54
  k = (Key *)tmp;
#line 55
  k->type = type;
#line 56
  k->dsa = (DSA *)((void *)0);
#line 57
  k->rsa = (RSA *)((void *)0);
#line 58
  switch (k->type) {
  case 0: 
#line 60
  rsa = RSA_new();
#line 61
  rsa->n = BN_new();
#line 62
  rsa->e = BN_new();
#line 63
  k->rsa = rsa;
#line 64
  break;
  case 1: 
#line 66
  dsa = DSA_new();
#line 67
  dsa->p = BN_new();
#line 68
  dsa->q = BN_new();
#line 69
  dsa->g = BN_new();
#line 70
  dsa->pub_key = BN_new();
#line 71
  k->dsa = dsa;
#line 72
  break;
  case 2: 
#line 74
  break;
  default: 
#line 76
  fatal("key_new: bad key type %d", k->type);
#line 77
  break;
  }
#line 79
  return (k);
}
}
#line 81 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 84
  switch (k->type) {
  case 0: 
#line 86
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 87
    RSA_free(k->rsa);
  }
#line 88
  k->rsa = (RSA *)((void *)0);
#line 89
  break;
  case 1: 
#line 91
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 92
    DSA_free(k->dsa);
  }
#line 93
  k->dsa = (DSA *)((void *)0);
#line 94
  break;
  default: 
#line 96
  fatal("key_free: bad key type %d", k->type);
#line 97
  break;
  }
#line 99
  xfree((void *)k);
#line 100
  return;
}
}
#line 101 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 104
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 105
    return (0);
  } else {
#line 104
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 105
      return (0);
    } else {
#line 104
      if (a->type != b->type) {
#line 105
        return (0);
      }
    }
  }
#line 106
  switch (a->type) {
  case 0: 
#line 108
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 108
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 108
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 108
      if (tmp == 0) {
#line 108
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 108
        if (tmp___0 == 0) {
#line 108
          tmp___1 = 1;
        } else {
#line 108
          tmp___1 = 0;
        }
      } else {
#line 108
        tmp___1 = 0;
      }
    } else {
#line 108
      tmp___1 = 0;
    }
  } else {
#line 108
    tmp___1 = 0;
  }
#line 108
  return (tmp___1);
#line 111
  break;
  case 1: 
#line 113
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 113
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 113
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 113
      if (tmp___2 == 0) {
#line 113
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 113
        if (tmp___3 == 0) {
#line 113
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 113
          if (tmp___4 == 0) {
#line 113
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 113
            if (tmp___5 == 0) {
#line 113
              tmp___6 = 1;
            } else {
#line 113
              tmp___6 = 0;
            }
          } else {
#line 113
            tmp___6 = 0;
          }
        } else {
#line 113
          tmp___6 = 0;
        }
      } else {
#line 113
        tmp___6 = 0;
      }
    } else {
#line 113
      tmp___6 = 0;
    }
  } else {
#line 113
    tmp___6 = 0;
  }
#line 113
  return (tmp___6);
#line 118
  break;
  default: 
#line 120
  fatal("key_equal: bad key type %d", a->type);
#line 121
  break;
  }
#line 123
  return (0);
}
}
#line 133 "key.c"
static char retval___0[195]  ;
#line 130 "key.c"
char *key_fingerprint(Key *k ) 
{ unsigned char *blob ;
  int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int i ;
  unsigned char digest___0[64] ;
  EVP_MD *md ;
  EVP_MD const   *tmp___2 ;
  EVP_MD_CTX ctx ;
  char hex[4] ;
  size_t tmp___3 ;

  {
#line 134
  blob = (unsigned char *)((void *)0);
#line 135
  len = 0;
#line 138
  switch (k->type) {
  case 0: 
#line 140
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 140
  nlen = (tmp + 7) / 8;
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 141
  elen = (tmp___0 + 7) / 8;
#line 142
  len = nlen + elen;
#line 143
  tmp___1 = xmalloc((unsigned int )len);
#line 143
  blob = (unsigned char *)tmp___1;
#line 144
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 145
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 146
  break;
  case 1: 
#line 148
  dsa_make_key_blob(k, & blob, (unsigned int *)(& len));
#line 149
  break;
  default: 
#line 151
  fatal("key_fingerprint: bad key type %d", k->type);
#line 152
  break;
  }
#line 154
  retval___0[0] = (char )'\000';
#line 156
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 159
    tmp___2 = EVP_md5();
#line 159
    md = (EVP_MD *)tmp___2;
#line 161
    EVP_DigestInit(& ctx, (EVP_MD const   *)md);
#line 162
    EVP_DigestUpdate(& ctx, (void const   *)blob, (unsigned int )len);
#line 163
    EVP_DigestFinal(& ctx, digest___0, (unsigned int *)((void *)0));
#line 164
    i = 0;
#line 164
    while (i < md->md_size) {
#line 166
      snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
               digest___0[i]);
#line 167
      strlcat(retval___0, (char const   *)(hex), sizeof(retval___0));
#line 164
      i ++;
    }
#line 169
    tmp___3 = strlen((char const   *)(retval___0));
#line 169
    retval___0[tmp___3 - 1U] = (char )'\000';
#line 170
    memset((void *)blob, 0, (unsigned int )len);
#line 171
    xfree((void *)blob);
  }
#line 173
  return (retval___0);
}
}
#line 183 "key.c"
int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 186
  cp = *cpp;
#line 190
  while (1) {
#line 190
    if (! ((int )*cp == 32)) {
#line 190
      if (! ((int )*cp == 9)) {
#line 190
        break;
      }
    }
#line 190
    cp ++;
  }
#line 194
  if ((int )*cp < 48) {
#line 195
    return (0);
  } else {
#line 194
    if ((int )*cp > 57) {
#line 195
      return (0);
    }
  }
#line 198
  *cpp = cp;
#line 201
  while (1) {
#line 201
    if ((int )*cp >= 48) {
#line 201
      if (! ((int )*cp <= 57)) {
#line 201
        break;
      }
    } else {
#line 201
      break;
    }
#line 201
    cp ++;
  }
#line 205
  old = (int )*cp;
#line 206
  *cp = (char)0;
#line 209
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 209
  if (tmp == 0) {
#line 210
    return (0);
  }
#line 213
  *cp = (char )old;
#line 216
  *cpp = cp;
#line 217
  return (1);
}
}
#line 219 "key.c"
int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 222
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 222
  buf___1 = tmp;
#line 223
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 224
    error("write_bignum: BN_bn2dec() failed");
#line 225
    return (0);
  }
#line 227
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 228
  free((void *)buf___1);
#line 229
  return (1);
}
}
#line 231 "key.c"
unsigned int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  unsigned int bits ;
  char *cp ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  int tmp ;
  int tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  int tmp___29 ;

  {
#line 235
  bits = 0U;
#line 240
  cp = *cpp;
#line 242
  switch (ret->type) {
  case 0: 
#line 245
  if ((int )*cp < 48) {
#line 246
    return (0U);
  } else {
#line 245
    if ((int )*cp > 57) {
#line 246
      return (0U);
    }
  }
#line 247
  bits = 0U;
#line 247
  while (1) {
#line 247
    if ((int )*cp >= 48) {
#line 247
      if (! ((int )*cp <= 57)) {
#line 247
        break;
      }
    } else {
#line 247
      break;
    }
#line 248
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 247
    cp ++;
  }
#line 249
  if (bits == 0U) {
#line 250
    return (0U);
  }
#line 251
  *cpp = cp;
#line 253
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 253
  if (! tmp) {
#line 254
    return (0U);
  }
#line 255
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 255
  if (! tmp___0) {
#line 256
    return (0U);
  }
#line 257
  break;
  case 1: 
#line 259
  if (0) {
#line 259
    if (0) {
#line 259
      __s1_len___0 = strlen((char const   *)cp);
#line 259
      __s2_len___0 = strlen("ssh-dss ");
#line 259
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___2;
      } else {
#line 259
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 259
          if (! ((unsigned int )((void const   *)("ssh-dss " + 1)) - (unsigned int )((void const   *)"ssh-dss ") == 1U)) {
#line 259
            tmp___24 = 1;
          } else {
#line 259
            if (__s2_len___0 >= 4U) {
#line 259
              tmp___24 = 1;
            } else {
#line 259
              tmp___24 = 0;
            }
          }
        } else {
#line 259
          tmp___24 = 0;
        }
      }
#line 259
      if (tmp___24) {
#line 259
        tmp___20 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
      } else {
#line 259
        tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 259
        tmp___20 = tmp___23;
      }
    } else {
#line 259
      tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 259
      tmp___20 = tmp___23;
    }
#line 259
    tmp___14 = tmp___20;
  } else {
#line 259
    tmp___14 = strncmp((char const   *)cp, "ssh-dss ", 7U);
  }
#line 259
  if (tmp___14 != 0) {
#line 260
    return (0U);
  }
#line 261
  cp += 7;
#line 262
  tmp___27 = strlen((char const   *)cp);
#line 262
  len = (int )(2U * tmp___27);
#line 263
  tmp___28 = xmalloc((unsigned int )len);
#line 263
  blob = (unsigned char *)tmp___28;
#line 264
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 265
  if (n___0 < 0) {
#line 266
    error("key_read: uudecode %s failed", cp);
#line 267
    return (0U);
  }
#line 269
  k = dsa_key_from_blob((char *)blob, n___0);
#line 270
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 271
    error("key_read: dsa_key_from_blob %s failed", cp);
#line 272
    return (0U);
  }
#line 274
  xfree((void *)blob);
#line 275
  if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 276
    DSA_free(ret->dsa);
  }
#line 277
  ret->dsa = k->dsa;
#line 278
  k->dsa = (DSA *)((void *)0);
#line 279
  key_free(k);
#line 280
  tmp___29 = BN_num_bits((BIGNUM const   *)(ret->dsa)->p);
#line 280
  bits = (unsigned int )tmp___29;
#line 282
  while (1) {
#line 282
    if (! ((int )*cp == 32)) {
#line 282
      if (! ((int )*cp == 9)) {
#line 282
        break;
      }
    }
#line 283
    cp ++;
  }
#line 284
  while (1) {
#line 284
    if ((int )*cp != 0) {
#line 284
      if ((int )*cp != 32) {
#line 284
        if (! ((int )*cp != 9)) {
#line 284
          break;
        }
      } else {
#line 284
        break;
      }
    } else {
#line 284
      break;
    }
#line 285
    cp ++;
  }
#line 286
  *cpp = cp;
#line 287
  break;
  default: 
#line 289
  fatal("key_read: bad key type: %d", ret->type);
#line 290
  break;
  }
#line 292
  return (bits);
}
}
#line 294 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  unsigned int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  unsigned char *uu ;
  void *tmp___2 ;

  {
#line 297
  success = 0;
#line 298
  bits = 0U;
#line 300
  if (key->type == 0) {
#line 300
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 302
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 302
      bits = (unsigned int )tmp;
#line 303
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 304
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 304
      if (tmp___0) {
#line 304
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 304
        if (tmp___1) {
#line 306
          success = 1;
        } else {
#line 308
          error("key_write: failed for RSA key");
        }
      } else {
#line 308
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 310
    if (key->type == 1) {
#line 310
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
#line 313
        dsa_make_key_blob(key, & blob, (unsigned int *)(& len));
#line 314
        tmp___2 = xmalloc((unsigned int )(2 * len));
#line 314
        uu = (unsigned char *)tmp___2;
#line 315
        n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 316
        if (n___0 > 0) {
#line 317
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s", "ssh-dss",
                  uu);
#line 318
          success = 1;
        }
#line 320
        xfree((void *)blob);
#line 321
        xfree((void *)uu);
      }
    }
  }
#line 323
  return (success);
}
}
#line 325 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 328
  switch (k->type) {
  case 0: 
#line 330
  return ((char *)"RSA");
#line 331
  break;
  case 1: 
#line 333
  return ((char *)"DSA");
#line 334
  break;
  }
#line 336
  return ((char *)"unknown");
}
}
#line 1 "kex.o"
#line 454 "/usr/include/openssl/bn.h"
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 459
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 91 "packet.h"
void packet_put_raw(char const   *buf___1 , unsigned int len ) ;
#line 125
unsigned int packet_get_char(void) ;
#line 136
char *packet_get_raw(int *length_ptr ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 93 "kex.h"
Buffer *kex_init(char **myproposal___0 ) ;
#line 94
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) ;
#line 98
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) ;
#line 101
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) ;
#line 103
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 104
DH *dh_new_group1(void) ;
#line 106
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 55 "kex.c"
Buffer *kex_init(char **myproposal___0 ) 
{ int first_kex_packet_follows ;
  unsigned char cookie[16] ;
  u_int32_t rand___0 ;
  int i ;
  Buffer *ki ;
  void *tmp ;

  {
#line 58
  first_kex_packet_follows = 0;
#line 60
  rand___0 = (u_int32_t )0;
#line 62
  tmp = xmalloc(sizeof(*ki));
#line 62
  ki = (Buffer *)tmp;
#line 63
  i = 0;
#line 63
  while (i < 16) {
#line 64
    if (i % 4 == 0) {
#line 65
      rand___0 = arc4random();
    }
#line 66
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 67
    rand___0 >>= 8;
#line 63
    i ++;
  }
#line 69
  buffer_init(ki);
#line 70
  buffer_append(ki, (char const   *)((char *)(cookie)), sizeof(cookie));
#line 71
  i = 0;
#line 71
  while (i < 10) {
#line 72
    buffer_put_cstring(ki, (char const   *)*(myproposal___0 + i));
#line 71
    i ++;
  }
#line 73
  buffer_put_char(ki, first_kex_packet_follows);
#line 74
  buffer_put_int(ki, 0U);
#line 75
  return (ki);
}
}
#line 79 "kex.c"
void kex_exchange_kexinit(Buffer *my_kexinit , Buffer *peer_kexint , char **peer_proposal ) 
{ int i ;
  char *ptr ;
  int plen ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 88
  debug("send KEXINIT");
#line 89
  packet_start(20);
#line 90
  tmp = buffer_len(my_kexinit);
#line 90
  tmp___0 = buffer_ptr(my_kexinit);
#line 90
  packet_put_raw((char const   *)tmp___0, tmp);
#line 91
  packet_send();
#line 92
  packet_write_wait();
#line 93
  debug("done");
#line 99
  debug("wait KEXINIT");
#line 100
  packet_read_expect(& plen, 20);
#line 101
  ptr = packet_get_raw(& plen);
#line 102
  buffer_append(peer_kexint, (char const   *)ptr, (unsigned int )plen);
#line 106
  i = 0;
#line 106
  while (i < 16) {
#line 107
    packet_get_char();
#line 106
    i ++;
  }
#line 109
  i = 0;
#line 109
  while (i < 10) {
#line 110
    *(peer_proposal + i) = packet_get_string((unsigned int *)((void *)0));
#line 111
    debug("got kexinit: %s", *(peer_proposal + i));
#line 109
    i ++;
  }
#line 114
  tmp___1 = packet_get_char();
#line 114
  i = (int )tmp___1;
#line 115
  debug("first kex follow: %d ", i);
#line 116
  tmp___2 = packet_get_int();
#line 116
  i = (int )tmp___2;
#line 117
  debug("reserved: %d ", i);
#line 118
  while (1) {
#line 118
    tmp___3 = packet_remaining();
#line 118
    _len = tmp___3;
#line 118
    if (_len > 0) {
#line 118
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 118);
#line 118
      packet_disconnect("Packet integrity error.");
    }
#line 118
    break;
  }
#line 119
  debug("done");
#line 120
  return;
}
}
#line 124 "kex.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 128
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 128
  n___0 = tmp;
#line 129
  bits_set = 0;
#line 132
  if ((dh->g)->top == 1) {
#line 132
    if (*((dh->g)->d + 0) == 2UL) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 132
    if (0) {
      _L: /* CIL Label */ 
#line 132
      if (! (! (dh->g)->neg)) {
#line 133
        log("invalid DH base != 2");
#line 134
        return (0);
      }
    } else {
#line 133
      log("invalid DH base != 2");
#line 134
      return (0);
    }
  }
#line 136
  if (dh_pub->neg) {
#line 137
    log("invalid public DH value: negativ");
#line 138
    return (0);
  }
#line 140
  i = 0;
#line 140
  while (i <= n___0) {
#line 141
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 141
    if (tmp___0) {
#line 142
      bits_set ++;
    }
#line 140
    i ++;
  }
#line 143
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 143
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 146
  if (bits_set > 1) {
#line 146
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 146
    if (tmp___2 == -1) {
#line 147
      return (1);
    }
  }
#line 148
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 148
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 149
  return (0);
}
}
#line 155 "kex.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 152 "kex.c"
DH *dh_new_group1(void) 
{ DH *dh ;
  int ret ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 163
  tries = 0;
#line 164
  dh = DH_new();
#line 165
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 166
    fatal("DH_new");
  }
#line 167
  ret = BN_hex2bn(& dh->p, (char const   *)group1);
#line 168
  if (ret < 0) {
#line 169
    fatal("BN_hex2bn");
  }
#line 170
  dh->g = BN_new();
#line 171
  if ((unsigned int )dh->g == (unsigned int )((void *)0)) {
#line 172
    fatal("DH_new g");
  }
#line 173
  BN_set_word(dh->g, 2UL);
#line 174
  while (1) {
#line 175
    tmp = DH_generate_key(dh);
#line 175
    if (tmp == 0) {
#line 176
      fatal("DH_generate_key");
    }
#line 177
    tmp___0 = tries;
#line 177
    tries ++;
#line 177
    if (tmp___0 > 10) {
#line 178
      fatal("dh_new_group1: too many bad keys: giving up");
    }
#line 174
    tmp___1 = dh_pub_is_valid(dh, dh->pub_key);
#line 174
    if (tmp___1) {
#line 174
      break;
    }
  }
#line 180
  return (dh);
}
}
#line 183 "kex.c"
void dump_digest(unsigned char *digest___0 , int len ) 
{ int i ;

  {
#line 187
  i = 0;
#line 187
  while (i < len) {
#line 188
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(digest___0 + i));
#line 189
    if (i % 2 != 0) {
#line 190
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
    }
#line 187
    i ++;
  }
#line 192
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 193
  return;
}
}
#line 207 "kex.c"
static unsigned char digest[64]  ;
#line 195 "kex.c"
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 208
  tmp = EVP_sha1();
#line 208
  evp_md = (EVP_MD *)tmp;
#line 211
  buffer_init(& b);
#line 212
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 212
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 213
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 213
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 216
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 217
  buffer_put_char(& b, 20);
#line 218
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 219
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 220
  buffer_put_char(& b, 20);
#line 221
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 223
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 224
  buffer_put_bignum2(& b, client_dh_pub);
#line 225
  buffer_put_bignum2(& b, server_dh_pub);
#line 226
  buffer_put_bignum2(& b, shared_secret);
#line 232
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 233
  tmp___2 = buffer_len(& b);
#line 233
  tmp___3 = buffer_ptr(& b);
#line 233
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 234
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 236
  buffer_free(& b);
#line 241
  return (digest);
}
}
#line 244 "kex.c"
unsigned char *derive_key(int id , int need , unsigned char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  unsigned char *digest___0 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;

  {
#line 248
  tmp = EVP_sha1();
#line 248
  evp_md = (EVP_MD *)tmp;
#line 250
  c = (char )id;
#line 252
  mdsz = evp_md->md_size;
#line 253
  tmp___0 = xmalloc((unsigned int )((((need + mdsz) - 1) / mdsz) * mdsz));
#line 253
  digest___0 = (unsigned char *)tmp___0;
#line 255
  buffer_init(& b);
#line 256
  buffer_put_bignum2(& b, shared_secret);
#line 258
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 259
  tmp___1 = buffer_len(& b);
#line 259
  tmp___2 = buffer_ptr(& b);
#line 259
  EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
#line 260
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 261
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 262
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 263
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 266
  have = mdsz;
#line 266
  while (need > have) {
#line 267
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 268
    tmp___3 = buffer_len(& b);
#line 268
    tmp___4 = buffer_ptr(& b);
#line 268
    EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
#line 269
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 270
    EVP_DigestUpdate(& md, (void const   *)digest___0, (unsigned int )have);
#line 271
    EVP_DigestFinal(& md, digest___0 + have, (unsigned int *)((void *)0));
#line 266
    have += mdsz;
  }
#line 273
  buffer_free(& b);
#line 278
  return (digest___0);
}
}
#line 286 "kex.c"
char *get_match(char *client , char *server ) 
{ char *sproposals[20] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;

  {
#line 293
  cp = xstrdup((char const   *)client);
#line 293
  c = cp;
#line 294
  sp = xstrdup((char const   *)server);
#line 294
  s = sp;
#line 296
  tmp___14 = __strsep_g(& sp, ",");
#line 296
  p = tmp___14;
#line 296
  i = 0;
#line 296
  while (1) {
#line 296
    if (p) {
#line 296
      if (! ((int )*p != 0)) {
#line 296
        break;
      }
    } else {
#line 296
      break;
    }
#line 298
    if (i < 20) {
#line 299
      sproposals[i] = p;
    } else {
#line 301
      break;
    }
#line 297
    tmp___30 = __strsep_g(& sp, ",");
#line 297
    p = tmp___30;
#line 297
    i ++;
  }
#line 303
  nproposals = i;
#line 305
  tmp___46 = __strsep_g(& cp, ",");
#line 305
  p = tmp___46;
#line 305
  i = 0;
#line 305
  while (1) {
#line 305
    if (p) {
#line 305
      if (! ((int )*p != 0)) {
#line 305
        break;
      }
    } else {
#line 305
      break;
    }
#line 307
    j = 0;
#line 307
    while (j < nproposals) {
#line 308
      if (0) {
#line 308
        __s1_len = strlen((char const   *)p);
#line 308
        __s2_len = strlen((char const   *)sproposals[j]);
#line 308
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 308
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 308
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 308
              tmp___72 = 1;
            } else {
#line 308
              if (__s2_len >= 4U) {
#line 308
                tmp___72 = 1;
              } else {
#line 308
                tmp___72 = 0;
              }
            }
          } else {
#line 308
            tmp___72 = 0;
          }
        }
#line 308
        if (tmp___72) {
#line 308
          tmp___68 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 308
          tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 308
          tmp___68 = tmp___71;
        }
      } else {
#line 308
        tmp___71 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 308
        tmp___68 = tmp___71;
      }
#line 308
      if (tmp___68 == 0) {
#line 309
        ret = xstrdup((char const   *)p);
#line 310
        xfree((void *)c);
#line 311
        xfree((void *)s);
#line 312
        return (ret);
      }
#line 307
      j ++;
    }
#line 306
    tmp___62 = __strsep_g(& cp, ",");
#line 306
    p = tmp___62;
#line 306
    i ++;
  }
#line 316
  xfree((void *)c);
#line 317
  xfree((void *)s);
#line 318
  return ((char *)((void *)0));
}
}
#line 320 "kex.c"
void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 323
  tmp = get_match(client, server);
#line 323
  name = tmp;
#line 324
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 325
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 326
  enc->type = cipher_number((char const   *)name);
#line 328
  switch (enc->type) {
  case 9: 
#line 330
  enc->key_len = 24;
#line 331
  enc->iv_len = 8;
#line 332
  enc->block_size = 8;
#line 333
  break;
  case 8: 
  case 11: 
#line 336
  enc->key_len = 16;
#line 337
  enc->iv_len = 8;
#line 338
  enc->block_size = 8;
#line 339
  break;
  case 10: 
#line 341
  enc->key_len = 16;
#line 342
  enc->iv_len = 0;
#line 343
  enc->block_size = 8;
#line 344
  break;
  default: 
#line 346
  fatal("unsupported cipher %s", name);
  }
#line 348
  enc->name = name;
#line 349
  enc->enabled = 0;
#line 350
  enc->iv = (unsigned char *)((void *)0);
#line 351
  enc->key = (unsigned char *)((void *)0);
#line 352
  return;
}
}
#line 353 "kex.c"
void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  EVP_MD const   *tmp___0 ;
  EVP_MD const   *tmp___1 ;
  EVP_MD const   *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 356
  tmp = get_match(client, server);
#line 356
  name = tmp;
#line 357
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 358
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 359
  if (0) {
#line 359
    __s1_len___1 = strlen((char const   *)name);
#line 359
    __s2_len___1 = strlen("hmac-md5");
#line 359
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 359
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 359
        if (! ((unsigned int )((void const   *)("hmac-md5" + 1)) - (unsigned int )((void const   *)"hmac-md5") == 1U)) {
#line 359
          tmp___32 = 1;
        } else {
#line 359
          if (__s2_len___1 >= 4U) {
#line 359
            tmp___32 = 1;
          } else {
#line 359
            tmp___32 = 0;
          }
        }
      } else {
#line 359
        tmp___32 = 0;
      }
    }
#line 359
    if (tmp___32) {
#line 359
      tmp___28 = __builtin_strcmp((char const   *)name, "hmac-md5");
    } else {
#line 359
      tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 359
      tmp___28 = tmp___31;
    }
  } else {
#line 359
    tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 359
    tmp___28 = tmp___31;
  }
#line 359
  if (tmp___28 == 0) {
#line 360
    tmp___0 = EVP_md5();
#line 360
    mac->md = (EVP_MD *)tmp___0;
  } else {
#line 361
    if (0) {
#line 361
      __s1_len___0 = strlen((char const   *)name);
#line 361
      __s2_len___0 = strlen("hmac-sha1");
#line 361
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 361
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 361
          if (! ((unsigned int )((void const   *)("hmac-sha1" + 1)) - (unsigned int )((void const   *)"hmac-sha1") == 1U)) {
#line 361
            tmp___22 = 1;
          } else {
#line 361
            if (__s2_len___0 >= 4U) {
#line 361
              tmp___22 = 1;
            } else {
#line 361
              tmp___22 = 0;
            }
          }
        } else {
#line 361
          tmp___22 = 0;
        }
      }
#line 361
      if (tmp___22) {
#line 361
        tmp___18 = __builtin_strcmp((char const   *)name, "hmac-sha1");
      } else {
#line 361
        tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 361
        tmp___18 = tmp___21;
      }
    } else {
#line 361
      tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 361
      tmp___18 = tmp___21;
    }
#line 361
    if (tmp___18 == 0) {
#line 362
      tmp___1 = EVP_sha1();
#line 362
      mac->md = (EVP_MD *)tmp___1;
    } else {
#line 363
      if (0) {
#line 363
        __s1_len = strlen((char const   *)name);
#line 363
        __s2_len = strlen("hmac-ripemd160@openssh.com");
#line 363
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 363
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 363
            if (! ((unsigned int )((void const   *)("hmac-ripemd160@openssh.com" + 1)) - (unsigned int )((void const   *)"hmac-ripemd160@openssh.com") == 1U)) {
#line 363
              tmp___12 = 1;
            } else {
#line 363
              if (__s2_len >= 4U) {
#line 363
                tmp___12 = 1;
              } else {
#line 363
                tmp___12 = 0;
              }
            }
          } else {
#line 363
            tmp___12 = 0;
          }
        }
#line 363
        if (tmp___12) {
#line 363
          tmp___8 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
        } else {
#line 363
          tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 363
          tmp___8 = tmp___11;
        }
      } else {
#line 363
        tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 363
        tmp___8 = tmp___11;
      }
#line 363
      if (tmp___8 == 0) {
#line 364
        tmp___2 = EVP_ripemd160();
#line 364
        mac->md = (EVP_MD *)tmp___2;
      } else {
#line 366
        fatal("unsupported mac %s", name);
      }
    }
  }
#line 368
  mac->name = name;
#line 369
  mac->mac_len = (mac->md)->md_size;
#line 370
  if (datafellows & 4) {
#line 370
    mac->key_len = 16;
  } else {
#line 370
    mac->key_len = mac->mac_len;
  }
#line 371
  mac->key = (unsigned char *)((void *)0);
#line 372
  mac->enabled = 0;
#line 373
  return;
}
}
#line 374 "kex.c"
void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 377
  tmp = get_match(client, server);
#line 377
  name = tmp;
#line 378
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 379
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 380
  if (0) {
#line 380
    __s1_len___0 = strlen((char const   *)name);
#line 380
    __s2_len___0 = strlen("zlib");
#line 380
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 380
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 380
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 380
          tmp___19 = 1;
        } else {
#line 380
          if (__s2_len___0 >= 4U) {
#line 380
            tmp___19 = 1;
          } else {
#line 380
            tmp___19 = 0;
          }
        }
      } else {
#line 380
        tmp___19 = 0;
      }
    }
#line 380
    if (tmp___19) {
#line 380
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 380
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 380
      tmp___15 = tmp___18;
    }
  } else {
#line 380
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 380
    tmp___15 = tmp___18;
  }
#line 380
  if (tmp___15 == 0) {
#line 381
    comp->type = 1;
  } else {
#line 382
    if (0) {
#line 382
      __s1_len = strlen((char const   *)name);
#line 382
      __s2_len = strlen("none");
#line 382
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 382
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 382
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 382
            tmp___9 = 1;
          } else {
#line 382
            if (__s2_len >= 4U) {
#line 382
              tmp___9 = 1;
            } else {
#line 382
              tmp___9 = 0;
            }
          }
        } else {
#line 382
          tmp___9 = 0;
        }
      }
#line 382
      if (tmp___9) {
#line 382
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 382
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 382
        tmp___5 = tmp___8;
      }
    } else {
#line 382
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 382
      tmp___5 = tmp___8;
    }
#line 382
    if (tmp___5 == 0) {
#line 383
      comp->type = 0;
    } else {
#line 385
      fatal("unsupported comp %s", name);
    }
  }
#line 387
  comp->name = name;
#line 388
  return;
}
}
#line 389 "kex.c"
void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 392
  k->name = get_match(client, server);
#line 393
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 394
    fatal("no kex alg");
  }
#line 395
  if (0) {
#line 395
    __s1_len = strlen((char const   *)k->name);
#line 395
    __s2_len = strlen("diffie-hellman-group1-sha1");
#line 395
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___0;
    } else {
#line 395
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 395
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 395
          tmp___8 = 1;
        } else {
#line 395
          if (__s2_len >= 4U) {
#line 395
            tmp___8 = 1;
          } else {
#line 395
            tmp___8 = 0;
          }
        }
      } else {
#line 395
        tmp___8 = 0;
      }
    }
#line 395
    if (tmp___8) {
#line 395
      tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 395
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 395
      tmp___4 = tmp___7;
    }
  } else {
#line 395
    tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 395
    tmp___4 = tmp___7;
  }
#line 395
  if (tmp___4 != 0) {
#line 396
    fatal("bad kex alg %s", k->name);
  }
#line 397
  return;
}
}
#line 398 "kex.c"
void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 401
  k->hostkeyalg = get_match(client, server);
#line 402
  if ((unsigned int )k->hostkeyalg == (unsigned int )((void *)0)) {
#line 403
    fatal("no hostkey alg");
  }
#line 404
  if (0) {
#line 404
    __s1_len = strlen((char const   *)k->hostkeyalg);
#line 404
    __s2_len = strlen("ssh-dss");
#line 404
    if (! ((unsigned int )((void const   *)(k->hostkeyalg + 1)) - (unsigned int )((void const   *)k->hostkeyalg) == 1U)) {
      goto _L___0;
    } else {
#line 404
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 404
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 404
          tmp___8 = 1;
        } else {
#line 404
          if (__s2_len >= 4U) {
#line 404
            tmp___8 = 1;
          } else {
#line 404
            tmp___8 = 0;
          }
        }
      } else {
#line 404
        tmp___8 = 0;
      }
    }
#line 404
    if (tmp___8) {
#line 404
      tmp___4 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
    } else {
#line 404
      tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 404
      tmp___4 = tmp___7;
    }
  } else {
#line 404
    tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 404
    tmp___4 = tmp___7;
  }
#line 404
  if (tmp___4 != 0) {
#line 405
    fatal("bad hostkey alg %s", k->hostkeyalg);
  }
#line 406
  return;
}
}
#line 408 "kex.c"
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) 
{ int mode ;
  int ctos ;
  int need ;
  Kex *k ;
  void *tmp ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 416
  tmp = xmalloc(sizeof(*k));
#line 416
  k = (Kex *)tmp;
#line 417
  memset((void *)k, 0, sizeof(*k));
#line 418
  k->server = server;
#line 420
  mode = 0;
#line 420
  while (mode < 2) {
#line 422
    if (! k->server) {
#line 422
      if (mode == 1) {
#line 422
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 422
      if (k->server) {
#line 422
        if (mode == 0) {
#line 422
          tmp___0 = 1;
        } else {
#line 422
          tmp___0 = 0;
        }
      } else {
#line 422
        tmp___0 = 0;
      }
    }
#line 422
    ctos = tmp___0;
#line 423
    if (ctos) {
#line 423
      nenc = 2;
    } else {
#line 423
      nenc = 3;
    }
#line 424
    if (ctos) {
#line 424
      nmac = 4;
    } else {
#line 424
      nmac = 5;
    }
#line 425
    if (ctos) {
#line 425
      ncomp = 6;
    } else {
#line 425
      ncomp = 7;
    }
#line 426
    choose_enc(& k->enc[mode], *(cprop + nenc), *(sprop + nenc));
#line 427
    choose_mac(& k->mac[mode], *(cprop + nmac), *(sprop + nmac));
#line 428
    choose_comp(& k->comp[mode], *(cprop + ncomp), *(sprop + ncomp));
#line 429
    if (ctos) {
#line 429
      tmp___1 = "client->server";
    } else {
#line 429
      tmp___1 = "server->client";
    }
#line 429
    debug("kex: %s %s %s %s", tmp___1, k->enc[mode].name, k->mac[mode].name, k->comp[mode].name);
#line 420
    mode ++;
  }
#line 435
  choose_kex(k, *(cprop + 0), *(sprop + 0));
#line 436
  choose_hostkeyalg(k, *(cprop + 1), *(sprop + 1));
#line 438
  need = 0;
#line 439
  mode = 0;
#line 439
  while (mode < 2) {
#line 440
    if (need < k->enc[mode].key_len) {
#line 441
      need = k->enc[mode].key_len;
    }
#line 442
    if (need < k->enc[mode].iv_len) {
#line 443
      need = k->enc[mode].iv_len;
    }
#line 444
    if (need < k->mac[mode].key_len) {
#line 445
      need = k->mac[mode].key_len;
    }
#line 439
    mode ++;
  }
#line 448
  k->we_need = need;
#line 449
  return (k);
}
}
#line 452 "kex.c"
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) 
{ int i ;
  int mode ;
  int ctos ;
  unsigned char *keys[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 460
  i = 0;
#line 460
  while (i < 6) {
#line 461
    keys[i] = derive_key(65 + i, k->we_need, hash, shared_secret);
#line 460
    i ++;
  }
#line 463
  mode = 0;
#line 463
  while (mode < 2) {
#line 464
    if (! k->server) {
#line 464
      if (mode == 1) {
#line 464
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 464
      if (k->server) {
#line 464
        if (mode == 0) {
#line 464
          tmp = 1;
        } else {
#line 464
          tmp = 0;
        }
      } else {
#line 464
        tmp = 0;
      }
    }
#line 464
    ctos = tmp;
#line 465
    if (ctos) {
#line 465
      tmp___0 = 0;
    } else {
#line 465
      tmp___0 = 1;
    }
#line 465
    k->enc[mode].iv = keys[tmp___0];
#line 466
    if (ctos) {
#line 466
      tmp___1 = 2;
    } else {
#line 466
      tmp___1 = 3;
    }
#line 466
    k->enc[mode].key = keys[tmp___1];
#line 467
    if (ctos) {
#line 467
      tmp___2 = 4;
    } else {
#line 467
      tmp___2 = 5;
    }
#line 467
    k->mac[mode].key = keys[tmp___2];
#line 463
    mode ++;
  }
#line 469
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 455 "ssh.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 458
SyslogFacility log_facility_number(char *name ) ;
#line 459
LogLevel log_level_number(char *name ) ;
#line 479
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 13 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 17
  __builtin_va_start(args, fmt);
#line 18
  do_log(1, fmt, args);
#line 19
  __builtin_va_end(args);
#line 20
  fatal_cleanup();
#line 21
  return;
}
}
#line 25 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 29
  __builtin_va_start(args, fmt);
#line 30
  do_log(2, fmt, args);
#line 31
  __builtin_va_end(args);
#line 32
  return;
}
}
#line 36 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 40
  __builtin_va_start(args, fmt);
#line 41
  do_log(3, fmt, args);
#line 42
  __builtin_va_end(args);
#line 43
  return;
}
}
#line 47 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 51
  __builtin_va_start(args, fmt);
#line 52
  do_log(4, fmt, args);
#line 53
  __builtin_va_end(args);
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(5, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 75 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 79 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 84
  tmp = xmalloc(sizeof(*cu));
#line 84
  cu = (struct fatal_cleanup *)tmp;
#line 85
  cu->proc = proc;
#line 86
  cu->context = context;
#line 87
  cu->next = fatal_cleanups;
#line 88
  fatal_cleanups = cu;
#line 89
  return;
}
}
#line 93 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 98
  cup = & fatal_cleanups;
#line 98
  while (*cup) {
#line 99
    cu = *cup;
#line 100
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 100
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 101
        *cup = cu->next;
#line 102
        xfree((void *)cu);
#line 103
        return;
      }
    }
#line 98
    cup = & cu->next;
  }
#line 106
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 108
  return;
}
}
#line 115 "log.c"
static int called  =    0;
#line 111 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 117
  if (called) {
#line 118
    exit(255);
  }
#line 119
  called = 1;
#line 121
  cu = fatal_cleanups;
#line 121
  while (cu) {
#line 122
    next_cu = cu->next;
#line 123
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 125
    (*(cu->proc))(cu->context);
#line 121
    cu = next_cu;
  }
#line 127
  exit(255);
}
}
#line 132 "log.c"
static struct __anonstruct_log_facilities_74 log_facilities[12]  = 
#line 132
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 150 "log.c"
static struct __anonstruct_log_levels_75 log_levels[7]  = {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 164 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 168
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 169
    i = 0;
#line 169
    while (log_facilities[i].name) {
#line 170
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 170
      if (tmp == 0) {
#line 171
        return (log_facilities[i].val);
      }
#line 169
      i ++;
    }
  }
#line 172
  return ((enum __anonenum_SyslogFacility_72 )-1);
}
}
#line 175 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 179
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 180
    i = 0;
#line 180
    while (log_levels[i].name) {
#line 181
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 181
      if (tmp == 0) {
#line 182
        return (log_levels[i].val);
      }
#line 180
      i ++;
    }
  }
#line 183
  return ((enum __anonenum_LogLevel_73 )-1);
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 26 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 29
  while (1) {
#line 31
    if (! *pattern) {
#line 32
      return (! *s);
    }
#line 34
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 49
          while (*s) {
#line 50
            if ((int const   )*s == (int const   )*pattern) {
#line 50
              tmp = match_pattern(s + 1, pattern + 1);
#line 50
              if (tmp) {
#line 52
                return (1);
              }
            }
#line 49
            s ++;
          }
#line 54
          return (0);
        }
      }
#line 60
      while (*s) {
#line 61
        tmp___0 = match_pattern(s, pattern);
#line 61
        if (tmp___0) {
#line 62
          return (1);
        }
#line 60
        s ++;
      }
#line 64
      return (0);
    }
#line 70
    if (! *s) {
#line 71
      return (0);
    }
#line 74
    if ((int const   )*pattern != 63) {
#line 74
      if ((int const   )*pattern != (int const   )*s) {
#line 75
        return (0);
      }
    }
#line 78
    s ++;
#line 79
    pattern ++;
  }
}
}
#line 91 "match.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 99
  got_positive = 0;
#line 100
  i = 0U;
#line 100
  while (i < len) {
#line 102
    if ((int const   )*(pattern + i) == 33) {
#line 103
      negated = 1;
#line 104
      i ++;
    } else {
#line 106
      negated = 0;
    }
#line 112
    subi = 0U;
#line 112
    while (1) {
#line 112
      if (i < len) {
#line 112
        if (subi < sizeof(sub) - 1U) {
#line 112
          if (! ((int const   )*(pattern + i) != 44)) {
#line 112
            break;
          }
        } else {
#line 112
          break;
        }
      } else {
#line 112
        break;
      }
#line 115
      tmp___6 = __ctype_b_loc();
#line 115
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 115
        if (sizeof(*(pattern + i)) > 1U) {
#line 115
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 115
          tmp___5 = __ctype_tolower_loc();
#line 115
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 115
        sub[subi] = (char )__res___0;
      } else {
#line 115
        sub[subi] = (char )*(pattern + i);
      }
#line 112
      subi ++;
#line 112
      i ++;
    }
#line 117
    if (subi >= sizeof(sub) - 1U) {
#line 118
      return (0);
    }
#line 121
    if (i < len) {
#line 121
      if ((int const   )*(pattern + i) == 44) {
#line 122
        i ++;
      }
    }
#line 125
    sub[subi] = (char )'\000';
#line 128
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 128
    if (tmp___7) {
#line 129
      if (negated) {
#line 130
        return (-1);
      } else {
#line 132
        got_positive = 1;
      }
    }
  }
#line 140
  return (got_positive);
}
}
#line 1 "mpaux.o"
#line 26 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ unsigned int host_key_bytes ;
  int tmp ;
  unsigned int session_key_bytes ;
  int tmp___0 ;
  unsigned int bytes ;
  unsigned char *buf___1 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (unsigned int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (unsigned int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___1 = (unsigned char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___1);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___1 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___1, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___1, 0, bytes);
#line 45
  xfree((void *)buf___1);
#line 46
  return;
}
}
#line 1 "nchan.o"
#line 48 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 49 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 50 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 52 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 53 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 54 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 58
static void chan_send_ieof1(Channel *c ) ;
#line 59
static void chan_send_oclose1(Channel *c ) ;
#line 60
static void chan_send_close2(Channel *c ) ;
#line 61
static void chan_send_eof2(Channel *c ) ;
#line 64 "nchan.c"
chan_event_fn *chan_delete_if_full_closed  =    (chan_event_fn *)((void *)0);
#line 67
static void chan_shutdown_write(Channel *c ) ;
#line 68
static void chan_shutdown_read(Channel *c ) ;
#line 74 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 77
  debug("channel %d: rcvd oclose", c->self);
#line 78
  switch (c->istate) {
  case 4: 
#line 80
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 81
  c->istate = 8;
#line 82
  break;
  case 1: 
#line 84
  debug("channel %d: input open -> closed", c->self);
#line 85
  chan_shutdown_read(c);
#line 86
  chan_send_ieof1(c);
#line 87
  c->istate = 8;
#line 88
  break;
  case 2: 
#line 91
  log("channel %d: input drain -> closed", c->self);
#line 92
  chan_send_ieof1(c);
#line 93
  c->istate = 8;
#line 94
  break;
  default: 
#line 96
  error("channel %d: protocol error: chan_rcvd_oclose for istate %d", c->self, c->istate);
#line 98
  return;
  }
#line 100
  return;
}
}
#line 101 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ unsigned int tmp ;

  {
#line 104
  debug("channel %d: read failed", c->self);
#line 105
  switch (c->istate) {
  case 1: 
#line 107
  debug("channel %d: input open -> drain", c->self);
#line 108
  chan_shutdown_read(c);
#line 109
  c->istate = 2;
#line 110
  tmp = buffer_len(& c->input);
#line 110
  if (tmp == 0U) {
#line 111
    debug("channel %d: input: no drain shortcut", c->self);
#line 112
    (*chan_ibuf_empty)(c);
  }
#line 114
  break;
  default: 
#line 116
  error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
        c->self, c->istate);
#line 118
  break;
  }
#line 120
  return;
}
}
#line 121 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 124
  debug("channel %d: ibuf empty", c->self);
#line 125
  tmp = buffer_len(& c->input);
#line 125
  if (tmp) {
#line 126
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 128
    return;
  }
#line 130
  switch (c->istate) {
  case 2: 
#line 132
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 133
  chan_send_ieof1(c);
#line 134
  c->istate = 4;
#line 135
  break;
  default: 
#line 137
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 139
  break;
  }
#line 141
  return;
}
}
#line 142 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 145
  debug("channel %d: rcvd ieof", c->self);
#line 146
  if (c->type != 4) {
#line 147
    debug("channel %d: non-open", c->self);
#line 148
    if (c->istate == 1) {
#line 149
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 150
      chan_shutdown_read(c);
#line 151
      chan_send_ieof1(c);
#line 152
      c->istate = 4;
    } else {
#line 154
      error("channel %d: istate %d != open", c->self, c->istate);
    }
#line 156
    if (c->ostate == 16) {
#line 157
      debug("channel %d: non-open: output open -> closed", c->self);
#line 158
      chan_send_oclose1(c);
#line 159
      c->ostate = 128;
    } else {
#line 161
      error("channel %d: ostate %d != open", c->self, c->ostate);
    }
#line 163
    return;
  }
#line 165
  switch (c->ostate) {
  case 16: 
#line 167
  debug("channel %d: output open -> drain", c->self);
#line 168
  c->ostate = 32;
#line 169
  break;
  case 64: 
#line 171
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 172
  c->ostate = 128;
#line 173
  break;
  default: 
#line 175
  error("channel %d: protocol error: chan_rcvd_ieof for ostate %d", c->self, c->ostate);
#line 177
  break;
  }
#line 179
  return;
}
}
#line 180 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 183
  debug("channel %d: write failed", c->self);
#line 184
  switch (c->ostate) {
  case 16: 
#line 186
  debug("channel %d: output open -> wait_ieof", c->self);
#line 187
  chan_send_oclose1(c);
#line 188
  c->ostate = 64;
#line 189
  break;
  case 32: 
#line 191
  debug("channel %d: output wait_drain -> closed", c->self);
#line 192
  chan_send_oclose1(c);
#line 193
  c->ostate = 128;
#line 194
  break;
  default: 
#line 196
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 198
  break;
  }
#line 200
  return;
}
}
#line 201 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 204
  debug("channel %d: obuf empty", c->self);
#line 205
  tmp = buffer_len(& c->output);
#line 205
  if (tmp) {
#line 206
    error("channel %d: internal error: chan_obuf_empty for non empty buffer", c->self);
#line 208
    return;
  }
#line 210
  switch (c->ostate) {
  case 32: 
#line 212
  debug("channel %d: output drain -> closed", c->self);
#line 213
  chan_send_oclose1(c);
#line 214
  c->ostate = 128;
#line 215
  break;
  default: 
#line 217
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 219
  break;
  }
#line 221
  return;
}
}
#line 222 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 225
  debug("channel %d: send ieof", c->self);
#line 226
  switch (c->istate) {
  case 1: 
  case 2: 
#line 229
  packet_start(24);
#line 230
  packet_put_int((unsigned int )c->remote_id);
#line 231
  packet_send();
#line 232
  break;
  default: 
#line 234
  error("channel %d: internal error: cannot send ieof for istate %d", c->self, c->istate);
#line 236
  break;
  }
#line 238
  return;
}
}
#line 239 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 242
  debug("channel %d: send oclose", c->self);
#line 243
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 246
  chan_shutdown_write(c);
#line 247
  tmp = buffer_len(& c->output);
#line 247
  buffer_consume(& c->output, tmp);
#line 248
  packet_start(25);
#line 249
  packet_put_int((unsigned int )c->remote_id);
#line 250
  packet_send();
#line 251
  break;
  default: 
#line 253
  error("channel %d: internal error: cannot send oclose for ostate %d", c->self, c->ostate);
#line 255
  break;
  }
#line 257
  return;
}
}
#line 258 "nchan.c"
static void chan_delete_if_full_closed1(Channel *c ) 
{ 

  {
#line 261
  if (c->istate == 8) {
#line 261
    if (c->ostate == 128) {
#line 262
      debug("channel %d: full closed", c->self);
#line 263
      channel_free(c->self);
    }
  }
#line 265
  return;
}
}
#line 270 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 273
  debug("channel %d: rcvd close", c->self);
#line 274
  if (c->flags & 2) {
#line 275
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 276
  c->flags |= 2;
#line 277
  if (c->type == 10) {
#line 279
    c->ostate = 128;
#line 280
    c->istate = 8;
#line 281
    return;
  }
#line 283
  switch (c->ostate) {
  case 16: 
#line 286
  debug("channel %d: output open -> drain", c->self);
#line 287
  c->ostate = 32;
#line 288
  break;
  }
#line 290
  switch (c->istate) {
  case 1: 
#line 292
  debug("channel %d: input open -> closed", c->self);
#line 293
  chan_shutdown_read(c);
#line 294
  break;
  case 2: 
#line 296
  debug("channel %d: input drain -> closed", c->self);
#line 297
  chan_send_eof2(c);
#line 298
  break;
  }
#line 300
  c->istate = 8;
#line 301
  return;
}
}
#line 302 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 305
  debug("channel %d: ibuf empty", c->self);
#line 306
  tmp = buffer_len(& c->input);
#line 306
  if (tmp) {
#line 307
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 309
    return;
  }
#line 311
  switch (c->istate) {
  case 2: 
#line 313
  debug("channel %d: input drain -> closed", c->self);
#line 314
  if (! (c->flags & 1)) {
#line 315
    chan_send_eof2(c);
  }
#line 316
  c->istate = 8;
#line 317
  break;
  default: 
#line 319
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 321
  break;
  }
#line 323
  return;
}
}
#line 324 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 327
  debug("channel %d: rcvd eof", c->self);
#line 328
  if (c->ostate == 16) {
#line 329
    debug("channel %d: output open -> drain", c->self);
#line 330
    c->ostate = 32;
  }
#line 332
  return;
}
}
#line 333 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 336
  debug("channel %d: write failed", c->self);
#line 337
  switch (c->ostate) {
  case 16: 
#line 339
  debug("channel %d: output open -> closed", c->self);
#line 340
  chan_shutdown_write(c);
#line 341
  c->ostate = 128;
#line 342
  break;
  case 32: 
#line 344
  debug("channel %d: output drain -> closed", c->self);
#line 345
  chan_shutdown_write(c);
#line 346
  c->ostate = 128;
#line 347
  break;
  default: 
#line 349
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 351
  break;
  }
#line 353
  return;
}
}
#line 354 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 357
  debug("channel %d: obuf empty", c->self);
#line 358
  tmp = buffer_len(& c->output);
#line 358
  if (tmp) {
#line 359
    error("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 361
    return;
  }
#line 363
  switch (c->ostate) {
  case 32: 
#line 365
  debug("channel %d: output drain -> closed", c->self);
#line 366
  chan_shutdown_write(c);
#line 367
  c->ostate = 128;
#line 368
  break;
  default: 
#line 370
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 372
  break;
  }
#line 374
  return;
}
}
#line 375 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 378
  debug("channel %d: send eof", c->self);
#line 379
  switch (c->istate) {
  case 2: 
#line 381
  packet_start(96);
#line 382
  packet_put_int((unsigned int )c->remote_id);
#line 383
  packet_send();
#line 384
  break;
  default: 
#line 386
  error("channel %d: internal error: cannot send eof for istate %d", c->self, c->istate);
#line 388
  break;
  }
#line 390
  return;
}
}
#line 391 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 394
  debug("channel %d: send close", c->self);
#line 395
  if (c->ostate != 128) {
#line 397
    error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
          c->self, c->istate, c->ostate);
  } else {
#line 395
    if (c->istate != 8) {
#line 397
      error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
            c->self, c->istate, c->ostate);
    } else {
#line 399
      if (c->flags & 1) {
#line 400
        error("channel %d: internal error: already sent close", c->self);
      } else {
#line 402
        packet_start(97);
#line 403
        packet_put_int((unsigned int )c->remote_id);
#line 404
        packet_send();
#line 405
        c->flags |= 1;
      }
    }
  }
#line 407
  return;
}
}
#line 408 "nchan.c"
static void chan_delete_if_full_closed2(Channel *c ) 
{ 

  {
#line 411
  if (c->istate == 8) {
#line 411
    if (c->ostate == 128) {
#line 412
      if (! (c->flags & 1)) {
#line 413
        chan_send_close2(c);
      }
#line 415
      if (c->flags & 1) {
#line 415
        if (c->flags & 2) {
#line 417
          debug("channel %d: full closed2", c->self);
#line 418
          channel_free(c->self);
        }
      }
    }
  }
#line 421
  return;
}
}
#line 424 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 427
  c->ostate = 16;
#line 428
  c->istate = 1;
#line 429
  c->flags = 0;
#line 430
  return;
}
}
#line 433 "nchan.c"
void chan_init(void) 
{ 

  {
#line 436
  if (compat20) {
#line 437
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 438
    chan_read_failed = & chan_read_failed_12;
#line 439
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 441
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 442
    chan_write_failed = & chan_write_failed2;
#line 443
    chan_obuf_empty = & chan_obuf_empty2;
#line 445
    chan_delete_if_full_closed = & chan_delete_if_full_closed2;
  } else {
#line 447
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 448
    chan_read_failed = & chan_read_failed_12;
#line 449
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 451
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 452
    chan_write_failed = & chan_write_failed1;
#line 453
    chan_obuf_empty = & chan_obuf_empty1;
#line 455
    chan_delete_if_full_closed = & chan_delete_if_full_closed1;
  }
#line 457
  return;
}
}
#line 460 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ unsigned int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 463
  tmp = buffer_len(& c->output);
#line 463
  buffer_consume(& c->output, tmp);
#line 464
  if (compat20) {
#line 464
    if (c->type == 10) {
#line 465
      return;
    }
  }
#line 467
  debug("channel %d: close_write", c->self);
#line 468
  if (c->sock != -1) {
#line 469
    tmp___2 = shutdown(c->sock, 1);
#line 469
    if (tmp___2 < 0) {
#line 470
      tmp___0 = __errno_location();
#line 470
      tmp___1 = strerror(*tmp___0);
#line 470
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 473
    tmp___5 = close(c->wfd);
#line 473
    if (tmp___5 < 0) {
#line 474
      tmp___3 = __errno_location();
#line 474
      tmp___4 = strerror(*tmp___3);
#line 474
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
#line 476
    c->wfd = -1;
  }
#line 478
  return;
}
}
#line 479 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 482
  if (compat20) {
#line 482
    if (c->type == 10) {
#line 483
      return;
    }
  }
#line 484
  debug("channel %d: close_read", c->self);
#line 485
  if (c->sock != -1) {
#line 486
    tmp___1 = shutdown(c->sock, 0);
#line 486
    if (tmp___1 < 0) {
#line 487
      tmp = __errno_location();
#line 487
      tmp___0 = strerror(*tmp);
#line 487
      error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
            c->self, c->sock, c->istate, c->ostate, tmp___0);
    }
  } else {
#line 490
    tmp___4 = close(c->rfd);
#line 490
    if (tmp___4 < 0) {
#line 491
      tmp___2 = __errno_location();
#line 491
      tmp___3 = strerror(*tmp___2);
#line 491
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___3);
    }
#line 493
    c->rfd = -1;
  }
#line 495
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 28 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 31
void packet_set_nonblocking(void) ;
#line 37
int packet_get_connection_out(void) ;
#line 43
void packet_close(void) ;
#line 50
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) ;
#line 58
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 61
unsigned int packet_get_protocol_flags(void) ;
#line 64
void packet_start_compression(int level ) ;
#line 70
void packet_set_interactive(int interactive , int keepalives ) ;
#line 85
void packet_put_bignum(BIGNUM *value ) ;
#line 86
void packet_put_bignum2(BIGNUM *value ) ;
#line 122
void packet_process_incoming(char const   *buf___1 , unsigned int len ) ;
#line 134
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 135
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 167
void packet_write_poll(void) ;
#line 173
int packet_have_data_to_write(void) ;
#line 176
int packet_not_very_much_data_to_write(void) ;
#line 180
int packet_set_maxsize(int s ) ;
#line 211
int packet_connection_is_ipv4(void) ;
#line 214
void packet_set_ssh2_format(void) ;
#line 102 "kex.h"
void packet_set_kex(Kex *k ) ;
#line 57 "packet.c"
static int connection_in  =    -1;
#line 58 "packet.c"
static int connection_out  =    -1;
#line 64 "packet.c"
static int cipher_type  =    0;
#line 67 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 70 "packet.c"
static CipherContext receive_context  ;
#line 73 "packet.c"
static CipherContext send_context  ;
#line 76 "packet.c"
static Buffer input  ;
#line 79 "packet.c"
static Buffer output  ;
#line 82 "packet.c"
static Buffer outgoing_packet  ;
#line 85 "packet.c"
static Buffer incoming_packet  ;
#line 88 "packet.c"
static Buffer compression_buffer  ;
#line 91 "packet.c"
static int packet_compression  =    0;
#line 94 "packet.c"
int max_packet_size  =    32768;
#line 97 "packet.c"
static int initialized  =    0;
#line 100 "packet.c"
static int interactive_mode  =    0;
#line 103 "packet.c"
int use_ssh2_packet_format  =    0;
#line 106 "packet.c"
Kex *kex  =    (Kex *)((void *)0);
#line 108 "packet.c"
void packet_set_kex(Kex *k ) 
{ 

  {
#line 111
  if ((unsigned int )k->mac[0].key == (unsigned int )((void *)0)) {
#line 117
    fatal("bad KEX");
  } else {
#line 111
    if ((unsigned int )k->enc[0].key == (unsigned int )((void *)0)) {
#line 117
      fatal("bad KEX");
    } else {
#line 111
      if ((unsigned int )k->enc[0].iv == (unsigned int )((void *)0)) {
#line 117
        fatal("bad KEX");
      } else {
#line 111
        if ((unsigned int )k->mac[1].key == (unsigned int )((void *)0)) {
#line 117
          fatal("bad KEX");
        } else {
#line 111
          if ((unsigned int )k->enc[1].key == (unsigned int )((void *)0)) {
#line 117
            fatal("bad KEX");
          } else {
#line 111
            if ((unsigned int )k->enc[1].iv == (unsigned int )((void *)0)) {
#line 117
              fatal("bad KEX");
            }
          }
        }
      }
    }
  }
#line 118
  kex = k;
#line 119
  return;
}
}
#line 120 "packet.c"
void clear_enc_keys(Enc *enc , int len ) 
{ 

  {
#line 123
  memset((void *)enc->iv, 0, (unsigned int )len);
#line 124
  memset((void *)enc->key, 0, (unsigned int )len);
#line 125
  xfree((void *)enc->iv);
#line 126
  xfree((void *)enc->key);
#line 127
  enc->iv = (unsigned char *)((void *)0);
#line 128
  enc->key = (unsigned char *)((void *)0);
#line 129
  return;
}
}
#line 130 "packet.c"
void packet_set_ssh2_format(void) 
{ 

  {
#line 134
  use_ssh2_packet_format = 1;
#line 135
  return;
}
}
#line 141 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 144
  connection_in = fd_in;
#line 145
  connection_out = fd_out;
#line 146
  cipher_type = 0;
#line 147
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 148
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 149
  if (! initialized) {
#line 150
    initialized = 1;
#line 151
    buffer_init(& input);
#line 152
    buffer_init(& output);
#line 153
    buffer_init(& outgoing_packet);
#line 154
    buffer_init(& incoming_packet);
  }
#line 157
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 158
  return;
}
}
#line 162 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 169
  if (connection_in == connection_out) {
#line 170
    return (1);
  }
#line 171
  fromlen = sizeof(from);
#line 172
  memset((void *)(& from), 0, sizeof(from));
#line 173
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 173
  if (tmp < 0) {
#line 174
    return (0);
  }
#line 175
  tolen = sizeof(to);
#line 176
  memset((void *)(& to), 0, sizeof(to));
#line 177
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 177
  if (tmp___0 < 0) {
#line 178
    return (0);
  }
#line 179
  if (fromlen != tolen) {
#line 180
    return (0);
  } else {
#line 179
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 179
    if (tmp___1 != 0) {
#line 180
      return (0);
    }
  }
#line 181
  if ((int )from.ss_family != 2) {
#line 181
    if ((int )from.ss_family != 10) {
#line 182
      return (0);
    }
  }
#line 183
  return (1);
}
}
#line 188 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 192
  tolen = sizeof(to);
#line 194
  memset((void *)(& to), 0, sizeof(to));
#line 195
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 195
  if (tmp < 0) {
#line 196
    return (0);
  }
#line 197
  if ((int )to.ss_family != 2) {
#line 198
    return (0);
  }
#line 199
  return (1);
}
}
#line 204 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 208
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 208
  if (tmp___1 < 0) {
#line 209
    tmp = __errno_location();
#line 209
    tmp___0 = strerror(*tmp);
#line 209
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 211
  if (connection_out != connection_in) {
#line 212
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 212
    if (tmp___4 < 0) {
#line 213
      tmp___2 = __errno_location();
#line 213
      tmp___3 = strerror(*tmp___2);
#line 213
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 215
  return;
}
}
#line 219 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 222
  return (connection_in);
}
}
#line 227 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 230
  return (connection_out);
}
}
#line 235 "packet.c"
void packet_close(void) 
{ 

  {
#line 238
  if (! initialized) {
#line 239
    return;
  }
#line 240
  initialized = 0;
#line 241
  if (connection_in == connection_out) {
#line 242
    shutdown(connection_out, 2);
#line 243
    close(connection_out);
  } else {
#line 245
    close(connection_in);
#line 246
    close(connection_out);
  }
#line 248
  buffer_free(& input);
#line 249
  buffer_free(& output);
#line 250
  buffer_free(& outgoing_packet);
#line 251
  buffer_free(& incoming_packet);
#line 252
  if (packet_compression) {
#line 253
    buffer_free(& compression_buffer);
#line 254
    buffer_compress_uninit();
  }
#line 256
  return;
}
}
#line 260 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 263
  remote_protocol_flags = protocol_flags;
#line 264
  channel_set_options((protocol_flags & 2U) != 0U);
#line 265
  return;
}
}
#line 269 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 272
  return (remote_protocol_flags);
}
}
#line 281 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 284
  if (packet_compression) {
#line 285
    fatal("Compression already enabled.");
  }
#line 286
  packet_compression = 1;
#line 287
  buffer_init(& compression_buffer);
#line 288
  buffer_compress_init(level);
#line 289
  return;
}
}
#line 296 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 300
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 301
  return;
}
}
#line 308 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 314
  if (bytes % 8U != 0U) {
#line 315
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  }
#line 322
  if (cc->type == 0U) {
#line 323
    i = 0;
  } else {
#line 322
    if (compat20) {
#line 323
      i = 0;
    } else {
#line 325
      i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
    }
  }
#line 327
  if (i == 1) {
#line 328
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 330
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 331
  return;
}
}
#line 339 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) 
{ 

  {
#line 343
  if (keylen < 20U) {
#line 344
    fatal("keylen too small: %d", keylen);
  }
#line 347
  cipher_set_key(& receive_context, cipher, key, (int )keylen);
#line 348
  cipher_set_key(& send_context, cipher, key, (int )keylen);
#line 349
  return;
}
}
#line 353 "packet.c"
void packet_start1(int type ) 
{ char buf___1[9] ;

  {
#line 358
  buffer_clear(& outgoing_packet);
#line 359
  memset((void *)(buf___1), 0, 8U);
#line 360
  buf___1[8] = (char )type;
#line 361
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 9U);
#line 362
  return;
}
}
#line 364 "packet.c"
void packet_start2(int type ) 
{ char buf___1[6] ;

  {
#line 369
  buffer_clear(& outgoing_packet);
#line 370
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 373
  buf___1[5] = (char )(type & 255);
#line 374
  buffer_append(& outgoing_packet, (char const   *)(buf___1), sizeof(buf___1));
#line 375
  return;
}
}
#line 377 "packet.c"
void packet_start(int type ) 
{ 

  {
#line 381
  if (use_ssh2_packet_format) {
#line 382
    packet_start2(type);
  } else {
#line 384
    packet_start1(type);
  }
#line 385
  return;
}
}
#line 389 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 392
  ch = (char )value;
#line 393
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 394
  return;
}
}
#line 398 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 401
  buffer_put_int(& outgoing_packet, value);
#line 402
  return;
}
}
#line 406 "packet.c"
void packet_put_string(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 409
  buffer_put_string(& outgoing_packet, (void const   *)buf___1, len);
#line 410
  return;
}
}
#line 411 "packet.c"
void packet_put_cstring(char const   *str ) 
{ size_t tmp ;

  {
#line 414
  tmp = strlen(str);
#line 414
  buffer_put_string(& outgoing_packet, (void const   *)str, tmp);
#line 415
  return;
}
}
#line 417 "packet.c"
void packet_put_raw(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 420
  buffer_append(& outgoing_packet, buf___1, len);
#line 421
  return;
}
}
#line 426 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 429
  buffer_put_bignum(& outgoing_packet, value);
#line 430
  return;
}
}
#line 431 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 434
  buffer_put_bignum2(& outgoing_packet, value);
#line 435
  return;
}
}
#line 442 "packet.c"
void packet_send1(void) 
{ char buf___1[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 448
  rand___0 = (u_int32_t )0;
#line 454
  if (packet_compression) {
#line 455
    buffer_clear(& compression_buffer);
#line 457
    buffer_consume(& outgoing_packet, 8U);
#line 459
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 460
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 461
    buffer_clear(& outgoing_packet);
#line 462
    tmp = buffer_len(& compression_buffer);
#line 462
    tmp___0 = buffer_ptr(& compression_buffer);
#line 462
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 466
  tmp___1 = buffer_len(& outgoing_packet);
#line 466
  len = (int )((tmp___1 + 4U) - 8U);
#line 469
  padding = 8 - len % 8;
#line 470
  if (cipher_type != 0) {
#line 471
    cp = buffer_ptr(& outgoing_packet);
#line 472
    i = 0;
#line 472
    while (i < padding) {
#line 473
      if (i % 4 == 0) {
#line 474
        rand___0 = arc4random();
      }
#line 475
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 476
      rand___0 >>= 8;
#line 472
      i ++;
    }
  }
#line 479
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 482
  tmp___2 = buffer_len(& outgoing_packet);
#line 482
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 482
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 484
  while (1) {
#line 484
    buf___1[0] = (char )(checksum >> 24);
#line 484
    buf___1[1] = (char )(checksum >> 16);
#line 484
    buf___1[2] = (char )(checksum >> 8);
#line 484
    buf___1[3] = (char )checksum;
#line 484
    break;
  }
#line 485
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 4U);
#line 493
  while (1) {
#line 493
    buf___1[0] = (char )(len >> 24);
#line 493
    buf___1[1] = (char )(len >> 16);
#line 493
    buf___1[2] = (char )(len >> 8);
#line 493
    buf___1[3] = (char )len;
#line 493
    break;
  }
#line 494
  buffer_append(& output, (char const   *)(buf___1), 4U);
#line 495
  tmp___4 = buffer_len(& outgoing_packet);
#line 495
  buffer_append_space(& output, & cp, tmp___4);
#line 496
  tmp___5 = buffer_len(& outgoing_packet);
#line 496
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 496
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 504
  buffer_clear(& outgoing_packet);
#line 511
  return;
}
}
#line 524
void packet_send2(void) ;
#line 524 "packet.c"
static unsigned int seqnr  =    0U;
#line 516 "packet.c"
void packet_send2(void) 
{ unsigned char *macbuf ;
  char *cp ;
  unsigned int packet_length___0 ;
  unsigned int i ;
  unsigned int padlen ;
  unsigned int len ;
  u_int32_t rand___0 ;
  int type ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 519
  macbuf = (unsigned char *)((void *)0);
#line 521
  packet_length___0 = 0U;
#line 523
  rand___0 = (u_int32_t )0;
#line 526
  enc = (Enc *)((void *)0);
#line 527
  mac = (Mac *)((void *)0);
#line 528
  comp = (Comp *)((void *)0);
#line 531
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 532
    enc = & kex->enc[1];
#line 533
    mac = & kex->mac[1];
#line 534
    comp = & kex->comp[1];
  }
#line 536
  if (enc) {
#line 536
    block_size = enc->block_size;
  } else {
#line 536
    block_size = 8;
  }
#line 538
  cp = buffer_ptr(& outgoing_packet);
#line 539
  type = (int )*(cp + 5) & 255;
#line 546
  if (comp) {
#line 546
    if (comp->enabled) {
#line 547
      len = buffer_len(& outgoing_packet);
#line 549
      buffer_consume(& outgoing_packet, 5U);
#line 550
      buffer_clear(& compression_buffer);
#line 551
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 552
      buffer_clear(& outgoing_packet);
#line 553
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 554
      tmp = buffer_len(& compression_buffer);
#line 554
      tmp___0 = buffer_ptr(& compression_buffer);
#line 554
      buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
    }
  }
#line 561
  len = buffer_len(& outgoing_packet);
#line 567
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 568
  if (padlen < 4U) {
#line 569
    padlen += (unsigned int )block_size;
  }
#line 570
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 571
  if (enc) {
#line 571
    if (enc->type != 0) {
#line 573
      i = 0U;
#line 573
      while (i < padlen) {
#line 574
        if (i % 4U == 0U) {
#line 575
          rand___0 = arc4random();
        }
#line 576
        *(cp + i) = (char )(rand___0 & 255U);
#line 577
        rand___0 <<= 8;
#line 573
        i ++;
      }
    } else {
#line 581
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 581
    memset((void *)cp, 0, padlen);
  }
#line 584
  tmp___1 = buffer_len(& outgoing_packet);
#line 584
  packet_length___0 = tmp___1 - 4U;
#line 585
  cp = buffer_ptr(& outgoing_packet);
#line 586
  while (1) {
#line 586
    *(cp + 0) = (char )(packet_length___0 >> 24);
#line 586
    *(cp + 1) = (char )(packet_length___0 >> 16);
#line 586
    *(cp + 2) = (char )(packet_length___0 >> 8);
#line 586
    *(cp + 3) = (char )packet_length___0;
#line 586
    break;
  }
#line 587
  *(cp + 4) = (char )(padlen & 255U);
#line 591
  if (mac) {
#line 591
    if (mac->enabled) {
#line 592
      tmp___2 = buffer_len(& outgoing_packet);
#line 592
      tmp___3 = buffer_ptr(& outgoing_packet);
#line 592
      macbuf = hmac(mac->md, seqnr, (unsigned char *)tmp___3, (int )tmp___2, mac->key,
                    mac->key_len);
    }
  }
#line 600
  tmp___4 = buffer_len(& outgoing_packet);
#line 600
  buffer_append_space(& output, & cp, tmp___4);
#line 601
  tmp___5 = buffer_len(& outgoing_packet);
#line 601
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 601
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 604
  if (mac) {
#line 604
    if (mac->enabled) {
#line 605
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 611
  seqnr ++;
#line 611
  if (seqnr == 0U) {
#line 612
    log("outgoing seqnr wraps around");
  }
#line 613
  buffer_clear(& outgoing_packet);
#line 615
  if (type == 21) {
#line 616
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 617
      fatal("packet_send2: no KEX");
    } else {
#line 616
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 617
        fatal("packet_send2: no KEX");
      } else {
#line 616
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 617
          fatal("packet_send2: no KEX");
        } else {
#line 616
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 617
            fatal("packet_send2: no KEX");
          }
        }
      }
    }
#line 618
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 619
      mac->enabled = 1;
    }
#line 621
    cipher_set_key_iv(& send_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 624
    clear_enc_keys(enc, kex->we_need);
#line 625
    if (comp->type != 0) {
#line 625
      if (comp->enabled == 0) {
#line 626
        comp->enabled = 1;
#line 627
        if (! packet_compression) {
#line 628
          packet_start_compression(6);
        }
      }
    }
  }
#line 631
  return;
}
}
#line 633 "packet.c"
void packet_send(void) 
{ 

  {
#line 636
  if (use_ssh2_packet_format) {
#line 637
    packet_send2();
  } else {
#line 639
    packet_send1();
  }
#line 641
  return;
}
}
#line 649 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf___1[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 658
  packet_write_wait();
#line 661
  while (1) {
#line 663
    type = packet_read_poll(payload_len_ptr);
#line 664
    if (! use_ssh2_packet_format) {
#line 664
      if (type == 14) {
        goto _L;
      } else {
#line 664
        if (type == 15) {
          goto _L;
        } else {
#line 664
          if (type == 19) {
            goto _L;
          } else {
#line 664
            if (type == 33) {
              _L: /* CIL Label */ 
#line 669
              while (1) {
#line 669
                _p = *payload_len_ptr;
#line 669
                _e = 0;
#line 669
                if (_p != _e) {
#line 669
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      669);
#line 669
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 669
                break;
              }
            }
          }
        }
      }
    }
#line 671
    if (type != 0) {
#line 672
      return (type);
    }
#line 677
    while (1) {
#line 677
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 677
      break;
    }
#line 678
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 681
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 684
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 685
    if (len == 0) {
#line 686
      tmp = get_remote_ipaddr();
#line 686
      log("Connection closed by %.200s", tmp);
#line 687
      fatal_cleanup();
    }
#line 689
    if (len < 0) {
#line 690
      tmp___0 = __errno_location();
#line 690
      tmp___1 = strerror(*tmp___0);
#line 690
      fatal("Read from socket failed: %.100s", tmp___1);
    }
#line 692
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 702 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 707
  type = packet_read(payload_len_ptr);
#line 708
  if (type != expected_type) {
#line 709
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 711
  return;
}
}
#line 728 "packet.c"
int packet_read_poll1(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf___1[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 737
  tmp = buffer_len(& input);
#line 737
  if (tmp < 12U) {
#line 738
    return (0);
  }
#line 740
  tmp___0 = buffer_ptr(& input);
#line 740
  ucp = (unsigned char *)tmp___0;
#line 741
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 742
  if (len < 5U) {
#line 743
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 742
    if (len > 262144U) {
#line 743
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 744
  padded_len = (len + 8U) & 4294967288U;
#line 747
  tmp___1 = buffer_len(& input);
#line 747
  if (tmp___1 < 4U + padded_len) {
#line 748
    return (0);
  }
#line 753
  buffer_consume(& input, 4U);
#line 756
  buffer_clear(& incoming_packet);
#line 757
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 758
  tmp___2 = buffer_ptr(& input);
#line 758
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 759
  buffer_consume(& input, padded_len);
#line 767
  tmp___3 = buffer_len(& incoming_packet);
#line 767
  tmp___4 = buffer_ptr(& incoming_packet);
#line 767
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 771
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 775
  tmp___6 = buffer_len(& incoming_packet);
#line 775
  if (len != tmp___6) {
#line 776
    tmp___5 = buffer_len(& incoming_packet);
#line 776
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 779
  tmp___7 = buffer_ptr(& incoming_packet);
#line 779
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 780
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 781
  if (checksum != stored_checksum) {
#line 782
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 783
  buffer_consume_end(& incoming_packet, 4U);
#line 786
  if (packet_compression) {
#line 787
    buffer_clear(& compression_buffer);
#line 788
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 789
    buffer_clear(& incoming_packet);
#line 790
    tmp___8 = buffer_len(& compression_buffer);
#line 790
    tmp___9 = buffer_ptr(& compression_buffer);
#line 790
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 794
  buffer_get(& incoming_packet, buf___1, 1U);
#line 797
  tmp___10 = buffer_len(& incoming_packet);
#line 797
  *payload_len_ptr = (int )tmp___10;
#line 800
  return ((int )((unsigned char )buf___1[0]));
}
}
#line 810
int packet_read_poll2(int *payload_len_ptr ) ;
#line 810 "packet.c"
static unsigned int packet_length  =    0U;
#line 811 "packet.c"
static unsigned int seqnr___0  =    0U;
#line 803 "packet.c"
int packet_read_poll2(int *payload_len_ptr ) 
{ unsigned int padlen ;
  unsigned int need ;
  unsigned char buf___1[8] ;
  unsigned char *macbuf ;
  unsigned char *ucp ;
  char *cp ;
  int type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  unsigned int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 814
  enc = (Enc *)((void *)0);
#line 815
  mac = (Mac *)((void *)0);
#line 816
  comp = (Comp *)((void *)0);
#line 818
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 819
    enc = & kex->enc[0];
#line 820
    mac = & kex->mac[0];
#line 821
    comp = & kex->comp[0];
  }
#line 823
  if (mac) {
#line 823
    if (mac->enabled) {
#line 823
      maclen = mac->mac_len;
    } else {
#line 823
      maclen = 0;
    }
  } else {
#line 823
    maclen = 0;
  }
#line 824
  if (enc) {
#line 824
    block_size = enc->block_size;
  } else {
#line 824
    block_size = 8;
  }
#line 826
  if (packet_length == 0U) {
#line 831
    tmp = buffer_len(& input);
#line 831
    if (tmp < (unsigned int )block_size) {
#line 832
      return (0);
    }
#line 833
    buffer_clear(& incoming_packet);
#line 834
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 835
    tmp___0 = buffer_ptr(& input);
#line 835
    packet_decrypt(& receive_context, (void *)cp, (void *)tmp___0, (unsigned int )block_size);
#line 837
    tmp___1 = buffer_ptr(& incoming_packet);
#line 837
    ucp = (unsigned char *)tmp___1;
#line 838
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 839
    if (packet_length < 5U) {
#line 840
      buffer_dump(& incoming_packet);
#line 841
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 839
      if (packet_length > 262144U) {
#line 840
        buffer_dump(& incoming_packet);
#line 841
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 844
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 847
  need = (4U + packet_length) - (unsigned int )block_size;
#line 850
  if (need % (unsigned int )block_size != 0U) {
#line 851
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 857
  tmp___2 = buffer_len(& input);
#line 857
  if (tmp___2 < need + (unsigned int )maclen) {
#line 858
    return (0);
  }
#line 863
  buffer_append_space(& incoming_packet, & cp, need);
#line 864
  tmp___3 = buffer_ptr(& input);
#line 864
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___3, need);
#line 865
  buffer_consume(& input, need);
#line 870
  if (mac) {
#line 870
    if (mac->enabled) {
#line 871
      tmp___4 = buffer_len(& incoming_packet);
#line 871
      tmp___5 = buffer_ptr(& incoming_packet);
#line 871
      macbuf = hmac(mac->md, seqnr___0, (unsigned char *)tmp___5, (int )tmp___4, mac->key,
                    mac->key_len);
#line 876
      tmp___6 = buffer_ptr(& input);
#line 876
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 876
      if (tmp___7 != 0) {
#line 877
        packet_disconnect("Corrupted HMAC on input.");
      }
#line 879
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 881
  seqnr___0 ++;
#line 881
  if (seqnr___0 == 0U) {
#line 882
    log("incoming seqnr wraps around");
  }
#line 885
  tmp___8 = buffer_ptr(& incoming_packet);
#line 885
  cp = tmp___8 + 4;
#line 886
  padlen = (unsigned int )((int )*cp & 255);
#line 888
  if (padlen < 4U) {
#line 889
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 892
  buffer_consume(& incoming_packet, 5U);
#line 893
  buffer_consume_end(& incoming_packet, padlen);
#line 896
  if (comp) {
#line 896
    if (comp->enabled) {
#line 897
      buffer_clear(& compression_buffer);
#line 898
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 899
      buffer_clear(& incoming_packet);
#line 900
      tmp___9 = buffer_len(& compression_buffer);
#line 900
      tmp___10 = buffer_ptr(& compression_buffer);
#line 900
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 908
  buffer_get(& incoming_packet, (char *)(buf___1), 1U);
#line 909
  tmp___11 = buffer_len(& incoming_packet);
#line 909
  *payload_len_ptr = (int )tmp___11;
#line 912
  packet_length = 0U;
#line 915
  type = (int )buf___1[0];
#line 917
  if (type == 21) {
#line 918
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 919
      fatal("packet_read_poll2: no KEX");
    } else {
#line 918
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 919
        fatal("packet_read_poll2: no KEX");
      } else {
#line 918
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 919
          fatal("packet_read_poll2: no KEX");
        } else {
#line 918
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 919
            fatal("packet_read_poll2: no KEX");
          }
        }
      }
    }
#line 920
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 921
      mac->enabled = 1;
    }
#line 923
    cipher_set_key_iv(& receive_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 926
    clear_enc_keys(enc, kex->we_need);
#line 927
    if (comp->type != 0) {
#line 927
      if (comp->enabled == 0) {
#line 928
        comp->enabled = 1;
#line 929
        if (! packet_compression) {
#line 930
          packet_start_compression(6);
        }
      }
    }
  }
#line 938
  return ((int )((unsigned char )type));
}
}
#line 941 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ char *msg ;
  int type ;
  int tmp___1 ;
  int reason ;
  unsigned int tmp___2 ;

  {
#line 945
  while (1) {
#line 946
    if (use_ssh2_packet_format) {
#line 946
      tmp___1 = packet_read_poll2(payload_len_ptr);
    } else {
#line 946
      tmp___1 = packet_read_poll1(payload_len_ptr);
    }
#line 946
    type = tmp___1;
#line 950
    if (compat20) {
#line 952
      if (type != 0) {

      }
#line 954
      switch (type) {
      case 2: 
#line 956
      break;
      case 4: 
#line 958
      packet_get_char();
#line 959
      msg = packet_get_string((unsigned int *)((void *)0));
#line 960
      debug("Remote: %.900s", msg);
#line 961
      xfree((void *)msg);
#line 962
      msg = packet_get_string((unsigned int *)((void *)0));
#line 963
      xfree((void *)msg);
#line 964
      break;
      case 1: 
#line 966
      tmp___2 = packet_get_int();
#line 966
      reason = (int )tmp___2;
#line 967
      msg = packet_get_string((unsigned int *)((void *)0));
#line 968
      log("Received disconnect: %d: %.900s", reason, msg);
#line 969
      xfree((void *)msg);
#line 970
      fatal_cleanup();
#line 971
      break;
      default: ;
#line 973
      return (type);
#line 974
      break;
      }
    } else {
#line 977
      switch (type) {
      case 32: 
#line 979
      break;
      case 36: 
#line 981
      msg = packet_get_string((unsigned int *)((void *)0));
#line 982
      debug("Remote: %.900s", msg);
#line 983
      xfree((void *)msg);
#line 984
      break;
      case 1: 
#line 986
      msg = packet_get_string((unsigned int *)((void *)0));
#line 987
      log("Received disconnect: %.900s", msg);
#line 988
      fatal_cleanup();
#line 989
      xfree((void *)msg);
#line 990
      break;
      default: ;
#line 992
      if (type != 0) {

      }
#line 994
      return (type);
#line 995
      break;
      }
    }
  }
}
}
#line 1006 "packet.c"
void packet_process_incoming(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 1009
  buffer_append(& input, buf___1, len);
#line 1010
  return;
}
}
#line 1014 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 1018
  buffer_get(& incoming_packet, & ch, 1U);
#line 1019
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1024 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 1027
  tmp = buffer_get_int(& incoming_packet);
#line 1027
  return (tmp);
}
}
#line 1035 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1038
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 1039
  return;
}
}
#line 1041 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1044
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 1045
  return;
}
}
#line 1047 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 1050
  tmp = buffer_len(& incoming_packet);
#line 1050
  bytes = (int )tmp;
#line 1051
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1052
    *length_ptr = bytes;
  }
#line 1053
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1053
  return (tmp___0);
}
}
#line 1056 "packet.c"
int packet_remaining(void) 
{ unsigned int tmp ;

  {
#line 1059
  tmp = buffer_len(& incoming_packet);
#line 1059
  return ((int )tmp);
}
}
#line 1069 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 1072
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1072
  return (tmp);
}
}
#line 1084 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1090
  __builtin_va_start(args, fmt);
#line 1091
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1092
  __builtin_va_end(args);
#line 1094
  if (compat20) {
#line 1095
    packet_start(4);
#line 1096
    packet_put_char(0);
#line 1097
    packet_put_cstring((char const   *)(buf___1));
#line 1098
    packet_put_cstring("");
  } else {
#line 1100
    packet_start(36);
#line 1101
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1103
  packet_send();
#line 1104
  packet_write_wait();
#line 1105
  return;
}
}
#line 1119 "packet.c"
static int disconnecting  =    0;
#line 1114 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 1120
  if (disconnecting) {
#line 1121
    fatal("packet_disconnect called recursively.");
  }
#line 1122
  disconnecting = 1;
#line 1128
  __builtin_va_start(args, fmt);
#line 1129
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1130
  __builtin_va_end(args);
#line 1133
  if (compat20) {
#line 1134
    packet_start(1);
#line 1135
    packet_put_int(2U);
#line 1136
    packet_put_cstring((char const   *)(buf___1));
#line 1137
    packet_put_cstring("");
  } else {
#line 1139
    packet_start(1);
#line 1140
    tmp = strlen((char const   *)(buf___1));
#line 1140
    packet_put_string((char const   *)(buf___1), tmp);
  }
#line 1142
  packet_send();
#line 1143
  packet_write_wait();
#line 1146
  channel_stop_listening();
#line 1149
  packet_close();
#line 1152
  log("Disconnecting: %.100s", buf___1);
#line 1153
  fatal_cleanup();
#line 1154
  return;
}
}
#line 1158 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1161
  tmp = buffer_len(& output);
#line 1161
  len = (int )tmp;
#line 1162
  if (len > 0) {
#line 1163
    tmp___0 = buffer_ptr(& output);
#line 1163
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1164
    if (len <= 0) {
#line 1165
      tmp___3 = __errno_location();
#line 1165
      if (*tmp___3 == 11) {
#line 1166
        return;
      } else {
#line 1168
        tmp___1 = __errno_location();
#line 1168
        tmp___2 = strerror(*tmp___1);
#line 1168
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1170
    buffer_consume(& output, (unsigned int )len);
  }
#line 1172
  return;
}
}
#line 1179 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 1182
  packet_write_poll();
#line 1183
  while (1) {
#line 1183
    tmp = packet_have_data_to_write();
#line 1183
    if (! tmp) {
#line 1183
      break;
    }
#line 1185
    while (1) {
#line 1185
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 1185
      break;
    }
#line 1186
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1187
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1188
    packet_write_poll();
  }
#line 1190
  return;
}
}
#line 1194 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 1197
  tmp = buffer_len(& output);
#line 1197
  return (tmp != 0U);
}
}
#line 1202 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1205
  if (interactive_mode) {
#line 1206
    tmp = buffer_len(& output);
#line 1206
    return (tmp < 16384U);
  } else {
#line 1208
    tmp___0 = buffer_len(& output);
#line 1208
    return (tmp___0 < 131072U);
  }
}
}
#line 1213 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int lowdelay ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int throughput ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 1216
  on = 1;
#line 1219
  interactive_mode = interactive;
#line 1222
  tmp = packet_connection_is_on_socket();
#line 1222
  if (! tmp) {
#line 1223
    return;
  }
#line 1224
  if (keepalives) {
#line 1226
    tmp___2 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1226
    if (tmp___2 < 0) {
#line 1228
      tmp___0 = __errno_location();
#line 1228
      tmp___1 = strerror(*tmp___0);
#line 1228
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___1);
    }
  }
#line 1233
  tmp___3 = packet_connection_is_ipv4();
#line 1233
  if (! tmp___3) {
#line 1234
    return;
  }
#line 1235
  if (interactive) {
#line 1241
    lowdelay = 16;
#line 1242
    tmp___6 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 1242
    if (tmp___6 < 0) {
#line 1244
      tmp___4 = __errno_location();
#line 1244
      tmp___5 = strerror(*tmp___4);
#line 1244
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___5);
    }
#line 1246
    tmp___9 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1246
    if (tmp___9 < 0) {
#line 1248
      tmp___7 = __errno_location();
#line 1248
      tmp___8 = strerror(*tmp___7);
#line 1248
      error("setsockopt TCP_NODELAY: %.100s", tmp___8);
    }
  } else {
#line 1255
    throughput = 8;
#line 1256
    tmp___12 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 1256
    if (tmp___12 < 0) {
#line 1258
      tmp___10 = __errno_location();
#line 1258
      tmp___11 = strerror(*tmp___10);
#line 1258
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___11);
    }
  }
#line 1261
  return;
}
}
#line 1265 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1268
  return (interactive_mode);
}
}
#line 1274 "packet.c"
static int called___0  =    0;
#line 1271 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1275
  if (called___0) {
#line 1276
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1278
    return (-1);
  }
#line 1280
  if (s < 4096) {
#line 1281
    log("packet_set_maxsize: bad size %d", s);
#line 1282
    return (-1);
  } else {
#line 1280
    if (s > 1048576) {
#line 1281
      log("packet_set_maxsize: bad size %d", s);
#line 1282
      return (-1);
    }
  }
#line 1284
  log("packet_set_maxsize: setting to %d", s);
#line 1285
  max_packet_size = s;
#line 1286
  return (s);
}
}
#line 1 "radix.o"
#line 1 "entropy.o"
#line 33 "entropy.h"
void seed_rng(void) ;
#line 34
void init_rng(void) ;
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 109
extern int RAND_status(void) ;
#line 130 "entropy.c"
int get_random_bytes(unsigned char *buf___1 , int len ) 
{ int random_pool ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 134
  random_pool = open("/dev/urandom", 0);
#line 135
  if (random_pool == -1) {
#line 136
    tmp = __errno_location();
#line 136
    tmp___0 = strerror(*tmp);
#line 136
    error("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
#line 138
    return (0);
  }
#line 141
  tmp___3 = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___1, (unsigned int )len);
#line 141
  if (tmp___3 != len) {
#line 142
    tmp___1 = __errno_location();
#line 142
    tmp___2 = strerror(*tmp___1);
#line 142
    error("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
#line 144
    close(random_pool);
#line 145
    return (0);
  }
#line 148
  close(random_pool);
#line 150
  return (1);
}
}
#line 159 "entropy.c"
void seed_rng(void) 
{ char buf___1[32] ;
  int tmp ;
  int tmp___0 ;

  {
#line 164
  debug("Seeding random number generator");
#line 166
  tmp___0 = get_random_bytes((unsigned char *)(buf___1), (int )sizeof(buf___1));
#line 166
  if (tmp___0) {
#line 170
    RAND_add((void const   *)(buf___1), (int )sizeof(buf___1), (double )sizeof(buf___1));
  } else {
#line 167
    tmp = RAND_status();
#line 167
    if (! tmp) {
#line 168
      fatal("Entropy collection failed and entropy exhausted");
    }
  }
#line 173
  memset((void *)(buf___1), '\000', sizeof(buf___1));
#line 174
  return;
}
}
#line 177 "entropy.c"
void init_rng(void) 
{ 

  {
#line 177
  return;
}
}
#line 1 "readpass.o"
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 423 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 40 "readpass.c"
int volatile   intr  ;
#line 42 "readpass.c"
void intcatch(void) 
{ 

  {
#line 45
  intr = (int volatile   )1;
#line 46
  return;
}
}
#line 53 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf___1[1024] ;
  char *p ;
  char ch ;
  struct termios tio ;
  struct termios saved_tio ;
  sigset_t oset ;
  sigset_t nset ;
  struct sigaction sa ;
  struct sigaction osa ;
  int input___0 ;
  int output___0 ;
  int echo ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  __pid_t tmp___3 ;

  {
#line 60
  echo = 0;
#line 62
  if (from_stdin) {
#line 63
    input___0 = 0;
#line 64
    output___0 = 2;
  } else {
#line 66
    output___0 = open("/dev/tty", 2);
#line 66
    input___0 = output___0;
  }
#line 68
  if (input___0 == -1) {
#line 69
    fatal("You have no controlling tty.  Cannot read passphrase.\n");
  }
#line 72
  sigemptyset(& nset);
#line 73
  sigaddset(& nset, 20);
#line 74
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 75
  memset((void *)(& sa), 0, sizeof(sa));
#line 76
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& intcatch);
#line 77
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& osa));
#line 79
  intr = (int volatile   )0;
#line 81
  tmp = tcgetattr(input___0, & saved_tio);
#line 81
  if (tmp == 0) {
#line 81
    if (saved_tio.c_lflag & 8U) {
#line 82
      echo = 1;
#line 83
      tio = saved_tio;
#line 84
      tio.c_lflag &= 4294967175U;
#line 85
      tcsetattr(input___0, 0, (struct termios  const  *)(& tio));
    }
  }
#line 88
  fflush(stdout);
#line 90
  tmp___0 = strlen(prompt);
#line 90
  write(output___0, (void const   *)prompt, tmp___0);
#line 91
  p = buf___1;
#line 91
  while (1) {
#line 91
    tmp___2 = read(input___0, (void *)(& ch), 1U);
#line 91
    if (tmp___2 == 1) {
#line 91
      if (! ((int )ch != 10)) {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
#line 92
    if (intr) {
#line 93
      break;
    }
#line 94
    if ((unsigned int )p < (unsigned int )((buf___1 + sizeof(buf___1)) - 1)) {
#line 95
      tmp___1 = p;
#line 95
      p ++;
#line 95
      *tmp___1 = ch;
    }
  }
#line 97
  *p = (char )'\000';
#line 98
  if (! intr) {
#line 99
    write(output___0, (void const   *)"\n", 1U);
  }
#line 102
  if (echo) {
#line 103
    tcsetattr(input___0, 0, (struct termios  const  *)(& saved_tio));
  }
#line 104
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 105
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 107
  if (intr) {
#line 108
    tmp___3 = getpid();
#line 108
    kill(tmp___3, 2);
#line 109
    sigemptyset(& nset);
#line 111
    sigsuspend((sigset_t const   *)(& nset));
  }
#line 114
  if (! from_stdin) {
#line 115
    close(input___0);
  }
#line 116
  p = xstrdup((char const   *)(buf___1));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  return (p);
}
}
#line 1 "rsa.o"
#line 452 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 490
__inline static int putchar(int __c ) ;
#line 75 "/usr/include/bits/stdio.h"
__inline static int putchar(int __c ) 
{ int tmp ;

  {
#line 78
  tmp = _IO_putc(__c, stdout);
#line 78
  return (tmp);
}
}
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 25 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 31
void rsa_set_verbose(int verbose___0 ) ;
#line 33
int rsa_alive(void) ;
#line 35
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 36
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 45 "rsa.c"
int rsa_verbose  =    1;
#line 47 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 52
  seed_rng();
#line 53
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 54
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 55
    return (0);
  }
#line 56
  RSA_free(key);
#line 57
  return (1);
}
}
#line 63 "rsa.c"
void keygen_progress(int p , int n___0 , void *arg ) 
{ char progress_chars[6] ;

  {
#line 66
  progress_chars[0] = (char )'.';
#line 66
  progress_chars[1] = (char )'o';
#line 66
  progress_chars[2] = (char )'+';
#line 66
  progress_chars[3] = (char )'O';
#line 66
  progress_chars[4] = (char )'?';
#line 66
  progress_chars[5] = (char )'\000';
#line 68
  if (p < 0) {
#line 69
    p = (int )(sizeof(progress_chars) - 2U);
  } else {
#line 68
    if ((unsigned int )p > sizeof(progress_chars) - 2U) {
#line 69
      p = (int )(sizeof(progress_chars) - 2U);
    }
  }
#line 71
  putchar((int )progress_chars[p]);
#line 72
  fflush(stdout);
#line 73
  return;
}
}
#line 81 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 86
  seed_rng();
#line 88
  if (rsa_verbose) {
#line 89
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 90
    fflush(stdout);
#line 91
    key = RSA_generate_key((int )bits, 35UL, & keygen_progress, (void *)0);
#line 92
    printf((char const   * __restrict  )"\n");
  } else {
#line 94
    key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                           (void *)0);
  }
#line 96
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 97
    fatal("rsa_generate_key: key generation failed.");
  }
#line 100
  pub->n = BN_new();
#line 101
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 102
  pub->e = BN_new();
#line 103
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 106
  prv->n = BN_new();
#line 107
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 108
  prv->e = BN_new();
#line 109
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 110
  prv->d = BN_new();
#line 111
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 112
  prv->p = BN_new();
#line 113
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 114
  prv->q = BN_new();
#line 115
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 117
  prv->dmp1 = BN_new();
#line 118
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 120
  prv->dmq1 = BN_new();
#line 121
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 123
  prv->iqmp = BN_new();
#line 124
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 126
  RSA_free(key);
#line 128
  if (rsa_verbose) {
#line 129
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 130
  return;
}
}
#line 132 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 138
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 138
  if (tmp < 2) {
#line 139
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 138
    if ((key->e)->top > 0) {
#line 138
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 139
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 139
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 141
  olen = (tmp___0 + 7) / 8;
#line 142
  tmp___1 = xmalloc((unsigned int )olen);
#line 142
  outbuf = (unsigned char *)tmp___1;
#line 144
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 144
  ilen = (tmp___2 + 7) / 8;
#line 145
  tmp___3 = xmalloc((unsigned int )ilen);
#line 145
  inbuf = (unsigned char *)tmp___3;
#line 146
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 148
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 148
  if (len <= 0) {
#line 150
    fatal("rsa_public_encrypt() failed");
  }
#line 152
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 154
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 155
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 156
  xfree((void *)outbuf);
#line 157
  xfree((void *)inbuf);
#line 158
  return;
}
}
#line 160 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 166
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 166
  olen = (tmp + 7) / 8;
#line 167
  tmp___0 = xmalloc((unsigned int )olen);
#line 167
  outbuf = (unsigned char *)tmp___0;
#line 169
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 169
  ilen = (tmp___1 + 7) / 8;
#line 170
  tmp___2 = xmalloc((unsigned int )ilen);
#line 170
  inbuf = (unsigned char *)tmp___2;
#line 171
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 173
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 173
  if (len <= 0) {
#line 175
    fatal("rsa_private_decrypt() failed");
  }
#line 177
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 179
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 180
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 181
  xfree((void *)outbuf);
#line 182
  xfree((void *)inbuf);
#line 183
  return;
}
}
#line 187 "rsa.c"
void rsa_set_verbose(int verbose___0 ) 
{ 

  {
#line 190
  rsa_verbose = verbose___0;
#line 191
  return;
}
}
#line 1 "tildexpand.o"
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 487 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 18 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 29
  if ((int const   )*(filename + 0) != 126) {
#line 30
    tmp = xstrdup(filename);
#line 30
    return (tmp);
  }
#line 33
  filename ++;
#line 36
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 36
  cp = (char const   *)tmp___1;
#line 37
  if (cp) {
#line 38
    userlen = (unsigned int )(cp - filename);
  } else {
#line 40
    userlen = strlen(filename);
  }
#line 41
  if (userlen == 0U) {
#line 42
    pw = getpwuid(my_uid);
  } else {
#line 45
    if (userlen > sizeof(user) - 1U) {
#line 46
      fatal("User name after tilde too long.");
    }
#line 47
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 48
    user[userlen] = (char)0;
#line 49
    pw = getpwnam((char const   *)(user));
  }
#line 51
  if (! pw) {
#line 52
    fatal("Unknown user %100s.", user);
  }
#line 55
  if (! cp) {
#line 57
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 57
    return (tmp___2);
  }
#line 60
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 60
  tmp___4 = strlen(cp + 1);
#line 60
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 61
  if (len > 4096) {
#line 62
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 63
  tmp___5 = xmalloc((unsigned int )len);
#line 63
  expanded = (char *)tmp___5;
#line 64
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 65
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 184 "packet.h"
void tty_make_modes(int fd ) ;
#line 187
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 26 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 29
  switch ((int )speed) {
  case 0: 
#line 31
  return (0);
  case 1: 
#line 33
  return (50);
  case 2: 
#line 35
  return (75);
  case 3: 
#line 37
  return (110);
  case 4: 
#line 39
  return (134);
  case 5: 
#line 41
  return (150);
  case 6: 
#line 43
  return (200);
  case 7: 
#line 45
  return (300);
  case 8: 
#line 47
  return (600);
  case 9: 
#line 49
  return (1200);
  case 10: 
#line 51
  return (1800);
  case 11: 
#line 53
  return (2400);
  case 12: 
#line 55
  return (4800);
  case 13: 
#line 57
  return (9600);
  case 14: 
#line 61
  return (19200);
  case 15: 
#line 71
  return (38400);
  case 4097: 
#line 93
  return (57600);
  case 4098: 
#line 101
  return (115200);
  case 4099: 
#line 105
  return (230400);
  default: ;
#line 108
  return (9600);
  }
}
}
#line 115 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 118
  switch (baud) {
  case 0: 
#line 120
  return (0U);
  case 50: 
#line 122
  return (1U);
  case 75: 
#line 124
  return (2U);
  case 110: 
#line 126
  return (3U);
  case 134: 
#line 128
  return (4U);
  case 150: 
#line 130
  return (5U);
  case 200: 
#line 132
  return (6U);
  case 300: 
#line 134
  return (7U);
  case 600: 
#line 136
  return (8U);
  case 1200: 
#line 138
  return (9U);
  case 1800: 
#line 140
  return (10U);
  case 2400: 
#line 142
  return (11U);
  case 4800: 
#line 144
  return (12U);
  case 9600: 
#line 146
  return (13U);
  case 19200: 
#line 150
  return (14U);
  case 38400: 
#line 160
  return (15U);
  case 57600: 
#line 182
  return (4097U);
  case 115200: 
#line 190
  return (4098U);
  case 230400: 
#line 194
  return (4099U);
  default: ;
#line 197
  return (13U);
  }
}
}
#line 206 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 212
  tmp___1 = tcgetattr(fd, & tio);
#line 212
  if (tmp___1 < 0) {
#line 213
    packet_put_char(0);
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    log("tcgetattr: %.100s", tmp___0);
#line 215
    return;
  }
#line 218
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 218
  baud = speed_to_baud(tmp___2);
#line 219
  packet_put_char(193);
#line 220
  packet_put_int((unsigned int )baud);
#line 221
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 221
  baud = speed_to_baud(tmp___3);
#line 222
  packet_put_char(192);
#line 223
  packet_put_int((unsigned int )baud);
#line 37 "ttymodes.h"
  packet_put_char(1);
#line 37
  packet_put_char((int )tio.c_cc[0]);
#line 38
  packet_put_char(2);
#line 38
  packet_put_char((int )tio.c_cc[1]);
#line 39
  packet_put_char(3);
#line 39
  packet_put_char((int )tio.c_cc[2]);
#line 41
  packet_put_char(4);
#line 41
  packet_put_char((int )tio.c_cc[3]);
#line 43
  packet_put_char(5);
#line 43
  packet_put_char((int )tio.c_cc[4]);
#line 45
  packet_put_char(6);
#line 45
  packet_put_char((int )tio.c_cc[11]);
#line 48
  packet_put_char(7);
#line 48
  packet_put_char((int )tio.c_cc[16]);
#line 50
  packet_put_char(8);
#line 50
  packet_put_char((int )tio.c_cc[8]);
#line 51
  packet_put_char(9);
#line 51
  packet_put_char((int )tio.c_cc[9]);
#line 53
  packet_put_char(10);
#line 53
  packet_put_char((int )tio.c_cc[10]);
#line 59
  packet_put_char(12);
#line 59
  packet_put_char((int )tio.c_cc[12]);
#line 62
  packet_put_char(13);
#line 62
  packet_put_char((int )tio.c_cc[14]);
#line 65
  packet_put_char(14);
#line 65
  packet_put_char((int )tio.c_cc[15]);
#line 77
  packet_put_char(18);
#line 77
  packet_put_char((int )tio.c_cc[13]);
#line 81
  packet_put_char(30);
#line 81
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 82
  packet_put_char(31);
#line 82
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 83
  packet_put_char(32);
#line 83
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 84
  packet_put_char(33);
#line 84
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 85
  packet_put_char(34);
#line 85
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 86
  packet_put_char(35);
#line 86
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 87
  packet_put_char(36);
#line 87
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 89
  packet_put_char(37);
#line 89
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 91
  packet_put_char(38);
#line 91
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 92
  packet_put_char(39);
#line 92
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 93
  packet_put_char(40);
#line 93
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 95
  packet_put_char(41);
#line 95
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 98
  packet_put_char(50);
#line 98
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 99
  packet_put_char(51);
#line 99
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 101
  packet_put_char(52);
#line 101
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 103
  packet_put_char(53);
#line 103
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 104
  packet_put_char(54);
#line 104
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 105
  packet_put_char(55);
#line 105
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 106
  packet_put_char(56);
#line 106
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 107
  packet_put_char(57);
#line 107
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 108
  packet_put_char(58);
#line 108
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 110
  packet_put_char(59);
#line 110
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 113
  packet_put_char(60);
#line 113
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 116
  packet_put_char(61);
#line 116
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 119
  packet_put_char(62);
#line 119
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 122
  packet_put_char(70);
#line 122
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 124
  packet_put_char(71);
#line 124
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 126
  packet_put_char(72);
#line 126
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 128
  packet_put_char(73);
#line 128
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 131
  packet_put_char(74);
#line 131
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 134
  packet_put_char(75);
#line 134
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 137
  packet_put_char(90);
#line 137
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 138
  packet_put_char(91);
#line 138
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 139
  packet_put_char(92);
#line 139
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 140
  packet_put_char(93);
#line 140
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 243 "ttymodes.c"
  packet_put_char(0);
#line 244
  return;
}
}
#line 250 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 255
  n_bytes = 0;
#line 256
  failure = 0;
#line 263
  tmp = tcgetattr(fd, & tio);
#line 263
  if (tmp < 0) {
#line 264
    failure = -1;
  }
#line 266
  while (1) {
#line 267
    n_bytes ++;
#line 268
    tmp___0 = packet_get_char();
#line 268
    opcode = (int )tmp___0;
#line 269
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 274
    n_bytes += 4;
#line 275
    tmp___1 = packet_get_int();
#line 275
    baud = (int )tmp___1;
#line 276
    if (failure != -1) {
#line 276
      tmp___2 = baud_to_speed(baud);
#line 276
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 276
      if (tmp___3 < 0) {
#line 277
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 278
    break;
    case 193: 
#line 281
    n_bytes += 4;
#line 282
    tmp___4 = packet_get_int();
#line 282
    baud = (int )tmp___4;
#line 283
    if (failure != -1) {
#line 283
      tmp___5 = baud_to_speed(baud);
#line 283
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 283
      if (tmp___6 < 0) {
#line 284
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 285
    break;
    case 1: 
#line 37 "ttymodes.h"
    n_bytes ++;
#line 37
    tmp___7 = packet_get_char();
#line 37
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 37
    break;
    case 2: 
#line 38
    n_bytes ++;
#line 38
    tmp___8 = packet_get_char();
#line 38
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 38
    break;
    case 3: 
#line 39
    n_bytes ++;
#line 39
    tmp___9 = packet_get_char();
#line 39
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 39
    break;
    case 4: 
#line 41
    n_bytes ++;
#line 41
    tmp___10 = packet_get_char();
#line 41
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 41
    break;
    case 5: 
#line 43
    n_bytes ++;
#line 43
    tmp___11 = packet_get_char();
#line 43
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 43
    break;
    case 6: 
#line 45
    n_bytes ++;
#line 45
    tmp___12 = packet_get_char();
#line 45
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 45
    break;
    case 7: 
#line 48
    n_bytes ++;
#line 48
    tmp___13 = packet_get_char();
#line 48
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 48
    break;
    case 8: 
#line 50
    n_bytes ++;
#line 50
    tmp___14 = packet_get_char();
#line 50
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 50
    break;
    case 9: 
#line 51
    n_bytes ++;
#line 51
    tmp___15 = packet_get_char();
#line 51
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 51
    break;
    case 10: 
#line 53
    n_bytes ++;
#line 53
    tmp___16 = packet_get_char();
#line 53
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 53
    break;
    case 12: 
#line 59
    n_bytes ++;
#line 59
    tmp___17 = packet_get_char();
#line 59
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 59
    break;
    case 13: 
#line 62
    n_bytes ++;
#line 62
    tmp___18 = packet_get_char();
#line 62
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 62
    break;
    case 14: 
#line 65
    n_bytes ++;
#line 65
    tmp___19 = packet_get_char();
#line 65
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 65
    break;
    case 18: 
#line 77
    n_bytes ++;
#line 77
    tmp___20 = packet_get_char();
#line 77
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 77
    break;
    case 30: 
#line 81
    n_bytes ++;
#line 81
    tmp___21 = packet_get_char();
#line 81
    if (tmp___21) {
#line 81
      tio.c_iflag |= 4U;
    } else {
#line 81
      tio.c_iflag &= 4294967291U;
    }
#line 81
    break;
    case 31: 
#line 82
    n_bytes ++;
#line 82
    tmp___22 = packet_get_char();
#line 82
    if (tmp___22) {
#line 82
      tio.c_iflag |= 8U;
    } else {
#line 82
      tio.c_iflag &= 4294967287U;
    }
#line 82
    break;
    case 32: 
#line 83
    n_bytes ++;
#line 83
    tmp___23 = packet_get_char();
#line 83
    if (tmp___23) {
#line 83
      tio.c_iflag |= 16U;
    } else {
#line 83
      tio.c_iflag &= 4294967279U;
    }
#line 83
    break;
    case 33: 
#line 84
    n_bytes ++;
#line 84
    tmp___24 = packet_get_char();
#line 84
    if (tmp___24) {
#line 84
      tio.c_iflag |= 32U;
    } else {
#line 84
      tio.c_iflag &= 4294967263U;
    }
#line 84
    break;
    case 34: 
#line 85
    n_bytes ++;
#line 85
    tmp___25 = packet_get_char();
#line 85
    if (tmp___25) {
#line 85
      tio.c_iflag |= 64U;
    } else {
#line 85
      tio.c_iflag &= 4294967231U;
    }
#line 85
    break;
    case 35: 
#line 86
    n_bytes ++;
#line 86
    tmp___26 = packet_get_char();
#line 86
    if (tmp___26) {
#line 86
      tio.c_iflag |= 128U;
    } else {
#line 86
      tio.c_iflag &= 4294967167U;
    }
#line 86
    break;
    case 36: 
#line 87
    n_bytes ++;
#line 87
    tmp___27 = packet_get_char();
#line 87
    if (tmp___27) {
#line 87
      tio.c_iflag |= 256U;
    } else {
#line 87
      tio.c_iflag &= 4294967039U;
    }
#line 87
    break;
    case 37: 
#line 89
    n_bytes ++;
#line 89
    tmp___28 = packet_get_char();
#line 89
    if (tmp___28) {
#line 89
      tio.c_iflag |= 512U;
    } else {
#line 89
      tio.c_iflag &= 4294966783U;
    }
#line 89
    break;
    case 38: 
#line 91
    n_bytes ++;
#line 91
    tmp___29 = packet_get_char();
#line 91
    if (tmp___29) {
#line 91
      tio.c_iflag |= 1024U;
    } else {
#line 91
      tio.c_iflag &= 4294966271U;
    }
#line 91
    break;
    case 39: 
#line 92
    n_bytes ++;
#line 92
    tmp___30 = packet_get_char();
#line 92
    if (tmp___30) {
#line 92
      tio.c_iflag |= 2048U;
    } else {
#line 92
      tio.c_iflag &= 4294965247U;
    }
#line 92
    break;
    case 40: 
#line 93
    n_bytes ++;
#line 93
    tmp___31 = packet_get_char();
#line 93
    if (tmp___31) {
#line 93
      tio.c_iflag |= 4096U;
    } else {
#line 93
      tio.c_iflag &= 4294963199U;
    }
#line 93
    break;
    case 41: 
#line 95
    n_bytes ++;
#line 95
    tmp___32 = packet_get_char();
#line 95
    if (tmp___32) {
#line 95
      tio.c_iflag |= 8192U;
    } else {
#line 95
      tio.c_iflag &= 4294959103U;
    }
#line 95
    break;
    case 50: 
#line 98
    n_bytes ++;
#line 98
    tmp___33 = packet_get_char();
#line 98
    if (tmp___33) {
#line 98
      tio.c_lflag |= 1U;
    } else {
#line 98
      tio.c_lflag &= 4294967294U;
    }
#line 98
    break;
    case 51: 
#line 99
    n_bytes ++;
#line 99
    tmp___34 = packet_get_char();
#line 99
    if (tmp___34) {
#line 99
      tio.c_lflag |= 2U;
    } else {
#line 99
      tio.c_lflag &= 4294967293U;
    }
#line 99
    break;
    case 52: 
#line 101
    n_bytes ++;
#line 101
    tmp___35 = packet_get_char();
#line 101
    if (tmp___35) {
#line 101
      tio.c_lflag |= 4U;
    } else {
#line 101
      tio.c_lflag &= 4294967291U;
    }
#line 101
    break;
    case 53: 
#line 103
    n_bytes ++;
#line 103
    tmp___36 = packet_get_char();
#line 103
    if (tmp___36) {
#line 103
      tio.c_lflag |= 8U;
    } else {
#line 103
      tio.c_lflag &= 4294967287U;
    }
#line 103
    break;
    case 54: 
#line 104
    n_bytes ++;
#line 104
    tmp___37 = packet_get_char();
#line 104
    if (tmp___37) {
#line 104
      tio.c_lflag |= 16U;
    } else {
#line 104
      tio.c_lflag &= 4294967279U;
    }
#line 104
    break;
    case 55: 
#line 105
    n_bytes ++;
#line 105
    tmp___38 = packet_get_char();
#line 105
    if (tmp___38) {
#line 105
      tio.c_lflag |= 32U;
    } else {
#line 105
      tio.c_lflag &= 4294967263U;
    }
#line 105
    break;
    case 56: 
#line 106
    n_bytes ++;
#line 106
    tmp___39 = packet_get_char();
#line 106
    if (tmp___39) {
#line 106
      tio.c_lflag |= 64U;
    } else {
#line 106
      tio.c_lflag &= 4294967231U;
    }
#line 106
    break;
    case 57: 
#line 107
    n_bytes ++;
#line 107
    tmp___40 = packet_get_char();
#line 107
    if (tmp___40) {
#line 107
      tio.c_lflag |= 128U;
    } else {
#line 107
      tio.c_lflag &= 4294967167U;
    }
#line 107
    break;
    case 58: 
#line 108
    n_bytes ++;
#line 108
    tmp___41 = packet_get_char();
#line 108
    if (tmp___41) {
#line 108
      tio.c_lflag |= 256U;
    } else {
#line 108
      tio.c_lflag &= 4294967039U;
    }
#line 108
    break;
    case 59: 
#line 110
    n_bytes ++;
#line 110
    tmp___42 = packet_get_char();
#line 110
    if (tmp___42) {
#line 110
      tio.c_lflag |= 32768U;
    } else {
#line 110
      tio.c_lflag &= 4294934527U;
    }
#line 110
    break;
    case 60: 
#line 113
    n_bytes ++;
#line 113
    tmp___43 = packet_get_char();
#line 113
    if (tmp___43) {
#line 113
      tio.c_lflag |= 512U;
    } else {
#line 113
      tio.c_lflag &= 4294966783U;
    }
#line 113
    break;
    case 61: 
#line 116
    n_bytes ++;
#line 116
    tmp___44 = packet_get_char();
#line 116
    if (tmp___44) {
#line 116
      tio.c_lflag |= 2048U;
    } else {
#line 116
      tio.c_lflag &= 4294965247U;
    }
#line 116
    break;
    case 62: 
#line 119
    n_bytes ++;
#line 119
    tmp___45 = packet_get_char();
#line 119
    if (tmp___45) {
#line 119
      tio.c_lflag |= 16384U;
    } else {
#line 119
      tio.c_lflag &= 4294950911U;
    }
#line 119
    break;
    case 70: 
#line 122
    n_bytes ++;
#line 122
    tmp___46 = packet_get_char();
#line 122
    if (tmp___46) {
#line 122
      tio.c_oflag |= 1U;
    } else {
#line 122
      tio.c_oflag &= 4294967294U;
    }
#line 122
    break;
    case 71: 
#line 124
    n_bytes ++;
#line 124
    tmp___47 = packet_get_char();
#line 124
    if (tmp___47) {
#line 124
      tio.c_oflag |= 2U;
    } else {
#line 124
      tio.c_oflag &= 4294967293U;
    }
#line 124
    break;
    case 72: 
#line 126
    n_bytes ++;
#line 126
    tmp___48 = packet_get_char();
#line 126
    if (tmp___48) {
#line 126
      tio.c_oflag |= 4U;
    } else {
#line 126
      tio.c_oflag &= 4294967291U;
    }
#line 126
    break;
    case 73: 
#line 128
    n_bytes ++;
#line 128
    tmp___49 = packet_get_char();
#line 128
    if (tmp___49) {
#line 128
      tio.c_oflag |= 8U;
    } else {
#line 128
      tio.c_oflag &= 4294967287U;
    }
#line 128
    break;
    case 74: 
#line 131
    n_bytes ++;
#line 131
    tmp___50 = packet_get_char();
#line 131
    if (tmp___50) {
#line 131
      tio.c_oflag |= 16U;
    } else {
#line 131
      tio.c_oflag &= 4294967279U;
    }
#line 131
    break;
    case 75: 
#line 134
    n_bytes ++;
#line 134
    tmp___51 = packet_get_char();
#line 134
    if (tmp___51) {
#line 134
      tio.c_oflag |= 32U;
    } else {
#line 134
      tio.c_oflag &= 4294967263U;
    }
#line 134
    break;
    case 90: 
#line 137
    n_bytes ++;
#line 137
    tmp___52 = packet_get_char();
#line 137
    if (tmp___52) {
#line 137
      tio.c_cflag |= 32U;
    } else {
#line 137
      tio.c_cflag &= 4294967263U;
    }
#line 137
    break;
    case 91: 
#line 138
    n_bytes ++;
#line 138
    tmp___53 = packet_get_char();
#line 138
    if (tmp___53) {
#line 138
      tio.c_cflag |= 48U;
    } else {
#line 138
      tio.c_cflag &= 4294967247U;
    }
#line 138
    break;
    case 92: 
#line 139
    n_bytes ++;
#line 139
    tmp___54 = packet_get_char();
#line 139
    if (tmp___54) {
#line 139
      tio.c_cflag |= 256U;
    } else {
#line 139
      tio.c_cflag &= 4294967039U;
    }
#line 139
    break;
    case 93: 
#line 140
    n_bytes ++;
#line 140
    tmp___55 = packet_get_char();
#line 140
    if (tmp___55) {
#line 140
      tio.c_cflag |= 512U;
    } else {
#line 140
      tio.c_cflag &= 4294966783U;
    }
#line 140
    break;
    default: 
#line 313 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 320
        n_bytes ++;
#line 321
        packet_get_char();
#line 322
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 329
          n_bytes += 4;
#line 330
          packet_get_int();
#line 331
          break;
        }
      }
    }
#line 341
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 342
    while (1) {
#line 342
      _p = 0;
#line 342
      _e = 1;
#line 342
      if (_p != _e) {
#line 342
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 342);
#line 342
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 342
      break;
    }
    goto set;
    }
  }
  set: 
#line 348
  if (*n_bytes_ptr != n_bytes) {
#line 349
    *n_bytes_ptr = n_bytes;
#line 350
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 34 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 33 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 41 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 46
  saved_euid = geteuid();
#line 49
  tmp___1 = seteuid(uid);
#line 49
  if (tmp___1 == -1) {
#line 50
    tmp = __errno_location();
#line 50
    tmp___0 = strerror(*tmp);
#line 50
    debug("seteuid %d: %.100s", (int )uid, tmp___0);
  }
#line 60
  return;
}
}
#line 65 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 70
  tmp___1 = seteuid(saved_euid);
#line 70
  if (tmp___1 < 0) {
#line 71
    tmp = __errno_location();
#line 71
    tmp___0 = strerror(*tmp);
#line 71
    debug("seteuid %d: %.100s", (int )saved_euid, tmp___0);
  }
#line 80
  return;
}
}
#line 86 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 97
  tmp___1 = setuid(uid);
#line 97
  if (tmp___1 < 0) {
#line 98
    tmp = __errno_location();
#line 98
    tmp___0 = strerror(*tmp);
#line 98
    debug("setuid %d: %.100s", (int )uid, tmp___0);
  }
#line 99
  return;
}
}
#line 1 "uuencode.o"
#line 8 "bsd-base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 10
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 9 "uuencode.c"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 13
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 13
  return (tmp);
}
}
#line 16 "uuencode.c"
int uudecode(char const   *src , unsigned char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 23
  encoded = xstrdup(src);
#line 25
  p = encoded;
#line 25
  while (1) {
#line 25
    if (! ((int )*p == 32)) {
#line 25
      if (! ((int )*p == 9)) {
#line 25
        break;
      }
    }
#line 25
    p ++;
  }
#line 27
  while (1) {
#line 27
    if ((int )*p != 0) {
#line 27
      if ((int )*p != 32) {
#line 27
        if (! ((int )*p != 9)) {
#line 27
          break;
        }
      } else {
#line 27
        break;
      }
    } else {
#line 27
      break;
    }
#line 27
    p ++;
  }
#line 30
  *p = (char )'\000';
#line 31
  len = b64_pton((char const   *)encoded, target, targsize);
#line 32
  xfree((void *)encoded);
#line 33
  return (len);
}
}
#line 36 "uuencode.c"
void dump_base64(FILE *fp , unsigned char *data , int len ) 
{ unsigned char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 39
  tmp = xmalloc((unsigned int )(2 * len));
#line 39
  buf___1 = (unsigned char *)tmp;
#line 41
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___1, (unsigned int )(2 * len));
#line 42
  i = 0;
#line 42
  while (i < n___0) {
#line 43
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 44
    if (i % 70 == 69) {
#line 45
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 42
    i ++;
  }
#line 47
  if (i % 70 != 69) {
#line 48
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 49
  xfree((void *)buf___1);
#line 50
  return;
}
}
#line 1 "xmalloc.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 15 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 18
  tmp = malloc(size);
#line 18
  ptr = tmp;
#line 19
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 20
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 21
  return (ptr);
}
}
#line 24 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 31
  new_ptr = realloc(ptr, new_size);
#line 32
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 33
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 34
  return (new_ptr);
}
}
#line 37 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 40
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 41
    fatal("xfree: NULL pointer given as argument");
  }
#line 42
  free(ptr);
#line 43
  return;
}
}
#line 45 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 48
  tmp = strlen(str);
#line 48
  len = (int )(tmp + 1U);
#line 50
  tmp___0 = xmalloc((unsigned int )len);
#line 50
  cp = (char *)tmp___0;
#line 51
  strlcpy(cp, str, (unsigned int )len);
#line 52
  return (cp);
}
}
#line 1 "bsd-base64.o"
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 65 "bsd-base64.c"
static char const   Base64[65]  = 
#line 65 "bsd-base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "bsd-base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "bsd-base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "bsd-base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bsd-bindresvport.o"
#line 7 "bsd-bindresvport.h"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) ;
#line 53 "bsd-bindresvport.c"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) 
{ int error___0 ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  int salen ;
  int i ;
  int *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 68
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 69
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 70
    sa = (struct sockaddr *)(& myaddr);
  }
#line 73
  if (af == 2) {
#line 74
    sin = (struct sockaddr_in *)sa;
#line 75
    salen = (int )sizeof(struct sockaddr_in );
#line 76
    portp = & sin->sin_port;
  } else {
#line 77
    if (af == 10) {
#line 78
      sin6 = (struct sockaddr_in6 *)sa;
#line 79
      salen = (int )sizeof(struct sockaddr_in6 );
#line 80
      portp = & sin6->sin6_port;
    } else {
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 96;
#line 83
      return (-1);
    }
  }
#line 85
  sa->sa_family = (unsigned short )af;
#line 87
  __x = *portp;
#line 87
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 87
  port = __v;
#line 88
  if ((int )port == 0) {
#line 89
    tmp___0 = arc4random();
#line 89
    port = (unsigned short )(tmp___0 % 424U + 600U);
  }
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  *)sa, (unsigned int )salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___1 = __errno_location();
#line 101
      if (! (*tmp___1 == 98)) {
#line 101
        tmp___2 = __errno_location();
#line 101
        if (! (*tmp___2 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port = (u_int16_t )((int )port + 1);
#line 105
    if ((int )port > 1023) {
#line 106
      port = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "bsd-daemon.o"
#line 1 "bsd-inet_aton.o"
#line 1 "bsd-misc.o"
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 37 "bsd-misc.h"
void arc4random_stir(void) ;
#line 41
void setproctitle(char const   *fmt  , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 61 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) ;
#line 62
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) ;
#line 64 "bsd-misc.c"
static rc4_t *rc4  =    (rc4_t *)((void *)0);
#line 66 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) 
{ int t ;

  {
#line 70
  r->i = 0;
#line 70
  while (r->i < 256) {
#line 71
    r->s[r->i] = (unsigned int )r->i;
#line 70
    (r->i) ++;
  }
#line 73
  r->j = 0;
#line 74
  r->i = 0;
#line 74
  while (r->i < 256) {
#line 76
    r->j = (int )((((unsigned int )r->j + r->s[r->i]) + (unsigned int )*(key + r->i % len)) % 256U);
#line 77
    t = (int )r->s[r->i];
#line 78
    r->s[r->i] = r->s[r->j];
#line 79
    r->s[r->j] = (unsigned int )t;
#line 74
    (r->i) ++;
  }
#line 81
  r->j = 0;
#line 81
  r->i = r->j;
#line 82
  return;
}
}
#line 84 "bsd-misc.c"
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) 
{ int t ;
  int c ;

  {
#line 89
  c = 0;
#line 90
  while (c < len) {
#line 92
    r->i = (r->i + 1) % 256;
#line 93
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 94
    t = (int )r->s[r->i];
#line 95
    r->s[r->i] = r->s[r->j];
#line 96
    r->s[r->j] = (unsigned int )t;
#line 98
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 100
    *(buffer + c) = (unsigned char )r->s[t];
#line 101
    c ++;
  }
#line 103
  return;
}
}
#line 105 "bsd-misc.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 109
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 110
    arc4random_stir();
  }
#line 112
  rc4_getbytes(rc4, (unsigned char *)(& r), (int )sizeof(r));
#line 114
  return (r);
}
}
#line 117 "bsd-misc.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[32] ;
  void *tmp ;

  {
#line 121
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 122
    tmp = xmalloc(sizeof(*rc4));
#line 122
    rc4 = (rc4_t *)tmp;
  }
#line 124
  seed_rng();
#line 125
  RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 127
  rc4_key(rc4, rand_buf, (int )sizeof(rand_buf));
#line 128
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 129
  return;
}
}
#line 133 "bsd-misc.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 136
  return;
}
}
#line 140
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 140 "bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 142
  return (0);
}
}
#line 1 "bsd-mktemp.o"
#line 1 "bsd-rresvport.o"
#line 1 "bsd-setenv.o"
#line 1 "bsd-sigaction.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-strlcat.o"
#line 46 "bsd-strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "bsd-strlcpy.o"
#line 45 "bsd-strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "bsd-strsep.o"
#line 1 "fake-getaddrinfo.o"
#line 1 "fake-getnameinfo.o"
#line 1 "next-posix.o"
#line 1 "sshd.o"
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 452 "ssh.h"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 7 "auth-pam.h"
void finish_pam(void) ;
#line 110 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 116
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 119
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 4 "auth.h"
void do_authentication(void) ;
#line 5
void do_authentication2(void) ;
#line 9 "myproposal.h"
static char *myproposal[10]  = 
#line 9 "myproposal.h"
  {      (char *)"diffie-hellman-group1-sha1",      (char *)"ssh-dss",      (char *)"3des-cbc,blowfish-cbc,arcfour,cast128-cbc",      (char *)"3des-cbc,blowfish-cbc,arcfour,cast128-cbc", 
        (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      (char *)"zlib,none",      (char *)"zlib,none", 
        (char *)"",      (char *)""};
#line 57 "sshd.c"
ServerOptions options  ;
#line 60 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 69 "sshd.c"
int IPv4or6  =    0;
#line 78 "sshd.c"
int debug_flag  =    0;
#line 81 "sshd.c"
int inetd_flag  =    0;
#line 84 "sshd.c"
int log_stderr  =    0;
#line 87 "sshd.c"
char *av0  ;
#line 90 "sshd.c"
char **saved_argv  ;
#line 91 "sshd.c"
int saved_argc  ;
#line 98 "sshd.c"
int listen_socks[16]  ;
#line 99 "sshd.c"
int num_listen_socks  =    0;
#line 105 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 106 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 116 "sshd.c"
struct __anonstruct_sensitive_data_76 sensitive_data  ;
#line 126 "sshd.c"
int key_used  =    0;
#line 129 "sshd.c"
int received_sighup  =    0;
#line 133 "sshd.c"
RSA *public_key  ;
#line 136 "sshd.c"
unsigned char session_id[16]  ;
#line 139 "sshd.c"
unsigned char *session_id2  =    (unsigned char *)((void *)0);
#line 140 "sshd.c"
int session_id2_len  =    0;
#line 143
void do_ssh1_kex(void) ;
#line 144
void do_ssh2_kex(void) ;
#line 149 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 153
  i = 0;
#line 153
  while (i < num_listen_socks) {
#line 154
    close(listen_socks[i]);
#line 153
    i ++;
  }
#line 155
  num_listen_socks = -1;
#line 156
  return;
}
}
#line 163 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 166
  received_sighup = 1;
#line 167
  signal(1, & sighup_handler);
#line 168
  return;
}
}
#line 174 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 177
  log("Received SIGHUP; restarting.");
#line 178
  close_listen_socks();
#line 179
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 180
  tmp = __errno_location();
#line 180
  tmp___0 = strerror(*tmp);
#line 180
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 181
  exit(1);
}
}
#line 189 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 192
  log("Received signal %d; terminating.", sig);
#line 193
  close_listen_socks();
#line 194
  unlink((char const   *)options.pid_file);
#line 195
  exit(255);
}
}
#line 202 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 205
  tmp = __errno_location();
#line 205
  save_errno = *tmp;
#line 208
  while (1) {
#line 208
    tmp___0 = waitpid(-1, & status, 1);
#line 208
    if (! (tmp___0 > 0)) {
#line 208
      break;
    }
  }
#line 211
  signal(17, & main_sigchld_handler);
#line 212
  tmp___1 = __errno_location();
#line 212
  *tmp___1 = save_errno;
#line 213
  return;
}
}
#line 218 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 222
  packet_close();
#line 225
  tmp = get_remote_ipaddr();
#line 225
  fatal("Timeout before authentication for %s.", tmp);
#line 226
  return;
}
}
#line 236 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 239
  tmp = __errno_location();
#line 239
  save_errno = *tmp;
#line 242
  if (key_used) {
#line 244
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 246
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 247
      RSA_free(sensitive_data.private_key);
    }
#line 248
    sensitive_data.private_key = RSA_new();
#line 250
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 251
      RSA_free(public_key);
    }
#line 252
    public_key = RSA_new();
#line 254
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 256
    arc4random_stir();
#line 257
    key_used = 0;
#line 258
    log("RSA key generation complete.");
  }
#line 261
  signal(14, & key_regeneration_alarm);
#line 262
  alarm((unsigned int )options.key_regeneration_time);
#line 263
  tmp___0 = __errno_location();
#line 263
  *tmp___0 = save_errno;
#line 264
  return;
}
}
#line 266 "sshd.c"
void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;

  {
#line 276
  if (options.protocol & 1) {
#line 276
    if (options.protocol & 4) {
#line 278
      major = 1;
#line 279
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 280
    if (options.protocol & 4) {
#line 281
      major = 2;
#line 282
      minor = 0;
    } else {
#line 284
      major = 1;
#line 285
      minor = 5;
    }
  }
#line 287
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_2.1.1");
#line 288
  server_version_string = xstrdup((char const   *)(buf___1));
#line 290
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 292
    tmp___0 = strlen((char const   *)server_version_string);
#line 292
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 292
    tmp___2 = strlen((char const   *)server_version_string);
#line 292
    if ((size_t )tmp___1 != tmp___2) {
#line 294
      tmp = get_remote_ipaddr();
#line 294
      log("Could not write ident string to %s.", tmp);
#line 295
      fatal_cleanup();
    }
#line 299
    i = 0;
#line 299
    while ((unsigned int )i < sizeof(buf___1) - 1U) {
#line 300
      tmp___4 = atomicio((ssize_t (*)())(& read), sock_in, (void *)(& buf___1[i]),
                         1U);
#line 300
      if (tmp___4 != 1) {
#line 301
        tmp___3 = get_remote_ipaddr();
#line 301
        log("Did not receive ident string from %s.", tmp___3);
#line 302
        fatal_cleanup();
      }
#line 304
      if ((int )buf___1[i] == 13) {
#line 305
        buf___1[i] = (char )'\n';
#line 306
        buf___1[i + 1] = (char)0;
        goto __Cont;
      }
#line 309
      if ((int )buf___1[i] == 10) {
#line 311
        buf___1[i + 1] = (char)0;
#line 312
        break;
      }
      __Cont: /* CIL Label */ 
#line 299
      i ++;
    }
#line 315
    buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 316
    client_version_string = xstrdup((char const   *)(buf___1));
  }
#line 323
  tmp___7 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                   & remote_major, & remote_minor, remote_version);
#line 323
  if (tmp___7 != 3) {
#line 325
    s = (char *)"Protocol mismatch.\n";
#line 326
    tmp___5 = strlen((char const   *)s);
#line 326
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___5);
#line 327
    close(sock_in);
#line 328
    close(sock_out);
#line 329
    tmp___6 = get_remote_ipaddr();
#line 329
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___6);
#line 331
    fatal_cleanup();
  }
#line 333
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 336
  compat_datafellows((char const   *)(remote_version));
#line 338
  mismatch = 0;
#line 339
  switch (remote_major) {
  case 1: 
#line 341
  if (remote_minor == 99) {
#line 342
    if (options.protocol & 4) {
#line 343
      enable_compat20();
    } else {
#line 345
      mismatch = 1;
    }
#line 346
    break;
  }
#line 348
  if (! (options.protocol & 1)) {
#line 349
    mismatch = 1;
#line 350
    break;
  }
#line 352
  if (remote_minor < 3) {
#line 353
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 355
    if (remote_minor == 3) {
#line 357
      enable_compat13();
    }
  }
#line 359
  break;
  case 2: 
#line 361
  if (options.protocol & 4) {
#line 362
    enable_compat20();
#line 363
    break;
  }
  default: 
#line 367
  mismatch = 1;
#line 368
  break;
  }
#line 370
  chop(server_version_string);
#line 371
  chop(client_version_string);
#line 372
  debug("Local version string %.200s", server_version_string);
#line 374
  if (mismatch) {
#line 375
    s = (char *)"Protocol major versions differ.\n";
#line 376
    tmp___8 = strlen((char const   *)s);
#line 376
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___8);
#line 377
    close(sock_in);
#line 378
    close(sock_out);
#line 379
    tmp___9 = get_remote_ipaddr();
#line 379
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___9, server_version_string,
        client_version_string);
#line 382
    fatal_cleanup();
  }
#line 384
  if (compat20) {
#line 385
    packet_set_ssh2_format();
  }
#line 386
  return;
}
}
#line 389 "sshd.c"
void destroy_sensitive_data(void) 
{ 

  {
#line 393
  if (public_key) {
#line 394
    RSA_free(public_key);
  }
#line 395
  if (sensitive_data.private_key) {
#line 396
    RSA_free(sensitive_data.private_key);
  }
#line 397
  if (sensitive_data.host_key) {
#line 398
    RSA_free(sensitive_data.host_key);
  }
#line 399
  if ((unsigned int )sensitive_data.dsa_host_key != (unsigned int )((void *)0)) {
#line 400
    key_free(sensitive_data.dsa_host_key);
  }
#line 401
  return;
}
}
#line 403 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 404 "sshd.c"
int startup_pipe  ;
#line 409 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  int silent ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  char *tmp ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Key k ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int fd ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int s1 ;
  int s2 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  __pid_t tmp___31 ;
  void *tmp___32 ;
  void *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int *tmp___40 ;
  int *tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int *tmp___46 ;
  char *tmp___47 ;

  {
#line 414
  sock_in = 0;
#line 414
  sock_out = 0;
#line 414
  on = 1;
#line 417
  silent = 0;
#line 428
  startups = 0;
#line 430
  init_rng();
#line 433
  saved_argc = ac;
#line 434
  saved_argv = av;
#line 435
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 435
  if (tmp___1) {
#line 436
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 436
    av0 = tmp + 1;
  } else {
#line 438
    av0 = *(av + 0);
  }
#line 441
  initialize_server_options(& options);
#line 444
  while (1) {
#line 444
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:diqQ46");
#line 444
    if (! (opt != -1)) {
#line 444
      break;
    }
#line 445
    switch (opt) {
    case 52: 
#line 447
    IPv4or6 = 2;
#line 448
    break;
    case 54: 
#line 450
    IPv4or6 = 10;
#line 451
    break;
    case 102: 
#line 453
    config_file_name = optarg;
#line 454
    break;
    case 100: 
#line 456
    debug_flag = 1;
#line 457
    options.log_level = 5;
#line 458
    break;
    case 105: 
#line 460
    inetd_flag = 1;
#line 461
    break;
    case 81: 
#line 463
    silent = 1;
#line 464
    break;
    case 113: 
#line 466
    options.log_level = 0;
#line 467
    break;
    case 98: 
#line 469
    options.server_key_bits = atoi((char const   *)optarg);
#line 470
    break;
    case 112: 
#line 472
    options.ports_from_cmdline = 1U;
#line 473
    if (options.num_ports >= 256U) {
#line 474
      fatal("too many ports.\n");
    }
#line 475
    tmp___2 = options.num_ports;
#line 475
    (options.num_ports) ++;
#line 475
    tmp___3 = atoi((char const   *)optarg);
#line 475
    options.ports[tmp___2] = (unsigned short )tmp___3;
#line 476
    break;
    case 103: 
#line 478
    options.login_grace_time = atoi((char const   *)optarg);
#line 479
    break;
    case 107: 
#line 481
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 482
    break;
    case 104: 
#line 484
    options.host_key_file = optarg;
#line 485
    break;
    case 86: 
#line 487
    client_version_string = optarg;
#line 489
    inetd_flag = 1;
#line 490
    break;
    case 63: 
    default: 
#line 493
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH_2.1.1");
#line 494
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 495
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 496
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 497
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 498
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 499
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 500
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 501
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 502
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 503
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 504
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 506
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 507
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 508
    exit(1);
    }
  }
#line 516
  if (! silent) {
#line 516
    if (! inetd_flag) {
#line 516
      tmp___4 = 1;
    } else {
#line 516
      tmp___4 = 0;
    }
  } else {
#line 516
    tmp___4 = 0;
  }
#line 516
  if ((int )options.log_facility == -1) {
#line 516
    tmp___5 = 2;
  } else {
#line 516
    tmp___5 = (int )options.log_facility;
  }
#line 516
  if ((int )options.log_level == -1) {
#line 516
    tmp___6 = 3;
  } else {
#line 516
    tmp___6 = (int )options.log_level;
  }
#line 516
  log_init(av0, (enum __anonenum_LogLevel_73 )tmp___6, (enum __anonenum_SyslogFacility_72 )tmp___5,
           tmp___4);
#line 522
  read_server_config(& options, (char const   *)config_file_name);
#line 525
  fill_default_server_options(& options);
#line 528
  if (optind < ac) {
#line 529
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 530
    exit(1);
  }
#line 533
  debug("sshd version %.100s", "OpenSSH_2.1.1");
#line 535
  sensitive_data.dsa_host_key = (Key *)((void *)0);
#line 536
  sensitive_data.host_key = (RSA *)((void *)0);
#line 539
  if (options.protocol & 1) {
#line 539
    tmp___7 = rsa_alive();
#line 539
    if (tmp___7 == 0) {
#line 541
      log("no RSA support in libssl and libcrypto.  See ssl(8)");
#line 542
      log("Disabling protocol version 1");
#line 543
      options.protocol &= -2;
    }
  }
#line 546
  if (options.protocol & 1) {
#line 548
    sensitive_data.host_key = RSA_new();
#line 549
    k.type = 0;
#line 550
    k.rsa = sensitive_data.host_key;
#line 551
    tmp___8 = __errno_location();
#line 551
    *tmp___8 = 0;
#line 552
    tmp___11 = load_private_key((char const   *)options.host_key_file, "", & k, (char **)((void *)0));
#line 552
    if (! tmp___11) {
#line 553
      tmp___9 = __errno_location();
#line 553
      tmp___10 = strerror(*tmp___9);
#line 553
      error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___10);
#line 555
      log("Disabling protocol version 1");
#line 556
      options.protocol &= -2;
    }
#line 558
    k.rsa = (RSA *)((void *)0);
  }
#line 560
  if (options.protocol & 4) {
#line 561
    sensitive_data.dsa_host_key = key_new(1);
#line 562
    tmp___12 = load_private_key((char const   *)options.host_dsa_key_file, "", sensitive_data.dsa_host_key,
                                (char **)((void *)0));
#line 562
    if (! tmp___12) {
#line 564
      error("Could not load DSA host key: %.200s", options.host_dsa_key_file);
#line 565
      log("Disabling protocol version 2");
#line 566
      options.protocol &= -5;
    }
  }
#line 569
  if (! options.protocol & 5) {
#line 570
    if (silent == 0) {
#line 571
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd: no hostkeys available -- exiting.\n");
    }
#line 572
    log("sshd: no hostkeys available -- exiting.\n");
#line 573
    exit(1);
  }
#line 577
  if (options.protocol & 1) {
#line 578
    if (options.server_key_bits < 512) {
#line 580
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 581
      exit(1);
    } else {
#line 578
      if (options.server_key_bits > 32768) {
#line 580
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 581
        exit(1);
      }
    }
#line 588
    tmp___14 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 588
    if (options.server_key_bits > tmp___14 - 128) {
#line 588
      tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 588
      if (options.server_key_bits < tmp___15 + 128) {
#line 592
        tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 592
        options.server_key_bits = tmp___13 + 128;
#line 594
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 600
  if (debug_flag) {
#line 600
    if (! inetd_flag) {
#line 601
      log_stderr = 1;
    }
  }
#line 602
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 609
  if (! debug_flag) {
#line 609
    if (! inetd_flag) {
#line 613
      tmp___18 = daemon(0, 0);
#line 613
      if (tmp___18 < 0) {
#line 614
        tmp___16 = __errno_location();
#line 614
        tmp___17 = strerror(*tmp___16);
#line 614
        fatal("daemon() failed: %.200s", tmp___17);
      }
#line 618
      fd = open("/dev/tty", 258);
#line 619
      if (fd >= 0) {
#line 620
        ioctl(fd, 21538UL, (void *)0);
#line 621
        close(fd);
      }
    }
  }
#line 626
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 629
  rsa_set_verbose(0);
#line 632
  arc4random_stir();
#line 636
  chdir("/");
#line 639
  if (inetd_flag) {
#line 641
    s1 = dup(0);
#line 642
    s2 = dup(s1);
#line 643
    sock_in = dup(0);
#line 644
    sock_out = dup(1);
#line 650
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 652
    if (options.protocol & 1) {
#line 653
      public_key = RSA_new();
#line 654
      sensitive_data.private_key = RSA_new();
#line 655
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 656
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 658
      arc4random_stir();
#line 659
      log("RSA key generation complete.");
    }
  } else {
#line 662
    ai = options.listen_addrs;
#line 662
    while (ai) {
#line 663
      if (ai->ai_family != 2) {
#line 663
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 665
      if (num_listen_socks >= 16) {
#line 666
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 668
      tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 668
      if (tmp___19 != 0) {
#line 671
        error("getnameinfo failed");
        goto __Cont;
      }
#line 675
      listen_sock = socket(ai->ai_family, 1, 0);
#line 676
      if (listen_sock < 0) {
#line 678
        tmp___20 = __errno_location();
#line 678
        tmp___21 = strerror(*tmp___20);
#line 678
        verbose("socket: %.100s", tmp___21);
        goto __Cont;
      }
#line 681
      tmp___24 = fcntl(listen_sock, 4, 2048);
#line 681
      if (tmp___24 < 0) {
#line 682
        tmp___22 = __errno_location();
#line 682
        tmp___23 = strerror(*tmp___22);
#line 682
        error("listen_sock O_NONBLOCK: %s", tmp___23);
#line 683
        close(listen_sock);
        goto __Cont;
      }
#line 692
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 694
      linger.l_onoff = 1;
#line 695
      linger.l_linger = 5;
#line 696
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 699
      debug("Bind to port %s on %s.", strport, ntop);
#line 702
      tmp___27 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 702
      if (tmp___27 < 0) {
#line 702
        if (! ai->ai_next) {
#line 704
          tmp___25 = __errno_location();
#line 704
          tmp___26 = strerror(*tmp___25);
#line 704
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___26);
#line 706
          close(listen_sock);
          goto __Cont;
        }
      }
#line 709
      listen_socks[num_listen_socks] = listen_sock;
#line 710
      num_listen_socks ++;
#line 713
      log("Server listening on %s port %s.", ntop, strport);
#line 714
      tmp___30 = listen(listen_sock, 5);
#line 714
      if (tmp___30 < 0) {
#line 715
        tmp___28 = __errno_location();
#line 715
        tmp___29 = strerror(*tmp___28);
#line 715
        fatal("listen: %.100s", tmp___29);
      }
      __Cont: /* CIL Label */ 
#line 662
      ai = ai->ai_next;
    }
#line 718
    freeaddrinfo(options.listen_addrs);
#line 720
    if (! num_listen_socks) {
#line 721
      fatal("Cannot bind any address.");
    }
#line 723
    if (! debug_flag) {
#line 731
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"w");
#line 732
      if (f) {
#line 733
        tmp___31 = getpid();
#line 733
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___31);
#line 734
        fclose(f);
      }
    }
#line 737
    if (options.protocol & 1) {
#line 738
      public_key = RSA_new();
#line 739
      sensitive_data.private_key = RSA_new();
#line 741
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 742
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 744
      arc4random_stir();
#line 745
      log("RSA key generation complete.");
#line 748
      signal(14, & key_regeneration_alarm);
#line 749
      alarm((unsigned int )options.key_regeneration_time);
    }
#line 753
    signal(1, & sighup_handler);
#line 755
    signal(15, & sigterm_handler);
#line 756
    signal(3, & sigterm_handler);
#line 759
    signal(17, & main_sigchld_handler);
#line 762
    fdset = (fd_set *)((void *)0);
#line 763
    maxfd = 0;
#line 764
    i = 0;
#line 764
    while (i < num_listen_socks) {
#line 765
      if (listen_socks[i] > maxfd) {
#line 766
        maxfd = listen_socks[i];
      }
#line 764
      i ++;
    }
#line 768
    tmp___32 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 768
    startup_pipes = (int *)tmp___32;
#line 769
    i = 0;
#line 769
    while (i < options.max_startups) {
#line 770
      *(startup_pipes + i) = -1;
#line 769
      i ++;
    }
#line 776
    while (1) {
#line 777
      if (received_sighup) {
#line 778
        sighup_restart();
      }
#line 779
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 780
        xfree((void *)fdset);
      }
#line 781
      fdsetsz = (int )((((unsigned int )maxfd + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 782
      tmp___33 = xmalloc((unsigned int )fdsetsz);
#line 782
      fdset = (fd_set *)tmp___33;
#line 783
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 785
      i = 0;
#line 785
      while (i < num_listen_socks) {
#line 786
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 785
        i ++;
      }
#line 787
      i = 0;
#line 787
      while (i < options.max_startups) {
#line 788
        if (*(startup_pipes + i) != -1) {
#line 789
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 787
        i ++;
      }
#line 792
      tmp___37 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 792
      if (tmp___37 < 0) {
#line 793
        tmp___36 = __errno_location();
#line 793
        if (*tmp___36 != 4) {
#line 794
          tmp___34 = __errno_location();
#line 794
          tmp___35 = strerror(*tmp___34);
#line 794
          error("select: %.100s", tmp___35);
        }
        goto __Cont___0;
      }
#line 797
      i = 0;
#line 797
      while (i < options.max_startups) {
#line 799
        if (*(startup_pipes + i) != -1) {
#line 799
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 799
          if (__result) {
#line 806
            close(*(startup_pipes + i));
#line 807
            *(startup_pipes + i) = -1;
#line 808
            startups --;
          }
        }
#line 797
        i ++;
      }
#line 810
      i = 0;
#line 810
      while (i < num_listen_socks) {
#line 811
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 811
        if (! __result___0) {
          goto __Cont___1;
        }
#line 813
        fromlen = sizeof(from);
#line 814
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 816
        if (newsock < 0) {
#line 817
          tmp___40 = __errno_location();
#line 817
          if (*tmp___40 != 4) {
#line 817
            tmp___41 = __errno_location();
#line 817
            if (*tmp___41 != 11) {
#line 818
              tmp___38 = __errno_location();
#line 818
              tmp___39 = strerror(*tmp___38);
#line 818
              error("accept: %.100s", tmp___39);
            }
          }
          goto __Cont___1;
        }
#line 821
        tmp___44 = fcntl(newsock, 4, 0);
#line 821
        if (tmp___44 < 0) {
#line 822
          tmp___42 = __errno_location();
#line 822
          tmp___43 = strerror(*tmp___42);
#line 822
          error("newsock del O_NONBLOCK: %s", tmp___43);
          goto __Cont___1;
        }
#line 825
        if (startups >= options.max_startups) {
#line 826
          close(newsock);
          goto __Cont___1;
        }
#line 829
        tmp___45 = pipe((int *)(startup_p));
#line 829
        if (tmp___45 == -1) {
#line 830
          close(newsock);
          goto __Cont___1;
        }
#line 834
        j = 0;
#line 834
        while (j < options.max_startups) {
#line 835
          if (*(startup_pipes + j) == -1) {
#line 836
            *(startup_pipes + j) = startup_p[0];
#line 837
            if (maxfd < startup_p[0]) {
#line 838
              maxfd = startup_p[0];
            }
#line 839
            startups ++;
#line 840
            break;
          }
#line 834
          j ++;
        }
#line 847
        if (debug_flag) {
#line 853
          debug("Server will not fork when running in debugging mode.");
#line 854
          close_listen_socks();
#line 855
          sock_in = newsock;
#line 856
          sock_out = newsock;
#line 857
          startup_pipe = -1;
#line 858
          pid = getpid();
#line 859
          break;
        } else {
#line 866
          pid = fork();
#line 866
          if (pid == 0) {
#line 874
            startup_pipe = startup_p[1];
#line 875
            j = 0;
#line 875
            while (j < options.max_startups) {
#line 876
              if (*(startup_pipes + j) != -1) {
#line 877
                close(*(startup_pipes + j));
              }
#line 875
              j ++;
            }
#line 878
            close_listen_socks();
#line 879
            sock_in = newsock;
#line 880
            sock_out = newsock;
#line 881
            log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 882
            break;
          }
        }
#line 887
        if (pid < 0) {
#line 888
          tmp___46 = __errno_location();
#line 888
          tmp___47 = strerror(*tmp___46);
#line 888
          error("fork: %.100s", tmp___47);
        } else {
#line 890
          debug("Forked child %d.", pid);
        }
#line 892
        close(startup_p[1]);
#line 895
        key_used = 1;
#line 897
        arc4random_stir();
#line 900
        close(newsock);
        __Cont___1: /* CIL Label */ 
#line 810
        i ++;
      }
#line 903
      if (num_listen_socks < 0) {
#line 904
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
  }
#line 915
  alarm(0U);
#line 916
  signal(14, (void (*)(int  ))0);
#line 917
  signal(1, (void (*)(int  ))0);
#line 918
  signal(15, (void (*)(int  ))0);
#line 919
  signal(3, (void (*)(int  ))0);
#line 920
  signal(17, (void (*)(int  ))0);
#line 928
  linger.l_onoff = 1;
#line 929
  linger.l_linger = 5;
#line 930
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 936
  packet_set_connection(sock_in, sock_out);
#line 938
  remote_port = get_remote_port();
#line 939
  remote_ip = get_remote_ipaddr();
#line 959
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 969
  signal(14, & grace_alarm_handler);
#line 970
  if (! debug_flag) {
#line 971
    alarm((unsigned int )options.login_grace_time);
  }
#line 973
  sshd_exchange_identification(sock_in, sock_out);
#line 981
  if (remote_port >= 1024) {
#line 983
    options.rhosts_authentication = 0;
#line 984
    options.rhosts_rsa_authentication = 0;
  } else {
#line 981
    if (remote_port < 512) {
#line 983
      options.rhosts_authentication = 0;
#line 984
      options.rhosts_rsa_authentication = 0;
    }
  }
#line 994
  packet_set_nonblocking();
#line 998
  if (compat20) {
#line 999
    do_ssh2_kex();
#line 1000
    do_authentication2();
  } else {
#line 1002
    do_ssh1_kex();
#line 1003
    do_authentication();
  }
#line 1013
  verbose("Closing connection to %.100s", remote_ip);
#line 1016
  finish_pam();
#line 1019
  packet_close();
#line 1020
  exit(0);
}
}
#line 1026 "sshd.c"
void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char cookie[8] ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;

  {
#line 1035
  rand___0 = (u_int32_t )0;
#line 1046
  i = 0;
#line 1046
  while (i < 8) {
#line 1047
    if (i % 4 == 0) {
#line 1048
      rand___0 = arc4random();
    }
#line 1049
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1050
    rand___0 >>= 8;
#line 1046
    i ++;
  }
#line 1058
  packet_start(2);
#line 1059
  i = 0;
#line 1059
  while (i < 8) {
#line 1060
    packet_put_char((int )cookie[i]);
#line 1059
    i ++;
  }
#line 1063
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1063
  packet_put_int((unsigned int )tmp);
#line 1064
  packet_put_bignum(public_key->e);
#line 1065
  packet_put_bignum(public_key->n);
#line 1068
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1068
  packet_put_int((unsigned int )tmp___0);
#line 1069
  packet_put_bignum((sensitive_data.host_key)->e);
#line 1070
  packet_put_bignum((sensitive_data.host_key)->n);
#line 1073
  packet_put_int(2U);
#line 1076
  tmp___1 = cipher_mask1();
#line 1076
  packet_put_int(tmp___1);
#line 1079
  auth_mask = 0U;
#line 1080
  if (options.rhosts_authentication) {
#line 1081
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1082
  if (options.rhosts_rsa_authentication) {
#line 1083
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1084
  if (options.rsa_authentication) {
#line 1085
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1100
  if (options.password_authentication) {
#line 1101
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1102
  packet_put_int(auth_mask);
#line 1105
  packet_send();
#line 1106
  packet_write_wait();
#line 1108
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1108
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1108
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 1112
  packet_read_expect(& plen, 3);
#line 1115
  cipher_type___0 = packet_get_char();
#line 1117
  tmp___4 = cipher_mask();
#line 1117
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1118
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1122
  i = 0;
#line 1122
  while (i < 8) {
#line 1123
    tmp___5 = packet_get_char();
#line 1123
    if ((unsigned int )cookie[i] != tmp___5) {
#line 1124
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1122
    i ++;
  }
#line 1126
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1126
  debug("Encryption type: %.200s", tmp___6);
#line 1129
  session_key_int = BN_new();
#line 1130
  packet_get_bignum(session_key_int, & slen);
#line 1132
  protocol_flags = packet_get_int();
#line 1133
  packet_set_protocol_flags(protocol_flags);
#line 1135
  while (1) {
#line 1135
    _p = plen;
#line 1135
    _e = (9 + slen) + 4;
#line 1135
    if (_p != _e) {
#line 1135
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1135);
#line 1135
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1135
    break;
  }
#line 1141
  tmp___17 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1141
  if (tmp___17 > 0) {
#line 1143
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1143
    tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1143
    if (tmp___10 < tmp___11 + 128) {
#line 1145
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1145
      tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1145
      tmp___9 = get_remote_ipaddr();
#line 1145
      fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1151
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 1153
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1157
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1157
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1157
    if (tmp___15 < tmp___16 + 128) {
#line 1159
      tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1159
      tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1159
      tmp___14 = get_remote_ipaddr();
#line 1159
      fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___14, tmp___13, tmp___12, 128);
    }
#line 1165
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1167
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1171
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(cookie), (sensitive_data.host_key)->n,
                     (sensitive_data.private_key)->n);
#line 1176
  destroy_sensitive_data();
#line 1183
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1184
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1184
  len = (tmp___18 + 7) / 8;
#line 1185
  if (len < 0) {
#line 1186
    tmp___19 = get_remote_ipaddr();
#line 1186
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
          tmp___19, len, sizeof(session_key));
  } else {
#line 1185
    if ((unsigned int )len > sizeof(session_key)) {
#line 1186
      tmp___19 = get_remote_ipaddr();
#line 1186
      fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
            tmp___19, len, sizeof(session_key));
    }
  }
#line 1189
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1190
  BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1193
  BN_clear_free(session_key_int);
#line 1196
  i = 0;
#line 1196
  while (i < 16) {
#line 1197
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1196
    i ++;
  }
#line 1200
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1203
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1205
  debug("Received session key; encryption turned on.");
#line 1208
  packet_start(14);
#line 1209
  packet_send();
#line 1210
  packet_write_wait();
#line 1211
  return;
}
}
#line 1216 "sshd.c"
void do_ssh2_kex(void) 
{ Buffer *server_kexinit ;
  Buffer *client_kexinit ;
  int payload_len ;
  int dlen ;
  int slen ;
  unsigned int klen ;
  unsigned int kout ;
  unsigned char *signature ;
  unsigned char *server_host_key_blob ;
  unsigned int sbloblen ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  BIGNUM *shared_secret ;
  int i ;
  unsigned char *kbuf ;
  unsigned char *hash ;
  Kex *kex___0 ;
  char *cprop[10] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
#line 1224
  signature = (unsigned char *)((void *)0);
#line 1225
  server_host_key_blob = (unsigned char *)((void *)0);
#line 1228
  dh_client_pub = (BIGNUM *)0;
#line 1229
  shared_secret = (BIGNUM *)0;
#line 1238
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1239
    myproposal[3] = options.ciphers;
#line 1239
    myproposal[2] = myproposal[3];
  }
#line 1242
  server_kexinit = kex_init((char **)(myproposal));
#line 1243
  tmp = xmalloc(sizeof(*client_kexinit));
#line 1243
  client_kexinit = (Buffer *)tmp;
#line 1244
  buffer_init(client_kexinit);
#line 1247
  kex_exchange_kexinit(server_kexinit, client_kexinit, (char **)(cprop));
#line 1248
  kex___0 = kex_choose_conf((char **)(cprop), (char **)(myproposal), 1);
#line 1249
  i = 0;
#line 1249
  while (i < 10) {
#line 1250
    xfree((void *)cprop[i]);
#line 1249
    i ++;
  }
#line 1254
  debug("Wait SSH2_MSG_KEXDH_INIT.");
#line 1255
  packet_read_expect(& payload_len, 30);
#line 1258
  dh_client_pub = BN_new();
#line 1259
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1260
    fatal("dh_client_pub == NULL");
  }
#line 1261
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1271
  dh = dh_new_group1();
#line 1282
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 1282
  if (! tmp___0) {
#line 1283
    packet_disconnect("bad client public DH value");
  }
#line 1285
  tmp___1 = DH_size((DH const   *)dh);
#line 1285
  klen = (unsigned int )tmp___1;
#line 1286
  tmp___2 = xmalloc(klen);
#line 1286
  kbuf = (unsigned char *)tmp___2;
#line 1287
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1287
  kout = (unsigned int )tmp___3;
#line 1296
  shared_secret = BN_new();
#line 1298
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1299
  memset((void *)kbuf, 0, klen);
#line 1300
  xfree((void *)kbuf);
#line 1303
  dsa_make_key_blob(sensitive_data.dsa_host_key, & server_host_key_blob, & sbloblen);
#line 1306
  tmp___4 = buffer_len(server_kexinit);
#line 1306
  tmp___5 = buffer_ptr(server_kexinit);
#line 1306
  tmp___6 = buffer_len(client_kexinit);
#line 1306
  tmp___7 = buffer_ptr(client_kexinit);
#line 1306
  hash = kex_hash(client_version_string, server_version_string, tmp___7, (int )tmp___6,
                  tmp___5, (int )tmp___4, (char *)server_host_key_blob, (int )sbloblen,
                  dh_client_pub, dh->pub_key, shared_secret);
#line 1316
  buffer_free(client_kexinit);
#line 1317
  buffer_free(server_kexinit);
#line 1318
  xfree((void *)client_kexinit);
#line 1319
  xfree((void *)server_kexinit);
#line 1328
  session_id2_len = 20;
#line 1329
  tmp___8 = xmalloc((unsigned int )session_id2_len);
#line 1329
  session_id2 = (unsigned char *)tmp___8;
#line 1330
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1334
  dsa_sign(sensitive_data.dsa_host_key, & signature, & slen, hash, 20);
#line 1336
  destroy_sensitive_data();
#line 1339
  packet_start(31);
#line 1340
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1341
  packet_put_bignum2(dh->pub_key);
#line 1342
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1343
  packet_send();
#line 1344
  xfree((void *)signature);
#line 1345
  xfree((void *)server_host_key_blob);
#line 1346
  packet_write_wait();
#line 1348
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1349
  packet_set_kex(kex___0);
#line 1352
  DH_free(dh);
#line 1354
  debug("send SSH2_MSG_NEWKEYS.");
#line 1355
  packet_start(21);
#line 1356
  packet_send();
#line 1357
  packet_write_wait();
#line 1358
  debug("done: send SSH2_MSG_NEWKEYS.");
#line 1360
  debug("Wait SSH2_MSG_NEWKEYS.");
#line 1361
  packet_read_expect(& payload_len, 21);
#line 1362
  debug("GOT SSH2_MSG_NEWKEYS.");
#line 1371
  debug("done: KEX2.");
#line 1372
  return;
}
}
#line 1 "auth.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 10 "auth.h"
int allowed_user(struct passwd *pw ) ;
#line 49 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  struct group *grp ;
  char *shell ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 82
  if (! pw) {
#line 83
    return (0);
  }
#line 90
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 90
    shell = (char *)"/bin/sh";
  } else {
#line 90
    shell = pw->pw_shell;
  }
#line 93
  tmp = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 93
  if (tmp != 0) {
#line 94
    return (0);
  }
#line 95
  if (st.st_mode & 32768U) {
#line 95
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 96
      return (0);
    }
  } else {
#line 96
    return (0);
  }
#line 99
  if (options.num_deny_users > 0U) {
#line 100
    if (! pw->pw_name) {
#line 101
      return (0);
    }
#line 102
    i = 0;
#line 102
    while ((unsigned int )i < options.num_deny_users) {
#line 103
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 103
      if (tmp___0) {
#line 104
        return (0);
      }
#line 102
      i ++;
    }
  }
#line 107
  if (options.num_allow_users > 0U) {
#line 108
    if (! pw->pw_name) {
#line 109
      return (0);
    }
#line 110
    i = 0;
#line 110
    while ((unsigned int )i < options.num_allow_users) {
#line 111
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 111
      if (tmp___1) {
#line 112
        break;
      }
#line 110
      i ++;
    }
#line 114
    if ((unsigned int )i >= options.num_allow_users) {
#line 115
      return (0);
    }
  }
#line 118
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 118
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 119
      grp = getgrgid(pw->pw_gid);
#line 120
      if (! grp) {
#line 121
        return (0);
      }
#line 124
      if (options.num_deny_groups > 0U) {
#line 125
        if (! grp->gr_name) {
#line 126
          return (0);
        }
#line 127
        i = 0;
#line 127
        while ((unsigned int )i < options.num_deny_groups) {
#line 128
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 128
          if (tmp___2) {
#line 129
            return (0);
          }
#line 127
          i ++;
        }
      }
#line 135
      if (options.num_allow_groups > 0U) {
#line 136
        if (! grp->gr_name) {
#line 137
          return (0);
        }
#line 138
        i = 0;
#line 138
        while ((unsigned int )i < options.num_allow_groups) {
#line 139
          tmp___3 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 139
          if (tmp___3) {
#line 140
            break;
          }
#line 138
          i ++;
        }
#line 143
        if ((unsigned int )i >= options.num_allow_groups) {
#line 144
          return (0);
        }
      }
    }
  }
#line 166
  return (1);
}
}
#line 1 "auth1.o"
#line 356 "ssh.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 362
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 376
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 6 "auth-pam.h"
void start_pam(struct passwd *pw ) ;
#line 8
int auth_pam_password(struct passwd *pw , char const   *password ) ;
#line 10
int do_pam_account(char *username , char *remote_user ) ;
#line 5 "session.h"
void do_authenticated(struct passwd *pw ) ;
#line 28 "auth1.c"
char *forced_command ;
#line 40 "auth1.c"
static char buf[1024]  ;
#line 37 "auth1.c"
char *get_authname(int type ) 
{ 

  {
#line 41
  switch (type) {
  case 9: 
#line 43
  return ((char *)"password");
  case 6: 
#line 45
  return ((char *)"rsa");
  case 35: 
#line 47
  return ((char *)"rhosts-rsa");
  case 5: 
#line 49
  return ((char *)"rhosts");
  }
#line 59
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 60
  return (buf);
}
}
#line 67 "auth1.c"
void do_fake_authloop1(char *user ) 
{ int attempt___0 ;
  int tmp ;
  char const   *tmp___0 ;
  int plen ;

  {
#line 70
  attempt___0 = 0;
#line 72
  tmp = get_remote_port();
#line 72
  tmp___0 = get_remote_ipaddr();
#line 72
  log("Faking authloop for illegal user %.200s from %.200s port %d", user, tmp___0,
      tmp);
#line 82
  packet_start(15);
#line 83
  packet_send();
#line 84
  packet_write_wait();
#line 90
  attempt___0 = 1;
#line 90
  while (1) {
#line 94
    packet_read(& plen);
#line 120
    if (attempt___0 > 6) {
#line 121
      packet_disconnect("Too many authentication failures for %.100s", user);
    }
#line 127
    packet_start(15);
#line 128
    packet_send();
#line 129
    packet_write_wait();
#line 90
    attempt___0 ++;
  }
#line 132
  abort();
}
}
#line 139 "auth1.c"
void do_authloop(struct passwd *pw ) 
{ int attempt___0 ;
  unsigned int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char user[1024] ;
  unsigned int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  unsigned int ulen ;
  int type ;
  void (*authlog___0)(char const   *fmt  , ...) ;
  int authenticated ;
  int _p ;
  int _e ;
  int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 142
  attempt___0 = 0;
#line 146
  client_user = (char *)((void *)0);
#line 146
  password = (char *)((void *)0);
#line 151
  type = 0;
#line 152
  authlog___0 = (void (*)(char const   *fmt  , ...))(& verbose);
#line 155
  packet_start(15);
#line 156
  packet_send();
#line 157
  packet_write_wait();
#line 159
  attempt___0 = 1;
#line 159
  while (1) {
#line 160
    authenticated = 0;
#line 161
    strlcpy(user, "", sizeof(user));
#line 164
    type = packet_read(& plen);
#line 167
    switch (type) {
    case 5: 
#line 227
    if (! options.rhosts_authentication) {
#line 228
      verbose("Rhosts authentication disabled.");
#line 229
      break;
    }
#line 237
    client_user = packet_get_string(& ulen);
#line 238
    while (1) {
#line 238
      _p = plen;
#line 238
      _e = (int )(4U + ulen);
#line 238
      if (_p != _e) {
#line 238
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 238);
#line 238
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 238
      break;
    }
#line 242
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 244
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 245
    break;
    case 35: 
#line 248
    if (! options.rhosts_rsa_authentication) {
#line 249
      verbose("Rhosts with RSA authentication disabled.");
#line 250
      break;
    }
#line 257
    client_user = packet_get_string(& ulen);
#line 260
    client_host_key = RSA_new();
#line 261
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 262
      fatal("RSA_new failed");
    }
#line 263
    client_host_key->e = BN_new();
#line 264
    client_host_key->n = BN_new();
#line 265
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 266
      fatal("BN_new failed");
    } else {
#line 265
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 266
        fatal("BN_new failed");
      }
    }
#line 267
    bits = packet_get_int();
#line 268
    packet_get_bignum(client_host_key->e, & elen);
#line 269
    packet_get_bignum(client_host_key->n, & nlen);
#line 271
    tmp___0 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 271
    if (bits != (unsigned int )tmp___0) {
#line 272
      tmp = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 272
      log("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
          tmp, bits);
    }
#line 274
    while (1) {
#line 274
      _p___0 = plen;
#line 274
      _e___0 = (int )((((4U + ulen) + 4U) + (unsigned int )elen) + (unsigned int )nlen);
#line 274
      if (_p___0 != _e___0) {
#line 274
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            274);
#line 274
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 274
      break;
    }
#line 276
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 277
    RSA_free(client_host_key);
#line 279
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 280
    break;
    case 6: 
#line 283
    if (! options.rsa_authentication) {
#line 284
      verbose("RSA authentication disabled.");
#line 285
      break;
    }
#line 288
    n___0 = BN_new();
#line 289
    packet_get_bignum(n___0, & nlen);
#line 290
    while (1) {
#line 290
      _p___1 = plen;
#line 290
      _e___1 = nlen;
#line 290
      if (_p___1 != _e___1) {
#line 290
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            290);
#line 290
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 290
      break;
    }
#line 291
    authenticated = auth_rsa(pw, n___0);
#line 292
    BN_clear_free(n___0);
#line 293
    break;
    case 9: 
#line 296
    if (! options.password_authentication) {
#line 297
      verbose("Password authentication disabled.");
#line 298
      break;
    }
#line 305
    password = packet_get_string(& dlen);
#line 306
    while (1) {
#line 306
      _p___2 = plen;
#line 306
      _e___2 = (int )(4U + dlen);
#line 306
      if (_p___2 != _e___2) {
#line 306
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            306);
#line 306
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 306
      break;
    }
#line 310
    authenticated = auth_pam_password(pw, (char const   *)password);
#line 323
    tmp___1 = strlen((char const   *)password);
#line 323
    memset((void *)password, 0, tmp___1);
#line 324
    xfree((void *)password);
#line 325
    break;
    case 39: 
#line 361
    log("TIS authentication unsupported.");
#line 362
    break;
    default: 
#line 370
    log("Unknown message during authentication: type %d", type);
#line 371
    break;
    }
#line 379
    if (authenticated) {
#line 379
      if (pw->pw_uid == 0U) {
#line 379
        if (! options.permit_root_login) {
#line 380
          if (forced_command) {
#line 381
            log("Root login accepted for forced command.");
          } else {
#line 383
            authenticated = 0;
#line 384
            tmp___2 = get_canonical_hostname();
#line 384
            log("ROOT LOGIN REFUSED FROM %.200s", tmp___2);
          }
        }
      }
    }
#line 390
    if (authenticated) {
#line 393
      authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 390
      if (attempt___0 == 3) {
#line 393
        authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 390
        if (type == 9) {
#line 393
          authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
#line 395
    tmp___3 = get_remote_port();
#line 395
    tmp___4 = get_remote_ipaddr();
#line 395
    if (pw->pw_uid == 0U) {
#line 395
      tmp___5 = "ROOT";
    } else {
#line 395
      tmp___5 = (char const   *)pw->pw_name;
    }
#line 395
    tmp___6 = get_authname(type);
#line 395
    if (authenticated) {
#line 395
      tmp___7 = "Accepted";
    } else {
#line 395
      tmp___7 = "Failed";
    }
#line 395
    (*authlog___0)("%s %s for %.200s from %.200s port %d%s", tmp___7, tmp___6, tmp___5,
                   tmp___4, tmp___3, user);
#line 404
    if (authenticated) {
#line 405
      tmp___8 = do_pam_account(pw->pw_name, client_user);
#line 405
      if (! tmp___8) {
#line 406
        if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 407
          xfree((void *)client_user);
#line 408
          client_user = (char *)((void *)0);
        }
#line 410
        do_fake_authloop1(pw->pw_name);
      }
#line 412
      return;
    }
#line 420
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 421
      xfree((void *)client_user);
#line 422
      client_user = (char *)((void *)0);
    }
#line 425
    if (attempt___0 > 6) {
#line 429
      packet_disconnect("Too many authentication failures for %.100s", pw->pw_name);
    }
#line 433
    packet_start(15);
#line 434
    packet_send();
#line 435
    packet_write_wait();
#line 159
    attempt___0 ++;
  }
}
}
#line 443 "auth1.c"
void do_authentication(void) 
{ struct passwd *pw ;
  struct passwd pwcopy ;
  int plen ;
  unsigned int ulen ;
  char *user ;
  int _p ;
  int _e ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 455
  packet_read_expect(& plen, 4);
#line 458
  user = packet_get_string(& ulen);
#line 459
  while (1) {
#line 459
    _p = plen;
#line 459
    _e = (int )(4U + ulen);
#line 459
    if (_p != _e) {
#line 459
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 459);
#line 459
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 459
    break;
  }
#line 461
  setproctitle("%s", user);
#line 472
  pw = getpwnam((char const   *)user);
#line 473
  if (! pw) {
#line 474
    do_fake_authloop1(user);
  } else {
#line 473
    tmp = allowed_user(pw);
#line 473
    if (! tmp) {
#line 474
      do_fake_authloop1(user);
    }
  }
#line 475
  xfree((void *)user);
#line 478
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 479
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 480
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 481
  pwcopy.pw_uid = pw->pw_uid;
#line 482
  pwcopy.pw_gid = pw->pw_gid;
#line 483
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 484
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 485
  pw = & pwcopy;
#line 488
  start_pam(pw);
#line 495
  tmp___0 = getuid();
#line 495
  if (tmp___0 != 0U) {
#line 495
    tmp___1 = getuid();
#line 495
    if (pw->pw_uid != tmp___1) {
#line 496
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 498
  debug("Attempting authentication for %.100s.", pw->pw_name);
#line 501
  if (options.password_authentication) {
#line 501
    tmp___3 = auth_pam_password(pw, "");
#line 501
    if (tmp___3) {
#line 515
      tmp___2 = get_remote_ipaddr();
#line 515
      log("Login for user %s from %.100s, accepted without authentication.", pw->pw_name,
          tmp___2);
    } else {
#line 521
      do_authloop(pw);
    }
  } else {
#line 521
    do_authloop(pw);
  }
#line 530
  packet_start(14);
#line 531
  packet_send();
#line 532
  packet_write_wait();
#line 535
  do_authenticated(pw);
#line 536
  return;
}
}
#line 1 "auth2.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 7 "auth.h"
struct passwd *auth_get_user(void) ;
#line 8 "session.h"
void do_authenticated2(void) ;
#line 12 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *options___0 , unsigned long linenum ) ;
#line 71 "auth2.c"
void input_service_request(int type , int plen ) ;
#line 72
void input_userauth_request(int type , int plen ) ;
#line 73
void protocol_error(int type , int plen ) ;
#line 76
int ssh2_auth_none(struct passwd *pw ) ;
#line 77
int ssh2_auth_password(struct passwd *pw ) ;
#line 78
int ssh2_auth_pubkey(struct passwd *pw , char *service ) ;
#line 81
struct passwd *auth_set_user(char *u , char *s ) ;
#line 82
int user_dsa_key_allowed(struct passwd *pw , Key *key ) ;
#line 91 "auth2.c"
static Authctxt *authctxt  =    (Authctxt *)((void *)0);
#line 92 "auth2.c"
static int userauth_success  =    0;
#line 98 "auth2.c"
void do_authentication2(void) 
{ 

  {
#line 109
  dispatch_init(& protocol_error);
#line 110
  dispatch_set(5, & input_service_request);
#line 111
  dispatch_run(0, & userauth_success);
#line 112
  do_authenticated2();
#line 113
  return;
}
}
#line 115 "auth2.c"
void protocol_error(int type , int plen ) 
{ 

  {
#line 118
  log("auth: protocol error: type %d plen %d", type, plen);
#line 119
  packet_start(3);
#line 120
  packet_put_int(0U);
#line 121
  packet_send();
#line 122
  packet_write_wait();
#line 123
  return;
}
}
#line 125 "auth2.c"
void input_service_request(int type , int plen ) 
{ unsigned int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 129
  accept___0 = 0;
#line 130
  tmp = packet_get_string(& len);
#line 130
  service = tmp;
#line 131
  while (1) {
#line 131
    tmp___0 = packet_remaining();
#line 131
    _len = tmp___0;
#line 131
    if (_len > 0) {
#line 131
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          131);
#line 131
      packet_disconnect("Packet integrity error.");
    }
#line 131
    break;
  }
#line 133
  if (0) {
#line 133
    __s1_len = strlen((char const   *)service);
#line 133
    __s2_len = strlen("ssh-userauth");
#line 133
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 133
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 133
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 133
          tmp___10 = 1;
        } else {
#line 133
          if (__s2_len >= 4U) {
#line 133
            tmp___10 = 1;
          } else {
#line 133
            tmp___10 = 0;
          }
        }
      } else {
#line 133
        tmp___10 = 0;
      }
    }
#line 133
    if (tmp___10) {
#line 133
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 133
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 133
      tmp___6 = tmp___9;
    }
  } else {
#line 133
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 133
    tmp___6 = tmp___9;
  }
#line 133
  if (tmp___6 == 0) {
#line 134
    if (! userauth_success) {
#line 135
      accept___0 = 1;
#line 137
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 142
  if (accept___0) {
#line 143
    packet_start(6);
#line 144
    packet_put_cstring((char const   *)service);
#line 145
    packet_send();
#line 146
    packet_write_wait();
  } else {
#line 148
    debug("bad service request %s", service);
#line 149
    packet_disconnect("bad service request %s", service);
  }
#line 151
  xfree((void *)service);
#line 152
  return;
}
}
#line 157 "auth2.c"
static void (*authlog)(char const   *fmt  , ...)  =    (void (*)(char const   *fmt  , ...))(& verbose);
#line 158 "auth2.c"
static int attempt  =    0;
#line 154 "auth2.c"
void input_userauth_request(int type , int plen ) 
{ unsigned int len ;
  int authenticated ;
  char *user ;
  char *service ;
  char *method ;
  char *authmsg ;
  struct passwd *pw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;

  {
#line 160
  authenticated = 0;
#line 161
  authmsg = (char *)((void *)0);
#line 167
  user = packet_get_string(& len);
#line 168
  service = packet_get_string(& len);
#line 169
  method = packet_get_string(& len);
#line 170
  attempt ++;
#line 170
  if (attempt == 6) {
#line 174
    packet_disconnect("too many failed userauth_requests");
  }
#line 176
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 179
  pw = auth_set_user(user, service);
#line 180
  if (pw) {
#line 180
    if (0) {
#line 180
      __s1_len___2 = strlen((char const   *)service);
#line 180
      __s2_len___2 = strlen("ssh-connection");
#line 180
      if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
        goto _L___6;
      } else {
#line 180
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 180
          if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 180
            tmp___38 = 1;
          } else {
#line 180
            if (__s2_len___2 >= 4U) {
#line 180
              tmp___38 = 1;
            } else {
#line 180
              tmp___38 = 0;
            }
          }
        } else {
#line 180
          tmp___38 = 0;
        }
      }
#line 180
      if (tmp___38) {
#line 180
        tmp___34 = __builtin_strcmp((char const   *)service, "ssh-connection");
      } else {
#line 180
        tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 180
        tmp___34 = tmp___37;
      }
    } else {
#line 180
      tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 180
      tmp___34 = tmp___37;
    }
#line 180
    if (tmp___34 == 0) {
#line 181
      if (0) {
#line 181
        __s1_len___1 = strlen((char const   *)method);
#line 181
        __s2_len___1 = strlen("none");
#line 181
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___4;
        } else {
#line 181
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 181
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 181
              tmp___28 = 1;
            } else {
#line 181
              if (__s2_len___1 >= 4U) {
#line 181
                tmp___28 = 1;
              } else {
#line 181
                tmp___28 = 0;
              }
            }
          } else {
#line 181
            tmp___28 = 0;
          }
        }
#line 181
        if (tmp___28) {
#line 181
          tmp___24 = __builtin_strcmp((char const   *)method, "none");
        } else {
#line 181
          tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 181
          tmp___24 = tmp___27;
        }
      } else {
#line 181
        tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 181
        tmp___24 = tmp___27;
      }
#line 181
      if (tmp___24 == 0) {
#line 182
        authenticated = ssh2_auth_none(pw);
      } else {
#line 183
        if (0) {
#line 183
          __s1_len___0 = strlen((char const   *)method);
#line 183
          __s2_len___0 = strlen("password");
#line 183
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___2;
          } else {
#line 183
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 183
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 183
                tmp___18 = 1;
              } else {
#line 183
                if (__s2_len___0 >= 4U) {
#line 183
                  tmp___18 = 1;
                } else {
#line 183
                  tmp___18 = 0;
                }
              }
            } else {
#line 183
              tmp___18 = 0;
            }
          }
#line 183
          if (tmp___18) {
#line 183
            tmp___14 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 183
            tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 183
            tmp___14 = tmp___17;
          }
        } else {
#line 183
          tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 183
          tmp___14 = tmp___17;
        }
#line 183
        if (tmp___14 == 0) {
#line 184
          authenticated = ssh2_auth_password(pw);
        } else {
#line 185
          if (0) {
#line 185
            __s1_len = strlen((char const   *)method);
#line 185
            __s2_len = strlen("publickey");
#line 185
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___0;
            } else {
#line 185
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 185
                if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
#line 185
                  tmp___8 = 1;
                } else {
#line 185
                  if (__s2_len >= 4U) {
#line 185
                    tmp___8 = 1;
                  } else {
#line 185
                    tmp___8 = 0;
                  }
                }
              } else {
#line 185
                tmp___8 = 0;
              }
            }
#line 185
            if (tmp___8) {
#line 185
              tmp___4 = __builtin_strcmp((char const   *)method, "publickey");
            } else {
#line 185
              tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 185
              tmp___4 = tmp___7;
            }
          } else {
#line 185
            tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 185
            tmp___4 = tmp___7;
          }
#line 185
          if (tmp___4 == 0) {
#line 186
            authenticated = ssh2_auth_pubkey(pw, service);
          }
        }
      }
    }
  }
#line 189
  if (authenticated) {
#line 189
    if (pw) {
#line 189
      if (pw->pw_uid == 0U) {
#line 189
        if (! options.permit_root_login) {
#line 190
          authenticated = 0;
#line 191
          tmp___39 = get_canonical_hostname();
#line 191
          log("ROOT LOGIN REFUSED FROM %.200s", tmp___39);
        }
      }
    }
  }
#line 196
  if (authenticated) {
#line 196
    tmp___40 = do_pam_account(pw->pw_name, (char *)((void *)0));
#line 196
    if (! tmp___40) {
#line 197
      authenticated = 0;
    }
  }
#line 203
  if (authenticated == 1) {
#line 204
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 203
    if (attempt == 3) {
#line 204
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 203
      if (0) {
#line 203
        __s1_len___3 = strlen((char const   *)method);
#line 203
        __s2_len___3 = strlen("password");
#line 203
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___8;
        } else {
#line 203
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 203
            if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 203
              tmp___50 = 1;
            } else {
#line 203
              if (__s2_len___3 >= 4U) {
#line 203
                tmp___50 = 1;
              } else {
#line 203
                tmp___50 = 0;
              }
            }
          } else {
#line 203
            tmp___50 = 0;
          }
        }
#line 203
        if (tmp___50) {
#line 203
          tmp___46 = __builtin_strcmp((char const   *)method, "password");
        } else {
#line 203
          tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 203
          tmp___46 = tmp___49;
        }
      } else {
#line 203
        tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 203
        tmp___46 = tmp___49;
      }
#line 203
      if (tmp___46 == 0) {
#line 204
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      }
    }
  }
#line 207
  if (authenticated == 1) {
#line 208
    authmsg = (char *)"Accepted";
  } else {
#line 209
    if (authenticated == 0) {
#line 210
      authmsg = (char *)"Failed";
    } else {
#line 212
      authmsg = (char *)"Postponed";
    }
  }
#line 214
  tmp___51 = get_remote_port();
#line 214
  tmp___52 = get_remote_ipaddr();
#line 214
  if (pw) {
#line 214
    if (pw->pw_uid == 0U) {
#line 214
      tmp___53 = "ROOT";
    } else {
#line 214
      tmp___53 = (char const   *)user;
    }
  } else {
#line 214
    tmp___53 = (char const   *)user;
  }
#line 214
  (*authlog)("%s %s for %.200s from %.200s port %d ssh2", authmsg, method, tmp___53,
             tmp___52, tmp___51);
#line 222
  if (authenticated == 1) {
#line 230
    dispatch_set(50, & protocol_error);
#line 231
    packet_start(52);
#line 232
    packet_send();
#line 233
    packet_write_wait();
#line 235
    userauth_success = 1;
  } else {
#line 236
    if (authenticated == 0) {
#line 237
      packet_start(51);
#line 238
      packet_put_cstring("publickey,password");
#line 239
      packet_put_char(0);
#line 240
      packet_send();
#line 241
      packet_write_wait();
    }
  }
#line 244
  xfree((void *)service);
#line 245
  xfree((void *)user);
#line 246
  xfree((void *)method);
#line 247
  return;
}
}
#line 249 "auth2.c"
int ssh2_auth_none(struct passwd *pw ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 257
  while (1) {
#line 257
    tmp = packet_remaining();
#line 257
    _len = tmp;
#line 257
    if (_len > 0) {
#line 257
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          257);
#line 257
      packet_disconnect("Packet integrity error.");
    }
#line 257
    break;
  }
#line 260
  tmp___0 = auth_pam_password(pw, "");
#line 260
  return (tmp___0);
}
}
#line 269 "auth2.c"
int ssh2_auth_password(struct passwd *pw ) 
{ char *password ;
  int authenticated ;
  int change ;
  unsigned int len ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 273
  authenticated = 0;
#line 280
  tmp = packet_get_char();
#line 280
  change = (int )tmp;
#line 281
  if (change) {
#line 282
    log("password change not supported");
  }
#line 283
  password = packet_get_string(& len);
#line 284
  while (1) {
#line 284
    tmp___0 = packet_remaining();
#line 284
    _len = tmp___0;
#line 284
    if (_len > 0) {
#line 284
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          284);
#line 284
      packet_disconnect("Packet integrity error.");
    }
#line 284
    break;
  }
#line 285
  if (options.password_authentication) {
#line 285
    tmp___1 = auth_pam_password(pw, (char const   *)password);
#line 285
    if (tmp___1 == 1) {
#line 295
      authenticated = 1;
    }
  }
#line 296
  memset((void *)password, 0, len);
#line 297
  xfree((void *)password);
#line 298
  return (authenticated);
}
}
#line 300 "auth2.c"
int ssh2_auth_pubkey(struct passwd *pw , char *service ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  unsigned int alen ;
  unsigned int blen ;
  unsigned int slen ;
  int have_sig ;
  int authenticated ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int _len ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int _len___0 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 308
  authenticated = 0;
#line 310
  if (options.dsa_authentication == 0) {
#line 311
    debug("pubkey auth disabled");
#line 312
    return (0);
  }
#line 314
  tmp = packet_get_char();
#line 314
  have_sig = (int )tmp;
#line 315
  pkalg = packet_get_string(& alen);
#line 316
  if (0) {
#line 316
    __s1_len = strlen((char const   *)pkalg);
#line 316
    __s2_len = strlen("ssh-dss");
#line 316
    if (! ((unsigned int )((void const   *)(pkalg + 1)) - (unsigned int )((void const   *)pkalg) == 1U)) {
      goto _L___0;
    } else {
#line 316
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 316
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 316
          tmp___9 = 1;
        } else {
#line 316
          if (__s2_len >= 4U) {
#line 316
            tmp___9 = 1;
          } else {
#line 316
            tmp___9 = 0;
          }
        }
      } else {
#line 316
        tmp___9 = 0;
      }
    }
#line 316
    if (tmp___9) {
#line 316
      tmp___5 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
    } else {
#line 316
      tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 316
      tmp___5 = tmp___8;
    }
  } else {
#line 316
    tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 316
    tmp___5 = tmp___8;
  }
#line 316
  if (tmp___5 != 0) {
#line 317
    xfree((void *)pkalg);
#line 318
    log("bad pkalg %s", pkalg);
#line 319
    return (0);
  }
#line 321
  pkblob = packet_get_string(& blen);
#line 322
  key = dsa_key_from_blob(pkblob, (int )blen);
#line 323
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 324
    if (have_sig) {
#line 325
      sig = packet_get_string(& slen);
#line 326
      while (1) {
#line 326
        tmp___10 = packet_remaining();
#line 326
        _len = tmp___10;
#line 326
        if (_len > 0) {
#line 326
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              326);
#line 326
          packet_disconnect("Packet integrity error.");
        }
#line 326
        break;
      }
#line 327
      buffer_init(& b);
#line 328
      if (datafellows & 16) {
#line 329
        buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
      } else {
#line 331
        buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
      }
#line 334
      buffer_put_char(& b, 50);
#line 335
      buffer_put_cstring(& b, (char const   *)pw->pw_name);
#line 336
      if (datafellows & 2) {
#line 336
        tmp___11 = "ssh-userauth";
      } else {
#line 336
        tmp___11 = (char const   *)service;
      }
#line 336
      buffer_put_cstring(& b, tmp___11);
#line 340
      buffer_put_cstring(& b, "publickey");
#line 341
      buffer_put_char(& b, have_sig);
#line 342
      buffer_put_cstring(& b, "ssh-dss");
#line 343
      buffer_put_string(& b, (void const   *)pkblob, blen);
#line 348
      tmp___12 = user_dsa_key_allowed(pw, key);
#line 348
      if (tmp___12) {
#line 348
        tmp___13 = buffer_len(& b);
#line 348
        tmp___14 = buffer_ptr(& b);
#line 348
        tmp___15 = dsa_verify(key, (unsigned char *)sig, (int )slen, (unsigned char *)tmp___14,
                              (int )tmp___13);
#line 348
        if (tmp___15 == 1) {
#line 350
          authenticated = 1;
        }
      }
#line 351
      buffer_clear(& b);
#line 352
      xfree((void *)sig);
    } else {
#line 354
      while (1) {
#line 354
        tmp___16 = packet_remaining();
#line 354
        _len___0 = tmp___16;
#line 354
        if (_len___0 > 0) {
#line 354
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              354);
#line 354
          packet_disconnect("Packet integrity error.");
        }
#line 354
        break;
      }
#line 355
      debug("test key...");
#line 365
      tmp___17 = user_dsa_key_allowed(pw, key);
#line 365
      if (tmp___17) {
#line 366
        packet_start(60);
#line 367
        packet_put_string((char const   *)pkalg, alen);
#line 368
        packet_put_string((char const   *)pkblob, blen);
#line 369
        packet_send();
#line 370
        packet_write_wait();
#line 371
        authenticated = -1;
      }
    }
#line 374
    key_free(key);
  }
#line 376
  xfree((void *)pkalg);
#line 377
  xfree((void *)pkblob);
#line 378
  return (authenticated);
}
}
#line 383 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 386
  if ((unsigned int )authctxt != (unsigned int )((void *)0)) {
#line 386
    if (authctxt->valid) {
#line 386
      tmp = & authctxt->pw;
    } else {
#line 386
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 386
    tmp = (struct passwd *)((void *)0);
  }
#line 386
  return (tmp);
}
}
#line 389 "auth2.c"
struct passwd *auth_set_user(char *u , char *s ) 
{ struct passwd *pw ;
  struct passwd *copy ;
  void *tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  struct passwd *tmp___21 ;

  {
#line 394
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 395
    tmp = xmalloc(sizeof(*authctxt));
#line 395
    authctxt = (Authctxt *)tmp;
#line 396
    authctxt->valid = 0;
#line 397
    authctxt->user = xstrdup((char const   *)u);
#line 398
    authctxt->service = xstrdup((char const   *)s);
#line 399
    setproctitle("%s", u);
#line 400
    pw = getpwnam((char const   *)u);
#line 401
    if (! pw) {
#line 402
      log("auth_set_user: illegal user %s", u);
#line 403
      return ((struct passwd *)((void *)0));
    } else {
#line 401
      tmp___0 = allowed_user(pw);
#line 401
      if (! tmp___0) {
#line 402
        log("auth_set_user: illegal user %s", u);
#line 403
        return ((struct passwd *)((void *)0));
      }
    }
#line 406
    start_pam(pw);
#line 408
    copy = & authctxt->pw;
#line 409
    memset((void *)copy, 0, sizeof(*copy));
#line 410
    copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 411
    copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 412
    copy->pw_uid = pw->pw_uid;
#line 413
    copy->pw_gid = pw->pw_gid;
#line 414
    copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 415
    copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 416
    authctxt->valid = 1;
  } else {
#line 418
    if (0) {
#line 418
      __s1_len = strlen((char const   *)u);
#line 418
      __s2_len = strlen((char const   *)authctxt->user);
#line 418
      if (! ((unsigned int )((void const   *)(u + 1)) - (unsigned int )((void const   *)u) == 1U)) {
        goto _L___0;
      } else {
#line 418
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 418
          if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 418
            tmp___10 = 1;
          } else {
#line 418
            if (__s2_len >= 4U) {
#line 418
              tmp___10 = 1;
            } else {
#line 418
              tmp___10 = 0;
            }
          }
        } else {
#line 418
          tmp___10 = 0;
        }
      }
#line 418
      if (tmp___10) {
#line 418
        tmp___6 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
      } else {
#line 418
        tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 418
        tmp___6 = tmp___9;
      }
    } else {
#line 418
      tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 418
      tmp___6 = tmp___9;
    }
#line 419
    if (tmp___6 != 0) {
#line 420
      log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 422
      return ((struct passwd *)((void *)0));
    } else {
#line 419
      if (0) {
#line 419
        __s1_len___0 = strlen((char const   *)s);
#line 419
        __s2_len___0 = strlen((char const   *)authctxt->service);
#line 419
        if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
          goto _L___2;
        } else {
#line 419
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 419
            if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 419
              tmp___20 = 1;
            } else {
#line 419
              if (__s2_len___0 >= 4U) {
#line 419
                tmp___20 = 1;
              } else {
#line 419
                tmp___20 = 0;
              }
            }
          } else {
#line 419
            tmp___20 = 0;
          }
        }
#line 419
        if (tmp___20) {
#line 419
          tmp___16 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
        } else {
#line 419
          tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 419
          tmp___16 = tmp___19;
        }
      } else {
#line 419
        tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 419
        tmp___16 = tmp___19;
      }
#line 419
      if (tmp___16 != 0) {
#line 420
        log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 422
        return ((struct passwd *)((void *)0));
      }
    }
  }
#line 425
  tmp___21 = auth_get_user();
#line 425
  return (tmp___21);
}
}
#line 473 "auth2.c"
static char const   *check[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 429 "auth2.c"
int user_dsa_key_allowed(struct passwd *pw , Key *key ) 
{ char line[8192] ;
  char file[1024] ;
  int found_key ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 433
  found_key = 0;
#line 434
  bits = 4294967295U;
#line 436
  linenum = 0UL;
#line 441
  temporarily_use_uid(pw->pw_uid);
#line 444
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys2");
#line 448
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 448
  if (tmp < 0) {
#line 450
    restore_uid();
#line 451
    return (0);
  }
#line 454
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 455
  if (! f) {
#line 457
    restore_uid();
#line 458
    return (0);
  }
#line 460
  if (options.strict_modes) {
#line 461
    fail = 0;
#line 464
    tmp___1 = fileno(f);
#line 464
    tmp___2 = fstat(tmp___1, & st);
#line 464
    if (tmp___2 < 0) {
#line 467
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 469
      fail = 1;
    } else {
#line 464
      if (st.st_uid != 0U) {
#line 464
        if (st.st_uid != pw->pw_uid) {
#line 467
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 469
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 464
        if ((st.st_mode & 18U) != 0U) {
#line 467
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 469
          fail = 1;
        } else {
#line 476
          i = 0;
#line 476
          while (check[i]) {
#line 477
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check[i]);
#line 479
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 479
            if (tmp___0 < 0) {
#line 482
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 486
              fail = 1;
#line 487
              break;
            } else {
#line 479
              if (st.st_uid != 0U) {
#line 479
                if (st.st_uid != pw->pw_uid) {
#line 482
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 486
                  fail = 1;
#line 487
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 479
                if ((st.st_mode & 18U) != 0U) {
#line 482
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 486
                  fail = 1;
#line 487
                  break;
                }
              }
            }
#line 476
            i ++;
          }
        }
      }
    }
#line 491
    if (fail) {
#line 492
      fclose(f);
#line 493
      log("%s", buf___1);
#line 494
      restore_uid();
#line 495
      return (0);
    }
  }
#line 498
  found_key = 0;
#line 499
  found = key_new(1);
#line 501
  while (1) {
#line 501
    tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 501
    if (! tmp___5) {
#line 501
      break;
    }
#line 502
    options___0 = (char *)((void *)0);
#line 503
    linenum ++;
#line 505
    cp = line;
#line 505
    while (1) {
#line 505
      if (! ((int )*cp == 32)) {
#line 505
        if (! ((int )*cp == 9)) {
#line 505
          break;
        }
      }
#line 505
      cp ++;
    }
#line 507
    if (! *cp) {
#line 508
      continue;
    } else {
#line 507
      if ((int )*cp == 10) {
#line 508
        continue;
      } else {
#line 507
        if ((int )*cp == 35) {
#line 508
          continue;
        }
      }
    }
#line 510
    bits = key_read(found, & cp);
#line 511
    if (bits == 0U) {
#line 513
      quoted = 0;
#line 514
      options___0 = cp;
#line 515
      while (1) {
#line 515
        if (*cp) {
#line 515
          if (! quoted) {
#line 515
            if ((int )*cp != 32) {
#line 515
              if (! ((int )*cp != 9)) {
#line 515
                break;
              }
            } else {
#line 515
              break;
            }
          }
        } else {
#line 515
          break;
        }
#line 516
        if ((int )*cp == 92) {
#line 516
          if ((int )*(cp + 1) == 34) {
#line 517
            cp ++;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 518
          if ((int )*cp == 34) {
#line 519
            quoted = ! quoted;
          }
        }
#line 515
        cp ++;
      }
#line 522
      while (1) {
#line 522
        if (! ((int )*cp == 32)) {
#line 522
          if (! ((int )*cp == 9)) {
#line 522
            break;
          }
        }
#line 522
        cp ++;
      }
#line 524
      bits = key_read(found, & cp);
#line 525
      if (bits == 0U) {
#line 527
        continue;
      }
    }
#line 530
    tmp___3 = key_equal(found, key);
#line 530
    if (tmp___3) {
#line 530
      tmp___4 = auth_parse_options(pw, options___0, linenum);
#line 530
      if (tmp___4 == 1) {
#line 532
        found_key = 1;
#line 533
        debug("matching key found: file %s, line %ld", file, linenum);
#line 535
        break;
      }
    }
  }
#line 538
  restore_uid();
#line 539
  fclose(f);
#line 540
  key_free(found);
#line 541
  return (found_key);
}
}
#line 1 "auth-rhosts.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 33 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 42
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 43
  if (! f) {
#line 44
    return (0);
  }
#line 46
  while (1) {
#line 46
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 46
    if (! tmp___50) {
#line 46
      break;
    }
#line 51
    cp = buf___1;
#line 51
    while (1) {
#line 51
      if (! ((int )*cp == 32)) {
#line 51
        if (! ((int )*cp == 9)) {
#line 51
          break;
        }
      }
#line 51
      cp ++;
    }
#line 53
    if ((int )*cp == 35) {
#line 54
      continue;
    } else {
#line 53
      if ((int )*cp == 10) {
#line 54
        continue;
      } else {
#line 53
        if (! *cp) {
#line 54
          continue;
        }
      }
    }
#line 60
    if (0) {
#line 60
      if (0) {
#line 60
        __s1_len___0 = strlen((char const   *)cp);
#line 60
        __s2_len___0 = strlen("NO_PLUS");
#line 60
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 60
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 60
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 60
              tmp___22 = 1;
            } else {
#line 60
              if (__s2_len___0 >= 4U) {
#line 60
                tmp___22 = 1;
              } else {
#line 60
                tmp___22 = 0;
              }
            }
          } else {
#line 60
            tmp___22 = 0;
          }
        }
#line 60
        if (tmp___22) {
#line 60
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 60
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
          tmp___18 = tmp___21;
        }
      } else {
#line 60
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
        tmp___18 = tmp___21;
      }
#line 60
      tmp___12 = tmp___18;
    } else {
#line 60
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 60
    if (tmp___12 == 0) {
#line 61
      continue;
    }
#line 67
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 67
    switch (tmp___25) {
    case 0: 
#line 69
    packet_send_debug("Found empty line in %.100s.", filename);
#line 70
    continue;
    case 1: 
#line 73
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 74
    break;
    case 2: 
#line 77
    break;
    case 3: 
#line 79
    packet_send_debug("Found garbage in %.100s.", filename);
#line 80
    continue;
    default: ;
#line 83
    continue;
    }
#line 86
    host = hostbuf;
#line 87
    user = userbuf;
#line 88
    negated = 0;
#line 91
    if ((int )*(host + 0) == 45) {
#line 92
      negated = 1;
#line 93
      host ++;
    } else {
#line 94
      if ((int )*(host + 0) == 43) {
#line 95
        host ++;
      }
    }
#line 97
    if ((int )*(user + 0) == 45) {
#line 98
      negated = 1;
#line 99
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 106
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 106
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
        continue;
      }
    }
#line 111
    if ((int )*(host + 0) == 64) {
#line 112
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 112
      if (! tmp___26) {
#line 112
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 112
        if (! tmp___27) {
#line 114
          continue;
        }
      }
    } else {
#line 115
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 115
      if (tmp___28) {
#line 115
        if (0) {
#line 115
          __s1_len___1 = strlen((char const   *)host);
#line 115
          __s2_len___1 = strlen(ipaddr);
#line 115
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 115
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 115
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 115
                tmp___38 = 1;
              } else {
#line 115
                if (__s2_len___1 >= 4U) {
#line 115
                  tmp___38 = 1;
                } else {
#line 115
                  tmp___38 = 0;
                }
              }
            } else {
#line 115
              tmp___38 = 0;
            }
          }
#line 115
          if (tmp___38) {
#line 115
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 115
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
            tmp___34 = tmp___37;
          }
        } else {
#line 115
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
          tmp___34 = tmp___37;
        }
#line 115
        if (tmp___34 != 0) {
#line 116
          continue;
        }
      }
    }
#line 119
    if ((int )*(user + 0) == 64) {
#line 120
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 120
      if (! tmp___39) {
#line 121
        continue;
      }
    } else {
#line 122
      if (0) {
#line 122
        __s1_len___2 = strlen((char const   *)user);
#line 122
        __s2_len___2 = strlen(client_user);
#line 122
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 122
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 122
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 122
              tmp___49 = 1;
            } else {
#line 122
              if (__s2_len___2 >= 4U) {
#line 122
                tmp___49 = 1;
              } else {
#line 122
                tmp___49 = 0;
              }
            }
          } else {
#line 122
            tmp___49 = 0;
          }
        }
#line 122
        if (tmp___49) {
#line 122
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 122
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
          tmp___45 = tmp___48;
        }
      } else {
#line 122
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
        tmp___45 = tmp___48;
      }
#line 122
      if (tmp___45 != 0) {
#line 123
        continue;
      }
    }
#line 126
    fclose(f);
#line 129
    if (negated) {
#line 130
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 132
      return (0);
    }
#line 135
    return (1);
  }
#line 139
  fclose(f);
#line 140
  return (0);
}
}
#line 156 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 149 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf___1[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 160
  temporarily_use_uid(pw->pw_uid);
#line 166
  rhosts_file_index = 0U;
#line 166
  while (rhosts_files[rhosts_file_index]) {
#line 169
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 171
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 171
    if (tmp >= 0) {
#line 172
      break;
    }
#line 166
    rhosts_file_index ++;
  }
#line 175
  restore_uid();
#line 178
  if (! rhosts_files[rhosts_file_index]) {
#line 178
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 178
    if (tmp___0 < 0) {
#line 178
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 178
      if (tmp___1 < 0) {
#line 181
        return (0);
      }
    }
  }
#line 183
  hostname = get_canonical_hostname();
#line 184
  ipaddr = get_remote_ipaddr();
#line 187
  if (pw->pw_uid != 0U) {
#line 188
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 188
    if (tmp___2) {
#line 190
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 192
      return (1);
    }
#line 194
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 194
    if (tmp___3) {
#line 196
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 198
      return (1);
    }
  }
#line 205
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 205
  if (tmp___4 < 0) {
#line 206
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 208
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 210
    return (0);
  }
#line 212
  if (options.strict_modes) {
#line 212
    if (st.st_uid != 0U) {
#line 212
      if (st.st_uid != pw->pw_uid) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 212
      if ((st.st_mode & 18U) != 0U) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      }
    }
  }
#line 222
  temporarily_use_uid(pw->pw_uid);
#line 225
  rhosts_file_index = 0U;
#line 225
  while (rhosts_files[rhosts_file_index]) {
#line 228
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 230
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 230
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 239
    if (options.strict_modes) {
#line 239
      if (st.st_uid != 0U) {
#line 239
        if (st.st_uid != pw->pw_uid) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 239
        if ((st.st_mode & 18U) != 0U) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 248
    if (options.ignore_rhosts) {
#line 249
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 254
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 254
    if (tmp___6) {
#line 255
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 258
      restore_uid();
#line 259
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 225
    rhosts_file_index ++;
  }
#line 264
  restore_uid();
#line 265
  return (0);
}
}
#line 1 "auth-options.o"
#line 10 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 11 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 12 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 13 "auth-options.c"
int no_pty_flag  =    0;
#line 16 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 19 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 22 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *options___0 , unsigned long linenum ) 
{ char const   *cp ;
  size_t tmp ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___34 ;
  int tmp___52 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t tmp___63 ;
  size_t tmp___69 ;
  int tmp___87 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___93 ;
  int tmp___96 ;
  int tmp___97 ;
  size_t tmp___98 ;
  size_t tmp___104 ;
  int tmp___122 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___128 ;
  int tmp___131 ;
  int tmp___132 ;
  size_t tmp___133 ;
  int i ;
  size_t tmp___139 ;
  size_t tmp___140 ;
  void *tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  char *tmp___144 ;
  int tmp___162 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___168 ;
  int tmp___171 ;
  int tmp___172 ;
  size_t tmp___173 ;
  int i___0 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___179 ;
  size_t tmp___180 ;
  void *tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  char *tmp___184 ;
  void *tmp___185 ;
  int tmp___203 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___209 ;
  int tmp___212 ;
  int tmp___213 ;
  size_t tmp___214 ;
  int mname ;
  int mip ;
  char *patterns ;
  size_t tmp___220 ;
  void *tmp___221 ;
  int i___1 ;
  size_t tmp___222 ;
  int tmp___223 ;
  int tmp___224 ;
  char *tmp___225 ;
  size_t tmp___226 ;
  char const   *tmp___227 ;
  size_t tmp___228 ;
  char const   *tmp___229 ;
  char const   *tmp___230 ;
  char const   *tmp___231 ;
  char const   *tmp___232 ;
  struct envstring *ce ;
  int tmp___250 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___256 ;
  int tmp___259 ;
  int tmp___260 ;
  size_t tmp___261 ;

  {
#line 26
  if (! options___0) {
#line 27
    return (1);
  }
#line 28
  while (1) {
#line 28
    if (*options___0) {
#line 28
      if ((int )*options___0 != 32) {
#line 28
        if (! ((int )*options___0 != 9)) {
#line 28
          break;
        }
      } else {
#line 28
        break;
      }
    } else {
#line 28
      break;
    }
#line 29
    cp = "no-port-forwarding";
#line 30
    if (0) {
#line 30
      if (0) {
#line 30
        __s1_len___0 = strlen((char const   *)options___0);
#line 30
        __s2_len___0 = strlen(cp);
#line 30
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___2;
        } else {
#line 30
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 30
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 30
              tmp___27 = 1;
            } else {
#line 30
              if (__s2_len___0 >= 4U) {
#line 30
                tmp___27 = 1;
              } else {
#line 30
                tmp___27 = 0;
              }
            }
          } else {
#line 30
            tmp___27 = 0;
          }
        }
#line 30
        if (tmp___27) {
#line 30
          tmp___23 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 30
          tmp___26 = __builtin_strcmp((char const   *)options___0, cp);
#line 30
          tmp___23 = tmp___26;
        }
      } else {
#line 30
        tmp___26 = __builtin_strcmp((char const   *)options___0, cp);
#line 30
        tmp___23 = tmp___26;
      }
#line 30
      tmp___17 = tmp___23;
    } else {
#line 30
      tmp___28 = strlen(cp);
#line 30
      tmp___17 = strncmp((char const   *)options___0, cp, tmp___28);
    }
#line 30
    if (tmp___17 == 0) {
#line 31
      packet_send_debug("Port forwarding disabled.");
#line 32
      no_port_forwarding_flag = 1;
#line 33
      tmp = strlen(cp);
#line 33
      options___0 += tmp;
      goto next_option;
    }
#line 36
    cp = "no-agent-forwarding";
#line 37
    if (0) {
#line 37
      if (0) {
#line 37
        __s1_len___2 = strlen((char const   *)options___0);
#line 37
        __s2_len___2 = strlen(cp);
#line 37
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___6;
        } else {
#line 37
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 37
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 37
              tmp___62 = 1;
            } else {
#line 37
              if (__s2_len___2 >= 4U) {
#line 37
                tmp___62 = 1;
              } else {
#line 37
                tmp___62 = 0;
              }
            }
          } else {
#line 37
            tmp___62 = 0;
          }
        }
#line 37
        if (tmp___62) {
#line 37
          tmp___58 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 37
          tmp___61 = __builtin_strcmp((char const   *)options___0, cp);
#line 37
          tmp___58 = tmp___61;
        }
      } else {
#line 37
        tmp___61 = __builtin_strcmp((char const   *)options___0, cp);
#line 37
        tmp___58 = tmp___61;
      }
#line 37
      tmp___52 = tmp___58;
    } else {
#line 37
      tmp___63 = strlen(cp);
#line 37
      tmp___52 = strncmp((char const   *)options___0, cp, tmp___63);
    }
#line 37
    if (tmp___52 == 0) {
#line 38
      packet_send_debug("Agent forwarding disabled.");
#line 39
      no_agent_forwarding_flag = 1;
#line 40
      tmp___34 = strlen(cp);
#line 40
      options___0 += tmp___34;
      goto next_option;
    }
#line 43
    cp = "no-X11-forwarding";
#line 44
    if (0) {
#line 44
      if (0) {
#line 44
        __s1_len___4 = strlen((char const   *)options___0);
#line 44
        __s2_len___4 = strlen(cp);
#line 44
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___10;
        } else {
#line 44
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 44
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 44
              tmp___97 = 1;
            } else {
#line 44
              if (__s2_len___4 >= 4U) {
#line 44
                tmp___97 = 1;
              } else {
#line 44
                tmp___97 = 0;
              }
            }
          } else {
#line 44
            tmp___97 = 0;
          }
        }
#line 44
        if (tmp___97) {
#line 44
          tmp___93 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 44
          tmp___96 = __builtin_strcmp((char const   *)options___0, cp);
#line 44
          tmp___93 = tmp___96;
        }
      } else {
#line 44
        tmp___96 = __builtin_strcmp((char const   *)options___0, cp);
#line 44
        tmp___93 = tmp___96;
      }
#line 44
      tmp___87 = tmp___93;
    } else {
#line 44
      tmp___98 = strlen(cp);
#line 44
      tmp___87 = strncmp((char const   *)options___0, cp, tmp___98);
    }
#line 44
    if (tmp___87 == 0) {
#line 45
      packet_send_debug("X11 forwarding disabled.");
#line 46
      no_x11_forwarding_flag = 1;
#line 47
      tmp___69 = strlen(cp);
#line 47
      options___0 += tmp___69;
      goto next_option;
    }
#line 50
    cp = "no-pty";
#line 51
    if (0) {
#line 51
      if (0) {
#line 51
        __s1_len___6 = strlen((char const   *)options___0);
#line 51
        __s2_len___6 = strlen(cp);
#line 51
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___14;
        } else {
#line 51
          if (__s1_len___6 >= 4U) {
            _L___14: /* CIL Label */ 
#line 51
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 51
              tmp___132 = 1;
            } else {
#line 51
              if (__s2_len___6 >= 4U) {
#line 51
                tmp___132 = 1;
              } else {
#line 51
                tmp___132 = 0;
              }
            }
          } else {
#line 51
            tmp___132 = 0;
          }
        }
#line 51
        if (tmp___132) {
#line 51
          tmp___128 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 51
          tmp___131 = __builtin_strcmp((char const   *)options___0, cp);
#line 51
          tmp___128 = tmp___131;
        }
      } else {
#line 51
        tmp___131 = __builtin_strcmp((char const   *)options___0, cp);
#line 51
        tmp___128 = tmp___131;
      }
#line 51
      tmp___122 = tmp___128;
    } else {
#line 51
      tmp___133 = strlen(cp);
#line 51
      tmp___122 = strncmp((char const   *)options___0, cp, tmp___133);
    }
#line 51
    if (tmp___122 == 0) {
#line 52
      packet_send_debug("Pty allocation disabled.");
#line 53
      no_pty_flag = 1;
#line 54
      tmp___104 = strlen(cp);
#line 54
      options___0 += tmp___104;
      goto next_option;
    }
#line 57
    cp = "command=\"";
#line 58
    if (0) {
#line 58
      if (0) {
#line 58
        __s1_len___8 = strlen((char const   *)options___0);
#line 58
        __s2_len___8 = strlen(cp);
#line 58
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___18;
        } else {
#line 58
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 58
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 58
              tmp___172 = 1;
            } else {
#line 58
              if (__s2_len___8 >= 4U) {
#line 58
                tmp___172 = 1;
              } else {
#line 58
                tmp___172 = 0;
              }
            }
          } else {
#line 58
            tmp___172 = 0;
          }
        }
#line 58
        if (tmp___172) {
#line 58
          tmp___168 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 58
          tmp___171 = __builtin_strcmp((char const   *)options___0, cp);
#line 58
          tmp___168 = tmp___171;
        }
      } else {
#line 58
        tmp___171 = __builtin_strcmp((char const   *)options___0, cp);
#line 58
        tmp___168 = tmp___171;
      }
#line 58
      tmp___162 = tmp___168;
    } else {
#line 58
      tmp___173 = strlen(cp);
#line 58
      tmp___162 = strncmp((char const   *)options___0, cp, tmp___173);
    }
#line 58
    if (tmp___162 == 0) {
#line 60
      tmp___139 = strlen(cp);
#line 60
      options___0 += tmp___139;
#line 61
      tmp___140 = strlen((char const   *)options___0);
#line 61
      tmp___141 = xmalloc(tmp___140 + 1U);
#line 61
      forced_command = (char *)tmp___141;
#line 62
      i = 0;
#line 63
      while (*options___0) {
#line 64
        if ((int )*options___0 == 34) {
#line 65
          break;
        }
#line 66
        if ((int )*options___0 == 92) {
#line 66
          if ((int )*(options___0 + 1) == 34) {
#line 67
            options___0 += 2;
#line 68
            tmp___142 = i;
#line 68
            i ++;
#line 68
            *(forced_command + tmp___142) = (char )'\"';
#line 69
            continue;
          }
        }
#line 71
        tmp___143 = i;
#line 71
        i ++;
#line 71
        tmp___144 = options___0;
#line 71
        options___0 ++;
#line 71
        *(forced_command + tmp___143) = *tmp___144;
      }
#line 73
      if (! *options___0) {
#line 74
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 76
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 78
        continue;
      }
#line 80
      *(forced_command + i) = (char)0;
#line 81
      packet_send_debug("Forced command: %.900s", forced_command);
#line 82
      options___0 ++;
      goto next_option;
    }
#line 85
    cp = "environment=\"";
#line 86
    if (0) {
#line 86
      if (0) {
#line 86
        __s1_len___10 = strlen((char const   *)options___0);
#line 86
        __s2_len___10 = strlen(cp);
#line 86
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___22;
        } else {
#line 86
          if (__s1_len___10 >= 4U) {
            _L___22: /* CIL Label */ 
#line 86
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 86
              tmp___213 = 1;
            } else {
#line 86
              if (__s2_len___10 >= 4U) {
#line 86
                tmp___213 = 1;
              } else {
#line 86
                tmp___213 = 0;
              }
            }
          } else {
#line 86
            tmp___213 = 0;
          }
        }
#line 86
        if (tmp___213) {
#line 86
          tmp___209 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 86
          tmp___212 = __builtin_strcmp((char const   *)options___0, cp);
#line 86
          tmp___209 = tmp___212;
        }
      } else {
#line 86
        tmp___212 = __builtin_strcmp((char const   *)options___0, cp);
#line 86
        tmp___209 = tmp___212;
      }
#line 86
      tmp___203 = tmp___209;
    } else {
#line 86
      tmp___214 = strlen(cp);
#line 86
      tmp___203 = strncmp((char const   *)options___0, cp, tmp___214);
    }
#line 86
    if (tmp___203 == 0) {
#line 90
      tmp___179 = strlen(cp);
#line 90
      options___0 += tmp___179;
#line 91
      tmp___180 = strlen((char const   *)options___0);
#line 91
      tmp___181 = xmalloc(tmp___180 + 1U);
#line 91
      s = (char *)tmp___181;
#line 92
      i___0 = 0;
#line 93
      while (*options___0) {
#line 94
        if ((int )*options___0 == 34) {
#line 95
          break;
        }
#line 96
        if ((int )*options___0 == 92) {
#line 96
          if ((int )*(options___0 + 1) == 34) {
#line 97
            options___0 += 2;
#line 98
            tmp___182 = i___0;
#line 98
            i___0 ++;
#line 98
            *(s + tmp___182) = (char )'\"';
#line 99
            continue;
          }
        }
#line 101
        tmp___183 = i___0;
#line 101
        i___0 ++;
#line 101
        tmp___184 = options___0;
#line 101
        options___0 ++;
#line 101
        *(s + tmp___183) = *tmp___184;
      }
#line 103
      if (! *options___0) {
#line 104
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 106
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 108
        continue;
      }
#line 110
      *(s + i___0) = (char)0;
#line 111
      packet_send_debug("Adding to environment: %.900s", s);
#line 112
      debug("Adding to environment: %.900s", s);
#line 113
      options___0 ++;
#line 114
      tmp___185 = xmalloc(sizeof(struct envstring ));
#line 114
      new_envstring = (struct envstring *)tmp___185;
#line 115
      new_envstring->s = s;
#line 116
      new_envstring->next = custom_environment;
#line 117
      custom_environment = new_envstring;
      goto next_option;
    }
#line 120
    cp = "from=\"";
#line 121
    if (0) {
#line 121
      if (0) {
#line 121
        __s1_len___12 = strlen((char const   *)options___0);
#line 121
        __s2_len___12 = strlen(cp);
#line 121
        if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
          goto _L___27;
        } else {
#line 121
          if (__s1_len___12 >= 4U) {
            _L___27: /* CIL Label */ 
#line 121
            if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 121
              tmp___260 = 1;
            } else {
#line 121
              if (__s2_len___12 >= 4U) {
#line 121
                tmp___260 = 1;
              } else {
#line 121
                tmp___260 = 0;
              }
            }
          } else {
#line 121
            tmp___260 = 0;
          }
        }
#line 121
        if (tmp___260) {
#line 121
          tmp___256 = __builtin_strcmp((char const   *)options___0, cp);
        } else {
#line 121
          tmp___259 = __builtin_strcmp((char const   *)options___0, cp);
#line 121
          tmp___256 = tmp___259;
        }
      } else {
#line 121
        tmp___259 = __builtin_strcmp((char const   *)options___0, cp);
#line 121
        tmp___256 = tmp___259;
      }
#line 121
      tmp___250 = tmp___256;
    } else {
#line 121
      tmp___261 = strlen(cp);
#line 121
      tmp___250 = strncmp((char const   *)options___0, cp, tmp___261);
    }
#line 121
    if (tmp___250 == 0) {
#line 123
      tmp___220 = strlen((char const   *)options___0);
#line 123
      tmp___221 = xmalloc(tmp___220 + 1U);
#line 123
      patterns = (char *)tmp___221;
#line 125
      tmp___222 = strlen(cp);
#line 125
      options___0 += tmp___222;
#line 126
      i___1 = 0;
#line 127
      while (*options___0) {
#line 128
        if ((int )*options___0 == 34) {
#line 129
          break;
        }
#line 130
        if ((int )*options___0 == 92) {
#line 130
          if ((int )*(options___0 + 1) == 34) {
#line 131
            options___0 += 2;
#line 132
            tmp___223 = i___1;
#line 132
            i___1 ++;
#line 132
            *(patterns + tmp___223) = (char )'\"';
#line 133
            continue;
          }
        }
#line 135
        tmp___224 = i___1;
#line 135
        i___1 ++;
#line 135
        tmp___225 = options___0;
#line 135
        options___0 ++;
#line 135
        *(patterns + tmp___224) = *tmp___225;
      }
#line 137
      if (! *options___0) {
#line 138
        debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 140
        packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                          linenum);
#line 142
        continue;
      }
#line 144
      *(patterns + i___1) = (char)0;
#line 145
      options___0 ++;
#line 151
      tmp___226 = strlen((char const   *)patterns);
#line 151
      tmp___227 = get_canonical_hostname();
#line 151
      mname = match_hostname(tmp___227, (char const   *)patterns, tmp___226);
#line 153
      tmp___228 = strlen((char const   *)patterns);
#line 153
      tmp___229 = get_remote_ipaddr();
#line 153
      mip = match_hostname(tmp___229, (char const   *)patterns, tmp___228);
#line 155
      xfree((void *)patterns);
#line 156
      if (mname == -1) {
        goto _L___23;
      } else {
#line 156
        if (mip == -1) {
          goto _L___23;
        } else {
#line 156
          if (mname != 1) {
#line 156
            if (mip != 1) {
              _L___23: /* CIL Label */ 
#line 158
              tmp___230 = get_remote_ipaddr();
#line 158
              tmp___231 = get_canonical_hostname();
#line 158
              log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___231, tmp___230);
#line 161
              tmp___232 = get_canonical_hostname();
#line 161
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___232);
#line 164
              no_agent_forwarding_flag = 0;
#line 165
              no_port_forwarding_flag = 0;
#line 166
              no_pty_flag = 0;
#line 167
              no_x11_forwarding_flag = 0;
#line 168
              while (custom_environment) {
#line 169
                ce = custom_environment;
#line 170
                custom_environment = ce->next;
#line 171
                xfree((void *)ce->s);
#line 172
                xfree((void *)ce);
              }
#line 174
              if (forced_command) {
#line 175
                xfree((void *)forced_command);
#line 176
                forced_command = (char *)((void *)0);
              }
#line 179
              return (0);
            }
          }
        }
      }
      goto next_option;
    }
    next_option: 
#line 189
    if (! *options___0) {
#line 190
      fatal("Bugs in auth-options.c option processing.");
    }
#line 191
    if ((int )*options___0 == 32) {
#line 192
      break;
    } else {
#line 191
      if ((int )*options___0 == 9) {
#line 192
        break;
      }
    }
#line 193
    if ((int )*options___0 != 44) {
      goto bad_option;
    }
#line 195
    options___0 ++;
  }
#line 199
  return (1);
  bad_option: 
#line 202
  log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys", linenum,
      options___0);
#line 204
  packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                    linenum, options___0);
#line 207
  return (0);
}
}
#line 1 "auth-krb4.o"
#line 1 "auth-pam.o"
#line 590 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 182
extern char ** __attribute__((__nonnull__(1))) pam_getenvlist(pam_handle_t *pamh ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 35
extern int __attribute__((__nonnull__(1)))  pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 9 "auth-pam.h"
char **fetch_pam_environment(void) ;
#line 11
void do_pam_session(char *username , char const   *ttyname___0 ) ;
#line 12
void do_pam_setcred(void) ;
#line 13
void print_pam_messages(void) ;
#line 43 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 45
void pam_cleanup_proc(void *context ) ;
#line 46
void pam_msg_cat(char const   *msg ) ;
#line 49 "auth-pam.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 53 "auth-pam.c"
static struct pam_handle_t *pamh  =    (struct pam_handle_t *)((void *)0);
#line 54 "auth-pam.c"
static char const   *pampasswd  =    (char const   *)((void *)0);
#line 55 "auth-pam.c"
static char *pam_msg  =    (char *)((void *)0);
#line 59 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ struct pam_response *reply ;
  int count ;
  void *tmp ;

  {
#line 66
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 66
  reply = (struct pam_response *)tmp;
#line 67
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 68
    return (19);
  }
#line 70
  count = 0;
#line 70
  while (count < num_msg) {
#line 71
    switch ((int )(*(msg + count))->msg_style) {
    case 1: 
#line 73
    if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 74
      free((void *)reply);
#line 75
      return (19);
    }
#line 77
    (reply + count)->resp_retcode = 0;
#line 78
    (reply + count)->resp = xstrdup(pampasswd);
#line 79
    break;
    case 4: 
#line 81
    (reply + count)->resp_retcode = 0;
#line 82
    (reply + count)->resp = xstrdup("");
#line 84
    if ((unsigned int )(*(msg + count))->msg != (unsigned int )((void *)0)) {
#line 85
      pam_msg_cat((char const   *)(*(msg + count))->msg);
    }
#line 87
    break;
    default: 
#line 89
    free((void *)reply);
#line 90
    return (19);
    }
#line 70
    count ++;
  }
#line 94
  *resp = reply;
#line 96
  return (0);
}
}
#line 100 "auth-pam.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;

  {
#line 104
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 106
    tmp = pam_close_session((pam_handle_t *)pamh, 0);
#line 106
    pam_retval = (int )tmp;
#line 107
    if (pam_retval != 0) {
#line 108
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 108
      log("Cannot close PAM session: %.200s", tmp___0);
    }
#line 112
    tmp___1 = pam_setcred((pam_handle_t *)pamh, 4);
#line 112
    pam_retval = (int )tmp___1;
#line 113
    if (pam_retval != 0) {
#line 114
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 114
      log("Cannot delete credentials: %.200s", tmp___2);
    }
#line 118
    tmp___3 = pam_end((pam_handle_t *)pamh, pam_retval);
#line 118
    pam_retval = (int )tmp___3;
#line 119
    if (pam_retval != 0) {
#line 120
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 120
      log("Cannot release PAM authentication: %.200s", tmp___4);
    }
  }
#line 124
  return;
}
}
#line 127 "auth-pam.c"
int auth_pam_password(struct passwd *pw , char const   *password ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 133
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 134
    return (0);
  }
#line 135
  if (pw->pw_uid == 0U) {
#line 135
    if (options.permit_root_login == 2) {
#line 136
      return (0);
    }
  }
#line 137
  if ((int const   )*password == 0) {
#line 137
    if (options.permit_empty_passwd == 0) {
#line 138
      return (0);
    }
  }
#line 140
  pampasswd = password;
#line 142
  tmp = pam_authenticate((pam_handle_t *)pamh, 0);
#line 142
  pam_retval = (int )tmp;
#line 143
  if (pam_retval == 0) {
#line 144
    debug("PAM Password authentication accepted for user \"%.100s\"", pw->pw_name);
#line 146
    return (1);
  } else {
#line 148
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 148
    debug("PAM Password authentication for \"%.100s\" failed: %s", pw->pw_name, tmp___0);
#line 150
    return (0);
  }
}
}
#line 155 "auth-pam.c"
int do_pam_account(char *username , char *remote_user ) 
{ int pam_retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 159
  tmp = get_canonical_hostname();
#line 159
  debug("PAM setting rhost to \"%.200s\"", tmp);
#line 160
  tmp___0 = get_canonical_hostname();
#line 160
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 4, (void const   *)tmp___0);
#line 160
  pam_retval = (int )tmp___1;
#line 162
  if (pam_retval != 0) {
#line 163
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 163
    fatal("PAM set rhost failed: %.200s", tmp___2);
  }
#line 167
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 168
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 169
    tmp___3 = pam_set_item((pam_handle_t *)pamh, 8, (void const   *)remote_user);
#line 169
    pam_retval = (int )tmp___3;
#line 170
    if (pam_retval != 0) {
#line 171
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 171
      fatal("PAM set ruser failed: %.200s", tmp___4);
    }
  }
#line 176
  tmp___5 = pam_acct_mgmt((pam_handle_t *)pamh, 0);
#line 176
  pam_retval = (int )tmp___5;
#line 177
  switch (pam_retval) {
  case 0: 
#line 180
  break;
  case 12: 
#line 182
  pam_msg_cat("Warning: You password has expired, please change it now");
#line 183
  break;
  default: 
#line 185
  tmp___6 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 185
  log("PAM rejected by account configuration: %.200s", tmp___6);
#line 187
  return (0);
  }
#line 190
  return (1);
}
}
#line 194 "auth-pam.c"
void do_pam_session(char *username , char const   *ttyname___0 ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 198
  if ((unsigned int )ttyname___0 != (unsigned int )((void *)0)) {
#line 199
    debug("PAM setting tty to \"%.200s\"", ttyname___0);
#line 200
    tmp = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)ttyname___0);
#line 200
    pam_retval = (int )tmp;
#line 201
    if (pam_retval != 0) {
#line 202
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 202
      fatal("PAM set tty failed: %.200s", tmp___0);
    }
  }
#line 207
  tmp___1 = pam_open_session((pam_handle_t *)pamh, 0);
#line 207
  pam_retval = (int )tmp___1;
#line 208
  if (pam_retval != 0) {
#line 209
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 209
    fatal("PAM session setup failed: %.200s", tmp___2);
  }
#line 212
  return;
}
}
#line 215 "auth-pam.c"
void do_pam_setcred(void) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 219
  debug("PAM establishing creds");
#line 220
  tmp = pam_setcred((pam_handle_t *)pamh, 2);
#line 220
  pam_retval = (int )tmp;
#line 221
  if (pam_retval != 0) {
#line 222
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 222
    fatal("PAM setcred failed: %.200s", tmp___0);
  }
#line 225
  return;
}
}
#line 228 "auth-pam.c"
void finish_pam(void) 
{ 

  {
#line 230
  pam_cleanup_proc((void *)0);
#line 231
  fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
#line 232
  return;
}
}
#line 235 "auth-pam.c"
void start_pam(struct passwd *pw ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1,3,4)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 239
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 241
  tmp = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                  (pam_handle_t **)(& pamh));
#line 241
  pam_retval = (int )tmp;
#line 244
  if (pam_retval != 0) {
#line 245
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 245
    fatal("PAM initialisation failed: %.200s", tmp___0);
  }
#line 257
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)"ssh");
#line 257
  pam_retval = (int )tmp___1;
#line 258
  if (pam_retval != 0) {
#line 259
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 259
    fatal("PAM set tty failed: %.200s", tmp___2);
  }
#line 264
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 265
  return;
}
}
#line 268 "auth-pam.c"
char **fetch_pam_environment(void) 
{ char ** __attribute__((__nonnull__(1))) tmp ;

  {
#line 271
  tmp = pam_getenvlist((pam_handle_t *)pamh);
#line 271
  return ((char **)tmp);
}
}
#line 279 "auth-pam.c"
void print_pam_messages(void) 
{ 

  {
#line 281
  if ((unsigned int )pam_msg != (unsigned int )((void *)0)) {
#line 282
    fputs((char const   * __restrict  )pam_msg, (FILE * __restrict  )stderr);
  }
#line 283
  return;
}
}
#line 286 "auth-pam.c"
void pam_msg_cat(char const   *msg ) 
{ char *p ;
  size_t new_msg_len ;
  size_t pam_msg_len ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 292
  new_msg_len = strlen(msg);
#line 294
  if (pam_msg) {
#line 295
    pam_msg_len = strlen((char const   *)pam_msg);
#line 296
    tmp = xrealloc((void *)pam_msg, (new_msg_len + pam_msg_len) + 2U);
#line 296
    pam_msg = (char *)tmp;
#line 297
    p = pam_msg + pam_msg_len;
  } else {
#line 299
    tmp___0 = xmalloc(new_msg_len + 2U);
#line 299
    p = (char *)tmp___0;
#line 299
    pam_msg = p;
  }
#line 302
  memcpy((void * __restrict  )p, (void const   * __restrict  )msg, new_msg_len);
#line 303
  *(p + new_msg_len) = (char )'\n';
#line 304
  *(p + (new_msg_len + 1U)) = (char )'\000';
#line 305
  return;
}
}
#line 1 "auth-passwd.o"
#line 1 "auth-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 416 "ssh.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 56 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  unsigned char buf___1[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 66
  encrypted_challenge = BN_new();
#line 67
  challenge = BN_new();
#line 70
  BN_rand(challenge, 256, 0, 0);
#line 71
  ctx = BN_CTX_new();
#line 72
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 73
  BN_CTX_free(ctx);
#line 76
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 79
  packet_start(7);
#line 80
  packet_put_bignum(encrypted_challenge);
#line 81
  packet_send();
#line 82
  BN_clear_free(encrypted_challenge);
#line 83
  packet_write_wait();
#line 86
  packet_read_expect(& plen, 8);
#line 87
  while (1) {
#line 87
    _p = plen;
#line 87
    _e = 16;
#line 87
    if (_p != _e) {
#line 87
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 87);
#line 87
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 87
    break;
  }
#line 88
  i = 0U;
#line 88
  while (i < 16U) {
#line 89
    tmp = packet_get_char();
#line 89
    response[i] = (unsigned char )tmp;
#line 88
    i ++;
  }
#line 92
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 92
  len = (tmp___0 + 7) / 8;
#line 93
  if (len <= 0) {
#line 94
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 93
    if (len > 32) {
#line 94
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 95
  memset((void *)(buf___1), 0, 32U);
#line 96
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 97
  MD5_Init(& md);
#line 98
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 99
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 100
  MD5_Final(mdbuf, & md);
#line 101
  BN_clear_free(challenge);
#line 104
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 104
  if (tmp___1 != 0) {
#line 106
    return (0);
  }
#line 109
  return (1);
}
}
#line 165 "auth-rsa.c"
static char const   *check___0[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 118 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[1024] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 126
  linenum = 0UL;
#line 131
  temporarily_use_uid(pw->pw_uid);
#line 134
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 138
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 138
  if (tmp < 0) {
#line 140
    restore_uid();
#line 141
    return (0);
  }
#line 144
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 145
  if (! f) {
#line 147
    restore_uid();
#line 148
    packet_send_debug("Could not open %.900s for reading.", file);
#line 149
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 150
    return (0);
  }
#line 152
  if (options.strict_modes) {
#line 153
    fail = 0;
#line 156
    tmp___1 = fileno(f);
#line 156
    tmp___2 = fstat(tmp___1, & st);
#line 156
    if (tmp___2 < 0) {
#line 159
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 161
      fail = 1;
    } else {
#line 156
      if (st.st_uid != 0U) {
#line 156
        if (st.st_uid != pw->pw_uid) {
#line 159
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 161
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 156
        if ((st.st_mode & 18U) != 0U) {
#line 159
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 161
          fail = 1;
        } else {
#line 168
          i = 0;
#line 168
          while (check___0[i]) {
#line 169
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___0[i]);
#line 170
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 170
            if (tmp___0 < 0) {
#line 173
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 175
              fail = 1;
#line 176
              break;
            } else {
#line 170
              if (st.st_uid != 0U) {
#line 170
                if (st.st_uid != pw->pw_uid) {
#line 173
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 175
                  fail = 1;
#line 176
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 170
                if ((st.st_mode & 18U) != 0U) {
#line 173
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 175
                  fail = 1;
#line 176
                  break;
                }
              }
            }
#line 168
            i ++;
          }
        }
      }
    }
#line 180
    if (fail) {
#line 181
      fclose(f);
#line 182
      log("%s", buf___1);
#line 183
      packet_send_debug("%s", buf___1);
#line 184
      restore_uid();
#line 185
      return (0);
    }
  }
#line 189
  authenticated = 0;
#line 191
  pk = RSA_new();
#line 192
  pk->e = BN_new();
#line 193
  pk->n = BN_new();
#line 200
  while (1) {
#line 200
    tmp___8 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 200
    if (! tmp___8) {
#line 200
      break;
    }
#line 204
    linenum ++;
#line 207
    cp = line;
#line 207
    while (1) {
#line 207
      if (! ((int )*cp == 32)) {
#line 207
        if (! ((int )*cp == 9)) {
#line 207
          break;
        }
      }
#line 207
      cp ++;
    }
#line 209
    if (! *cp) {
#line 210
      continue;
    } else {
#line 209
      if ((int )*cp == 10) {
#line 210
        continue;
      } else {
#line 209
        if ((int )*cp == 35) {
#line 210
          continue;
        }
      }
    }
#line 218
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 218
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 219
        quoted = 0;
#line 220
        options___0 = cp;
#line 221
        while (1) {
#line 221
          if (*cp) {
#line 221
            if (! quoted) {
#line 221
              if ((int )*cp != 32) {
#line 221
                if (! ((int )*cp != 9)) {
#line 221
                  break;
                }
              } else {
#line 221
                break;
              }
            }
          } else {
#line 221
            break;
          }
#line 222
          if ((int )*cp == 92) {
#line 222
            if ((int )*(cp + 1) == 34) {
#line 223
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 224
            if ((int )*cp == 34) {
#line 225
              quoted = ! quoted;
            }
          }
#line 221
          cp ++;
        }
      } else {
#line 228
        options___0 = (char *)((void *)0);
      }
    }
#line 231
    tmp___3 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 231
    if (! tmp___3) {
#line 232
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 234
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 236
      continue;
    }
#line 241
    tmp___4 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 241
    if (tmp___4 != 0) {
#line 242
      continue;
    }
#line 245
    tmp___6 = BN_num_bits((BIGNUM const   *)pk->n);
#line 245
    if (bits != (unsigned int )tmp___6) {
#line 246
      tmp___5 = BN_num_bits((BIGNUM const   *)pk->n);
#line 246
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 253
    tmp___7 = auth_rsa_challenge_dialog(pk);
#line 253
    if (! tmp___7) {
#line 255
      verbose("Wrong response to RSA authentication challenge.");
#line 256
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 257
      continue;
    }
#line 267
    authenticated = auth_parse_options(pw, options___0, linenum);
#line 268
    if (authenticated) {
#line 269
      break;
    }
  }
#line 273
  restore_uid();
#line 276
  fclose(f);
#line 278
  RSA_free(pk);
#line 280
  if (authenticated) {
#line 281
    packet_send_debug("RSA authentication accepted.");
  }
#line 284
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 36 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  Key *found ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 44
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 46
  if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 47
    return (0);
  }
#line 50
  tmp = auth_rhosts(pw, client_user);
#line 50
  if (! tmp) {
#line 51
    return (0);
  }
#line 53
  canonical_hostname = get_canonical_hostname();
#line 55
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 58
  client_key = key_new(0);
#line 59
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 60
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 61
  found = key_new(0);
#line 64
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_key, found);
#line 68
  if ((int )host_status != 0) {
#line 68
    if (! options.ignore_user_known_hosts) {
#line 70
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 70
      user_hostfile = tmp___0;
#line 75
      if (options.strict_modes) {
#line 75
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 75
        if (tmp___1 == 0) {
#line 75
          if (st.st_uid != 0U) {
#line 75
            if (st.st_uid != pw->pw_uid) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 75
            if ((st.st_mode & 18U) != 0U) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 83
              temporarily_use_uid(pw->pw_uid);
#line 84
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_key,
                                                   found);
#line 86
              restore_uid();
            }
          }
        } else {
#line 83
          temporarily_use_uid(pw->pw_uid);
#line 84
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_key, found);
#line 86
          restore_uid();
        }
      } else {
#line 83
        temporarily_use_uid(pw->pw_uid);
#line 84
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_key, found);
#line 86
        restore_uid();
      }
#line 88
      xfree((void *)user_hostfile);
    }
  }
#line 90
  key_free(client_key);
#line 91
  key_free(found);
#line 93
  if ((int )host_status != 0) {
#line 94
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 95
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 96
    return (0);
  }
#line 101
  tmp___2 = auth_rsa_challenge_dialog(client_host_key);
#line 101
  if (! tmp___2) {
#line 102
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 104
    return (0);
  }
#line 111
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 113
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 114
  return (1);
}
}
#line 1 "pty.o"
#line 280 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 27 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 33
void pty_release(char const   *ttyname___0 ) ;
#line 39
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 42
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 46
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 57 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 49 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char buf___1[64] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 57
  i = openpty(ptyfd, ttyfd, buf___1, (void *)0, (void *)0);
#line 58
  if (i < 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("openpty: %.100s", tmp___0);
#line 60
    return (0);
  }
#line 62
  strlcpy(namebuf, (char const   *)(buf___1), (unsigned int )namebuflen);
#line 63
  return (1);
}
}
#line 189 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 192
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 192
  if (tmp___1 < 0) {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 194
  tmp___4 = chmod(ttyname___0, 438U);
#line 194
  if (tmp___4 < 0) {
#line 195
    tmp___2 = __errno_location();
#line 195
    tmp___3 = strerror(*tmp___2);
#line 195
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 196
  return;
}
}
#line 200 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  __sighandler_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 210
  fd = open("/dev/tty", 258);
#line 211
  if (fd >= 0) {
#line 212
    ioctl(fd, 21538UL, (void *)0);
#line 213
    close(fd);
  }
#line 216
  tmp___1 = setsid();
#line 216
  if (tmp___1 < 0) {
#line 217
    tmp = __errno_location();
#line 217
    tmp___0 = strerror(*tmp);
#line 217
    error("setsid: %.100s", tmp___0);
  }
#line 223
  fd = open("/dev/tty", 258);
#line 224
  if (fd >= 0) {
#line 225
    error("Failed to disconnect from controlling tty.");
#line 226
    close(fd);
  }
#line 230
  debug("Setting controlling tty using TIOCSCTTY.");
#line 236
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 239
  tmp___2 = signal(1, (void (*)(int  ))1);
#line 239
  old = (void *)tmp___2;
#line 240
  vhangup();
#line 241
  signal(1, (void (*)(int  ))old);
#line 243
  fd = open(ttyname___0, 2);
#line 244
  if (fd < 0) {
#line 245
    tmp___3 = __errno_location();
#line 245
    tmp___4 = strerror(*tmp___3);
#line 245
    error("%.100s: %.100s", ttyname___0, tmp___4);
  } else {
#line 248
    close(*ttyfd);
#line 249
    *ttyfd = fd;
  }
#line 255
  fd = open("/dev/tty", 1);
#line 256
  if (fd < 0) {
#line 257
    tmp___5 = __errno_location();
#line 257
    tmp___6 = strerror(*tmp___5);
#line 257
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___6);
  } else {
#line 260
    close(fd);
  }
#line 262
  return;
}
}
#line 266 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 271
  w.ws_row = (unsigned short )row;
#line 272
  w.ws_col = (unsigned short )col;
#line 273
  w.ws_xpixel = (unsigned short )xpixel;
#line 274
  w.ws_ypixel = (unsigned short )ypixel;
#line 275
  ioctl(ptyfd, 21524UL, & w);
#line 276
  return;
}
}
#line 278 "pty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 286
  grp = getgrnam("tty");
#line 287
  if (grp) {
#line 288
    gid = grp->gr_gid;
#line 289
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 291
    gid = pw->pw_gid;
#line 292
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 296
  tmp___1 = chown(ttyname___0, pw->pw_uid, gid);
#line 296
  if (tmp___1 < 0) {
#line 297
    tmp = __errno_location();
#line 297
    tmp___0 = strerror(*tmp);
#line 297
    fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid, tmp___0);
  }
#line 299
  tmp___4 = chmod(ttyname___0, mode);
#line 299
  if (tmp___4 < 0) {
#line 300
    tmp___2 = __errno_location();
#line 300
    tmp___3 = strerror(*tmp___2);
#line 300
    fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___3);
  }
#line 302
  return;
}
}
#line 1 "log-server.o"
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "log-server.c"
extern char *__progname ;
#line 31 "log-server.c"
static LogLevel log_level  =    3;
#line 32 "log-server.c"
static int log_on_stderr  =    0;
#line 33 "log-server.c"
static int log_facility  =    4 << 3;
#line 41 "log-server.c"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 44
  switch ((int )level) {
  case 0: 
  case 2: 
  case 1: 
  case 3: 
  case 4: 
  case 5: 
#line 51
  log_level = level;
#line 52
  break;
  default: 
#line 54
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 56
  exit(1);
  }
#line 58
  switch ((int )facility) {
  case 0: 
#line 60
  log_facility = 3 << 3;
#line 61
  break;
  case 1: 
#line 63
  log_facility = 1 << 3;
#line 64
  break;
  case 2: 
#line 66
  log_facility = 4 << 3;
#line 67
  break;
  case 3: 
#line 69
  log_facility = 16 << 3;
#line 70
  break;
  case 4: 
#line 72
  log_facility = 17 << 3;
#line 73
  break;
  case 5: 
#line 75
  log_facility = 18 << 3;
#line 76
  break;
  case 6: 
#line 78
  log_facility = 19 << 3;
#line 79
  break;
  case 7: 
#line 81
  log_facility = 20 << 3;
#line 82
  break;
  case 8: 
#line 84
  log_facility = 21 << 3;
#line 85
  break;
  case 9: 
#line 87
  log_facility = 22 << 3;
#line 88
  break;
  case 10: 
#line 90
  log_facility = 23 << 3;
#line 91
  break;
  default: 
#line 93
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 95
  exit(1);
  }
#line 97
  log_on_stderr = on_stderr;
#line 98
  return;
}
}
#line 102 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 107
  txt = (char *)((void *)0);
#line 108
  pri = 6;
#line 110
  if ((int )level > (int )log_level) {
#line 111
    return;
  }
#line 112
  switch ((int )level) {
  case 2: 
#line 114
  txt = (char *)"error";
#line 115
  pri = 3;
#line 116
  break;
  case 1: 
#line 118
  txt = (char *)"fatal";
#line 119
  pri = 3;
#line 120
  break;
  case 3: 
  case 4: 
#line 123
  pri = 6;
#line 124
  break;
  case 5: 
#line 126
  txt = (char *)"debug";
#line 127
  pri = 7;
#line 128
  break;
  default: 
#line 130
  txt = (char *)"internal error";
#line 131
  pri = 3;
#line 132
  break;
  }
#line 134
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 135
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 136
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 138
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 140
  if (log_on_stderr) {
#line 141
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  } else {
#line 143
    openlog((char const   *)__progname, 1, log_facility);
#line 144
    syslog(pri, "%.500s", msgbuf);
#line 145
    closelog();
  }
#line 147
  return;
}
}
#line 1 "login.o"
#line 100 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 103
void login_free_entry(struct logininfo *li ) ;
#line 111
int login_login(struct logininfo *li ) ;
#line 112
int login_logout(struct logininfo *li ) ;
#line 121
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 128
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 31 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 ,
                                  unsigned int bufsize ) 
{ struct logininfo li ;

  {
#line 37
  login_get_lastlog(& li, (int )uid);
#line 38
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 39
  return ((unsigned long )li.tv_sec);
}
}
#line 47 "login.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct logininfo *li ;

  {
#line 53
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 54
  login_set_addr(li, (struct sockaddr  const  *)addr, sizeof(struct sockaddr ));
#line 55
  login_login(li);
#line 56
  login_free_entry(li);
#line 57
  return;
}
}
#line 61 "login.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ struct logininfo *li ;

  {
#line 66
  li = login_alloc_entry(pid, (char const   *)((void *)0), (char const   *)((void *)0),
                         ttyname___0);
#line 67
  login_logout(li);
#line 68
  login_free_entry(li);
#line 69
  return;
}
}
#line 1 "loginrec.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 105 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 108
void login_set_current_time(struct logininfo *li ) ;
#line 117
int login_write(struct logininfo *li ) ;
#line 130
unsigned int login_get_lastlog_time(int uid ) ;
#line 133
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 134
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 135
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 170 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 171
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 183
int lastlog_write_entry(struct logininfo *li ) ;
#line 184
int syslogin_write_entry(struct logininfo *li ) ;
#line 186
int getlast_entry(struct logininfo *li ) ;
#line 187
int lastlog_get_entry(struct logininfo *li ) ;
#line 207 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 210
  li->type = (short)7;
#line 211
  tmp = login_write(li);
#line 211
  return (tmp);
}
}
#line 223 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 226
  li->type = (short)8;
#line 227
  tmp = login_write(li);
#line 227
  return (tmp);
}
}
#line 247 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 252
  tmp = login_get_lastlog(& li, uid);
#line 252
  if (tmp) {
#line 253
    return (li.tv_sec);
  } else {
#line 255
    return (0U);
  }
}
}
#line 271 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 276
  memset((void *)li, '\000', sizeof(struct logininfo ));
#line 277
  li->uid = uid;
#line 284
  pw = getpwuid((unsigned int )uid);
#line 285
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 286
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 290
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 292
  tmp = getlast_entry(li);
#line 292
  if (tmp) {
#line 293
    return (li);
  } else {
#line 295
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 308 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 314
  tmp = xmalloc(sizeof(struct logininfo ));
#line 314
  newli = (struct logininfo *)tmp;
#line 315
  login_init_entry(newli, pid, username, hostname, line);
#line 316
  return (newli);
}
}
#line 321 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 324
  xfree((void *)li);
#line 325
  return;
}
}
#line 336 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 342
  memset((void *)li, 0, sizeof(struct logininfo ));
#line 344
  li->pid = pid;
#line 347
  if (line) {
#line 348
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 350
  if (username) {
#line 351
    strlcpy(li->username, username, sizeof(li->username));
#line 352
    pw = getpwnam((char const   *)(li->username));
#line 353
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 354
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 355
    li->uid = (int )pw->pw_uid;
  }
#line 358
  if (hostname) {
#line 359
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 361
  return (1);
}
}
#line 370 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 375
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 377
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 378
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 379
  return;
}
}
#line 382 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 386
  bufsize = sa_size;
#line 389
  if (sizeof(li->hostaddr) < sa_size) {
#line 390
    bufsize = sizeof(li->hostaddr);
  }
#line 392
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 393
  return;
}
}
#line 400 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 403
  tmp = geteuid();
#line 403
  if ((int )tmp != 0) {
#line 404
    log("Attempt to write login records by non-root user (aborting)");
#line 405
    return (1);
  }
#line 409
  login_set_current_time(li);
#line 411
  syslogin_write_entry(li);
#line 414
  if ((int )li->type == 7) {
#line 415
    lastlog_write_entry(li);
  }
#line 430
  return (0);
}
}
#line 439 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 443
  tmp = lastlog_get_entry(li);
#line 443
  return (tmp);
}
}
#line 490 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 493
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 494
  if (0) {
#line 494
    if (0) {
#line 494
      __s1_len___0 = strlen(src);
#line 494
      __s2_len___0 = strlen("/dev/");
#line 494
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 494
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 494
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 494
            tmp___22 = 1;
          } else {
#line 494
            if (__s2_len___0 >= 4U) {
#line 494
              tmp___22 = 1;
            } else {
#line 494
              tmp___22 = 0;
            }
          }
        } else {
#line 494
          tmp___22 = 0;
        }
      }
#line 494
      if (tmp___22) {
#line 494
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 494
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 494
        tmp___18 = tmp___21;
      }
    } else {
#line 494
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 494
      tmp___18 = tmp___21;
    }
#line 494
    tmp___12 = tmp___18;
  } else {
#line 494
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 494
  if (tmp___12 == 0) {
#line 495
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 494
    tmp___25 = strlen(src);
#line 494
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 495
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 497
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 498
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 500
  return (dst);
}
}
#line 504 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 507
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 508
  if (0) {
#line 508
    if (0) {
#line 508
      __s1_len___0 = strlen(src);
#line 508
      __s2_len___0 = strlen("/dev/");
#line 508
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 508
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 508
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 508
            tmp___22 = 1;
          } else {
#line 508
            if (__s2_len___0 >= 4U) {
#line 508
              tmp___22 = 1;
            } else {
#line 508
              tmp___22 = 0;
            }
          }
        } else {
#line 508
          tmp___22 = 0;
        }
      }
#line 508
      if (tmp___22) {
#line 508
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 508
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 508
        tmp___18 = tmp___21;
      }
    } else {
#line 508
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 508
      tmp___18 = tmp___21;
    }
#line 508
    tmp___12 = tmp___18;
  } else {
#line 508
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 508
  if (tmp___12 == 0) {
#line 509
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 511
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 512
  return (dst);
}
}
#line 521 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 526
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 529
  if (0) {
#line 529
    if (0) {
#line 529
      __s1_len___0 = strlen(src);
#line 529
      __s2_len___0 = strlen("/dev/");
#line 529
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 529
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 529
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 529
            tmp___22 = 1;
          } else {
#line 529
            if (__s2_len___0 >= 4U) {
#line 529
              tmp___22 = 1;
            } else {
#line 529
              tmp___22 = 0;
            }
          }
        } else {
#line 529
          tmp___22 = 0;
        }
      }
#line 529
      if (tmp___22) {
#line 529
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 529
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 529
        tmp___18 = tmp___21;
      }
    } else {
#line 529
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 529
      tmp___18 = tmp___21;
    }
#line 529
    tmp___12 = tmp___18;
  } else {
#line 529
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 529
  if (tmp___12 == 0) {
#line 530
    src += 5;
  }
#line 532
  len = strlen(src);
#line 534
  if (len > 0U) {
#line 535
    if ((int )len - dstsize > 0) {
#line 536
      src += (int )len - dstsize;
    }
#line 539
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 542
  return (dst);
}
}
#line 555 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 559
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 560
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 566
  return;
}
}
#line 568 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 572
  memset((void *)ut, '\000', sizeof(struct utmp ));
#line 577
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 582
  switch ((int )li->type) {
  case 7: 
#line 584
  ut->ut_type = (short)7;
#line 585
  break;
  case 8: 
#line 587
  ut->ut_type = (short)8;
#line 588
  break;
  }
#line 591
  set_utmp_time(li, ut);
#line 593
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 596
  ut->ut_pid = li->pid;
#line 600
  if ((int )li->type == 8) {
#line 601
    return;
  }
#line 609
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 609
    tmp = sizeof(ut->ut_user);
  } else {
#line 609
    tmp = sizeof(li->username);
  }
#line 609
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 611
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 611
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 611
    tmp___0 = sizeof(li->hostname);
  }
#line 611
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 615
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 616
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 618
  return;
}
}
#line 1236 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1241
  tmp = malloc(sizeof(struct utmp ));
#line 1241
  ut = (struct utmp *)tmp;
#line 1241
  if (! ut) {
#line 1242
    log("syslogin_perform_login: couldn\'t malloc()");
#line 1243
    return (0);
  }
#line 1245
  construct_utmp(li, ut);
#line 1246
  login((struct utmp  const  *)ut);
#line 1248
  return (1);
}
}
#line 1251 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[8] ;
  int tmp ;

  {
#line 1257
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1259
  tmp = logout((char const   *)(line));
#line 1259
  if (tmp) {
#line 1263
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1260
    log("syslogin_perform_logout: logout() returned an error");
  }
#line 1271
  return (1);
}
}
#line 1274 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1277
  switch ((int )li->type) {
  case 7: 
#line 1279
  tmp = syslogin_perform_login(li);
#line 1279
  return (tmp);
  case 8: 
#line 1281
  tmp___0 = syslogin_perform_logout(li);
#line 1281
  return (tmp___0);
  default: 
#line 1283
  log("syslogin_write_entry: Invalid type field");
#line 1284
  return (0);
  }
}
}
#line 1300 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1304
  memset((void *)last, '\000', sizeof(struct lastlog ));
#line 1306
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1307
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1307
    tmp = sizeof(last->ll_host);
  } else {
#line 1307
    tmp = sizeof(li->hostname);
  }
#line 1307
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1309
  last->ll_time = (long )li->tv_sec;
#line 1310
  return;
}
}
#line 1312 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1317
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1317
  if (tmp___1 != 0) {
#line 1318
    tmp = __errno_location();
#line 1318
    tmp___0 = strerror(*tmp);
#line 1318
    log("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1320
    return (0);
  }
#line 1322
  if ((st.st_mode & 61440U) == 16384U) {
#line 1323
    return (2);
  } else {
#line 1324
    if ((st.st_mode & 61440U) == 32768U) {
#line 1325
      return (1);
    } else {
#line 1327
      return (3);
    }
  }
}
}
#line 1332 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off_t tmp___3 ;

  {
#line 1339
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1340
  switch (type) {
  case 1: 
#line 1342
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1343
  break;
  case 2: 
#line 1345
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1347
  break;
  default: 
#line 1349
  log("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1351
  return (0);
  }
#line 1354
  *fd = open((char const   *)(lastlog_file), filemode);
#line 1355
  if (*fd < 0) {
#line 1356
    tmp = __errno_location();
#line 1356
    tmp___0 = strerror(*tmp);
#line 1356
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1358
    return (0);
  }
#line 1362
  offset = (long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1364
  tmp___3 = lseek(*fd, offset, 0);
#line 1364
  if (tmp___3 != offset) {
#line 1365
    tmp___1 = __errno_location();
#line 1365
    tmp___2 = strerror(*tmp___1);
#line 1365
    log("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1367
    return (0);
  }
#line 1369
  return (1);
}
}
#line 1372 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1379
  lastlog_construct(li, & last);
#line 1382
  tmp___2 = lastlog_openseek(li, & fd, 66);
#line 1382
  if (tmp___2) {
#line 1383
    tmp___1 = atomicio((ssize_t (*)())(& write), fd, (void *)(& last), sizeof(last));
#line 1383
    if ((unsigned int )tmp___1 != sizeof(last)) {
#line 1384
      tmp = __errno_location();
#line 1384
      tmp___0 = strerror(*tmp);
#line 1384
      log("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___0);
#line 1386
      return (0);
    }
#line 1388
    return (1);
  } else {
#line 1390
    return (0);
  }
}
}
#line 1394 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1397
  switch ((int )li->type) {
  case 7: 
#line 1399
  tmp = lastlog_perform_login(li);
#line 1399
  return (tmp);
  default: 
#line 1401
  log("lastlog_write_entry: Invalid type field");
#line 1402
  return (0);
  }
}
}
#line 1406 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1409
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1410
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1410
    tmp = sizeof(li->hostname);
  } else {
#line 1410
    tmp = sizeof(last->ll_host);
  }
#line 1410
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1412
  li->tv_sec = (unsigned int )last->ll_time;
#line 1413
  return;
}
}
#line 1415 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1421
  tmp___2 = lastlog_openseek(li, & fd, 0);
#line 1421
  if (tmp___2) {
#line 1422
    tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)(& last), sizeof(last));
#line 1422
    if ((unsigned int )tmp___1 != sizeof(last)) {
#line 1423
      tmp = __errno_location();
#line 1423
      tmp___0 = strerror(*tmp);
#line 1423
      log("lastlog_get_entry: Error reading from %s: %s", "/var/log/lastlog", tmp___0);
#line 1425
      return (0);
    } else {
#line 1427
      lastlog_populate_entry(li, & last);
#line 1428
      return (1);
    }
  } else {
#line 1431
    return (0);
  }
}
}
#line 1 "servconf.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 23 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) ;
#line 27 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 30
  memset((void *)options___0, 0, sizeof(*options___0));
#line 31
  options___0->num_ports = 0U;
#line 32
  options___0->ports_from_cmdline = 0U;
#line 33
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 34
  options___0->host_key_file = (char *)((void *)0);
#line 35
  options___0->host_dsa_key_file = (char *)((void *)0);
#line 36
  options___0->pid_file = (char *)((void *)0);
#line 37
  options___0->server_key_bits = -1;
#line 38
  options___0->login_grace_time = -1;
#line 39
  options___0->key_regeneration_time = -1;
#line 40
  options___0->permit_root_login = -1;
#line 41
  options___0->ignore_rhosts = -1;
#line 42
  options___0->ignore_user_known_hosts = -1;
#line 43
  options___0->print_motd = -1;
#line 44
  options___0->check_mail = -1;
#line 45
  options___0->x11_forwarding = -1;
#line 46
  options___0->x11_display_offset = -1;
#line 47
  options___0->xauth_location = (char *)((void *)0);
#line 48
  options___0->strict_modes = -1;
#line 49
  options___0->keepalives = -1;
#line 50
  options___0->log_facility = (enum __anonenum_SyslogFacility_72 )-1;
#line 51
  options___0->log_level = (enum __anonenum_LogLevel_73 )-1;
#line 52
  options___0->rhosts_authentication = -1;
#line 53
  options___0->rhosts_rsa_authentication = -1;
#line 54
  options___0->rsa_authentication = -1;
#line 55
  options___0->dsa_authentication = -1;
#line 65
  options___0->password_authentication = -1;
#line 69
  options___0->permit_empty_passwd = -1;
#line 70
  options___0->use_login = -1;
#line 71
  options___0->num_allow_users = 0U;
#line 72
  options___0->num_deny_users = 0U;
#line 73
  options___0->num_allow_groups = 0U;
#line 74
  options___0->num_deny_groups = 0U;
#line 75
  options___0->ciphers = (char *)((void *)0);
#line 76
  options___0->protocol = 0;
#line 77
  options___0->gateway_ports = -1;
#line 78
  options___0->num_subsystems = 0U;
#line 79
  options___0->max_startups = -1;
#line 80
  return;
}
}
#line 82 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ unsigned int tmp ;

  {
#line 85
  if (options___0->num_ports == 0U) {
#line 86
    tmp = options___0->num_ports;
#line 86
    (options___0->num_ports) ++;
#line 86
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 87
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 88
    add_listen_addr(options___0, (char *)((void *)0));
  }
#line 89
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 90
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 91
  if ((unsigned int )options___0->host_dsa_key_file == (unsigned int )((void *)0)) {
#line 92
    options___0->host_dsa_key_file = (char *)"/usr/local/etc/ssh_host_dsa_key";
  }
#line 93
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 94
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 95
  if (options___0->server_key_bits == -1) {
#line 96
    options___0->server_key_bits = 768;
  }
#line 97
  if (options___0->login_grace_time == -1) {
#line 98
    options___0->login_grace_time = 600;
  }
#line 99
  if (options___0->key_regeneration_time == -1) {
#line 100
    options___0->key_regeneration_time = 3600;
  }
#line 101
  if (options___0->permit_root_login == -1) {
#line 102
    options___0->permit_root_login = 1;
  }
#line 103
  if (options___0->ignore_rhosts == -1) {
#line 104
    options___0->ignore_rhosts = 1;
  }
#line 105
  if (options___0->ignore_user_known_hosts == -1) {
#line 106
    options___0->ignore_user_known_hosts = 0;
  }
#line 107
  if (options___0->check_mail == -1) {
#line 108
    options___0->check_mail = 0;
  }
#line 109
  if (options___0->print_motd == -1) {
#line 110
    options___0->print_motd = 1;
  }
#line 111
  if (options___0->x11_forwarding == -1) {
#line 112
    options___0->x11_forwarding = 0;
  }
#line 113
  if (options___0->x11_display_offset == -1) {
#line 114
    options___0->x11_display_offset = 10;
  }
#line 116
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 117
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 119
  if (options___0->strict_modes == -1) {
#line 120
    options___0->strict_modes = 1;
  }
#line 121
  if (options___0->keepalives == -1) {
#line 122
    options___0->keepalives = 1;
  }
#line 123
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 124
    options___0->log_facility = 2;
  }
#line 125
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 126
    options___0->log_level = 3;
  }
#line 127
  if (options___0->rhosts_authentication == -1) {
#line 128
    options___0->rhosts_authentication = 0;
  }
#line 129
  if (options___0->rhosts_rsa_authentication == -1) {
#line 130
    options___0->rhosts_rsa_authentication = 0;
  }
#line 131
  if (options___0->rsa_authentication == -1) {
#line 132
    options___0->rsa_authentication = 1;
  }
#line 133
  if (options___0->dsa_authentication == -1) {
#line 134
    options___0->dsa_authentication = 1;
  }
#line 149
  if (options___0->password_authentication == -1) {
#line 150
    options___0->password_authentication = 1;
  }
#line 155
  if (options___0->permit_empty_passwd == -1) {
#line 156
    options___0->permit_empty_passwd = 0;
  }
#line 157
  if (options___0->use_login == -1) {
#line 158
    options___0->use_login = 0;
  }
#line 159
  if (options___0->protocol == 0) {
#line 160
    options___0->protocol = 5;
  }
#line 161
  if (options___0->gateway_ports == -1) {
#line 162
    options___0->gateway_ports = 0;
  }
#line 163
  if (options___0->max_startups == -1) {
#line 164
    options___0->max_startups = 10;
  }
#line 165
  return;
}
}
#line 191 "servconf.c"
static struct __anonstruct_keywords_76 keywords[38]  = 
#line 191
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 29}, 
        {"pidfile", 32}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"dsaauthentication", 34}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"ignoreuserknownhosts", 28}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"xauthlocation", 35}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {"ciphers", 30}, 
        {"protocol", 31}, 
        {"gatewayports", 33}, 
        {"subsystem", 36}, 
        {"maxstartups", 37}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 252 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  int tmp ;

  {
#line 258
  i = 0U;
#line 258
  while (keywords[i].name) {
#line 259
    tmp = strcasecmp(cp, keywords[i].name);
#line 259
    if (tmp == 0) {
#line 260
      return (keywords[i].opcode);
    }
#line 258
    i ++;
  }
#line 262
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 264
  return (0);
}
}
#line 270 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int i ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 279
  if (options___0->num_ports == 0U) {
#line 280
    tmp = options___0->num_ports;
#line 280
    (options___0->num_ports) ++;
#line 280
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 281
  i = 0;
#line 281
  while ((unsigned int )i < options___0->num_ports) {
#line 282
    memset((void *)(& hints), 0, sizeof(hints));
#line 283
    hints.ai_family = IPv4or6;
#line 284
    hints.ai_socktype = 1;
#line 285
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 285
      hints.ai_flags = 1;
    } else {
#line 285
      hints.ai_flags = 0;
    }
#line 286
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             options___0->ports[i]);
#line 287
    gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 287
    if (gaierr != 0) {
#line 288
      tmp___0 = gai_strerror(gaierr);
#line 288
      if (addr) {
#line 288
        tmp___1 = (char const   *)addr;
      } else {
#line 288
        tmp___1 = "<NULL>";
      }
#line 288
      fatal("bad addr or host: %s (%s)\n", tmp___1, tmp___0);
    }
#line 291
    ai = aitop;
#line 291
    while (ai->ai_next) {
#line 291
      ai = ai->ai_next;
    }
#line 293
    ai->ai_next = options___0->listen_addrs;
#line 294
    options___0->listen_addrs = aitop;
#line 281
    i ++;
  }
#line 296
  return;
}
}
#line 300 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  char *arg ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  int i ;
  unsigned int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  SyslogFacility tmp___52 ;
  char const   *tmp___53 ;
  LogLevel tmp___54 ;
  char const   *tmp___55 ;
  unsigned int tmp___56 ;
  unsigned int tmp___57 ;
  unsigned int tmp___58 ;
  unsigned int tmp___59 ;
  char const   *tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;
  char *tmp___73 ;

  {
#line 307
  bad_options = 0;
#line 311
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 312
  if (! f) {
#line 313
    perror(filename);
#line 314
    exit(1);
  }
#line 316
  linenum = 0;
#line 317
  while (1) {
#line 317
    tmp___73 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 317
    if (! tmp___73) {
#line 317
      break;
    }
#line 318
    linenum ++;
#line 319
    cp = line;
#line 320
    arg = strdelim(& cp);
#line 322
    if ((int )*arg == 0) {
#line 323
      arg = strdelim(& cp);
    }
#line 324
    if (! *arg) {
#line 325
      continue;
    } else {
#line 324
      if ((int )*arg == 35) {
#line 325
        continue;
      }
    }
#line 326
    opcode = parse_token((char const   *)arg, filename, linenum);
#line 327
    switch ((int )opcode) {
    case 0: 
#line 329
    bad_options ++;
#line 330
    continue;
    case 1: 
#line 333
    if (options___0->ports_from_cmdline) {
#line 334
      continue;
    }
#line 335
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 336
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 338
    if (options___0->num_ports >= 256U) {
#line 339
      fatal("%s line %d: too many ports.\n", filename, linenum);
    }
#line 341
    arg = strdelim(& cp);
#line 342
    if (! arg) {
#line 343
      fatal("%s line %d: missing port number.\n", filename, linenum);
    } else {
#line 342
      if ((int )*arg == 0) {
#line 343
        fatal("%s line %d: missing port number.\n", filename, linenum);
      }
    }
#line 345
    tmp = options___0->num_ports;
#line 345
    (options___0->num_ports) ++;
#line 345
    tmp___0 = atoi((char const   *)arg);
#line 345
    options___0->ports[tmp] = (unsigned short )tmp___0;
#line 346
    break;
    case 3: 
#line 349
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 351
    arg = strdelim(& cp);
#line 352
    if (! arg) {
#line 353
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 355
      exit(1);
    } else {
#line 352
      if ((int )*arg == 0) {
#line 353
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
                filename, linenum);
#line 355
        exit(1);
      }
    }
#line 357
    value = atoi((char const   *)arg);
#line 358
    if (*intptr == -1) {
#line 359
      *intptr = value;
    }
#line 360
    break;
    case 4: 
#line 363
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 367
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 371
    arg = strdelim(& cp);
#line 372
    if (! arg) {
#line 373
      fatal("%s line %d: missing inet addr.\n", filename, linenum);
    } else {
#line 372
      if ((int )*arg == 0) {
#line 373
        fatal("%s line %d: missing inet addr.\n", filename, linenum);
      }
    }
#line 375
    add_listen_addr(options___0, arg);
#line 376
    break;
    case 2: 
    case 29: 
#line 380
    if ((int )opcode == 2) {
#line 380
      charptr = & options___0->host_key_file;
    } else {
#line 380
      charptr = & options___0->host_dsa_key_file;
    }
    parse_filename: 
#line 383
    arg = strdelim(& cp);
#line 384
    if (! arg) {
#line 385
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 387
      exit(1);
    } else {
#line 384
      if ((int )*arg == 0) {
#line 385
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
                filename, linenum);
#line 387
        exit(1);
      }
    }
#line 389
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 390
      tmp___1 = getuid();
#line 390
      *charptr = tilde_expand_filename((char const   *)arg, tmp___1);
    }
#line 391
    break;
    case 32: 
#line 394
    charptr = & options___0->pid_file;
    goto parse_filename;
    case 20: 
#line 398
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 400
    arg = strdelim(& cp);
#line 401
    break;
    case 6: 
#line 404
    intptr = & options___0->permit_root_login;
#line 405
    arg = strdelim(& cp);
#line 406
    if (! arg) {
#line 407
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 409
      exit(1);
    } else {
#line 406
      if ((int )*arg == 0) {
#line 407
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
                filename, linenum);
#line 409
        exit(1);
      }
    }
#line 411
    if (0) {
#line 411
      __s1_len___1 = strlen((char const   *)arg);
#line 411
      __s2_len___1 = strlen("without-password");
#line 411
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___4;
      } else {
#line 411
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 411
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 411
            tmp___31 = 1;
          } else {
#line 411
            if (__s2_len___1 >= 4U) {
#line 411
              tmp___31 = 1;
            } else {
#line 411
              tmp___31 = 0;
            }
          }
        } else {
#line 411
          tmp___31 = 0;
        }
      }
#line 411
      if (tmp___31) {
#line 411
        tmp___27 = __builtin_strcmp((char const   *)arg, "without-password");
      } else {
#line 411
        tmp___30 = __builtin_strcmp((char const   *)arg, "without-password");
#line 411
        tmp___27 = tmp___30;
      }
    } else {
#line 411
      tmp___30 = __builtin_strcmp((char const   *)arg, "without-password");
#line 411
      tmp___27 = tmp___30;
    }
#line 411
    if (tmp___27 == 0) {
#line 412
      value = 2;
    } else {
#line 413
      if (0) {
#line 413
        __s1_len___0 = strlen((char const   *)arg);
#line 413
        __s2_len___0 = strlen("yes");
#line 413
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___2;
        } else {
#line 413
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 413
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 413
              tmp___21 = 1;
            } else {
#line 413
              if (__s2_len___0 >= 4U) {
#line 413
                tmp___21 = 1;
              } else {
#line 413
                tmp___21 = 0;
              }
            }
          } else {
#line 413
            tmp___21 = 0;
          }
        }
#line 413
        if (tmp___21) {
#line 413
          tmp___17 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 413
          tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 413
          tmp___17 = tmp___20;
        }
      } else {
#line 413
        tmp___20 = __builtin_strcmp((char const   *)arg, "yes");
#line 413
        tmp___17 = tmp___20;
      }
#line 413
      if (tmp___17 == 0) {
#line 414
        value = 1;
      } else {
#line 415
        if (0) {
#line 415
          __s1_len = strlen((char const   *)arg);
#line 415
          __s2_len = strlen("no");
#line 415
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___0;
          } else {
#line 415
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 415
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 415
                tmp___11 = 1;
              } else {
#line 415
                if (__s2_len >= 4U) {
#line 415
                  tmp___11 = 1;
                } else {
#line 415
                  tmp___11 = 0;
                }
              }
            } else {
#line 415
              tmp___11 = 0;
            }
          }
#line 415
          if (tmp___11) {
#line 415
            tmp___7 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 415
            tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 415
            tmp___7 = tmp___10;
          }
        } else {
#line 415
          tmp___10 = __builtin_strcmp((char const   *)arg, "no");
#line 415
          tmp___7 = tmp___10;
        }
#line 415
        if (tmp___7 == 0) {
#line 416
          value = 0;
        } else {
#line 418
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, arg);
#line 420
          exit(1);
        }
      }
    }
#line 422
    if (*intptr == -1) {
#line 423
      *intptr = value;
    }
#line 424
    break;
    case 15: 
#line 427
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 429
    arg = strdelim(& cp);
#line 430
    if (! arg) {
#line 431
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 433
      exit(1);
    } else {
#line 430
      if ((int )*arg == 0) {
#line 431
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
                filename, linenum);
#line 433
        exit(1);
      }
    }
#line 435
    if (0) {
#line 435
      __s1_len___3 = strlen((char const   *)arg);
#line 435
      __s2_len___3 = strlen("yes");
#line 435
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 435
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 435
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 435
            tmp___51 = 1;
          } else {
#line 435
            if (__s2_len___3 >= 4U) {
#line 435
              tmp___51 = 1;
            } else {
#line 435
              tmp___51 = 0;
            }
          }
        } else {
#line 435
          tmp___51 = 0;
        }
      }
#line 435
      if (tmp___51) {
#line 435
        tmp___47 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 435
        tmp___50 = __builtin_strcmp((char const   *)arg, "yes");
#line 435
        tmp___47 = tmp___50;
      }
    } else {
#line 435
      tmp___50 = __builtin_strcmp((char const   *)arg, "yes");
#line 435
      tmp___47 = tmp___50;
    }
#line 435
    if (tmp___47 == 0) {
#line 436
      value = 1;
    } else {
#line 437
      if (0) {
#line 437
        __s1_len___2 = strlen((char const   *)arg);
#line 437
        __s2_len___2 = strlen("no");
#line 437
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___6;
        } else {
#line 437
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 437
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 437
              tmp___41 = 1;
            } else {
#line 437
              if (__s2_len___2 >= 4U) {
#line 437
                tmp___41 = 1;
              } else {
#line 437
                tmp___41 = 0;
              }
            }
          } else {
#line 437
            tmp___41 = 0;
          }
        }
#line 437
        if (tmp___41) {
#line 437
          tmp___37 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 437
          tmp___40 = __builtin_strcmp((char const   *)arg, "no");
#line 437
          tmp___37 = tmp___40;
        }
      } else {
#line 437
        tmp___40 = __builtin_strcmp((char const   *)arg, "no");
#line 437
        tmp___37 = tmp___40;
      }
#line 437
      if (tmp___37 == 0) {
#line 438
        value = 0;
      } else {
#line 440
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, arg);
#line 442
        exit(1);
      }
    }
#line 444
    if (*intptr == -1) {
#line 445
      *intptr = value;
    }
#line 446
    break;
    case 28: 
#line 449
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 453
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 457
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 461
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 34: 
#line 465
    intptr = & options___0->dsa_authentication;
    goto parse_flag;
    case 12: 
#line 493
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 497
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 507
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 511
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 515
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 35: 
#line 519
    charptr = & options___0->xauth_location;
    goto parse_filename;
    case 18: 
#line 523
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 527
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 531
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 535
    intptr = & options___0->use_login;
    goto parse_flag;
    case 33: 
#line 539
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 7: 
#line 543
    intptr = (int *)(& options___0->log_facility);
#line 544
    arg = strdelim(& cp);
#line 545
    tmp___52 = log_facility_number(arg);
#line 545
    value = (int )tmp___52;
#line 546
    if (value == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 547
      if (arg) {
#line 547
        tmp___53 = (char const   *)arg;
      } else {
#line 547
        tmp___53 = "<NONE>";
      }
#line 547
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___53);
    }
#line 549
    if (*intptr == -1) {
#line 550
      *intptr = (int )((enum __anonenum_SyslogFacility_72 )value);
    }
#line 551
    break;
    case 8: 
#line 554
    intptr = (int *)(& options___0->log_level);
#line 555
    arg = strdelim(& cp);
#line 556
    tmp___54 = log_level_number(arg);
#line 556
    value = (int )tmp___54;
#line 557
    if (value == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 558
      if (arg) {
#line 558
        tmp___55 = (char const   *)arg;
      } else {
#line 558
        tmp___55 = "<NONE>";
      }
#line 558
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___55);
    }
#line 560
    if (*intptr == -1) {
#line 561
      *intptr = (int )((enum __anonenum_LogLevel_73 )value);
    }
#line 562
    break;
    case 24: 
#line 565
    while (1) {
#line 565
      arg = strdelim(& cp);
#line 565
      if (arg) {
#line 565
        if (! ((int )*arg != 0)) {
#line 565
          break;
        }
      } else {
#line 565
        break;
      }
#line 566
      if (options___0->num_allow_users >= 256U) {
#line 567
        fatal("%s line %d: too many allow users.\n", filename, linenum);
      }
#line 569
      tmp___56 = options___0->num_allow_users;
#line 569
      (options___0->num_allow_users) ++;
#line 569
      options___0->allow_users[tmp___56] = xstrdup((char const   *)arg);
    }
#line 571
    break;
    case 25: 
#line 574
    while (1) {
#line 574
      arg = strdelim(& cp);
#line 574
      if (arg) {
#line 574
        if (! ((int )*arg != 0)) {
#line 574
          break;
        }
      } else {
#line 574
        break;
      }
#line 575
      if (options___0->num_deny_users >= 256U) {
#line 576
        fatal("%s line %d: too many deny users.\n", filename, linenum);
      }
#line 578
      tmp___57 = options___0->num_deny_users;
#line 578
      (options___0->num_deny_users) ++;
#line 578
      options___0->deny_users[tmp___57] = xstrdup((char const   *)arg);
    }
#line 580
    break;
    case 26: 
#line 583
    while (1) {
#line 583
      arg = strdelim(& cp);
#line 583
      if (arg) {
#line 583
        if (! ((int )*arg != 0)) {
#line 583
          break;
        }
      } else {
#line 583
        break;
      }
#line 584
      if (options___0->num_allow_groups >= 256U) {
#line 585
        fatal("%s line %d: too many allow groups.\n", filename, linenum);
      }
#line 587
      tmp___58 = options___0->num_allow_groups;
#line 587
      (options___0->num_allow_groups) ++;
#line 587
      options___0->allow_groups[tmp___58] = xstrdup((char const   *)arg);
    }
#line 589
    break;
    case 27: 
#line 592
    while (1) {
#line 592
      arg = strdelim(& cp);
#line 592
      if (arg) {
#line 592
        if (! ((int )*arg != 0)) {
#line 592
          break;
        }
      } else {
#line 592
        break;
      }
#line 593
      if (options___0->num_deny_groups >= 256U) {
#line 594
        fatal("%s line %d: too many deny groups.\n", filename, linenum);
      }
#line 596
      tmp___59 = options___0->num_deny_groups;
#line 596
      (options___0->num_deny_groups) ++;
#line 596
      options___0->deny_groups[tmp___59] = xstrdup((char const   *)arg);
    }
#line 598
    break;
    case 30: 
#line 601
    arg = strdelim(& cp);
#line 602
    if (! arg) {
#line 603
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 602
      if ((int )*arg == 0) {
#line 603
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 604
    tmp___61 = ciphers_valid((char const   *)arg);
#line 604
    if (! tmp___61) {
#line 605
      if (arg) {
#line 605
        tmp___60 = (char const   *)arg;
      } else {
#line 605
        tmp___60 = "<NONE>";
      }
#line 605
      fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___60);
    }
#line 607
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 608
      options___0->ciphers = xstrdup((char const   *)arg);
    }
#line 609
    break;
    case 31: 
#line 612
    intptr = & options___0->protocol;
#line 613
    arg = strdelim(& cp);
#line 614
    if (! arg) {
#line 615
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 614
      if ((int )*arg == 0) {
#line 615
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 616
    value = proto_spec((char const   *)arg);
#line 617
    if (value == 0) {
#line 618
      if (arg) {
#line 618
        tmp___62 = (char const   *)arg;
      } else {
#line 618
        tmp___62 = "<NONE>";
      }
#line 618
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___62);
    }
#line 620
    if (*intptr == 0) {
#line 621
      *intptr = value;
    }
#line 622
    break;
    case 36: 
#line 625
    if (options___0->num_subsystems >= 256U) {
#line 626
      fatal("%s line %d: too many subsystems defined.", filename, linenum);
    }
#line 629
    arg = strdelim(& cp);
#line 630
    if (! arg) {
#line 631
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    } else {
#line 630
      if ((int )*arg == 0) {
#line 631
        fatal("%s line %d: Missing subsystem name.", filename, linenum);
      }
    }
#line 633
    i = 0;
#line 633
    while ((unsigned int )i < options___0->num_subsystems) {
#line 634
      if (0) {
#line 634
        __s1_len___4 = strlen((char const   *)arg);
#line 634
        __s2_len___4 = strlen((char const   *)options___0->subsystem_name[i]);
#line 634
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___10;
        } else {
#line 634
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 634
            if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 634
              tmp___72 = 1;
            } else {
#line 634
              if (__s2_len___4 >= 4U) {
#line 634
                tmp___72 = 1;
              } else {
#line 634
                tmp___72 = 0;
              }
            }
          } else {
#line 634
            tmp___72 = 0;
          }
        }
#line 634
        if (tmp___72) {
#line 634
          tmp___68 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
        } else {
#line 634
          tmp___71 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 634
          tmp___68 = tmp___71;
        }
      } else {
#line 634
        tmp___71 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 634
        tmp___68 = tmp___71;
      }
#line 634
      if (tmp___68 == 0) {
#line 635
        fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum,
              arg);
      }
#line 633
      i ++;
    }
#line 637
    options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 638
    arg = strdelim(& cp);
#line 639
    if (! arg) {
#line 640
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    } else {
#line 639
      if ((int )*arg == 0) {
#line 640
        fatal("%s line %d: Missing subsystem command.", filename, linenum);
      }
    }
#line 642
    options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 643
    (options___0->num_subsystems) ++;
#line 644
    break;
    case 37: 
#line 647
    intptr = & options___0->max_startups;
    goto parse_int;
    default: 
#line 651
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, arg, opcode);
#line 653
    exit(1);
    }
#line 655
    arg = strdelim(& cp);
#line 655
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 655
      if ((int )*arg != 0) {
#line 656
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line; \"%.200s\".\n",
                filename, linenum, arg);
#line 659
        exit(1);
      }
    }
  }
#line 662
  fclose(f);
#line 663
  if (bad_options > 0) {
#line 664
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 666
    exit(1);
  }
#line 668
  return;
}
}
#line 1 "serverloop.o"
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 505 "ssh.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 506
void server_loop2(void) ;
#line 9 "session.h"
int session_open(int chanid ) ;
#line 10
void session_input_channel_req(int id , void *arg ) ;
#line 11
void session_close_by_pid(pid_t pid , int status ) ;
#line 12
void session_close_by_channel(int id , void *arg ) ;
#line 28 "serverloop.c"
static Buffer stdin_buffer  ;
#line 29 "serverloop.c"
static Buffer stdout_buffer  ;
#line 30 "serverloop.c"
static Buffer stderr_buffer  ;
#line 31 "serverloop.c"
static int fdin  ;
#line 32 "serverloop.c"
static int fdout  ;
#line 34 "serverloop.c"
static int fderr  ;
#line 35 "serverloop.c"
static long stdin_bytes  =    0L;
#line 36 "serverloop.c"
static long stdout_bytes  =    0L;
#line 37 "serverloop.c"
static long stderr_bytes  =    0L;
#line 38 "serverloop.c"
static long fdout_bytes  =    0L;
#line 39 "serverloop.c"
static int stdin_eof  =    0;
#line 40 "serverloop.c"
static int fdout_eof  =    0;
#line 41 "serverloop.c"
static int fderr_eof  =    0;
#line 42 "serverloop.c"
static int connection_in___0  ;
#line 43 "serverloop.c"
static int connection_out___0  ;
#line 44 "serverloop.c"
static unsigned int buffer_high  ;
#line 45 "serverloop.c"
static int max_fd  ;
#line 56 "serverloop.c"
static pid_t child_pid  ;
#line 57 "serverloop.c"
static int volatile   child_terminated  ;
#line 58 "serverloop.c"
static int volatile   child_has_selected  ;
#line 59 "serverloop.c"
static int volatile   child_wait_status  ;
#line 61
void server_init_dispatch(void) ;
#line 63 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t wait_pid ;
  union __anonunion_77 __constr_expr_0 ;
  union __anonunion_78 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 66
  tmp = __errno_location();
#line 66
  save_errno = *tmp;
#line 69
  debug("Received SIGCHLD.");
#line 70
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 71
  if (wait_pid != -1) {
#line 72
    if (wait_pid != child_pid) {
#line 73
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 75
    __constr_expr_0.__in = child_wait_status;
#line 75
    if ((__constr_expr_0.__i & 127) == 0) {
#line 77
      child_terminated = (int volatile   )1;
    } else {
#line 75
      __constr_expr_1.__in = child_wait_status;
#line 75
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 77
        child_terminated = (int volatile   )1;
      }
    }
#line 78
    child_has_selected = (int volatile   )0;
  }
#line 80
  signal(17, & sigchld_handler);
#line 81
  tmp___0 = __errno_location();
#line 81
  *tmp___0 = save_errno;
#line 82
  return;
}
}
#line 83 "serverloop.c"
void sigchld_handler2(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 86
  tmp = __errno_location();
#line 86
  save_errno = *tmp;
#line 87
  debug("Received SIGCHLD.");
#line 88
  child_terminated = (int volatile   )1;
#line 89
  tmp___0 = __errno_location();
#line 89
  *tmp___0 = save_errno;
#line 90
  return;
}
}
#line 96 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 102
  while (1) {
#line 102
    tmp___2 = buffer_len(& stderr_buffer);
#line 102
    if (tmp___2 > 0U) {
#line 102
      tmp___3 = packet_not_very_much_data_to_write();
#line 102
      if (! tmp___3) {
#line 102
        break;
      }
    } else {
#line 102
      break;
    }
#line 104
    tmp = buffer_len(& stderr_buffer);
#line 104
    len = (int )tmp;
#line 105
    tmp___0 = packet_is_interactive();
#line 105
    if (tmp___0) {
#line 106
      if (len > 512) {
#line 107
        len = 512;
      }
    } else {
#line 110
      if (len > max_packet_size) {
#line 111
        len = max_packet_size;
      }
    }
#line 113
    packet_start(18);
#line 114
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 114
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 115
    packet_send();
#line 116
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 117
    stderr_bytes += (long )len;
  }
#line 119
  return;
}
}
#line 125 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 131
  while (1) {
#line 131
    tmp___2 = buffer_len(& stdout_buffer);
#line 131
    if (tmp___2 > 0U) {
#line 131
      tmp___3 = packet_not_very_much_data_to_write();
#line 131
      if (! tmp___3) {
#line 131
        break;
      }
    } else {
#line 131
      break;
    }
#line 133
    tmp = buffer_len(& stdout_buffer);
#line 133
    len = (int )tmp;
#line 134
    tmp___0 = packet_is_interactive();
#line 134
    if (tmp___0) {
#line 135
      if (len > 512) {
#line 136
        len = 512;
      }
    } else {
#line 139
      if (len > max_packet_size) {
#line 140
        len = max_packet_size;
      }
    }
#line 142
    packet_start(17);
#line 143
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 143
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 144
    packet_send();
#line 145
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 146
    stdout_bytes += (long )len;
  }
#line 148
  return;
}
}
#line 156 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;

  {
  retry_select: 
#line 167
  while (1) {
#line 167
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 167
    break;
  }
#line 168
  while (1) {
#line 168
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 168
    break;
  }
#line 170
  if (compat20) {
#line 172
    tmp = channel_not_very_much_buffered_data();
#line 172
    if (tmp) {
#line 173
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 179
    tmp___0 = buffer_len(& stdin_buffer);
#line 179
    if (tmp___0 < buffer_high) {
#line 179
      tmp___1 = channel_not_very_much_buffered_data();
#line 179
      if (tmp___1) {
#line 181
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 186
    tmp___2 = packet_not_very_much_data_to_write();
#line 186
    if (tmp___2) {
#line 187
      if (! fdout_eof) {
#line 188
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 189
      if (! fderr_eof) {
#line 190
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 196
    if (fdin != -1) {
#line 196
      tmp___3 = buffer_len(& stdin_buffer);
#line 196
      if (tmp___3 > 0U) {
#line 197
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 200
  channel_prepare_select(readset, writeset);
#line 206
  tmp___4 = packet_have_data_to_write();
#line 206
  if (tmp___4) {
#line 207
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 210
  tmp___5 = channel_max_fd();
#line 210
  if (tmp___5 > max_fd) {
#line 211
    max_fd = channel_max_fd();
  }
#line 217
  if (child_terminated) {
#line 217
    tmp___6 = packet_not_very_much_data_to_write();
#line 217
    if (tmp___6) {
#line 218
      if (max_time_milliseconds == 0U) {
#line 219
        max_time_milliseconds = 100U;
      }
    }
  }
#line 221
  if (max_time_milliseconds == 0U) {
#line 222
    tvp = (struct timeval *)((void *)0);
  } else {
#line 224
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 225
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 226
    tvp = & tv;
  }
#line 228
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 229
    debug("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 232
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 234
  if (ret < 0) {
#line 235
    tmp___9 = __errno_location();
#line 235
    if (*tmp___9 != 4) {
#line 236
      tmp___7 = __errno_location();
#line 236
      tmp___8 = strerror(*tmp___7);
#line 236
      error("select: %.100s", tmp___8);
    } else {
      goto retry_select;
    }
  }
#line 241
  if (child_terminated) {
#line 242
    child_has_selected = (int volatile   )1;
  }
#line 243
  return;
}
}
#line 249 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 256
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 256
  if (__result) {
#line 257
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 258
    if (len == 0) {
#line 259
      verbose("Connection closed by remote host.");
#line 260
      fatal_cleanup();
    } else {
#line 261
      if (len < 0) {
#line 262
        tmp___1 = __errno_location();
#line 262
        if (*tmp___1 != 4) {
#line 262
          tmp___2 = __errno_location();
#line 262
          if (*tmp___2 != 11) {
#line 263
            tmp = __errno_location();
#line 263
            tmp___0 = strerror(*tmp);
#line 263
            verbose("Read error from remote host: %.100s", tmp___0);
#line 264
            fatal_cleanup();
          }
        }
      } else {
#line 268
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 271
  if (compat20) {
#line 272
    return;
  }
#line 275
  if (! fdout_eof) {
#line 275
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 275
    if (__result___0) {
#line 276
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 277
      if (len < 0) {
#line 277
        tmp___3 = __errno_location();
#line 277
        if (! (*tmp___3 == 4)) {
#line 277
          tmp___4 = __errno_location();
#line 277
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 279
        if (len <= 0) {
#line 280
          fdout_eof = 1;
        } else {
#line 282
          buffer_append(& stdout_buffer, (char const   *)(buf___1), (unsigned int )len);
#line 283
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 287
  if (! fderr_eof) {
#line 287
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 287
    if (__result___1) {
#line 288
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 289
      if (len < 0) {
#line 289
        tmp___5 = __errno_location();
#line 289
        if (! (*tmp___5 == 4)) {
#line 289
          tmp___6 = __errno_location();
#line 289
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 291
        if (len <= 0) {
#line 292
          fderr_eof = 1;
        } else {
#line 294
          buffer_append(& stderr_buffer, (char const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 297
  return;
}
}
#line 302 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 308
  if (! compat20) {
#line 308
    if (fdin != -1) {
#line 308
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 308
      if (__result) {
#line 309
        tmp = buffer_len(& stdin_buffer);
#line 309
        tmp___0 = buffer_ptr(& stdin_buffer);
#line 309
        len = write(fdin, (void const   *)tmp___0, tmp);
#line 311
        if (len < 0) {
#line 311
          tmp___1 = __errno_location();
#line 311
          if (! (*tmp___1 == 4)) {
#line 311
            tmp___2 = __errno_location();
#line 311
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 313
          if (len <= 0) {
#line 317
            if (fdin != fdout) {
#line 318
              close(fdin);
            } else {
#line 320
              shutdown(fdin, 1);
            }
#line 322
            fdin = -1;
          } else {
#line 325
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 327
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 331
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 331
  if (__result___0) {
#line 332
    packet_write_poll();
  }
#line 333
  return;
}
}
#line 339 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 343
  tmp___2 = buffer_len(& stdout_buffer);
#line 343
  if (tmp___2 > 0U) {
#line 344
    packet_start(17);
#line 345
    tmp = buffer_len(& stdout_buffer);
#line 345
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 345
    packet_put_string((char const   *)tmp___0, tmp);
#line 347
    packet_send();
#line 349
    tmp___1 = buffer_len(& stdout_buffer);
#line 349
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 352
  tmp___6 = buffer_len(& stderr_buffer);
#line 352
  if (tmp___6 > 0U) {
#line 353
    packet_start(18);
#line 354
    tmp___3 = buffer_len(& stderr_buffer);
#line 354
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 354
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 356
    packet_send();
#line 358
    tmp___5 = buffer_len(& stderr_buffer);
#line 358
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 361
  packet_write_wait();
#line 362
  return;
}
}
#line 364 "serverloop.c"
void process_buffered_input_packets(void) 
{ 

  {
#line 367
  dispatch_run(1, (int *)((void *)0));
#line 368
  return;
}
}
#line 377 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set readset ;
  fd_set writeset ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_79 __constr_expr_0 ;
  union __anonunion_80 __constr_expr_1 ;
  int plen ;
  union __anonunion_81 __constr_expr_2 ;
  union __anonunion_82 __constr_expr_3 ;
  union __anonunion_83 __constr_expr_4 ;

  {
#line 383
  waiting_termination = 0;
#line 389
  debug("Entering interactive session.");
#line 392
  child_pid = pid;
#line 393
  child_terminated = (int volatile   )0;
#line 394
  child_has_selected = (int volatile   )0;
#line 395
  signal(17, & sigchld_handler);
#line 398
  fdin = fdin_arg;
#line 399
  fdout = fdout_arg;
#line 400
  fderr = fderr_arg;
#line 403
  set_nonblock(fdin);
#line 404
  set_nonblock(fdout);
#line 406
  if (fderr != -1) {
#line 407
    set_nonblock(fderr);
  }
#line 409
  connection_in___0 = packet_get_connection_in();
#line 410
  connection_out___0 = packet_get_connection_out();
#line 412
  previous_stdout_buffer_bytes = 0U;
#line 415
  tmp = packet_is_interactive();
#line 415
  if (tmp) {
#line 416
    buffer_high = 4096U;
  } else {
#line 418
    buffer_high = 65536U;
  }
#line 421
  max_fd = fdin;
#line 422
  if (fdout > max_fd) {
#line 423
    max_fd = fdout;
  }
#line 424
  if (fderr != -1) {
#line 424
    if (fderr > max_fd) {
#line 425
      max_fd = fderr;
    }
  }
#line 426
  if (connection_in___0 > max_fd) {
#line 427
    max_fd = connection_in___0;
  }
#line 428
  if (connection_out___0 > max_fd) {
#line 429
    max_fd = connection_out___0;
  }
#line 432
  buffer_init(& stdin_buffer);
#line 433
  buffer_init(& stdout_buffer);
#line 434
  buffer_init(& stderr_buffer);
#line 442
  if (fderr == -1) {
#line 443
    fderr_eof = 1;
  }
#line 445
  server_init_dispatch();
#line 448
  while (1) {
#line 451
    process_buffered_input_packets();
#line 457
    if (stdin_eof) {
#line 457
      if (fdin != -1) {
#line 457
        tmp___0 = buffer_len(& stdin_buffer);
#line 457
        if (tmp___0 == 0U) {
#line 461
          if (fdin != fdout) {
#line 462
            close(fdin);
          } else {
#line 464
            shutdown(fdin, 1);
          }
#line 466
          fdin = -1;
        }
      }
    }
#line 469
    make_packets_from_stderr_data();
#line 478
    max_time_milliseconds = 0U;
#line 479
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 480
    if (stdout_buffer_bytes != 0U) {
#line 480
      if (stdout_buffer_bytes < 256U) {
#line 480
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 483
          max_time_milliseconds = 10U;
        } else {
#line 486
          make_packets_from_stdout_data();
        }
      } else {
#line 486
        make_packets_from_stdout_data();
      }
    } else {
#line 486
      make_packets_from_stdout_data();
    }
#line 488
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 491
    tmp___1 = packet_not_very_much_data_to_write();
#line 491
    if (tmp___1) {
#line 492
      channel_output_poll();
    }
#line 499
    if (fdout_eof) {
#line 499
      if (fderr_eof) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 499
      if (child_terminated) {
#line 499
        if (child_has_selected) {
          _L: /* CIL Label */ 
#line 499
          tmp___5 = packet_have_data_to_write();
#line 499
          if (! tmp___5) {
#line 499
            tmp___6 = buffer_len(& stdout_buffer);
#line 499
            if (tmp___6 == 0U) {
#line 499
              tmp___7 = buffer_len(& stderr_buffer);
#line 499
              if (tmp___7 == 0U) {
#line 504
                tmp___2 = channel_still_open();
#line 504
                if (! tmp___2) {
#line 505
                  break;
                }
#line 506
                if (! waiting_termination) {
#line 507
                  s = "Waiting for forwarded connections to terminate...\r\n";
#line 509
                  waiting_termination = 1;
#line 510
                  tmp___3 = strlen(s);
#line 510
                  buffer_append(& stderr_buffer, s, tmp___3);
#line 513
                  cp = channel_open_message();
#line 514
                  tmp___4 = strlen((char const   *)cp);
#line 514
                  buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 515
                  xfree((void *)cp);
                }
              }
            }
          }
        }
      }
    }
#line 519
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 523
    channel_after_select(& readset, & writeset);
#line 526
    process_input(& readset);
#line 529
    process_output(& writeset);
  }
#line 535
  drain_output();
#line 537
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 541
  buffer_free(& stdin_buffer);
#line 542
  buffer_free(& stdout_buffer);
#line 543
  buffer_free(& stderr_buffer);
#line 546
  if (fdout != -1) {
#line 547
    close(fdout);
  }
#line 548
  fdout = -1;
#line 549
  fdout_eof = 1;
#line 550
  if (fderr != -1) {
#line 551
    close(fderr);
  }
#line 552
  fderr = -1;
#line 553
  fderr_eof = 1;
#line 554
  if (fdin != -1) {
#line 555
    close(fdin);
  }
#line 556
  fdin = -1;
#line 559
  channel_stop_listening();
#line 562
  wait_pid = wait((union wait *)(& wait_status));
#line 563
  if (wait_pid < 0) {
#line 569
    if (child_terminated) {
#line 570
      wait_status = (int )child_wait_status;
    } else {
#line 572
      tmp___8 = __errno_location();
#line 572
      tmp___9 = strerror(*tmp___8);
#line 572
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 575
    if (wait_pid != pid) {
#line 576
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 581
  signal(17, (void (*)(int  ))0);
#line 584
  __constr_expr_2.__in = wait_status;
#line 584
  if ((__constr_expr_2.__i & 127) == 0) {
#line 586
    __constr_expr_0.__in = wait_status;
#line 586
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 587
    packet_start(20);
#line 588
    __constr_expr_1.__in = wait_status;
#line 588
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 589
    packet_send();
#line 590
    packet_write_wait();
#line 599
    while (1) {
#line 601
      type = packet_read(& plen);
#line 599
      if (! (type != 33)) {
#line 599
        break;
      }
    }
#line 605
    debug("Received exit confirmation.");
#line 606
    return;
  }
#line 609
  __constr_expr_4.__in = wait_status;
#line 609
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 610
    __constr_expr_3.__in = wait_status;
#line 610
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 614
  packet_disconnect("wait returned status %04x.", wait_status);
#line 616
  return;
}
}
#line 618 "serverloop.c"
void server_loop2(void) 
{ fd_set readset ;
  fd_set writeset ;
  int had_channel ;
  int status ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 622
  had_channel = 0;
#line 626
  debug("Entering interactive session for SSH2.");
#line 628
  signal(17, & sigchld_handler2);
#line 629
  child_terminated = (int volatile   )0;
#line 630
  connection_in___0 = packet_get_connection_in();
#line 631
  connection_out___0 = packet_get_connection_out();
#line 632
  max_fd = connection_in___0;
#line 633
  if (connection_out___0 > max_fd) {
#line 634
    max_fd = connection_out___0;
  }
#line 635
  server_init_dispatch();
#line 637
  while (1) {
#line 638
    process_buffered_input_packets();
#line 639
    if (! had_channel) {
#line 639
      tmp = channel_still_open();
#line 639
      if (tmp) {
#line 640
        had_channel = 1;
      }
    }
#line 641
    if (had_channel) {
#line 641
      tmp___0 = channel_still_open();
#line 641
      if (! tmp___0) {
#line 642
        debug("!channel_still_open.");
#line 643
        break;
      }
    }
#line 645
    tmp___1 = packet_not_very_much_data_to_write();
#line 645
    if (tmp___1) {
#line 646
      channel_output_poll();
    }
#line 647
    wait_until_can_do_something(& readset, & writeset, 0U);
#line 648
    if (child_terminated) {
#line 649
      while (1) {
#line 649
        pid = waitpid(-1, & status, 1);
#line 649
        if (! (pid > 0)) {
#line 649
          break;
        }
#line 650
        session_close_by_pid(pid, status);
      }
#line 651
      child_terminated = (int volatile   )0;
#line 652
      signal(17, & sigchld_handler2);
    }
#line 654
    channel_after_select(& readset, & writeset);
#line 655
    process_input(& readset);
#line 656
    process_output(& writeset);
  }
#line 658
  signal(17, (void (*)(int  ))0);
#line 659
  while (1) {
#line 659
    pid = waitpid(-1, & status, 1);
#line 659
    if (! (pid > 0)) {
#line 659
      break;
    }
#line 660
    session_close_by_pid(pid, status);
  }
#line 661
  channel_stop_listening();
#line 662
  return;
}
}
#line 664 "serverloop.c"
void server_input_stdin_data(int type , int plen ) 
{ char *data ;
  unsigned int data_len ;
  int _p ;
  int _e ;

  {
#line 672
  if (fdin == -1) {
#line 673
    return;
  }
#line 674
  data = packet_get_string(& data_len);
#line 675
  while (1) {
#line 675
    _p = plen;
#line 675
    _e = (int )(4U + data_len);
#line 675
    if (_p != _e) {
#line 675
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 675);
#line 675
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 675
    break;
  }
#line 676
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 677
  memset((void *)data, 0, data_len);
#line 678
  xfree((void *)data);
#line 679
  return;
}
}
#line 681 "serverloop.c"
void server_input_eof(int type , int plen ) 
{ int _p ;
  int _e ;

  {
#line 689
  debug("EOF received for stdin.");
#line 690
  while (1) {
#line 690
    _p = plen;
#line 690
    _e = 0;
#line 690
    if (_p != _e) {
#line 690
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 690);
#line 690
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 690
    break;
  }
#line 691
  stdin_eof = 1;
#line 692
  return;
}
}
#line 694 "serverloop.c"
void server_input_window_size(int type , int plen ) 
{ int row ;
  unsigned int tmp ;
  int col ;
  unsigned int tmp___0 ;
  int xpixel ;
  unsigned int tmp___1 ;
  int ypixel ;
  unsigned int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 697
  tmp = packet_get_int();
#line 697
  row = (int )tmp;
#line 698
  tmp___0 = packet_get_int();
#line 698
  col = (int )tmp___0;
#line 699
  tmp___1 = packet_get_int();
#line 699
  xpixel = (int )tmp___1;
#line 700
  tmp___2 = packet_get_int();
#line 700
  ypixel = (int )tmp___2;
#line 702
  debug("Window change received.");
#line 703
  while (1) {
#line 703
    _p = plen;
#line 703
    _e = 16;
#line 703
    if (_p != _e) {
#line 703
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 703);
#line 703
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 703
    break;
  }
#line 704
  if (fdin != -1) {
#line 705
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 706
  return;
}
}
#line 708 "serverloop.c"
int input_direct_tcpip(void) 
{ int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 715
  target = packet_get_string((unsigned int *)((void *)0));
#line 716
  tmp = packet_get_int();
#line 716
  target_port = (int )tmp;
#line 717
  originator = packet_get_string((unsigned int *)((void *)0));
#line 718
  tmp___0 = packet_get_int();
#line 718
  originator_port = (int )tmp___0;
#line 719
  while (1) {
#line 719
    tmp___1 = packet_remaining();
#line 719
    _len = tmp___1;
#line 719
    if (_len > 0) {
#line 719
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          719);
#line 719
      packet_disconnect("Packet integrity error.");
    }
#line 719
    break;
  }
#line 721
  debug("open direct-tcpip: from %s port %d to %s port %d", originator, originator_port,
        target, target_port);
#line 725
  if (no_port_forwarding_flag) {
#line 726
    xfree((void *)target);
#line 727
    xfree((void *)originator);
#line 728
    return (-1);
  }
#line 730
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 731
  xfree((void *)target);
#line 732
  xfree((void *)originator);
#line 733
  if (sock < 0) {
#line 734
    return (-1);
  }
#line 735
  tmp___2 = xstrdup("direct-tcpip");
#line 735
  tmp___3 = channel_new((char *)"direct-tcpip", 4, sock, sock, -1, 4096, 32768, 0,
                        tmp___2);
#line 735
  return (tmp___3);
}
}
#line 739 "serverloop.c"
void server_input_channel_open(int type , int plen ) 
{ Channel *c ;
  char *ctype ;
  int id ;
  unsigned int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int _len ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 742
  c = (Channel *)((void *)0);
#line 750
  ctype = packet_get_string(& len);
#line 751
  tmp = packet_get_int();
#line 751
  rchan = (int )tmp;
#line 752
  tmp___0 = packet_get_int();
#line 752
  rwindow = (int )tmp___0;
#line 753
  tmp___1 = packet_get_int();
#line 753
  rmaxpack = (int )tmp___1;
#line 755
  debug("channel_input_open: ctype %s rchan %d win %d max %d", ctype, rchan, rwindow,
        rmaxpack);
#line 758
  if (0) {
#line 758
    __s1_len___0 = strlen((char const   *)ctype);
#line 758
    __s2_len___0 = strlen("session");
#line 758
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 758
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 758
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 758
          tmp___24 = 1;
        } else {
#line 758
          if (__s2_len___0 >= 4U) {
#line 758
            tmp___24 = 1;
          } else {
#line 758
            tmp___24 = 0;
          }
        }
      } else {
#line 758
        tmp___24 = 0;
      }
    }
#line 758
    if (tmp___24) {
#line 758
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 758
      tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 758
      tmp___20 = tmp___23;
    }
  } else {
#line 758
    tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 758
    tmp___20 = tmp___23;
  }
#line 758
  if (tmp___20 == 0) {
#line 759
    debug("open session");
#line 760
    while (1) {
#line 760
      tmp___2 = packet_remaining();
#line 760
      _len = tmp___2;
#line 760
      if (_len > 0) {
#line 760
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            760);
#line 760
        packet_disconnect("Packet integrity error.");
      }
#line 760
      break;
    }
#line 768
    tmp___3 = xstrdup("server-session");
#line 768
    id = channel_new(ctype, 10, -1, -1, -1, 0, 32768, 0, tmp___3);
#line 770
    tmp___4 = session_open(id);
#line 770
    if (tmp___4 == 1) {
#line 771
      channel_register_callback(id, 98, & session_input_channel_req, (void *)0);
#line 773
      channel_register_cleanup(id, & session_close_by_channel);
#line 774
      c = channel_lookup(id);
    } else {
#line 776
      debug("session open failed, free channel %d", id);
#line 777
      channel_free(id);
    }
  } else {
#line 779
    if (0) {
#line 779
      __s1_len = strlen((char const   *)ctype);
#line 779
      __s2_len = strlen("direct-tcpip");
#line 779
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 779
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 779
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 779
            tmp___14 = 1;
          } else {
#line 779
            if (__s2_len >= 4U) {
#line 779
              tmp___14 = 1;
            } else {
#line 779
              tmp___14 = 0;
            }
          }
        } else {
#line 779
          tmp___14 = 0;
        }
      }
#line 779
      if (tmp___14) {
#line 779
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 779
        tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 779
        tmp___10 = tmp___13;
      }
    } else {
#line 779
      tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 779
      tmp___10 = tmp___13;
    }
#line 779
    if (tmp___10 == 0) {
#line 780
      id = input_direct_tcpip();
#line 781
      if (id >= 0) {
#line 782
        c = channel_lookup(id);
      }
    }
  }
#line 784
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 785
    debug("confirm %s", ctype);
#line 786
    c->remote_id = rchan;
#line 787
    c->remote_window = rwindow;
#line 788
    c->remote_maxpacket = rmaxpack;
#line 790
    packet_start(91);
#line 791
    packet_put_int((unsigned int )c->remote_id);
#line 792
    packet_put_int((unsigned int )c->self);
#line 793
    packet_put_int((unsigned int )c->local_window);
#line 794
    packet_put_int((unsigned int )c->local_maxpacket);
#line 795
    packet_send();
  } else {
#line 797
    debug("failure %s", ctype);
#line 798
    packet_start(92);
#line 799
    packet_put_int((unsigned int )rchan);
#line 800
    packet_put_int(1U);
#line 801
    packet_put_cstring("bla bla");
#line 802
    packet_put_cstring("");
#line 803
    packet_send();
  }
#line 805
  xfree((void *)ctype);
#line 806
  return;
}
}
#line 808 "serverloop.c"
void server_init_dispatch_20(void) 
{ 

  {
#line 811
  debug("server_init_dispatch_20");
#line 812
  dispatch_init(& dispatch_protocol_error);
#line 813
  dispatch_set(97, & channel_input_oclose);
#line 814
  dispatch_set(94, & channel_input_data);
#line 815
  dispatch_set(96, & channel_input_ieof);
#line 816
  dispatch_set(95, & channel_input_extended_data);
#line 817
  dispatch_set(90, & server_input_channel_open);
#line 818
  dispatch_set(91, & channel_input_open_confirmation);
#line 819
  dispatch_set(92, & channel_input_open_failure);
#line 820
  dispatch_set(98, & channel_input_channel_request);
#line 821
  dispatch_set(93, & channel_input_window_adjust);
#line 822
  return;
}
}
#line 823 "serverloop.c"
void server_init_dispatch_13(void) 
{ 

  {
#line 826
  debug("server_init_dispatch_13");
#line 827
  dispatch_init((dispatch_fn *)((void *)0));
#line 828
  dispatch_set(19, & server_input_eof);
#line 829
  dispatch_set(16, & server_input_stdin_data);
#line 830
  dispatch_set(11, & server_input_window_size);
#line 831
  dispatch_set(24, & channel_input_close);
#line 832
  dispatch_set(25, & channel_input_close_confirmation);
#line 833
  dispatch_set(23, & channel_input_data);
#line 834
  dispatch_set(21, & channel_input_open_confirmation);
#line 835
  dispatch_set(22, & channel_input_open_failure);
#line 836
  dispatch_set(29, & channel_input_port_open);
#line 837
  return;
}
}
#line 838 "serverloop.c"
void server_init_dispatch_15(void) 
{ 

  {
#line 841
  server_init_dispatch_13();
#line 842
  debug("server_init_dispatch_15");
#line 843
  dispatch_set(24, & channel_input_ieof);
#line 844
  dispatch_set(25, & channel_input_oclose);
#line 845
  return;
}
}
#line 846 "serverloop.c"
void server_init_dispatch(void) 
{ 

  {
#line 849
  if (compat20) {
#line 850
    server_init_dispatch_20();
  } else {
#line 851
    if (compat13) {
#line 852
      server_init_dispatch_13();
    } else {
#line 854
      server_init_dispatch_15();
    }
  }
#line 855
  return;
}
}
#line 1 "md5crypt.o"
#line 1 "session.o"
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 71 "session.c"
Session *session_new(void) ;
#line 72
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 73
void session_pty_cleanup(Session *s ) ;
#line 74
void session_proctitle(Session *s ) ;
#line 75
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 76
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 78
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 97 "session.c"
static char *xauthfile  ;
#line 101 "session.c"
Session sessions[10]  ;
#line 110 "session.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 113
  debug("xauthfile_cleanup_proc called");
#line 115
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 117
    unlink((char const   *)xauthfile);
#line 118
    p = strrchr((char const   *)xauthfile, '/');
#line 119
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 120
      *p = (char )'\000';
#line 121
      rmdir((char const   *)xauthfile);
    }
#line 123
    xfree((void *)xauthfile);
#line 124
    xauthfile = (char *)((void *)0);
  }
#line 126
  return;
}
}
#line 132 "session.c"
void pty_cleanup_proc(void *session ) 
{ Session *s ;

  {
#line 135
  s = (Session *)session;
#line 136
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 137
    fatal("pty_cleanup_proc: no session");
  }
#line 138
  debug("pty_cleanup_proc: %s", s->tty);
#line 140
  if (s->pid != 0) {
#line 142
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 146
  pty_release((char const   *)(s->tty));
#line 147
  return;
}
}
#line 155 "session.c"
void do_authenticated(struct passwd *pw ) 
{ Session *s ;
  int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  char *command ;
  int n_bytes ;
  int plen ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int dlen ;
  int success ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  void *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int tmp___25 ;

  {
#line 160
  compression_level = 0;
#line 160
  enable_compression_after_reply = 0;
#line 161
  have_pty = 0;
#line 171
  alarm(0U);
#line 172
  if (startup_pipe != -1) {
#line 173
    close(startup_pipe);
#line 174
    startup_pipe = -1;
  }
#line 184
  if (! no_port_forwarding_flag) {
#line 185
    channel_permit_all_opens();
  }
#line 187
  s = session_new();
#line 188
  s->pw = pw;
#line 194
  while (1) {
#line 195
    success = 0;
#line 198
    type = packet_read(& plen);
#line 201
    switch (type) {
    case 37: 
#line 203
    while (1) {
#line 203
      _p = plen;
#line 203
      _e = 4;
#line 203
      if (_p != _e) {
#line 203
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 203);
#line 203
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 203
      break;
    }
#line 204
    tmp = packet_get_int();
#line 204
    compression_level = (int )tmp;
#line 205
    if (compression_level < 1) {
#line 206
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 208
      break;
    } else {
#line 205
      if (compression_level > 9) {
#line 206
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 208
        break;
      }
    }
#line 211
    enable_compression_after_reply = 1;
#line 212
    success = 1;
#line 213
    break;
    case 10: 
#line 216
    if (no_pty_flag) {
#line 217
      debug("Allocating a pty not permitted for this authentication.");
#line 218
      break;
    }
#line 220
    if (have_pty) {
#line 221
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 223
    debug("Allocating pty.");
#line 226
    tmp___0 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 226
    if (! tmp___0) {
#line 228
      error("Failed to allocate pty.");
#line 229
      break;
    }
#line 231
    fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 232
    pty_setowner(pw, (char const   *)(s->tty));
#line 235
    s->term = packet_get_string(& dlen);
#line 236
    while (1) {
#line 236
      _p___0 = (int )dlen;
#line 236
      tmp___1 = strlen((char const   *)s->term);
#line 236
      _e___0 = (int )tmp___1;
#line 236
      if (_p___0 != _e___0) {
#line 236
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "session.c",
            236);
#line 236
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 236
      break;
    }
#line 239
    n_bytes = (int )((unsigned int )plen - ((4U + dlen) + 16U));
#line 241
    if (0) {
#line 241
      __s1_len = strlen((char const   *)s->term);
#line 241
      __s2_len = strlen("");
#line 241
      if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
        goto _L___0;
      } else {
#line 241
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 241
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 241
            tmp___11 = 1;
          } else {
#line 241
            if (__s2_len >= 4U) {
#line 241
              tmp___11 = 1;
            } else {
#line 241
              tmp___11 = 0;
            }
          }
        } else {
#line 241
          tmp___11 = 0;
        }
      }
#line 241
      if (tmp___11) {
#line 241
        tmp___7 = __builtin_strcmp((char const   *)s->term, "");
      } else {
#line 241
        tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 241
        tmp___7 = tmp___10;
      }
    } else {
#line 241
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 241
      tmp___7 = tmp___10;
    }
#line 241
    if (tmp___7 == 0) {
#line 242
      xfree((void *)s->term);
#line 243
      s->term = (char *)((void *)0);
    }
#line 246
    tmp___12 = packet_get_int();
#line 246
    s->row = (int )tmp___12;
#line 247
    tmp___13 = packet_get_int();
#line 247
    s->col = (int )tmp___13;
#line 248
    tmp___14 = packet_get_int();
#line 248
    s->xpixel = (int )tmp___14;
#line 249
    tmp___15 = packet_get_int();
#line 249
    s->ypixel = (int )tmp___15;
#line 250
    pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 253
    tty_parse_modes(s->ttyfd, & n_bytes);
#line 254
    while (1) {
#line 254
      _p___1 = plen;
#line 254
      _e___1 = (int )(((4U + dlen) + 16U) + (unsigned int )n_bytes);
#line 254
      if (_p___1 != _e___1) {
#line 254
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "session.c",
            254);
#line 254
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 254
      break;
    }
#line 256
    session_proctitle(s);
#line 259
    success = 1;
#line 260
    have_pty = 1;
#line 261
    break;
    case 34: 
#line 264
    if (! options.x11_forwarding) {
#line 265
      packet_send_debug("X11 forwarding disabled in server configuration file.");
#line 266
      break;
    }
#line 268
    if (! options.xauth_location) {
#line 269
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 270
      break;
    }
#line 272
    if (no_x11_forwarding_flag) {
#line 273
      packet_send_debug("X11 forwarding not permitted for this authentication.");
#line 274
      break;
    }
#line 276
    debug("Received request for X11 forwarding with auth spoofing.");
#line 277
    if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 278
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 280
    s->auth_proto = packet_get_string(& proto_len);
#line 281
    s->auth_data = packet_get_string(& data_len);
#line 282
    while (1) {
#line 282
      _p___2 = plen;
#line 282
      _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 282
      if (_p___2 != _e___2) {
#line 282
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "session.c",
            282);
#line 282
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 282
      break;
    }
#line 284
    tmp___17 = packet_get_protocol_flags();
#line 284
    if (tmp___17 & 1U) {
#line 285
      tmp___16 = packet_get_int();
#line 285
      s->screen = (int )tmp___16;
    } else {
#line 287
      s->screen = 0;
    }
#line 288
    s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 290
    if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 291
      break;
    }
#line 294
    tmp___18 = xmalloc(4096U);
#line 294
    xauthfile = (char *)tmp___18;
#line 295
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 296
    temporarily_use_uid(pw->pw_uid);
#line 297
    tmp___21 = mkdtemp(xauthfile);
#line 297
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
#line 298
      restore_uid();
#line 299
      tmp___19 = __errno_location();
#line 299
      tmp___20 = strerror(*tmp___19);
#line 299
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___20);
#line 301
      xfree((void *)xauthfile);
#line 302
      xauthfile = (char *)((void *)0);
#line 304
      break;
    }
#line 306
    strlcat(xauthfile, "/cookies", 4096U);
#line 307
    open((char const   *)xauthfile, 194, 384);
#line 308
    restore_uid();
#line 309
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 310
    success = 1;
#line 311
    break;
    case 30: 
#line 314
    if (no_agent_forwarding_flag) {
#line 315
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 316
      break;
    } else {
#line 314
      if (compat13) {
#line 315
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 316
        break;
      }
    }
#line 318
    debug("Received authentication agent forwarding request.");
#line 319
    success = auth_input_request_forwarding(pw);
#line 320
    break;
    case 28: 
#line 323
    if (no_port_forwarding_flag) {
#line 324
      debug("Port forwarding not permitted for this authentication.");
#line 325
      break;
    }
#line 327
    debug("Received TCP/IP port forwarding request.");
#line 328
    channel_input_port_forward_request(pw->pw_uid == 0U, options.gateway_ports);
#line 329
    success = 1;
#line 330
    break;
    case 38: 
#line 333
    tmp___22 = packet_get_int();
#line 333
    tmp___23 = packet_set_maxsize((int )tmp___22);
#line 333
    if (tmp___23 > 0) {
#line 334
      success = 1;
    }
#line 335
    break;
    case 12: 
    case 13: 
#line 340
    if (have_pty) {
#line 340
      tmp___24 = 1;
    } else {
#line 340
      if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 340
        tmp___24 = 1;
      } else {
#line 340
        tmp___24 = 0;
      }
    }
#line 340
    packet_set_interactive(tmp___24, options.keepalives);
#line 343
    if (type == 13) {
#line 344
      command = packet_get_string(& dlen);
#line 345
      debug("Exec command \'%.500s\'", command);
#line 346
      while (1) {
#line 346
        _p___3 = plen;
#line 346
        _e___3 = (int )(4U + dlen);
#line 346
        if (_p___3 != _e___3) {
#line 346
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "session.c",
              346);
#line 346
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 346
        break;
      }
    } else {
#line 348
      command = (char *)((void *)0);
#line 349
      while (1) {
#line 349
        _p___4 = plen;
#line 349
        _e___4 = 0;
#line 349
        if (_p___4 != _e___4) {
#line 349
          log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "session.c",
              349);
#line 349
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 349
        break;
      }
    }
#line 351
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
#line 352
      command = forced_command;
#line 353
      debug("Forced command \'%.500s\'", forced_command);
    }
#line 355
    if (have_pty) {
#line 356
      do_exec_pty(s, (char const   *)command, pw);
    } else {
#line 358
      do_exec_no_pty(s, (char const   *)command, pw);
    }
#line 360
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 361
      xfree((void *)command);
    }
#line 363
    if (xauthfile) {
#line 364
      xauthfile_cleanup_proc((void *)0);
    }
#line 365
    return;
    default: 
#line 372
    log("Unknown packet type received after authentication: %d", type);
    }
#line 374
    if (success) {
#line 374
      tmp___25 = 14;
    } else {
#line 374
      tmp___25 = 15;
    }
#line 374
    packet_start(tmp___25);
#line 375
    packet_send();
#line 376
    packet_write_wait();
#line 379
    if (enable_compression_after_reply) {
#line 380
      enable_compression_after_reply = 0;
#line 381
      packet_start_compression(compression_level);
    }
  }
}
}
#line 391 "session.c"
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 405
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 405
  if (tmp___1 < 0) {
#line 407
    tmp = __errno_location();
#line 407
    tmp___0 = strerror(*tmp);
#line 407
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 405
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 405
    if (tmp___2 < 0) {
#line 407
      tmp = __errno_location();
#line 407
      tmp___0 = strerror(*tmp);
#line 407
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 410
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 411
    fatal("do_exec_no_pty: no session");
  }
#line 413
  session_proctitle(s);
#line 416
  do_pam_setcred();
#line 420
  pid = fork();
#line 420
  if (pid == 0) {
#line 422
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 428
    tmp___5 = setsid();
#line 428
    if (tmp___5 < 0) {
#line 429
      tmp___3 = __errno_location();
#line 429
      tmp___4 = strerror(*tmp___3);
#line 429
      error("setsid failed: %.100s", tmp___4);
    }
#line 458
    close(inout[1]);
#line 459
    close(err[1]);
#line 460
    tmp___6 = dup2(inout[0], 0);
#line 460
    if (tmp___6 < 0) {
#line 461
      perror("dup2 stdin");
    }
#line 462
    tmp___7 = dup2(inout[0], 1);
#line 462
    if (tmp___7 < 0) {
#line 463
      perror("dup2 stdout");
    }
#line 464
    tmp___8 = dup2(err[0], 2);
#line 464
    if (tmp___8 < 0) {
#line 465
      perror("dup2 stderr");
    }
#line 469
    do_child(command, pw, (char const   *)((void *)0), (char const   *)s->display,
             (char const   *)s->auth_proto, (char const   *)s->auth_data, (char const   *)((void *)0));
  }
#line 472
  if (pid < 0) {
#line 473
    tmp___9 = __errno_location();
#line 473
    tmp___10 = strerror(*tmp___9);
#line 473
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 474
  s->pid = pid;
#line 490
  close(inout[0]);
#line 491
  close(err[0]);
#line 497
  if (compat20) {
#line 498
    if (s->extended) {
#line 498
      tmp___11 = err[1];
    } else {
#line 498
      tmp___11 = -1;
    }
#line 498
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 500
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 504
  return;
}
}
#line 512 "session.c"
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) 
{ FILE *f ;
  char buf___1[100] ;
  char *time_string ;
  char line[256] ;
  char const   *hostname ;
  int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  int quiet_login ;
  pid_t pid ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct stat st ;
  time_t last_login_time ;
  unsigned long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___19 ;
  char *tmp___21 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 527
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 528
    fatal("do_exec_pty: no session");
  }
#line 529
  ptyfd = s->ptyfd;
#line 530
  ttyfd = s->ttyfd;
#line 533
  hostname = get_canonical_hostname();
#line 539
  if (! options.use_login) {
#line 540
    tmp = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf___1, sizeof(buf___1));
#line 540
    last_login_time = (long )tmp;
  }
#line 545
  do_pam_session(pw->pw_name, (char const   *)(s->tty));
#line 546
  do_pam_setcred();
#line 550
  pid = fork();
#line 550
  if (pid == 0) {
#line 551
    pid = getpid();
#line 555
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 558
    close(ptyfd);
#line 561
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 564
    tmp___2 = fileno(stdin);
#line 564
    tmp___3 = dup2(ttyfd, tmp___2);
#line 564
    if (tmp___3 < 0) {
#line 565
      tmp___0 = __errno_location();
#line 565
      tmp___1 = strerror(*tmp___0);
#line 565
      error("dup2 stdin failed: %.100s", tmp___1);
    }
#line 568
    tmp___6 = fileno(stdout);
#line 568
    tmp___7 = dup2(ttyfd, tmp___6);
#line 568
    if (tmp___7 < 0) {
#line 569
      tmp___4 = __errno_location();
#line 569
      tmp___5 = strerror(*tmp___4);
#line 569
      error("dup2 stdin failed: %.100s", tmp___5);
    }
#line 572
    tmp___10 = fileno(stderr);
#line 572
    tmp___11 = dup2(ttyfd, tmp___10);
#line 572
    if (tmp___11 < 0) {
#line 573
      tmp___8 = __errno_location();
#line 573
      tmp___9 = strerror(*tmp___8);
#line 573
      error("dup2 stdin failed: %.100s", tmp___9);
    }
#line 576
    close(ttyfd);
#line 584
    memset((void *)(& from), 0, sizeof(from));
#line 585
    tmp___16 = packet_connection_is_on_socket();
#line 585
    if (tmp___16) {
#line 586
      fromlen = sizeof(from);
#line 587
      tmp___14 = packet_get_connection_in();
#line 587
      tmp___15 = getpeername(tmp___14, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                             (socklen_t * __restrict  )(& fromlen));
#line 587
      if (tmp___15 < 0) {
#line 589
        tmp___12 = __errno_location();
#line 589
        tmp___13 = strerror(*tmp___12);
#line 589
        debug("getpeername: %.100s", tmp___13);
#line 590
        fatal_cleanup();
      }
    }
#line 594
    record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
                 hostname, (struct sockaddr *)(& from));
#line 598
    snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.200s/.hushlogin",
             pw->pw_dir);
#line 599
    tmp___17 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 599
    quiet_login = tmp___17 >= 0;
#line 602
    if (! quiet_login) {
#line 603
      print_pam_messages();
    }
#line 614
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 614
      if (last_login_time != 0L) {
#line 614
        if (! quiet_login) {
#line 614
          if (! options.use_login) {
#line 617
            time_string = ctime((time_t const   *)(& last_login_time));
#line 619
            tmp___21 = __builtin_strchr(time_string, '\n');
#line 619
            if (tmp___21) {
#line 620
              tmp___19 = __builtin_strchr(time_string, '\n');
#line 620
              *tmp___19 = (char)0;
            }
#line 623
            if (0) {
#line 623
              __s1_len = strlen((char const   *)(buf___1));
#line 623
              __s2_len = strlen("");
#line 623
              if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
                goto _L___0;
              } else {
#line 623
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 623
                  if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 623
                    tmp___31 = 1;
                  } else {
#line 623
                    if (__s2_len >= 4U) {
#line 623
                      tmp___31 = 1;
                    } else {
#line 623
                      tmp___31 = 0;
                    }
                  }
                } else {
#line 623
                  tmp___31 = 0;
                }
              }
#line 623
              if (tmp___31) {
#line 623
                tmp___27 = __builtin_strcmp((char const   *)(buf___1), "");
              } else {
#line 623
                tmp___30 = __builtin_strcmp((char const   *)(buf___1), "");
#line 623
                tmp___27 = tmp___30;
              }
            } else {
#line 623
              tmp___30 = __builtin_strcmp((char const   *)(buf___1), "");
#line 623
              tmp___27 = tmp___30;
            }
#line 623
            if (tmp___27 == 0) {
#line 624
              printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
            } else {
#line 626
              printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
                     buf___1);
            }
          }
        }
      }
    }
#line 634
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 634
      if (options.print_motd) {
#line 634
        if (! quiet_login) {
#line 634
          if (! options.use_login) {
#line 637
            f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 638
            if (f) {
#line 639
              while (1) {
#line 639
                tmp___32 = fgets((char * __restrict  )(line), (int )sizeof(line),
                                 (FILE * __restrict  )f);
#line 639
                if (! tmp___32) {
#line 639
                  break;
                }
#line 640
                fputs((char const   * __restrict  )(line), (FILE * __restrict  )stdout);
              }
#line 641
              fclose(f);
            }
          }
        }
      }
    }
#line 654
    do_child(command, pw, (char const   *)s->term, (char const   *)s->display, (char const   *)s->auth_proto,
             (char const   *)s->auth_data, (char const   *)(s->tty));
  }
#line 658
  if (pid < 0) {
#line 659
    tmp___33 = __errno_location();
#line 659
    tmp___34 = strerror(*tmp___33);
#line 659
    packet_disconnect("fork failed: %.100s", tmp___34);
  }
#line 660
  s->pid = pid;
#line 663
  close(ttyfd);
#line 670
  fdout___0 = dup(ptyfd);
#line 671
  if (fdout___0 < 0) {
#line 672
    tmp___35 = __errno_location();
#line 672
    tmp___36 = strerror(*tmp___35);
#line 672
    packet_disconnect("dup #1 failed: %.100s", tmp___36);
  }
#line 675
  ptymaster = dup(ptyfd);
#line 676
  if (ptymaster < 0) {
#line 677
    tmp___37 = __errno_location();
#line 677
    tmp___38 = strerror(*tmp___37);
#line 677
    packet_disconnect("dup #2 failed: %.100s", tmp___38);
  }
#line 678
  s->ptymaster = ptymaster;
#line 681
  if (compat20) {
#line 682
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 684
    server_loop(pid, ptyfd, fdout___0, -1);
#line 686
    session_pty_cleanup(s);
  }
#line 688
  return;
}
}
#line 694 "session.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 706
  env = *envp;
#line 707
  namelen = strlen(name);
#line 708
  i = 0U;
#line 708
  while (*(env + i)) {
#line 709
    if (0) {
#line 709
      if (0) {
#line 709
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 709
        __s2_len___0 = strlen(name);
#line 709
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 709
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 709
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 709
              tmp___22 = 1;
            } else {
#line 709
              if (__s2_len___0 >= 4U) {
#line 709
                tmp___22 = 1;
              } else {
#line 709
                tmp___22 = 0;
              }
            }
          } else {
#line 709
            tmp___22 = 0;
          }
        }
#line 709
        if (tmp___22) {
#line 709
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 709
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 709
          tmp___18 = tmp___21;
        }
      } else {
#line 709
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 709
        tmp___18 = tmp___21;
      }
#line 709
      tmp___12 = tmp___18;
    } else {
#line 709
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 709
    if (tmp___12 == 0) {
#line 709
      if ((int )*(*(env + i) + namelen) == 61) {
#line 710
        break;
      }
    }
#line 708
    i ++;
  }
#line 711
  if (*(env + i)) {
#line 713
    xfree((void *)*(env + i));
  } else {
#line 716
    if (i >= *envsizep - 1U) {
#line 717
      *envsizep += 50U;
#line 718
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 718
      *envp = (char **)tmp___25;
#line 718
      env = *envp;
    }
#line 721
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 725
  tmp___26 = strlen(name);
#line 725
  tmp___27 = strlen(value);
#line 725
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 725
  *(env + i) = (char *)tmp___28;
#line 726
  tmp___29 = strlen(name);
#line 726
  tmp___30 = strlen(value);
#line 726
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 727
  return;
}
}
#line 735 "session.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 743
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 744
  if (! f) {
#line 745
    return;
  }
#line 747
  while (1) {
#line 747
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 747
    if (! tmp___5) {
#line 747
      break;
    }
#line 748
    cp = buf___1;
#line 748
    while (1) {
#line 748
      if (! ((int )*cp == 32)) {
#line 748
        if (! ((int )*cp == 9)) {
#line 748
          break;
        }
      }
#line 748
      cp ++;
    }
#line 750
    if (! *cp) {
#line 751
      continue;
    } else {
#line 750
      if ((int )*cp == 35) {
#line 751
        continue;
      } else {
#line 750
        if ((int )*cp == 10) {
#line 751
          continue;
        }
      }
    }
#line 752
    tmp___2 = __builtin_strchr(cp, '\n');
#line 752
    if (tmp___2) {
#line 753
      tmp___0 = __builtin_strchr(cp, '\n');
#line 753
      *tmp___0 = (char )'\000';
    }
#line 754
    tmp___4 = __builtin_strchr(cp, '=');
#line 754
    value = tmp___4;
#line 755
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 756
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___1);
#line 757
      continue;
    }
#line 763
    *value = (char )'\000';
#line 764
    value ++;
#line 765
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 767
  fclose(f);
#line 768
  return;
}
}
#line 774 "session.c"
void do_pam_environment(char ***env , int *envsize ) 
{ char *equals ;
  char var_name[512] ;
  char var_val[512] ;
  char **pam_env ;
  int i ;
  size_t tmp ;

  {
#line 780
  pam_env = fetch_pam_environment();
#line 780
  if ((unsigned int )pam_env == (unsigned int )((void *)0)) {
#line 781
    return;
  }
#line 783
  i = 0;
#line 783
  while ((unsigned int )*(pam_env + i) != (unsigned int )((void *)0)) {
#line 784
    equals = strstr((char const   *)*(pam_env + i), "=");
#line 784
    if ((unsigned int )equals == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 787
    tmp = strlen((char const   *)*(pam_env + i));
#line 787
    if (tmp < sizeof(var_name) - 1U) {
#line 788
      memset((void *)(var_name), '\000', sizeof(var_name));
#line 789
      memset((void *)(var_val), '\000', sizeof(var_val));
#line 791
      __builtin_strncpy(var_name, (char const   *)*(pam_env + i), (unsigned int )(equals - *(pam_env + i)));
#line 792
      strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equals + 1));
#line 794
      debug("PAM environment: %s=%s", var_name, var_val);
#line 796
      child_set_env(env, (unsigned int *)envsize, (char const   *)(var_name), (char const   *)(var_val));
    }
    __Cont: /* CIL Label */ 
#line 783
    i ++;
  }
#line 799
  return;
}
}
#line 897
extern char **environ ;
#line 886 "session.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *cp ;
  char buf___1[256] ;
  char cmd[1024] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *screen ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char buf___2[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___29 ;
  char const   *tmp___30 ;

  {
#line 891
  cp = (char const   *)((void *)0);
#line 905
  if (options.use_login) {
#line 905
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 906
      options.use_login = 0;
    }
  }
#line 922
  tmp___1 = setlogin((char const   *)pw->pw_name);
#line 922
  if (tmp___1 < 0) {
#line 923
    tmp = __errno_location();
#line 923
    tmp___0 = strerror(*tmp);
#line 923
    error("setlogin failed: %s", tmp___0);
  }
#line 929
  if (! options.use_login) {
#line 946
    tmp___4 = getuid();
#line 946
    if (tmp___4 == 0U) {
      goto _L;
    } else {
#line 946
      tmp___5 = geteuid();
#line 946
      if (tmp___5 == 0U) {
        _L: /* CIL Label */ 
#line 951
        tmp___2 = setgid(pw->pw_gid);
#line 951
        if (tmp___2 < 0) {
#line 952
          perror("setgid");
#line 953
          exit(1);
        }
#line 956
        tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 956
        if (tmp___3 < 0) {
#line 957
          perror("initgroups");
#line 958
          exit(1);
        }
#line 960
        endgrent();
#line 982
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 984
    tmp___6 = getuid();
#line 984
    if (tmp___6 != pw->pw_uid) {
#line 985
      fatal("Failed to set uids to %d.", (int )pw->pw_uid);
    } else {
#line 984
      tmp___7 = geteuid();
#line 984
      if (tmp___7 != pw->pw_uid) {
#line 985
        fatal("Failed to set uids to %d.", (int )pw->pw_uid);
      }
    }
  }
#line 992
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 992
    shell = "/bin/sh";
  } else {
#line 992
    shell = (char const   *)pw->pw_shell;
  }
#line 1007
  envsize = 100U;
#line 1008
  tmp___8 = xmalloc(envsize * sizeof(char *));
#line 1008
  env = (char **)tmp___8;
#line 1009
  *(env + 0) = (char *)((void *)0);
#line 1011
  if (! options.use_login) {
#line 1013
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1014
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1015
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1016
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 1018
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1020
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 1023
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1025
  tmp___10 = getenv("TZ");
#line 1025
  if (tmp___10) {
#line 1026
    tmp___9 = getenv("TZ");
#line 1026
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___9);
  }
#line 1029
  while (custom_environment) {
#line 1030
    ce = custom_environment;
#line 1031
    s = ce->s;
#line 1033
    i___0 = 0;
#line 1033
    while (1) {
#line 1033
      if ((int )*(s + i___0) != 61) {
#line 1033
        if (! *(s + i___0)) {
#line 1033
          break;
        }
      } else {
#line 1033
        break;
      }
#line 1033
      i___0 ++;
    }
#line 1034
    if ((int )*(s + i___0) == 61) {
#line 1035
      *(s + i___0) = (char)0;
#line 1036
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 1038
    custom_environment = ce->next;
#line 1039
    xfree((void *)ce->s);
#line 1040
    xfree((void *)ce);
  }
#line 1043
  tmp___11 = get_local_port();
#line 1043
  tmp___12 = get_remote_port();
#line 1043
  tmp___13 = get_remote_ipaddr();
#line 1043
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___13, tmp___12, tmp___11);
#line 1045
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1047
  if (ttyname___0) {
#line 1048
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 1049
  if (term) {
#line 1050
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 1051
  if (display) {
#line 1052
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 1077
  do_pam_environment(& env, (int *)(& envsize));
#line 1080
  read_environment_file(& env, & envsize, "/etc/environment");
#line 1082
  if (xauthfile) {
#line 1083
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 1084
  tmp___15 = auth_get_socket_name();
#line 1084
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 1085
    tmp___14 = auth_get_socket_name();
#line 1085
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___14);
  }
#line 1089
  if (! options.use_login) {
#line 1090
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 1092
    read_environment_file(& env, & envsize, (char const   *)(buf___1));
  }
#line 1094
  if (debug_flag) {
#line 1096
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1097
    i = 0U;
#line 1097
    while (*(env + i)) {
#line 1098
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1097
      i ++;
    }
  }
#line 1107
  tmp___19 = packet_get_connection_in();
#line 1107
  tmp___20 = packet_get_connection_out();
#line 1107
  if (tmp___19 == tmp___20) {
#line 1108
    tmp___16 = packet_get_connection_in();
#line 1108
    close(tmp___16);
  } else {
#line 1110
    tmp___17 = packet_get_connection_in();
#line 1110
    close(tmp___17);
#line 1111
    tmp___18 = packet_get_connection_out();
#line 1111
    close(tmp___18);
  }
#line 1118
  channel_close_all();
#line 1124
  endpwent();
#line 1132
  i = 3U;
#line 1132
  while (i < 64U) {
#line 1133
    close((int )i);
#line 1132
    i ++;
  }
#line 1136
  tmp___23 = chdir((char const   *)pw->pw_dir);
#line 1136
  if (tmp___23 < 0) {
#line 1137
    tmp___21 = __errno_location();
#line 1137
    tmp___22 = strerror(*tmp___21);
#line 1137
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___22);
  }
#line 1144
  environ = env;
#line 1150
  if (! options.use_login) {
#line 1151
    tmp___27 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1151
    if (tmp___27 >= 0) {
#line 1152
      if (debug_flag) {
#line 1153
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 1155
      f = popen("/bin/sh .ssh/rc", "w");
#line 1156
      if (f) {
#line 1157
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1157
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1158
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 1159
        pclose(f);
      } else {
#line 1161
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 1162
      tmp___26 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1162
      if (tmp___26 >= 0) {
#line 1163
        if (debug_flag) {
#line 1164
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 1166
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1167
        if (f) {
#line 1168
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1168
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1169
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 1170
          pclose(f);
        } else {
#line 1172
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1173
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1175
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1175
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1176
              tmp___25 = __builtin_strchr((char *)display, ':');
#line 1176
              screen = tmp___25;
#line 1177
              if (debug_flag) {
#line 1178
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                        options.xauth_location, display, auth_proto, auth_data);
#line 1182
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1183
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Adding %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
              }
#line 1188
              snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                       options.xauth_location);
#line 1190
              f = popen((char const   *)(cmd), "w");
#line 1191
              if (f) {
#line 1192
                fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                        display, auth_proto, auth_data);
#line 1194
                if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1195
                  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %.*s/unix%s %s %s\n",
                          screen - (char *)display, display, screen, auth_proto, auth_data);
                }
#line 1198
                pclose(f);
              } else {
#line 1200
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                        cmd);
              }
            }
          }
        }
      }
    }
#line 1206
    tmp___28 = strrchr(shell, '/');
#line 1206
    cp = (char const   *)tmp___28;
#line 1207
    if (cp) {
#line 1208
      cp ++;
    } else {
#line 1210
      cp = shell;
    }
  }
#line 1217
  if (! command) {
#line 1218
    if (! options.use_login) {
#line 1225
      if (ttyname___0) {
#line 1225
        if (options.check_mail) {
#line 1228
          mailbox = getenv("MAIL");
#line 1229
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 1230
            tmp___29 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 1230
            if (tmp___29 != 0) {
#line 1232
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 1230
              if (mailstat.st_size == 0L) {
#line 1232
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 1233
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 1234
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 1236
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 1240
      buf___2[0] = (char )'-';
#line 1241
      __builtin_strncpy(buf___2 + 1, cp, sizeof(buf___2) - 1U);
#line 1242
      buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 1245
      argv[0] = buf___2;
#line 1246
      argv[1] = (char *)((void *)0);
#line 1247
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1250
      perror(shell);
#line 1251
      exit(1);
    } else {
#line 1256
      tmp___30 = get_remote_ipaddr();
#line 1256
      execl("/usr/bin/login", "login", "-h", tmp___30, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 1261
      perror("login");
#line 1262
      exit(1);
    }
  }
#line 1269
  argv[0] = (char *)cp;
#line 1270
  argv[1] = (char *)"-c";
#line 1271
  argv[2] = (char *)command;
#line 1272
  argv[3] = (char *)((void *)0);
#line 1273
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1274
  perror(shell);
#line 1275
  exit(1);
}
}
#line 1282 "session.c"
static int did_init___0  =    0;
#line 1278 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1283
  if (! did_init___0) {
#line 1284
    debug("session_new: init");
#line 1285
    i = 0;
#line 1285
    while (i < 10) {
#line 1286
      sessions[i].used = 0;
#line 1287
      sessions[i].self = i;
#line 1285
      i ++;
    }
#line 1289
    did_init___0 = 1;
  }
#line 1291
  i = 0;
#line 1291
  while (i < 10) {
#line 1292
    s = & sessions[i];
#line 1293
    if (! s->used) {
#line 1294
      s->pid = 0;
#line 1295
      s->extended = 0;
#line 1296
      s->chanid = -1;
#line 1297
      s->ptyfd = -1;
#line 1298
      s->ttyfd = -1;
#line 1299
      s->term = (char *)((void *)0);
#line 1300
      s->pw = (struct passwd *)((void *)0);
#line 1301
      s->display = (char *)((void *)0);
#line 1302
      s->screen = 0;
#line 1303
      s->auth_data = (char *)((void *)0);
#line 1304
      s->auth_proto = (char *)((void *)0);
#line 1305
      s->used = 1;
#line 1306
      s->pw = (struct passwd *)((void *)0);
#line 1307
      debug("session_new: session %d", i);
#line 1308
      return (s);
    }
#line 1291
    i ++;
  }
#line 1311
  return ((Session *)((void *)0));
}
}
#line 1314 "session.c"
void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1318
  i = 0;
#line 1318
  while (i < 10) {
#line 1319
    s = & sessions[i];
#line 1320
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1318
    i ++;
  }
#line 1327
  return;
}
}
#line 1329 "session.c"
int session_open(int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1332
  tmp = session_new();
#line 1332
  s = tmp;
#line 1333
  debug("session_open: channel %d", chanid);
#line 1334
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1335
    error("no more sessions");
#line 1336
    return (0);
  }
#line 1338
  s->pw = auth_get_user();
#line 1339
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1340
    fatal("no user for session %i", s->self);
  }
#line 1341
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1342
  s->chanid = chanid;
#line 1343
  return (1);
}
}
#line 1346 "session.c"
Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1350
  i = 0;
#line 1350
  while (i < 10) {
#line 1351
    s = & sessions[i];
#line 1352
    if (s->used) {
#line 1352
      if (s->chanid == id) {
#line 1353
        debug("session_by_channel: session %d channel %d", i, id);
#line 1354
        return (s);
      }
    }
#line 1350
    i ++;
  }
#line 1357
  debug("session_by_channel: unknown channel %d", id);
#line 1358
  session_dump();
#line 1359
  return ((Session *)((void *)0));
}
}
#line 1362 "session.c"
Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1366
  debug("session_by_pid: pid %d", pid);
#line 1367
  i = 0;
#line 1367
  while (i < 10) {
#line 1368
    s = & sessions[i];
#line 1369
    if (s->used) {
#line 1369
      if (s->pid == pid) {
#line 1370
        return (s);
      }
    }
#line 1367
    i ++;
  }
#line 1372
  error("session_by_pid: unknown pid %d", pid);
#line 1373
  session_dump();
#line 1374
  return ((Session *)((void *)0));
}
}
#line 1377 "session.c"
int session_window_change_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1380
  tmp = packet_get_int();
#line 1380
  s->col = (int )tmp;
#line 1381
  tmp___0 = packet_get_int();
#line 1381
  s->row = (int )tmp___0;
#line 1382
  tmp___1 = packet_get_int();
#line 1382
  s->xpixel = (int )tmp___1;
#line 1383
  tmp___2 = packet_get_int();
#line 1383
  s->ypixel = (int )tmp___2;
#line 1384
  while (1) {
#line 1384
    tmp___3 = packet_remaining();
#line 1384
    _len = tmp___3;
#line 1384
    if (_len > 0) {
#line 1384
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1384);
#line 1384
      packet_disconnect("Packet integrity error.");
    }
#line 1384
    break;
  }
#line 1385
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1386
  return (1);
}
}
#line 1389 "session.c"
int session_pty_req(Session *s ) 
{ unsigned int len ;
  char *term_modes ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1395
  if (no_pty_flag) {
#line 1396
    return (0);
  }
#line 1397
  if (s->ttyfd != -1) {
#line 1398
    return (0);
  }
#line 1399
  s->term = packet_get_string(& len);
#line 1400
  tmp = packet_get_int();
#line 1400
  s->col = (int )tmp;
#line 1401
  tmp___0 = packet_get_int();
#line 1401
  s->row = (int )tmp___0;
#line 1402
  tmp___1 = packet_get_int();
#line 1402
  s->xpixel = (int )tmp___1;
#line 1403
  tmp___2 = packet_get_int();
#line 1403
  s->ypixel = (int )tmp___2;
#line 1404
  term_modes = packet_get_string(& len);
#line 1405
  while (1) {
#line 1405
    tmp___3 = packet_remaining();
#line 1405
    _len = tmp___3;
#line 1405
    if (_len > 0) {
#line 1405
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1405);
#line 1405
      packet_disconnect("Packet integrity error.");
    }
#line 1405
    break;
  }
#line 1407
  if (0) {
#line 1407
    __s1_len = strlen((char const   *)s->term);
#line 1407
    __s2_len = strlen("");
#line 1407
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1407
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1407
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1407
          tmp___13 = 1;
        } else {
#line 1407
          if (__s2_len >= 4U) {
#line 1407
            tmp___13 = 1;
          } else {
#line 1407
            tmp___13 = 0;
          }
        }
      } else {
#line 1407
        tmp___13 = 0;
      }
    }
#line 1407
    if (tmp___13) {
#line 1407
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1407
      tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1407
      tmp___9 = tmp___12;
    }
  } else {
#line 1407
    tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1407
    tmp___9 = tmp___12;
  }
#line 1407
  if (tmp___9 == 0) {
#line 1408
    xfree((void *)s->term);
#line 1409
    s->term = (char *)((void *)0);
  }
#line 1412
  tmp___14 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1412
  if (! tmp___14) {
#line 1413
    xfree((void *)s->term);
#line 1414
    s->term = (char *)((void *)0);
#line 1415
    s->ptyfd = -1;
#line 1416
    s->ttyfd = -1;
#line 1417
    error("session_pty_req: session %d alloc failed", s->self);
#line 1418
    xfree((void *)term_modes);
#line 1419
    return (0);
  }
#line 1421
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1426
  fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 1427
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1429
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1431
  session_proctitle(s);
#line 1434
  xfree((void *)term_modes);
#line 1435
  return (1);
}
}
#line 1438 "session.c"
int session_subsystem_req(Session *s ) 
{ unsigned int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1442
  success = 0;
#line 1443
  tmp = packet_get_string(& len);
#line 1443
  subsys = tmp;
#line 1446
  while (1) {
#line 1446
    tmp___0 = packet_remaining();
#line 1446
    _len = tmp___0;
#line 1446
    if (_len > 0) {
#line 1446
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1446);
#line 1446
      packet_disconnect("Packet integrity error.");
    }
#line 1446
    break;
  }
#line 1447
  log("subsystem request for %s", subsys);
#line 1449
  i = 0;
#line 1449
  while ((unsigned int )i < options.num_subsystems) {
#line 1450
    if (0) {
#line 1450
      __s1_len = strlen((char const   *)subsys);
#line 1450
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1450
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1450
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1450
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1450
            tmp___10 = 1;
          } else {
#line 1450
            if (__s2_len >= 4U) {
#line 1450
              tmp___10 = 1;
            } else {
#line 1450
              tmp___10 = 0;
            }
          }
        } else {
#line 1450
          tmp___10 = 0;
        }
      }
#line 1450
      if (tmp___10) {
#line 1450
        tmp___6 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1450
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1450
        tmp___6 = tmp___9;
      }
    } else {
#line 1450
      tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1450
      tmp___6 = tmp___9;
    }
#line 1450
    if (tmp___6 == 0) {
#line 1451
      debug("subsystem: exec() %s", options.subsystem_command[i]);
#line 1452
      do_exec_no_pty(s, (char const   *)options.subsystem_command[i], s->pw);
#line 1453
      success = 1;
    }
#line 1449
    i ++;
  }
#line 1457
  if (! success) {
#line 1458
    log("subsystem request for %s failed, subsystem not found", subsys);
  }
#line 1460
  xfree((void *)subsys);
#line 1461
  return (success);
}
}
#line 1464 "session.c"
int session_x11_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1467
  if (no_x11_forwarding_flag) {
#line 1468
    debug("X11 forwarding disabled in user configuration file.");
#line 1469
    return (0);
  }
#line 1471
  if (! options.x11_forwarding) {
#line 1472
    debug("X11 forwarding disabled in server configuration file.");
#line 1473
    return (0);
  }
#line 1475
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1476
    debug("X11 fwd already started.");
#line 1477
    return (0);
  }
#line 1480
  debug("Received request for X11 forwarding with auth spoofing.");
#line 1481
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1482
    packet_disconnect("Protocol error: X11 display already set.");
  }
#line 1484
  tmp = packet_get_char();
#line 1484
  s->single_connection = (int )tmp;
#line 1485
  s->auth_proto = packet_get_string((unsigned int *)((void *)0));
#line 1486
  s->auth_data = packet_get_string((unsigned int *)((void *)0));
#line 1487
  tmp___0 = packet_get_int();
#line 1487
  s->screen = (int )tmp___0;
#line 1488
  while (1) {
#line 1488
    tmp___1 = packet_remaining();
#line 1488
    _len = tmp___1;
#line 1488
    if (_len > 0) {
#line 1488
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1488);
#line 1488
      packet_disconnect("Packet integrity error.");
    }
#line 1488
    break;
  }
#line 1490
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 1491
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 1492
    xfree((void *)s->auth_proto);
#line 1493
    xfree((void *)s->auth_data);
#line 1494
    return (0);
  }
#line 1496
  tmp___2 = xmalloc(4096U);
#line 1496
  xauthfile = (char *)tmp___2;
#line 1497
  strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1498
  temporarily_use_uid((s->pw)->pw_uid);
#line 1499
  tmp___5 = mkdtemp(xauthfile);
#line 1499
  if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 1500
    restore_uid();
#line 1501
    tmp___3 = __errno_location();
#line 1501
    tmp___4 = strerror(*tmp___3);
#line 1501
    error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___4);
#line 1503
    xfree((void *)xauthfile);
#line 1504
    xauthfile = (char *)((void *)0);
#line 1505
    xfree((void *)s->auth_proto);
#line 1506
    xfree((void *)s->auth_data);
#line 1508
    return (0);
  }
#line 1510
  strlcat(xauthfile, "/cookies", 4096U);
#line 1511
  open((char const   *)xauthfile, 194, 384);
#line 1512
  restore_uid();
#line 1513
  fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)s);
#line 1514
  return (1);
}
}
#line 1517 "session.c"
int session_shell_req(Session *s ) 
{ char *shell ;
  int _len ;
  int tmp ;

  {
#line 1521
  shell = forced_command;
#line 1522
  while (1) {
#line 1522
    tmp = packet_remaining();
#line 1522
    _len = tmp;
#line 1522
    if (_len > 0) {
#line 1522
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1522);
#line 1522
      packet_disconnect("Packet integrity error.");
    }
#line 1522
    break;
  }
#line 1523
  s->extended = 1;
#line 1524
  if (s->ttyfd == -1) {
#line 1525
    do_exec_no_pty(s, (char const   *)shell, s->pw);
  } else {
#line 1527
    do_exec_pty(s, (char const   *)shell, s->pw);
  }
#line 1528
  return (1);
}
}
#line 1531 "session.c"
int session_exec_req(Session *s ) 
{ unsigned int len ;
  char *command ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1535
  tmp = packet_get_string(& len);
#line 1535
  command = tmp;
#line 1536
  while (1) {
#line 1536
    tmp___0 = packet_remaining();
#line 1536
    _len = tmp___0;
#line 1536
    if (_len > 0) {
#line 1536
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1536);
#line 1536
      packet_disconnect("Packet integrity error.");
    }
#line 1536
    break;
  }
#line 1537
  if (forced_command) {
#line 1538
    xfree((void *)command);
#line 1539
    command = forced_command;
#line 1540
    debug("Forced command \'%.500s\'", forced_command);
  }
#line 1542
  s->extended = 1;
#line 1543
  if (s->ttyfd == -1) {
#line 1544
    do_exec_no_pty(s, (char const   *)command, s->pw);
  } else {
#line 1546
    do_exec_pty(s, (char const   *)command, s->pw);
  }
#line 1547
  if ((unsigned int )forced_command == (unsigned int )((void *)0)) {
#line 1548
    xfree((void *)command);
  }
#line 1549
  return (1);
}
}
#line 1552 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ unsigned int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;

  {
#line 1557
  success = 0;
#line 1562
  rtype = packet_get_string(& len);
#line 1563
  tmp = packet_get_char();
#line 1563
  reply = (int )tmp;
#line 1565
  s = session_by_channel(id);
#line 1566
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1567
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1568
  c = channel_lookup(id);
#line 1569
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1570
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1572
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1579
  if (c->type == 10) {
#line 1580
    if (0) {
#line 1580
      __s1_len___3 = strlen((char const   *)rtype);
#line 1580
      __s2_len___3 = strlen("shell");
#line 1580
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___8;
      } else {
#line 1580
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 1580
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1580
            tmp___49 = 1;
          } else {
#line 1580
            if (__s2_len___3 >= 4U) {
#line 1580
              tmp___49 = 1;
            } else {
#line 1580
              tmp___49 = 0;
            }
          }
        } else {
#line 1580
          tmp___49 = 0;
        }
      }
#line 1580
      if (tmp___49) {
#line 1580
        tmp___45 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1580
        tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1580
        tmp___45 = tmp___48;
      }
    } else {
#line 1580
      tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1580
      tmp___45 = tmp___48;
    }
#line 1580
    if (tmp___45 == 0) {
#line 1581
      success = session_shell_req(s);
    } else {
#line 1582
      if (0) {
#line 1582
        __s1_len___2 = strlen((char const   *)rtype);
#line 1582
        __s2_len___2 = strlen("exec");
#line 1582
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___6;
        } else {
#line 1582
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 1582
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1582
              tmp___39 = 1;
            } else {
#line 1582
              if (__s2_len___2 >= 4U) {
#line 1582
                tmp___39 = 1;
              } else {
#line 1582
                tmp___39 = 0;
              }
            }
          } else {
#line 1582
            tmp___39 = 0;
          }
        }
#line 1582
        if (tmp___39) {
#line 1582
          tmp___35 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1582
          tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1582
          tmp___35 = tmp___38;
        }
      } else {
#line 1582
        tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1582
        tmp___35 = tmp___38;
      }
#line 1582
      if (tmp___35 == 0) {
#line 1583
        success = session_exec_req(s);
      } else {
#line 1584
        if (0) {
#line 1584
          __s1_len___1 = strlen((char const   *)rtype);
#line 1584
          __s2_len___1 = strlen("pty-req");
#line 1584
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___4;
          } else {
#line 1584
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 1584
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1584
                tmp___29 = 1;
              } else {
#line 1584
                if (__s2_len___1 >= 4U) {
#line 1584
                  tmp___29 = 1;
                } else {
#line 1584
                  tmp___29 = 0;
                }
              }
            } else {
#line 1584
              tmp___29 = 0;
            }
          }
#line 1584
          if (tmp___29) {
#line 1584
            tmp___25 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1584
            tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1584
            tmp___25 = tmp___28;
          }
        } else {
#line 1584
          tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1584
          tmp___25 = tmp___28;
        }
#line 1584
        if (tmp___25 == 0) {
#line 1585
          success = session_pty_req(s);
        } else {
#line 1586
          if (0) {
#line 1586
            __s1_len___0 = strlen((char const   *)rtype);
#line 1586
            __s2_len___0 = strlen("x11-req");
#line 1586
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___2;
            } else {
#line 1586
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 1586
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1586
                  tmp___19 = 1;
                } else {
#line 1586
                  if (__s2_len___0 >= 4U) {
#line 1586
                    tmp___19 = 1;
                  } else {
#line 1586
                    tmp___19 = 0;
                  }
                }
              } else {
#line 1586
                tmp___19 = 0;
              }
            }
#line 1586
            if (tmp___19) {
#line 1586
              tmp___15 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1586
              tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1586
              tmp___15 = tmp___18;
            }
          } else {
#line 1586
            tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1586
            tmp___15 = tmp___18;
          }
#line 1586
          if (tmp___15 == 0) {
#line 1587
            success = session_x11_req(s);
          } else {
#line 1588
            if (0) {
#line 1588
              __s1_len = strlen((char const   *)rtype);
#line 1588
              __s2_len = strlen("subsystem");
#line 1588
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___0;
              } else {
#line 1588
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 1588
                  if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1588
                    tmp___9 = 1;
                  } else {
#line 1588
                    if (__s2_len >= 4U) {
#line 1588
                      tmp___9 = 1;
                    } else {
#line 1588
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 1588
                  tmp___9 = 0;
                }
              }
#line 1588
              if (tmp___9) {
#line 1588
                tmp___5 = __builtin_strcmp((char const   *)rtype, "subsystem");
              } else {
#line 1588
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1588
                tmp___5 = tmp___8;
              }
            } else {
#line 1588
              tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1588
              tmp___5 = tmp___8;
            }
#line 1588
            if (tmp___5 == 0) {
#line 1589
              success = session_subsystem_req(s);
            }
          }
        }
      }
    }
  }
#line 1592
  if (0) {
#line 1592
    __s1_len___4 = strlen((char const   *)rtype);
#line 1592
    __s2_len___4 = strlen("window-change");
#line 1592
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___10;
    } else {
#line 1592
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 1592
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1592
          tmp___59 = 1;
        } else {
#line 1592
          if (__s2_len___4 >= 4U) {
#line 1592
            tmp___59 = 1;
          } else {
#line 1592
            tmp___59 = 0;
          }
        }
      } else {
#line 1592
        tmp___59 = 0;
      }
    }
#line 1592
    if (tmp___59) {
#line 1592
      tmp___55 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1592
      tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1592
      tmp___55 = tmp___58;
    }
  } else {
#line 1592
    tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1592
    tmp___55 = tmp___58;
  }
#line 1592
  if (tmp___55 == 0) {
#line 1593
    success = session_window_change_req(s);
  }
#line 1596
  if (reply) {
#line 1597
    if (success) {
#line 1597
      tmp___60 = 99;
    } else {
#line 1597
      tmp___60 = 100;
    }
#line 1597
    packet_start(tmp___60);
#line 1599
    packet_put_int((unsigned int )c->remote_id);
#line 1600
    packet_send();
  }
#line 1602
  xfree((void *)rtype);
#line 1603
  return;
}
}
#line 1605 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1608
  if (! compat20) {
#line 1609
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1614
  if (s->chanid == -1) {
#line 1615
    fatal("no channel for session %d", s->self);
  }
#line 1616
  if (fderr___0 == -1) {
#line 1616
    tmp = 0;
  } else {
#line 1616
    tmp = 1;
  }
#line 1616
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp);
#line 1619
  return;
}
}
#line 1621 "session.c"
void session_pty_cleanup(Session *s ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1624
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1625
    return;
  } else {
#line 1624
    if (s->ttyfd == -1) {
#line 1625
      return;
    }
  }
#line 1627
  debug("session_pty_cleanup: session %i release %s", s->self, s->tty);
#line 1630
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)s);
#line 1633
  record_logout(s->pid, (char const   *)(s->tty));
#line 1636
  pty_release((char const   *)(s->tty));
#line 1643
  tmp___1 = close(s->ptymaster);
#line 1643
  if (tmp___1 < 0) {
#line 1644
    tmp = __errno_location();
#line 1644
    tmp___0 = strerror(*tmp);
#line 1644
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1645
  return;
}
}
#line 1647 "session.c"
void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_76 __constr_expr_0 ;
  union __anonunion_77___0 __constr_expr_1 ;
  union __anonunion_78___0 __constr_expr_2 ;
  union __anonunion_79___0 __constr_expr_3 ;
  union __anonunion_80___0 __constr_expr_4 ;

  {
#line 1651
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1652
    fatal("session_close: no session");
  }
#line 1653
  c = channel_lookup(s->chanid);
#line 1654
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1655
    fatal("session_close: session %d: no channel %d", s->self, s->chanid);
  }
#line 1657
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1660
  __constr_expr_4.__in = status;
#line 1660
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1661
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1663
    __constr_expr_0.__in = status;
#line 1663
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1664
    packet_send();
  } else {
#line 1665
    __constr_expr_3.__in = status;
#line 1665
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1666
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1668
      __constr_expr_1.__in = status;
#line 1668
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1670
      __constr_expr_2.__in = status;
#line 1670
      packet_put_char(__constr_expr_2.__i & 128);
#line 1674
      packet_put_cstring("");
#line 1675
      packet_put_cstring("");
#line 1676
      packet_send();
    } else {
#line 1679
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1683
  debug("session_exit_message: release channel %d", s->chanid);
#line 1684
  channel_cancel_cleanup(s->chanid);
#line 1691
  if (c->ostate != 128) {
#line 1692
    (*chan_write_failed)(c);
  }
#line 1693
  s->chanid = -1;
#line 1694
  return;
}
}
#line 1696 "session.c"
void session_free(Session *s ) 
{ 

  {
#line 1699
  debug("session_free: session %d pid %d", s->self, s->pid);
#line 1700
  if (s->term) {
#line 1701
    xfree((void *)s->term);
  }
#line 1702
  if (s->display) {
#line 1703
    xfree((void *)s->display);
  }
#line 1704
  if (s->auth_data) {
#line 1705
    xfree((void *)s->auth_data);
  }
#line 1706
  if (s->auth_proto) {
#line 1707
    xfree((void *)s->auth_proto);
  }
#line 1708
  s->used = 0;
#line 1709
  return;
}
}
#line 1711 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1714
  session_pty_cleanup(s);
#line 1715
  session_free(s);
#line 1716
  session_proctitle(s);
#line 1717
  return;
}
}
#line 1719 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1722
  tmp = session_by_pid(pid);
#line 1722
  s = tmp;
#line 1723
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1724
    debug("session_close_by_pid: no session for pid %d", s->pid);
#line 1725
    return;
  }
#line 1727
  if (s->chanid != -1) {
#line 1728
    session_exit_message(s, status);
  }
#line 1729
  session_close(s);
#line 1730
  return;
}
}
#line 1736 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1739
  tmp = session_by_channel(id);
#line 1739
  s = tmp;
#line 1740
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1741
    debug("session_close_by_channel: no session for channel %d", id);
#line 1742
    return;
  }
#line 1745
  channel_cancel_cleanup(s->chanid);
#line 1746
  s->chanid = -1;
#line 1748
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 1749
  if (s->pid == 0) {
#line 1751
    session_close(s);
  } else {
#line 1754
    if (s->pid <= 1) {
#line 1755
      fatal("session_close_by_channel: Unsafe s->pid = %d", s->pid);
    }
#line 1756
    if (s->ttyfd == -1) {
#line 1756
      tmp___2 = 15;
    } else {
#line 1756
      tmp___2 = 1;
    }
#line 1756
    tmp___3 = kill(s->pid, tmp___2);
#line 1756
    if (tmp___3 < 0) {
#line 1757
      tmp___0 = __errno_location();
#line 1757
      tmp___1 = strerror(*tmp___0);
#line 1757
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 1760
  return;
}
}
#line 1765 "session.c"
static char buf___0[1024]  ;
#line 1762 "session.c"
char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1767
  buf___0[0] = (char )'\000';
#line 1768
  i = 0;
#line 1768
  while (i < 10) {
#line 1769
    s = & sessions[i];
#line 1770
    if (s->used) {
#line 1770
      if (s->ttyfd != -1) {
#line 1771
        if ((int )buf___0[0] != 0) {
#line 1772
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 1773
        tmp = strrchr((char const   *)(s->tty), '/');
#line 1773
        strlcat(buf___0, (char const   *)(tmp + 1), sizeof(buf___0));
      }
    }
#line 1768
    i ++;
  }
#line 1776
  if ((int )buf___0[0] == 0) {
#line 1777
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 1778
  return (buf___0);
}
}
#line 1781 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 1784
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1785
    error("no user for session %d", s->self);
  } else {
#line 1787
    tmp = session_tty_list();
#line 1787
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 1788
  return;
}
}
#line 1790 "session.c"
void do_authenticated2(void) 
{ 

  {
#line 1797
  alarm(0U);
#line 1798
  if (startup_pipe != -1) {
#line 1799
    close(startup_pipe);
#line 1800
    startup_pipe = -1;
  }
#line 1802
  server_loop2();
#line 1803
  if (xauthfile) {
#line 1804
    xauthfile_cleanup_proc((void *)0);
  }
#line 1805
  return;
}
}
