/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_74 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 34 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer packet ;
   Buffer identities ;
   int howmany ;
};
#line 34 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_64 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_64 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 41 "cipher.h"
struct __anonstruct_des3_69 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 41 "cipher.h"
struct __anonstruct_bf_70 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 41 "cipher.h"
union __anonunion_u_68 {
   struct __anonstruct_des3_69 des3 ;
   struct __anonstruct_bf_70 bf ;
};
#line 41 "cipher.h"
struct __anonstruct_CipherContext_67 {
   unsigned int type ;
   union __anonunion_u_68 u ;
};
#line 41 "cipher.h"
typedef struct __anonstruct_CipherContext_67 CipherContext;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 461 "ssh.h"
enum __anonenum_SyslogFacility_72 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 461 "ssh.h"
typedef enum __anonenum_SyslogFacility_72 SyslogFacility;
#line 475
enum __anonenum_LogLevel_73 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG = 5
} ;
#line 475 "ssh.h"
typedef enum __anonenum_LogLevel_73 LogLevel;
#line 26 "servconf.h"
struct __anonstruct_ServerOptions_78 {
   int port ;
   struct in_addr listen_addr ;
   char *host_key_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   int strict_modes ;
   int keepalives ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
};
#line 26 "servconf.h"
typedef struct __anonstruct_ServerOptions_78 ServerOptions;
#line 25 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int sock ;
   Buffer input ;
   Buffer output ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
};
#line 25 "channels.h"
typedef struct Channel Channel;
#line 83 "channels.c"
struct __anonstruct_ForwardPermission_79 {
   char *host ;
   u_short port ;
};
#line 83 "channels.c"
typedef struct __anonstruct_ForwardPermission_79 ForwardPermission;
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 91 "cipher.c"
union __anonunion_t_74 {
   u_int32_t i ;
   char c[4] ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 398 "ssh.h"
enum __anonenum_HostStatus_71 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 398 "ssh.h"
typedef enum __anonenum_HostStatus_71 HostStatus;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 59 "helper.c"
struct __anonstruct_rc4_t_47 {
   unsigned int s[256] ;
   int i ;
   int j ;
};
#line 59 "helper.c"
typedef struct __anonstruct_rc4_t_47 rc4_t;
#line 69 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 132 "log.c"
struct __anonstruct_log_facilities_74 {
   char const   *name ;
   SyslogFacility val ;
};
#line 150 "log.c"
struct __anonstruct_log_levels_75 {
   char const   *name ;
   LogLevel val ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 37 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 40 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 701 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 105 "sshd.c"
struct __anonstruct_sensitive_data_76 {
   RSA *private_key ;
   RSA *host_key ;
};
#line 151
struct pam_handle_t;
#line 2069 "sshd.c"
struct pty_cleanup_context {
   char const   *ttyname ;
   int pid ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 43 "/usr/include/bits/utmpx.h"
struct __exit_status {
   short __e_termination ;
   short __e_exit ;
};
#line 56 "/usr/include/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 251 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 146 "servconf.c"
enum __anonenum_ServerOpCodes_75 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27,
    sIgnoreUserKnownHosts = 28
} ;
#line 146 "servconf.c"
typedef enum __anonenum_ServerOpCodes_75 ServerOpCodes;
#line 168 "servconf.c"
struct __anonstruct_keywords_76 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_40 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_41 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_40 __wait_terminated ;
   struct __anonstruct___wait_stopped_41 __wait_stopped ;
};
#line 56 "serverloop.c"
union __anonunion_76 {
   int volatile   __in ;
   int __i ;
};
#line 56 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 621 "serverloop.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 623 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 619 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 645 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 644 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 1 "atomicio.o"
#pragma merger(0,"./atomicio.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 709 "ssh.h"
int atomicio(int (*f)() , int fd , void *s , size_t n___0 ) ;
#line 35 "atomicio.c"
int atomicio(int (*f)() , int fd , void *s , size_t n___0 ) 
{ int res ;
  int pos ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 42
  pos = 0;
#line 44
  while (n___0 > (size_t )pos) {
#line 45
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 46
    switch (res) {
    case -1: 
#line 48
    tmp = __errno_location();
#line 48
    if (*tmp == 4) {
#line 49
      continue;
    } else {
#line 48
      tmp___0 = __errno_location();
#line 48
      if (*tmp___0 == 11) {
#line 49
        continue;
      }
    }
    case 0: 
#line 51
    return (res);
    default: 
#line 53
    pos += res;
    }
  }
#line 56
  return (pos);
}
}
#line 1 "authfd.o"
#pragma merger(0,"./authfd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 7 "bsd-strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 494 "ssh.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 495
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 496
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 28 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 31
void buffer_free(Buffer *buffer ) ;
#line 35
void buffer_clear(Buffer *buffer ) ;
#line 38
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 51
void buffer_get(Buffer *buffer , char *buf , unsigned int len ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 41 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 48
void ssh_close_authentication_socket(int sock ) ;
#line 56
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 62
void ssh_close_authentication_connection(AuthenticationConnection *ac ) ;
#line 70
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) ;
#line 80
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) ;
#line 86
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) ;
#line 98
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) ;
#line 107
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) ;
#line 114
int ssh_remove_all_identities(AuthenticationConnection *auth ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 28
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 31
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 34
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 37
int buffer_get_char(Buffer *buffer ) ;
#line 40
void buffer_put_char(Buffer *buffer , int value ) ;
#line 50
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 53
void buffer_put_string(Buffer *buffer , void const   *buf , unsigned int len ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 36 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 43
  tmp = getenv("SSH_AUTH_SOCK");
#line 43
  authsocket = (char const   *)tmp;
#line 44
  if (! authsocket) {
#line 45
    return (-1);
  }
#line 47
  sunaddr.sun_family = (unsigned short)1;
#line 48
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 50
  sock = socket(1, 1, 0);
#line 51
  if (sock < 0) {
#line 52
    return (-1);
  }
#line 55
  tmp___0 = fcntl(sock, 2, 1);
#line 55
  if (tmp___0 == -1) {
#line 56
    close(sock);
#line 57
    return (-1);
  }
#line 59
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 59
  if (tmp___1 < 0) {
#line 60
    close(sock);
#line 61
    return (-1);
  }
#line 63
  return (sock);
}
}
#line 72 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 75
  tmp = getenv("SSH_AUTH_SOCK");
#line 75
  if (tmp) {
#line 76
    close(sock);
  }
#line 77
  return;
}
}
#line 87 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 93
  sock = ssh_get_authentication_socket();
#line 99
  if (sock < 0) {
#line 100
    return ((AuthenticationConnection *)((void *)0));
  }
#line 102
  tmp = xmalloc(sizeof(*auth));
#line 102
  auth = (AuthenticationConnection *)tmp;
#line 103
  auth->fd = sock;
#line 104
  buffer_init(& auth->packet);
#line 105
  buffer_init(& auth->identities);
#line 106
  auth->howmany = 0;
#line 108
  return (auth);
}
}
#line 116 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *ac ) 
{ 

  {
#line 119
  buffer_free(& ac->packet);
#line 120
  buffer_free(& ac->identities);
#line 121
  close(ac->fd);
#line 122
  xfree((void *)ac);
#line 123
  return;
}
}
#line 132 "authfd.c"
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) 
{ unsigned char msg[8192] ;
  int len ;
  int l ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 143
  msg[0] = (unsigned char)0;
#line 144
  msg[1] = (unsigned char)0;
#line 145
  msg[2] = (unsigned char)0;
#line 146
  msg[3] = (unsigned char)1;
#line 147
  msg[4] = (unsigned char)1;
#line 148
  tmp___1 = atomicio((int (*)())(& write), auth->fd, (void *)(msg), 5U);
#line 148
  if (tmp___1 != 5) {
#line 149
    tmp = __errno_location();
#line 149
    tmp___0 = strerror(*tmp);
#line 149
    error("write auth->fd: %.100s", tmp___0);
#line 150
    return (0);
  }
#line 153
  len = 4;
#line 154
  while (len > 0) {
#line 155
    l = read(auth->fd, (void *)((msg + 4) - len), (unsigned int )len);
#line 156
    if (l <= 0) {
#line 157
      tmp___2 = __errno_location();
#line 157
      tmp___3 = strerror(*tmp___2);
#line 157
      error("read auth->fd: %.100s", tmp___3);
#line 158
      return (0);
    }
#line 160
    len -= l;
  }
#line 167
  len = (int )(((((unsigned long )msg[0] << 24) | ((unsigned long )msg[1] << 16)) | ((unsigned long )msg[2] << 8)) | (unsigned long )msg[3]);
#line 168
  if (len < 1) {
#line 169
    fatal("Authentication reply message too long: %d\n", len);
  } else {
#line 168
    if (len > 262144) {
#line 169
      fatal("Authentication reply message too long: %d\n", len);
    }
  }
#line 172
  buffer_clear(& auth->identities);
#line 173
  while (len > 0) {
#line 174
    l = len;
#line 175
    if ((unsigned int )l > sizeof(msg)) {
#line 176
      l = (int )sizeof(msg);
    }
#line 177
    l = read(auth->fd, (void *)(msg), (unsigned int )l);
#line 178
    if (l <= 0) {
#line 179
      fatal("Incomplete authentication reply.");
    }
#line 180
    buffer_append(& auth->identities, (char const   *)((char *)(msg)), (unsigned int )l);
#line 181
    len -= l;
  }
#line 185
  buffer_get(& auth->identities, (char *)(msg), 1U);
#line 186
  if ((int )msg[0] != 2) {
#line 187
    fatal("Bad authentication reply message type: %d", msg[0]);
  }
#line 190
  tmp___4 = buffer_get_int(& auth->identities);
#line 190
  auth->howmany = (int )tmp___4;
#line 191
  if (auth->howmany > 1024) {
#line 192
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 195
  tmp___5 = ssh_get_next_identity(auth, e, n___0, comment);
#line 195
  return (tmp___5);
}
}
#line 205 "authfd.c"
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) 
{ unsigned int bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 212
  if (auth->howmany <= 0) {
#line 213
    return (0);
  }
#line 219
  bits = buffer_get_int(& auth->identities);
#line 220
  buffer_get_bignum(& auth->identities, e);
#line 221
  buffer_get_bignum(& auth->identities, n___0);
#line 222
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 224
  tmp___0 = BN_num_bits((BIGNUM const   *)n___0);
#line 224
  if (bits != (unsigned int )tmp___0) {
#line 225
    tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 225
    error("Warning: keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 229
  (auth->howmany) --;
#line 231
  return (1);
}
}
#line 242 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 254
  if (response_type == 0U) {
#line 255
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
  }
#line 258
  buf[0] = (unsigned char)3;
#line 259
  buffer_init(& buffer);
#line 260
  buffer_append(& buffer, (char const   *)((char *)(buf)), 1U);
#line 261
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 261
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 262
  buffer_put_bignum(& buffer, e);
#line 263
  buffer_put_bignum(& buffer, n___0);
#line 264
  buffer_put_bignum(& buffer, challenge);
#line 265
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 266
  buffer_put_int(& buffer, response_type);
#line 269
  tmp___0 = buffer_len(& buffer);
#line 269
  len = (int )tmp___0;
#line 270
  while (1) {
#line 270
    buf[0] = (unsigned char )(len >> 24);
#line 270
    buf[1] = (unsigned char )(len >> 16);
#line 270
    buf[2] = (unsigned char )(len >> 8);
#line 270
    buf[3] = (unsigned char )len;
#line 270
    break;
  }
#line 273
  tmp___1 = atomicio((int (*)())(& write), auth->fd, (void *)(buf), 4U);
#line 273
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 273
    tmp___2 = buffer_len(& buffer);
#line 273
    tmp___3 = buffer_ptr(& buffer);
#line 273
    tmp___4 = atomicio((int (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 273
    tmp___5 = buffer_len(& buffer);
#line 273
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 276
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 278
      buffer_free(& buffer);
#line 279
      return (0);
    }
  }
#line 285
  len = 4;
#line 286
  while (len > 0) {
#line 287
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 288
    if (l <= 0) {
#line 289
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 292
    len -= l;
  }
#line 296
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 297
  if (len > 262144) {
#line 298
    fatal("Authentication response too long: %d", len);
  }
#line 301
  buffer_clear(& buffer);
#line 302
  while (len > 0) {
#line 303
    l = len;
#line 304
    if ((unsigned int )l > sizeof(buf)) {
#line 305
      l = (int )sizeof(buf);
    }
#line 306
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 307
    if (l <= 0) {
#line 308
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 311
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 312
    len -= l;
  }
#line 316
  buffer_get(& buffer, (char *)(buf), 1U);
#line 319
  if ((int )buf[0] == 5) {
#line 320
    log("Agent admitted failure to authenticate using the key.");
    goto error_cleanup;
  }
#line 324
  if ((int )buf[0] != 4) {
#line 325
    fatal("Bad authentication response: %d", buf[0]);
  }
#line 331
  i = 0;
#line 331
  while (i < 16) {
#line 332
    tmp___6 = buffer_get_char(& buffer);
#line 332
    *(response + i) = (unsigned char )tmp___6;
#line 331
    i ++;
  }
#line 335
  buffer_free(& buffer);
#line 338
  return (1);
}
}
#line 346 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 355
  buffer_init(& buffer);
#line 356
  buffer_put_char(& buffer, 7);
#line 357
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 357
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 358
  buffer_put_bignum(& buffer, key->n);
#line 359
  buffer_put_bignum(& buffer, key->e);
#line 360
  buffer_put_bignum(& buffer, key->d);
#line 362
  buffer_put_bignum(& buffer, key->iqmp);
#line 363
  buffer_put_bignum(& buffer, key->q);
#line 364
  buffer_put_bignum(& buffer, key->p);
#line 365
  tmp___0 = strlen(comment);
#line 365
  buffer_put_string(& buffer, (void const   *)comment, tmp___0);
#line 368
  tmp___1 = buffer_len(& buffer);
#line 368
  len = (int )tmp___1;
#line 369
  while (1) {
#line 369
    buf[0] = (unsigned char )(len >> 24);
#line 369
    buf[1] = (unsigned char )(len >> 16);
#line 369
    buf[2] = (unsigned char )(len >> 8);
#line 369
    buf[3] = (unsigned char )len;
#line 369
    break;
  }
#line 372
  tmp___2 = atomicio((int (*)())(& write), auth->fd, (void *)(buf), 4U);
#line 372
  if (tmp___2 != 4) {
    goto _L;
  } else {
#line 372
    tmp___3 = buffer_len(& buffer);
#line 372
    tmp___4 = buffer_ptr(& buffer);
#line 372
    tmp___5 = atomicio((int (*)())(& write), auth->fd, (void *)tmp___4, tmp___3);
#line 372
    tmp___6 = buffer_len(& buffer);
#line 372
    if ((unsigned int )tmp___5 != tmp___6) {
      _L: /* CIL Label */ 
#line 375
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 377
      buffer_free(& buffer);
#line 378
      return (0);
    }
  }
#line 382
  len = 4;
#line 383
  while (len > 0) {
#line 384
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 385
    if (l <= 0) {
#line 386
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 389
    len -= l;
  }
#line 393
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 394
  if (len > 262144) {
#line 395
    fatal("Add identity response too long: %d", len);
  }
#line 398
  buffer_clear(& buffer);
#line 399
  while (len > 0) {
#line 400
    l = len;
#line 401
    if ((unsigned int )l > sizeof(buf)) {
#line 402
      l = (int )sizeof(buf);
    }
#line 403
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 404
    if (l <= 0) {
#line 405
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 408
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 409
    len -= l;
  }
#line 413
  type = buffer_get_char(& buffer);
#line 414
  switch (type) {
  case 5: 
#line 416
  buffer_free(& buffer);
#line 417
  return (0);
  case 6: 
#line 419
  buffer_free(& buffer);
#line 420
  return (1);
  default: 
#line 422
  fatal("Bad response to add identity from authentication agent: %d", type);
  }
#line 426
  return (0);
}
}
#line 434 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 442
  buffer_init(& buffer);
#line 443
  buffer_put_char(& buffer, 8);
#line 444
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 444
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 445
  buffer_put_bignum(& buffer, key->e);
#line 446
  buffer_put_bignum(& buffer, key->n);
#line 449
  tmp___0 = buffer_len(& buffer);
#line 449
  len = (int )tmp___0;
#line 450
  while (1) {
#line 450
    buf[0] = (unsigned char )(len >> 24);
#line 450
    buf[1] = (unsigned char )(len >> 16);
#line 450
    buf[2] = (unsigned char )(len >> 8);
#line 450
    buf[3] = (unsigned char )len;
#line 450
    break;
  }
#line 453
  tmp___1 = atomicio((int (*)())(& write), auth->fd, (void *)(buf), 4U);
#line 453
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 453
    tmp___2 = buffer_len(& buffer);
#line 453
    tmp___3 = buffer_ptr(& buffer);
#line 453
    tmp___4 = atomicio((int (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 453
    tmp___5 = buffer_len(& buffer);
#line 453
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 456
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 458
      buffer_free(& buffer);
#line 459
      return (0);
    }
  }
#line 465
  len = 4;
#line 466
  while (len > 0) {
#line 467
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 468
    if (l <= 0) {
#line 469
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 472
    len -= l;
  }
#line 476
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 477
  if (len > 262144) {
#line 478
    fatal("Remove identity response too long: %d", len);
  }
#line 481
  buffer_clear(& buffer);
#line 482
  while (len > 0) {
#line 483
    l = len;
#line 484
    if ((unsigned int )l > sizeof(buf)) {
#line 485
      l = (int )sizeof(buf);
    }
#line 486
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 487
    if (l <= 0) {
#line 488
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 491
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 492
    len -= l;
  }
#line 496
  type = buffer_get_char(& buffer);
#line 497
  switch (type) {
  case 5: 
#line 499
  buffer_free(& buffer);
#line 500
  return (0);
  case 6: 
#line 502
  buffer_free(& buffer);
#line 503
  return (1);
  default: 
#line 505
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 509
  return (0);
}
}
#line 517 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth ) 
{ Buffer buffer ;
  unsigned char buf[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;

  {
#line 525
  while (1) {
#line 525
    buf[0] = (unsigned char )(1 >> 24);
#line 525
    buf[1] = (unsigned char )(1 >> 16);
#line 525
    buf[2] = (unsigned char )(1 >> 8);
#line 525
    buf[3] = (unsigned char)1;
#line 525
    break;
  }
#line 526
  buf[4] = (unsigned char)9;
#line 529
  tmp = atomicio((int (*)())(& write), auth->fd, (void *)(buf), 5U);
#line 529
  if (tmp != 5) {
#line 530
    error("Error writing to authentication socket.");
#line 531
    return (0);
  }
#line 537
  len = 4;
#line 538
  while (len > 0) {
#line 539
    l = read(auth->fd, (void *)((buf + 4) - len), (unsigned int )len);
#line 540
    if (l <= 0) {
#line 541
      error("Error reading response length from authentication socket.");
#line 542
      return (0);
    }
#line 544
    len -= l;
  }
#line 548
  len = (int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]);
#line 549
  if (len > 262144) {
#line 550
    fatal("Remove identity response too long: %d", len);
  }
#line 553
  buffer_init(& buffer);
#line 554
  while (len > 0) {
#line 555
    l = len;
#line 556
    if ((unsigned int )l > sizeof(buf)) {
#line 557
      l = (int )sizeof(buf);
    }
#line 558
    l = read(auth->fd, (void *)(buf), (unsigned int )l);
#line 559
    if (l <= 0) {
#line 560
      error("Error reading response from authentication socket.");
#line 561
      buffer_free(& buffer);
#line 562
      return (0);
    }
#line 564
    buffer_append(& buffer, (char const   *)((char *)(buf)), (unsigned int )l);
#line 565
    len -= l;
  }
#line 569
  type = buffer_get_char(& buffer);
#line 570
  switch (type) {
  case 5: 
#line 572
  buffer_free(& buffer);
#line 573
  return (0);
  case 6: 
#line 575
  buffer_free(& buffer);
#line 576
  return (1);
  default: 
#line 578
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 582
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#pragma merger(0,"./authfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 42 "helper.h"
unsigned int arc4random(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 62 "cipher.h"
unsigned int cipher_mask(void) ;
#line 65
char const   *cipher_name(int cipher ) ;
#line 85
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) ;
#line 90
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 95
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 433 "ssh.h"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) ;
#line 443
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) ;
#line 454
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) ;
#line 498
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 43 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 58
  if (0) {
#line 58
    __s1_len = strlen(passphrase);
#line 58
    __s2_len = strlen("");
#line 58
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 58
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 58
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 58
          tmp___8 = 1;
        } else {
#line 58
          if (__s2_len >= 4U) {
#line 58
            tmp___8 = 1;
          } else {
#line 58
            tmp___8 = 0;
          }
        }
      } else {
#line 58
        tmp___8 = 0;
      }
    }
#line 58
    if (tmp___8) {
#line 58
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 58
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
      tmp___4 = tmp___7;
    }
  } else {
#line 58
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
    tmp___4 = tmp___7;
  }
#line 58
  if (tmp___4 == 0) {
#line 59
    cipher_type___0 = 0;
  } else {
#line 61
    cipher_type___0 = 3;
  }
#line 64
  buffer_init(& buffer);
#line 67
  rand___0 = arc4random();
#line 68
  buf[0] = (char )(rand___0 & 255U);
#line 69
  buf[1] = (char )((rand___0 >> 8) & 255U);
#line 70
  buf[2] = buf[0];
#line 71
  buf[3] = buf[1];
#line 72
  buffer_append(& buffer, (char const   *)(buf), 4U);
#line 79
  buffer_put_bignum(& buffer, key->d);
#line 80
  buffer_put_bignum(& buffer, key->iqmp);
#line 81
  buffer_put_bignum(& buffer, key->q);
#line 82
  buffer_put_bignum(& buffer, key->p);
#line 85
  while (1) {
#line 85
    tmp___9 = buffer_len(& buffer);
#line 85
    if (! (tmp___9 % 8U != 0U)) {
#line 85
      break;
    }
#line 86
    buffer_put_char(& buffer, 0);
  }
#line 89
  buffer_init(& encrypted);
#line 92
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 93
  i = 0;
#line 93
  while (*(cp + i)) {
#line 94
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 93
    i ++;
  }
#line 95
  buffer_put_char(& encrypted, 0);
#line 98
  buffer_put_char(& encrypted, cipher_type___0);
#line 99
  buffer_put_int(& encrypted, 0U);
#line 102
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 102
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 103
  buffer_put_bignum(& encrypted, key->n);
#line 104
  buffer_put_bignum(& encrypted, key->e);
#line 105
  tmp___11 = strlen(comment);
#line 105
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 108
  tmp___12 = buffer_len(& buffer);
#line 108
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 110
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 1);
#line 111
  tmp___13 = buffer_len(& buffer);
#line 111
  tmp___14 = buffer_ptr(& buffer);
#line 111
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 114
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 117
  memset((void *)(buf), 0, sizeof(buf));
#line 118
  buffer_free(& buffer);
#line 120
  fd = open(filename, 577, 384);
#line 121
  if (fd < 0) {
#line 122
    return (0);
  }
#line 123
  tmp___17 = buffer_len(& encrypted);
#line 123
  tmp___18 = buffer_ptr(& encrypted);
#line 123
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 123
  tmp___20 = buffer_len(& encrypted);
#line 123
  if ((unsigned int )tmp___19 != tmp___20) {
#line 125
    tmp___15 = __errno_location();
#line 125
    tmp___16 = strerror(*tmp___15);
#line 125
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 127
    buffer_free(& encrypted);
#line 128
    close(fd);
#line 129
    remove(filename);
#line 130
    return (0);
  }
#line 132
  close(fd);
#line 133
  buffer_free(& encrypted);
#line 134
  return (1);
}
}
#line 143 "authfile.c"
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 152
  fd = open(filename, 0);
#line 153
  if (fd < 0) {
#line 154
    return (0);
  }
#line 155
  len = lseek(fd, 0L, 2);
#line 156
  lseek(fd, 0L, 0);
#line 158
  buffer_init(& buffer);
#line 159
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 161
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 161
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 162
    tmp = __errno_location();
#line 162
    tmp___0 = strerror(*tmp);
#line 162
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 164
    buffer_free(& buffer);
#line 165
    close(fd);
#line 166
    return (0);
  }
#line 168
  close(fd);
#line 171
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 171
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 172
    debug("Bad key file %.200s.", filename);
#line 173
    buffer_free(& buffer);
#line 174
    return (0);
  }
#line 180
  i = 0;
#line 180
  while (1) {
#line 180
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 180
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 180
      break;
    }
#line 181
    tmp___3 = buffer_get_char(& buffer);
#line 181
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 182
      debug("Bad key file %.200s.", filename);
#line 183
      buffer_free(& buffer);
#line 184
      return (0);
    }
#line 180
    i ++;
  }
#line 187
  buffer_get_char(& buffer);
#line 188
  buffer_get_int(& buffer);
#line 191
  buffer_get_int(& buffer);
#line 192
  pub->n = BN_new();
#line 193
  buffer_get_bignum(& buffer, pub->n);
#line 194
  pub->e = BN_new();
#line 195
  buffer_get_bignum(& buffer, pub->e);
#line 196
  if (comment_return) {
#line 197
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 200
  buffer_free(& buffer);
#line 202
  return (1);
}
}
#line 212 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) 
{ int fd ;
  int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  char *tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  BIGNUM const   *tmp___25 ;
  BIGNUM const   *tmp___26 ;

  {
#line 225
  fd = open(filename, 0);
#line 226
  if (fd < 0) {
#line 227
    return (0);
  }
#line 230
  tmp = fstat(fd, & st);
#line 230
  if (tmp < 0) {
    goto _L;
  } else {
#line 230
    if (st.st_uid != 0U) {
#line 230
      tmp___0 = getuid();
#line 230
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 230
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 233
        close(fd);
#line 234
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 235
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 236
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 237
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 239
        error("It is recommended that your private key files are NOT accessible by others.");
#line 240
        return (0);
      }
    }
  }
#line 242
  len = lseek(fd, 0L, 2);
#line 243
  lseek(fd, 0L, 0);
#line 245
  buffer_init(& buffer);
#line 246
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 248
  tmp___3 = read(fd, (void *)cp, (unsigned int )len);
#line 248
  if ((unsigned int )tmp___3 != (unsigned int )len) {
#line 249
    tmp___1 = __errno_location();
#line 249
    tmp___2 = strerror(*tmp___1);
#line 249
    debug("Read from key file %.200s failed: %.100s", filename, tmp___2);
#line 251
    buffer_free(& buffer);
#line 252
    close(fd);
#line 253
    return (0);
  }
#line 255
  close(fd);
#line 258
  tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 258
  if ((unsigned long )len < (unsigned long )(tmp___4 + 1U)) {
#line 259
    debug("Bad key file %.200s.", filename);
#line 260
    buffer_free(& buffer);
#line 261
    return (0);
  }
#line 267
  i = 0;
#line 267
  while (1) {
#line 267
    tmp___6 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 267
    if (! ((unsigned int )i < tmp___6 + 1U)) {
#line 267
      break;
    }
#line 268
    tmp___5 = buffer_get_char(& buffer);
#line 268
    if (tmp___5 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 269
      debug("Bad key file %.200s.", filename);
#line 270
      buffer_free(& buffer);
#line 271
      return (0);
    }
#line 267
    i ++;
  }
#line 274
  cipher_type___0 = buffer_get_char(& buffer);
#line 275
  buffer_get_int(& buffer);
#line 278
  buffer_get_int(& buffer);
#line 279
  prv->n = BN_new();
#line 280
  buffer_get_bignum(& buffer, prv->n);
#line 281
  prv->e = BN_new();
#line 282
  buffer_get_bignum(& buffer, prv->e);
#line 283
  if (comment_return) {
#line 284
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 286
    tmp___7 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 286
    xfree((void *)tmp___7);
  }
#line 289
  tmp___9 = cipher_mask();
#line 289
  if (((tmp___9 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 291
    tmp___8 = cipher_name(cipher_type___0);
#line 291
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___8, filename);
#line 293
    buffer_free(& buffer);
    goto fail;
  }
#line 297
  buffer_init(& decrypted);
#line 298
  tmp___10 = buffer_len(& buffer);
#line 298
  buffer_append_space(& decrypted, & cp, tmp___10);
#line 301
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 0);
#line 302
  tmp___11 = buffer_len(& buffer);
#line 302
  tmp___12 = buffer_ptr(& buffer);
#line 302
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___12),
                 tmp___11);
#line 306
  buffer_free(& buffer);
#line 308
  check1 = buffer_get_char(& decrypted);
#line 309
  check2 = buffer_get_char(& decrypted);
#line 310
  tmp___23 = buffer_get_char(& decrypted);
#line 310
  if (check1 != tmp___23) {
    goto _L___3;
  } else {
#line 310
    tmp___24 = buffer_get_char(& decrypted);
#line 310
    if (check2 != tmp___24) {
      _L___3: /* CIL Label */ 
#line 312
      if (0) {
#line 312
        __s1_len = strlen(passphrase);
#line 312
        __s2_len = strlen("");
#line 312
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___2;
        } else {
#line 312
          if (__s1_len >= 4U) {
            _L___2: /* CIL Label */ 
#line 312
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 312
              tmp___22 = 1;
            } else {
#line 312
              if (__s2_len >= 4U) {
#line 312
                tmp___22 = 1;
              } else {
#line 312
                tmp___22 = 0;
              }
            }
          } else {
#line 312
            tmp___22 = 0;
          }
        }
#line 312
        if (tmp___22) {
#line 312
          tmp___18 = __builtin_strcmp(passphrase, "");
        } else {
#line 312
          tmp___21 = __builtin_strcmp(passphrase, "");
#line 312
          tmp___18 = tmp___21;
        }
      } else {
#line 312
        tmp___21 = __builtin_strcmp(passphrase, "");
#line 312
        tmp___18 = tmp___21;
      }
#line 312
      if (tmp___18 != 0) {
#line 313
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 315
      buffer_free(& decrypted);
      fail: 
#line 317
      BN_clear_free(prv->n);
#line 318
      BN_clear_free(prv->e);
#line 319
      if (comment_return) {
#line 320
        xfree((void *)*comment_return);
      }
#line 321
      return (0);
    }
  }
#line 324
  prv->d = BN_new();
#line 325
  buffer_get_bignum(& decrypted, prv->d);
#line 326
  prv->iqmp = BN_new();
#line 327
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 329
  prv->q = BN_new();
#line 330
  buffer_get_bignum(& decrypted, prv->q);
#line 331
  prv->p = BN_new();
#line 332
  buffer_get_bignum(& decrypted, prv->p);
#line 334
  ctx = BN_CTX_new();
#line 335
  aux = BN_new();
#line 337
  tmp___25 = BN_value_one();
#line 337
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___25);
#line 338
  prv->dmq1 = BN_new();
#line 339
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 341
  tmp___26 = BN_value_one();
#line 341
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___26);
#line 342
  prv->dmp1 = BN_new();
#line 343
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 345
  BN_clear_free(aux);
#line 346
  BN_CTX_free(ctx);
#line 348
  buffer_free(& decrypted);
#line 350
  return (1);
}
}
#line 1 "bufaux.o"
#pragma merger(0,"./bufaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 54 "buffer.h"
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 37 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  char *buf ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 40
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 40
  bits = tmp;
#line 41
  bin_size = (bits + 7) / 8;
#line 42
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 42
  buf = (char *)tmp___0;
#line 47
  oi = BN_bn2bin((BIGNUM const   *)value, (unsigned char *)buf);
#line 48
  if (oi != bin_size) {
#line 49
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 53
  while (1) {
#line 53
    msg[0] = (char )(bits >> 8);
#line 53
    msg[1] = (char )bits;
#line 53
    break;
  }
#line 54
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 56
  buffer_append(buffer, (char const   *)buf, (unsigned int )oi);
#line 58
  memset((void *)buf, 0, (unsigned int )bin_size);
#line 59
  xfree((void *)buf);
#line 60
  return;
}
}
#line 65 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf[2] ;
  unsigned char *bin ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 72
  buffer_get(buffer, (char *)(buf), 2U);
#line 73
  bits = (int )(((unsigned long )buf[0] << 8) | (unsigned long )buf[1]);
#line 75
  bytes = (bits + 7) / 8;
#line 76
  tmp = buffer_len(buffer);
#line 76
  if (tmp < (unsigned int )bytes) {
#line 77
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 78
  tmp___0 = buffer_ptr(buffer);
#line 78
  bin = (unsigned char *)tmp___0;
#line 79
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 80
  buffer_consume(buffer, (unsigned int )bytes);
#line 82
  return (2 + bytes);
}
}
#line 88 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf[4] ;

  {
#line 92
  buffer_get(buffer, (char *)(buf), 4U);
#line 93
  return ((unsigned int )(((((unsigned long )buf[0] << 24) | ((unsigned long )buf[1] << 16)) | ((unsigned long )buf[2] << 8)) | (unsigned long )buf[3]));
}
}
#line 99 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf[4] ;

  {
#line 103
  while (1) {
#line 103
    buf[0] = (char )(value >> 24);
#line 103
    buf[1] = (char )(value >> 16);
#line 103
    buf[2] = (char )(value >> 8);
#line 103
    buf[3] = (char )value;
#line 103
    break;
  }
#line 104
  buffer_append(buffer, (char const   *)(buf), 4U);
#line 105
  return;
}
}
#line 115 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 121
  len = buffer_get_int(buffer);
#line 122
  if (len > 262144U) {
#line 123
    fatal("Received packet with bad string length %d", len);
  }
#line 125
  tmp = xmalloc(len + 1U);
#line 125
  value = (char *)tmp;
#line 127
  buffer_get(buffer, value, len);
#line 129
  *(value + len) = (char)0;
#line 131
  if (length_ptr) {
#line 132
    *length_ptr = len;
  }
#line 133
  return (value);
}
}
#line 139 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf , unsigned int len ) 
{ 

  {
#line 142
  buffer_put_int(buffer, len);
#line 143
  buffer_append(buffer, (char const   *)buf, len);
#line 144
  return;
}
}
#line 149 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 153
  buffer_get(buffer, & ch, 1U);
#line 154
  return ((int )((unsigned char )ch));
}
}
#line 160 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 163
  ch = (char )value;
#line 164
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 165
  return;
}
}
#line 1 "buffer.o"
#pragma merger(0,"./buffer.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 57 "buffer.h"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 66
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 28
  buffer->alloc = 4096U;
#line 29
  tmp = xmalloc(buffer->alloc);
#line 29
  buffer->buf = (char *)tmp;
#line 30
  buffer->offset = 0U;
#line 31
  buffer->end = 0U;
#line 32
  return;
}
}
#line 36 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 39
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 40
  xfree((void *)buffer->buf);
#line 41
  return;
}
}
#line 48 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 51
  buffer->offset = 0U;
#line 52
  buffer->end = 0U;
#line 53
  return;
}
}
#line 57 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 61
  buffer_append_space(buffer, & cp, len);
#line 62
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 63
  return;
}
}
#line 71 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 75
  if (buffer->offset == buffer->end) {
#line 76
    buffer->offset = 0U;
#line 77
    buffer->end = 0U;
  }
  restart: 
#line 81
  if (buffer->end + len < buffer->alloc) {
#line 82
    *datap = buffer->buf + buffer->end;
#line 83
    buffer->end += len;
#line 84
    return;
  }
#line 90
  if (buffer->offset > buffer->alloc / 2U) {
#line 91
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 93
    buffer->end -= buffer->offset;
#line 94
    buffer->offset = 0U;
    goto restart;
  }
#line 98
  buffer->alloc += len + 32768U;
#line 99
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 99
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 105 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 108
  return (buffer->end - buffer->offset);
}
}
#line 113 "buffer.c"
void buffer_get(Buffer *buffer , char *buf , unsigned int len ) 
{ 

  {
#line 116
  if (len > buffer->end - buffer->offset) {
#line 117
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 118
  memcpy((void * __restrict  )buf, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 119
  buffer->offset += len;
#line 120
  return;
}
}
#line 124 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 127
  if (bytes > buffer->end - buffer->offset) {
#line 128
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 129
  buffer->offset += bytes;
#line 130
  return;
}
}
#line 134 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 137
  if (bytes > buffer->end - buffer->offset) {
#line 138
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 139
  buffer->end -= bytes;
#line 140
  return;
}
}
#line 144 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 147
  return (buffer->buf + buffer->offset);
}
}
#line 152 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 156
  ucp = (unsigned char *)buffer->buf;
#line 158
  i = (int )buffer->offset;
#line 158
  while ((unsigned int )i < buffer->end) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 158
    i ++;
  }
#line 160
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 161
  return;
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "canohost.o"
#pragma merger(0,"./canohost.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 131 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 138
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 352
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 41 "packet.h"
int packet_get_connection_in(void) ;
#line 44
int packet_get_connection_out(void) ;
#line 154
void packet_disconnect(char const   *fmt  , ...) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 363 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 370
char const   *get_canonical_hostname(void) ;
#line 376
char const   *get_remote_ipaddr(void) ;
#line 379
int get_peer_port(int sock ) ;
#line 382
int get_remote_port(void) ;
#line 501
void fatal_cleanup(void) ;
#line 28 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_in from ;
  int fromlen ;
  int i ;
  struct hostent *hp ;
  char name[64] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  int __res ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  int option_size ;
  int ipproto ;
  struct protoent *ip ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;

  {
#line 37
  fromlen = (int )sizeof(from);
#line 38
  memset((void *)(& from), 0, sizeof(from));
#line 39
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 39
  if (tmp___1 < 0) {
#line 40
    tmp = __errno_location();
#line 40
    tmp___0 = strerror(*tmp);
#line 40
    debug("getpeername failed: %.100s", tmp___0);
#line 41
    fatal_cleanup();
  }
#line 44
  hp = gethostbyaddr((void const   *)((char *)(& from.sin_addr)), sizeof(struct in_addr ),
                     (int )from.sin_family);
#line 46
  if (hp) {
#line 48
    tmp___5 = __builtin_strchr(hp->h_name, '.');
#line 48
    if ((unsigned int )tmp___5 != (unsigned int )((char *)0)) {
#line 49
      strlcpy(name, (char const   *)hp->h_name, sizeof(name));
    } else {
#line 50
      if ((unsigned int )hp->h_aliases != (unsigned int )((char **)0)) {
#line 50
        if ((unsigned int )*(hp->h_aliases + 0) != (unsigned int )((char *)0)) {
#line 50
          tmp___3 = __builtin_strchr(*(hp->h_aliases + 0), '.');
#line 50
          if ((unsigned int )tmp___3 != (unsigned int )((char *)0)) {
#line 53
            strlcpy(name, (char const   *)*(hp->h_aliases + 0), sizeof(name));
          } else {
#line 55
            strlcpy(name, (char const   *)hp->h_name, sizeof(name));
          }
        } else {
#line 55
          strlcpy(name, (char const   *)hp->h_name, sizeof(name));
        }
      } else {
#line 55
        strlcpy(name, (char const   *)hp->h_name, sizeof(name));
      }
    }
#line 61
    i = 0;
#line 61
    while (name[i]) {
#line 62
      tmp___9 = __ctype_b_loc();
#line 62
      if ((int const   )*(*tmp___9 + (int )name[i]) & 256) {
#line 63
        if (sizeof(name[i]) > 1U) {
#line 63
          __res = tolower((int )name[i]);
        } else {
#line 63
          tmp___8 = __ctype_tolower_loc();
#line 63
          __res = (int )*(*tmp___8 + (int )name[i]);
        }
#line 63
        name[i] = (char )__res;
      }
#line 61
      i ++;
    }
#line 74
    hp = gethostbyname((char const   *)(name));
#line 75
    if (! hp) {
#line 76
      log("reverse mapping checking gethostbyname for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 77
      tmp___10 = inet_ntoa(from.sin_addr);
#line 77
      strlcpy(name, (char const   *)tmp___10, sizeof(name));
      goto check_ip_options;
    }
#line 81
    i = 0;
#line 81
    while (*(hp->h_addr_list + i)) {
#line 82
      tmp___11 = memcmp((void const   *)*(hp->h_addr_list + i), (void const   *)(& from.sin_addr),
                        sizeof(from.sin_addr));
#line 82
      if (tmp___11 == 0) {
#line 84
        break;
      }
#line 81
      i ++;
    }
#line 89
    if (! *(hp->h_addr_list + i)) {
#line 91
      tmp___12 = inet_ntoa(from.sin_addr);
#line 91
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          tmp___12, name);
#line 93
      tmp___13 = inet_ntoa(from.sin_addr);
#line 93
      strlcpy(name, (char const   *)tmp___13, sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 99
    tmp___14 = inet_ntoa(from.sin_addr);
#line 99
    strlcpy(name, (char const   *)tmp___14, sizeof(name));
#line 100
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 122
  ip = getprotobyname("ip");
#line 122
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 123
    ipproto = ip->p_proto;
  } else {
#line 125
    ipproto = 0;
  }
#line 126
  option_size = (int )sizeof(options___0);
#line 127
  tmp___17 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                        (socklen_t * __restrict  )(& option_size));
#line 127
  if (tmp___17 >= 0) {
#line 127
    if (option_size != 0) {
#line 129
      cp = text;
#line 131
      ucp = options___0;
#line 131
      while (option_size > 0) {
#line 132
        sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x", *ucp);
#line 131
        ucp ++;
#line 131
        option_size --;
#line 131
        cp += 3;
      }
#line 133
      tmp___15 = inet_ntoa(from.sin_addr);
#line 133
      log("Connection from %.100s with IP options:%.800s", tmp___15, text);
#line 135
      tmp___16 = inet_ntoa(from.sin_addr);
#line 135
      packet_disconnect("Connection from %.100s with IP options:%.800s", tmp___16,
                        text);
    }
  }
#line 140
  tmp___18 = xstrdup((char const   *)(name));
#line 140
  return (tmp___18);
}
}
#line 143 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 144 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 152 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 156
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 157
    return ((char const   *)canonical_host_name);
  }
#line 160
  tmp___0 = packet_get_connection_in();
#line 160
  tmp___1 = packet_get_connection_out();
#line 160
  if (tmp___0 == tmp___1) {
#line 161
    tmp = packet_get_connection_in();
#line 161
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 163
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 165
  return ((char const   *)canonical_host_name);
}
}
#line 173 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_in from ;
  int fromlen ;
  int socket___0 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 180
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 181
    return ((char const   *)canonical_host_ip);
  }
#line 184
  tmp = packet_get_connection_in();
#line 184
  tmp___0 = packet_get_connection_out();
#line 184
  if (tmp != tmp___0) {
#line 185
    canonical_host_ip = xstrdup("UNKNOWN");
#line 186
    return ((char const   *)canonical_host_ip);
  }
#line 189
  socket___0 = packet_get_connection_in();
#line 192
  fromlen = (int )sizeof(from);
#line 193
  memset((void *)(& from), 0, sizeof(from));
#line 194
  tmp___3 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 194
  if (tmp___3 < 0) {
#line 195
    tmp___1 = __errno_location();
#line 195
    tmp___2 = strerror(*tmp___1);
#line 195
    debug("getpeername failed: %.100s", tmp___2);
#line 196
    fatal_cleanup();
  }
#line 199
  tmp___4 = inet_ntoa(from.sin_addr);
#line 199
  canonical_host_ip = xstrdup((char const   *)tmp___4);
#line 202
  return ((char const   *)canonical_host_ip);
}
}
#line 207 "canohost.c"
int get_peer_port(int sock ) 
{ struct sockaddr_in from ;
  int fromlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 214
  fromlen = (int )sizeof(from);
#line 215
  memset((void *)(& from), 0, sizeof(from));
#line 216
  tmp___1 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 216
  if (tmp___1 < 0) {
#line 217
    tmp = __errno_location();
#line 217
    tmp___0 = strerror(*tmp);
#line 217
    debug("getpeername failed: %.100s", tmp___0);
#line 218
    fatal_cleanup();
  }
#line 221
  __x = from.sin_port;
#line 221
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 221
  return ((int )__v);
}
}
#line 226 "canohost.c"
int get_remote_port(void) 
{ int socket___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 235
  tmp = packet_get_connection_in();
#line 235
  tmp___0 = packet_get_connection_out();
#line 235
  if (tmp != tmp___0) {
#line 236
    return (65535);
  }
#line 239
  socket___0 = packet_get_connection_in();
#line 242
  tmp___1 = get_peer_port(socket___0);
#line 242
  return (tmp___1);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#pragma merger(0,"./channels.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 508 "ssh.h"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 516
void channel_set_options(int hostname_in_open ) ;
#line 523
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 526
void channel_free(int channel ) ;
#line 529
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 535
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 538
void channel_output_poll(void) ;
#line 545
void channel_input_data(int payload_len ) ;
#line 548
int channel_not_very_much_buffered_data(void) ;
#line 551
void channel_input_close(void) ;
#line 554
void channel_input_close_confirmation(void) ;
#line 557
void channel_input_open_confirmation(void) ;
#line 560
void channel_input_open_failure(void) ;
#line 564
void channel_stop_listening(void) ;
#line 570
void channel_close_all(void) ;
#line 573
int channel_max_fd(void) ;
#line 576
int channel_still_open(void) ;
#line 583
char *channel_open_message(void) ;
#line 590
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ) ;
#line 600
void channel_request_remote_forwarding(u_short port , char const   *host , u_short remote_port ) ;
#line 609
void channel_permit_all_opens(void) ;
#line 616
void channel_input_port_forward_request(int is_root ) ;
#line 623
void channel_input_port_open(int payload_len ) ;
#line 636
char *x11_create_display_inet(int screen_number ) ;
#line 643
void x11_input_open(int payload_len ) ;
#line 655
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) ;
#line 658
void auth_request_forwarding(void) ;
#line 665
char *auth_get_socket_name(void) ;
#line 671
void auth_input_request_forwarding(struct passwd *pw ) ;
#line 674
void auth_input_open_request(void) ;
#line 80 "packet.h"
int packet_is_interactive(void) ;
#line 83
void packet_start(int type ) ;
#line 89
void packet_put_int(unsigned int value ) ;
#line 95
void packet_put_string(char const   *buf , unsigned int len ) ;
#line 101
void packet_send(void) ;
#line 110
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 132
unsigned int packet_get_int(void) ;
#line 146
char *packet_get_string(unsigned int *length_ptr ) ;
#line 172
void packet_write_wait(void) ;
#line 181
int max_packet_size ;
#line 22 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 28
void restore_uid(void) ;
#line 76 "nchan.h"
void chan_rcvd_oclose(Channel *c ) ;
#line 77
void chan_read_failed(Channel *c ) ;
#line 78
void chan_ibuf_empty(Channel *c ) ;
#line 81
void chan_rcvd_ieof(Channel *c ) ;
#line 82
void chan_write_failed(Channel *c ) ;
#line 83
void chan_obuf_empty(Channel *c ) ;
#line 85
void chan_init_iostates(Channel *c ) ;
#line 34 "compat.h"
int compat13 ;
#line 44 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 51 "channels.c"
static int channels_alloc  =    0;
#line 57 "channels.c"
static int channel_max_fd_value  =    0;
#line 60 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 61 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 64 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 67 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 68 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 74 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 75 "channels.c"
unsigned int x11_fake_data_len  ;
#line 89 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 91 "channels.c"
static int num_permitted_opens  =    0;
#line 97 "channels.c"
static int all_opens_permitted  =    0;
#line 100 "channels.c"
static int have_hostname_in_open  =    0;
#line 104 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 107
  have_hostname_in_open = hostname_in_open;
#line 108
  return;
}
}
#line 116 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 119
  all_opens_permitted = 1;
#line 120
  return;
}
}
#line 127 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 134
  if (sock > channel_max_fd_value) {
#line 135
    channel_max_fd_value = sock;
  }
#line 139
  if (channels_alloc == 0) {
#line 140
    channels_alloc = 10;
#line 141
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 141
    channels = (Channel *)tmp;
#line 142
    i = 0;
#line 142
    while (i < channels_alloc) {
#line 143
      (channels + i)->type = 0;
#line 142
      i ++;
    }
#line 148
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 151
  found = -1;
#line 151
  i = 0;
#line 151
  while (i < channels_alloc) {
#line 152
    if ((channels + i)->type == 0) {
#line 154
      found = i;
#line 155
      break;
    }
#line 151
    i ++;
  }
#line 157
  if (found == -1) {
#line 159
    found = channels_alloc;
#line 160
    channels_alloc += 10;
#line 161
    debug("channel: expanding %d", channels_alloc);
#line 162
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 162
    channels = (Channel *)tmp___0;
#line 163
    i = found;
#line 163
    while (i < channels_alloc) {
#line 164
      (channels + i)->type = 0;
#line 163
      i ++;
    }
  }
#line 167
  c = channels + found;
#line 168
  buffer_init(& c->input);
#line 169
  buffer_init(& c->output);
#line 170
  chan_init_iostates(c);
#line 171
  c->self = found;
#line 172
  c->type = type;
#line 173
  c->sock = sock;
#line 174
  c->remote_id = -1;
#line 175
  c->remote_name = remote_name;
#line 176
  debug("channel %d: new [%s]", found, remote_name);
#line 177
  return (found);
}
}
#line 182 "channels.c"
void channel_free(int channel ) 
{ 

  {
#line 185
  if (channel < 0) {
#line 187
    packet_disconnect("channel free: bad local channel %d", channel);
  } else {
#line 185
    if (channel >= channels_alloc) {
#line 187
      packet_disconnect("channel free: bad local channel %d", channel);
    } else {
#line 185
      if ((channels + channel)->type == 0) {
#line 187
        packet_disconnect("channel free: bad local channel %d", channel);
      }
    }
  }
#line 189
  if (compat13) {
#line 190
    shutdown((channels + channel)->sock, 2);
  }
#line 191
  close((channels + channel)->sock);
#line 192
  buffer_free(& (channels + channel)->input);
#line 193
  buffer_free(& (channels + channel)->output);
#line 194
  (channels + channel)->type = 0;
#line 195
  if ((channels + channel)->remote_name) {
#line 196
    xfree((void *)(channels + channel)->remote_name);
#line 197
    (channels + channel)->remote_name = (char *)((void *)0);
  }
#line 199
  return;
}
}
#line 206 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *ch ;
  unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 214
  i = 0;
#line 214
  while (i < channels_alloc) {
#line 215
    ch = channels + i;
    redo: 
#line 217
    switch (ch->type) {
    case 1: 
    case 2: 
    case 7: 
#line 221
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 222
    break;
    case 4: 
#line 225
    if (compat13) {
#line 226
      tmp = buffer_len(& ch->input);
#line 226
      if (tmp < (unsigned int )max_packet_size) {
#line 227
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 228
      tmp___0 = buffer_len(& ch->output);
#line 228
      if (tmp___0 > 0U) {
#line 229
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 230
      break;
    }
#line 233
    if (ch->istate == 1) {
#line 234
      tmp___1 = buffer_len(& ch->input);
#line 234
      if (tmp___1 < (unsigned int )max_packet_size) {
#line 235
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 236
    if (ch->ostate == 16) {
      goto _L;
    } else {
#line 236
      if (ch->ostate == 32) {
        _L: /* CIL Label */ 
#line 238
        tmp___2 = buffer_len(& ch->output);
#line 238
        if (tmp___2 > 0U) {
#line 239
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
#line 240
          if (ch->ostate == 32) {
#line 241
            chan_obuf_empty(ch);
          }
        }
      }
    }
#line 244
    break;
    case 10: 
#line 247
    if (! compat13) {
#line 248
      fatal("cannot happen: IN_DRAIN");
    }
#line 249
    tmp___3 = buffer_len(& ch->input);
#line 249
    if (tmp___3 == 0U) {
#line 250
      packet_start(24);
#line 251
      packet_put_int((unsigned int )ch->remote_id);
#line 252
      packet_send();
#line 253
      ch->type = 5;
#line 254
      debug("Closing channel %d after input drain.", i);
#line 255
      break;
    }
#line 257
    break;
    case 11: 
#line 260
    if (! compat13) {
#line 261
      fatal("cannot happen: OUT_DRAIN");
    }
#line 262
    tmp___4 = buffer_len(& ch->output);
#line 262
    if (tmp___4 == 0U) {
#line 263
      channel_free(i);
#line 264
      break;
    }
#line 266
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 267
    break;
    case 9: 
#line 281
    tmp___5 = buffer_len(& ch->output);
#line 281
    if (tmp___5 < 12U) {
#line 282
      break;
    }
#line 285
    tmp___6 = buffer_ptr(& ch->output);
#line 285
    ucp = (unsigned char *)tmp___6;
#line 286
    if ((int )*(ucp + 0) == 66) {
#line 287
      proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 288
      data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
    } else {
#line 289
      if ((int )*(ucp + 0) == 108) {
#line 290
        proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 291
        data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
      } else {
#line 293
        debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 295
        ch->type = 4;
        goto reject;
      }
    }
#line 300
    tmp___7 = buffer_len(& ch->output);
#line 300
    if (tmp___7 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 302
      break;
    }
#line 305
    tmp___8 = strlen((char const   *)x11_saved_proto);
#line 305
    if (proto_len != tmp___8) {
#line 307
      debug("X11 connection uses different authentication protocol.");
#line 308
      ch->type = 4;
      goto reject;
    } else {
#line 305
      tmp___9 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                       proto_len);
#line 305
      if (tmp___9 != 0) {
#line 307
        debug("X11 connection uses different authentication protocol.");
#line 308
        ch->type = 4;
        goto reject;
      }
    }
#line 312
    if (data_len != x11_fake_data_len) {
#line 315
      debug("X11 auth data does not match fake data.");
#line 316
      ch->type = 4;
      goto reject;
    } else {
#line 312
      tmp___10 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                        (void const   *)x11_fake_data, x11_fake_data_len);
#line 312
      if (tmp___10 != 0) {
#line 315
        debug("X11 auth data does not match fake data.");
#line 316
        ch->type = 4;
        goto reject;
      }
    }
#line 320
    if (x11_fake_data_len != x11_saved_data_len) {
#line 321
      error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 323
      ch->type = 4;
      goto reject;
    }
#line 331
    memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
           x11_saved_data_len);
#line 335
    ch->type = 4;
    goto redo;
    reject: 
#line 343
    log("X11 connection rejected because of wrong authentication.\r\n");
#line 344
    buffer_clear(& ch->input);
#line 345
    buffer_clear(& ch->output);
#line 346
    if (compat13) {
#line 347
      close(ch->sock);
#line 348
      ch->sock = -1;
#line 349
      ch->type = 5;
#line 350
      packet_start(24);
#line 351
      packet_put_int((unsigned int )ch->remote_id);
#line 352
      packet_send();
    } else {
#line 354
      debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
#line 355
      chan_read_failed(ch);
#line 356
      chan_write_failed(ch);
#line 357
      debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
    }
#line 359
    break;
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 214
    i ++;
  }
#line 366
  return;
}
}
#line 373 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int addrlen ;
  int newsock ;
  int i ;
  int newch ;
  int len ;
  Channel *ch ;
  char buf[16384] ;
  char *remote_hostname ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  register char __result ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  register char __result___0 ;
  int nchan ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  register char __result___1 ;
  unsigned int tmp___13 ;
  register char __result___2 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned int tmp___16 ;
  register char __result___3 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  char *tmp___19 ;
  unsigned int tmp___20 ;
  register char __result___4 ;
  unsigned int tmp___21 ;

  {
#line 382
  i = 0;
#line 382
  while (i < channels_alloc) {
#line 383
    ch = channels + i;
#line 384
    switch (ch->type) {
    case 1: 
#line 387
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 387
    if (__result) {
#line 388
      debug("X11 connection requested.");
#line 389
      addrlen = (int )sizeof(addr);
#line 390
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 391
      if (newsock < 0) {
#line 392
        tmp = __errno_location();
#line 392
        tmp___0 = strerror(*tmp);
#line 392
        error("accept: %.100s", tmp___0);
#line 393
        break;
      }
#line 395
      remote_hostname = get_remote_hostname(newsock);
#line 396
      tmp___1 = get_peer_port(newsock);
#line 396
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"X11 connection from %.200s port %d",
               remote_hostname, tmp___1);
#line 398
      xfree((void *)remote_hostname);
#line 399
      tmp___2 = xstrdup((char const   *)(buf));
#line 399
      newch = channel_allocate(3, newsock, tmp___2);
#line 401
      packet_start(27);
#line 402
      packet_put_int((unsigned int )newch);
#line 403
      if (have_hostname_in_open) {
#line 404
        tmp___3 = strlen((char const   *)(buf));
#line 404
        packet_put_string((char const   *)(buf), tmp___3);
      }
#line 405
      packet_send();
    }
#line 407
    break;
    case 2: 
#line 414
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 414
    if (__result___0) {
#line 415
      debug("Connection to port %d forwarding to %.100s:%d requested.", ch->listening_port,
            ch->path, ch->host_port);
#line 417
      addrlen = (int )sizeof(addr);
#line 418
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 419
      if (newsock < 0) {
#line 420
        tmp___4 = __errno_location();
#line 420
        tmp___5 = strerror(*tmp___4);
#line 420
        error("accept: %.100s", tmp___5);
#line 421
        break;
      }
#line 423
      remote_hostname = get_remote_hostname(newsock);
#line 424
      tmp___6 = get_peer_port(newsock);
#line 424
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"listen port %d:%.100s:%d, connect from %.200s:%d",
               ch->listening_port, ch->path, ch->host_port, remote_hostname, tmp___6);
#line 427
      xfree((void *)remote_hostname);
#line 428
      tmp___7 = xstrdup((char const   *)(buf));
#line 428
      newch = channel_allocate(3, newsock, tmp___7);
#line 430
      packet_start(29);
#line 431
      packet_put_int((unsigned int )newch);
#line 432
      tmp___8 = strlen((char const   *)(ch->path));
#line 432
      packet_put_string((char const   *)(ch->path), tmp___8);
#line 433
      packet_put_int((unsigned int )ch->host_port);
#line 434
      if (have_hostname_in_open) {
#line 435
        tmp___9 = strlen((char const   *)(buf));
#line 435
        packet_put_string((char const   *)(buf), tmp___9);
      }
#line 436
      packet_send();
    }
#line 438
    break;
    case 7: 
#line 445
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 445
    if (__result___1) {
#line 447
      len = (int )sizeof(addr);
#line 448
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& len));
#line 449
      if (newsock < 0) {
#line 450
        tmp___10 = __errno_location();
#line 450
        tmp___11 = strerror(*tmp___10);
#line 450
        error("accept from auth socket: %.100s", tmp___11);
#line 451
        break;
      }
#line 453
      tmp___12 = xstrdup("accepted auth socket");
#line 453
      nchan = channel_allocate(3, newsock, tmp___12);
#line 455
      packet_start(31);
#line 456
      packet_put_int((unsigned int )nchan);
#line 457
      packet_send();
    }
#line 459
    break;
    case 4: 
#line 472
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___2): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 472
    if (__result___2) {
#line 473
      len = read(ch->sock, (void *)(buf), sizeof(buf));
#line 474
      if (len <= 0) {
#line 475
        if (compat13) {
#line 476
          tmp___13 = buffer_len(& ch->output);
#line 476
          buffer_consume(& ch->output, tmp___13);
#line 477
          ch->type = 10;
#line 478
          debug("Channel %d status set to input draining.", i);
        } else {
#line 480
          chan_read_failed(ch);
        }
#line 482
        break;
      }
#line 484
      buffer_append(& ch->input, (char const   *)(buf), (unsigned int )len);
    }
#line 487
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___3): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 487
    if (__result___3) {
#line 487
      tmp___17 = buffer_len(& ch->output);
#line 487
      if (tmp___17 > 0U) {
#line 488
        tmp___14 = buffer_len(& ch->output);
#line 488
        tmp___15 = buffer_ptr(& ch->output);
#line 488
        len = write(ch->sock, (void const   *)tmp___15, tmp___14);
#line 490
        if (len <= 0) {
#line 491
          if (compat13) {
#line 492
            tmp___16 = buffer_len(& ch->output);
#line 492
            buffer_consume(& ch->output, tmp___16);
#line 493
            debug("Channel %d status set to input draining.", i);
#line 494
            ch->type = 10;
          } else {
#line 496
            chan_write_failed(ch);
          }
#line 498
          break;
        }
#line 500
        buffer_consume(& ch->output, (unsigned int )len);
      }
    }
#line 502
    break;
    case 11: 
#line 505
    if (! compat13) {
#line 506
      fatal("cannot happen: OUT_DRAIN");
    }
#line 508
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___4): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 508
    if (__result___4) {
#line 508
      tmp___21 = buffer_len(& ch->output);
#line 508
      if (tmp___21 > 0U) {
#line 509
        tmp___18 = buffer_len(& ch->output);
#line 509
        tmp___19 = buffer_ptr(& ch->output);
#line 509
        len = write(ch->sock, (void const   *)tmp___19, tmp___18);
#line 511
        if (len <= 0) {
#line 512
          tmp___20 = buffer_len(& ch->output);
#line 512
          buffer_consume(& ch->output, tmp___20);
        } else {
#line 514
          buffer_consume(& ch->output, (unsigned int )len);
        }
      }
    }
#line 516
    break;
    case 9: 
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 382
    i ++;
  }
#line 524
  return;
}
}
#line 528 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *ch ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 534
  i = 0;
#line 534
  while (i < channels_alloc) {
#line 535
    ch = channels + i;
#line 537
    if (ch->type != 4) {
#line 537
      if (ch->type != 10) {
        goto __Cont;
      }
    }
#line 542
    tmp = buffer_len(& ch->input);
#line 542
    len = (int )tmp;
#line 543
    if (len > 0) {
#line 545
      tmp___0 = packet_is_interactive();
#line 545
      if (tmp___0) {
#line 546
        if (len > 1024) {
#line 547
          len = 512;
        }
      } else {
#line 550
        if (len > 16384) {
#line 551
          len = 16384;
        }
      }
#line 553
      packet_start(23);
#line 554
      packet_put_int((unsigned int )ch->remote_id);
#line 555
      tmp___1 = buffer_ptr(& ch->input);
#line 555
      packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 556
      packet_send();
#line 557
      buffer_consume(& ch->input, (unsigned int )len);
    } else {
#line 558
      if (ch->istate == 2) {
#line 559
        if (compat13) {
#line 560
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 565
        chan_ibuf_empty(ch);
      }
    }
    __Cont: /* CIL Label */ 
#line 534
    i ++;
  }
#line 568
  return;
}
}
#line 576 "channels.c"
void channel_input_data(int payload_len ) 
{ int channel ;
  char *data ;
  unsigned int data_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;

  {
#line 584
  tmp = packet_get_int();
#line 584
  channel = (int )tmp;
#line 585
  if (channel < 0) {
#line 587
    packet_disconnect("Received data for nonexistent channel %d.", channel);
  } else {
#line 585
    if (channel >= channels_alloc) {
#line 587
      packet_disconnect("Received data for nonexistent channel %d.", channel);
    } else {
#line 585
      if ((channels + channel)->type == 0) {
#line 587
        packet_disconnect("Received data for nonexistent channel %d.", channel);
      }
    }
  }
#line 590
  if ((channels + channel)->type != 4) {
#line 590
    if ((channels + channel)->type != 9) {
#line 592
      return;
    }
  }
#line 595
  data = packet_get_string(& data_len);
#line 596
  while (1) {
#line 596
    _p = payload_len;
#line 596
    _e = (int )(8U + data_len);
#line 596
    if (_p != _e) {
#line 596
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 596);
#line 596
      packet_disconnect("Packet integrity error. (%d)", 23);
    }
#line 596
    break;
  }
#line 597
  buffer_append(& (channels + channel)->output, (char const   *)data, data_len);
#line 598
  xfree((void *)data);
#line 599
  return;
}
}
#line 606 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *ch ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 612
  i = 0U;
#line 612
  while (i < (unsigned int )channels_alloc) {
#line 613
    ch = channels + i;
#line 614
    switch (ch->type) {
    case 1: 
    case 2: 
    case 7: 
    goto __Cont;
    case 4: 
#line 620
    tmp = buffer_len(& ch->input);
#line 620
    if (tmp > (unsigned int )max_packet_size) {
#line 621
      return (0);
    }
#line 622
    tmp___0 = buffer_len(& ch->output);
#line 622
    if (tmp___0 > (unsigned int )max_packet_size) {
#line 623
      return (0);
    }
    goto __Cont;
    case 10: 
    case 11: 
    case 9: 
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 612
    i ++;
  }
#line 633
  return (1);
}
}
#line 638 "channels.c"
void channel_input_close(void) 
{ int channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 644
  tmp = packet_get_int();
#line 644
  channel = (int )tmp;
#line 645
  if (channel < 0) {
#line 647
    packet_disconnect("Received data for nonexistent channel %d.", channel);
  } else {
#line 645
    if (channel >= channels_alloc) {
#line 647
      packet_disconnect("Received data for nonexistent channel %d.", channel);
    } else {
#line 645
      if ((channels + channel)->type == 0) {
#line 647
        packet_disconnect("Received data for nonexistent channel %d.", channel);
      }
    }
  }
#line 649
  if (! compat13) {
#line 651
    chan_rcvd_ieof(channels + channel);
#line 652
    return;
  }
#line 659
  packet_start(25);
#line 660
  packet_put_int((unsigned int )(channels + channel)->remote_id);
#line 661
  packet_send();
#line 670
  if ((channels + channel)->type != 5) {
#line 675
    tmp___0 = buffer_len(& (channels + channel)->input);
#line 675
    buffer_consume(& (channels + channel)->input, tmp___0);
#line 677
    (channels + channel)->type = 11;
  }
#line 679
  return;
}
}
#line 683 "channels.c"
void channel_input_close_confirmation(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 689
  tmp = packet_get_int();
#line 689
  channel = (int )tmp;
#line 690
  if (channel < 0) {
#line 691
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      channel);
  } else {
#line 690
    if (channel >= channels_alloc) {
#line 691
      packet_disconnect("Received close confirmation for out-of-range channel %d.",
                        channel);
    }
  }
#line 694
  if (! compat13) {
#line 696
    chan_rcvd_oclose(channels + channel);
#line 697
    return;
  }
#line 699
  if ((channels + channel)->type != 5) {
#line 700
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      channel, (channels + channel)->type);
  }
#line 704
  channel_free(channel);
#line 705
  return;
}
}
#line 709 "channels.c"
void channel_input_open_confirmation(void) 
{ int channel ;
  int remote_channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 715
  tmp = packet_get_int();
#line 715
  channel = (int )tmp;
#line 716
  if (channel < 0) {
#line 718
    packet_disconnect("Received open confirmation for non-opening channel %d.", channel);
  } else {
#line 716
    if (channel >= channels_alloc) {
#line 718
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        channel);
    } else {
#line 716
      if ((channels + channel)->type != 3) {
#line 718
        packet_disconnect("Received open confirmation for non-opening channel %d.",
                          channel);
      }
    }
  }
#line 722
  tmp___0 = packet_get_int();
#line 722
  remote_channel = (int )tmp___0;
#line 725
  (channels + channel)->remote_id = remote_channel;
#line 726
  (channels + channel)->type = 4;
#line 727
  return;
}
}
#line 731 "channels.c"
void channel_input_open_failure(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 737
  tmp = packet_get_int();
#line 737
  channel = (int )tmp;
#line 738
  if (channel < 0) {
#line 740
    packet_disconnect("Received open failure for non-opening channel %d.", channel);
  } else {
#line 738
    if (channel >= channels_alloc) {
#line 740
      packet_disconnect("Received open failure for non-opening channel %d.", channel);
    } else {
#line 738
      if ((channels + channel)->type != 3) {
#line 740
        packet_disconnect("Received open failure for non-opening channel %d.", channel);
      }
    }
  }
#line 744
  channel_free(channel);
#line 745
  return;
}
}
#line 752 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 756
  i = 0;
#line 756
  while (i < channels_alloc) {
#line 757
    switch ((channels + i)->type) {
    case 7: 
#line 759
    close((channels + i)->sock);
#line 760
    remove((char const   *)((channels + i)->path));
#line 761
    channel_free(i);
#line 762
    break;
    case 2: 
    case 1: 
#line 765
    close((channels + i)->sock);
#line 766
    channel_free(i);
#line 767
    break;
    default: ;
#line 769
    break;
    }
#line 756
    i ++;
  }
#line 772
  return;
}
}
#line 779 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 783
  i = 0;
#line 783
  while (i < channels_alloc) {
#line 784
    if ((channels + i)->type != 0) {
#line 785
      close((channels + i)->sock);
    }
#line 783
    i ++;
  }
#line 787
  return;
}
}
#line 791 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 794
  return (channel_max_fd_value);
}
}
#line 799 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 803
  i = 0U;
#line 803
  while (i < (unsigned int )channels_alloc) {
#line 804
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
#line 814
    return (1);
    case 10: 
    case 11: 
#line 817
    if (! compat13) {
#line 818
      fatal("cannot happen: OUT_DRAIN");
    }
#line 819
    return (1);
    default: 
#line 821
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 803
    i ++;
  }
#line 824
  return (0);
}
}
#line 833 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 840
  buffer_init(& buffer);
#line 841
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"The following connections are open:\r\n");
#line 842
  tmp = strlen((char const   *)(buf));
#line 842
  buffer_append(& buffer, (char const   *)(buf), tmp);
#line 843
  i = 0;
#line 843
  while (i < channels_alloc) {
#line 844
    c = channels + i;
#line 845
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
    case 10: 
    case 11: 
#line 857
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d o%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, c->ostate);
#line 860
    tmp___0 = strlen((char const   *)(buf));
#line 860
    buffer_append(& buffer, (char const   *)(buf), tmp___0);
    goto __Cont;
    default: 
#line 863
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 843
    i ++;
  }
#line 867
  buffer_append(& buffer, "\000", 1U);
#line 868
  tmp___1 = buffer_ptr(& buffer);
#line 868
  cp = xstrdup((char const   *)tmp___1);
#line 869
  buffer_free(& buffer);
#line 870
  return (cp);
}
}
#line 878 "channels.c"
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ) 
{ int ch ;
  int sock ;
  int on ;
  struct sockaddr_in sin ;
  struct linger linger ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 882
  on = 1;
#line 887
  tmp = strlen(host);
#line 887
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 888
    packet_disconnect("Forward host name too long.");
  }
#line 891
  sock = socket(2, 1, 0);
#line 892
  if (sock < 0) {
#line 893
    tmp___0 = __errno_location();
#line 893
    tmp___1 = strerror(*tmp___0);
#line 893
    packet_disconnect("socket: %.100s", tmp___1);
  }
#line 896
  memset((void *)(& sin), 0, sizeof(sin));
#line 897
  sin.sin_family = (unsigned short)2;
#line 902
  __x = port;
#line 902
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 902
  sin.sin_port = __v;
#line 908
  setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 909
  linger.l_onoff = 1;
#line 910
  linger.l_linger = 5;
#line 911
  setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 914
  tmp___4 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), sizeof(sin));
#line 914
  if (tmp___4 < 0) {
#line 915
    tmp___2 = __errno_location();
#line 915
    tmp___3 = strerror(*tmp___2);
#line 915
    packet_disconnect("bind: %.100s", tmp___3);
  }
#line 918
  tmp___7 = listen(sock, 5);
#line 918
  if (tmp___7 < 0) {
#line 919
    tmp___5 = __errno_location();
#line 919
    tmp___6 = strerror(*tmp___5);
#line 919
    packet_disconnect("listen: %.100s", tmp___6);
  }
#line 922
  tmp___8 = xstrdup("port listener");
#line 922
  ch = channel_allocate(2, sock, tmp___8);
#line 924
  strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 925
  (channels + ch)->host_port = (int )host_port;
#line 926
  (channels + ch)->listening_port = (int )port;
#line 927
  return;
}
}
#line 934 "channels.c"
void channel_request_remote_forwarding(u_short port , char const   *host , u_short remote_port ) 
{ int payload_len ;
  size_t tmp ;

  {
#line 940
  if (num_permitted_opens >= 100) {
#line 941
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 943
  permitted_opens[num_permitted_opens].host = xstrdup(host);
#line 944
  permitted_opens[num_permitted_opens].port = remote_port;
#line 945
  num_permitted_opens ++;
#line 948
  packet_start(28);
#line 949
  packet_put_int((unsigned int )port);
#line 950
  tmp = strlen(host);
#line 950
  packet_put_string(host, tmp);
#line 951
  packet_put_int((unsigned int )remote_port);
#line 952
  packet_send();
#line 953
  packet_write_wait();
#line 959
  packet_read_expect(& payload_len, 14);
#line 960
  return;
}
}
#line 968 "channels.c"
void channel_input_port_forward_request(int is_root ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 975
  tmp = packet_get_int();
#line 975
  port = (unsigned short )tmp;
#line 976
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 977
  tmp___0 = packet_get_int();
#line 977
  host_port = (unsigned short )tmp___0;
#line 983
  if ((int )port < 1024) {
#line 983
    if (! is_root) {
#line 984
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 988
  channel_request_local_forwarding(port, (char const   *)hostname, host_port);
#line 991
  xfree((void *)hostname);
#line 992
  return;
}
}
#line 1000 "channels.c"
void channel_input_port_open(int payload_len ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  u_short host_port ;
  struct sockaddr_in sin ;
  char *host ;
  char *originator_string ;
  struct hostent *hp ;
  int host_len ;
  int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 1011
  tmp = packet_get_int();
#line 1011
  remote_channel = (int )tmp;
#line 1014
  host = packet_get_string((unsigned int *)(& host_len));
#line 1017
  tmp___0 = packet_get_int();
#line 1017
  host_port = (unsigned short )tmp___0;
#line 1020
  if (have_hostname_in_open) {
#line 1021
    originator_string = packet_get_string((unsigned int *)(& originator_len));
#line 1022
    originator_len += 4;
  } else {
#line 1024
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1025
    originator_len = 0;
  }
#line 1028
  while (1) {
#line 1028
    _p = payload_len;
#line 1028
    _e = ((8 + host_len) + 4) + originator_len;
#line 1028
    if (_p != _e) {
#line 1028
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1030);
#line 1028
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1028
    break;
  }
#line 1033
  if (! all_opens_permitted) {
#line 1035
    i = 0;
#line 1035
    while (i < num_permitted_opens) {
#line 1037
      if ((int )permitted_opens[i].port == (int )host_port) {
#line 1037
        if (0) {
#line 1037
          __s1_len = strlen((char const   *)permitted_opens[i].host);
#line 1037
          __s2_len = strlen((char const   *)host);
#line 1037
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host + 1)) - (unsigned int )((void const   *)permitted_opens[i].host) == 1U)) {
            goto _L___0;
          } else {
#line 1037
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1037
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1037
                tmp___10 = 1;
              } else {
#line 1037
                if (__s2_len >= 4U) {
#line 1037
                  tmp___10 = 1;
                } else {
#line 1037
                  tmp___10 = 0;
                }
              }
            } else {
#line 1037
              tmp___10 = 0;
            }
          }
#line 1037
          if (tmp___10) {
#line 1037
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
          } else {
#line 1037
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 1037
            tmp___6 = tmp___9;
          }
        } else {
#line 1037
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 1037
          tmp___6 = tmp___9;
        }
#line 1037
        if (tmp___6 == 0) {
#line 1038
          break;
        }
      }
#line 1035
      i ++;
    }
#line 1041
    if (i >= num_permitted_opens) {
#line 1043
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1045
      packet_start(22);
#line 1046
      packet_put_int((unsigned int )remote_channel);
#line 1047
      packet_send();
    }
  }
#line 1050
  memset((void *)(& sin), 0, sizeof(sin));
#line 1051
  sin.sin_addr.s_addr = inet_addr((char const   *)host);
#line 1052
  if ((sin.sin_addr.s_addr & 4294967295U) != 4294967295U) {
#line 1054
    sin.sin_family = (unsigned short)2;
  } else {
#line 1057
    hp = gethostbyname((char const   *)host);
#line 1058
    if (! hp) {
#line 1059
      error("%.100s: unknown host.", host);
      goto fail;
    }
#line 1062
    if (! *(hp->h_addr_list + 0)) {
#line 1063
      error("%.100s: host has no IP address.", host);
      goto fail;
    }
#line 1066
    sin.sin_family = (unsigned short )hp->h_addrtype;
#line 1067
    memcpy((void * __restrict  )(& sin.sin_addr), (void const   * __restrict  )*(hp->h_addr_list + 0),
           sizeof(sin.sin_addr));
  }
#line 1070
  __x = host_port;
#line 1070
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1070
  sin.sin_port = __v;
#line 1073
  sock = socket((int )sin.sin_family, 1, 0);
#line 1074
  if (sock < 0) {
#line 1075
    tmp___11 = __errno_location();
#line 1075
    tmp___12 = strerror(*tmp___11);
#line 1075
    error("socket: %.100s", tmp___12);
    goto fail;
  }
#line 1079
  tmp___15 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                     sizeof(sin));
#line 1079
  if (tmp___15 < 0) {
#line 1080
    tmp___13 = __errno_location();
#line 1080
    tmp___14 = strerror(*tmp___13);
#line 1080
    error("connect %.100s:%d: %.100s", host, host_port, tmp___14);
#line 1082
    close(sock);
    goto fail;
  }
#line 1088
  newch = channel_allocate(4, sock, originator_string);
#line 1089
  (channels + newch)->remote_id = remote_channel;
#line 1092
  packet_start(21);
#line 1093
  packet_put_int((unsigned int )remote_channel);
#line 1094
  packet_put_int((unsigned int )newch);
#line 1095
  packet_send();
#line 1098
  xfree((void *)host);
#line 1100
  return;
  fail: 
#line 1104
  xfree((void *)host);
#line 1107
  packet_start(22);
#line 1108
  packet_put_int((unsigned int )remote_channel);
#line 1109
  packet_send();
#line 1110
  return;
}
}
#line 1121
ServerOptions options ;
#line 1118 "channels.c"
char *x11_create_display_inet(int screen_number ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct sockaddr_in sin ;
  char buf[512] ;
  char hostname[64] ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 1128
  display_number = options.x11_display_offset;
#line 1128
  while (display_number < 1000) {
#line 1131
    port = (unsigned short )(6000 + display_number);
#line 1132
    memset((void *)(& sin), 0, sizeof(sin));
#line 1133
    sin.sin_family = (unsigned short)2;
#line 1134
    __x = 0U;
#line 1134
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1134
    sin.sin_addr.s_addr = __v;
#line 1135
    __x___0 = port;
#line 1135
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1135
    sin.sin_port = __v___0;
#line 1137
    sock = socket(2, 1, 0);
#line 1138
    if (sock < 0) {
#line 1139
      tmp = __errno_location();
#line 1139
      tmp___0 = strerror(*tmp);
#line 1139
      error("socket: %.100s", tmp___0);
#line 1140
      return ((char *)((void *)0));
    }
#line 1142
    tmp___3 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                   sizeof(sin));
#line 1142
    if (tmp___3 < 0) {
#line 1143
      tmp___1 = __errno_location();
#line 1143
      tmp___2 = strerror(*tmp___1);
#line 1143
      debug("bind port %d: %.100s", port, tmp___2);
#line 1144
      shutdown(sock, 2);
#line 1145
      close(sock);
      goto __Cont;
    }
#line 1148
    break;
    __Cont: /* CIL Label */ 
#line 1128
    display_number ++;
  }
#line 1150
  if (display_number >= 1000) {
#line 1151
    error("Failed to allocate internet-domain X11 display socket.");
#line 1152
    return ((char *)((void *)0));
  }
#line 1155
  tmp___6 = listen(sock, 5);
#line 1155
  if (tmp___6 < 0) {
#line 1156
    tmp___4 = __errno_location();
#line 1156
    tmp___5 = strerror(*tmp___4);
#line 1156
    error("listen: %.100s", tmp___5);
#line 1157
    shutdown(sock, 2);
#line 1158
    close(sock);
#line 1159
    return ((char *)((void *)0));
  }
#line 1162
  tmp___9 = gethostname(hostname, sizeof(hostname));
#line 1162
  if (tmp___9 < 0) {
#line 1163
    tmp___7 = __errno_location();
#line 1163
    tmp___8 = strerror(*tmp___7);
#line 1163
    fatal("gethostname: %.100s", tmp___8);
  }
#line 1164
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1168
  tmp___10 = xstrdup("X11 inet listener");
#line 1168
  channel_allocate(1, sock, tmp___10);
#line 1172
  tmp___11 = xstrdup((char const   *)(buf));
#line 1172
  return (tmp___11);
}
}
#line 1183
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1183 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1179 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1193
  path = x_sockets;
#line 1193
  while (*path) {
#line 1194
    sock = socket(1, 1, 0);
#line 1195
    if (sock < 0) {
#line 1196
      tmp = __errno_location();
#line 1196
      tmp___0 = strerror(*tmp);
#line 1196
      error("socket: %.100s", tmp___0);
    }
#line 1197
    memset((void *)(& addr), 0, sizeof(addr));
#line 1198
    addr.sun_family = (unsigned short)1;
#line 1199
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1200
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1200
    if (tmp___1 == 0) {
#line 1201
      return (sock);
    }
#line 1202
    close(sock);
#line 1193
    path ++;
  }
#line 1204
  tmp___2 = __errno_location();
#line 1204
  tmp___3 = strerror(*tmp___2);
#line 1204
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1205
  return (-1);
}
}
#line 1215 "channels.c"
void x11_input_open(int payload_len ) 
{ int remote_channel ;
  int display_number ;
  int sock ;
  int newch ;
  char const   *display ;
  struct sockaddr_in sin ;
  char buf[1024] ;
  char *cp ;
  char *remote_host ;
  struct hostent *hp ;
  int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___30 ;
  int tmp___31 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;

  {
#line 1226
  tmp = packet_get_int();
#line 1226
  remote_channel = (int )tmp;
#line 1229
  if (have_hostname_in_open) {
#line 1230
    remote_host = packet_get_string((unsigned int *)(& remote_len));
#line 1231
    remote_len += 4;
  } else {
#line 1233
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 1234
    remote_len = 0;
  }
#line 1237
  debug("Received X11 open request.");
#line 1238
  while (1) {
#line 1238
    _p = payload_len;
#line 1238
    _e = 4 + remote_len;
#line 1238
    if (_p != _e) {
#line 1238
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1238);
#line 1238
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 1238
    break;
  }
#line 1241
  tmp___0 = getenv("DISPLAY");
#line 1241
  display = (char const   *)tmp___0;
#line 1242
  if (! display) {
#line 1243
    error("DISPLAY not set.");
    goto fail;
  }
#line 1255
  if (0) {
#line 1255
    if (0) {
#line 1255
      __s1_len___0 = strlen(display);
#line 1255
      __s2_len___0 = strlen("unix:");
#line 1255
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1255
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1255
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1255
            tmp___26 = 1;
          } else {
#line 1255
            if (__s2_len___0 >= 4U) {
#line 1255
              tmp___26 = 1;
            } else {
#line 1255
              tmp___26 = 0;
            }
          }
        } else {
#line 1255
          tmp___26 = 0;
        }
      }
#line 1255
      if (tmp___26) {
#line 1255
        tmp___22 = __builtin_strcmp(display, "unix:");
      } else {
#line 1255
        tmp___25 = __builtin_strcmp(display, "unix:");
#line 1255
        tmp___22 = tmp___25;
      }
    } else {
#line 1255
      tmp___25 = __builtin_strcmp(display, "unix:");
#line 1255
      tmp___22 = tmp___25;
    }
#line 1255
    tmp___16 = tmp___22;
  } else {
#line 1255
    tmp___16 = strncmp(display, "unix:", 5U);
  }
#line 1255
  if (tmp___16 == 0) {
    goto _L___3;
  } else {
#line 1255
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1258
      tmp___1 = strrchr(display, ':');
#line 1258
      tmp___2 = sscanf((char const   * __restrict  )(tmp___1 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1258
      if (tmp___2 != 1) {
#line 1259
        error("Could not parse display number from DISPLAY: %.100s", display);
        goto fail;
      }
#line 1264
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1265
      if (sock < 0) {
        goto fail;
      }
      goto success;
    }
  }
#line 1275
  __builtin_strncpy(buf, display, sizeof(buf));
#line 1276
  buf[sizeof(buf) - 1U] = (char)0;
#line 1277
  tmp___30 = __builtin_strchr(buf, ':');
#line 1277
  cp = tmp___30;
#line 1278
  if (! cp) {
#line 1279
    error("Could not find \':\' in DISPLAY: %.100s", display);
    goto fail;
  }
#line 1282
  *cp = (char)0;
#line 1284
  tmp___31 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1284
  if (tmp___31 != 1) {
#line 1285
    error("Could not parse display number from DISPLAY: %.100s", display);
    goto fail;
  }
#line 1290
  memset((void *)(& sin), 0, sizeof(sin));
#line 1291
  sin.sin_addr.s_addr = inet_addr((char const   *)(buf));
#line 1292
  if ((sin.sin_addr.s_addr & 4294967295U) != 4294967295U) {
#line 1294
    sin.sin_family = (unsigned short)2;
  } else {
#line 1298
    hp = gethostbyname((char const   *)(buf));
#line 1299
    if (! hp) {
#line 1300
      error("%.100s: unknown host.", buf);
      goto fail;
    }
#line 1303
    if (! *(hp->h_addr_list + 0)) {
#line 1304
      error("%.100s: host has no IP address.", buf);
      goto fail;
    }
#line 1307
    sin.sin_family = (unsigned short )hp->h_addrtype;
#line 1308
    memcpy((void * __restrict  )(& sin.sin_addr), (void const   * __restrict  )*(hp->h_addr_list + 0),
           sizeof(sin.sin_addr));
  }
#line 1312
  __x = (unsigned short )(6000 + display_number);
#line 1312
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1312
  sin.sin_port = __v;
#line 1315
  sock = socket((int )sin.sin_family, 1, 0);
#line 1316
  if (sock < 0) {
#line 1317
    tmp___32 = __errno_location();
#line 1317
    tmp___33 = strerror(*tmp___32);
#line 1317
    error("socket: %.100s", tmp___33);
    goto fail;
  }
#line 1321
  tmp___36 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                     sizeof(sin));
#line 1321
  if (tmp___36 < 0) {
#line 1322
    tmp___34 = __errno_location();
#line 1322
    tmp___35 = strerror(*tmp___34);
#line 1322
    error("connect %.100s:%d: %.100s", buf, 6000 + display_number, tmp___35);
#line 1324
    close(sock);
    goto fail;
  }
  success: 
#line 1331
  if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 1332
    newch = channel_allocate(4, sock, remote_host);
  } else {
#line 1334
    newch = channel_allocate(9, sock, remote_host);
  }
#line 1335
  (channels + newch)->remote_id = remote_channel;
#line 1338
  packet_start(21);
#line 1339
  packet_put_int((unsigned int )remote_channel);
#line 1340
  packet_put_int((unsigned int )newch);
#line 1341
  packet_send();
#line 1343
  return;
  fail: 
#line 1347
  packet_start(22);
#line 1348
  packet_put_int((unsigned int )remote_channel);
#line 1349
  packet_send();
#line 1350
  return;
}
}
#line 1357 "channels.c"
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 1360
  tmp = strlen(data);
#line 1360
  data_len = tmp / 2U;
#line 1365
  rand___0 = (u_int32_t )0;
#line 1367
  tmp___0 = getenv("DISPLAY");
#line 1367
  cp = (char const   *)tmp___0;
#line 1368
  if (cp) {
#line 1369
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 1369
    cp = (char const   *)tmp___2;
  }
#line 1370
  if (cp) {
#line 1371
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 1371
    cp = (char const   *)tmp___4;
  }
#line 1372
  if (cp) {
#line 1373
    screen_number = atoi(cp + 1);
  } else {
#line 1375
    screen_number = 0;
  }
#line 1378
  x11_saved_proto = xstrdup(proto);
#line 1384
  tmp___5 = xmalloc(data_len);
#line 1384
  x11_saved_data = (char *)tmp___5;
#line 1385
  tmp___6 = xmalloc(data_len);
#line 1385
  x11_fake_data = (char *)tmp___6;
#line 1386
  i = 0U;
#line 1386
  while (i < data_len) {
#line 1387
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 1387
    if (tmp___7 != 1) {
#line 1388
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 1389
    if (i % 4U == 0U) {
#line 1390
      rand___0 = arc4random();
    }
#line 1391
    *(x11_saved_data + i) = (char )value;
#line 1392
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 1393
    rand___0 >>= 8;
#line 1386
    i ++;
  }
#line 1395
  x11_saved_data_len = data_len;
#line 1396
  x11_fake_data_len = data_len;
#line 1399
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 1399
  new_data = (char *)tmp___8;
#line 1400
  i = 0U;
#line 1400
  while (i < data_len) {
#line 1401
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 1400
    i ++;
  }
#line 1404
  packet_start(34);
#line 1405
  tmp___9 = strlen(proto);
#line 1405
  packet_put_string(proto, tmp___9);
#line 1406
  tmp___10 = strlen((char const   *)new_data);
#line 1406
  packet_put_string((char const   *)new_data, tmp___10);
#line 1407
  packet_put_int((unsigned int )screen_number);
#line 1408
  packet_send();
#line 1409
  packet_write_wait();
#line 1410
  xfree((void *)new_data);
#line 1411
  return;
}
}
#line 1415 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 1418
  packet_start(30);
#line 1419
  packet_send();
#line 1420
  packet_write_wait();
#line 1421
  return;
}
}
#line 1429 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 1432
  return (channel_forwarded_auth_socket_name);
}
}
#line 1437 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 1440
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 1441
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 1442
  return;
}
}
#line 1449 "channels.c"
void auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 1455
  tmp = auth_get_socket_name();
#line 1455
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 1456
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 1459
  temporarily_use_uid(pw->pw_uid);
#line 1462
  tmp___0 = xmalloc(100U);
#line 1462
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 1463
  tmp___1 = xmalloc(100U);
#line 1463
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 1464
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 1467
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 1467
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 1468
    tmp___2 = __errno_location();
#line 1468
    tmp___3 = strerror(*tmp___2);
#line 1468
    packet_disconnect("mkdtemp: %.100s", tmp___3);
  }
#line 1469
  tmp___5 = getpid();
#line 1469
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 1472
  tmp___8 = atexit(& cleanup_socket);
#line 1472
  if (tmp___8 < 0) {
#line 1473
    tmp___6 = __errno_location();
#line 1473
    saved = *tmp___6;
#line 1474
    cleanup_socket();
#line 1475
    tmp___7 = strerror(saved);
#line 1475
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 1478
  sock = socket(1, 1, 0);
#line 1479
  if (sock < 0) {
#line 1480
    tmp___9 = __errno_location();
#line 1480
    tmp___10 = strerror(*tmp___9);
#line 1480
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 1483
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 1484
  sunaddr.sun_family = (unsigned short)1;
#line 1485
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 1488
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 1488
  if (tmp___13 < 0) {
#line 1489
    tmp___11 = __errno_location();
#line 1489
    tmp___12 = strerror(*tmp___11);
#line 1489
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 1492
  restore_uid();
#line 1495
  tmp___16 = listen(sock, 5);
#line 1495
  if (tmp___16 < 0) {
#line 1496
    tmp___14 = __errno_location();
#line 1496
    tmp___15 = strerror(*tmp___14);
#line 1496
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 1499
  tmp___17 = xstrdup("auth socket");
#line 1499
  newch = channel_allocate(7, sock, tmp___17);
#line 1501
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 1503
  return;
}
}
#line 1507 "channels.c"
void auth_input_open_request(void) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  unsigned int tmp ;

  {
#line 1514
  tmp = packet_get_int();
#line 1514
  remch = (int )tmp;
#line 1520
  sock = ssh_get_authentication_socket();
#line 1528
  if (sock < 0) {
#line 1529
    packet_start(22);
#line 1530
    packet_put_int((unsigned int )remch);
#line 1531
    packet_send();
#line 1532
    return;
  }
#line 1534
  debug("Forwarding authentication connection.");
#line 1541
  dummyname = xstrdup("authentication agent connection");
#line 1543
  newch = channel_allocate(4, sock, dummyname);
#line 1544
  (channels + newch)->remote_id = remch;
#line 1547
  packet_start(21);
#line 1548
  packet_put_int((unsigned int )remch);
#line 1549
  packet_put_int((unsigned int )newch);
#line 1550
  packet_send();
#line 1551
  return;
}
}
#line 1 "cipher.o"
#pragma merger(0,"./cipher.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 71 "cipher.h"
int cipher_number(char const   *name ) ;
#line 77
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) ;
#line 103
void (*cipher_attack_detected)(char const   *fmt  , ...) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 39 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , void *dest , void *src ,
                      unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 48
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 50
  DES_cbc_encrypt((unsigned char const   *)src, (unsigned char *)dest, (long )len,
                  & ks1, & iv1, 1);
#line 51
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 53
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks2, iv2, 0);
#line 54
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 56
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks3, iv3, 1);
#line 57
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 58
  return;
}
}
#line 60 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , void *dest , void *src ,
                      unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 69
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 71
  DES_cbc_encrypt((unsigned char const   *)src, (unsigned char *)dest, (long )len,
                  & ks3, iv3, 0);
#line 72
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 74
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks2, iv2, 1);
#line 75
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 77
  DES_cbc_encrypt((unsigned char const   *)dest, (unsigned char *)dest, (long )len,
                  & ks1, & iv1, 0);
#line 80
  return;
}
}
#line 86 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_74 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 90
  dst = (u_int32_t *)dst_;
#line 97
  n___0 /= 8;
#line 97
  while (n___0 > 0) {
#line 98
    tmp = src;
#line 98
    src ++;
#line 98
    t.c[3] = (char )*tmp;
#line 99
    tmp___0 = src;
#line 99
    src ++;
#line 99
    t.c[2] = (char )*tmp___0;
#line 100
    tmp___1 = src;
#line 100
    src ++;
#line 100
    t.c[1] = (char )*tmp___1;
#line 101
    tmp___2 = src;
#line 101
    src ++;
#line 101
    t.c[0] = (char )*tmp___2;
#line 102
    tmp___3 = dst;
#line 102
    dst ++;
#line 102
    *tmp___3 = t.i;
#line 104
    tmp___4 = src;
#line 104
    src ++;
#line 104
    t.c[3] = (char )*tmp___4;
#line 105
    tmp___5 = src;
#line 105
    src ++;
#line 105
    t.c[2] = (char )*tmp___5;
#line 106
    tmp___6 = src;
#line 106
    src ++;
#line 106
    t.c[1] = (char )*tmp___6;
#line 107
    tmp___7 = src;
#line 107
    src ++;
#line 107
    t.c[0] = (char )*tmp___7;
#line 108
    tmp___8 = dst;
#line 108
    dst ++;
#line 108
    *tmp___8 = t.i;
#line 97
    n___0 --;
  }
#line 110
  return;
}
}
#line 112 "cipher.c"
void (*cipher_attack_detected)(char const   *fmt  , ...)  =    (void (*)(char const   *fmt  , ...))(& fatal);
#line 114 "cipher.c"
__inline static void detect_cbc_attack(unsigned char const   *src , unsigned int len ) 
{ 

  {
#line 118
  return;
#line 120
  log("CRC-32 CBC insertion attack detected");
#line 121
  (*cipher_attack_detected)("CRC-32 CBC insertion attack detected");
}
}
#line 128 "cipher.c"
static char *cipher_names[7]  = {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish"};
#line 145 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int mask ;

  {
#line 148
  mask = 0U;
#line 149
  mask |= (unsigned int )(1 << 3);
#line 150
  mask |= (unsigned int )(1 << 6);
#line 151
  return (mask);
}
}
#line 156 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 159
  if (cipher < 0) {
#line 161
    fatal("cipher_name: bad cipher number: %d", cipher);
  } else {
#line 159
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 161
      fatal("cipher_name: bad cipher number: %d", cipher);
    } else {
#line 159
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 161
        fatal("cipher_name: bad cipher number: %d", cipher);
      }
    }
  }
#line 162
  return ((char const   *)cipher_names[cipher]);
}
}
#line 170 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 174
  i = 0;
#line 174
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 175
    if (0) {
#line 175
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 175
      __s2_len = strlen(name);
#line 175
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 175
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 175
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 175
            tmp___8 = 1;
          } else {
#line 175
            if (__s2_len >= 4U) {
#line 175
              tmp___8 = 1;
            } else {
#line 175
              tmp___8 = 0;
            }
          }
        } else {
#line 175
          tmp___8 = 0;
        }
      }
#line 175
      if (tmp___8) {
#line 175
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 175
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 175
        tmp___4 = tmp___7;
      }
    } else {
#line 175
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 175
      tmp___4 = tmp___7;
    }
#line 175
    if (tmp___4 == 0) {
#line 175
      tmp___9 = cipher_mask();
#line 175
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 177
        return (i);
      }
    }
#line 174
    i ++;
  }
#line 178
  return (-1);
}
}
#line 186 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) 
{ MD5_CTX md ;
  unsigned char digest[16] ;
  size_t tmp ;

  {
#line 193
  MD5_Init(& md);
#line 194
  tmp = strlen(passphrase);
#line 194
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 195
  MD5_Final(digest, & md);
#line 197
  cipher_set_key(context, cipher, (unsigned char const   *)(digest), 16, for_encryption);
#line 199
  memset((void *)(digest), 0, sizeof(digest));
#line 200
  memset((void *)(& md), 0, sizeof(md));
#line 201
  return;
}
}
#line 205 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;
  char const   *tmp___0 ;

  {
#line 212
  context->type = (unsigned int )cipher;
#line 216
  memset((void *)(padded), 0, sizeof(padded));
#line 217
  if ((unsigned int )keylen < sizeof(padded)) {
#line 217
    tmp = (unsigned int )keylen;
  } else {
#line 217
    tmp = sizeof(padded);
  }
#line 217
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 220
  switch (cipher) {
  case 0: 
#line 226
  break;
  case 3: 
#line 234
  if (keylen < 16) {
#line 235
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 236
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 237
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 238
  if (keylen <= 16) {
#line 239
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 241
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 242
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 243
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 244
  break;
  case 6: 
#line 247
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 248
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 249
  break;
  default: 
#line 252
  tmp___0 = cipher_name(cipher);
#line 252
  fatal("cipher_set_key: unknown cipher: %s", tmp___0);
  }
#line 254
  memset((void *)(padded), 0, sizeof(padded));
#line 255
  return;
}
}
#line 259 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 263
  if ((len & 7U) != 0U) {
#line 264
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 266
  switch ((int )context->type) {
  case 0: 
#line 268
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 269
  break;
  case 3: 
#line 272
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, (void *)dest, (void *)src,
                   len);
#line 276
  break;
  case 6: 
#line 279
  swap_bytes(src, dest, (int )len);
#line 280
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 283
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 284
  break;
  default: 
#line 287
  tmp = cipher_name((int )context->type);
#line 287
  fatal("cipher_encrypt: unknown cipher: %s", tmp);
  }
#line 289
  return;
}
}
#line 293 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 297
  if ((len & 7U) != 0U) {
#line 298
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 300
  switch ((int )context->type) {
  case 0: 
#line 302
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 303
  break;
  case 3: 
#line 307
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, (void *)dest, (void *)src,
                   len);
#line 311
  break;
  case 6: 
#line 314
  detect_cbc_attack(src, len);
#line 315
  swap_bytes(src, dest, (int )len);
#line 316
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 319
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 320
  break;
  default: 
#line 323
  tmp = cipher_name((int )context->type);
#line 323
  fatal("cipher_decrypt: unknown cipher: %s", tmp);
  }
#line 325
  return;
}
}
#line 1 "compat.o"
#pragma merger(0,"./compat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 497 "ssh.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 35 "compat.c"
int compat13  =    0;
#line 37 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 40
  verbose("Enabling compatibility mode for protocol 1.3");
#line 41
  compat13 = 1;
#line 42
  return;
}
}
#line 1 "compress.o"
#pragma merger(0,"./compress.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 31 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 34
  debug("Enabling compression at level %d.", level);
#line 35
  if (level < 1) {
#line 36
    fatal("Bad compression level %d.", level);
  } else {
#line 35
    if (level > 9) {
#line 36
      fatal("Bad compression level %d.", level);
    }
  }
#line 37
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 38
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 39
  return;
}
}
#line 43 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 46
  if (outgoing_stream.total_in == 0UL) {
#line 46
    tmp = 0.0;
  } else {
#line 46
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 46
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 50
  if (incoming_stream.total_out == 0UL) {
#line 50
    tmp___0 = 0.0;
  } else {
#line 50
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 50
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 54
  inflateEnd(& incoming_stream);
#line 55
  deflateEnd(& outgoing_stream);
#line 56
  return;
}
}
#line 67 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 74
  tmp = buffer_len(input_buffer);
#line 74
  if (tmp == 0U) {
#line 75
    return;
  }
#line 78
  tmp___0 = buffer_ptr(input_buffer);
#line 78
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 79
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 82
  while (1) {
#line 84
    outgoing_stream.next_out = (Bytef *)(buf);
#line 85
    outgoing_stream.avail_out = sizeof(buf);
#line 88
    status = deflate(& outgoing_stream, 1);
#line 89
    switch (status) {
    case 0: 
#line 92
    buffer_append(output_buffer, (char const   *)(buf), sizeof(buf) - outgoing_stream.avail_out);
#line 94
    break;
    case 1: 
#line 96
    fatal("buffer_compress: deflate returned Z_STREAM_END");
    case -2: 
#line 99
    fatal("buffer_compress: deflate returned Z_STREAM_ERROR");
    case -5: 
#line 102
    fatal("buffer_compress: deflate returned Z_BUF_ERROR");
    default: 
#line 105
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 82
    if (! (outgoing_stream.avail_out == 0U)) {
#line 82
      break;
    }
  }
#line 110
  return;
}
}
#line 121 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf[4096] ;
  int status ;
  char *tmp ;

  {
#line 127
  tmp = buffer_ptr(input_buffer);
#line 127
  incoming_stream.next_in = (Bytef *)tmp;
#line 128
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 130
  incoming_stream.next_out = (Bytef *)(buf);
#line 131
  incoming_stream.avail_out = sizeof(buf);
#line 133
  while (1) {
#line 134
    status = inflate(& incoming_stream, 1);
#line 135
    switch (status) {
    case 0: 
#line 137
    buffer_append(output_buffer, (char const   *)(buf), sizeof(buf) - incoming_stream.avail_out);
#line 139
    incoming_stream.next_out = (Bytef *)(buf);
#line 140
    incoming_stream.avail_out = sizeof(buf);
#line 141
    break;
    case 1: 
#line 143
    fatal("buffer_uncompress: inflate returned Z_STREAM_END");
    case -3: 
#line 146
    fatal("buffer_uncompress: inflate returned Z_DATA_ERROR");
    case -2: 
#line 149
    fatal("buffer_uncompress: inflate returned Z_STREAM_ERROR");
    case -5: 
#line 157
    return;
    case -4: 
#line 159
    fatal("buffer_uncompress: inflate returned Z_MEM_ERROR");
    default: 
#line 162
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#pragma merger(0,"./crc32.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 25 "crc32.h"
unsigned int crc32(unsigned char const   *s , unsigned int len ) ;
#line 53 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 53 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 110 "crc32.c"
unsigned int crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 116
  crc32val = 0U;
#line 117
  i = 0U;
#line 117
  while (i < len) {
#line 118
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 117
    i ++;
  }
#line 120
  return (crc32val);
}
}
#line 1 "deattack.o"
#pragma merger(0,"./deattack.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 27 "deattack.h"
int detect_attack(unsigned char *buf , u_int32_t len , unsigned char *IV ) ;
#line 49 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 52
  b ^= *a;
#line 53
  *a = crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 54
  return;
}
}
#line 57 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  crc = 0U;
#line 65
  if (IV) {
#line 65
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 65
    if (! tmp) {
#line 66
      crc_update(& crc, 1U);
#line 67
      crc_update(& crc, 0U);
    }
  }
#line 69
  c = buf;
#line 69
  while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 70
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 70
    if (tmp___0) {
#line 74
      crc_update(& crc, 0U);
#line 75
      crc_update(& crc, 0U);
    } else {
#line 71
      crc_update(& crc, 1U);
#line 72
      crc_update(& crc, 0U);
    }
#line 69
    c += 8;
  }
#line 78
  return (crc == 0U);
}
}
#line 86 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 87 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 83 "deattack.c"
int detect_attack(unsigned char *buf , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (len > 262144U) {
#line 95
    fatal("detect_attack: bad length %d", len);
  } else {
#line 93
    if (len % 8U != 0U) {
#line 95
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 97
  l = (unsigned int )n;
#line 97
  while (l < ((len / 8U) * 3U) / 2U) {
#line 97
    l <<= 2;
  }
#line 100
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 101
    debug("Installing crc compensation attack detector.");
#line 102
    n = (unsigned short )l;
#line 103
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 103
    h = (u_int16_t *)tmp;
  } else {
#line 105
    if (l > (u_int32_t )n) {
#line 106
      n = (unsigned short )l;
#line 107
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 107
      h = (u_int16_t *)tmp___0;
    }
  }
#line 111
  if (len <= 56U) {
#line 112
    c = buf;
#line 112
    while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 113
      if (IV) {
#line 113
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 113
        if (! tmp___2) {
#line 114
          tmp___1 = check_crc(c, buf, len, (unsigned char *)IV);
#line 114
          if (tmp___1) {
#line 115
            return (1);
          } else {
#line 117
            break;
          }
        }
      }
#line 119
      d = buf;
#line 119
      while ((unsigned int )d < (unsigned int )c) {
#line 120
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 120
        if (! tmp___4) {
#line 121
          tmp___3 = check_crc(c, buf, len, (unsigned char *)IV);
#line 121
          if (tmp___3) {
#line 122
            return (1);
          } else {
#line 124
            break;
          }
        }
#line 119
        d += 8;
      }
#line 112
      c += 8;
    }
#line 128
    return (0);
  }
#line 130
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 132
  if (IV) {
#line 133
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 135
  c = buf;
#line 135
  j = 0U;
#line 135
  while ((unsigned int )c < (unsigned int )(buf + len)) {
#line 136
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 136
    while ((int )*(h + i) != 65535) {
#line 138
      if ((int )*(h + i) == 65534) {
#line 139
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 139
        if (! tmp___6) {
#line 140
          tmp___5 = check_crc(c, buf, len, (unsigned char *)IV);
#line 140
          if (tmp___5) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
      } else {
#line 145
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf + (int )*(h + i) * 8),
                         8U);
#line 145
        if (! tmp___8) {
#line 146
          tmp___7 = check_crc(c, buf, len, (unsigned char *)IV);
#line 146
          if (tmp___7) {
#line 147
            return (1);
          } else {
#line 149
            break;
          }
        }
      }
#line 136
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 152
    *(h + i) = (unsigned short )j;
#line 135
    c += 8;
#line 135
    j ++;
  }
#line 154
  return (0);
}
}
#line 1 "hostfile.o"
#pragma merger(0,"./hostfile.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 357 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 390
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 401
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                                  BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) ;
#line 409
int add_host_to_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                         BIGNUM *n___0 ) ;
#line 680
int match_pattern(char const   *s , char const   *pattern ) ;
#line 30 "hostfile.c"
int auth_rsa_read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int len ;
  int old ;
  int tmp ;

  {
#line 33
  cp = *cpp;
#line 37
  while (1) {
#line 37
    if (! ((int )*cp == 32)) {
#line 37
      if (! ((int )*cp == 9)) {
#line 37
        break;
      }
    }
#line 37
    cp ++;
  }
#line 41
  if ((int )*cp < 48) {
#line 42
    return (0);
  } else {
#line 41
    if ((int )*cp > 57) {
#line 42
      return (0);
    }
  }
#line 45
  *cpp = cp;
#line 48
  while (1) {
#line 48
    if ((int )*cp >= 48) {
#line 48
      if (! ((int )*cp <= 57)) {
#line 48
        break;
      }
    } else {
#line 48
      break;
    }
#line 48
    cp ++;
  }
#line 52
  len = cp - *cpp;
#line 55
  old = (int )*cp;
#line 56
  *cp = (char)0;
#line 59
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 59
  if (tmp == 0) {
#line 60
    return (0);
  }
#line 63
  *cp = (char )old;
#line 66
  *cpp = cp;
#line 67
  return (1);
}
}
#line 75 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ unsigned int bits ;
  char *cp ;
  int tmp ;
  int tmp___0 ;

  {
#line 82
  cp = *cpp;
#line 82
  while (1) {
#line 82
    if (! ((int )*cp == 32)) {
#line 82
      if (! ((int )*cp == 9)) {
#line 82
        break;
      }
    }
#line 82
    cp ++;
  }
#line 86
  if ((int )*cp < 48) {
#line 87
    return (0);
  } else {
#line 86
    if ((int )*cp > 57) {
#line 87
      return (0);
    }
  }
#line 88
  bits = 0U;
#line 88
  while (1) {
#line 88
    if ((int )*cp >= 48) {
#line 88
      if (! ((int )*cp <= 57)) {
#line 88
        break;
      }
    } else {
#line 88
      break;
    }
#line 89
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 88
    cp ++;
  }
#line 92
  tmp = auth_rsa_read_bignum(& cp, e);
#line 92
  if (! tmp) {
#line 93
    return (0);
  }
#line 96
  tmp___0 = auth_rsa_read_bignum(& cp, n___0);
#line 96
  if (! tmp___0) {
#line 97
    return (0);
  }
#line 100
  while (1) {
#line 100
    if (! ((int )*cp == 32)) {
#line 100
      if (! ((int )*cp == 9)) {
#line 100
        break;
      }
    }
#line 100
    cp ++;
  }
#line 104
  *cpp = cp;
#line 105
  *bitsp = bits;
#line 106
  return (1);
}
}
#line 116 "hostfile.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 124
  got_positive = 0;
#line 125
  i = 0U;
#line 125
  while (i < len) {
#line 127
    if ((int const   )*(pattern + i) == 33) {
#line 128
      negated = 1;
#line 129
      i ++;
    } else {
#line 131
      negated = 0;
    }
#line 137
    subi = 0U;
#line 137
    while (1) {
#line 137
      if (i < len) {
#line 137
        if (subi < sizeof(sub) - 1U) {
#line 137
          if (! ((int const   )*(pattern + i) != 44)) {
#line 137
            break;
          }
        } else {
#line 137
          break;
        }
      } else {
#line 137
        break;
      }
#line 140
      tmp___6 = __ctype_b_loc();
#line 140
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 140
        if (sizeof(*(pattern + i)) > 1U) {
#line 140
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 140
          tmp___5 = __ctype_tolower_loc();
#line 140
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 140
        sub[subi] = (char )__res___0;
      } else {
#line 140
        sub[subi] = (char )*(pattern + i);
      }
#line 137
      subi ++;
#line 137
      i ++;
    }
#line 142
    if (subi >= sizeof(sub) - 1U) {
#line 143
      return (0);
    }
#line 146
    if (i < len) {
#line 146
      if ((int const   )*(pattern + i) == 44) {
#line 147
        i ++;
      }
    }
#line 150
    sub[subi] = (char )'\000';
#line 153
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 153
    if (tmp___7) {
#line 154
      if (negated) {
#line 155
        return (0);
      } else {
#line 157
        got_positive = 1;
      }
    }
  }
#line 165
  return (got_positive);
}
}
#line 175 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                                  BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  unsigned int bits ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 181
  linenum = 0;
#line 187
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 188
  if (! f) {
#line 189
    return (1);
  }
#line 192
  hostlen = strlen(host);
#line 199
  end_return = 1;
#line 202
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 202
  bits = (unsigned int )tmp;
#line 205
  while (1) {
#line 205
    tmp___7 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 205
    if (! tmp___7) {
#line 205
      break;
    }
#line 206
    cp = line;
#line 207
    linenum ++;
#line 210
    while (1) {
#line 210
      if (! ((int )*cp == 32)) {
#line 210
        if (! ((int )*cp == 9)) {
#line 210
          break;
        }
      }
#line 210
      cp ++;
    }
#line 212
    if (! *cp) {
#line 213
      continue;
    } else {
#line 212
      if ((int )*cp == 35) {
#line 213
        continue;
      } else {
#line 212
        if ((int )*cp == 10) {
#line 213
          continue;
        }
      }
    }
#line 216
    cp2 = cp;
#line 216
    while (1) {
#line 216
      if (*cp2) {
#line 216
        if ((int )*cp2 != 32) {
#line 216
          if (! ((int )*cp2 != 9)) {
#line 216
            break;
          }
        } else {
#line 216
          break;
        }
      } else {
#line 216
        break;
      }
#line 216
      cp2 ++;
    }
#line 220
    tmp___0 = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 220
    if (! tmp___0) {
#line 221
      continue;
    }
#line 224
    cp = cp2;
#line 230
    tmp___1 = auth_rsa_read_key(& cp, & kbits, ke, kn);
#line 230
    if (! tmp___1) {
#line 231
      continue;
    }
#line 233
    tmp___4 = BN_num_bits((BIGNUM const   *)kn);
#line 233
    if (kbits != (unsigned int )tmp___4) {
#line 234
      tmp___2 = BN_num_bits((BIGNUM const   *)kn);
#line 234
      error("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
            filename, linenum, host, tmp___2, kbits);
#line 237
      tmp___3 = BN_num_bits((BIGNUM const   *)kn);
#line 237
      error("Warning: replace %d with %d in %s, line %d.", kbits, tmp___3, filename,
            linenum);
    }
#line 241
    tmp___5 = BN_cmp((BIGNUM const   *)ke, (BIGNUM const   *)e);
#line 241
    if (tmp___5 == 0) {
#line 241
      tmp___6 = BN_cmp((BIGNUM const   *)kn, (BIGNUM const   *)n___0);
#line 241
      if (tmp___6 == 0) {
#line 243
        fclose(f);
#line 244
        return (0);
      }
    }
#line 251
    end_return = 2;
  }
#line 254
  fclose(f);
#line 260
  return (end_return);
}
}
#line 268 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                         BIGNUM *n___0 ) 
{ FILE *f ;
  char *buf ;
  unsigned int bits ;
  int tmp ;

  {
#line 277
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 278
  if (! f) {
#line 279
    return (0);
  }
#line 282
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 282
  bits = (unsigned int )tmp;
#line 285
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %u ", host, bits);
#line 286
  buf = BN_bn2dec((BIGNUM const   *)e);
#line 287
  if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 288
    error("add_host_to_hostfile: BN_bn2dec(e) failed");
#line 289
    fclose(f);
#line 290
    return (0);
  }
#line 292
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", buf);
#line 293
  free((void *)buf);
#line 294
  buf = BN_bn2dec((BIGNUM const   *)n___0);
#line 295
  if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 296
    error("add_host_to_hostfile: BN_bn2dec(n) failed");
#line 297
    fclose(f);
#line 298
    return (0);
  }
#line 300
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s\n", buf);
#line 301
  free((void *)buf);
#line 304
  fclose(f);
#line 305
  return (1);
}
}
#line 1 "match.o"
#pragma merger(0,"./match.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 26 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 29
  while (1) {
#line 31
    if (! *pattern) {
#line 32
      return (! *s);
    }
#line 34
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 49
          while (*s) {
#line 50
            if ((int const   )*s == (int const   )*pattern) {
#line 50
              tmp = match_pattern(s + 1, pattern + 1);
#line 50
              if (tmp) {
#line 52
                return (1);
              }
            }
#line 49
            s ++;
          }
#line 54
          return (0);
        }
      }
#line 60
      while (*s) {
#line 61
        tmp___0 = match_pattern(s, pattern);
#line 61
        if (tmp___0) {
#line 62
          return (1);
        }
#line 60
        s ++;
      }
#line 64
      return (0);
    }
#line 70
    if (! *s) {
#line 71
      return (0);
    }
#line 74
    if ((int const   )*pattern != 63) {
#line 74
      if ((int const   )*pattern != (int const   )*s) {
#line 75
        return (0);
      }
    }
#line 78
    s ++;
#line 79
    pattern ++;
  }
}
}
#line 1 "mpaux.o"
#pragma merger(0,"./mpaux.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 32 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ unsigned int host_key_bits ;
  int tmp ;
  unsigned int session_key_bits ;
  int tmp___0 ;
  unsigned int bytes ;
  unsigned char *buf ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 38
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 38
  host_key_bits = (unsigned int )tmp;
#line 39
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 39
  session_key_bits = (unsigned int )tmp___0;
#line 40
  bytes = ((host_key_bits + 7U) / 8U + (session_key_bits + 7U) / 8U) + 8U;
#line 41
  tmp___1 = xmalloc(bytes);
#line 41
  buf = (unsigned char *)tmp___1;
#line 44
  BN_bn2bin((BIGNUM const   *)host_key_n, buf);
#line 45
  BN_bn2bin((BIGNUM const   *)session_key_n, buf + (host_key_bits + 7U) / 8U);
#line 46
  memcpy((void * __restrict  )((buf + (host_key_bits + 7U) / 8U) + (session_key_bits + 7U) / 8U),
         (void const   * __restrict  )cookie, 8U);
#line 47
  MD5_Init(& md);
#line 48
  MD5_Update(& md, (void const   *)buf, bytes);
#line 49
  MD5_Final((unsigned char *)session_id___0, & md);
#line 50
  memset((void *)buf, 0, bytes);
#line 51
  xfree((void *)buf);
#line 52
  return;
}
}
#line 1 "nchan.o"
#pragma merger(0,"./nchan.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 40 "nchan.c"
static void chan_send_ieof(Channel *c ) ;
#line 41
static void chan_send_oclose(Channel *c ) ;
#line 42
static void chan_shutdown_write(Channel *c ) ;
#line 43
static void chan_shutdown_read(Channel *c ) ;
#line 44
static void chan_delele_if_full_closed(Channel *c ) ;
#line 51 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 54
  switch (c->istate) {
  case 4: 
#line 56
  debug("channel %d: INPUT_WAIT_OCLOSE -> INPUT_CLOSED [rcvd OCLOSE]", c->self);
#line 57
  c->istate = 8;
#line 58
  chan_delele_if_full_closed(c);
#line 59
  break;
  case 1: 
#line 61
  debug("channel %d: INPUT_OPEN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
#line 62
  chan_shutdown_read(c);
#line 63
  chan_send_ieof(c);
#line 64
  c->istate = 8;
#line 65
  chan_delele_if_full_closed(c);
#line 66
  break;
  default: 
#line 68
  error("protocol error: chan_rcvd_oclose %d for istate %d", c->self, c->istate);
#line 69
  break;
  }
#line 71
  return;
}
}
#line 72 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 75
  switch (c->istate) {
  case 1: 
#line 77
  debug("channel %d: INPUT_OPEN -> INPUT_WAIT_DRAIN [read failed]", c->self);
#line 78
  chan_shutdown_read(c);
#line 79
  c->istate = 2;
#line 80
  break;
  default: 
#line 82
  error("internal error: we do not read, but chan_read_failed %d for istate %d", c->self,
        c->istate);
#line 84
  break;
  }
#line 86
  return;
}
}
#line 87 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 90
  tmp = buffer_len(& c->input);
#line 90
  if (tmp) {
#line 91
    error("internal error: chan_ibuf_empty %d for non empty buffer", c->self);
#line 92
    return;
  }
#line 94
  switch (c->istate) {
  case 2: 
#line 96
  debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_WAIT_OCLOSE [inbuf empty, send IEOF]",
        c->self);
#line 97
  chan_send_ieof(c);
#line 98
  c->istate = 4;
#line 99
  break;
  default: 
#line 101
  error("internal error: chan_ibuf_empty %d for istate %d", c->self, c->istate);
#line 102
  break;
  }
#line 104
  return;
}
}
#line 107 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ 

  {
#line 110
  switch (c->ostate) {
  case 16: 
#line 112
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_DRAIN [rvcd IEOF]", c->self);
#line 113
  c->ostate = 32;
#line 114
  break;
  case 64: 
#line 116
  debug("channel %d: OUTPUT_WAIT_IEOF -> OUTPUT_CLOSED [rvcd IEOF]", c->self);
#line 117
  c->ostate = 128;
#line 118
  chan_delele_if_full_closed(c);
#line 119
  break;
  default: 
#line 121
  error("protocol error: chan_rcvd_ieof %d for ostate %d", c->self, c->ostate);
#line 122
  break;
  }
#line 124
  return;
}
}
#line 125 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 128
  switch (c->ostate) {
  case 16: 
#line 130
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_IEOF [write failed]", c->self);
#line 131
  chan_send_oclose(c);
#line 132
  c->ostate = 64;
#line 133
  break;
  case 32: 
#line 135
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [write failed]", c->self);
#line 136
  chan_send_oclose(c);
#line 137
  c->ostate = 128;
#line 138
  chan_delele_if_full_closed(c);
#line 139
  break;
  default: 
#line 141
  error("internal error: chan_write_failed %d for ostate %d", c->self, c->ostate);
#line 142
  break;
  }
#line 144
  return;
}
}
#line 145 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 148
  tmp = buffer_len(& c->output);
#line 148
  if (tmp) {
#line 149
    debug("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 150
    return;
  }
#line 152
  switch (c->ostate) {
  case 32: 
#line 154
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [obuf empty, send OCLOSE]",
        c->self);
#line 155
  chan_send_oclose(c);
#line 156
  c->ostate = 128;
#line 157
  chan_delele_if_full_closed(c);
#line 158
  break;
  default: 
#line 160
  error("internal error: chan_obuf_empty %d for ostate %d", c->self, c->ostate);
#line 161
  break;
  }
#line 163
  return;
}
}
#line 168 "nchan.c"
static void chan_send_ieof(Channel *c ) 
{ 

  {
#line 171
  switch (c->istate) {
  case 1: 
  case 2: 
#line 174
  packet_start(24);
#line 175
  packet_put_int((unsigned int )c->remote_id);
#line 176
  packet_send();
#line 177
  break;
  default: 
#line 179
  error("internal error: channel %d: cannot send IEOF for istate %d", c->self, c->istate);
#line 180
  break;
  }
#line 182
  return;
}
}
#line 183 "nchan.c"
static void chan_send_oclose(Channel *c ) 
{ unsigned int tmp ;

  {
#line 186
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 189
  chan_shutdown_write(c);
#line 190
  tmp = buffer_len(& c->output);
#line 190
  buffer_consume(& c->output, tmp);
#line 191
  packet_start(25);
#line 192
  packet_put_int((unsigned int )c->remote_id);
#line 193
  packet_send();
#line 194
  break;
  default: 
#line 196
  error("internal error: channel %d: cannot send OCLOSE for ostate %d", c->self, c->istate);
#line 197
  break;
  }
#line 199
  return;
}
}
#line 202 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 206
  debug("channel %d: shutdown_write", c->self);
#line 207
  tmp___1 = shutdown(c->sock, 1);
#line 207
  if (tmp___1 < 0) {
#line 208
    tmp = __errno_location();
#line 208
    tmp___0 = strerror(*tmp);
#line 208
    debug("chan_shutdown_write failed for #%d/fd%d: %.100s", c->self, c->sock, tmp___0);
  }
#line 210
  return;
}
}
#line 211 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 214
  debug("channel %d: shutdown_read", c->self);
#line 215
  tmp___1 = shutdown(c->sock, 0);
#line 215
  if (tmp___1 < 0) {
#line 216
    tmp = __errno_location();
#line 216
    tmp___0 = strerror(*tmp);
#line 216
    error("chan_shutdown_read failed for #%d/fd%d: %.100s", c->self, c->sock, tmp___0);
  }
#line 218
  return;
}
}
#line 219 "nchan.c"
static void chan_delele_if_full_closed(Channel *c ) 
{ 

  {
#line 222
  if (c->istate == 8) {
#line 222
    if (c->ostate == 128) {
#line 223
      debug("channel %d: closing", c->self);
#line 224
      channel_free(c->self);
    }
  }
#line 226
  return;
}
}
#line 227 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 230
  c->ostate = 16;
#line 231
  c->istate = 1;
#line 232
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "packet.o"
#pragma merger(0,"./packet.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 35 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 38
void packet_set_nonblocking(void) ;
#line 50
void packet_close(void) ;
#line 57
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) ;
#line 65
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 68
unsigned int packet_get_protocol_flags(void) ;
#line 71
void packet_start_compression(int level ) ;
#line 77
void packet_set_interactive(int interactive , int keepalives ) ;
#line 86
void packet_put_char(int value ) ;
#line 92
void packet_put_bignum(BIGNUM *value ) ;
#line 104
int packet_read(int *payload_len_ptr ) ;
#line 120
int packet_read_poll(int *payload_len_ptr ) ;
#line 126
void packet_process_incoming(char const   *buf , unsigned int len ) ;
#line 129
unsigned int packet_get_char(void) ;
#line 138
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 166
void packet_send_debug(char const   *fmt  , ...) ;
#line 169
void packet_write_poll(void) ;
#line 175
int packet_have_data_to_write(void) ;
#line 178
int packet_not_very_much_data_to_write(void) ;
#line 182
int packet_set_maxsize(int s ) ;
#line 38 "packet.c"
static int connection_in  =    -1;
#line 39 "packet.c"
static int connection_out  =    -1;
#line 45 "packet.c"
static int cipher_type  =    0;
#line 48 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 51 "packet.c"
static CipherContext receive_context  ;
#line 54 "packet.c"
static CipherContext send_context  ;
#line 57 "packet.c"
static Buffer input  ;
#line 60 "packet.c"
static Buffer output  ;
#line 63 "packet.c"
static Buffer outgoing_packet  ;
#line 66 "packet.c"
static Buffer incoming_packet  ;
#line 69 "packet.c"
static Buffer compression_buffer  ;
#line 72 "packet.c"
static int packet_compression  =    0;
#line 75 "packet.c"
int max_packet_size  =    32768;
#line 78 "packet.c"
static int initialized  =    0;
#line 81 "packet.c"
static int interactive_mode  =    0;
#line 88 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 91
  connection_in = fd_in;
#line 92
  connection_out = fd_out;
#line 93
  cipher_type = 0;
#line 94
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 1);
#line 95
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 0);
#line 96
  if (! initialized) {
#line 97
    initialized = 1;
#line 98
    buffer_init(& input);
#line 99
    buffer_init(& output);
#line 100
    buffer_init(& outgoing_packet);
#line 101
    buffer_init(& incoming_packet);
  }
#line 104
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 105
  return;
}
}
#line 109 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 113
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 113
  if (tmp___1 < 0) {
#line 114
    tmp = __errno_location();
#line 114
    tmp___0 = strerror(*tmp);
#line 114
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 116
  if (connection_out != connection_in) {
#line 117
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 117
    if (tmp___4 < 0) {
#line 118
      tmp___2 = __errno_location();
#line 118
      tmp___3 = strerror(*tmp___2);
#line 118
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 120
  return;
}
}
#line 124 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 127
  return (connection_in);
}
}
#line 132 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 135
  return (connection_out);
}
}
#line 140 "packet.c"
void packet_close(void) 
{ 

  {
#line 143
  if (! initialized) {
#line 144
    return;
  }
#line 145
  initialized = 0;
#line 146
  if (connection_in == connection_out) {
#line 147
    shutdown(connection_out, 2);
#line 148
    close(connection_out);
  } else {
#line 150
    close(connection_in);
#line 151
    close(connection_out);
  }
#line 153
  buffer_free(& input);
#line 154
  buffer_free(& output);
#line 155
  buffer_free(& outgoing_packet);
#line 156
  buffer_free(& incoming_packet);
#line 157
  if (packet_compression) {
#line 158
    buffer_free(& compression_buffer);
#line 159
    buffer_compress_uninit();
  }
#line 161
  return;
}
}
#line 165 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 168
  remote_protocol_flags = protocol_flags;
#line 169
  channel_set_options((protocol_flags & 2U) != 0U);
#line 170
  return;
}
}
#line 174 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 177
  return (remote_protocol_flags);
}
}
#line 185 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 188
  if (packet_compression) {
#line 189
    fatal("Compression already enabled.");
  }
#line 190
  packet_compression = 1;
#line 191
  buffer_init(& compression_buffer);
#line 192
  buffer_compress_init(level);
#line 193
  return;
}
}
#line 200 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 204
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 205
  return;
}
}
#line 212 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 218
  if (bytes % 8U != 0U) {
#line 219
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  }
#line 226
  switch ((int )cc->type) {
  case 0: 
#line 228
  i = 0;
#line 229
  break;
  default: 
#line 231
  i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
#line 232
  break;
  }
#line 235
  if (i == 1) {
#line 236
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 238
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 239
  return;
}
}
#line 247 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) 
{ 

  {
#line 252
  cipher_set_key(& receive_context, cipher, key, (int )keylen, 0);
#line 253
  cipher_set_key(& send_context, cipher, key, (int )keylen, 1);
#line 254
  return;
}
}
#line 258 "packet.c"
void packet_start(int type ) 
{ char buf[9] ;

  {
#line 263
  buffer_clear(& outgoing_packet);
#line 264
  memset((void *)(buf), 0, 8U);
#line 265
  buf[8] = (char )type;
#line 266
  buffer_append(& outgoing_packet, (char const   *)(buf), 9U);
#line 267
  return;
}
}
#line 271 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 274
  ch = (char )value;
#line 275
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 276
  return;
}
}
#line 280 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 283
  buffer_put_int(& outgoing_packet, value);
#line 284
  return;
}
}
#line 288 "packet.c"
void packet_put_string(char const   *buf , unsigned int len ) 
{ 

  {
#line 291
  buffer_put_string(& outgoing_packet, (void const   *)buf, len);
#line 292
  return;
}
}
#line 296 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 299
  buffer_put_bignum(& outgoing_packet, value);
#line 300
  return;
}
}
#line 307 "packet.c"
void packet_send(void) 
{ char buf[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 313
  rand___0 = (u_int32_t )0;
#line 319
  if (packet_compression) {
#line 320
    buffer_clear(& compression_buffer);
#line 322
    buffer_consume(& outgoing_packet, 8U);
#line 324
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 325
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 326
    buffer_clear(& outgoing_packet);
#line 327
    tmp = buffer_len(& compression_buffer);
#line 327
    tmp___0 = buffer_ptr(& compression_buffer);
#line 327
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 331
  tmp___1 = buffer_len(& outgoing_packet);
#line 331
  len = (int )((tmp___1 + 4U) - 8U);
#line 334
  padding = 8 - len % 8;
#line 335
  if (cipher_type != 0) {
#line 336
    cp = buffer_ptr(& outgoing_packet);
#line 337
    i = 0;
#line 337
    while (i < padding) {
#line 338
      if (i % 4 == 0) {
#line 339
        rand___0 = arc4random();
      }
#line 340
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 341
      rand___0 >>= 8;
#line 337
      i ++;
    }
  }
#line 344
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 347
  tmp___2 = buffer_len(& outgoing_packet);
#line 347
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 347
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 349
  while (1) {
#line 349
    buf[0] = (char )(checksum >> 24);
#line 349
    buf[1] = (char )(checksum >> 16);
#line 349
    buf[2] = (char )(checksum >> 8);
#line 349
    buf[3] = (char )checksum;
#line 349
    break;
  }
#line 350
  buffer_append(& outgoing_packet, (char const   *)(buf), 4U);
#line 358
  while (1) {
#line 358
    buf[0] = (char )(len >> 24);
#line 358
    buf[1] = (char )(len >> 16);
#line 358
    buf[2] = (char )(len >> 8);
#line 358
    buf[3] = (char )len;
#line 358
    break;
  }
#line 359
  buffer_append(& output, (char const   *)(buf), 4U);
#line 360
  tmp___4 = buffer_len(& outgoing_packet);
#line 360
  buffer_append_space(& output, & cp, tmp___4);
#line 361
  tmp___5 = buffer_len(& outgoing_packet);
#line 361
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 361
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 369
  buffer_clear(& outgoing_packet);
#line 376
  return;
}
}
#line 384 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 392
  packet_write_wait();
#line 395
  while (1) {
#line 397
    type = packet_read_poll(payload_len_ptr);
#line 398
    if (type == 14) {
      goto _L;
    } else {
#line 398
      if (type == 15) {
        goto _L;
      } else {
#line 398
        if (type == 19) {
          goto _L;
        } else {
#line 398
          if (type == 33) {
            _L: /* CIL Label */ 
#line 402
            while (1) {
#line 402
              _p = *payload_len_ptr;
#line 402
              _e = 0;
#line 402
              if (_p != _e) {
#line 402
                log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                    402);
#line 402
                packet_disconnect("Packet integrity error. (%d)", type);
              }
#line 402
              break;
            }
          }
        }
      }
    }
#line 404
    if (type != 0) {
#line 405
      return (type);
    }
#line 410
    while (1) {
#line 410
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 410
      break;
    }
#line 411
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 414
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 417
    len = read(connection_in, (void *)(buf), sizeof(buf));
#line 418
    if (len == 0) {
#line 419
      tmp = get_remote_ipaddr();
#line 419
      fatal("Connection closed by %.200s", tmp);
    }
#line 420
    if (len < 0) {
#line 421
      tmp___0 = __errno_location();
#line 421
      tmp___1 = strerror(*tmp___0);
#line 421
      fatal("Read from socket failed: %.100s", tmp___1);
    }
#line 423
    packet_process_incoming((char const   *)(buf), (unsigned int )len);
  }
}
}
#line 433 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 438
  type = packet_read(payload_len_ptr);
#line 439
  if (type != expected_type) {
#line 440
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 442
  return;
}
}
#line 459 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  restart: 
#line 470
  tmp = buffer_len(& input);
#line 470
  if (tmp < 12U) {
#line 471
    return (0);
  }
#line 473
  tmp___0 = buffer_ptr(& input);
#line 473
  ucp = (unsigned char *)tmp___0;
#line 474
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 475
  if (len < 5U) {
#line 476
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 475
    if (len > 262144U) {
#line 476
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 477
  padded_len = (len + 8U) & 4294967288U;
#line 480
  tmp___1 = buffer_len(& input);
#line 480
  if (tmp___1 < 4U + padded_len) {
#line 481
    return (0);
  }
#line 486
  buffer_consume(& input, 4U);
#line 489
  buffer_clear(& incoming_packet);
#line 490
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 491
  tmp___2 = buffer_ptr(& input);
#line 491
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 492
  buffer_consume(& input, padded_len);
#line 500
  tmp___3 = buffer_len(& incoming_packet);
#line 500
  tmp___4 = buffer_ptr(& incoming_packet);
#line 500
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 504
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 508
  tmp___6 = buffer_len(& incoming_packet);
#line 508
  if (len != tmp___6) {
#line 509
    tmp___5 = buffer_len(& incoming_packet);
#line 509
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 512
  tmp___7 = buffer_ptr(& incoming_packet);
#line 512
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 513
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 514
  if (checksum != stored_checksum) {
#line 515
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 516
  buffer_consume_end(& incoming_packet, 4U);
#line 519
  if (packet_compression) {
#line 520
    buffer_clear(& compression_buffer);
#line 521
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 522
    buffer_clear(& incoming_packet);
#line 523
    tmp___8 = buffer_len(& compression_buffer);
#line 523
    tmp___9 = buffer_ptr(& compression_buffer);
#line 523
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 527
  buffer_get(& incoming_packet, buf, 1U);
#line 530
  tmp___10 = buffer_len(& incoming_packet);
#line 530
  *payload_len_ptr = (int )tmp___10;
#line 533
  if ((int )((unsigned char )buf[0]) == 1) {
#line 534
    tmp___11 = packet_get_string((unsigned int *)((void *)0));
#line 534
    log("Received disconnect: %.900s", tmp___11);
#line 535
    fatal_cleanup();
  }
#line 539
  if ((int )((unsigned char )buf[0]) == 32) {
    goto restart;
  }
#line 543
  if ((int )((unsigned char )buf[0]) == 36) {
#line 544
    tmp___12 = packet_get_string((unsigned int *)((void *)0));
#line 544
    debug("Remote: %.900s", tmp___12);
    goto restart;
  }
#line 548
  return ((int )((unsigned char )buf[0]));
}
}
#line 556 "packet.c"
void packet_process_incoming(char const   *buf , unsigned int len ) 
{ 

  {
#line 559
  buffer_append(& input, buf, len);
#line 560
  return;
}
}
#line 564 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 568
  buffer_get(& incoming_packet, & ch, 1U);
#line 569
  return ((unsigned int )((unsigned char )ch));
}
}
#line 574 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 577
  tmp = buffer_get_int(& incoming_packet);
#line 577
  return (tmp);
}
}
#line 585 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 588
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 589
  return;
}
}
#line 598 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 601
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 601
  return (tmp);
}
}
#line 613 "packet.c"
void packet_send_debug(char const   *fmt  , ...) 
{ char buf[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 619
  __builtin_va_start(args, fmt);
#line 620
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            args);
#line 621
  __builtin_va_end(args);
#line 623
  packet_start(36);
#line 624
  tmp = strlen((char const   *)(buf));
#line 624
  packet_put_string((char const   *)(buf), tmp);
#line 625
  packet_send();
#line 626
  packet_write_wait();
#line 627
  return;
}
}
#line 641 "packet.c"
static int disconnecting  =    0;
#line 636 "packet.c"
void packet_disconnect(char const   *fmt  , ...) 
{ char buf[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 642
  if (disconnecting) {
#line 643
    fatal("packet_disconnect called recursively.");
  }
#line 644
  disconnecting = 1;
#line 650
  __builtin_va_start(args, fmt);
#line 651
  vsnprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )fmt,
            args);
#line 652
  __builtin_va_end(args);
#line 655
  packet_start(1);
#line 656
  tmp = strlen((char const   *)(buf));
#line 656
  packet_put_string((char const   *)(buf), tmp);
#line 657
  packet_send();
#line 658
  packet_write_wait();
#line 661
  channel_stop_listening();
#line 664
  packet_close();
#line 667
  log("Disconnecting: %.100s", buf);
#line 668
  fatal_cleanup();
#line 669
  return;
}
}
#line 673 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 676
  tmp = buffer_len(& output);
#line 676
  len = (int )tmp;
#line 677
  if (len > 0) {
#line 678
    tmp___0 = buffer_ptr(& output);
#line 678
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 679
    if (len <= 0) {
#line 680
      tmp___3 = __errno_location();
#line 680
      if (*tmp___3 == 11) {
#line 681
        return;
      } else {
#line 683
        tmp___1 = __errno_location();
#line 683
        tmp___2 = strerror(*tmp___1);
#line 683
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 685
    buffer_consume(& output, (unsigned int )len);
  }
#line 687
  return;
}
}
#line 694 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 697
  packet_write_poll();
#line 698
  while (1) {
#line 698
    tmp = packet_have_data_to_write();
#line 698
    if (! tmp) {
#line 698
      break;
    }
#line 700
    while (1) {
#line 700
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 700
      break;
    }
#line 701
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 702
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 703
    packet_write_poll();
  }
#line 705
  return;
}
}
#line 709 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 712
  tmp = buffer_len(& output);
#line 712
  return (tmp != 0U);
}
}
#line 717 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 720
  if (interactive_mode) {
#line 721
    tmp = buffer_len(& output);
#line 721
    return (tmp < 16384U);
  } else {
#line 723
    tmp___0 = buffer_len(& output);
#line 723
    return (tmp___0 < 131072U);
  }
}
}
#line 728 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int lowdelay ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int throughput ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 731
  on = 1;
#line 734
  interactive_mode = interactive;
#line 740
  if (connection_in != connection_out) {
#line 741
    return;
  }
#line 743
  if (keepalives) {
#line 745
    tmp___1 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 745
    if (tmp___1 < 0) {
#line 747
      tmp = __errno_location();
#line 747
      tmp___0 = strerror(*tmp);
#line 747
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___0);
    }
  }
#line 749
  if (interactive) {
#line 754
    lowdelay = 16;
#line 755
    tmp___4 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 755
    if (tmp___4 < 0) {
#line 757
      tmp___2 = __errno_location();
#line 757
      tmp___3 = strerror(*tmp___2);
#line 757
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___3);
    }
#line 758
    tmp___7 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 758
    if (tmp___7 < 0) {
#line 760
      tmp___5 = __errno_location();
#line 760
      tmp___6 = strerror(*tmp___5);
#line 760
      error("setsockopt TCP_NODELAY: %.100s", tmp___6);
    }
  } else {
#line 766
    throughput = 8;
#line 767
    tmp___10 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 767
    if (tmp___10 < 0) {
#line 769
      tmp___8 = __errno_location();
#line 769
      tmp___9 = strerror(*tmp___8);
#line 769
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___9);
    }
  }
#line 771
  return;
}
}
#line 775 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 778
  return (interactive_mode);
}
}
#line 784 "packet.c"
static int called  =    0;
#line 781 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 785
  if (called) {
#line 786
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 787
    return (-1);
  }
#line 789
  if (s < 4096) {
#line 790
    log("packet_set_maxsize: bad size %d", s);
#line 791
    return (-1);
  } else {
#line 789
    if (s > 1048576) {
#line 790
      log("packet_set_maxsize: bad size %d", s);
#line 791
      return (-1);
    }
  }
#line 793
  log("packet_set_maxsize: setting to %d", s);
#line 794
  max_packet_size = s;
#line 795
  return (s);
}
}
#line 1 "readpass.o"
#pragma merger(0,"./readpass.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 425 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 45 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf[1024] ;
  char *p ;
  char ch ;
  struct termios tio ;
  struct termios saved_tio ;
  sigset_t oset ;
  sigset_t nset ;
  int input___0 ;
  int output___0 ;
  int echo ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 51
  echo = 0;
#line 53
  if (from_stdin) {
#line 54
    input___0 = 0;
#line 55
    output___0 = 2;
  } else {
#line 57
    output___0 = open("/dev/tty", 2);
#line 57
    input___0 = output___0;
  }
#line 59
  if (input___0 == -1) {
#line 60
    fatal("You have no controlling tty.  Cannot read passphrase.\n");
  }
#line 63
  sigemptyset(& nset);
#line 64
  sigaddset(& nset, 2);
#line 65
  sigaddset(& nset, 20);
#line 66
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 68
  tmp = tcgetattr(input___0, & tio);
#line 68
  if (tmp == 0) {
#line 68
    if (tio.c_lflag & 8U) {
#line 69
      echo = 1;
#line 70
      saved_tio = tio;
#line 71
      tio.c_lflag &= 4294967175U;
#line 72
      tcsetattr(input___0, 0, (struct termios  const  *)(& tio));
    }
  }
#line 75
  fflush(stdout);
#line 77
  tmp___0 = strlen(prompt);
#line 77
  write(output___0, (void const   *)prompt, tmp___0);
#line 78
  p = buf;
#line 78
  while (1) {
#line 78
    tmp___2 = read(input___0, (void *)(& ch), 1U);
#line 78
    if (tmp___2 == 1) {
#line 78
      if (! ((int )ch != 10)) {
#line 78
        break;
      }
    } else {
#line 78
      break;
    }
#line 79
    if ((unsigned int )p < (unsigned int )((buf + sizeof(buf)) - 1)) {
#line 80
      tmp___1 = p;
#line 80
      p ++;
#line 80
      *tmp___1 = ch;
    }
  }
#line 81
  *p = (char )'\000';
#line 82
  write(output___0, (void const   *)"\n", 1U);
#line 85
  if (echo) {
#line 86
    tcsetattr(input___0, 0, (struct termios  const  *)(& saved_tio));
  }
#line 87
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 89
  if (! from_stdin) {
#line 90
    close(input___0);
  }
#line 91
  p = xstrdup((char const   *)(buf));
#line 92
  memset((void *)(buf), 0, sizeof(buf));
#line 93
  return (p);
}
}
#line 1 "rsa.o"
#pragma merger(0,"./rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 34 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 40
void rsa_set_verbose(int verbose___0 ) ;
#line 42
int rsa_alive(void) ;
#line 44
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 45
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 44 "rsa.c"
int rsa_verbose  =    1;
#line 46 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 51
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 52
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 53
    return (0);
  }
#line 54
  RSA_free(key);
#line 55
  return (1);
}
}
#line 64 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 69
  if (rsa_verbose) {
#line 70
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 71
    fflush(stdout);
  }
#line 73
  key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                         (void *)0);
#line 74
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 75
    fatal("rsa_generate_key: key generation failed.");
  }
#line 78
  pub->n = BN_new();
#line 79
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 80
  pub->e = BN_new();
#line 81
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 84
  prv->n = BN_new();
#line 85
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 86
  prv->e = BN_new();
#line 87
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 88
  prv->d = BN_new();
#line 89
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 90
  prv->p = BN_new();
#line 91
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 92
  prv->q = BN_new();
#line 93
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 95
  prv->dmp1 = BN_new();
#line 96
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 98
  prv->dmq1 = BN_new();
#line 99
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 101
  prv->iqmp = BN_new();
#line 102
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 104
  RSA_free(key);
#line 106
  if (rsa_verbose) {
#line 107
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 108
  return;
}
}
#line 110 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ char *inbuf ;
  char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 116
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 116
  if (tmp < 2) {
#line 117
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 116
    if ((key->e)->top > 0) {
#line 116
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 117
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 117
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 119
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 119
  olen = (tmp___0 + 7) / 8;
#line 120
  tmp___1 = xmalloc((unsigned int )olen);
#line 120
  outbuf = (char *)tmp___1;
#line 122
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 122
  ilen = (tmp___2 + 7) / 8;
#line 123
  tmp___3 = xmalloc((unsigned int )ilen);
#line 123
  inbuf = (char *)tmp___3;
#line 124
  BN_bn2bin((BIGNUM const   *)in, (unsigned char *)inbuf);
#line 126
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, (unsigned char *)outbuf,
                           key, 1);
#line 126
  if (len <= 0) {
#line 128
    fatal("rsa_public_encrypt() failed");
  }
#line 130
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 132
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 133
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 134
  xfree((void *)outbuf);
#line 135
  xfree((void *)inbuf);
#line 136
  return;
}
}
#line 138 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ char *inbuf ;
  char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 144
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 144
  olen = (tmp + 7) / 8;
#line 145
  tmp___0 = xmalloc((unsigned int )olen);
#line 145
  outbuf = (char *)tmp___0;
#line 147
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 147
  ilen = (tmp___1 + 7) / 8;
#line 148
  tmp___2 = xmalloc((unsigned int )ilen);
#line 148
  inbuf = (char *)tmp___2;
#line 149
  BN_bn2bin((BIGNUM const   *)in, (unsigned char *)inbuf);
#line 151
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, (unsigned char *)outbuf,
                            key, 2);
#line 151
  if (len <= 0) {
#line 153
    fatal("rsa_private_decrypt() failed");
  }
#line 155
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 157
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 158
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 159
  xfree((void *)outbuf);
#line 160
  xfree((void *)inbuf);
#line 161
  return;
}
}
#line 165 "rsa.c"
void rsa_set_verbose(int verbose___0 ) 
{ 

  {
#line 168
  rsa_verbose = verbose___0;
#line 169
  return;
}
}
#line 1 "tildexpand.o"
#pragma merger(0,"./tildexpand.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 686 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 18 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 29
  if ((int const   )*(filename + 0) != 126) {
#line 30
    tmp = xstrdup(filename);
#line 30
    return (tmp);
  }
#line 33
  filename ++;
#line 36
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 36
  cp = (char const   *)tmp___1;
#line 37
  if (cp) {
#line 38
    userlen = (unsigned int )(cp - filename);
  } else {
#line 40
    userlen = strlen(filename);
  }
#line 41
  if (userlen == 0U) {
#line 42
    pw = getpwuid(my_uid);
  } else {
#line 45
    if (userlen > sizeof(user) - 1U) {
#line 46
      fatal("User name after tilde too long.");
    }
#line 47
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 48
    user[userlen] = (char)0;
#line 49
    pw = getpwnam((char const   *)(user));
  }
#line 51
  if (! pw) {
#line 52
    fatal("Unknown user %100s.", user);
  }
#line 55
  if (! cp) {
#line 57
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 57
    return (tmp___2);
  }
#line 60
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 60
  tmp___4 = strlen(cp + 1);
#line 60
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 61
  if (len > 4096) {
#line 62
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 63
  tmp___5 = xmalloc((unsigned int )len);
#line 63
  expanded = (char *)tmp___5;
#line 64
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 65
  return (expanded);
}
}
#line 1 "ttymodes.o"
#pragma merger(0,"./ttymodes.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 186 "packet.h"
void tty_make_modes(int fd ) ;
#line 189
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 26 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 29
  switch ((int )speed) {
  case 0: 
#line 31
  return (0);
  case 1: 
#line 33
  return (50);
  case 2: 
#line 35
  return (75);
  case 3: 
#line 37
  return (110);
  case 4: 
#line 39
  return (134);
  case 5: 
#line 41
  return (150);
  case 6: 
#line 43
  return (200);
  case 7: 
#line 45
  return (300);
  case 8: 
#line 47
  return (600);
  case 9: 
#line 49
  return (1200);
  case 10: 
#line 51
  return (1800);
  case 11: 
#line 53
  return (2400);
  case 12: 
#line 55
  return (4800);
  case 13: 
#line 57
  return (9600);
  case 14: 
#line 61
  return (19200);
  case 15: 
#line 71
  return (38400);
  case 4097: 
#line 93
  return (57600);
  case 4098: 
#line 101
  return (115200);
  case 4099: 
#line 105
  return (230400);
  default: ;
#line 108
  return (9600);
  }
}
}
#line 115 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 118
  switch (baud) {
  case 0: 
#line 120
  return (0U);
  case 50: 
#line 122
  return (1U);
  case 75: 
#line 124
  return (2U);
  case 110: 
#line 126
  return (3U);
  case 134: 
#line 128
  return (4U);
  case 150: 
#line 130
  return (5U);
  case 200: 
#line 132
  return (6U);
  case 300: 
#line 134
  return (7U);
  case 600: 
#line 136
  return (8U);
  case 1200: 
#line 138
  return (9U);
  case 1800: 
#line 140
  return (10U);
  case 2400: 
#line 142
  return (11U);
  case 4800: 
#line 144
  return (12U);
  case 9600: 
#line 146
  return (13U);
  case 19200: 
#line 150
  return (14U);
  case 38400: 
#line 160
  return (15U);
  case 57600: 
#line 182
  return (4097U);
  case 115200: 
#line 190
  return (4098U);
  case 230400: 
#line 194
  return (4099U);
  default: ;
#line 197
  return (13U);
  }
}
}
#line 206 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 212
  tmp___1 = tcgetattr(fd, & tio);
#line 212
  if (tmp___1 < 0) {
#line 213
    packet_put_char(0);
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    log("tcgetattr: %.100s", tmp___0);
#line 215
    return;
  }
#line 218
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 218
  baud = speed_to_baud(tmp___2);
#line 219
  packet_put_char(193);
#line 220
  packet_put_int((unsigned int )baud);
#line 221
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 221
  baud = speed_to_baud(tmp___3);
#line 222
  packet_put_char(192);
#line 223
  packet_put_int((unsigned int )baud);
#line 37 "ttymodes.h"
  packet_put_char(1);
#line 37
  packet_put_char((int )tio.c_cc[0]);
#line 38
  packet_put_char(2);
#line 38
  packet_put_char((int )tio.c_cc[1]);
#line 39
  packet_put_char(3);
#line 39
  packet_put_char((int )tio.c_cc[2]);
#line 41
  packet_put_char(4);
#line 41
  packet_put_char((int )tio.c_cc[3]);
#line 43
  packet_put_char(5);
#line 43
  packet_put_char((int )tio.c_cc[4]);
#line 45
  packet_put_char(6);
#line 45
  packet_put_char((int )tio.c_cc[11]);
#line 48
  packet_put_char(7);
#line 48
  packet_put_char((int )tio.c_cc[16]);
#line 50
  packet_put_char(8);
#line 50
  packet_put_char((int )tio.c_cc[8]);
#line 51
  packet_put_char(9);
#line 51
  packet_put_char((int )tio.c_cc[9]);
#line 53
  packet_put_char(10);
#line 53
  packet_put_char((int )tio.c_cc[10]);
#line 59
  packet_put_char(12);
#line 59
  packet_put_char((int )tio.c_cc[12]);
#line 62
  packet_put_char(13);
#line 62
  packet_put_char((int )tio.c_cc[14]);
#line 65
  packet_put_char(14);
#line 65
  packet_put_char((int )tio.c_cc[15]);
#line 77
  packet_put_char(18);
#line 77
  packet_put_char((int )tio.c_cc[13]);
#line 81
  packet_put_char(30);
#line 81
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 82
  packet_put_char(31);
#line 82
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 83
  packet_put_char(32);
#line 83
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 84
  packet_put_char(33);
#line 84
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 85
  packet_put_char(34);
#line 85
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 86
  packet_put_char(35);
#line 86
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 87
  packet_put_char(36);
#line 87
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 89
  packet_put_char(37);
#line 89
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 91
  packet_put_char(38);
#line 91
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 92
  packet_put_char(39);
#line 92
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 93
  packet_put_char(40);
#line 93
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 95
  packet_put_char(41);
#line 95
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 98
  packet_put_char(50);
#line 98
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 99
  packet_put_char(51);
#line 99
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 101
  packet_put_char(52);
#line 101
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 103
  packet_put_char(53);
#line 103
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 104
  packet_put_char(54);
#line 104
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 105
  packet_put_char(55);
#line 105
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 106
  packet_put_char(56);
#line 106
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 107
  packet_put_char(57);
#line 107
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 108
  packet_put_char(58);
#line 108
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 110
  packet_put_char(59);
#line 110
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 113
  packet_put_char(60);
#line 113
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 116
  packet_put_char(61);
#line 116
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 119
  packet_put_char(62);
#line 119
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 122
  packet_put_char(70);
#line 122
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 124
  packet_put_char(71);
#line 124
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 126
  packet_put_char(72);
#line 126
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 128
  packet_put_char(73);
#line 128
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 131
  packet_put_char(74);
#line 131
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 134
  packet_put_char(75);
#line 134
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 137
  packet_put_char(90);
#line 137
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 138
  packet_put_char(91);
#line 138
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 139
  packet_put_char(92);
#line 139
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 140
  packet_put_char(93);
#line 140
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 243 "ttymodes.c"
  packet_put_char(0);
#line 244
  return;
}
}
#line 250 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 255
  n_bytes = 0;
#line 256
  failure = 0;
#line 263
  tmp = tcgetattr(fd, & tio);
#line 263
  if (tmp < 0) {
#line 264
    failure = -1;
  }
#line 266
  while (1) {
#line 267
    n_bytes ++;
#line 268
    tmp___0 = packet_get_char();
#line 268
    opcode = (int )tmp___0;
#line 269
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 274
    n_bytes += 4;
#line 275
    tmp___1 = packet_get_int();
#line 275
    baud = (int )tmp___1;
#line 276
    if (failure != -1) {
#line 276
      tmp___2 = baud_to_speed(baud);
#line 276
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 276
      if (tmp___3 < 0) {
#line 277
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 278
    break;
    case 193: 
#line 281
    n_bytes += 4;
#line 282
    tmp___4 = packet_get_int();
#line 282
    baud = (int )tmp___4;
#line 283
    if (failure != -1) {
#line 283
      tmp___5 = baud_to_speed(baud);
#line 283
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 283
      if (tmp___6 < 0) {
#line 284
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 285
    break;
    case 1: 
#line 37 "ttymodes.h"
    n_bytes ++;
#line 37
    tmp___7 = packet_get_char();
#line 37
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 37
    break;
    case 2: 
#line 38
    n_bytes ++;
#line 38
    tmp___8 = packet_get_char();
#line 38
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 38
    break;
    case 3: 
#line 39
    n_bytes ++;
#line 39
    tmp___9 = packet_get_char();
#line 39
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 39
    break;
    case 4: 
#line 41
    n_bytes ++;
#line 41
    tmp___10 = packet_get_char();
#line 41
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 41
    break;
    case 5: 
#line 43
    n_bytes ++;
#line 43
    tmp___11 = packet_get_char();
#line 43
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 43
    break;
    case 6: 
#line 45
    n_bytes ++;
#line 45
    tmp___12 = packet_get_char();
#line 45
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 45
    break;
    case 7: 
#line 48
    n_bytes ++;
#line 48
    tmp___13 = packet_get_char();
#line 48
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 48
    break;
    case 8: 
#line 50
    n_bytes ++;
#line 50
    tmp___14 = packet_get_char();
#line 50
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 50
    break;
    case 9: 
#line 51
    n_bytes ++;
#line 51
    tmp___15 = packet_get_char();
#line 51
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 51
    break;
    case 10: 
#line 53
    n_bytes ++;
#line 53
    tmp___16 = packet_get_char();
#line 53
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 53
    break;
    case 12: 
#line 59
    n_bytes ++;
#line 59
    tmp___17 = packet_get_char();
#line 59
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 59
    break;
    case 13: 
#line 62
    n_bytes ++;
#line 62
    tmp___18 = packet_get_char();
#line 62
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 62
    break;
    case 14: 
#line 65
    n_bytes ++;
#line 65
    tmp___19 = packet_get_char();
#line 65
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 65
    break;
    case 18: 
#line 77
    n_bytes ++;
#line 77
    tmp___20 = packet_get_char();
#line 77
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 77
    break;
    case 30: 
#line 81
    n_bytes ++;
#line 81
    tmp___21 = packet_get_char();
#line 81
    if (tmp___21) {
#line 81
      tio.c_iflag |= 4U;
    } else {
#line 81
      tio.c_iflag &= 4294967291U;
    }
#line 81
    break;
    case 31: 
#line 82
    n_bytes ++;
#line 82
    tmp___22 = packet_get_char();
#line 82
    if (tmp___22) {
#line 82
      tio.c_iflag |= 8U;
    } else {
#line 82
      tio.c_iflag &= 4294967287U;
    }
#line 82
    break;
    case 32: 
#line 83
    n_bytes ++;
#line 83
    tmp___23 = packet_get_char();
#line 83
    if (tmp___23) {
#line 83
      tio.c_iflag |= 16U;
    } else {
#line 83
      tio.c_iflag &= 4294967279U;
    }
#line 83
    break;
    case 33: 
#line 84
    n_bytes ++;
#line 84
    tmp___24 = packet_get_char();
#line 84
    if (tmp___24) {
#line 84
      tio.c_iflag |= 32U;
    } else {
#line 84
      tio.c_iflag &= 4294967263U;
    }
#line 84
    break;
    case 34: 
#line 85
    n_bytes ++;
#line 85
    tmp___25 = packet_get_char();
#line 85
    if (tmp___25) {
#line 85
      tio.c_iflag |= 64U;
    } else {
#line 85
      tio.c_iflag &= 4294967231U;
    }
#line 85
    break;
    case 35: 
#line 86
    n_bytes ++;
#line 86
    tmp___26 = packet_get_char();
#line 86
    if (tmp___26) {
#line 86
      tio.c_iflag |= 128U;
    } else {
#line 86
      tio.c_iflag &= 4294967167U;
    }
#line 86
    break;
    case 36: 
#line 87
    n_bytes ++;
#line 87
    tmp___27 = packet_get_char();
#line 87
    if (tmp___27) {
#line 87
      tio.c_iflag |= 256U;
    } else {
#line 87
      tio.c_iflag &= 4294967039U;
    }
#line 87
    break;
    case 37: 
#line 89
    n_bytes ++;
#line 89
    tmp___28 = packet_get_char();
#line 89
    if (tmp___28) {
#line 89
      tio.c_iflag |= 512U;
    } else {
#line 89
      tio.c_iflag &= 4294966783U;
    }
#line 89
    break;
    case 38: 
#line 91
    n_bytes ++;
#line 91
    tmp___29 = packet_get_char();
#line 91
    if (tmp___29) {
#line 91
      tio.c_iflag |= 1024U;
    } else {
#line 91
      tio.c_iflag &= 4294966271U;
    }
#line 91
    break;
    case 39: 
#line 92
    n_bytes ++;
#line 92
    tmp___30 = packet_get_char();
#line 92
    if (tmp___30) {
#line 92
      tio.c_iflag |= 2048U;
    } else {
#line 92
      tio.c_iflag &= 4294965247U;
    }
#line 92
    break;
    case 40: 
#line 93
    n_bytes ++;
#line 93
    tmp___31 = packet_get_char();
#line 93
    if (tmp___31) {
#line 93
      tio.c_iflag |= 4096U;
    } else {
#line 93
      tio.c_iflag &= 4294963199U;
    }
#line 93
    break;
    case 41: 
#line 95
    n_bytes ++;
#line 95
    tmp___32 = packet_get_char();
#line 95
    if (tmp___32) {
#line 95
      tio.c_iflag |= 8192U;
    } else {
#line 95
      tio.c_iflag &= 4294959103U;
    }
#line 95
    break;
    case 50: 
#line 98
    n_bytes ++;
#line 98
    tmp___33 = packet_get_char();
#line 98
    if (tmp___33) {
#line 98
      tio.c_lflag |= 1U;
    } else {
#line 98
      tio.c_lflag &= 4294967294U;
    }
#line 98
    break;
    case 51: 
#line 99
    n_bytes ++;
#line 99
    tmp___34 = packet_get_char();
#line 99
    if (tmp___34) {
#line 99
      tio.c_lflag |= 2U;
    } else {
#line 99
      tio.c_lflag &= 4294967293U;
    }
#line 99
    break;
    case 52: 
#line 101
    n_bytes ++;
#line 101
    tmp___35 = packet_get_char();
#line 101
    if (tmp___35) {
#line 101
      tio.c_lflag |= 4U;
    } else {
#line 101
      tio.c_lflag &= 4294967291U;
    }
#line 101
    break;
    case 53: 
#line 103
    n_bytes ++;
#line 103
    tmp___36 = packet_get_char();
#line 103
    if (tmp___36) {
#line 103
      tio.c_lflag |= 8U;
    } else {
#line 103
      tio.c_lflag &= 4294967287U;
    }
#line 103
    break;
    case 54: 
#line 104
    n_bytes ++;
#line 104
    tmp___37 = packet_get_char();
#line 104
    if (tmp___37) {
#line 104
      tio.c_lflag |= 16U;
    } else {
#line 104
      tio.c_lflag &= 4294967279U;
    }
#line 104
    break;
    case 55: 
#line 105
    n_bytes ++;
#line 105
    tmp___38 = packet_get_char();
#line 105
    if (tmp___38) {
#line 105
      tio.c_lflag |= 32U;
    } else {
#line 105
      tio.c_lflag &= 4294967263U;
    }
#line 105
    break;
    case 56: 
#line 106
    n_bytes ++;
#line 106
    tmp___39 = packet_get_char();
#line 106
    if (tmp___39) {
#line 106
      tio.c_lflag |= 64U;
    } else {
#line 106
      tio.c_lflag &= 4294967231U;
    }
#line 106
    break;
    case 57: 
#line 107
    n_bytes ++;
#line 107
    tmp___40 = packet_get_char();
#line 107
    if (tmp___40) {
#line 107
      tio.c_lflag |= 128U;
    } else {
#line 107
      tio.c_lflag &= 4294967167U;
    }
#line 107
    break;
    case 58: 
#line 108
    n_bytes ++;
#line 108
    tmp___41 = packet_get_char();
#line 108
    if (tmp___41) {
#line 108
      tio.c_lflag |= 256U;
    } else {
#line 108
      tio.c_lflag &= 4294967039U;
    }
#line 108
    break;
    case 59: 
#line 110
    n_bytes ++;
#line 110
    tmp___42 = packet_get_char();
#line 110
    if (tmp___42) {
#line 110
      tio.c_lflag |= 32768U;
    } else {
#line 110
      tio.c_lflag &= 4294934527U;
    }
#line 110
    break;
    case 60: 
#line 113
    n_bytes ++;
#line 113
    tmp___43 = packet_get_char();
#line 113
    if (tmp___43) {
#line 113
      tio.c_lflag |= 512U;
    } else {
#line 113
      tio.c_lflag &= 4294966783U;
    }
#line 113
    break;
    case 61: 
#line 116
    n_bytes ++;
#line 116
    tmp___44 = packet_get_char();
#line 116
    if (tmp___44) {
#line 116
      tio.c_lflag |= 2048U;
    } else {
#line 116
      tio.c_lflag &= 4294965247U;
    }
#line 116
    break;
    case 62: 
#line 119
    n_bytes ++;
#line 119
    tmp___45 = packet_get_char();
#line 119
    if (tmp___45) {
#line 119
      tio.c_lflag |= 16384U;
    } else {
#line 119
      tio.c_lflag &= 4294950911U;
    }
#line 119
    break;
    case 70: 
#line 122
    n_bytes ++;
#line 122
    tmp___46 = packet_get_char();
#line 122
    if (tmp___46) {
#line 122
      tio.c_oflag |= 1U;
    } else {
#line 122
      tio.c_oflag &= 4294967294U;
    }
#line 122
    break;
    case 71: 
#line 124
    n_bytes ++;
#line 124
    tmp___47 = packet_get_char();
#line 124
    if (tmp___47) {
#line 124
      tio.c_oflag |= 2U;
    } else {
#line 124
      tio.c_oflag &= 4294967293U;
    }
#line 124
    break;
    case 72: 
#line 126
    n_bytes ++;
#line 126
    tmp___48 = packet_get_char();
#line 126
    if (tmp___48) {
#line 126
      tio.c_oflag |= 4U;
    } else {
#line 126
      tio.c_oflag &= 4294967291U;
    }
#line 126
    break;
    case 73: 
#line 128
    n_bytes ++;
#line 128
    tmp___49 = packet_get_char();
#line 128
    if (tmp___49) {
#line 128
      tio.c_oflag |= 8U;
    } else {
#line 128
      tio.c_oflag &= 4294967287U;
    }
#line 128
    break;
    case 74: 
#line 131
    n_bytes ++;
#line 131
    tmp___50 = packet_get_char();
#line 131
    if (tmp___50) {
#line 131
      tio.c_oflag |= 16U;
    } else {
#line 131
      tio.c_oflag &= 4294967279U;
    }
#line 131
    break;
    case 75: 
#line 134
    n_bytes ++;
#line 134
    tmp___51 = packet_get_char();
#line 134
    if (tmp___51) {
#line 134
      tio.c_oflag |= 32U;
    } else {
#line 134
      tio.c_oflag &= 4294967263U;
    }
#line 134
    break;
    case 90: 
#line 137
    n_bytes ++;
#line 137
    tmp___52 = packet_get_char();
#line 137
    if (tmp___52) {
#line 137
      tio.c_cflag |= 32U;
    } else {
#line 137
      tio.c_cflag &= 4294967263U;
    }
#line 137
    break;
    case 91: 
#line 138
    n_bytes ++;
#line 138
    tmp___53 = packet_get_char();
#line 138
    if (tmp___53) {
#line 138
      tio.c_cflag |= 48U;
    } else {
#line 138
      tio.c_cflag &= 4294967247U;
    }
#line 138
    break;
    case 92: 
#line 139
    n_bytes ++;
#line 139
    tmp___54 = packet_get_char();
#line 139
    if (tmp___54) {
#line 139
      tio.c_cflag |= 256U;
    } else {
#line 139
      tio.c_cflag &= 4294967039U;
    }
#line 139
    break;
    case 93: 
#line 140
    n_bytes ++;
#line 140
    tmp___55 = packet_get_char();
#line 140
    if (tmp___55) {
#line 140
      tio.c_cflag |= 512U;
    } else {
#line 140
      tio.c_cflag &= 4294966783U;
    }
#line 140
    break;
    default: 
#line 313 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 320
        n_bytes ++;
#line 321
        packet_get_char();
#line 322
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 329
          n_bytes += 4;
#line 330
          packet_get_int();
#line 331
          break;
        }
      }
    }
#line 341
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 342
    while (1) {
#line 342
      _p = 0;
#line 342
      _e = 1;
#line 342
      if (_p != _e) {
#line 342
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 342);
#line 342
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 342
      break;
    }
    goto set;
    }
  }
  set: 
#line 348
  if (*n_bytes_ptr != n_bytes) {
#line 349
    *n_bytes_ptr = n_bytes;
#line 350
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#pragma merger(0,"./uidswap.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 34 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 31 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 37 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 42
  saved_euid = geteuid();
#line 45
  tmp___1 = seteuid(uid);
#line 45
  if (tmp___1 == -1) {
#line 46
    tmp = __errno_location();
#line 46
    tmp___0 = strerror(*tmp);
#line 46
    debug("seteuid %d: %.100s", (int )uid, tmp___0);
  }
#line 56
  return;
}
}
#line 61 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 66
  tmp___1 = seteuid(saved_euid);
#line 66
  if (tmp___1 < 0) {
#line 67
    tmp = __errno_location();
#line 67
    tmp___0 = strerror(*tmp);
#line 67
    debug("seteuid %d: %.100s", (int )saved_euid, tmp___0);
  }
#line 76
  return;
}
}
#line 82 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 85
  tmp___1 = setuid(uid);
#line 85
  if (tmp___1 < 0) {
#line 86
    tmp = __errno_location();
#line 86
    tmp___0 = strerror(*tmp);
#line 86
    debug("setuid %d: %.100s", (int )uid, tmp___0);
  }
#line 87
  return;
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"./xmalloc.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 15 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 18
  tmp = malloc(size);
#line 18
  ptr = tmp;
#line 19
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 20
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 21
  return (ptr);
}
}
#line 24 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 31
  new_ptr = realloc(ptr, new_size);
#line 32
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 33
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 34
  return (new_ptr);
}
}
#line 37 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 40
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 41
    fatal("xfree: NULL pointer given as argument");
  }
#line 42
  free(ptr);
#line 43
  return;
}
}
#line 45 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 48
  tmp = strlen(str);
#line 48
  len = (int )(tmp + 1U);
#line 50
  tmp___0 = xmalloc((unsigned int )len);
#line 50
  cp = (char *)tmp___0;
#line 51
  strlcpy(cp, str, (unsigned int )len);
#line 52
  return (cp);
}
}
#line 1 "helper.o"
#pragma merger(0,"./helper.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 43 "helper.h"
void arc4random_stir(void) ;
#line 47
void setproctitle(char const   *fmt  , ...) ;
#line 66 "helper.c"
void get_random_bytes(unsigned char *buf , int len ) ;
#line 67
void rc4_key(rc4_t *r , unsigned char *key , int len ) ;
#line 68
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) ;
#line 70 "helper.c"
static rc4_t *rc4  =    (rc4_t *)((void *)0);
#line 72 "helper.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) 
{ int t ;

  {
#line 76
  r->i = 0;
#line 76
  while (r->i < 256) {
#line 77
    r->s[r->i] = (unsigned int )r->i;
#line 76
    (r->i) ++;
  }
#line 79
  r->j = 0;
#line 80
  r->i = 0;
#line 80
  while (r->i < 256) {
#line 82
    r->j = (int )((((unsigned int )r->j + r->s[r->i]) + (unsigned int )*(key + r->i % len)) % 256U);
#line 83
    t = (int )r->s[r->i];
#line 84
    r->s[r->i] = r->s[r->j];
#line 85
    r->s[r->j] = (unsigned int )t;
#line 80
    (r->i) ++;
  }
#line 87
  r->j = 0;
#line 87
  r->i = r->j;
#line 88
  return;
}
}
#line 90 "helper.c"
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) 
{ int t ;
  int c ;

  {
#line 95
  c = 0;
#line 96
  while (c < len) {
#line 98
    r->i = (r->i + 1) % 256;
#line 99
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 100
    t = (int )r->s[r->i];
#line 101
    r->s[r->i] = r->s[r->j];
#line 102
    r->s[r->j] = (unsigned int )t;
#line 104
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 106
    *(buffer + c) = (unsigned char )r->s[t];
#line 107
    c ++;
  }
#line 109
  return;
}
}
#line 111 "helper.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 115
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 116
    arc4random_stir();
  }
#line 118
  rc4_getbytes(rc4, (unsigned char *)(& r), (int )sizeof(r));
#line 120
  return (r);
}
}
#line 123 "helper.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[32] ;
  void *tmp ;

  {
#line 127
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 128
    tmp = xmalloc(sizeof(*rc4));
#line 128
    rc4 = (rc4_t *)tmp;
  }
#line 130
  get_random_bytes(rand_buf, (int )sizeof(rand_buf));
#line 131
  rc4_key(rc4, rand_buf, (int )sizeof(rand_buf));
#line 132
  return;
}
}
#line 136 "helper.c"
static int random_pool  ;
#line 134 "helper.c"
void get_random_bytes(unsigned char *buf , int len ) 
{ int c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 174
  random_pool = open("/dev/urandom", 0);
#line 175
  if (random_pool == -1) {
#line 176
    tmp = __errno_location();
#line 176
    tmp___0 = strerror(*tmp);
#line 176
    fatal("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
  }
#line 180
  c = atomicio((int (*)())(& read), random_pool, (void *)buf, (unsigned int )len);
#line 181
  if (c <= 0) {
#line 182
    tmp___1 = __errno_location();
#line 182
    tmp___2 = strerror(*tmp___1);
#line 182
    fatal("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
  }
#line 184
  close(random_pool);
#line 185
  return;
}
}
#line 189 "helper.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 192
  return;
}
}
#line 1 "bsd-mktemp.o"
#pragma merger(0,"./bsd-mktemp.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-strlcpy.o"
#pragma merger(0,"./bsd-strlcpy.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 45 "bsd-strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "bsd-strlcat.o"
#pragma merger(0,"./bsd-strlcat.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "bsd-strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "log.o"
#pragma merger(0,"./log.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 487 "ssh.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 490
SyslogFacility log_facility_number(char *name ) ;
#line 491
LogLevel log_level_number(char *name ) ;
#line 511
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 13 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 17
  __builtin_va_start(args, fmt);
#line 18
  do_log(1, fmt, args);
#line 19
  __builtin_va_end(args);
#line 20
  fatal_cleanup();
#line 21
  return;
}
}
#line 25 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 29
  __builtin_va_start(args, fmt);
#line 30
  do_log(2, fmt, args);
#line 31
  __builtin_va_end(args);
#line 32
  return;
}
}
#line 36 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 40
  __builtin_va_start(args, fmt);
#line 41
  do_log(3, fmt, args);
#line 42
  __builtin_va_end(args);
#line 43
  return;
}
}
#line 47 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 51
  __builtin_va_start(args, fmt);
#line 52
  do_log(4, fmt, args);
#line 53
  __builtin_va_end(args);
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(5, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 75 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 79 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 84
  tmp = xmalloc(sizeof(*cu));
#line 84
  cu = (struct fatal_cleanup *)tmp;
#line 85
  cu->proc = proc;
#line 86
  cu->context = context;
#line 87
  cu->next = fatal_cleanups;
#line 88
  fatal_cleanups = cu;
#line 89
  return;
}
}
#line 93 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 98
  cup = & fatal_cleanups;
#line 98
  while (*cup) {
#line 99
    cu = *cup;
#line 100
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 100
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 101
        *cup = cu->next;
#line 102
        xfree((void *)cu);
#line 103
        return;
      }
    }
#line 98
    cup = & cu->next;
  }
#line 106
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 108
  return;
}
}
#line 115 "log.c"
static int called___0  =    0;
#line 111 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 117
  if (called___0) {
#line 118
    exit(255);
  }
#line 119
  called___0 = 1;
#line 121
  cu = fatal_cleanups;
#line 121
  while (cu) {
#line 122
    next_cu = cu->next;
#line 123
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 125
    (*(cu->proc))(cu->context);
#line 121
    cu = next_cu;
  }
#line 127
  exit(255);
}
}
#line 132 "log.c"
static struct __anonstruct_log_facilities_74 log_facilities[12]  = 
#line 132
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 150 "log.c"
static struct __anonstruct_log_levels_75 log_levels[7]  = {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 164 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 168
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 169
    i = 0;
#line 169
    while (log_facilities[i].name) {
#line 170
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 170
      if (tmp == 0) {
#line 171
        return (log_facilities[i].val);
      }
#line 169
      i ++;
    }
  }
#line 172
  return ((enum __anonenum_SyslogFacility_72 )-1);
}
}
#line 175 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 179
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 180
    i = 0;
#line 180
    while (log_levels[i].name) {
#line 181
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 181
      if (tmp == 0) {
#line 182
        return (log_levels[i].val);
      }
#line 180
      i ++;
    }
  }
#line 183
  return ((enum __anonenum_LogLevel_73 )-1);
}
}
#line 1 "fingerprint.o"
#pragma merger(0,"./fingerprint.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 51 "fingerprint.c"
static char retval[80]  ;
#line 48 "fingerprint.c"
char *fingerprint(BIGNUM *e , BIGNUM *n___0 ) 
{ MD5_CTX md ;
  unsigned char d[16] ;
  char *buf ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 57
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 57
  nlen = (tmp + 7) / 8;
#line 58
  tmp___0 = BN_num_bits((BIGNUM const   *)e);
#line 58
  elen = (tmp___0 + 7) / 8;
#line 60
  tmp___1 = xmalloc((unsigned int )(nlen + elen));
#line 60
  buf = (char *)tmp___1;
#line 62
  BN_bn2bin((BIGNUM const   *)n___0, (unsigned char *)buf);
#line 63
  BN_bn2bin((BIGNUM const   *)e, (unsigned char *)(buf + nlen));
#line 65
  MD5_Init(& md);
#line 66
  MD5_Update(& md, (void const   *)buf, (unsigned int )(nlen + elen));
#line 67
  MD5_Final(d, & md);
#line 68
  snprintf((char * __restrict  )(retval), sizeof(retval), (char const   * __restrict  )"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
           d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11],
           d[12], d[13], d[14], d[15]);
#line 71
  memset((void *)buf, 0, (unsigned int )(nlen + elen));
#line 72
  xfree((void *)buf);
#line 73
  return (retval);
}
}
#line 1 "sshd.o"
#pragma merger(0,"./sshd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 117 "/usr/include/netdb.h"
extern void endhostent(void) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 747
extern void perror(char const   *__s ) ;
#line 759
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 709
extern int mkstemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 103
extern struct group *getgrgid(__gid_t __gid ) ;
#line 109
extern struct group *getgrnam(char const   *__name ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 433
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 438
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 182
extern char ** __attribute__((__nonnull__(1))) pam_getenvlist(pam_handle_t *pamh ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 58 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 275 "ssh.h"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf ,
                                  unsigned int bufsize ) ;
#line 283
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr_in *addr ) ;
#line 291
void record_logout(int pid , char const   *ttyname___0 ) ;
#line 330
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 336
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , BIGNUM *client_host_key_e ,
                    BIGNUM *client_host_key_n ) ;
#line 344
int auth_password(struct passwd *pw , char const   *password ) ;
#line 351
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 484
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 695
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 27 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 33
void pty_release(char const   *ttyname___0 ) ;
#line 39
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 42
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 91 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 97
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 100
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 42 "sshd.c"
static char *xauthfile  =    (char *)((void *)0);
#line 45 "sshd.c"
ServerOptions options  ;
#line 48 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 56 "sshd.c"
int debug_flag  =    0;
#line 59 "sshd.c"
int inetd_flag  =    0;
#line 62 "sshd.c"
int log_stderr  =    0;
#line 65 "sshd.c"
char *av0  ;
#line 68 "sshd.c"
char **saved_argv  ;
#line 74 "sshd.c"
int listen_sock  ;
#line 80 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 83 "sshd.c"
int no_port_forwarding_flag  =    0;
#line 84 "sshd.c"
int no_agent_forwarding_flag  =    0;
#line 85 "sshd.c"
int no_x11_forwarding_flag  =    0;
#line 86 "sshd.c"
int no_pty_flag  =    0;
#line 89 "sshd.c"
char *forced_command  =    (char *)((void *)0);
#line 92 "sshd.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 95 "sshd.c"
unsigned char session_id[16]  ;
#line 105 "sshd.c"
struct __anonstruct_sensitive_data_76 sensitive_data  ;
#line 114 "sshd.c"
int key_used  =    0;
#line 117 "sshd.c"
int received_sighup  =    0;
#line 121 "sshd.c"
RSA *public_key  ;
#line 124
void do_connection(void) ;
#line 125
void do_authentication(char *user ) ;
#line 126
void do_authloop(struct passwd *pw ) ;
#line 127
void do_fake_authloop(char *user ) ;
#line 128
void do_authenticated(struct passwd *pw ) ;
#line 129
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) ;
#line 133
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) ;
#line 136
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 141
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 143
void do_pam_account(char *username , char *remote_user ) ;
#line 144
void do_pam_session(char *username , char *ttyname___0 ) ;
#line 145
void pam_cleanup_proc(void *context ) ;
#line 147 "sshd.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 151 "sshd.c"
struct pam_handle_t *pamh  =    (struct pam_handle_t *)((void *)0);
#line 152 "sshd.c"
char const   *pampasswd  =    (char const   *)((void *)0);
#line 153 "sshd.c"
char *pamconv_msg  =    (char *)((void *)0);
#line 155 "sshd.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ struct pam_response *reply ;
  int count ;
  size_t msg_len ;
  char *p ;
  void *tmp ;
  size_t n___0 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 164
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 164
  reply = (struct pam_response *)tmp;
#line 165
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 166
    return (19);
  }
#line 168
  count = 0;
#line 168
  while (count < num_msg) {
#line 169
    switch ((int )(*(msg + count))->msg_style) {
    case 1: 
#line 171
    if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 172
      free((void *)reply);
#line 173
      return (19);
    }
#line 175
    (reply + count)->resp_retcode = 0;
#line 176
    (reply + count)->resp = xstrdup(pampasswd);
#line 177
    break;
    case 4: 
#line 180
    (reply + count)->resp_retcode = 0;
#line 181
    (reply + count)->resp = xstrdup("");
#line 183
    if ((unsigned int )(*(msg + count))->msg == (unsigned int )((void *)0)) {
#line 184
      break;
    }
#line 186
    debug("Adding PAM message: %s", (*(msg + count))->msg);
#line 188
    msg_len = strlen((char const   *)(*(msg + count))->msg);
#line 189
    if (pamconv_msg) {
#line 190
      tmp___0 = strlen((char const   *)pamconv_msg);
#line 190
      n___0 = tmp___0;
#line 191
      tmp___1 = xrealloc((void *)pamconv_msg, (n___0 + msg_len) + 2U);
#line 191
      pamconv_msg = (char *)tmp___1;
#line 192
      p = pamconv_msg + n___0;
    } else {
#line 194
      tmp___2 = xmalloc(msg_len + 2U);
#line 194
      p = (char *)tmp___2;
#line 194
      pamconv_msg = p;
    }
#line 196
    memcpy((void * __restrict  )p, (void const   * __restrict  )(*(msg + count))->msg,
           msg_len);
#line 197
    *(p + msg_len) = (char )'\n';
#line 198
    *(p + (msg_len + 1U)) = (char )'\000';
#line 199
    break;
    case 2: 
    case 3: 
    default: 
#line 204
    free((void *)reply);
#line 205
    return (19);
    }
#line 168
    count ++;
  }
#line 209
  *resp = reply;
#line 211
  return (0);
}
}
#line 214 "sshd.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 218
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 220
    tmp = pam_close_session((pam_handle_t *)pamh, 0);
#line 220
    pam_retval = (int )tmp;
#line 221
    if (pam_retval != 0) {
#line 222
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 222
      log("Cannot close PAM session: %.200s", tmp___0);
    }
#line 226
    tmp___1 = pam_end((pam_handle_t *)pamh, pam_retval);
#line 226
    pam_retval = (int )tmp___1;
#line 227
    if (pam_retval != 0) {
#line 228
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 228
      log("Cannot release PAM authentication: %.200s", tmp___2);
    }
  }
#line 232
  return;
}
}
#line 234 "sshd.c"
void do_pam_account(char *username , char *remote_user ) 
{ int pam_retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 238
  tmp = get_canonical_hostname();
#line 238
  debug("PAM setting rhost to \"%.200s\"", tmp);
#line 239
  tmp___0 = get_canonical_hostname();
#line 239
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 4, (void const   *)tmp___0);
#line 239
  pam_retval = (int )tmp___1;
#line 241
  if (pam_retval != 0) {
#line 242
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 242
    log("PAM set rhost failed: %.200s", tmp___2);
#line 243
    do_fake_authloop(username);
  }
#line 246
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 247
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 248
    tmp___3 = pam_set_item((pam_handle_t *)pamh, 8, (void const   *)remote_user);
#line 248
    pam_retval = (int )tmp___3;
#line 249
    if (pam_retval != 0) {
#line 250
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 250
      log("PAM set ruser failed: %.200s", tmp___4);
#line 251
      do_fake_authloop(username);
    }
  }
#line 255
  tmp___5 = pam_acct_mgmt((pam_handle_t *)pamh, 0);
#line 255
  pam_retval = (int )tmp___5;
#line 256
  if (pam_retval != 0) {
#line 257
    tmp___6 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 257
    log("PAM rejected by account configuration: %.200s", tmp___6);
#line 258
    do_fake_authloop(username);
  }
#line 260
  return;
}
}
#line 262 "sshd.c"
void do_pam_session(char *username , char *ttyname___0 ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 266
  if ((unsigned int )ttyname___0 != (unsigned int )((void *)0)) {
#line 267
    debug("PAM setting tty to \"%.200s\"", ttyname___0);
#line 268
    tmp = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)ttyname___0);
#line 268
    pam_retval = (int )tmp;
#line 269
    if (pam_retval != 0) {
#line 270
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 270
      fatal("PAM set tty failed: %.200s", tmp___0);
    }
  }
#line 273
  tmp___1 = pam_open_session((pam_handle_t *)pamh, 0);
#line 273
  pam_retval = (int )tmp___1;
#line 274
  if (pam_retval != 0) {
#line 275
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 275
    fatal("PAM session setup failed: %.200s", tmp___2);
  }
#line 276
  return;
}
}
#line 284 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 287
  received_sighup = 1;
#line 288
  signal(1, & sighup_handler);
#line 289
  return;
}
}
#line 295 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 298
  log("Received SIGHUP; restarting.");
#line 299
  close(listen_sock);
#line 300
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 301
  tmp = __errno_location();
#line 301
  tmp___0 = strerror(*tmp);
#line 301
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 302
  exit(1);
}
}
#line 310 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 313
  log("Received signal %d; terminating.", sig);
#line 314
  close(listen_sock);
#line 315
  exit(255);
}
}
#line 322 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 325
  tmp = __errno_location();
#line 325
  save_errno = *tmp;
#line 328
  while (1) {
#line 328
    tmp___0 = waitpid(-1, & status, 1);
#line 328
    if (! (tmp___0 > 0)) {
#line 328
      break;
    }
  }
#line 331
  signal(17, & main_sigchld_handler);
#line 332
  tmp___1 = __errno_location();
#line 332
  *tmp___1 = save_errno;
#line 333
  return;
}
}
#line 338 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 342
  packet_close();
#line 345
  tmp = get_remote_ipaddr();
#line 345
  fatal("Timeout before authentication for %s.", tmp);
#line 346
  return;
}
}
#line 351 "sshd.c"
char *get_authname(int type ) 
{ 

  {
#line 354
  switch (type) {
  case 9: 
#line 356
  return ((char *)"password");
  case 6: 
#line 358
  return ((char *)"rsa");
  case 35: 
#line 360
  return ((char *)"rhosts-rsa");
  case 5: 
#line 362
  return ((char *)"rhosts");
  }
#line 372
  fatal("get_authname: unknown auth %d: internal error", type);
#line 373
  return ((char *)((void *)0));
}
}
#line 383 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 386
  tmp = __errno_location();
#line 386
  save_errno = *tmp;
#line 389
  if (key_used) {
#line 391
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 393
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 394
      RSA_free(sensitive_data.private_key);
    }
#line 395
    sensitive_data.private_key = RSA_new();
#line 397
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 398
      RSA_free(public_key);
    }
#line 399
    public_key = RSA_new();
#line 401
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 403
    arc4random_stir();
#line 404
    key_used = 0;
#line 405
    log("RSA key generation complete.");
  }
#line 408
  signal(14, & key_regeneration_alarm);
#line 409
  alarm((unsigned int )options.key_regeneration_time);
#line 410
  tmp___0 = __errno_location();
#line 410
  *tmp___0 = save_errno;
#line 411
  return;
}
}
#line 416 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int aux ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int i ;
  int pid ;
  int on ;
  int remote_major ;
  int remote_minor ;
  int silentrsa ;
  struct pollfd fds ;
  struct sockaddr_in sin ;
  char buf[100] ;
  char remote_version[100] ;
  char const   *remote_ip ;
  int remote_port ;
  char *comment ;
  FILE *f ;
  struct linger linger ;
  char *tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int fd ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int s1 ;
  int s2 ;
  int *tmp___13 ;
  char *tmp___14 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  __pid_t tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  char const   *tmp___35 ;
  ssize_t tmp___36 ;
  char *s ;
  size_t tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  char *s___0 ;
  size_t tmp___40 ;
  char const   *tmp___41 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  int retval___0 ;
  int __attribute__((__nonnull__(1)))  tmp___52 ;
  int __attribute__((__nonnull__(1)))  tmp___53 ;

  {
#line 421
  on = 1;
#line 423
  silentrsa = 0;
#line 435
  saved_argv = av;
#line 436
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 436
  if (tmp___1) {
#line 437
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 437
    av0 = tmp + 1;
  } else {
#line 439
    av0 = *(av + 0);
  }
#line 442
  initialize_server_options(& options);
#line 445
  while (1) {
#line 445
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:diqQ");
#line 445
    if (! (opt != -1)) {
#line 445
      break;
    }
#line 446
    switch (opt) {
    case 102: 
#line 448
    config_file_name = optarg;
#line 449
    break;
    case 100: 
#line 451
    debug_flag = 1;
#line 452
    options.log_level = 5;
#line 453
    break;
    case 105: 
#line 455
    inetd_flag = 1;
#line 456
    break;
    case 81: 
#line 458
    silentrsa = 1;
#line 459
    break;
    case 113: 
#line 461
    options.log_level = 0;
#line 462
    break;
    case 98: 
#line 464
    options.server_key_bits = atoi((char const   *)optarg);
#line 465
    break;
    case 112: 
#line 467
    options.port = atoi((char const   *)optarg);
#line 468
    break;
    case 103: 
#line 470
    options.login_grace_time = atoi((char const   *)optarg);
#line 471
    break;
    case 107: 
#line 473
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 474
    break;
    case 104: 
#line 476
    options.host_key_file = optarg;
#line 477
    break;
    case 86: 
#line 479
    client_version_string = optarg;
#line 481
    inetd_flag = 1;
#line 482
    break;
    case 63: 
    default: 
#line 485
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH-1.2");
#line 486
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 487
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 488
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 489
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 490
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 491
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 492
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 493
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 494
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 495
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 496
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 498
    exit(1);
    }
  }
#line 503
  tmp___2 = rsa_alive();
#line 503
  if (tmp___2 == 0) {
#line 504
    if (silentrsa == 0) {
#line 505
      printf((char const   * __restrict  )"sshd: no RSA support in libssl and libcrypto -- exiting.  See ssl(8)\n");
    }
#line 506
    log("no RSA support in libssl and libcrypto -- exiting.  See ssl(8)");
#line 507
    exit(1);
  }
#line 510
  read_server_config(& options, (char const   *)config_file_name);
#line 513
  fill_default_server_options(& options);
#line 516
  if (options.server_key_bits < 512) {
#line 518
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 519
    exit(1);
  } else {
#line 516
    if (options.server_key_bits > 32768) {
#line 518
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 519
      exit(1);
    }
  }
#line 521
  if (options.port < 1) {
#line 522
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 523
    exit(1);
  } else {
#line 521
    if (options.port > 65535) {
#line 522
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 523
      exit(1);
    }
  }
#line 526
  if (optind < ac) {
#line 527
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 528
    exit(1);
  }
#line 532
  log_init(av0, options.log_level, options.log_facility, ! inetd_flag);
#line 534
  debug("sshd version %.100s", "OpenSSH-1.2");
#line 536
  sensitive_data.host_key = RSA_new();
#line 537
  tmp___3 = __errno_location();
#line 537
  *tmp___3 = 0;
#line 539
  tmp___6 = load_private_key((char const   *)options.host_key_file, "", sensitive_data.host_key,
                             & comment);
#line 539
  if (! tmp___6) {
#line 541
    tmp___4 = __errno_location();
#line 541
    tmp___5 = strerror(*tmp___4);
#line 541
    error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___5);
#line 543
    exit(1);
  }
#line 545
  xfree((void *)comment);
#line 549
  if (debug_flag) {
#line 549
    if (! inetd_flag) {
#line 550
      log_stderr = 1;
    }
  }
#line 551
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 556
  if (! debug_flag) {
#line 556
    if (! inetd_flag) {
#line 560
      tmp___9 = daemon(0, 0);
#line 560
      if (tmp___9 < 0) {
#line 561
        tmp___7 = __errno_location();
#line 561
        tmp___8 = strerror(*tmp___7);
#line 561
        fatal("daemon() failed: %.200s", tmp___8);
      }
#line 565
      fd = open("/dev/tty", 258);
#line 566
      if (fd >= 0) {
#line 567
        ioctl(fd, 21538UL, (void *)0);
#line 568
        close(fd);
      }
    }
  }
#line 573
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 578
  tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 578
  if (options.server_key_bits > tmp___11 - 128) {
#line 578
    tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 578
    if (options.server_key_bits < tmp___12 + 128) {
#line 582
      tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 582
      options.server_key_bits = tmp___10 + 128;
#line 584
      debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
    }
  }
#line 588
  rsa_set_verbose(0);
#line 591
  arc4random_stir();
#line 595
  chdir("/");
#line 598
  cipher_attack_detected = & packet_disconnect;
#line 601
  if (inetd_flag) {
#line 603
    s1 = dup(0);
#line 604
    s2 = dup(s1);
#line 605
    sock_in = dup(0);
#line 606
    sock_out = dup(1);
#line 610
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 612
    public_key = RSA_new();
#line 613
    sensitive_data.private_key = RSA_new();
#line 615
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 616
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 618
    arc4random_stir();
#line 619
    log("RSA key generation complete.");
  } else {
#line 622
    listen_sock = socket(2, 1, 0);
#line 623
    if (listen_sock < 0) {
#line 624
      tmp___13 = __errno_location();
#line 624
      tmp___14 = strerror(*tmp___13);
#line 624
      fatal("socket: %.100s", tmp___14);
    }
#line 629
    setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 631
    linger.l_onoff = 1;
#line 632
    linger.l_linger = 5;
#line 633
    setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 636
    memset((void *)(& sin), 0, sizeof(sin));
#line 637
    sin.sin_family = (unsigned short)2;
#line 638
    sin.sin_addr = options.listen_addr;
#line 639
    __x = (unsigned short )options.port;
#line 639
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 639
    sin.sin_port = __v;
#line 641
    tmp___17 = bind(listen_sock, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                    sizeof(sin));
#line 641
    if (tmp___17 < 0) {
#line 642
      tmp___15 = __errno_location();
#line 642
      tmp___16 = strerror(*tmp___15);
#line 642
      error("bind: %.100s", tmp___16);
#line 643
      shutdown(listen_sock, 2);
#line 644
      close(listen_sock);
#line 645
      fatal("Bind to port %d failed.", options.port);
    }
#line 647
    if (! debug_flag) {
#line 655
      f = fopen((char const   * __restrict  )"/var/run/sshd.pid", (char const   * __restrict  )"w");
#line 656
      if (f) {
#line 657
        tmp___18 = getpid();
#line 657
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___18);
#line 658
        fclose(f);
      }
    }
#line 662
    log("Server listening on port %d.", options.port);
#line 663
    tmp___21 = listen(listen_sock, 5);
#line 663
    if (tmp___21 < 0) {
#line 664
      tmp___19 = __errno_location();
#line 664
      tmp___20 = strerror(*tmp___19);
#line 664
      fatal("listen: %.100s", tmp___20);
    }
#line 666
    public_key = RSA_new();
#line 667
    sensitive_data.private_key = RSA_new();
#line 669
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 670
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 672
    arc4random_stir();
#line 673
    log("RSA key generation complete.");
#line 676
    signal(14, & key_regeneration_alarm);
#line 677
    alarm((unsigned int )options.key_regeneration_time);
#line 680
    signal(1, & sighup_handler);
#line 681
    signal(15, & sigterm_handler);
#line 682
    signal(3, & sigterm_handler);
#line 685
    signal(17, & main_sigchld_handler);
#line 691
    while (1) {
#line 692
      if (received_sighup) {
#line 693
        sighup_restart();
      }
#line 695
      memset((void *)(& fds), 0, sizeof(fds));
#line 696
      fds.fd = listen_sock;
#line 697
      fds.events = (short)1;
#line 698
      tmp___25 = poll(& fds, 1UL, -1);
#line 698
      if (tmp___25 == -1) {
#line 699
        tmp___22 = __errno_location();
#line 699
        if (*tmp___22 == 4) {
          goto __Cont;
        }
#line 701
        tmp___23 = __errno_location();
#line 701
        tmp___24 = strerror(*tmp___23);
#line 701
        fatal("poll: %.100s", tmp___24);
      }
#line 704
      if ((int )fds.revents == 0) {
        goto __Cont;
      }
#line 706
      aux = (int )sizeof(sin);
#line 707
      newsock = accept(listen_sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& sin)),
                       (socklen_t * __restrict  )(& aux));
#line 708
      if (received_sighup) {
#line 709
        sighup_restart();
      }
#line 710
      if (newsock < 0) {
#line 711
        tmp___26 = __errno_location();
#line 711
        if (*tmp___26 == 4) {
          goto __Cont;
        }
#line 713
        tmp___27 = __errno_location();
#line 713
        tmp___28 = strerror(*tmp___27);
#line 713
        error("accept: %.100s", tmp___28);
        goto __Cont;
      }
#line 720
      if (debug_flag) {
#line 726
        debug("Server will not fork when running in debugging mode.");
#line 727
        close(listen_sock);
#line 728
        sock_in = newsock;
#line 729
        sock_out = newsock;
#line 730
        pid = getpid();
#line 731
        break;
      } else {
#line 738
        pid = fork();
#line 738
        if (pid == 0) {
#line 744
          close(listen_sock);
#line 745
          sock_in = newsock;
#line 746
          sock_out = newsock;
#line 747
          log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 748
          break;
        }
      }
#line 753
      if (pid < 0) {
#line 754
        tmp___29 = __errno_location();
#line 754
        tmp___30 = strerror(*tmp___29);
#line 754
        error("fork: %.100s", tmp___30);
      } else {
#line 756
        debug("Forked child %d.", pid);
      }
#line 759
      key_used = 1;
#line 761
      arc4random_stir();
#line 764
      close(newsock);
      __Cont: /* CIL Label */ ;
    }
  }
#line 775
  alarm(0U);
#line 776
  signal(14, (void (*)(int  ))0);
#line 777
  signal(1, (void (*)(int  ))0);
#line 778
  signal(15, (void (*)(int  ))0);
#line 779
  signal(3, (void (*)(int  ))0);
#line 780
  signal(17, (void (*)(int  ))0);
#line 788
  linger.l_onoff = 1;
#line 789
  linger.l_linger = 5;
#line 790
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 796
  packet_set_connection(sock_in, sock_out);
#line 798
  remote_port = get_remote_port();
#line 799
  remote_ip = get_remote_ipaddr();
#line 818
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 829
  signal(14, & grace_alarm_handler);
#line 830
  if (! debug_flag) {
#line 831
    alarm((unsigned int )options.login_grace_time);
  }
#line 833
  if ((unsigned int )client_version_string != (unsigned int )((void *)0)) {
#line 835
    strlcpy(buf, (char const   *)client_version_string, sizeof(buf));
  } else {
#line 838
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
             1, 5, "OpenSSH-1.2");
#line 840
    tmp___32 = strlen((char const   *)(buf));
#line 840
    tmp___33 = atomicio((int (*)())(& write), sock_out, (void *)(buf), tmp___32);
#line 840
    tmp___34 = strlen((char const   *)(buf));
#line 840
    if ((size_t )tmp___33 != tmp___34) {
#line 841
      tmp___31 = get_remote_ipaddr();
#line 841
      fatal("Could not write ident string to %s.", tmp___31);
    }
#line 844
    i = 0;
#line 844
    while ((unsigned int )i < sizeof(buf) - 1U) {
#line 845
      tmp___36 = read(sock_in, (void *)(& buf[i]), 1U);
#line 845
      if (tmp___36 != 1) {
#line 846
        tmp___35 = get_remote_ipaddr();
#line 846
        fatal("Did not receive ident string from %s.", tmp___35);
      }
#line 847
      if ((int )buf[i] == 13) {
#line 848
        buf[i] = (char )'\n';
#line 849
        buf[i + 1] = (char)0;
#line 850
        break;
      }
#line 852
      if ((int )buf[i] == 10) {
#line 854
        buf[i + 1] = (char)0;
#line 855
        break;
      }
#line 844
      i ++;
    }
#line 858
    buf[sizeof(buf) - 1U] = (char)0;
  }
#line 865
  tmp___39 = sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 865
  if (tmp___39 != 3) {
#line 867
    s = (char *)"Protocol mismatch.\n";
#line 869
    tmp___37 = strlen((char const   *)s);
#line 869
    atomicio((int (*)())(& write), sock_out, (void *)s, tmp___37);
#line 870
    close(sock_in);
#line 871
    close(sock_out);
#line 872
    tmp___38 = get_remote_ipaddr();
#line 872
    fatal("Bad protocol version identification \'%.100s\' from %s", buf, tmp___38);
  }
#line 875
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 877
  if (remote_major != 1) {
#line 878
    s___0 = (char *)"Protocol major versions differ.\n";
#line 880
    tmp___40 = strlen((char const   *)s___0);
#line 880
    atomicio((int (*)())(& write), sock_out, (void *)s___0, tmp___40);
#line 881
    close(sock_in);
#line 882
    close(sock_out);
#line 883
    tmp___41 = get_remote_ipaddr();
#line 883
    fatal("Protocol major versions differ for %s: %d vs. %d", tmp___41, 1, remote_major);
  }
#line 888
  if (remote_major == 1) {
#line 888
    if (remote_minor < 3) {
#line 889
      packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
    }
  }
#line 891
  if (remote_major == 1) {
#line 891
    if (remote_minor == 3) {
#line 892
      enable_compat13();
#line 893
      if (0) {
#line 893
        __s1_len = strlen((char const   *)(remote_version));
#line 893
        __s2_len = strlen("OpenSSH-1.1");
#line 893
        if (! ((unsigned int )((void const   *)(remote_version + 1)) - (unsigned int )((void const   *)(remote_version)) == 1U)) {
          goto _L___0;
        } else {
#line 893
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 893
            if (! ((unsigned int )((void const   *)("OpenSSH-1.1" + 1)) - (unsigned int )((void const   *)"OpenSSH-1.1") == 1U)) {
#line 893
              tmp___51 = 1;
            } else {
#line 893
              if (__s2_len >= 4U) {
#line 893
                tmp___51 = 1;
              } else {
#line 893
                tmp___51 = 0;
              }
            }
          } else {
#line 893
            tmp___51 = 0;
          }
        }
#line 893
        if (tmp___51) {
#line 893
          tmp___47 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
        } else {
#line 893
          tmp___50 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
#line 893
          tmp___47 = tmp___50;
        }
      } else {
#line 893
        tmp___50 = __builtin_strcmp((char const   *)(remote_version), "OpenSSH-1.1");
#line 893
        tmp___47 = tmp___50;
      }
#line 893
      if (tmp___47 != 0) {
#line 894
        debug("Agent forwarding disabled, remote version is not compatible.");
#line 895
        no_agent_forwarding_flag = 1;
      }
    }
  }
#line 905
  if (remote_port >= 1024) {
#line 907
    options.rhosts_authentication = 0;
#line 908
    options.rhosts_rsa_authentication = 0;
  } else {
#line 905
    if (remote_port < 512) {
#line 907
      options.rhosts_authentication = 0;
#line 908
      options.rhosts_rsa_authentication = 0;
    }
  }
#line 910
  packet_set_nonblocking();
#line 913
  do_connection();
#line 922
  if (xauthfile) {
#line 923
    unlink((char const   *)xauthfile);
  }
#line 926
  verbose("Closing connection to %.100s", remote_ip);
#line 932
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 933
    debug("Closing PAM session.");
#line 934
    tmp___52 = pam_close_session((pam_handle_t *)pamh, 0);
#line 934
    retval___0 = (int )tmp___52;
#line 936
    debug("Terminating PAM library.");
#line 937
    tmp___53 = pam_end((pam_handle_t *)pamh, retval___0);
#line 937
    if (tmp___53 != (int __attribute__((__nonnull__(1)))  )0) {
#line 938
      log("Cannot release PAM authentication.");
    }
#line 940
    fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
  }
#line 945
  packet_close();
#line 946
  exit(0);
}
}
#line 954 "sshd.c"
void do_connection(void) 
{ int i ;
  int len ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char check_bytes[8] ;
  char *user ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  int plen ;
  int slen ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int ulen ;
  int _p___0 ;
  int _e___0 ;

  {
#line 964
  rand___0 = (u_int32_t )0;
#line 975
  i = 0;
#line 975
  while (i < 8) {
#line 976
    if (i % 4 == 0) {
#line 977
      rand___0 = arc4random();
    }
#line 978
    check_bytes[i] = (unsigned char )(rand___0 & 255U);
#line 979
    rand___0 >>= 8;
#line 975
    i ++;
  }
#line 987
  packet_start(2);
#line 988
  i = 0;
#line 988
  while (i < 8) {
#line 989
    packet_put_char((int )check_bytes[i]);
#line 988
    i ++;
  }
#line 992
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 992
  packet_put_int((unsigned int )tmp);
#line 993
  packet_put_bignum(public_key->e);
#line 994
  packet_put_bignum(public_key->n);
#line 997
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 997
  packet_put_int((unsigned int )tmp___0);
#line 998
  packet_put_bignum((sensitive_data.host_key)->e);
#line 999
  packet_put_bignum((sensitive_data.host_key)->n);
#line 1002
  packet_put_int(2U);
#line 1005
  tmp___1 = cipher_mask();
#line 1005
  packet_put_int(tmp___1);
#line 1008
  auth_mask = 0U;
#line 1009
  if (options.rhosts_authentication) {
#line 1010
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1011
  if (options.rhosts_rsa_authentication) {
#line 1012
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1013
  if (options.rsa_authentication) {
#line 1014
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1029
  if (options.password_authentication) {
#line 1030
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1031
  packet_put_int(auth_mask);
#line 1034
  packet_send();
#line 1035
  packet_write_wait();
#line 1037
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1037
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1037
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 1041
  packet_read_expect(& plen, 3);
#line 1044
  cipher_type___0 = packet_get_char();
#line 1046
  tmp___4 = cipher_mask();
#line 1046
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1047
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1051
  i = 0;
#line 1051
  while (i < 8) {
#line 1052
    tmp___5 = packet_get_char();
#line 1052
    if ((unsigned int )check_bytes[i] != tmp___5) {
#line 1053
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1051
    i ++;
  }
#line 1055
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1055
  debug("Encryption type: %.200s", tmp___6);
#line 1058
  session_key_int = BN_new();
#line 1059
  packet_get_bignum(session_key_int, & slen);
#line 1061
  protocol_flags = packet_get_int();
#line 1062
  packet_set_protocol_flags(protocol_flags);
#line 1064
  while (1) {
#line 1064
    _p = plen;
#line 1064
    _e = (9 + slen) + 4;
#line 1064
    if (_p != _e) {
#line 1064
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1064);
#line 1064
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1064
    break;
  }
#line 1070
  tmp___17 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1070
  if (tmp___17 > 0) {
#line 1072
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1072
    tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1072
    if (tmp___10 < tmp___11 + 128) {
#line 1074
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1074
      tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1074
      tmp___9 = get_remote_ipaddr();
#line 1074
      fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1080
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 1082
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1086
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1086
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1086
    if (tmp___15 < tmp___16 + 128) {
#line 1088
      tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1088
      tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1088
      tmp___14 = get_remote_ipaddr();
#line 1088
      fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___14, tmp___13, tmp___12, 128);
    }
#line 1094
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1096
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1100
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(check_bytes),
                     (sensitive_data.host_key)->n, (sensitive_data.private_key)->n);
#line 1109
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1110
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1110
  len = (tmp___18 + 7) / 8;
#line 1111
  if (len < 0) {
#line 1112
    tmp___19 = get_remote_ipaddr();
#line 1112
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
          tmp___19, len, sizeof(session_key));
  } else {
#line 1111
    if ((unsigned int )len > sizeof(session_key)) {
#line 1112
      tmp___19 = get_remote_ipaddr();
#line 1112
      fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
            tmp___19, len, sizeof(session_key));
    }
  }
#line 1115
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1116
  BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1119
  i = 0;
#line 1119
  while (i < 16) {
#line 1120
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1119
    i ++;
  }
#line 1123
  BN_clear_free(session_key_int);
#line 1126
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1129
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1131
  debug("Received session key; encryption turned on.");
#line 1134
  packet_start(14);
#line 1135
  packet_send();
#line 1136
  packet_write_wait();
#line 1139
  packet_read_expect(& plen, 4);
#line 1144
  user = packet_get_string((unsigned int *)(& ulen));
#line 1145
  while (1) {
#line 1145
    _p___0 = plen;
#line 1145
    _e___0 = 4 + ulen;
#line 1145
    if (_p___0 != _e___0) {
#line 1145
      log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
          1145);
#line 1145
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 1145
    break;
  }
#line 1149
  RSA_free(public_key);
#line 1150
  RSA_free(sensitive_data.private_key);
#line 1151
  RSA_free(sensitive_data.host_key);
#line 1153
  setproctitle("%s", user);
#line 1155
  do_authentication(user);
#line 1156
  return;
}
}
#line 1166 "sshd.c"
static int allowed_user(struct passwd *pw ) 
{ struct group *grp ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1173
  if (! pw) {
#line 1174
    return (0);
  }
#line 1179
  if (options.num_deny_users > 0U) {
#line 1180
    if (! pw->pw_name) {
#line 1181
      return (0);
    }
#line 1182
    i = 0;
#line 1182
    while ((unsigned int )i < options.num_deny_users) {
#line 1183
      tmp = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 1183
      if (tmp) {
#line 1184
        return (0);
      }
#line 1182
      i ++;
    }
  }
#line 1187
  if (options.num_allow_users > 0U) {
#line 1188
    if (! pw->pw_name) {
#line 1189
      return (0);
    }
#line 1190
    i = 0;
#line 1190
    while ((unsigned int )i < options.num_allow_users) {
#line 1191
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 1191
      if (tmp___0) {
#line 1192
        break;
      }
#line 1190
      i ++;
    }
#line 1194
    if ((unsigned int )i >= options.num_allow_users) {
#line 1195
      return (0);
    }
  }
#line 1198
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 1198
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 1199
      grp = getgrgid(pw->pw_gid);
#line 1200
      if (! grp) {
#line 1201
        return (0);
      }
#line 1204
      if (options.num_deny_groups > 0U) {
#line 1205
        if (! grp->gr_name) {
#line 1206
          return (0);
        }
#line 1207
        i = 0;
#line 1207
        while ((unsigned int )i < options.num_deny_groups) {
#line 1208
          tmp___1 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 1208
          if (tmp___1) {
#line 1209
            return (0);
          }
#line 1207
          i ++;
        }
      }
#line 1215
      if (options.num_allow_groups > 0U) {
#line 1216
        if (! grp->gr_name) {
#line 1217
          return (0);
        }
#line 1218
        i = 0;
#line 1218
        while ((unsigned int )i < options.num_allow_groups) {
#line 1219
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 1219
          if (tmp___2) {
#line 1220
            break;
          }
#line 1218
          i ++;
        }
#line 1223
        if ((unsigned int )i >= options.num_allow_groups) {
#line 1224
          return (0);
        }
      }
    }
  }
#line 1228
  return (1);
}
}
#line 1236 "sshd.c"
void do_authentication(char *user ) 
{ struct passwd *pw ;
  struct passwd pwcopy ;
  int tmp ;
  int pam_retval ;
  int __attribute__((__nonnull__(1,3,4)))  tmp___0 ;
  char const   *tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
#line 1250
  pw = getpwnam((char const   *)user);
#line 1251
  if (! pw) {
#line 1252
    do_fake_authloop(user);
  } else {
#line 1251
    tmp = allowed_user(pw);
#line 1251
    if (! tmp) {
#line 1252
      do_fake_authloop(user);
    }
  }
#line 1255
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 1256
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 1257
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 1258
  pwcopy.pw_uid = pw->pw_uid;
#line 1259
  pwcopy.pw_gid = pw->pw_gid;
#line 1260
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 1261
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 1262
  pw = & pwcopy;
#line 1268
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 1270
  tmp___0 = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                      (pam_handle_t **)(& pamh));
#line 1270
  pam_retval = (int )tmp___0;
#line 1271
  if (pam_retval != 0) {
#line 1272
    tmp___1 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 1272
    fatal("PAM initialisation failed: %.200s", tmp___1);
  }
#line 1274
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 1282
  tmp___2 = getuid();
#line 1282
  if (tmp___2 != 0U) {
#line 1282
    tmp___3 = getuid();
#line 1282
    if (pw->pw_uid != tmp___3) {
#line 1283
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 1285
  debug("Attempting authentication for %.100s.", user);
#line 1288
  if (options.password_authentication) {
#line 1288
    tmp___5 = auth_password(pw, "");
#line 1288
    if (tmp___5) {
#line 1294
      tmp___4 = get_remote_ipaddr();
#line 1294
      log("Login for user %s from %.100s, accepted without authentication.", pw->pw_name,
          tmp___4);
    } else {
#line 1300
      do_authloop(pw);
    }
  } else {
#line 1300
    do_authloop(pw);
  }
#line 1304
  if (pw->pw_uid == 0U) {
#line 1304
    if (! options.permit_root_login) {
#line 1305
      if (forced_command) {
#line 1306
        log("Root login accepted for forced command.");
      } else {
#line 1308
        tmp___6 = get_canonical_hostname();
#line 1308
        packet_disconnect("ROOT LOGIN REFUSED FROM %.200s", tmp___6);
      }
    }
  }
#line 1312
  packet_start(14);
#line 1313
  packet_send();
#line 1314
  packet_write_wait();
#line 1317
  do_authenticated(pw);
#line 1318
  return;
}
}
#line 1328 "sshd.c"
void do_authloop(struct passwd *pw ) 
{ int attempt ;
  unsigned int bits ;
  BIGNUM *client_host_key_e ;
  BIGNUM *client_host_key_n ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char user[1024] ;
  int plen ;
  int dlen ;
  int nlen ;
  int ulen ;
  int elen ;
  int type ;
  void (*authlog)(char const   *fmt  , ...) ;
  int pam_retval ;
  int authenticated ;
  int _p ;
  int _e ;
  int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 1331
  attempt = 0;
#line 1335
  client_user = (char *)((void *)0);
#line 1335
  password = (char *)((void *)0);
#line 1338
  type = 0;
#line 1339
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 1345
  packet_start(15);
#line 1346
  packet_send();
#line 1347
  packet_write_wait();
#line 1349
  attempt = 1;
#line 1349
  while (1) {
#line 1350
    authenticated = 0;
#line 1351
    strlcpy(user, "", sizeof(user));
#line 1354
    type = packet_read(& plen);
#line 1357
    switch (type) {
    case 5: 
#line 1417
    if (! options.rhosts_authentication) {
#line 1418
      verbose("Rhosts authentication disabled.");
#line 1419
      break;
    }
#line 1427
    client_user = packet_get_string((unsigned int *)(& ulen));
#line 1428
    while (1) {
#line 1428
      _p = plen;
#line 1428
      _e = 4 + ulen;
#line 1428
      if (_p != _e) {
#line 1428
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1428);
#line 1428
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1428
      break;
    }
#line 1432
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 1434
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 1438
    break;
    case 35: 
#line 1441
    if (! options.rhosts_rsa_authentication) {
#line 1442
      verbose("Rhosts with RSA authentication disabled.");
#line 1443
      break;
    }
#line 1450
    client_user = packet_get_string((unsigned int *)(& ulen));
#line 1453
    client_host_key_e = BN_new();
#line 1454
    client_host_key_n = BN_new();
#line 1455
    bits = packet_get_int();
#line 1456
    packet_get_bignum(client_host_key_e, & elen);
#line 1457
    packet_get_bignum(client_host_key_n, & nlen);
#line 1459
    tmp___0 = BN_num_bits((BIGNUM const   *)client_host_key_n);
#line 1459
    if (bits != (unsigned int )tmp___0) {
#line 1460
      tmp = BN_num_bits((BIGNUM const   *)client_host_key_n);
#line 1460
      error("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
            tmp, bits);
    }
#line 1462
    while (1) {
#line 1462
      _p___0 = plen;
#line 1462
      _e___0 = (((4 + ulen) + 4) + elen) + nlen;
#line 1462
      if (_p___0 != _e___0) {
#line 1462
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1462);
#line 1462
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1462
      break;
    }
#line 1464
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key_e,
                                    client_host_key_n);
#line 1466
    BN_clear_free(client_host_key_e);
#line 1467
    BN_clear_free(client_host_key_n);
#line 1469
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 1473
    break;
    case 6: 
#line 1476
    if (! options.rsa_authentication) {
#line 1477
      verbose("RSA authentication disabled.");
#line 1478
      break;
    }
#line 1481
    n___0 = BN_new();
#line 1482
    packet_get_bignum(n___0, & nlen);
#line 1483
    while (1) {
#line 1483
      _p___1 = plen;
#line 1483
      _e___1 = nlen;
#line 1483
      if (_p___1 != _e___1) {
#line 1483
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1483);
#line 1483
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1483
      break;
    }
#line 1484
    authenticated = auth_rsa(pw, n___0);
#line 1485
    BN_clear_free(n___0);
#line 1486
    break;
    case 9: 
#line 1489
    if (! options.password_authentication) {
#line 1490
      verbose("Password authentication disabled.");
#line 1491
      break;
    }
#line 1498
    password = packet_get_string((unsigned int *)(& dlen));
#line 1499
    while (1) {
#line 1499
      _p___2 = plen;
#line 1499
      _e___2 = 4 + dlen;
#line 1499
      if (_p___2 != _e___2) {
#line 1499
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1499);
#line 1499
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1499
      break;
    }
#line 1503
    pampasswd = (char const   *)password;
#line 1504
    tmp___1 = pam_authenticate((pam_handle_t *)pamh, 0);
#line 1504
    pam_retval = (int )tmp___1;
#line 1505
    if (pam_retval == 0) {
#line 1506
      log("PAM Password authentication accepted for user \"%.100s\"", pw->pw_name);
#line 1507
      tmp___2 = strlen((char const   *)password);
#line 1507
      memset((void *)password, 0, tmp___2);
#line 1508
      xfree((void *)password);
#line 1509
      authenticated = 1;
#line 1510
      break;
    }
#line 1513
    tmp___3 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 1513
    log("PAM Password authentication for \"%.100s\" failed: %s", pw->pw_name, tmp___3);
#line 1515
    tmp___4 = strlen((char const   *)password);
#line 1515
    memset((void *)password, 0, tmp___4);
#line 1516
    xfree((void *)password);
#line 1517
    break;
    case 39: 
#line 1561
    log("TIS authentication unsupported.");
#line 1562
    break;
    default: 
#line 1570
    log("Unknown message during authentication: type %d", type);
#line 1571
    break;
    }
#line 1575
    if (authenticated) {
#line 1578
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 1575
      if (attempt == 3) {
#line 1578
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 1575
        if (type == 9) {
#line 1578
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
#line 1580
    tmp___5 = get_remote_port();
#line 1580
    tmp___6 = get_remote_ipaddr();
#line 1580
    if (pw->pw_uid == 0U) {
#line 1580
      tmp___7 = "ROOT";
    } else {
#line 1580
      tmp___7 = (char const   *)pw->pw_name;
    }
#line 1580
    tmp___8 = get_authname(type);
#line 1580
    if (authenticated) {
#line 1580
      tmp___9 = "Accepted";
    } else {
#line 1580
      tmp___9 = "Failed";
    }
#line 1580
    (*authlog)("%s %s for %.200s from %.200s port %d%s", tmp___9, tmp___8, tmp___7,
               tmp___6, tmp___5, user);
#line 1595
    if (authenticated) {
#line 1596
      do_pam_account(pw->pw_name, client_user);
#line 1598
      if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 1599
        xfree((void *)client_user);
      }
#line 1601
      return;
    }
#line 1604
    if (attempt > 6) {
#line 1605
      if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 1606
        xfree((void *)client_user);
      }
#line 1608
      packet_disconnect("Too many authentication failures for %.100s", pw->pw_name);
    }
#line 1613
    packet_start(15);
#line 1614
    packet_send();
#line 1615
    packet_write_wait();
#line 1349
    attempt ++;
  }
}
}
#line 1623 "sshd.c"
void do_fake_authloop(char *user ) 
{ int attempt ;
  int tmp ;
  char const   *tmp___0 ;
  int plen ;
  int type ;
  int tmp___1 ;

  {
#line 1626
  attempt = 0;
#line 1628
  tmp = get_remote_port();
#line 1628
  tmp___0 = get_remote_ipaddr();
#line 1628
  log("Faking authloop for illegal user %.200s from %.200s port %d", user, tmp___0,
      tmp);
#line 1634
  packet_start(15);
#line 1635
  packet_send();
#line 1636
  packet_write_wait();
#line 1642
  attempt = 1;
#line 1642
  while (1) {
#line 1645
    tmp___1 = packet_read(& plen);
#line 1645
    type = tmp___1;
#line 1660
    if (attempt > 6) {
#line 1661
      packet_disconnect("Too many authentication failures for %.100s", user);
    }
#line 1667
    packet_start(15);
#line 1668
    packet_send();
#line 1669
    packet_write_wait();
#line 1642
    attempt ++;
  }
#line 1672
  abort();
}
}
#line 1679 "sshd.c"
static void xauthfile_cleanup_proc(void *ignore ) 
{ 

  {
#line 1682
  debug("xauthfile_cleanup_proc called");
#line 1684
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1685
    unlink((char const   *)xauthfile);
#line 1686
    xfree((void *)xauthfile);
#line 1687
    xauthfile = (char *)((void *)0);
  }
#line 1689
  return;
}
}
#line 1697 "sshd.c"
void do_authenticated(struct passwd *pw ) 
{ int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  int ptyfd ;
  int ttyfd ;
  int xauthfd ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int screen ;
  char ttyname___0[64] ;
  char *command ;
  char *term ;
  char *display ;
  char *proto ;
  char *data ;
  struct group *grp ;
  gid_t tty_gid ;
  mode_t tty_mode ;
  int n_bytes ;
  int plen ;
  int dlen ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___7 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  int _p___1 ;
  int _e___1 ;
  int proto_len ;
  int data_len ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  void *tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int _p___3 ;
  int _e___3 ;
  int tmp___28 ;
  int dlen___0 ;
  int _p___4 ;
  int _e___4 ;

  {
#line 1701
  compression_level = 0;
#line 1701
  enable_compression_after_reply = 0;
#line 1702
  have_pty = 0;
#line 1702
  ptyfd = -1;
#line 1702
  ttyfd = -1;
#line 1702
  xauthfd = -1;
#line 1705
  term = (char *)((void *)0);
#line 1705
  display = (char *)((void *)0);
#line 1705
  proto = (char *)((void *)0);
#line 1705
  data = (char *)((void *)0);
#line 1716
  alarm(0U);
#line 1725
  channel_permit_all_opens();
#line 1731
  while (1) {
#line 1735
    type = packet_read(& plen);
#line 1738
    switch (type) {
    case 37: 
#line 1740
    while (1) {
#line 1740
      _p = plen;
#line 1740
      _e = 4;
#line 1740
      if (_p != _e) {
#line 1740
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1740);
#line 1740
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1740
      break;
    }
#line 1741
    tmp = packet_get_int();
#line 1741
    compression_level = (int )tmp;
#line 1742
    if (compression_level < 1) {
#line 1743
      packet_send_debug("Received illegal compression level %d.", compression_level);
      goto fail;
    } else {
#line 1742
      if (compression_level > 9) {
#line 1743
        packet_send_debug("Received illegal compression level %d.", compression_level);
        goto fail;
      }
    }
#line 1748
    enable_compression_after_reply = 1;
#line 1749
    break;
    case 10: 
#line 1752
    if (no_pty_flag) {
#line 1753
      debug("Allocating a pty not permitted for this authentication.");
      goto fail;
    }
#line 1756
    if (have_pty) {
#line 1757
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 1759
    debug("Allocating pty.");
#line 1762
    tmp___0 = pty_allocate(& ptyfd, & ttyfd, ttyname___0, (int )sizeof(ttyname___0));
#line 1762
    if (! tmp___0) {
#line 1764
      error("Failed to allocate pty.");
      goto fail;
    }
#line 1768
    grp = getgrnam("tty");
#line 1769
    if (grp) {
#line 1770
      tty_gid = grp->gr_gid;
#line 1771
      tty_mode = (unsigned int )(384 | (128 >> 3));
    } else {
#line 1773
      tty_gid = pw->pw_gid;
#line 1774
      tty_mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
    }
#line 1778
    tmp___3 = chown((char const   *)(ttyname___0), pw->pw_uid, tty_gid);
#line 1778
    if (tmp___3 < 0) {
#line 1779
      tmp___1 = __errno_location();
#line 1779
      tmp___2 = strerror(*tmp___1);
#line 1779
      fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, tty_gid,
            tmp___2);
    }
#line 1781
    tmp___6 = chmod((char const   *)(ttyname___0), tty_mode);
#line 1781
    if (tmp___6 < 0) {
#line 1782
      tmp___4 = __errno_location();
#line 1782
      tmp___5 = strerror(*tmp___4);
#line 1782
      fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, tty_mode, tmp___5);
    }
#line 1786
    term = packet_get_string((unsigned int *)(& dlen));
#line 1787
    while (1) {
#line 1787
      _p___0 = dlen;
#line 1787
      tmp___7 = strlen((char const   *)term);
#line 1787
      _e___0 = (int )tmp___7;
#line 1787
      if (_p___0 != _e___0) {
#line 1787
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1787);
#line 1787
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1787
      break;
    }
#line 1790
    n_bytes = plen - ((4 + dlen) + 16);
#line 1792
    if (0) {
#line 1792
      __s1_len = strlen((char const   *)term);
#line 1792
      __s2_len = strlen("");
#line 1792
      if (! ((unsigned int )((void const   *)(term + 1)) - (unsigned int )((void const   *)term) == 1U)) {
        goto _L___0;
      } else {
#line 1792
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1792
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1792
            tmp___17 = 1;
          } else {
#line 1792
            if (__s2_len >= 4U) {
#line 1792
              tmp___17 = 1;
            } else {
#line 1792
              tmp___17 = 0;
            }
          }
        } else {
#line 1792
          tmp___17 = 0;
        }
      }
#line 1792
      if (tmp___17) {
#line 1792
        tmp___13 = __builtin_strcmp((char const   *)term, "");
      } else {
#line 1792
        tmp___16 = __builtin_strcmp((char const   *)term, "");
#line 1792
        tmp___13 = tmp___16;
      }
    } else {
#line 1792
      tmp___16 = __builtin_strcmp((char const   *)term, "");
#line 1792
      tmp___13 = tmp___16;
    }
#line 1792
    if (tmp___13 == 0) {
#line 1793
      term = (char *)((void *)0);
    }
#line 1796
    tmp___18 = packet_get_int();
#line 1796
    row = (int )tmp___18;
#line 1797
    tmp___19 = packet_get_int();
#line 1797
    col = (int )tmp___19;
#line 1798
    tmp___20 = packet_get_int();
#line 1798
    xpixel = (int )tmp___20;
#line 1799
    tmp___21 = packet_get_int();
#line 1799
    ypixel = (int )tmp___21;
#line 1800
    pty_change_window_size(ptyfd, row, col, xpixel, ypixel);
#line 1803
    tty_parse_modes(ttyfd, & n_bytes);
#line 1804
    while (1) {
#line 1804
      _p___1 = plen;
#line 1804
      _e___1 = ((4 + dlen) + 16) + n_bytes;
#line 1804
      if (_p___1 != _e___1) {
#line 1804
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1804);
#line 1804
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1804
      break;
    }
#line 1807
    have_pty = 1;
#line 1811
    do_pam_session(pw->pw_name, ttyname___0);
#line 1814
    break;
    case 34: 
#line 1817
    if (! options.x11_forwarding) {
#line 1818
      packet_send_debug("X11 forwarding disabled in server configuration file.");
      goto fail;
    }
#line 1822
    if (no_x11_forwarding_flag) {
#line 1823
      packet_send_debug("X11 forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1826
    debug("Received request for X11 forwarding with auth spoofing.");
#line 1827
    if (display) {
#line 1828
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 1831
    proto = packet_get_string((unsigned int *)(& proto_len));
#line 1832
    data = packet_get_string((unsigned int *)(& data_len));
#line 1833
    while (1) {
#line 1833
      _p___2 = plen;
#line 1833
      _e___2 = (((4 + proto_len) + 4) + data_len) + 4;
#line 1833
      if (_p___2 != _e___2) {
#line 1833
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1833);
#line 1833
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1833
      break;
    }
#line 1835
    tmp___23 = packet_get_protocol_flags();
#line 1835
    if (tmp___23 & 1U) {
#line 1836
      tmp___22 = packet_get_int();
#line 1836
      screen = (int )tmp___22;
    } else {
#line 1838
      screen = 0;
    }
#line 1839
    display = x11_create_display_inet(screen);
#line 1840
    if (! display) {
      goto fail;
    }
#line 1844
    tmp___24 = xmalloc(4096U);
#line 1844
    xauthfile = (char *)tmp___24;
#line 1845
    snprintf((char * __restrict  )xauthfile, 4096U, (char const   * __restrict  )"/tmp/XauthXXXXXX");
#line 1847
    xauthfd = mkstemp(xauthfile);
#line 1847
    if (xauthfd != -1) {
#line 1848
      fchown(xauthfd, pw->pw_uid, pw->pw_gid);
#line 1849
      close(xauthfd);
#line 1850
      fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
    } else {
#line 1852
      xfree((void *)xauthfile);
#line 1853
      xauthfile = (char *)((void *)0);
    }
#line 1855
    break;
    case 30: 
#line 1862
    if (no_agent_forwarding_flag) {
#line 1863
      debug("Authentication agent forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1866
    debug("Received authentication agent forwarding request.");
#line 1867
    auth_input_request_forwarding(pw);
#line 1868
    break;
    case 28: 
#line 1871
    if (no_port_forwarding_flag) {
#line 1872
      debug("Port forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1875
    debug("Received TCP/IP port forwarding request.");
#line 1876
    channel_input_port_forward_request(pw->pw_uid == 0U);
#line 1877
    break;
    case 38: 
#line 1880
    tmp___25 = packet_get_int();
#line 1880
    tmp___26 = packet_set_maxsize((int )tmp___25);
#line 1880
    if (tmp___26 < 0) {
      goto fail;
    }
#line 1882
    break;
    case 12: 
#line 1886
    if (have_pty) {
#line 1886
      tmp___27 = 1;
    } else {
#line 1886
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1886
        tmp___27 = 1;
      } else {
#line 1886
        tmp___27 = 0;
      }
    }
#line 1886
    packet_set_interactive(tmp___27, options.keepalives);
#line 1889
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1891
    debug("Forking shell.");
#line 1892
    while (1) {
#line 1892
      _p___3 = plen;
#line 1892
      _e___3 = 0;
#line 1892
      if (_p___3 != _e___3) {
#line 1892
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "sshd.c",
            1892);
#line 1892
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1892
      break;
    }
#line 1893
    if (have_pty) {
#line 1894
      do_exec_pty((char const   *)((void *)0), ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1896
      do_exec_no_pty((char const   *)((void *)0), pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1897
    return;
    case 13: 
#line 1901
    if (have_pty) {
#line 1901
      tmp___28 = 1;
    } else {
#line 1901
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1901
        tmp___28 = 1;
      } else {
#line 1901
        tmp___28 = 0;
      }
    }
#line 1901
    packet_set_interactive(tmp___28, options.keepalives);
#line 1904
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1909
    command = packet_get_string((unsigned int *)(& dlen___0));
#line 1910
    debug("Executing command \'%.500s\'", command);
#line 1911
    while (1) {
#line 1911
      _p___4 = plen;
#line 1911
      _e___4 = 4 + dlen___0;
#line 1911
      if (_p___4 != _e___4) {
#line 1911
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "sshd.c",
            1911);
#line 1911
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1911
      break;
    }
#line 1913
    if (have_pty) {
#line 1914
      do_exec_pty((char const   *)command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1916
      do_exec_no_pty((char const   *)command, pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1917
    xfree((void *)command);
#line 1918
    return;
    default: 
#line 1925
    log("Unknown packet type received after authentication: %d", type);
    goto fail;
    }
#line 1930
    packet_start(14);
#line 1931
    packet_send();
#line 1932
    packet_write_wait();
#line 1935
    if (enable_compression_after_reply) {
#line 1936
      enable_compression_after_reply = 0;
#line 1937
      packet_start_compression(compression_level);
    }
#line 1939
    continue;
    fail: 
#line 1943
    packet_start(15);
#line 1944
    packet_send();
#line 1945
    packet_write_wait();
#line 1946
    continue;
    do_forced_command: 
#line 1953
    debug("Executing forced command: %.900s", forced_command);
#line 1954
    if (have_pty) {
#line 1955
      do_exec_pty((char const   *)forced_command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1957
      do_exec_no_pty((char const   *)forced_command, pw, (char const   *)display,
                     (char const   *)proto, (char const   *)data);
    }
#line 1958
    return;
  }
}
}
#line 1967 "sshd.c"
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int pin[2] ;
  int pout[2] ;
  int perr[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __pid_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;

  {
#line 1977
  tmp___1 = pipe((int *)(pin));
#line 1977
  if (tmp___1 < 0) {
#line 1978
    tmp = __errno_location();
#line 1978
    tmp___0 = strerror(*tmp);
#line 1978
    packet_disconnect("Could not create pipes: %.100s", tmp___0);
  } else {
#line 1977
    tmp___2 = pipe((int *)(pout));
#line 1977
    if (tmp___2 < 0) {
#line 1978
      tmp = __errno_location();
#line 1978
      tmp___0 = strerror(*tmp);
#line 1978
      packet_disconnect("Could not create pipes: %.100s", tmp___0);
    } else {
#line 1977
      tmp___3 = pipe((int *)(perr));
#line 1977
      if (tmp___3 < 0) {
#line 1978
        tmp = __errno_location();
#line 1978
        tmp___0 = strerror(*tmp);
#line 1978
        packet_disconnect("Could not create pipes: %.100s", tmp___0);
      }
    }
  }
#line 1989
  setproctitle("%s@notty", pw->pw_name);
#line 1992
  pid = fork();
#line 1992
  if (pid == 0) {
#line 1994
    log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 2000
    tmp___6 = setsid();
#line 2000
    if (tmp___6 < 0) {
#line 2001
      tmp___4 = __errno_location();
#line 2001
      tmp___5 = strerror(*tmp___4);
#line 2001
      error("setsid failed: %.100s", tmp___5);
    }
#line 2008
    close(pin[1]);
#line 2009
    tmp___7 = dup2(pin[0], 0);
#line 2009
    if (tmp___7 < 0) {
#line 2010
      perror("dup2 stdin");
    }
#line 2011
    close(pin[0]);
#line 2014
    close(pout[0]);
#line 2015
    tmp___8 = dup2(pout[1], 1);
#line 2015
    if (tmp___8 < 0) {
#line 2016
      perror("dup2 stdout");
    }
#line 2017
    close(pout[1]);
#line 2020
    close(perr[0]);
#line 2021
    tmp___9 = dup2(perr[1], 2);
#line 2021
    if (tmp___9 < 0) {
#line 2022
      perror("dup2 stderr");
    }
#line 2023
    close(perr[1]);
#line 2041
    do_child(command, pw, (char const   *)((void *)0), display, auth_proto, auth_data,
             (char const   *)((void *)0));
  }
#line 2044
  if (pid < 0) {
#line 2045
    tmp___10 = __errno_location();
#line 2045
    tmp___11 = strerror(*tmp___10);
#line 2045
    packet_disconnect("fork failed: %.100s", tmp___11);
  }
#line 2048
  close(pin[0]);
#line 2049
  close(pout[1]);
#line 2050
  close(perr[1]);
#line 2053
  server_loop(pid, pin[1], pout[0], perr[0]);
#line 2067
  return;
}
}
#line 2078 "sshd.c"
void pty_cleanup_proc(void *context ) 
{ struct pty_cleanup_context *cu ;

  {
#line 2081
  cu = (struct pty_cleanup_context *)context;
#line 2083
  debug("pty_cleanup_proc called");
#line 2086
  record_logout(cu->pid, cu->ttyname);
#line 2089
  pty_release(cu->ttyname);
#line 2090
  return;
}
}
#line 2098 "sshd.c"
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int fdout___0 ;
  char const   *hostname ;
  time_t last_login_time ;
  char buf[100] ;
  char *time_string ;
  FILE *f ;
  char line[256] ;
  struct stat st ;
  int quiet_login ;
  struct sockaddr_in from ;
  int fromlen ;
  struct pty_cleanup_context cleanup_context ;
  unsigned long tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___21 ;
  char *tmp___23 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2117
  hostname = get_canonical_hostname();
#line 2123
  if (! options.use_login) {
#line 2124
    tmp = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf, sizeof(buf));
#line 2124
    last_login_time = (long )tmp;
  }
#line 2127
  tmp___0 = strrchr(ttyname___0, '/');
#line 2127
  setproctitle("%s@%s", pw->pw_name, tmp___0 + 1);
#line 2130
  pid = fork();
#line 2130
  if (pid == 0) {
#line 2131
    pid = getpid();
#line 2135
    log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 2138
    close(ptyfd);
#line 2141
    pty_make_controlling_tty(& ttyfd, ttyname___0);
#line 2144
    tmp___3 = fileno(stdin);
#line 2144
    tmp___4 = dup2(ttyfd, tmp___3);
#line 2144
    if (tmp___4 < 0) {
#line 2145
      tmp___1 = __errno_location();
#line 2145
      tmp___2 = strerror(*tmp___1);
#line 2145
      error("dup2 stdin failed: %.100s", tmp___2);
    }
#line 2148
    tmp___7 = fileno(stdout);
#line 2148
    tmp___8 = dup2(ttyfd, tmp___7);
#line 2148
    if (tmp___8 < 0) {
#line 2149
      tmp___5 = __errno_location();
#line 2149
      tmp___6 = strerror(*tmp___5);
#line 2149
      error("dup2 stdin failed: %.100s", tmp___6);
    }
#line 2152
    tmp___11 = fileno(stderr);
#line 2152
    tmp___12 = dup2(ttyfd, tmp___11);
#line 2152
    if (tmp___12 < 0) {
#line 2153
      tmp___9 = __errno_location();
#line 2153
      tmp___10 = strerror(*tmp___9);
#line 2153
      error("dup2 stdin failed: %.100s", tmp___10);
    }
#line 2156
    close(ttyfd);
#line 2163
    memset((void *)(& from), 0, sizeof(from));
#line 2164
    tmp___17 = packet_get_connection_in();
#line 2164
    tmp___18 = packet_get_connection_out();
#line 2164
    if (tmp___17 == tmp___18) {
#line 2165
      fromlen = (int )sizeof(from);
#line 2166
      tmp___15 = packet_get_connection_in();
#line 2166
      tmp___16 = getpeername(tmp___15, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                             (socklen_t * __restrict  )(& fromlen));
#line 2166
      if (tmp___16 < 0) {
#line 2168
        tmp___13 = __errno_location();
#line 2168
        tmp___14 = strerror(*tmp___13);
#line 2168
        debug("getpeername: %.100s", tmp___14);
#line 2169
        fatal_cleanup();
      }
    }
#line 2173
    record_login(pid, ttyname___0, (char const   *)pw->pw_name, pw->pw_uid, hostname,
                 & from);
#line 2177
    snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.200s/.hushlogin",
             pw->pw_dir);
#line 2178
    tmp___19 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 2178
    quiet_login = tmp___19 >= 0;
#line 2182
    if (! quiet_login) {
#line 2182
      if ((unsigned int )pamconv_msg != (unsigned int )((void *)0)) {
#line 2183
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )pamconv_msg);
      }
    }
#line 2194
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 2194
      if (last_login_time != 0L) {
#line 2194
        if (! quiet_login) {
#line 2194
          if (! options.use_login) {
#line 2197
            time_string = ctime((time_t const   *)(& last_login_time));
#line 2199
            tmp___23 = __builtin_strchr(time_string, '\n');
#line 2199
            if (tmp___23) {
#line 2200
              tmp___21 = __builtin_strchr(time_string, '\n');
#line 2200
              *tmp___21 = (char)0;
            }
#line 2203
            if (0) {
#line 2203
              __s1_len = strlen((char const   *)(buf));
#line 2203
              __s2_len = strlen("");
#line 2203
              if (! ((unsigned int )((void const   *)(buf + 1)) - (unsigned int )((void const   *)(buf)) == 1U)) {
                goto _L___0;
              } else {
#line 2203
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 2203
                  if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 2203
                    tmp___33 = 1;
                  } else {
#line 2203
                    if (__s2_len >= 4U) {
#line 2203
                      tmp___33 = 1;
                    } else {
#line 2203
                      tmp___33 = 0;
                    }
                  }
                } else {
#line 2203
                  tmp___33 = 0;
                }
              }
#line 2203
              if (tmp___33) {
#line 2203
                tmp___29 = __builtin_strcmp((char const   *)(buf), "");
              } else {
#line 2203
                tmp___32 = __builtin_strcmp((char const   *)(buf), "");
#line 2203
                tmp___29 = tmp___32;
              }
            } else {
#line 2203
              tmp___32 = __builtin_strcmp((char const   *)(buf), "");
#line 2203
              tmp___29 = tmp___32;
            }
#line 2203
            if (tmp___29 == 0) {
#line 2204
              printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
            } else {
#line 2206
              printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
                     buf);
            }
          }
        }
      }
    }
#line 2214
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 2214
      if (options.print_motd) {
#line 2214
        if (! quiet_login) {
#line 2214
          if (! options.use_login) {
#line 2217
            f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 2218
            if (f) {
#line 2219
              while (1) {
#line 2219
                tmp___34 = fgets((char * __restrict  )(line), (int )sizeof(line),
                                 (FILE * __restrict  )f);
#line 2219
                if (! tmp___34) {
#line 2219
                  break;
                }
#line 2220
                fputs((char const   * __restrict  )(line), (FILE * __restrict  )stdout);
              }
#line 2221
              fclose(f);
            }
          }
        }
      }
    }
#line 2225
    do_child(command, pw, term, display, auth_proto, auth_data, ttyname___0);
  }
#line 2228
  if (pid < 0) {
#line 2229
    tmp___35 = __errno_location();
#line 2229
    tmp___36 = strerror(*tmp___35);
#line 2229
    packet_disconnect("fork failed: %.100s", tmp___36);
  }
#line 2231
  close(ttyfd);
#line 2238
  fdout___0 = dup(ptyfd);
#line 2239
  if (fdout___0 < 0) {
#line 2240
    tmp___37 = __errno_location();
#line 2240
    tmp___38 = strerror(*tmp___37);
#line 2240
    packet_disconnect("dup failed: %.100s", tmp___38);
  }
#line 2246
  cleanup_context.pid = pid;
#line 2247
  cleanup_context.ttyname = ttyname___0;
#line 2248
  fatal_add_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2251
  server_loop(pid, ptyfd, fdout___0, -1);
#line 2255
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2258
  record_logout(pid, ttyname___0);
#line 2261
  pty_release(ttyname___0);
#line 2268
  close(ptyfd);
#line 2269
  close(fdout___0);
#line 2270
  return;
}
}
#line 2276 "sshd.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 2288
  env = *envp;
#line 2289
  namelen = strlen(name);
#line 2290
  i = 0U;
#line 2290
  while (*(env + i)) {
#line 2291
    if (0) {
#line 2291
      if (0) {
#line 2291
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 2291
        __s2_len___0 = strlen(name);
#line 2291
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 2291
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 2291
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 2291
              tmp___22 = 1;
            } else {
#line 2291
              if (__s2_len___0 >= 4U) {
#line 2291
                tmp___22 = 1;
              } else {
#line 2291
                tmp___22 = 0;
              }
            }
          } else {
#line 2291
            tmp___22 = 0;
          }
        }
#line 2291
        if (tmp___22) {
#line 2291
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 2291
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2291
          tmp___18 = tmp___21;
        }
      } else {
#line 2291
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2291
        tmp___18 = tmp___21;
      }
#line 2291
      tmp___12 = tmp___18;
    } else {
#line 2291
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 2291
    if (tmp___12 == 0) {
#line 2291
      if ((int )*(*(env + i) + namelen) == 61) {
#line 2292
        break;
      }
    }
#line 2290
    i ++;
  }
#line 2293
  if (*(env + i)) {
#line 2295
    xfree((void *)*(env + i));
  } else {
#line 2298
    if (i >= *envsizep - 1U) {
#line 2299
      *envsizep += 50U;
#line 2300
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 2300
      *envp = (char **)tmp___25;
#line 2300
      env = *envp;
    }
#line 2303
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 2307
  tmp___26 = strlen(name);
#line 2307
  tmp___27 = strlen(value);
#line 2307
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 2307
  *(env + i) = (char *)tmp___28;
#line 2308
  tmp___29 = strlen(name);
#line 2308
  tmp___30 = strlen(value);
#line 2308
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 2309
  return;
}
}
#line 2317 "sshd.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 2325
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 2326
  if (! f) {
#line 2327
    return;
  }
#line 2329
  while (1) {
#line 2329
    tmp___5 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 2329
    if (! tmp___5) {
#line 2329
      break;
    }
#line 2330
    cp = buf;
#line 2330
    while (1) {
#line 2330
      if (! ((int )*cp == 32)) {
#line 2330
        if (! ((int )*cp == 9)) {
#line 2330
          break;
        }
      }
#line 2330
      cp ++;
    }
#line 2332
    if (! *cp) {
#line 2333
      continue;
    } else {
#line 2332
      if ((int )*cp == 35) {
#line 2333
        continue;
      } else {
#line 2332
        if ((int )*cp == 10) {
#line 2333
          continue;
        }
      }
    }
#line 2334
    tmp___2 = __builtin_strchr(cp, '\n');
#line 2334
    if (tmp___2) {
#line 2335
      tmp___0 = __builtin_strchr(cp, '\n');
#line 2335
      *tmp___0 = (char )'\000';
    }
#line 2336
    tmp___4 = __builtin_strchr(cp, '=');
#line 2336
    value = tmp___4;
#line 2337
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 2338
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf);
#line 2339
      continue;
    }
#line 2342
    *value = (char )'\000';
#line 2343
    value ++;
#line 2344
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 2346
  fclose(f);
#line 2347
  return;
}
}
#line 2364
extern char **environ ;
#line 2354 "sshd.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *cp ;
  char buf[256] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  __uid_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *equals ;
  char var_name[512] ;
  char var_val[512] ;
  char **pam_env ;
  char ** __attribute__((__nonnull__(1))) tmp___10 ;
  int i___1 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char buf___0[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___25 ;
  char const   *tmp___26 ;

  {
#line 2359
  cp = (char const   *)((void *)0);
#line 2390
  if (! options.use_login) {
#line 2391
    tmp___1 = getuid();
#line 2391
    if (tmp___1 == 0U) {
      goto _L;
    } else {
#line 2391
      tmp___2 = geteuid();
#line 2391
      if (tmp___2 == 0U) {
        _L: /* CIL Label */ 
#line 2392
        tmp = setgid(pw->pw_gid);
#line 2392
        if (tmp < 0) {
#line 2393
          perror("setgid");
#line 2394
          exit(1);
        }
#line 2397
        tmp___0 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 2397
        if (tmp___0 < 0) {
#line 2398
          perror("initgroups");
#line 2399
          exit(1);
        }
#line 2401
        endgrent();
#line 2404
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 2406
    tmp___3 = getuid();
#line 2406
    if (tmp___3 != pw->pw_uid) {
#line 2407
      fatal("Failed to set uids to %d.", (int )pw->pw_uid);
    } else {
#line 2406
      tmp___4 = geteuid();
#line 2406
      if (tmp___4 != pw->pw_uid) {
#line 2407
        fatal("Failed to set uids to %d.", (int )pw->pw_uid);
      }
    }
  }
#line 2413
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 2413
    shell = "/bin/sh";
  } else {
#line 2413
    shell = (char const   *)pw->pw_shell;
  }
#line 2428
  envsize = 100U;
#line 2429
  tmp___5 = xmalloc(envsize * sizeof(char *));
#line 2429
  env = (char **)tmp___5;
#line 2430
  *(env + 0) = (char *)((void *)0);
#line 2432
  if (! options.use_login) {
#line 2434
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 2435
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 2436
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 2437
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 2439
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 2441
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf));
#line 2444
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 2446
  tmp___7 = getenv("TZ");
#line 2446
  if (tmp___7) {
#line 2447
    tmp___6 = getenv("TZ");
#line 2447
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___6);
  }
#line 2450
  while (custom_environment) {
#line 2451
    ce = custom_environment;
#line 2452
    s = ce->s;
#line 2454
    i___0 = 0;
#line 2454
    while (1) {
#line 2454
      if ((int )*(s + i___0) != 61) {
#line 2454
        if (! *(s + i___0)) {
#line 2454
          break;
        }
      } else {
#line 2454
        break;
      }
#line 2454
      i___0 ++;
    }
#line 2455
    if ((int )*(s + i___0) == 61) {
#line 2456
      *(s + i___0) = (char)0;
#line 2457
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 2459
    custom_environment = ce->next;
#line 2460
    xfree((void *)ce->s);
#line 2461
    xfree((void *)ce);
  }
#line 2464
  tmp___8 = get_remote_port();
#line 2464
  tmp___9 = get_remote_ipaddr();
#line 2464
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.50s %d %d",
           tmp___9, tmp___8, options.port);
#line 2466
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf));
#line 2468
  if (ttyname___0) {
#line 2469
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 2470
  if (term) {
#line 2471
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 2472
  if (display) {
#line 2473
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 2488
  tmp___10 = pam_getenvlist((pam_handle_t *)pamh);
#line 2488
  pam_env = (char **)tmp___10;
#line 2490
  i___1 = 0;
#line 2490
  while (1) {
#line 2490
    if (pam_env) {
#line 2490
      if (! *(pam_env + i___1)) {
#line 2490
        break;
      }
    } else {
#line 2490
      break;
    }
#line 2491
    equals = strstr((char const   *)*(pam_env + i___1), "=");
#line 2492
    tmp___11 = strlen((char const   *)*(pam_env + i___1));
#line 2492
    if (tmp___11 < sizeof(var_name) - 1U) {
#line 2492
      if ((unsigned int )equals != (unsigned int )((void *)0)) {
#line 2494
        debug("PAM environment: %s=%s", var_name, var_val);
#line 2495
        memset((void *)(var_name), '\000', sizeof(var_name));
#line 2496
        memset((void *)(var_val), '\000', sizeof(var_val));
#line 2497
        __builtin_strncpy(var_name, (char const   *)*(pam_env + i___1), (unsigned int )(equals - *(pam_env + i___1)));
#line 2498
        strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equals + 1));
#line 2499
        child_set_env(& env, & envsize, (char const   *)(var_name), (char const   *)(var_val));
      }
    }
#line 2490
    i___1 ++;
  }
#line 2505
  if (xauthfile) {
#line 2506
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 2508
  tmp___13 = auth_get_socket_name();
#line 2508
  if ((unsigned int )tmp___13 != (unsigned int )((void *)0)) {
#line 2509
    tmp___12 = auth_get_socket_name();
#line 2509
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___12);
  }
#line 2513
  if (! options.use_login) {
#line 2514
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 2515
    read_environment_file(& env, & envsize, (char const   *)(buf));
  }
#line 2517
  if (debug_flag) {
#line 2519
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 2520
    i = 0U;
#line 2520
    while (*(env + i)) {
#line 2521
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 2520
      i ++;
    }
  }
#line 2530
  tmp___17 = packet_get_connection_in();
#line 2530
  tmp___18 = packet_get_connection_out();
#line 2530
  if (tmp___17 == tmp___18) {
#line 2531
    tmp___14 = packet_get_connection_in();
#line 2531
    close(tmp___14);
  } else {
#line 2533
    tmp___15 = packet_get_connection_in();
#line 2533
    close(tmp___15);
#line 2534
    tmp___16 = packet_get_connection_out();
#line 2534
    close(tmp___16);
  }
#line 2541
  channel_close_all();
#line 2547
  endpwent();
#line 2548
  endhostent();
#line 2556
  i = 3U;
#line 2556
  while (i < 64U) {
#line 2557
    close((int )i);
#line 2556
    i ++;
  }
#line 2560
  tmp___21 = chdir((char const   *)pw->pw_dir);
#line 2560
  if (tmp___21 < 0) {
#line 2561
    tmp___19 = __errno_location();
#line 2561
    tmp___20 = strerror(*tmp___19);
#line 2561
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___20);
  }
#line 2568
  environ = env;
#line 2574
  if (! options.use_login) {
#line 2575
    tmp___23 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 2575
    if (tmp___23 >= 0) {
#line 2576
      if (debug_flag) {
#line 2577
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 2579
      f = popen("/bin/sh .ssh/rc", "w");
#line 2580
      if (f) {
#line 2581
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2581
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2582
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 2583
        pclose(f);
      } else {
#line 2585
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 2586
      tmp___22 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 2586
      if (tmp___22 >= 0) {
#line 2587
        if (debug_flag) {
#line 2588
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 2590
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 2591
        if (f) {
#line 2592
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2592
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2593
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 2594
          pclose(f);
        } else {
#line 2596
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 2601
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2601
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2602
            if (debug_flag) {
#line 2603
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      "/usr/X11R6/bin/xauth", display, auth_proto, auth_data);
            }
#line 2606
            f = popen("/usr/X11R6/bin/xauth -q -", "w");
#line 2607
            if (f) {
#line 2608
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      display, auth_proto, auth_data);
#line 2609
              fclose(f);
            } else {
#line 2611
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s -q -\n",
                      "/usr/X11R6/bin/xauth");
            }
          }
        }
      }
    }
#line 2617
    tmp___24 = strrchr(shell, '/');
#line 2617
    cp = (char const   *)tmp___24;
#line 2618
    if (cp) {
#line 2619
      cp ++;
    } else {
#line 2621
      cp = shell;
    }
  }
#line 2628
  if (! command) {
#line 2629
    if (! options.use_login) {
#line 2636
      if (ttyname___0) {
#line 2636
        if (options.check_mail) {
#line 2639
          mailbox = getenv("MAIL");
#line 2640
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 2641
            tmp___25 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 2641
            if (tmp___25 != 0) {
#line 2642
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 2641
              if (mailstat.st_size == 0L) {
#line 2642
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 2643
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 2644
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 2646
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 2650
      buf___0[0] = (char )'-';
#line 2651
      __builtin_strncpy(buf___0 + 1, cp, sizeof(buf___0) - 1U);
#line 2652
      buf___0[sizeof(buf___0) - 1U] = (char)0;
#line 2655
      argv[0] = buf___0;
#line 2656
      argv[1] = (char *)((void *)0);
#line 2657
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2660
      perror(shell);
#line 2661
      exit(1);
    } else {
#line 2666
      tmp___26 = get_remote_ipaddr();
#line 2666
      execl("/usr/bin/login", "login", "-h", tmp___26, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 2671
      perror("login");
#line 2672
      exit(1);
    }
  }
#line 2679
  argv[0] = (char *)cp;
#line 2680
  argv[1] = (char *)"-c";
#line 2681
  argv[2] = (char *)command;
#line 2682
  argv[3] = (char *)((void *)0);
#line 2683
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2684
  perror(shell);
#line 2685
  exit(1);
}
}
#line 1 "auth-rhosts.o"
#pragma merger(0,"./auth-rhosts.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 33 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 42
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 43
  if (! f) {
#line 44
    return (0);
  }
#line 46
  while (1) {
#line 46
    tmp___50 = fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )f);
#line 46
    if (! tmp___50) {
#line 46
      break;
    }
#line 51
    cp = buf;
#line 51
    while (1) {
#line 51
      if (! ((int )*cp == 32)) {
#line 51
        if (! ((int )*cp == 9)) {
#line 51
          break;
        }
      }
#line 51
      cp ++;
    }
#line 53
    if ((int )*cp == 35) {
#line 54
      continue;
    } else {
#line 53
      if ((int )*cp == 10) {
#line 54
        continue;
      } else {
#line 53
        if (! *cp) {
#line 54
          continue;
        }
      }
    }
#line 60
    if (0) {
#line 60
      if (0) {
#line 60
        __s1_len___0 = strlen((char const   *)cp);
#line 60
        __s2_len___0 = strlen("NO_PLUS");
#line 60
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 60
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 60
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 60
              tmp___22 = 1;
            } else {
#line 60
              if (__s2_len___0 >= 4U) {
#line 60
                tmp___22 = 1;
              } else {
#line 60
                tmp___22 = 0;
              }
            }
          } else {
#line 60
            tmp___22 = 0;
          }
        }
#line 60
        if (tmp___22) {
#line 60
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 60
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
          tmp___18 = tmp___21;
        }
      } else {
#line 60
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
        tmp___18 = tmp___21;
      }
#line 60
      tmp___12 = tmp___18;
    } else {
#line 60
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 60
    if (tmp___12 == 0) {
#line 61
      continue;
    }
#line 67
    tmp___25 = sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 67
    switch (tmp___25) {
    case 0: 
#line 69
    packet_send_debug("Found empty line in %.100s.", filename);
#line 70
    continue;
    case 1: 
#line 73
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 74
    break;
    case 2: 
#line 77
    break;
    case 3: 
#line 79
    packet_send_debug("Found garbage in %.100s.", filename);
#line 80
    continue;
    default: ;
#line 83
    continue;
    }
#line 86
    host = hostbuf;
#line 87
    user = userbuf;
#line 88
    negated = 0;
#line 91
    if ((int )*(host + 0) == 45) {
#line 92
      negated = 1;
#line 93
      host ++;
    } else {
#line 94
      if ((int )*(host + 0) == 43) {
#line 95
        host ++;
      }
    }
#line 97
    if ((int )*(user + 0) == 45) {
#line 98
      negated = 1;
#line 99
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 106
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 106
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
        continue;
      }
    }
#line 111
    if ((int )*(host + 0) == 64) {
#line 112
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 112
      if (! tmp___26) {
#line 112
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 112
        if (! tmp___27) {
#line 114
          continue;
        }
      }
    } else {
#line 115
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 115
      if (tmp___28) {
#line 115
        if (0) {
#line 115
          __s1_len___1 = strlen((char const   *)host);
#line 115
          __s2_len___1 = strlen(ipaddr);
#line 115
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 115
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 115
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 115
                tmp___38 = 1;
              } else {
#line 115
                if (__s2_len___1 >= 4U) {
#line 115
                  tmp___38 = 1;
                } else {
#line 115
                  tmp___38 = 0;
                }
              }
            } else {
#line 115
              tmp___38 = 0;
            }
          }
#line 115
          if (tmp___38) {
#line 115
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 115
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
            tmp___34 = tmp___37;
          }
        } else {
#line 115
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
          tmp___34 = tmp___37;
        }
#line 115
        if (tmp___34 != 0) {
#line 116
          continue;
        }
      }
    }
#line 119
    if ((int )*(user + 0) == 64) {
#line 120
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 120
      if (! tmp___39) {
#line 121
        continue;
      }
    } else {
#line 122
      if (0) {
#line 122
        __s1_len___2 = strlen((char const   *)user);
#line 122
        __s2_len___2 = strlen(client_user);
#line 122
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 122
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 122
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 122
              tmp___49 = 1;
            } else {
#line 122
              if (__s2_len___2 >= 4U) {
#line 122
                tmp___49 = 1;
              } else {
#line 122
                tmp___49 = 0;
              }
            }
          } else {
#line 122
            tmp___49 = 0;
          }
        }
#line 122
        if (tmp___49) {
#line 122
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 122
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
          tmp___45 = tmp___48;
        }
      } else {
#line 122
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
        tmp___45 = tmp___48;
      }
#line 122
      if (tmp___45 != 0) {
#line 123
        continue;
      }
    }
#line 126
    fclose(f);
#line 129
    if (negated) {
#line 130
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 132
      return (0);
    }
#line 135
    return (1);
  }
#line 139
  fclose(f);
#line 140
  return (0);
}
}
#line 156 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 149 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 160
  temporarily_use_uid(pw->pw_uid);
#line 166
  rhosts_file_index = 0U;
#line 166
  while (rhosts_files[rhosts_file_index]) {
#line 169
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 171
    tmp = stat((char const   * __restrict  )(buf), (struct stat * __restrict  )(& st));
#line 171
    if (tmp >= 0) {
#line 172
      break;
    }
#line 166
    rhosts_file_index ++;
  }
#line 175
  restore_uid();
#line 178
  if (! rhosts_files[rhosts_file_index]) {
#line 178
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 178
    if (tmp___0 < 0) {
#line 178
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 178
      if (tmp___1 < 0) {
#line 181
        return (0);
      }
    }
  }
#line 183
  hostname = get_canonical_hostname();
#line 184
  ipaddr = get_remote_ipaddr();
#line 187
  if (pw->pw_uid != 0U) {
#line 188
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 188
    if (tmp___2) {
#line 190
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 192
      return (1);
    }
#line 194
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 194
    if (tmp___3) {
#line 196
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 198
      return (1);
    }
  }
#line 205
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 205
  if (tmp___4 < 0) {
#line 206
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 208
    packet_send_debug("Rhosts authentication refused for %.100: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 210
    return (0);
  }
#line 212
  if (options.strict_modes) {
#line 212
    if (st.st_uid != 0U) {
#line 212
      if (st.st_uid != pw->pw_uid) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 212
      if ((st.st_mode & 18U) != 0U) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      }
    }
  }
#line 222
  temporarily_use_uid(pw->pw_uid);
#line 225
  rhosts_file_index = 0U;
#line 225
  while (rhosts_files[rhosts_file_index]) {
#line 228
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 230
    tmp___5 = stat((char const   * __restrict  )(buf), (struct stat * __restrict  )(& st));
#line 230
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 239
    if (options.strict_modes) {
#line 239
      if (st.st_uid != 0U) {
#line 239
        if (st.st_uid != pw->pw_uid) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 239
        if ((st.st_mode & 18U) != 0U) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf);
          goto __Cont;
        }
      }
    }
#line 248
    if (options.ignore_rhosts) {
#line 249
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 254
    tmp___6 = check_rhosts_file((char const   *)(buf), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 254
    if (tmp___6) {
#line 255
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 258
      restore_uid();
#line 259
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 225
    rhosts_file_index ++;
  }
#line 264
  restore_uid();
#line 265
  return (0);
}
}
#line 1 "auth-passwd.o"
#pragma merger(0,"./auth-passwd.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 89 "auth-passwd.c"
extern int ( /* missing proto */  crypt)() ;
#line 33 "auth-passwd.c"
int auth_password(struct passwd *pw , char const   *password ) 
{ char *encrypted_password ;
  struct spwd *spw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;

  {
#line 42
  if (pw->pw_uid == 0U) {
#line 42
    if (options.permit_root_login == 2) {
#line 43
      return (0);
    }
  }
#line 44
  if ((int const   )*password == 0) {
#line 44
    if (options.permit_empty_passwd == 0) {
#line 45
      return (0);
    }
  }
#line 47
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 48
    return (0);
  }
#line 68
  if (0) {
#line 68
    __s1_len = strlen(password);
#line 68
    __s2_len = strlen("");
#line 68
    if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
      goto _L___0;
    } else {
#line 68
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 68
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 68
          tmp___8 = 1;
        } else {
#line 68
          if (__s2_len >= 4U) {
#line 68
            tmp___8 = 1;
          } else {
#line 68
            tmp___8 = 0;
          }
        }
      } else {
#line 68
        tmp___8 = 0;
      }
    }
#line 68
    if (tmp___8) {
#line 68
      tmp___4 = __builtin_strcmp(password, "");
    } else {
#line 68
      tmp___7 = __builtin_strcmp(password, "");
#line 68
      tmp___4 = tmp___7;
    }
  } else {
#line 68
    tmp___7 = __builtin_strcmp(password, "");
#line 68
    tmp___4 = tmp___7;
  }
#line 68
  if (tmp___4 == 0) {
#line 68
    if (0) {
#line 68
      __s1_len___0 = strlen((char const   *)pw->pw_passwd);
#line 68
      __s2_len___0 = strlen("");
#line 68
      if (! ((unsigned int )((void const   *)(pw->pw_passwd + 1)) - (unsigned int )((void const   *)pw->pw_passwd) == 1U)) {
        goto _L___2;
      } else {
#line 68
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 68
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 68
            tmp___18 = 1;
          } else {
#line 68
            if (__s2_len___0 >= 4U) {
#line 68
              tmp___18 = 1;
            } else {
#line 68
              tmp___18 = 0;
            }
          }
        } else {
#line 68
          tmp___18 = 0;
        }
      }
#line 68
      if (tmp___18) {
#line 68
        tmp___14 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
      } else {
#line 68
        tmp___17 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
#line 68
        tmp___14 = tmp___17;
      }
    } else {
#line 68
      tmp___17 = __builtin_strcmp((char const   *)pw->pw_passwd, "");
#line 68
      tmp___14 = tmp___17;
    }
#line 68
    if (tmp___14 == 0) {
#line 69
      return (1);
    }
  }
#line 72
  spw = getspnam((char const   *)pw->pw_name);
#line 73
  if ((unsigned int )spw == (unsigned int )((void *)0)) {
#line 74
    return (0);
  }
#line 76
  if ((unsigned int )spw->sp_namp == (unsigned int )((void *)0)) {
#line 77
    fatal("Shadow lookup returned garbage.");
  } else {
#line 76
    if (0) {
#line 76
      __s1_len___1 = strlen((char const   *)pw->pw_name);
#line 76
      __s2_len___1 = strlen((char const   *)spw->sp_namp);
#line 76
      if (! ((unsigned int )((void const   *)(pw->pw_name + 1)) - (unsigned int )((void const   *)pw->pw_name) == 1U)) {
        goto _L___4;
      } else {
#line 76
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 76
          if (! ((unsigned int )((void const   *)(spw->sp_namp + 1)) - (unsigned int )((void const   *)spw->sp_namp) == 1U)) {
#line 76
            tmp___28 = 1;
          } else {
#line 76
            if (__s2_len___1 >= 4U) {
#line 76
              tmp___28 = 1;
            } else {
#line 76
              tmp___28 = 0;
            }
          }
        } else {
#line 76
          tmp___28 = 0;
        }
      }
#line 76
      if (tmp___28) {
#line 76
        tmp___24 = __builtin_strcmp((char const   *)pw->pw_name, (char const   *)spw->sp_namp);
      } else {
#line 76
        tmp___27 = __builtin_strcmp((char const   *)pw->pw_name, (char const   *)spw->sp_namp);
#line 76
        tmp___24 = tmp___27;
      }
    } else {
#line 76
      tmp___27 = __builtin_strcmp((char const   *)pw->pw_name, (char const   *)spw->sp_namp);
#line 76
      tmp___24 = tmp___27;
    }
#line 76
    if (tmp___24 != 0) {
#line 77
      fatal("Shadow lookup returned garbage.");
    }
  }
#line 79
  tmp___29 = strlen((char const   *)spw->sp_pwdp);
#line 79
  if (tmp___29 < 3U) {
#line 80
    return (0);
  }
#line 89
  tmp___30 = crypt(password, spw->sp_pwdp);
#line 89
  encrypted_password = (char *)tmp___30;
#line 92
  if (0) {
#line 92
    __s1_len___2 = strlen((char const   *)encrypted_password);
#line 92
    __s2_len___2 = strlen((char const   *)spw->sp_pwdp);
#line 92
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___6;
    } else {
#line 92
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 92
        if (! ((unsigned int )((void const   *)(spw->sp_pwdp + 1)) - (unsigned int )((void const   *)spw->sp_pwdp) == 1U)) {
#line 92
          tmp___40 = 1;
        } else {
#line 92
          if (__s2_len___2 >= 4U) {
#line 92
            tmp___40 = 1;
          } else {
#line 92
            tmp___40 = 0;
          }
        }
      } else {
#line 92
        tmp___40 = 0;
      }
    }
#line 92
    if (tmp___40) {
#line 92
      tmp___36 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)spw->sp_pwdp);
    } else {
#line 92
      tmp___39 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)spw->sp_pwdp);
#line 92
      tmp___36 = tmp___39;
    }
  } else {
#line 92
    tmp___39 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)spw->sp_pwdp);
#line 92
    tmp___36 = tmp___39;
  }
#line 92
  return (tmp___36 == 0);
}
}
#line 1 "auth-rsa.o"
#pragma merger(0,"./auth-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 418 "ssh.h"
int auth_rsa_challenge_dialog(BIGNUM *e , BIGNUM *n___0 ) ;
#line 68 "auth-rsa.c"
int auth_rsa_challenge_dialog(BIGNUM *e , BIGNUM *n___0 ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BIGNUM *aux ;
  RSA *pk ;
  BN_CTX *ctx ;
  BN_CTX *tmp ;
  unsigned char buf[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int tmp___0 ;
  int _p ;
  int _e ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 73
  tmp = BN_CTX_new();
#line 73
  ctx = tmp;
#line 79
  encrypted_challenge = BN_new();
#line 80
  challenge = BN_new();
#line 81
  aux = BN_new();
#line 84
  BN_rand(challenge, 256, 0, 0);
#line 85
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)n___0,
         ctx);
#line 88
  pk = RSA_new();
#line 89
  pk->e = BN_new();
#line 90
  BN_copy(pk->e, (BIGNUM const   *)e);
#line 91
  pk->n = BN_new();
#line 92
  BN_copy(pk->n, (BIGNUM const   *)n___0);
#line 95
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 96
  RSA_free(pk);
#line 99
  packet_start(7);
#line 100
  packet_put_bignum(encrypted_challenge);
#line 101
  packet_send();
#line 102
  packet_write_wait();
#line 105
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 105
  len = (tmp___0 + 7) / 8;
#line 106
  if (len <= 0) {
#line 107
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 106
    if (len > 32) {
#line 107
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 108
  memset((void *)(buf), 0, 32U);
#line 109
  BN_bn2bin((BIGNUM const   *)challenge, (buf + 32) - len);
#line 110
  MD5_Init(& md);
#line 111
  MD5_Update(& md, (void const   *)(buf), 32U);
#line 112
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 113
  MD5_Final(mdbuf, & md);
#line 116
  BN_clear_free(encrypted_challenge);
#line 117
  BN_clear_free(challenge);
#line 118
  BN_clear_free(aux);
#line 119
  BN_CTX_free(ctx);
#line 122
  packet_read_expect(& plen, 8);
#line 123
  while (1) {
#line 123
    _p = plen;
#line 123
    _e = 16;
#line 123
    if (_p != _e) {
#line 123
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 123);
#line 123
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 123
    break;
  }
#line 124
  i = 0U;
#line 124
  while (i < 16U) {
#line 125
    tmp___1 = packet_get_char();
#line 125
    response[i] = (unsigned char )tmp___1;
#line 124
    i ++;
  }
#line 128
  tmp___2 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 128
  if (tmp___2 != 0) {
#line 130
    return (0);
  }
#line 133
  return (1);
}
}
#line 189 "auth-rsa.c"
static char const   *check[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 142 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[1024] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  BIGNUM *e ;
  BIGNUM *n___0 ;
  int tmp ;
  int fail ;
  char buf[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___26 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___43 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t tmp___72 ;
  size_t tmp___78 ;
  int tmp___96 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___102 ;
  int tmp___105 ;
  int tmp___106 ;
  size_t tmp___107 ;
  size_t tmp___113 ;
  int tmp___131 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___137 ;
  int tmp___140 ;
  int tmp___141 ;
  size_t tmp___142 ;
  int i___0 ;
  size_t tmp___148 ;
  size_t tmp___149 ;
  void *tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  char *tmp___153 ;
  int tmp___171 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___177 ;
  int tmp___180 ;
  int tmp___181 ;
  size_t tmp___182 ;
  int i___1 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___188 ;
  size_t tmp___189 ;
  void *tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  char *tmp___193 ;
  void *tmp___194 ;
  int tmp___212 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___218 ;
  int tmp___221 ;
  int tmp___222 ;
  size_t tmp___223 ;
  char *patterns ;
  size_t tmp___229 ;
  void *tmp___230 ;
  int i___2 ;
  size_t tmp___231 ;
  int tmp___232 ;
  int tmp___233 ;
  char *tmp___234 ;
  char const   *tmp___235 ;
  char const   *tmp___236 ;
  char const   *tmp___237 ;
  size_t tmp___238 ;
  char const   *tmp___239 ;
  int tmp___240 ;
  size_t tmp___241 ;
  char const   *tmp___242 ;
  int tmp___243 ;
  int tmp___261 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___267 ;
  int tmp___270 ;
  int tmp___271 ;
  size_t tmp___272 ;
  char *tmp___278 ;

  {
#line 150
  linenum = 0UL;
#line 155
  temporarily_use_uid(pw->pw_uid);
#line 158
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 162
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 162
  if (tmp < 0) {
#line 164
    restore_uid();
#line 165
    return (0);
  }
#line 168
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 169
  if (! f) {
#line 171
    restore_uid();
#line 172
    packet_send_debug("Could not open %.900s for reading.", file);
#line 173
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 174
    return (0);
  }
#line 176
  if (options.strict_modes) {
#line 177
    fail = 0;
#line 180
    tmp___1 = fileno(f);
#line 180
    tmp___2 = fstat(tmp___1, & st);
#line 180
    if (tmp___2 < 0) {
#line 183
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 185
      fail = 1;
    } else {
#line 180
      if (st.st_uid != 0U) {
#line 180
        if (st.st_uid != pw->pw_uid) {
#line 183
          snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 185
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 180
        if ((st.st_mode & 18U) != 0U) {
#line 183
          snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 185
          fail = 1;
        } else {
#line 192
          i = 0;
#line 192
          while (check[i]) {
#line 193
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check[i]);
#line 194
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 194
            if (tmp___0 < 0) {
#line 197
              snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 199
              fail = 1;
#line 200
              break;
            } else {
#line 194
              if (st.st_uid != 0U) {
#line 194
                if (st.st_uid != pw->pw_uid) {
#line 197
                  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 199
                  fail = 1;
#line 200
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 194
                if ((st.st_mode & 18U) != 0U) {
#line 197
                  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 199
                  fail = 1;
#line 200
                  break;
                }
              }
            }
#line 192
            i ++;
          }
        }
      }
    }
#line 204
    if (fail) {
#line 205
      log((char const   *)(buf));
#line 206
      packet_send_debug((char const   *)(buf));
#line 207
      restore_uid();
#line 208
      return (0);
    }
  }
#line 212
  authenticated = 0;
#line 214
  e = BN_new();
#line 215
  n___0 = BN_new();
#line 222
  while (1) {
#line 222
    tmp___278 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 222
    if (! tmp___278) {
#line 222
      break;
    }
#line 226
    linenum ++;
#line 229
    cp = line;
#line 229
    while (1) {
#line 229
      if (! ((int )*cp == 32)) {
#line 229
        if (! ((int )*cp == 9)) {
#line 229
          break;
        }
      }
#line 229
      cp ++;
    }
#line 231
    if (! *cp) {
#line 232
      continue;
    } else {
#line 231
      if ((int )*cp == 10) {
#line 232
        continue;
      } else {
#line 231
        if ((int )*cp == 35) {
#line 232
          continue;
        }
      }
    }
#line 240
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 240
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 241
        quoted = 0;
#line 242
        options___0 = cp;
#line 243
        while (1) {
#line 243
          if (*cp) {
#line 243
            if (! quoted) {
#line 243
              if ((int )*cp != 32) {
#line 243
                if (! ((int )*cp != 9)) {
#line 243
                  break;
                }
              } else {
#line 243
                break;
              }
            }
          } else {
#line 243
            break;
          }
#line 244
          if ((int )*cp == 92) {
#line 244
            if ((int )*(cp + 1) == 34) {
#line 245
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 246
            if ((int )*cp == 34) {
#line 247
              quoted = ! quoted;
            }
          }
#line 243
          cp ++;
        }
      } else {
#line 250
        options___0 = (char *)((void *)0);
      }
    }
#line 253
    tmp___3 = auth_rsa_read_key(& cp, & bits, e, n___0);
#line 253
    if (! tmp___3) {
#line 254
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 256
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 258
      continue;
    }
#line 263
    tmp___4 = BN_cmp((BIGNUM const   *)n___0, (BIGNUM const   *)client_n);
#line 263
    if (tmp___4 != 0) {
#line 264
      continue;
    }
#line 267
    tmp___6 = BN_num_bits((BIGNUM const   *)n___0);
#line 267
    if (bits != (unsigned int )tmp___6) {
#line 268
      tmp___5 = BN_num_bits((BIGNUM const   *)n___0);
#line 268
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 275
    tmp___7 = auth_rsa_challenge_dialog(e, n___0);
#line 275
    if (! tmp___7) {
#line 277
      verbose("Wrong response to RSA authentication challenge.");
#line 278
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 279
      continue;
    }
#line 287
    authenticated = 1;
#line 290
    if (options___0) {
#line 291
      while (1) {
#line 291
        if (*options___0) {
#line 291
          if ((int )*options___0 != 32) {
#line 291
            if (! ((int )*options___0 != 9)) {
#line 291
              break;
            }
          } else {
#line 291
            break;
          }
        } else {
#line 291
          break;
        }
#line 292
        cp = (char *)"no-port-forwarding";
#line 293
        if (0) {
#line 293
          if (0) {
#line 293
            __s1_len___0 = strlen((char const   *)options___0);
#line 293
            __s2_len___0 = strlen((char const   *)cp);
#line 293
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___6;
            } else {
#line 293
              if (__s1_len___0 >= 4U) {
                _L___6: /* CIL Label */ 
#line 293
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 293
                  tmp___36 = 1;
                } else {
#line 293
                  if (__s2_len___0 >= 4U) {
#line 293
                    tmp___36 = 1;
                  } else {
#line 293
                    tmp___36 = 0;
                  }
                }
              } else {
#line 293
                tmp___36 = 0;
              }
            }
#line 293
            if (tmp___36) {
#line 293
              tmp___32 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 293
              tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 293
              tmp___32 = tmp___35;
            }
          } else {
#line 293
            tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 293
            tmp___32 = tmp___35;
          }
#line 293
          tmp___26 = tmp___32;
        } else {
#line 293
          tmp___37 = strlen((char const   *)cp);
#line 293
          tmp___26 = strncmp((char const   *)options___0, (char const   *)cp, tmp___37);
        }
#line 293
        if (tmp___26 == 0) {
#line 294
          packet_send_debug("Port forwarding disabled.");
#line 295
          no_port_forwarding_flag = 1;
#line 296
          tmp___8 = strlen((char const   *)cp);
#line 296
          options___0 += tmp___8;
          goto next_option;
        }
#line 299
        cp = (char *)"no-agent-forwarding";
#line 300
        if (0) {
#line 300
          if (0) {
#line 300
            __s1_len___2 = strlen((char const   *)options___0);
#line 300
            __s2_len___2 = strlen((char const   *)cp);
#line 300
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___10;
            } else {
#line 300
              if (__s1_len___2 >= 4U) {
                _L___10: /* CIL Label */ 
#line 300
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 300
                  tmp___71 = 1;
                } else {
#line 300
                  if (__s2_len___2 >= 4U) {
#line 300
                    tmp___71 = 1;
                  } else {
#line 300
                    tmp___71 = 0;
                  }
                }
              } else {
#line 300
                tmp___71 = 0;
              }
            }
#line 300
            if (tmp___71) {
#line 300
              tmp___67 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 300
              tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 300
              tmp___67 = tmp___70;
            }
          } else {
#line 300
            tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 300
            tmp___67 = tmp___70;
          }
#line 300
          tmp___61 = tmp___67;
        } else {
#line 300
          tmp___72 = strlen((char const   *)cp);
#line 300
          tmp___61 = strncmp((char const   *)options___0, (char const   *)cp, tmp___72);
        }
#line 300
        if (tmp___61 == 0) {
#line 301
          packet_send_debug("Agent forwarding disabled.");
#line 302
          no_agent_forwarding_flag = 1;
#line 303
          tmp___43 = strlen((char const   *)cp);
#line 303
          options___0 += tmp___43;
          goto next_option;
        }
#line 306
        cp = (char *)"no-X11-forwarding";
#line 307
        if (0) {
#line 307
          if (0) {
#line 307
            __s1_len___4 = strlen((char const   *)options___0);
#line 307
            __s2_len___4 = strlen((char const   *)cp);
#line 307
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___14;
            } else {
#line 307
              if (__s1_len___4 >= 4U) {
                _L___14: /* CIL Label */ 
#line 307
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 307
                  tmp___106 = 1;
                } else {
#line 307
                  if (__s2_len___4 >= 4U) {
#line 307
                    tmp___106 = 1;
                  } else {
#line 307
                    tmp___106 = 0;
                  }
                }
              } else {
#line 307
                tmp___106 = 0;
              }
            }
#line 307
            if (tmp___106) {
#line 307
              tmp___102 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 307
              tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 307
              tmp___102 = tmp___105;
            }
          } else {
#line 307
            tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 307
            tmp___102 = tmp___105;
          }
#line 307
          tmp___96 = tmp___102;
        } else {
#line 307
          tmp___107 = strlen((char const   *)cp);
#line 307
          tmp___96 = strncmp((char const   *)options___0, (char const   *)cp, tmp___107);
        }
#line 307
        if (tmp___96 == 0) {
#line 308
          packet_send_debug("X11 forwarding disabled.");
#line 309
          no_x11_forwarding_flag = 1;
#line 310
          tmp___78 = strlen((char const   *)cp);
#line 310
          options___0 += tmp___78;
          goto next_option;
        }
#line 313
        cp = (char *)"no-pty";
#line 314
        if (0) {
#line 314
          if (0) {
#line 314
            __s1_len___6 = strlen((char const   *)options___0);
#line 314
            __s2_len___6 = strlen((char const   *)cp);
#line 314
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___18;
            } else {
#line 314
              if (__s1_len___6 >= 4U) {
                _L___18: /* CIL Label */ 
#line 314
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 314
                  tmp___141 = 1;
                } else {
#line 314
                  if (__s2_len___6 >= 4U) {
#line 314
                    tmp___141 = 1;
                  } else {
#line 314
                    tmp___141 = 0;
                  }
                }
              } else {
#line 314
                tmp___141 = 0;
              }
            }
#line 314
            if (tmp___141) {
#line 314
              tmp___137 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 314
              tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 314
              tmp___137 = tmp___140;
            }
          } else {
#line 314
            tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 314
            tmp___137 = tmp___140;
          }
#line 314
          tmp___131 = tmp___137;
        } else {
#line 314
          tmp___142 = strlen((char const   *)cp);
#line 314
          tmp___131 = strncmp((char const   *)options___0, (char const   *)cp, tmp___142);
        }
#line 314
        if (tmp___131 == 0) {
#line 315
          packet_send_debug("Pty allocation disabled.");
#line 316
          no_pty_flag = 1;
#line 317
          tmp___113 = strlen((char const   *)cp);
#line 317
          options___0 += tmp___113;
          goto next_option;
        }
#line 320
        cp = (char *)"command=\"";
#line 321
        if (0) {
#line 321
          if (0) {
#line 321
            __s1_len___8 = strlen((char const   *)options___0);
#line 321
            __s2_len___8 = strlen((char const   *)cp);
#line 321
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___22;
            } else {
#line 321
              if (__s1_len___8 >= 4U) {
                _L___22: /* CIL Label */ 
#line 321
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 321
                  tmp___181 = 1;
                } else {
#line 321
                  if (__s2_len___8 >= 4U) {
#line 321
                    tmp___181 = 1;
                  } else {
#line 321
                    tmp___181 = 0;
                  }
                }
              } else {
#line 321
                tmp___181 = 0;
              }
            }
#line 321
            if (tmp___181) {
#line 321
              tmp___177 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 321
              tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 321
              tmp___177 = tmp___180;
            }
          } else {
#line 321
            tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 321
            tmp___177 = tmp___180;
          }
#line 321
          tmp___171 = tmp___177;
        } else {
#line 321
          tmp___182 = strlen((char const   *)cp);
#line 321
          tmp___171 = strncmp((char const   *)options___0, (char const   *)cp, tmp___182);
        }
#line 321
        if (tmp___171 == 0) {
#line 323
          tmp___148 = strlen((char const   *)cp);
#line 323
          options___0 += tmp___148;
#line 324
          tmp___149 = strlen((char const   *)options___0);
#line 324
          tmp___150 = xmalloc(tmp___149 + 1U);
#line 324
          forced_command = (char *)tmp___150;
#line 325
          i___0 = 0;
#line 326
          while (*options___0) {
#line 327
            if ((int )*options___0 == 34) {
#line 328
              break;
            }
#line 329
            if ((int )*options___0 == 92) {
#line 329
              if ((int )*(options___0 + 1) == 34) {
#line 330
                options___0 += 2;
#line 331
                tmp___151 = i___0;
#line 331
                i___0 ++;
#line 331
                *(forced_command + tmp___151) = (char )'\"';
#line 332
                continue;
              }
            }
#line 334
            tmp___152 = i___0;
#line 334
            i___0 ++;
#line 334
            tmp___153 = options___0;
#line 334
            options___0 ++;
#line 334
            *(forced_command + tmp___152) = *tmp___153;
          }
#line 336
          if (! *options___0) {
#line 337
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 339
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 341
            continue;
          }
#line 343
          *(forced_command + i___0) = (char)0;
#line 344
          packet_send_debug("Forced command: %.900s", forced_command);
#line 345
          options___0 ++;
          goto next_option;
        }
#line 348
        cp = (char *)"environment=\"";
#line 349
        if (0) {
#line 349
          if (0) {
#line 349
            __s1_len___10 = strlen((char const   *)options___0);
#line 349
            __s2_len___10 = strlen((char const   *)cp);
#line 349
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___26;
            } else {
#line 349
              if (__s1_len___10 >= 4U) {
                _L___26: /* CIL Label */ 
#line 349
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 349
                  tmp___222 = 1;
                } else {
#line 349
                  if (__s2_len___10 >= 4U) {
#line 349
                    tmp___222 = 1;
                  } else {
#line 349
                    tmp___222 = 0;
                  }
                }
              } else {
#line 349
                tmp___222 = 0;
              }
            }
#line 349
            if (tmp___222) {
#line 349
              tmp___218 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 349
              tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 349
              tmp___218 = tmp___221;
            }
          } else {
#line 349
            tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 349
            tmp___218 = tmp___221;
          }
#line 349
          tmp___212 = tmp___218;
        } else {
#line 349
          tmp___223 = strlen((char const   *)cp);
#line 349
          tmp___212 = strncmp((char const   *)options___0, (char const   *)cp, tmp___223);
        }
#line 349
        if (tmp___212 == 0) {
#line 353
          tmp___188 = strlen((char const   *)cp);
#line 353
          options___0 += tmp___188;
#line 354
          tmp___189 = strlen((char const   *)options___0);
#line 354
          tmp___190 = xmalloc(tmp___189 + 1U);
#line 354
          s = (char *)tmp___190;
#line 355
          i___1 = 0;
#line 356
          while (*options___0) {
#line 357
            if ((int )*options___0 == 34) {
#line 358
              break;
            }
#line 359
            if ((int )*options___0 == 92) {
#line 359
              if ((int )*(options___0 + 1) == 34) {
#line 360
                options___0 += 2;
#line 361
                tmp___191 = i___1;
#line 361
                i___1 ++;
#line 361
                *(s + tmp___191) = (char )'\"';
#line 362
                continue;
              }
            }
#line 364
            tmp___192 = i___1;
#line 364
            i___1 ++;
#line 364
            tmp___193 = options___0;
#line 364
            options___0 ++;
#line 364
            *(s + tmp___192) = *tmp___193;
          }
#line 366
          if (! *options___0) {
#line 367
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 369
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 371
            continue;
          }
#line 373
          *(s + i___1) = (char)0;
#line 374
          packet_send_debug("Adding to environment: %.900s", s);
#line 375
          debug("Adding to environment: %.900s", s);
#line 376
          options___0 ++;
#line 377
          tmp___194 = xmalloc(sizeof(struct envstring ));
#line 377
          new_envstring = (struct envstring *)tmp___194;
#line 378
          new_envstring->s = s;
#line 379
          new_envstring->next = custom_environment;
#line 380
          custom_environment = new_envstring;
          goto next_option;
        }
#line 383
        cp = (char *)"from=\"";
#line 384
        if (0) {
#line 384
          if (0) {
#line 384
            __s1_len___12 = strlen((char const   *)options___0);
#line 384
            __s2_len___12 = strlen((char const   *)cp);
#line 384
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___30;
            } else {
#line 384
              if (__s1_len___12 >= 4U) {
                _L___30: /* CIL Label */ 
#line 384
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 384
                  tmp___271 = 1;
                } else {
#line 384
                  if (__s2_len___12 >= 4U) {
#line 384
                    tmp___271 = 1;
                  } else {
#line 384
                    tmp___271 = 0;
                  }
                }
              } else {
#line 384
                tmp___271 = 0;
              }
            }
#line 384
            if (tmp___271) {
#line 384
              tmp___267 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 384
              tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 384
              tmp___267 = tmp___270;
            }
          } else {
#line 384
            tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 384
            tmp___267 = tmp___270;
          }
#line 384
          tmp___261 = tmp___267;
        } else {
#line 384
          tmp___272 = strlen((char const   *)cp);
#line 384
          tmp___261 = strncmp((char const   *)options___0, (char const   *)cp, tmp___272);
        }
#line 384
        if (tmp___261 == 0) {
#line 385
          tmp___229 = strlen((char const   *)options___0);
#line 385
          tmp___230 = xmalloc(tmp___229 + 1U);
#line 385
          patterns = (char *)tmp___230;
#line 387
          tmp___231 = strlen((char const   *)cp);
#line 387
          options___0 += tmp___231;
#line 388
          i___2 = 0;
#line 389
          while (*options___0) {
#line 390
            if ((int )*options___0 == 34) {
#line 391
              break;
            }
#line 392
            if ((int )*options___0 == 92) {
#line 392
              if ((int )*(options___0 + 1) == 34) {
#line 393
                options___0 += 2;
#line 394
                tmp___232 = i___2;
#line 394
                i___2 ++;
#line 394
                *(patterns + tmp___232) = (char )'\"';
#line 395
                continue;
              }
            }
#line 397
            tmp___233 = i___2;
#line 397
            i___2 ++;
#line 397
            tmp___234 = options___0;
#line 397
            options___0 ++;
#line 397
            *(patterns + tmp___233) = *tmp___234;
          }
#line 399
          if (! *options___0) {
#line 400
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 402
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 404
            continue;
          }
#line 406
          *(patterns + i___2) = (char)0;
#line 407
          options___0 ++;
#line 408
          tmp___238 = strlen((char const   *)patterns);
#line 408
          tmp___239 = get_canonical_hostname();
#line 408
          tmp___240 = match_hostname(tmp___239, (char const   *)patterns, tmp___238);
#line 408
          if (! tmp___240) {
#line 408
            tmp___241 = strlen((char const   *)patterns);
#line 408
            tmp___242 = get_remote_ipaddr();
#line 408
            tmp___243 = match_hostname(tmp___242, (char const   *)patterns, tmp___241);
#line 408
            if (! tmp___243) {
#line 412
              tmp___235 = get_remote_ipaddr();
#line 412
              tmp___236 = get_canonical_hostname();
#line 412
              log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___236, tmp___235);
#line 415
              tmp___237 = get_canonical_hostname();
#line 415
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___237);
#line 417
              xfree((void *)patterns);
#line 418
              authenticated = 0;
#line 419
              break;
            }
          }
#line 421
          xfree((void *)patterns);
          goto next_option;
        }
        bad_option: 
#line 426
        log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
            linenum, options___0);
#line 428
        packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                          linenum, options___0);
#line 430
        authenticated = 0;
#line 431
        break;
        next_option: 
#line 438
        if (! *options___0) {
#line 439
          fatal("Bugs in auth-rsa.c option processing.");
        }
#line 440
        if ((int )*options___0 == 32) {
#line 441
          break;
        } else {
#line 440
          if ((int )*options___0 == 9) {
#line 441
            break;
          }
        }
#line 442
        if ((int )*options___0 != 44) {
          goto bad_option;
        }
#line 444
        options___0 ++;
#line 446
        continue;
      }
    }
#line 453
    if (authenticated) {
#line 454
      break;
    }
  }
#line 458
  restore_uid();
#line 461
  fclose(f);
#line 463
  BN_clear_free(n___0);
#line 464
  BN_clear_free(e);
#line 466
  if (authenticated) {
#line 467
    packet_send_debug("RSA authentication accepted.");
  }
#line 470
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#pragma merger(0,"./auth-rh-rsa.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 458 "/usr/include/openssl/bn.h"
extern void BN_free(BIGNUM *a ) ;
#line 31 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , BIGNUM *client_host_key_e ,
                    BIGNUM *client_host_key_n ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  BIGNUM *ke ;
  BIGNUM *kn ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 40
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 43
  tmp = auth_rhosts(pw, client_user);
#line 43
  if (! tmp) {
#line 44
    return (0);
  }
#line 46
  canonical_hostname = get_canonical_hostname();
#line 48
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 52
  ke = BN_new();
#line 53
  kn = BN_new();
#line 54
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_host_key_e, client_host_key_n, ke, kn);
#line 59
  if ((int )host_status != 0) {
#line 59
    if (! options.ignore_user_known_hosts) {
#line 61
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 61
      user_hostfile = tmp___0;
#line 66
      if (options.strict_modes) {
#line 66
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 66
        if (tmp___1 == 0) {
#line 66
          if (st.st_uid != 0U) {
#line 66
            if (st.st_uid != pw->pw_uid) {
#line 70
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 66
            if ((st.st_mode & 18U) != 0U) {
#line 70
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 74
              temporarily_use_uid(pw->pw_uid);
#line 75
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_host_key_e,
                                                   client_host_key_n, ke, kn);
#line 78
              restore_uid();
            }
          }
        } else {
#line 74
          temporarily_use_uid(pw->pw_uid);
#line 75
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_host_key_e, client_host_key_n,
                                               ke, kn);
#line 78
          restore_uid();
        }
      } else {
#line 74
        temporarily_use_uid(pw->pw_uid);
#line 75
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_host_key_e, client_host_key_n,
                                             ke, kn);
#line 78
        restore_uid();
      }
#line 80
      xfree((void *)user_hostfile);
    }
  }
#line 82
  BN_free(ke);
#line 83
  BN_free(kn);
#line 85
  if ((int )host_status != 0) {
#line 86
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 87
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 88
    return (0);
  }
#line 93
  tmp___2 = auth_rsa_challenge_dialog(client_host_key_e, client_host_key_n);
#line 93
  if (! tmp___2) {
#line 94
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 96
    return (0);
  }
#line 103
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 105
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 106
  return (1);
}
}
#line 1 "pty.o"
#pragma merger(0,"./pty.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 57 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 49 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char buf[64] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 57
  i = openpty(ptyfd, ttyfd, buf, (void *)0, (void *)0);
#line 58
  if (i < 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("openpty: %.100s", tmp___0);
#line 60
    return (0);
  }
#line 62
  strlcpy(namebuf, (char const   *)(buf), (unsigned int )namebuflen);
#line 63
  return (1);
}
}
#line 187 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 190
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 190
  if (tmp___1 < 0) {
#line 191
    tmp = __errno_location();
#line 191
    tmp___0 = strerror(*tmp);
#line 191
    debug("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 192
  tmp___4 = chmod(ttyname___0, 438U);
#line 192
  if (tmp___4 < 0) {
#line 193
    tmp___2 = __errno_location();
#line 193
    tmp___3 = strerror(*tmp___2);
#line 193
    debug("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 194
  return;
}
}
#line 198 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 205
  fd = open("/dev/tty", 258);
#line 206
  if (fd >= 0) {
#line 207
    ioctl(fd, 21538UL, (void *)0);
#line 208
    close(fd);
  }
#line 211
  tmp___1 = setsid();
#line 211
  if (tmp___1 < 0) {
#line 212
    tmp = __errno_location();
#line 212
    tmp___0 = strerror(*tmp);
#line 212
    error("setsid: %.100s", tmp___0);
  }
#line 218
  fd = open("/dev/tty", 258);
#line 219
  if (fd >= 0) {
#line 220
    error("Failed to disconnect from controlling tty.");
#line 221
    close(fd);
  }
#line 225
  debug("Setting controlling tty using TIOCSCTTY.");
#line 231
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 233
  fd = open(ttyname___0, 2);
#line 234
  if (fd < 0) {
#line 235
    tmp___2 = __errno_location();
#line 235
    tmp___3 = strerror(*tmp___2);
#line 235
    error("%.100s: %.100s", ttyname___0, tmp___3);
  } else {
#line 237
    close(fd);
  }
#line 240
  fd = open("/dev/tty", 1);
#line 241
  if (fd < 0) {
#line 242
    tmp___4 = __errno_location();
#line 242
    tmp___5 = strerror(*tmp___4);
#line 242
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___5);
  } else {
#line 245
    close(fd);
  }
#line 247
  return;
}
}
#line 251 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 256
  w.ws_row = (unsigned short )row;
#line 257
  w.ws_col = (unsigned short )col;
#line 258
  w.ws_xpixel = (unsigned short )xpixel;
#line 259
  w.ws_ypixel = (unsigned short )ypixel;
#line 260
  ioctl(ptyfd, 21524UL, & w);
#line 261
  return;
}
}
#line 1 "log-server.o"
#pragma merger(0,"./log-server.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "log-server.c"
extern char *__progname ;
#line 31 "log-server.c"
static LogLevel log_level  =    3;
#line 32 "log-server.c"
static int log_on_stderr  =    0;
#line 33 "log-server.c"
static int log_facility  =    4 << 3;
#line 41 "log-server.c"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 44
  switch ((int )level) {
  case 0: 
  case 2: 
  case 1: 
  case 3: 
  case 4: 
  case 5: 
#line 51
  log_level = level;
#line 52
  break;
  default: 
#line 54
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 56
  exit(1);
  }
#line 58
  switch ((int )facility) {
  case 0: 
#line 60
  log_facility = 3 << 3;
#line 61
  break;
  case 1: 
#line 63
  log_facility = 1 << 3;
#line 64
  break;
  case 2: 
#line 66
  log_facility = 4 << 3;
#line 67
  break;
  case 3: 
#line 69
  log_facility = 16 << 3;
#line 70
  break;
  case 4: 
#line 72
  log_facility = 17 << 3;
#line 73
  break;
  case 5: 
#line 75
  log_facility = 18 << 3;
#line 76
  break;
  case 6: 
#line 78
  log_facility = 19 << 3;
#line 79
  break;
  case 7: 
#line 81
  log_facility = 20 << 3;
#line 82
  break;
  case 8: 
#line 84
  log_facility = 21 << 3;
#line 85
  break;
  case 9: 
#line 87
  log_facility = 22 << 3;
#line 88
  break;
  case 10: 
#line 90
  log_facility = 23 << 3;
#line 91
  break;
  default: 
#line 93
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 95
  exit(1);
  }
#line 97
  log_on_stderr = on_stderr;
#line 98
  return;
}
}
#line 102 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 107
  txt = (char *)((void *)0);
#line 108
  pri = 6;
#line 110
  if ((int )level > (int )log_level) {
#line 111
    return;
  }
#line 112
  switch ((int )level) {
  case 2: 
#line 114
  txt = (char *)"error";
#line 115
  pri = 3;
#line 116
  break;
  case 1: 
#line 118
  txt = (char *)"fatal";
#line 119
  pri = 3;
#line 120
  break;
  case 3: 
  case 4: 
#line 123
  pri = 6;
#line 124
  break;
  case 5: 
#line 126
  txt = (char *)"debug";
#line 127
  pri = 7;
#line 128
  break;
  default: 
#line 130
  txt = (char *)"internal error";
#line 131
  pri = 3;
#line 132
  break;
  }
#line 134
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 135
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 136
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 138
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 140
  if (log_on_stderr) {
#line 141
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  }
#line 142
  openlog((char const   *)__progname, 1, log_facility);
#line 143
  syslog(pri, "%.500s", msgbuf);
#line 144
  closelog();
#line 145
  return;
}
}
#line 1 "login.o"
#pragma merger(0,"./login.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 52 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf ,
                                  unsigned int bufsize ) 
{ struct lastlog ll ;
  char *lastlog ;
  int fd ;
  ssize_t tmp ;

  {
#line 60
  lastlog = (char *)"/var/log/lastlog";
#line 61
  *(buf + 0) = (char )'\000';
#line 63
  fd = open((char const   *)lastlog, 0);
#line 64
  if (fd < 0) {
#line 65
    return (0UL);
  }
#line 66
  lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)), 0);
#line 67
  tmp = read(fd, (void *)(& ll), sizeof(ll));
#line 67
  if ((unsigned int )tmp != sizeof(ll)) {
#line 68
    close(fd);
#line 69
    return (0UL);
  }
#line 71
  close(fd);
#line 72
  if (bufsize > sizeof(ll.ll_host) + 1U) {
#line 73
    bufsize = sizeof(ll.ll_host) + 1U;
  }
#line 74
  __builtin_strncpy(buf, (char const   *)(ll.ll_host), bufsize - 1U);
#line 75
  *(buf + (bufsize - 1U)) = (char)0;
#line 76
  return ((unsigned long )ll.ll_time);
}
}
#line 84 "login.c"
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr_in *addr ) 
{ int fd ;
  struct lastlog ll ;
  char *lastlog ;
  struct utmpx u ;
  char const   *utmp ;
  char const   *wtmp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 95
  memset((void *)(& u), 0, sizeof(u));
#line 96
  __builtin_strncpy(u.ut_line, ttyname___0 + 5, sizeof(u.ut_line));
#line 98
  u.ut_tv.tv_sec = time((time_t *)((void *)0));
#line 99
  __builtin_strncpy(u.ut_user, user, sizeof(u.ut_user));
#line 105
  __builtin_strncpy(u.ut_host, host, sizeof(u.ut_host));
#line 109
  utmp = "/var/run/utmp";
#line 110
  wtmp = "/var/log/wtmp";
#line 112
  login((struct utmp  const  *)(& u));
#line 113
  lastlog = (char *)"/var/log/lastlog";
#line 116
  if (0) {
#line 116
    __s1_len = strlen(user);
#line 116
    __s2_len = strlen("");
#line 116
    if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
      goto _L___0;
    } else {
#line 116
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 116
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 116
          tmp___11 = 1;
        } else {
#line 116
          if (__s2_len >= 4U) {
#line 116
            tmp___11 = 1;
          } else {
#line 116
            tmp___11 = 0;
          }
        }
      } else {
#line 116
        tmp___11 = 0;
      }
    }
#line 116
    if (tmp___11) {
#line 116
      tmp___7 = __builtin_strcmp(user, "");
    } else {
#line 116
      tmp___10 = __builtin_strcmp(user, "");
#line 116
      tmp___7 = tmp___10;
    }
  } else {
#line 116
    tmp___10 = __builtin_strcmp(user, "");
#line 116
    tmp___7 = tmp___10;
  }
#line 116
  if (tmp___7 != 0) {
#line 121
    memset((void *)(& ll), 0, sizeof(ll));
#line 124
    ll.ll_time = time((time_t *)((void *)0));
#line 125
    __builtin_strncpy(ll.ll_line, ttyname___0 + 5, sizeof(ll.ll_line));
#line 126
    __builtin_strncpy(ll.ll_host, host, sizeof(ll.ll_host));
#line 127
    fd = open((char const   *)lastlog, 2);
#line 128
    if (fd >= 0) {
#line 129
      lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)),
            0);
#line 130
      tmp___1 = write(fd, (void const   *)(& ll), sizeof(ll));
#line 130
      if ((unsigned int )tmp___1 != sizeof(ll)) {
#line 131
        tmp = __errno_location();
#line 131
        tmp___0 = strerror(*tmp);
#line 131
        log("Could not write %.100s: %.100s", lastlog, tmp___0);
      }
#line 132
      close(fd);
    }
  }
#line 135
  return;
}
}
#line 139 "login.c"
void record_logout(int pid , char const   *ttyname___0 ) 
{ char const   *line ;
  int tmp ;

  {
#line 143
  line = ttyname___0 + 5;
#line 144
  tmp = logout(line);
#line 144
  if (tmp) {
#line 145
    logwtmp(line, "", "");
  }
#line 149
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "servconf.o"
#pragma merger(0,"./servconf.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 270 "/usr/include/netdb.h"
extern void endservent(void) ;
#line 284
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 23 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ register unsigned int __v ;
  register unsigned int __x ;

  {
#line 26
  memset((void *)options___0, 0, sizeof(*options___0));
#line 27
  options___0->port = -1;
#line 28
  __x = 0U;
#line 28
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 28
  options___0->listen_addr.s_addr = __v;
#line 29
  options___0->host_key_file = (char *)((void *)0);
#line 30
  options___0->server_key_bits = -1;
#line 31
  options___0->login_grace_time = -1;
#line 32
  options___0->key_regeneration_time = -1;
#line 33
  options___0->permit_root_login = -1;
#line 34
  options___0->ignore_rhosts = -1;
#line 35
  options___0->ignore_user_known_hosts = -1;
#line 36
  options___0->print_motd = -1;
#line 37
  options___0->check_mail = -1;
#line 38
  options___0->x11_forwarding = -1;
#line 39
  options___0->x11_display_offset = -1;
#line 40
  options___0->strict_modes = -1;
#line 41
  options___0->keepalives = -1;
#line 42
  options___0->log_facility = (enum __anonenum_SyslogFacility_72 )-1;
#line 43
  options___0->log_level = (enum __anonenum_LogLevel_73 )-1;
#line 44
  options___0->rhosts_authentication = -1;
#line 45
  options___0->rhosts_rsa_authentication = -1;
#line 46
  options___0->rsa_authentication = -1;
#line 56
  options___0->password_authentication = -1;
#line 60
  options___0->permit_empty_passwd = -1;
#line 61
  options___0->use_login = -1;
#line 62
  options___0->num_allow_users = 0U;
#line 63
  options___0->num_deny_users = 0U;
#line 64
  options___0->num_allow_groups = 0U;
#line 65
  options___0->num_deny_groups = 0U;
#line 66
  return;
}
}
#line 68 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ struct servent *sp ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 71
  if (options___0->port == -1) {
#line 74
    sp = getservbyname("ssh", "tcp");
#line 75
    if (sp) {
#line 76
      __x = (unsigned short )sp->s_port;
#line 76
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 76
      options___0->port = (int )__v;
    } else {
#line 78
      options___0->port = 22;
    }
#line 79
    endservent();
  }
#line 81
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 82
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 83
  if (options___0->server_key_bits == -1) {
#line 84
    options___0->server_key_bits = 768;
  }
#line 85
  if (options___0->login_grace_time == -1) {
#line 86
    options___0->login_grace_time = 600;
  }
#line 87
  if (options___0->key_regeneration_time == -1) {
#line 88
    options___0->key_regeneration_time = 3600;
  }
#line 89
  if (options___0->permit_root_login == -1) {
#line 90
    options___0->permit_root_login = 1;
  }
#line 91
  if (options___0->ignore_rhosts == -1) {
#line 92
    options___0->ignore_rhosts = 0;
  }
#line 93
  if (options___0->ignore_user_known_hosts == -1) {
#line 94
    options___0->ignore_user_known_hosts = 0;
  }
#line 95
  if (options___0->check_mail == -1) {
#line 96
    options___0->check_mail = 0;
  }
#line 97
  if (options___0->print_motd == -1) {
#line 98
    options___0->print_motd = 1;
  }
#line 99
  if (options___0->x11_forwarding == -1) {
#line 100
    options___0->x11_forwarding = 1;
  }
#line 101
  if (options___0->x11_display_offset == -1) {
#line 102
    options___0->x11_display_offset = 1;
  }
#line 103
  if (options___0->strict_modes == -1) {
#line 104
    options___0->strict_modes = 1;
  }
#line 105
  if (options___0->keepalives == -1) {
#line 106
    options___0->keepalives = 1;
  }
#line 107
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 108
    options___0->log_facility = 2;
  }
#line 109
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 110
    options___0->log_level = 3;
  }
#line 111
  if (options___0->rhosts_authentication == -1) {
#line 112
    options___0->rhosts_authentication = 0;
  }
#line 113
  if (options___0->rhosts_rsa_authentication == -1) {
#line 114
    options___0->rhosts_rsa_authentication = 1;
  }
#line 115
  if (options___0->rsa_authentication == -1) {
#line 116
    options___0->rsa_authentication = 1;
  }
#line 131
  if (options___0->password_authentication == -1) {
#line 132
    options___0->password_authentication = 1;
  }
#line 137
  if (options___0->permit_empty_passwd == -1) {
#line 138
    options___0->permit_empty_passwd = 1;
  }
#line 139
  if (options___0->use_login == -1) {
#line 140
    options___0->use_login = 0;
  }
#line 141
  return;
}
}
#line 168 "servconf.c"
static struct __anonstruct_keywords_76 keywords[29]  = 
#line 168
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"ignoreuserknownhosts", 28}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 220 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  int tmp ;

  {
#line 226
  i = 0U;
#line 226
  while (keywords[i].name) {
#line 227
    tmp = strcasecmp(cp, keywords[i].name);
#line 227
    if (tmp == 0) {
#line 228
      return (keywords[i].opcode);
    }
#line 226
    i ++;
  }
#line 230
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 232
  return (0);
}
}
#line 237 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  unsigned int tmp___30 ;
  __uid_t tmp___31 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___77 ;
  int tmp___80 ;
  int tmp___81 ;
  SyslogFacility tmp___82 ;
  char const   *tmp___83 ;
  LogLevel tmp___84 ;
  char const   *tmp___85 ;
  unsigned int tmp___86 ;
  unsigned int tmp___87 ;
  unsigned int tmp___88 ;
  unsigned int tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;

  {
#line 244
  bad_options = 0;
#line 247
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 248
  if (! f) {
#line 249
    perror(filename);
#line 250
    exit(1);
  }
#line 252
  linenum = 0;
#line 253
  while (1) {
#line 253
    tmp___91 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 253
    if (! tmp___91) {
#line 253
      break;
    }
#line 254
    linenum ++;
#line 255
    tmp___30 = __builtin_strspn((char const   *)(line), " \t\r\n");
#line 255
    cp = line + tmp___30;
#line 256
    if (! *cp) {
#line 257
      continue;
    } else {
#line 256
      if ((int )*cp == 35) {
#line 257
        continue;
      }
    }
#line 258
    cp = strtok((char * __restrict  )cp, (char const   * __restrict  )" \t\r\n");
#line 259
    opcode = parse_token((char const   *)cp, filename, linenum);
#line 260
    switch ((int )opcode) {
    case 0: 
#line 262
    bad_options ++;
#line 263
    continue;
    case 1: 
#line 265
    intptr = & options___0->port;
    parse_int: 
#line 267
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 268
    if (! cp) {
#line 269
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 271
      exit(1);
    }
#line 273
    value = atoi((char const   *)cp);
#line 274
    if (*intptr == -1) {
#line 275
      *intptr = value;
    }
#line 276
    break;
    case 3: 
#line 279
    intptr = & options___0->server_key_bits;
    goto parse_int;
    case 4: 
#line 283
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 287
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 291
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 292
    if (! cp) {
#line 293
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing inet addr.\n",
              filename, linenum);
#line 295
      exit(1);
    }
#line 297
    options___0->listen_addr.s_addr = inet_addr((char const   *)cp);
#line 298
    break;
    case 2: 
#line 301
    charptr = & options___0->host_key_file;
#line 302
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 303
    if (! cp) {
#line 304
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 306
      exit(1);
    }
#line 308
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 309
      tmp___31 = getuid();
#line 309
      *charptr = tilde_expand_filename((char const   *)cp, tmp___31);
    }
#line 310
    break;
    case 20: 
#line 313
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 315
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 316
    break;
    case 6: 
#line 319
    intptr = & options___0->permit_root_login;
#line 320
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 321
    if (! cp) {
#line 322
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 324
      exit(1);
    }
#line 326
    if (0) {
#line 326
      __s1_len___1 = strlen((char const   *)cp);
#line 326
      __s2_len___1 = strlen("without-password");
#line 326
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___4;
      } else {
#line 326
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 326
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 326
            tmp___61 = 1;
          } else {
#line 326
            if (__s2_len___1 >= 4U) {
#line 326
              tmp___61 = 1;
            } else {
#line 326
              tmp___61 = 0;
            }
          }
        } else {
#line 326
          tmp___61 = 0;
        }
      }
#line 326
      if (tmp___61) {
#line 326
        tmp___57 = __builtin_strcmp((char const   *)cp, "without-password");
      } else {
#line 326
        tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
#line 326
        tmp___57 = tmp___60;
      }
    } else {
#line 326
      tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
#line 326
      tmp___57 = tmp___60;
    }
#line 326
    if (tmp___57 == 0) {
#line 327
      value = 2;
    } else {
#line 328
      if (0) {
#line 328
        __s1_len___0 = strlen((char const   *)cp);
#line 328
        __s2_len___0 = strlen("yes");
#line 328
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 328
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 328
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 328
              tmp___51 = 1;
            } else {
#line 328
              if (__s2_len___0 >= 4U) {
#line 328
                tmp___51 = 1;
              } else {
#line 328
                tmp___51 = 0;
              }
            }
          } else {
#line 328
            tmp___51 = 0;
          }
        }
#line 328
        if (tmp___51) {
#line 328
          tmp___47 = __builtin_strcmp((char const   *)cp, "yes");
        } else {
#line 328
          tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
#line 328
          tmp___47 = tmp___50;
        }
      } else {
#line 328
        tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
#line 328
        tmp___47 = tmp___50;
      }
#line 328
      if (tmp___47 == 0) {
#line 329
        value = 1;
      } else {
#line 330
        if (0) {
#line 330
          __s1_len = strlen((char const   *)cp);
#line 330
          __s2_len = strlen("no");
#line 330
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___0;
          } else {
#line 330
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 330
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 330
                tmp___41 = 1;
              } else {
#line 330
                if (__s2_len >= 4U) {
#line 330
                  tmp___41 = 1;
                } else {
#line 330
                  tmp___41 = 0;
                }
              }
            } else {
#line 330
              tmp___41 = 0;
            }
          }
#line 330
          if (tmp___41) {
#line 330
            tmp___37 = __builtin_strcmp((char const   *)cp, "no");
          } else {
#line 330
            tmp___40 = __builtin_strcmp((char const   *)cp, "no");
#line 330
            tmp___37 = tmp___40;
          }
        } else {
#line 330
          tmp___40 = __builtin_strcmp((char const   *)cp, "no");
#line 330
          tmp___37 = tmp___40;
        }
#line 330
        if (tmp___37 == 0) {
#line 331
          value = 0;
        } else {
#line 333
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, cp);
#line 335
          exit(1);
        }
      }
    }
#line 337
    if (*intptr == -1) {
#line 338
      *intptr = value;
    }
#line 339
    break;
    case 15: 
#line 342
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 344
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 345
    if (! cp) {
#line 346
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 348
      exit(1);
    }
#line 350
    if (0) {
#line 350
      __s1_len___3 = strlen((char const   *)cp);
#line 350
      __s2_len___3 = strlen("yes");
#line 350
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___8;
      } else {
#line 350
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 350
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 350
            tmp___81 = 1;
          } else {
#line 350
            if (__s2_len___3 >= 4U) {
#line 350
              tmp___81 = 1;
            } else {
#line 350
              tmp___81 = 0;
            }
          }
        } else {
#line 350
          tmp___81 = 0;
        }
      }
#line 350
      if (tmp___81) {
#line 350
        tmp___77 = __builtin_strcmp((char const   *)cp, "yes");
      } else {
#line 350
        tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
#line 350
        tmp___77 = tmp___80;
      }
    } else {
#line 350
      tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
#line 350
      tmp___77 = tmp___80;
    }
#line 350
    if (tmp___77 == 0) {
#line 351
      value = 1;
    } else {
#line 352
      if (0) {
#line 352
        __s1_len___2 = strlen((char const   *)cp);
#line 352
        __s2_len___2 = strlen("no");
#line 352
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___6;
        } else {
#line 352
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 352
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 352
              tmp___71 = 1;
            } else {
#line 352
              if (__s2_len___2 >= 4U) {
#line 352
                tmp___71 = 1;
              } else {
#line 352
                tmp___71 = 0;
              }
            }
          } else {
#line 352
            tmp___71 = 0;
          }
        }
#line 352
        if (tmp___71) {
#line 352
          tmp___67 = __builtin_strcmp((char const   *)cp, "no");
        } else {
#line 352
          tmp___70 = __builtin_strcmp((char const   *)cp, "no");
#line 352
          tmp___67 = tmp___70;
        }
      } else {
#line 352
        tmp___70 = __builtin_strcmp((char const   *)cp, "no");
#line 352
        tmp___67 = tmp___70;
      }
#line 352
      if (tmp___67 == 0) {
#line 353
        value = 0;
      } else {
#line 355
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, cp);
#line 357
        exit(1);
      }
    }
#line 359
    if (*intptr == -1) {
#line 360
      *intptr = value;
    }
#line 361
    break;
    case 28: 
#line 364
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_int;
    case 9: 
#line 368
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 372
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 376
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 12: 
#line 404
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 408
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 418
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 422
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 426
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 18: 
#line 430
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 434
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 438
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 442
    intptr = & options___0->use_login;
    goto parse_flag;
    case 7: 
#line 446
    intptr = (int *)(& options___0->log_facility);
#line 447
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 448
    tmp___82 = log_facility_number(cp);
#line 448
    value = (int )tmp___82;
#line 449
    if (value == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 450
      if (cp) {
#line 450
        tmp___83 = (char const   *)cp;
      } else {
#line 450
        tmp___83 = "<NONE>";
      }
#line 450
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___83);
    }
#line 452
    if (*intptr == -1) {
#line 453
      *intptr = (int )((enum __anonenum_SyslogFacility_72 )value);
    }
#line 454
    break;
    case 8: 
#line 457
    intptr = (int *)(& options___0->log_level);
#line 458
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 459
    tmp___84 = log_level_number(cp);
#line 459
    value = (int )tmp___84;
#line 460
    if (value == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 461
      if (cp) {
#line 461
        tmp___85 = (char const   *)cp;
      } else {
#line 461
        tmp___85 = "<NONE>";
      }
#line 461
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___85);
    }
#line 463
    if (*intptr == -1) {
#line 464
      *intptr = (int )((enum __anonenum_LogLevel_73 )value);
    }
#line 465
    break;
    case 24: 
#line 468
    while (1) {
#line 468
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 468
      if (! cp) {
#line 468
        break;
      }
#line 469
      if (options___0->num_allow_users >= 256U) {
#line 470
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow users.\n",
                filename, linenum);
#line 472
        exit(1);
      }
#line 474
      tmp___86 = options___0->num_allow_users;
#line 474
      (options___0->num_allow_users) ++;
#line 474
      options___0->allow_users[tmp___86] = xstrdup((char const   *)cp);
    }
#line 476
    break;
    case 25: 
#line 479
    while (1) {
#line 479
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 479
      if (! cp) {
#line 479
        break;
      }
#line 480
      if (options___0->num_deny_users >= 256U) {
#line 481
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny users.\n",
                filename, linenum);
#line 483
        exit(1);
      }
#line 485
      tmp___87 = options___0->num_deny_users;
#line 485
      (options___0->num_deny_users) ++;
#line 485
      options___0->deny_users[tmp___87] = xstrdup((char const   *)cp);
    }
#line 487
    break;
    case 26: 
#line 490
    while (1) {
#line 490
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 490
      if (! cp) {
#line 490
        break;
      }
#line 491
      if (options___0->num_allow_groups >= 256U) {
#line 492
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow groups.\n",
                filename, linenum);
#line 494
        exit(1);
      }
#line 496
      tmp___88 = options___0->num_allow_groups;
#line 496
      (options___0->num_allow_groups) ++;
#line 496
      options___0->allow_groups[tmp___88] = xstrdup((char const   *)cp);
    }
#line 498
    break;
    case 27: 
#line 501
    while (1) {
#line 501
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 501
      if (! cp) {
#line 501
        break;
      }
#line 502
      if (options___0->num_deny_groups >= 256U) {
#line 503
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny groups.\n",
                filename, linenum);
#line 505
        exit(1);
      }
#line 507
      tmp___89 = options___0->num_deny_groups;
#line 507
      (options___0->num_deny_groups) ++;
#line 507
      options___0->deny_groups[tmp___89] = xstrdup((char const   *)cp);
    }
#line 509
    break;
    default: 
#line 512
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, cp, opcode);
#line 514
    exit(1);
    }
#line 516
    tmp___90 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 516
    if ((unsigned int )tmp___90 != (unsigned int )((void *)0)) {
#line 517
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line.\n",
              filename, linenum);
#line 519
      exit(1);
    }
  }
#line 522
  fclose(f);
#line 523
  if (bad_options > 0) {
#line 524
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 526
    exit(1);
  }
#line 528
  return;
}
}
#line 1 "serverloop.o"
#pragma merger(0,"./serverloop.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 17 "serverloop.c"
static Buffer stdin_buffer  ;
#line 18 "serverloop.c"
static Buffer stdout_buffer  ;
#line 19 "serverloop.c"
static Buffer stderr_buffer  ;
#line 20 "serverloop.c"
static int fdin  ;
#line 21 "serverloop.c"
static int fdout  ;
#line 23 "serverloop.c"
static int fderr  ;
#line 24 "serverloop.c"
static long stdin_bytes  =    0L;
#line 25 "serverloop.c"
static long stdout_bytes  =    0L;
#line 26 "serverloop.c"
static long stderr_bytes  =    0L;
#line 27 "serverloop.c"
static long fdout_bytes  =    0L;
#line 28 "serverloop.c"
static int stdin_eof  =    0;
#line 29 "serverloop.c"
static int fdout_eof  =    0;
#line 30 "serverloop.c"
static int fderr_eof  =    0;
#line 31 "serverloop.c"
static int connection_in___0  ;
#line 32 "serverloop.c"
static int connection_out___0  ;
#line 33 "serverloop.c"
static unsigned int buffer_high  ;
#line 34 "serverloop.c"
static int max_fd  ;
#line 41 "serverloop.c"
static int child_pid  ;
#line 42 "serverloop.c"
static int volatile   child_terminated  ;
#line 43 "serverloop.c"
static int volatile   child_wait_status  ;
#line 45 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int wait_pid ;
  union __anonunion_76 __constr_expr_0 ;
  union __anonunion_77 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 48
  tmp = __errno_location();
#line 48
  save_errno = *tmp;
#line 50
  debug("Received SIGCHLD.");
#line 51
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 52
  if (wait_pid != -1) {
#line 53
    if (wait_pid != child_pid) {
#line 54
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 56
    __constr_expr_0.__in = child_wait_status;
#line 56
    if ((__constr_expr_0.__i & 127) == 0) {
#line 58
      child_terminated = (int volatile   )1;
    } else {
#line 56
      __constr_expr_1.__in = child_wait_status;
#line 56
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 58
        child_terminated = (int volatile   )1;
      }
    }
  }
#line 60
  signal(17, & sigchld_handler);
#line 61
  tmp___0 = __errno_location();
#line 61
  *tmp___0 = save_errno;
#line 62
  return;
}
}
#line 67 "serverloop.c"
void process_buffered_input_packets(void) 
{ int type ;
  char *data ;
  unsigned int data_len ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int payload_len ;
  int _p ;
  int _e ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _p___2 ;
  int _e___2 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int _p___5 ;
  int _e___5 ;

  {
#line 77
  while (1) {
#line 77
    type = packet_read_poll(& payload_len);
#line 77
    if (! (type != 0)) {
#line 77
      break;
    }
#line 78
    switch (type) {
    case 16: 
#line 82
    if (fdin == -1) {
#line 83
      break;
    }
#line 84
    data = packet_get_string(& data_len);
#line 85
    while (1) {
#line 85
      _p = payload_len;
#line 85
      _e = (int )(4U + data_len);
#line 85
      if (_p != _e) {
#line 85
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c",
            85);
#line 85
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 85
      break;
    }
#line 86
    buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 87
    memset((void *)data, 0, data_len);
#line 88
    xfree((void *)data);
#line 89
    break;
    case 19: 
#line 97
    debug("EOF received for stdin.");
#line 98
    while (1) {
#line 98
      _p___0 = payload_len;
#line 98
      _e___0 = 0;
#line 98
      if (_p___0 != _e___0) {
#line 98
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "serverloop.c",
            98);
#line 98
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 98
      break;
    }
#line 99
    stdin_eof = 1;
#line 100
    break;
    case 11: 
#line 103
    debug("Window change received.");
#line 104
    while (1) {
#line 104
      _p___1 = payload_len;
#line 104
      _e___1 = 16;
#line 104
      if (_p___1 != _e___1) {
#line 104
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "serverloop.c",
            104);
#line 104
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 104
      break;
    }
#line 105
    tmp = packet_get_int();
#line 105
    row = (int )tmp;
#line 106
    tmp___0 = packet_get_int();
#line 106
    col = (int )tmp___0;
#line 107
    tmp___1 = packet_get_int();
#line 107
    xpixel = (int )tmp___1;
#line 108
    tmp___2 = packet_get_int();
#line 108
    ypixel = (int )tmp___2;
#line 109
    if (fdin != -1) {
#line 110
      pty_change_window_size(fdin, row, col, xpixel, ypixel);
    }
#line 111
    break;
    case 29: 
#line 114
    debug("Received port open request.");
#line 115
    channel_input_port_open(payload_len);
#line 116
    break;
    case 21: 
#line 119
    debug("Received channel open confirmation.");
#line 120
    while (1) {
#line 120
      _p___2 = payload_len;
#line 120
      _e___2 = 8;
#line 120
      if (_p___2 != _e___2) {
#line 120
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "serverloop.c",
            120);
#line 120
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 120
      break;
    }
#line 121
    channel_input_open_confirmation();
#line 122
    break;
    case 22: 
#line 125
    debug("Received channel open failure.");
#line 126
    while (1) {
#line 126
      _p___3 = payload_len;
#line 126
      _e___3 = 4;
#line 126
      if (_p___3 != _e___3) {
#line 126
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "serverloop.c",
            126);
#line 126
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 126
      break;
    }
#line 127
    channel_input_open_failure();
#line 128
    break;
    case 23: 
#line 131
    channel_input_data(payload_len);
#line 132
    break;
    case 24: 
#line 135
    debug("Received channel close.");
#line 136
    while (1) {
#line 136
      _p___4 = payload_len;
#line 136
      _e___4 = 4;
#line 136
      if (_p___4 != _e___4) {
#line 136
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "serverloop.c",
            136);
#line 136
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 136
      break;
    }
#line 137
    channel_input_close();
#line 138
    break;
    case 25: 
#line 141
    debug("Received channel close confirmation.");
#line 142
    while (1) {
#line 142
      _p___5 = payload_len;
#line 142
      _e___5 = 4;
#line 142
      if (_p___5 != _e___5) {
#line 142
        log("Packet integrity error (%d != %d) at %s:%d", _p___5, _e___5, "serverloop.c",
            142);
#line 142
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 142
      break;
    }
#line 143
    channel_input_close_confirmation();
#line 144
    break;
    default: 
#line 156
    packet_disconnect("Protocol error during session: type %d", type);
    }
  }
#line 160
  return;
}
}
#line 166 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 172
  while (1) {
#line 172
    tmp___2 = buffer_len(& stderr_buffer);
#line 172
    if (tmp___2 > 0U) {
#line 172
      tmp___3 = packet_not_very_much_data_to_write();
#line 172
      if (! tmp___3) {
#line 172
        break;
      }
    } else {
#line 172
      break;
    }
#line 174
    tmp = buffer_len(& stderr_buffer);
#line 174
    len = (int )tmp;
#line 175
    tmp___0 = packet_is_interactive();
#line 175
    if (tmp___0) {
#line 176
      if (len > 512) {
#line 177
        len = 512;
      }
    } else {
#line 180
      if (len > max_packet_size) {
#line 181
        len = max_packet_size;
      }
    }
#line 183
    packet_start(18);
#line 184
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 184
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 185
    packet_send();
#line 186
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 187
    stderr_bytes += (long )len;
  }
#line 189
  return;
}
}
#line 195 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 201
  while (1) {
#line 201
    tmp___2 = buffer_len(& stdout_buffer);
#line 201
    if (tmp___2 > 0U) {
#line 201
      tmp___3 = packet_not_very_much_data_to_write();
#line 201
      if (! tmp___3) {
#line 201
        break;
      }
    } else {
#line 201
      break;
    }
#line 203
    tmp = buffer_len(& stdout_buffer);
#line 203
    len = (int )tmp;
#line 204
    tmp___0 = packet_is_interactive();
#line 204
    if (tmp___0) {
#line 205
      if (len > 512) {
#line 206
        len = 512;
      }
    } else {
#line 209
      if (len > max_packet_size) {
#line 210
        len = max_packet_size;
      }
    }
#line 212
    packet_start(17);
#line 213
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 213
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 214
    packet_send();
#line 215
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 216
    stdout_bytes += (long )len;
  }
#line 218
  return;
}
}
#line 226 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  retry_select: 
#line 237
  while (1) {
#line 237
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 237
    break;
  }
#line 243
  tmp = buffer_len(& stdin_buffer);
#line 243
  if (tmp < 4096U) {
#line 243
    tmp___0 = channel_not_very_much_buffered_data();
#line 243
    if (tmp___0) {
#line 245
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 251
  tmp___1 = packet_not_very_much_data_to_write();
#line 251
  if (tmp___1) {
#line 252
    if (! fdout_eof) {
#line 253
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 254
    if (! fderr_eof) {
#line 255
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 257
  while (1) {
#line 257
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 257
    break;
  }
#line 260
  channel_prepare_select(readset, writeset);
#line 266
  tmp___2 = packet_have_data_to_write();
#line 266
  if (tmp___2) {
#line 267
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 271
  if (fdin != -1) {
#line 271
    tmp___3 = buffer_len(& stdin_buffer);
#line 271
    if (tmp___3 > 0U) {
#line 272
      __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 275
  tmp___4 = channel_max_fd();
#line 275
  if (tmp___4 > max_fd) {
#line 276
    max_fd = channel_max_fd();
  }
#line 282
  if (child_terminated) {
#line 282
    tmp___5 = packet_not_very_much_data_to_write();
#line 282
    if (tmp___5) {
#line 283
      if (max_time_milliseconds == 0U) {
#line 284
        max_time_milliseconds = 100U;
      }
    }
  }
#line 286
  if (max_time_milliseconds == 0U) {
#line 287
    tvp = (struct timeval *)((void *)0);
  } else {
#line 289
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 290
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 291
    tvp = & tv;
  }
#line 295
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 297
  if (ret < 0) {
#line 298
    tmp___8 = __errno_location();
#line 298
    if (*tmp___8 != 4) {
#line 299
      tmp___6 = __errno_location();
#line 299
      tmp___7 = strerror(*tmp___6);
#line 299
      error("select: %.100s", tmp___7);
    } else {
      goto retry_select;
    }
  }
#line 303
  return;
}
}
#line 309 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf[16384] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register char __result ;
  register char __result___0 ;
  register char __result___1 ;

  {
#line 316
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 316
  if (__result) {
#line 317
    len = read(connection_in___0, (void *)(buf), sizeof(buf));
#line 318
    if (len == 0) {
#line 319
      verbose("Connection closed by remote host.");
#line 320
      fatal_cleanup();
    }
#line 326
    if (len < 0) {
#line 326
      tmp = __errno_location();
#line 326
      if (*tmp == 11) {
#line 327
        len = 0;
      }
    }
#line 329
    if (len < 0) {
#line 330
      tmp___0 = __errno_location();
#line 330
      tmp___1 = strerror(*tmp___0);
#line 330
      verbose("Read error from remote host: %.100s", tmp___1);
#line 331
      fatal_cleanup();
    }
#line 334
    packet_process_incoming((char const   *)(buf), (unsigned int )len);
  }
#line 337
  if (! fdout_eof) {
#line 337
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 337
    if (__result___0) {
#line 338
      len = read(fdout, (void *)(buf), sizeof(buf));
#line 339
      if (len <= 0) {
#line 340
        fdout_eof = 1;
      } else {
#line 342
        buffer_append(& stdout_buffer, (char const   *)(buf), (unsigned int )len);
#line 343
        fdout_bytes += (long )len;
      }
    }
  }
#line 347
  if (! fderr_eof) {
#line 347
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 347
    if (__result___1) {
#line 348
      len = read(fderr, (void *)(buf), sizeof(buf));
#line 349
      if (len <= 0) {
#line 350
        fderr_eof = 1;
      } else {
#line 352
        buffer_append(& stderr_buffer, (char const   *)(buf), (unsigned int )len);
      }
    }
  }
#line 354
  return;
}
}
#line 359 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;

  {
#line 365
  if (fdin != -1) {
#line 365
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 365
    if (__result) {
#line 366
      tmp = buffer_len(& stdin_buffer);
#line 366
      tmp___0 = buffer_ptr(& stdin_buffer);
#line 366
      len = write(fdin, (void const   *)tmp___0, tmp);
#line 368
      if (len <= 0) {
#line 370
        close(fdin);
#line 377
        fdin = -1;
      } else {
#line 380
        buffer_consume(& stdin_buffer, (unsigned int )len);
#line 382
        stdin_bytes += (long )len;
      }
    }
  }
#line 386
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 386
  if (__result___0) {
#line 387
    packet_write_poll();
  }
#line 388
  return;
}
}
#line 394 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 398
  tmp___2 = buffer_len(& stdout_buffer);
#line 398
  if (tmp___2 > 0U) {
#line 399
    packet_start(17);
#line 400
    tmp = buffer_len(& stdout_buffer);
#line 400
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 400
    packet_put_string((char const   *)tmp___0, tmp);
#line 402
    packet_send();
#line 404
    tmp___1 = buffer_len(& stdout_buffer);
#line 404
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 407
  tmp___6 = buffer_len(& stderr_buffer);
#line 407
  if (tmp___6 > 0U) {
#line 408
    packet_start(18);
#line 409
    tmp___3 = buffer_len(& stderr_buffer);
#line 409
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 409
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 411
    packet_send();
#line 413
    tmp___5 = buffer_len(& stderr_buffer);
#line 413
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 416
  packet_write_wait();
#line 417
  return;
}
}
#line 426 "serverloop.c"
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ int wait_status ;
  int wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  fd_set readset ;
  fd_set writeset ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_78 __constr_expr_0 ;
  union __anonunion_79 __constr_expr_1 ;
  int plen ;
  union __anonunion_80 __constr_expr_2 ;
  union __anonunion_81 __constr_expr_3 ;
  union __anonunion_82 __constr_expr_4 ;

  {
#line 430
  waiting_termination = 0;
#line 436
  debug("Entering interactive session.");
#line 439
  child_pid = pid;
#line 440
  child_terminated = (int volatile   )0;
#line 441
  signal(17, & sigchld_handler);
#line 444
  fdin = fdin_arg;
#line 445
  fdout = fdout_arg;
#line 446
  fderr = fderr_arg;
#line 447
  connection_in___0 = packet_get_connection_in();
#line 448
  connection_out___0 = packet_get_connection_out();
#line 450
  previous_stdout_buffer_bytes = 0U;
#line 453
  tmp = packet_is_interactive();
#line 453
  if (tmp) {
#line 454
    buffer_high = 4096U;
  } else {
#line 456
    buffer_high = 65536U;
  }
#line 459
  max_fd = fdin;
#line 460
  if (fdout > max_fd) {
#line 461
    max_fd = fdout;
  }
#line 462
  if (fderr != -1) {
#line 462
    if (fderr > max_fd) {
#line 463
      max_fd = fderr;
    }
  }
#line 464
  if (connection_in___0 > max_fd) {
#line 465
    max_fd = connection_in___0;
  }
#line 466
  if (connection_out___0 > max_fd) {
#line 467
    max_fd = connection_out___0;
  }
#line 470
  buffer_init(& stdin_buffer);
#line 471
  buffer_init(& stdout_buffer);
#line 472
  buffer_init(& stderr_buffer);
#line 480
  if (fderr == -1) {
#line 481
    fderr_eof = 1;
  }
#line 484
  while (1) {
#line 488
    process_buffered_input_packets();
#line 494
    if (stdin_eof) {
#line 494
      if (fdin != -1) {
#line 494
        tmp___0 = buffer_len(& stdin_buffer);
#line 494
        if (tmp___0 == 0U) {
#line 496
          close(fdin);
#line 503
          fdin = -1;
        }
      }
    }
#line 506
    make_packets_from_stderr_data();
#line 515
    max_time_milliseconds = 0U;
#line 516
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 517
    if (stdout_buffer_bytes != 0U) {
#line 517
      if (stdout_buffer_bytes < 256U) {
#line 517
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 520
          max_time_milliseconds = 10U;
        } else {
#line 523
          make_packets_from_stdout_data();
        }
      } else {
#line 523
        make_packets_from_stdout_data();
      }
    } else {
#line 523
      make_packets_from_stdout_data();
    }
#line 525
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 528
    tmp___1 = packet_not_very_much_data_to_write();
#line 528
    if (tmp___1) {
#line 529
      channel_output_poll();
    }
#line 536
    if (fdout_eof) {
#line 536
      if (fderr_eof) {
#line 536
        tmp___5 = packet_have_data_to_write();
#line 536
        if (! tmp___5) {
#line 536
          tmp___6 = buffer_len(& stdout_buffer);
#line 536
          if (tmp___6 == 0U) {
#line 536
            tmp___7 = buffer_len(& stderr_buffer);
#line 536
            if (tmp___7 == 0U) {
#line 538
              tmp___2 = channel_still_open();
#line 538
              if (! tmp___2) {
                goto quit;
              }
#line 540
              if (! waiting_termination) {
#line 541
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 543
                waiting_termination = 1;
#line 544
                tmp___3 = strlen(s);
#line 544
                buffer_append(& stderr_buffer, s, tmp___3);
#line 547
                cp = channel_open_message();
#line 548
                tmp___4 = strlen((char const   *)cp);
#line 548
                buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 549
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 553
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 557
    channel_after_select(& readset, & writeset);
#line 560
    process_input(& readset);
#line 563
    process_output(& writeset);
  }
  quit: 
#line 570
  drain_output();
#line 572
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 576
  buffer_free(& stdin_buffer);
#line 577
  buffer_free(& stdout_buffer);
#line 578
  buffer_free(& stderr_buffer);
#line 581
  if (fdout != -1) {
#line 582
    close(fdout);
  }
#line 583
  fdout = -1;
#line 584
  fdout_eof = 1;
#line 585
  if (fderr != -1) {
#line 586
    close(fderr);
  }
#line 587
  fderr = -1;
#line 588
  fderr_eof = 1;
#line 589
  if (fdin != -1) {
#line 590
    close(fdin);
  }
#line 591
  fdin = -1;
#line 594
  channel_stop_listening();
#line 597
  wait_pid = wait((union wait *)(& wait_status));
#line 598
  if (wait_pid < 0) {
#line 604
    if (child_terminated) {
#line 605
      wait_status = (int )child_wait_status;
    } else {
#line 607
      tmp___8 = __errno_location();
#line 607
      tmp___9 = strerror(*tmp___8);
#line 607
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 610
    if (wait_pid != pid) {
#line 611
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 616
  signal(17, (void (*)(int  ))0);
#line 619
  __constr_expr_2.__in = wait_status;
#line 619
  if ((__constr_expr_2.__i & 127) == 0) {
#line 621
    __constr_expr_0.__in = wait_status;
#line 621
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 622
    packet_start(20);
#line 623
    __constr_expr_1.__in = wait_status;
#line 623
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 624
    packet_send();
#line 625
    packet_write_wait();
#line 634
    while (1) {
#line 636
      type = packet_read(& plen);
#line 634
      if (! (type != 33)) {
#line 634
        break;
      }
    }
#line 640
    debug("Received exit confirmation.");
#line 641
    return;
  }
#line 644
  __constr_expr_4.__in = wait_status;
#line 644
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 645
    __constr_expr_3.__in = wait_status;
#line 645
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 649
  packet_disconnect("wait returned status %04x.", wait_status);
#line 651
  return;
}
}
#line 1 "bsd-login.o"
#pragma merger(0,"./bsd-login.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "bsd-daemon.o"
#pragma merger(0,"./bsd-daemon.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
#line 1 "md5crypt.o"
#pragma merger(0,"./md5crypt.i","-g,-O2,-Wall,-Wpointer-arith,-Wno-uninitialized")
