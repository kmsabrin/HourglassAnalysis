/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_74 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 34 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer packet ;
   Buffer identities ;
   int howmany ;
};
#line 34 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_64 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_64 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 41 "cipher.h"
struct __anonstruct_des3_69 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 41 "cipher.h"
struct __anonstruct_bf_70 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 41 "cipher.h"
union __anonunion_u_68 {
   struct __anonstruct_des3_69 des3 ;
   struct __anonstruct_bf_70 bf ;
};
#line 41 "cipher.h"
struct __anonstruct_CipherContext_67 {
   unsigned int type ;
   union __anonunion_u_68 u ;
};
#line 41 "cipher.h"
typedef struct __anonstruct_CipherContext_67 CipherContext;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 59 "bsd-misc.c"
struct __anonstruct_rc4_t_74 {
   unsigned int s[256] ;
   int i ;
   int j ;
};
#line 59 "bsd-misc.c"
typedef struct __anonstruct_rc4_t_74 rc4_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 25 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int sock ;
   Buffer input ;
   Buffer output ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
};
#line 25 "channels.h"
typedef struct Channel Channel;
#line 83 "channels.c"
struct __anonstruct_ForwardPermission_79 {
   char *host ;
   u_short port ;
};
#line 83 "channels.c"
typedef struct __anonstruct_ForwardPermission_79 ForwardPermission;
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 92 "cipher.c"
union __anonunion_t_74 {
   u_int32_t i ;
   char c[4] ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 404 "ssh.h"
enum __anonenum_HostStatus_71 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 404 "ssh.h"
typedef enum __anonenum_HostStatus_71 HostStatus;
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 467 "ssh.h"
enum __anonenum_SyslogFacility_72 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 467 "ssh.h"
typedef enum __anonenum_SyslogFacility_72 SyslogFacility;
#line 481
enum __anonenum_LogLevel_73 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG = 5
} ;
#line 481 "ssh.h"
typedef enum __anonenum_LogLevel_73 LogLevel;
#line 69 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 132 "log.c"
struct __anonstruct_log_facilities_74 {
   char const   *name ;
   SyslogFacility val ;
};
#line 150 "log.c"
struct __anonstruct_log_levels_75 {
   char const   *name ;
   LogLevel val ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_24 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_27 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_28 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_22 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_23 _kill ;
   struct __anonstruct__timer_24 _timer ;
   struct __anonstruct__rt_25 _rt ;
   struct __anonstruct__sigchld_26 _sigchld ;
   struct __anonstruct__sigfault_27 _sigfault ;
   struct __anonstruct__sigpoll_28 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_22 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_40 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_40 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 707 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 28 "servconf.h"
struct __anonstruct_ServerOptions_75 {
   unsigned int num_ports ;
   unsigned int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   int strict_modes ;
   int keepalives ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
};
#line 28 "servconf.h"
typedef struct __anonstruct_ServerOptions_75 ServerOptions;
#line 115 "sshd.c"
struct __anonstruct_sensitive_data_76 {
   RSA *private_key ;
   RSA *host_key ;
};
#line 1657 "sshd.c"
struct pty_cleanup_context {
   char const   *ttyname ;
   int pid ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 28 "auth-pam.c"
struct pam_handle_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 144 "servconf.c"
enum __anonenum_ServerOpCodes_75 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27,
    sIgnoreUserKnownHosts = 28
} ;
#line 144 "servconf.c"
typedef enum __anonenum_ServerOpCodes_75 ServerOpCodes;
#line 166 "servconf.c"
struct __anonstruct_keywords_76 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_43 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_44 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_43 __wait_terminated ;
   struct __anonstruct___wait_stopped_44 __wait_stopped ;
};
#line 61 "serverloop.c"
union __anonunion_76 {
   int volatile   __in ;
   int __i ;
};
#line 61 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 634 "serverloop.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 636 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 632 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 658 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 657 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 1 "atomicio.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 715 "ssh.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 49
    tmp = __errno_location();
#line 49
    if (*tmp == 4) {
#line 50
      continue;
    } else {
#line 49
      tmp___0 = __errno_location();
#line 49
      if (*tmp___0 == 11) {
#line 50
        continue;
      }
    }
    case 0: 
#line 52
    return (res);
    default: 
#line 54
    pos += res;
    }
  }
#line 57
  return (pos);
}
}
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 7 "bsd-strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 500 "ssh.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 501
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 502
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 28 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 31
void buffer_free(Buffer *buffer ) ;
#line 35
void buffer_clear(Buffer *buffer ) ;
#line 38
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 51
void buffer_get(Buffer *buffer , char *buf___0 , unsigned int len ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 41 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 48
void ssh_close_authentication_socket(int sock ) ;
#line 56
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 62
void ssh_close_authentication_connection(AuthenticationConnection *ac ) ;
#line 70
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) ;
#line 80
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) ;
#line 86
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) ;
#line 98
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) ;
#line 107
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) ;
#line 114
int ssh_remove_all_identities(AuthenticationConnection *auth ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 28
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 31
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 34
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 37
int buffer_get_char(Buffer *buffer ) ;
#line 40
void buffer_put_char(Buffer *buffer , int value ) ;
#line 50
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 53
void buffer_put_string(Buffer *buffer , void const   *buf___0 , unsigned int len ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 36 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 43
  tmp = getenv("SSH_AUTH_SOCK");
#line 43
  authsocket = (char const   *)tmp;
#line 44
  if (! authsocket) {
#line 45
    return (-1);
  }
#line 47
  sunaddr.sun_family = (unsigned short)1;
#line 48
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 50
  sock = socket(1, 1, 0);
#line 51
  if (sock < 0) {
#line 52
    return (-1);
  }
#line 55
  tmp___0 = fcntl(sock, 2, 1);
#line 55
  if (tmp___0 == -1) {
#line 56
    close(sock);
#line 57
    return (-1);
  }
#line 59
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 59
  if (tmp___1 < 0) {
#line 60
    close(sock);
#line 61
    return (-1);
  }
#line 63
  return (sock);
}
}
#line 72 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 75
  tmp = getenv("SSH_AUTH_SOCK");
#line 75
  if (tmp) {
#line 76
    close(sock);
  }
#line 77
  return;
}
}
#line 87 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 93
  sock = ssh_get_authentication_socket();
#line 99
  if (sock < 0) {
#line 100
    return ((AuthenticationConnection *)((void *)0));
  }
#line 102
  tmp = xmalloc(sizeof(*auth));
#line 102
  auth = (AuthenticationConnection *)tmp;
#line 103
  auth->fd = sock;
#line 104
  buffer_init(& auth->packet);
#line 105
  buffer_init(& auth->identities);
#line 106
  auth->howmany = 0;
#line 108
  return (auth);
}
}
#line 116 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *ac ) 
{ 

  {
#line 119
  buffer_free(& ac->packet);
#line 120
  buffer_free(& ac->identities);
#line 121
  close(ac->fd);
#line 122
  xfree((void *)ac);
#line 123
  return;
}
}
#line 132 "authfd.c"
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) 
{ unsigned char msg[8192] ;
  int len ;
  int l ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 143
  msg[0] = (unsigned char)0;
#line 144
  msg[1] = (unsigned char)0;
#line 145
  msg[2] = (unsigned char)0;
#line 146
  msg[3] = (unsigned char)1;
#line 147
  msg[4] = (unsigned char)1;
#line 148
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(msg), 5U);
#line 148
  if (tmp___1 != 5) {
#line 149
    tmp = __errno_location();
#line 149
    tmp___0 = strerror(*tmp);
#line 149
    error("write auth->fd: %.100s", tmp___0);
#line 150
    return (0);
  }
#line 153
  len = 4;
#line 154
  while (len > 0) {
#line 155
    l = read(auth->fd, (void *)((msg + 4) - len), (unsigned int )len);
#line 156
    if (l <= 0) {
#line 157
      tmp___2 = __errno_location();
#line 157
      tmp___3 = strerror(*tmp___2);
#line 157
      error("read auth->fd: %.100s", tmp___3);
#line 158
      return (0);
    }
#line 160
    len -= l;
  }
#line 167
  len = (int )(((((unsigned long )msg[0] << 24) | ((unsigned long )msg[1] << 16)) | ((unsigned long )msg[2] << 8)) | (unsigned long )msg[3]);
#line 168
  if (len < 1) {
#line 169
    fatal("Authentication reply message too long: %d\n", len);
  } else {
#line 168
    if (len > 262144) {
#line 169
      fatal("Authentication reply message too long: %d\n", len);
    }
  }
#line 172
  buffer_clear(& auth->identities);
#line 173
  while (len > 0) {
#line 174
    l = len;
#line 175
    if ((unsigned int )l > sizeof(msg)) {
#line 176
      l = (int )sizeof(msg);
    }
#line 177
    l = read(auth->fd, (void *)(msg), (unsigned int )l);
#line 178
    if (l <= 0) {
#line 179
      fatal("Incomplete authentication reply.");
    }
#line 180
    buffer_append(& auth->identities, (char const   *)((char *)(msg)), (unsigned int )l);
#line 181
    len -= l;
  }
#line 185
  buffer_get(& auth->identities, (char *)(msg), 1U);
#line 186
  if ((int )msg[0] != 2) {
#line 187
    fatal("Bad authentication reply message type: %d", msg[0]);
  }
#line 190
  tmp___4 = buffer_get_int(& auth->identities);
#line 190
  auth->howmany = (int )tmp___4;
#line 191
  if (auth->howmany > 1024) {
#line 192
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 195
  tmp___5 = ssh_get_next_identity(auth, e, n___0, comment);
#line 195
  return (tmp___5);
}
}
#line 205 "authfd.c"
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) 
{ unsigned int bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 212
  if (auth->howmany <= 0) {
#line 213
    return (0);
  }
#line 219
  bits = buffer_get_int(& auth->identities);
#line 220
  buffer_get_bignum(& auth->identities, e);
#line 221
  buffer_get_bignum(& auth->identities, n___0);
#line 222
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 224
  tmp___0 = BN_num_bits((BIGNUM const   *)n___0);
#line 224
  if (bits != (unsigned int )tmp___0) {
#line 225
    tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 225
    error("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 229
  (auth->howmany) --;
#line 231
  return (1);
}
}
#line 242 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) 
{ Buffer buffer ;
  unsigned char buf___0[8192] ;
  int len ;
  int l ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 254
  if (response_type == 0U) {
#line 255
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
  }
#line 258
  buf___0[0] = (unsigned char)3;
#line 259
  buffer_init(& buffer);
#line 260
  buffer_append(& buffer, (char const   *)((char *)(buf___0)), 1U);
#line 261
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 261
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 262
  buffer_put_bignum(& buffer, e);
#line 263
  buffer_put_bignum(& buffer, n___0);
#line 264
  buffer_put_bignum(& buffer, challenge);
#line 265
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 266
  buffer_put_int(& buffer, response_type);
#line 269
  tmp___0 = buffer_len(& buffer);
#line 269
  len = (int )tmp___0;
#line 270
  while (1) {
#line 270
    buf___0[0] = (unsigned char )(len >> 24);
#line 270
    buf___0[1] = (unsigned char )(len >> 16);
#line 270
    buf___0[2] = (unsigned char )(len >> 8);
#line 270
    buf___0[3] = (unsigned char )len;
#line 270
    break;
  }
#line 273
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___0), 4U);
#line 273
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 273
    tmp___2 = buffer_len(& buffer);
#line 273
    tmp___3 = buffer_ptr(& buffer);
#line 273
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 273
    tmp___5 = buffer_len(& buffer);
#line 273
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 276
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 278
      buffer_free(& buffer);
#line 279
      return (0);
    }
  }
#line 285
  len = 4;
#line 286
  while (len > 0) {
#line 287
    l = read(auth->fd, (void *)((buf___0 + 4) - len), (unsigned int )len);
#line 288
    if (l <= 0) {
#line 289
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 292
    len -= l;
  }
#line 296
  len = (int )(((((unsigned long )buf___0[0] << 24) | ((unsigned long )buf___0[1] << 16)) | ((unsigned long )buf___0[2] << 8)) | (unsigned long )buf___0[3]);
#line 297
  if (len > 262144) {
#line 298
    fatal("Authentication response too long: %d", len);
  }
#line 301
  buffer_clear(& buffer);
#line 302
  while (len > 0) {
#line 303
    l = len;
#line 304
    if ((unsigned int )l > sizeof(buf___0)) {
#line 305
      l = (int )sizeof(buf___0);
    }
#line 306
    l = read(auth->fd, (void *)(buf___0), (unsigned int )l);
#line 307
    if (l <= 0) {
#line 308
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 311
    buffer_append(& buffer, (char const   *)((char *)(buf___0)), (unsigned int )l);
#line 312
    len -= l;
  }
#line 316
  buffer_get(& buffer, (char *)(buf___0), 1U);
#line 319
  if ((int )buf___0[0] == 5) {
#line 320
    log("Agent admitted failure to authenticate using the key.");
    goto error_cleanup;
  }
#line 324
  if ((int )buf___0[0] != 4) {
#line 325
    fatal("Bad authentication response: %d", buf___0[0]);
  }
#line 331
  i = 0;
#line 331
  while (i < 16) {
#line 332
    tmp___6 = buffer_get_char(& buffer);
#line 332
    *(response + i) = (unsigned char )tmp___6;
#line 331
    i ++;
  }
#line 335
  buffer_free(& buffer);
#line 338
  return (1);
}
}
#line 346 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) 
{ Buffer buffer ;
  unsigned char buf___0[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 355
  buffer_init(& buffer);
#line 356
  buffer_put_char(& buffer, 7);
#line 357
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 357
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 358
  buffer_put_bignum(& buffer, key->n);
#line 359
  buffer_put_bignum(& buffer, key->e);
#line 360
  buffer_put_bignum(& buffer, key->d);
#line 362
  buffer_put_bignum(& buffer, key->iqmp);
#line 363
  buffer_put_bignum(& buffer, key->q);
#line 364
  buffer_put_bignum(& buffer, key->p);
#line 365
  tmp___0 = strlen(comment);
#line 365
  buffer_put_string(& buffer, (void const   *)comment, tmp___0);
#line 368
  tmp___1 = buffer_len(& buffer);
#line 368
  len = (int )tmp___1;
#line 369
  while (1) {
#line 369
    buf___0[0] = (unsigned char )(len >> 24);
#line 369
    buf___0[1] = (unsigned char )(len >> 16);
#line 369
    buf___0[2] = (unsigned char )(len >> 8);
#line 369
    buf___0[3] = (unsigned char )len;
#line 369
    break;
  }
#line 372
  tmp___2 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___0), 4U);
#line 372
  if (tmp___2 != 4) {
    goto _L;
  } else {
#line 372
    tmp___3 = buffer_len(& buffer);
#line 372
    tmp___4 = buffer_ptr(& buffer);
#line 372
    tmp___5 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___4, tmp___3);
#line 372
    tmp___6 = buffer_len(& buffer);
#line 372
    if ((unsigned int )tmp___5 != tmp___6) {
      _L: /* CIL Label */ 
#line 375
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 377
      buffer_free(& buffer);
#line 378
      return (0);
    }
  }
#line 382
  len = 4;
#line 383
  while (len > 0) {
#line 384
    l = read(auth->fd, (void *)((buf___0 + 4) - len), (unsigned int )len);
#line 385
    if (l <= 0) {
#line 386
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 389
    len -= l;
  }
#line 393
  len = (int )(((((unsigned long )buf___0[0] << 24) | ((unsigned long )buf___0[1] << 16)) | ((unsigned long )buf___0[2] << 8)) | (unsigned long )buf___0[3]);
#line 394
  if (len > 262144) {
#line 395
    fatal("Add identity response too long: %d", len);
  }
#line 398
  buffer_clear(& buffer);
#line 399
  while (len > 0) {
#line 400
    l = len;
#line 401
    if ((unsigned int )l > sizeof(buf___0)) {
#line 402
      l = (int )sizeof(buf___0);
    }
#line 403
    l = read(auth->fd, (void *)(buf___0), (unsigned int )l);
#line 404
    if (l <= 0) {
#line 405
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 408
    buffer_append(& buffer, (char const   *)((char *)(buf___0)), (unsigned int )l);
#line 409
    len -= l;
  }
#line 413
  type = buffer_get_char(& buffer);
#line 414
  switch (type) {
  case 5: 
#line 416
  buffer_free(& buffer);
#line 417
  return (0);
  case 6: 
#line 419
  buffer_free(& buffer);
#line 420
  return (1);
  default: 
#line 422
  fatal("Bad response to add identity from authentication agent: %d", type);
  }
#line 426
  return (0);
}
}
#line 434 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) 
{ Buffer buffer ;
  unsigned char buf___0[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 442
  buffer_init(& buffer);
#line 443
  buffer_put_char(& buffer, 8);
#line 444
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 444
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 445
  buffer_put_bignum(& buffer, key->e);
#line 446
  buffer_put_bignum(& buffer, key->n);
#line 449
  tmp___0 = buffer_len(& buffer);
#line 449
  len = (int )tmp___0;
#line 450
  while (1) {
#line 450
    buf___0[0] = (unsigned char )(len >> 24);
#line 450
    buf___0[1] = (unsigned char )(len >> 16);
#line 450
    buf___0[2] = (unsigned char )(len >> 8);
#line 450
    buf___0[3] = (unsigned char )len;
#line 450
    break;
  }
#line 453
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___0), 4U);
#line 453
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 453
    tmp___2 = buffer_len(& buffer);
#line 453
    tmp___3 = buffer_ptr(& buffer);
#line 453
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 453
    tmp___5 = buffer_len(& buffer);
#line 453
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 456
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 458
      buffer_free(& buffer);
#line 459
      return (0);
    }
  }
#line 465
  len = 4;
#line 466
  while (len > 0) {
#line 467
    l = read(auth->fd, (void *)((buf___0 + 4) - len), (unsigned int )len);
#line 468
    if (l <= 0) {
#line 469
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 472
    len -= l;
  }
#line 476
  len = (int )(((((unsigned long )buf___0[0] << 24) | ((unsigned long )buf___0[1] << 16)) | ((unsigned long )buf___0[2] << 8)) | (unsigned long )buf___0[3]);
#line 477
  if (len > 262144) {
#line 478
    fatal("Remove identity response too long: %d", len);
  }
#line 481
  buffer_clear(& buffer);
#line 482
  while (len > 0) {
#line 483
    l = len;
#line 484
    if ((unsigned int )l > sizeof(buf___0)) {
#line 485
      l = (int )sizeof(buf___0);
    }
#line 486
    l = read(auth->fd, (void *)(buf___0), (unsigned int )l);
#line 487
    if (l <= 0) {
#line 488
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 491
    buffer_append(& buffer, (char const   *)((char *)(buf___0)), (unsigned int )l);
#line 492
    len -= l;
  }
#line 496
  type = buffer_get_char(& buffer);
#line 497
  switch (type) {
  case 5: 
#line 499
  buffer_free(& buffer);
#line 500
  return (0);
  case 6: 
#line 502
  buffer_free(& buffer);
#line 503
  return (1);
  default: 
#line 505
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 509
  return (0);
}
}
#line 517 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth ) 
{ Buffer buffer ;
  unsigned char buf___0[8192] ;
  int len ;
  int l ;
  int type ;
  ssize_t tmp ;

  {
#line 525
  while (1) {
#line 525
    buf___0[0] = (unsigned char )(1 >> 24);
#line 525
    buf___0[1] = (unsigned char )(1 >> 16);
#line 525
    buf___0[2] = (unsigned char )(1 >> 8);
#line 525
    buf___0[3] = (unsigned char)1;
#line 525
    break;
  }
#line 526
  buf___0[4] = (unsigned char)9;
#line 529
  tmp = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___0), 5U);
#line 529
  if (tmp != 5) {
#line 530
    error("Error writing to authentication socket.");
#line 531
    return (0);
  }
#line 537
  len = 4;
#line 538
  while (len > 0) {
#line 539
    l = read(auth->fd, (void *)((buf___0 + 4) - len), (unsigned int )len);
#line 540
    if (l <= 0) {
#line 541
      error("Error reading response length from authentication socket.");
#line 542
      return (0);
    }
#line 544
    len -= l;
  }
#line 548
  len = (int )(((((unsigned long )buf___0[0] << 24) | ((unsigned long )buf___0[1] << 16)) | ((unsigned long )buf___0[2] << 8)) | (unsigned long )buf___0[3]);
#line 549
  if (len > 262144) {
#line 550
    fatal("Remove identity response too long: %d", len);
  }
#line 553
  buffer_init(& buffer);
#line 554
  while (len > 0) {
#line 555
    l = len;
#line 556
    if ((unsigned int )l > sizeof(buf___0)) {
#line 557
      l = (int )sizeof(buf___0);
    }
#line 558
    l = read(auth->fd, (void *)(buf___0), (unsigned int )l);
#line 559
    if (l <= 0) {
#line 560
      error("Error reading response from authentication socket.");
#line 561
      buffer_free(& buffer);
#line 562
      return (0);
    }
#line 564
    buffer_append(& buffer, (char const   *)((char *)(buf___0)), (unsigned int )l);
#line 565
    len -= l;
  }
#line 569
  type = buffer_get_char(& buffer);
#line 570
  switch (type) {
  case 5: 
#line 572
  buffer_free(& buffer);
#line 573
  return (0);
  case 6: 
#line 575
  buffer_free(& buffer);
#line 576
  return (1);
  default: 
#line 578
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 582
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 43 "bsd-misc.h"
unsigned int arc4random(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 62 "cipher.h"
unsigned int cipher_mask(void) ;
#line 65
char const   *cipher_name(int cipher ) ;
#line 85
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) ;
#line 90
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 95
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 439 "ssh.h"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) ;
#line 449
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) ;
#line 460
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) ;
#line 504
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 43 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , RSA *key ,
                     char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___0[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 58
  if (0) {
#line 58
    __s1_len = strlen(passphrase);
#line 58
    __s2_len = strlen("");
#line 58
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 58
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 58
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 58
          tmp___8 = 1;
        } else {
#line 58
          if (__s2_len >= 4U) {
#line 58
            tmp___8 = 1;
          } else {
#line 58
            tmp___8 = 0;
          }
        }
      } else {
#line 58
        tmp___8 = 0;
      }
    }
#line 58
    if (tmp___8) {
#line 58
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 58
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
      tmp___4 = tmp___7;
    }
  } else {
#line 58
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
    tmp___4 = tmp___7;
  }
#line 58
  if (tmp___4 == 0) {
#line 59
    cipher_type___0 = 0;
  } else {
#line 61
    cipher_type___0 = 3;
  }
#line 64
  buffer_init(& buffer);
#line 67
  rand___0 = arc4random();
#line 68
  buf___0[0] = (char )(rand___0 & 255U);
#line 69
  buf___0[1] = (char )((rand___0 >> 8) & 255U);
#line 70
  buf___0[2] = buf___0[0];
#line 71
  buf___0[3] = buf___0[1];
#line 72
  buffer_append(& buffer, (char const   *)(buf___0), 4U);
#line 79
  buffer_put_bignum(& buffer, key->d);
#line 80
  buffer_put_bignum(& buffer, key->iqmp);
#line 81
  buffer_put_bignum(& buffer, key->q);
#line 82
  buffer_put_bignum(& buffer, key->p);
#line 85
  while (1) {
#line 85
    tmp___9 = buffer_len(& buffer);
#line 85
    if (! (tmp___9 % 8U != 0U)) {
#line 85
      break;
    }
#line 86
    buffer_put_char(& buffer, 0);
  }
#line 89
  buffer_init(& encrypted);
#line 92
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 93
  i = 0;
#line 93
  while (*(cp + i)) {
#line 94
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 93
    i ++;
  }
#line 95
  buffer_put_char(& encrypted, 0);
#line 98
  buffer_put_char(& encrypted, cipher_type___0);
#line 99
  buffer_put_int(& encrypted, 0U);
#line 102
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 102
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 103
  buffer_put_bignum(& encrypted, key->n);
#line 104
  buffer_put_bignum(& encrypted, key->e);
#line 105
  tmp___11 = strlen(comment);
#line 105
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 108
  tmp___12 = buffer_len(& buffer);
#line 108
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 110
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 1);
#line 111
  tmp___13 = buffer_len(& buffer);
#line 111
  tmp___14 = buffer_ptr(& buffer);
#line 111
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 114
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 117
  memset((void *)(buf___0), 0, sizeof(buf___0));
#line 118
  buffer_free(& buffer);
#line 120
  fd = open(filename, 577, 384);
#line 121
  if (fd < 0) {
#line 122
    return (0);
  }
#line 123
  tmp___17 = buffer_len(& encrypted);
#line 123
  tmp___18 = buffer_ptr(& encrypted);
#line 123
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 123
  tmp___20 = buffer_len(& encrypted);
#line 123
  if ((unsigned int )tmp___19 != tmp___20) {
#line 125
    tmp___15 = __errno_location();
#line 125
    tmp___16 = strerror(*tmp___15);
#line 125
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 127
    buffer_free(& encrypted);
#line 128
    close(fd);
#line 129
    remove(filename);
#line 130
    return (0);
  }
#line 132
  close(fd);
#line 133
  buffer_free(& encrypted);
#line 134
  return (1);
}
}
#line 143 "authfile.c"
int load_public_key(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 152
  fd = open(filename, 0);
#line 153
  if (fd < 0) {
#line 154
    return (0);
  }
#line 155
  len = lseek(fd, 0L, 2);
#line 156
  lseek(fd, 0L, 0);
#line 158
  buffer_init(& buffer);
#line 159
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 161
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 161
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 162
    tmp = __errno_location();
#line 162
    tmp___0 = strerror(*tmp);
#line 162
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 164
    buffer_free(& buffer);
#line 165
    close(fd);
#line 166
    return (0);
  }
#line 168
  close(fd);
#line 171
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 171
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 172
    debug("Bad key file %.200s.", filename);
#line 173
    buffer_free(& buffer);
#line 174
    return (0);
  }
#line 180
  i = 0;
#line 180
  while (1) {
#line 180
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 180
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 180
      break;
    }
#line 181
    tmp___3 = buffer_get_char(& buffer);
#line 181
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 182
      debug("Bad key file %.200s.", filename);
#line 183
      buffer_free(& buffer);
#line 184
      return (0);
    }
#line 180
    i ++;
  }
#line 187
  buffer_get_char(& buffer);
#line 188
  buffer_get_int(& buffer);
#line 191
  buffer_get_int(& buffer);
#line 192
  pub->n = BN_new();
#line 193
  buffer_get_bignum(& buffer, pub->n);
#line 194
  pub->e = BN_new();
#line 195
  buffer_get_bignum(& buffer, pub->e);
#line 196
  if (comment_return) {
#line 197
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 200
  buffer_free(& buffer);
#line 202
  return (1);
}
}
#line 212 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , RSA *prv ,
                     char **comment_return ) 
{ int fd ;
  int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char *tmp___13 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  BIGNUM const   *tmp___26 ;
  BIGNUM const   *tmp___27 ;

  {
#line 225
  fd = open(filename, 0);
#line 226
  if (fd < 0) {
#line 227
    return (0);
  }
#line 230
  tmp = fstat(fd, & st);
#line 230
  if (tmp < 0) {
    goto _L;
  } else {
#line 230
    if (st.st_uid != 0U) {
#line 230
      tmp___0 = getuid();
#line 230
      if (tmp___0 != 0U) {
#line 230
        tmp___1 = getuid();
#line 230
        if (st.st_uid != tmp___1) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 230
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 233
        close(fd);
#line 234
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 235
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 236
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 237
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 239
        error("It is recommended that your private key files are NOT accessible by others.");
#line 240
        return (0);
      }
    }
  }
#line 242
  len = lseek(fd, 0L, 2);
#line 243
  lseek(fd, 0L, 0);
#line 245
  buffer_init(& buffer);
#line 246
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 248
  tmp___4 = read(fd, (void *)cp, (unsigned int )len);
#line 248
  if ((unsigned int )tmp___4 != (unsigned int )len) {
#line 249
    tmp___2 = __errno_location();
#line 249
    tmp___3 = strerror(*tmp___2);
#line 249
    debug("Read from key file %.200s failed: %.100s", filename, tmp___3);
#line 251
    buffer_free(& buffer);
#line 252
    close(fd);
#line 253
    return (0);
  }
#line 255
  close(fd);
#line 258
  tmp___5 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 258
  if ((unsigned long )len < (unsigned long )(tmp___5 + 1U)) {
#line 259
    debug("Bad key file %.200s.", filename);
#line 260
    buffer_free(& buffer);
#line 261
    return (0);
  }
#line 267
  i = 0;
#line 267
  while (1) {
#line 267
    tmp___7 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 267
    if (! ((unsigned int )i < tmp___7 + 1U)) {
#line 267
      break;
    }
#line 268
    tmp___6 = buffer_get_char(& buffer);
#line 268
    if (tmp___6 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 269
      debug("Bad key file %.200s.", filename);
#line 270
      buffer_free(& buffer);
#line 271
      return (0);
    }
#line 267
    i ++;
  }
#line 274
  cipher_type___0 = buffer_get_char(& buffer);
#line 275
  buffer_get_int(& buffer);
#line 278
  buffer_get_int(& buffer);
#line 279
  prv->n = BN_new();
#line 280
  buffer_get_bignum(& buffer, prv->n);
#line 281
  prv->e = BN_new();
#line 282
  buffer_get_bignum(& buffer, prv->e);
#line 283
  if (comment_return) {
#line 284
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 286
    tmp___8 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 286
    xfree((void *)tmp___8);
  }
#line 289
  tmp___10 = cipher_mask();
#line 289
  if (((tmp___10 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 291
    tmp___9 = cipher_name(cipher_type___0);
#line 291
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___9, filename);
#line 293
    buffer_free(& buffer);
    goto fail;
  }
#line 297
  buffer_init(& decrypted);
#line 298
  tmp___11 = buffer_len(& buffer);
#line 298
  buffer_append_space(& decrypted, & cp, tmp___11);
#line 301
  cipher_set_key_string(& cipher, cipher_type___0, passphrase, 0);
#line 302
  tmp___12 = buffer_len(& buffer);
#line 302
  tmp___13 = buffer_ptr(& buffer);
#line 302
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___13),
                 tmp___12);
#line 306
  buffer_free(& buffer);
#line 308
  check1 = buffer_get_char(& decrypted);
#line 309
  check2 = buffer_get_char(& decrypted);
#line 310
  tmp___24 = buffer_get_char(& decrypted);
#line 310
  if (check1 != tmp___24) {
    goto _L___4;
  } else {
#line 310
    tmp___25 = buffer_get_char(& decrypted);
#line 310
    if (check2 != tmp___25) {
      _L___4: /* CIL Label */ 
#line 312
      if (0) {
#line 312
        __s1_len = strlen(passphrase);
#line 312
        __s2_len = strlen("");
#line 312
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___3;
        } else {
#line 312
          if (__s1_len >= 4U) {
            _L___3: /* CIL Label */ 
#line 312
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 312
              tmp___23 = 1;
            } else {
#line 312
              if (__s2_len >= 4U) {
#line 312
                tmp___23 = 1;
              } else {
#line 312
                tmp___23 = 0;
              }
            }
          } else {
#line 312
            tmp___23 = 0;
          }
        }
#line 312
        if (tmp___23) {
#line 312
          tmp___19 = __builtin_strcmp(passphrase, "");
        } else {
#line 312
          tmp___22 = __builtin_strcmp(passphrase, "");
#line 312
          tmp___19 = tmp___22;
        }
      } else {
#line 312
        tmp___22 = __builtin_strcmp(passphrase, "");
#line 312
        tmp___19 = tmp___22;
      }
#line 312
      if (tmp___19 != 0) {
#line 313
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 315
      buffer_free(& decrypted);
      fail: 
#line 317
      BN_clear_free(prv->n);
#line 318
      BN_clear_free(prv->e);
#line 319
      if (comment_return) {
#line 320
        xfree((void *)*comment_return);
      }
#line 321
      return (0);
    }
  }
#line 324
  prv->d = BN_new();
#line 325
  buffer_get_bignum(& decrypted, prv->d);
#line 326
  prv->iqmp = BN_new();
#line 327
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 329
  prv->q = BN_new();
#line 330
  buffer_get_bignum(& decrypted, prv->q);
#line 331
  prv->p = BN_new();
#line 332
  buffer_get_bignum(& decrypted, prv->p);
#line 334
  ctx = BN_CTX_new();
#line 335
  aux = BN_new();
#line 337
  tmp___26 = BN_value_one();
#line 337
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___26);
#line 338
  prv->dmq1 = BN_new();
#line 339
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 341
  tmp___27 = BN_value_one();
#line 341
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___27);
#line 342
  prv->dmp1 = BN_new();
#line 343
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 345
  BN_clear_free(aux);
#line 346
  BN_CTX_free(ctx);
#line 348
  buffer_free(& decrypted);
#line 350
  return (1);
}
}
#line 1 "bsd-bindresvport.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 7 "bsd-bindresvport.h"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) ;
#line 53 "bsd-bindresvport.c"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) 
{ int error___0 ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  int salen ;
  int i ;
  int *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 68
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 69
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 70
    sa = (struct sockaddr *)(& myaddr);
  }
#line 73
  if (af == 2) {
#line 74
    sin = (struct sockaddr_in *)sa;
#line 75
    salen = (int )sizeof(struct sockaddr_in );
#line 76
    portp = & sin->sin_port;
  } else {
#line 77
    if (af == 10) {
#line 78
      sin6 = (struct sockaddr_in6 *)sa;
#line 79
      salen = (int )sizeof(struct sockaddr_in6 );
#line 80
      portp = & sin6->sin6_port;
    } else {
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 96;
#line 83
      return (-1);
    }
  }
#line 85
  sa->sa_family = (unsigned short )af;
#line 87
  __x = *portp;
#line 87
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 87
  port = __v;
#line 88
  if ((int )port == 0) {
#line 89
    tmp___0 = arc4random();
#line 89
    port = (unsigned short )(tmp___0 % 424U + 600U);
  }
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  *)sa, (unsigned int )salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___1 = __errno_location();
#line 101
      if (! (*tmp___1 == 98)) {
#line 101
        tmp___2 = __errno_location();
#line 101
        if (! (*tmp___2 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port = (u_int16_t )((int )port + 1);
#line 105
    if ((int )port > 1023) {
#line 106
      port = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "bsd-daemon.o"
#line 1 "bsd-misc.o"
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 44 "bsd-misc.h"
void arc4random_stir(void) ;
#line 48
void setproctitle(char const   *fmt  , ...) ;
#line 39 "random.h"
void get_random_bytes(unsigned char *buf___0 , int len ) ;
#line 66 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) ;
#line 67
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) ;
#line 69 "bsd-misc.c"
static rc4_t *rc4  =    (rc4_t *)((void *)0);
#line 71 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) 
{ int t ;

  {
#line 75
  r->i = 0;
#line 75
  while (r->i < 256) {
#line 76
    r->s[r->i] = (unsigned int )r->i;
#line 75
    (r->i) ++;
  }
#line 78
  r->j = 0;
#line 79
  r->i = 0;
#line 79
  while (r->i < 256) {
#line 81
    r->j = (int )((((unsigned int )r->j + r->s[r->i]) + (unsigned int )*(key + r->i % len)) % 256U);
#line 82
    t = (int )r->s[r->i];
#line 83
    r->s[r->i] = r->s[r->j];
#line 84
    r->s[r->j] = (unsigned int )t;
#line 79
    (r->i) ++;
  }
#line 86
  r->j = 0;
#line 86
  r->i = r->j;
#line 87
  return;
}
}
#line 89 "bsd-misc.c"
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) 
{ int t ;
  int c ;

  {
#line 94
  c = 0;
#line 95
  while (c < len) {
#line 97
    r->i = (r->i + 1) % 256;
#line 98
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 99
    t = (int )r->s[r->i];
#line 100
    r->s[r->i] = r->s[r->j];
#line 101
    r->s[r->j] = (unsigned int )t;
#line 103
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 105
    *(buffer + c) = (unsigned char )r->s[t];
#line 106
    c ++;
  }
#line 108
  return;
}
}
#line 110 "bsd-misc.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 114
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 115
    arc4random_stir();
  }
#line 117
  rc4_getbytes(rc4, (unsigned char *)(& r), (int )sizeof(r));
#line 119
  return (r);
}
}
#line 122 "bsd-misc.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[32] ;
  void *tmp ;

  {
#line 126
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 127
    tmp = xmalloc(sizeof(*rc4));
#line 127
    rc4 = (rc4_t *)tmp;
  }
#line 129
  get_random_bytes(rand_buf, (int )sizeof(rand_buf));
#line 130
  rc4_key(rc4, rand_buf, (int )sizeof(rand_buf));
#line 131
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 132
  return;
}
}
#line 136 "bsd-misc.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 139
  return;
}
}
#line 167
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 167 "bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 169
  return (0);
}
}
#line 1 "bsd-mktemp.o"
#line 1 "bsd-rresvport.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-strlcat.o"
#line 46 "bsd-strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "bsd-strlcpy.o"
#line 45 "bsd-strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 54 "buffer.h"
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 37 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  unsigned char *buf___0 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 40
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 40
  bits = tmp;
#line 41
  bin_size = (bits + 7) / 8;
#line 42
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 42
  buf___0 = (unsigned char *)tmp___0;
#line 47
  oi = BN_bn2bin((BIGNUM const   *)value, buf___0);
#line 48
  if (oi != bin_size) {
#line 49
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 53
  while (1) {
#line 53
    msg[0] = (char )(bits >> 8);
#line 53
    msg[1] = (char )bits;
#line 53
    break;
  }
#line 54
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 56
  buffer_append(buffer, (char const   *)((char *)buf___0), (unsigned int )oi);
#line 58
  memset((void *)buf___0, 0, (unsigned int )bin_size);
#line 59
  xfree((void *)buf___0);
#line 60
  return;
}
}
#line 65 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf___0[2] ;
  unsigned char *bin ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 72
  buffer_get(buffer, (char *)(buf___0), 2U);
#line 73
  bits = (int )(((unsigned long )buf___0[0] << 8) | (unsigned long )buf___0[1]);
#line 75
  bytes = (bits + 7) / 8;
#line 76
  tmp = buffer_len(buffer);
#line 76
  if (tmp < (unsigned int )bytes) {
#line 77
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 78
  tmp___0 = buffer_ptr(buffer);
#line 78
  bin = (unsigned char *)tmp___0;
#line 79
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 80
  buffer_consume(buffer, (unsigned int )bytes);
#line 82
  return (2 + bytes);
}
}
#line 88 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf___0[4] ;

  {
#line 92
  buffer_get(buffer, (char *)(buf___0), 4U);
#line 93
  return ((unsigned int )(((((unsigned long )buf___0[0] << 24) | ((unsigned long )buf___0[1] << 16)) | ((unsigned long )buf___0[2] << 8)) | (unsigned long )buf___0[3]));
}
}
#line 99 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf___0[4] ;

  {
#line 103
  while (1) {
#line 103
    buf___0[0] = (char )(value >> 24);
#line 103
    buf___0[1] = (char )(value >> 16);
#line 103
    buf___0[2] = (char )(value >> 8);
#line 103
    buf___0[3] = (char )value;
#line 103
    break;
  }
#line 104
  buffer_append(buffer, (char const   *)(buf___0), 4U);
#line 105
  return;
}
}
#line 115 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 121
  len = buffer_get_int(buffer);
#line 122
  if (len > 262144U) {
#line 123
    fatal("Received packet with bad string length %d", len);
  }
#line 125
  tmp = xmalloc(len + 1U);
#line 125
  value = (char *)tmp;
#line 127
  buffer_get(buffer, value, len);
#line 129
  *(value + len) = (char)0;
#line 131
  if (length_ptr) {
#line 132
    *length_ptr = len;
  }
#line 133
  return (value);
}
}
#line 139 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___0 , unsigned int len ) 
{ 

  {
#line 142
  buffer_put_int(buffer, len);
#line 143
  buffer_append(buffer, (char const   *)buf___0, len);
#line 144
  return;
}
}
#line 149 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 153
  buffer_get(buffer, & ch, 1U);
#line 154
  return ((int )((unsigned char )ch));
}
}
#line 160 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 163
  ch = (char )value;
#line 164
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 165
  return;
}
}
#line 1 "buffer.o"
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 57 "buffer.h"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 66
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 28
  buffer->alloc = 4096U;
#line 29
  tmp = xmalloc(buffer->alloc);
#line 29
  buffer->buf = (char *)tmp;
#line 30
  buffer->offset = 0U;
#line 31
  buffer->end = 0U;
#line 32
  return;
}
}
#line 36 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 39
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 40
  xfree((void *)buffer->buf);
#line 41
  return;
}
}
#line 48 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 51
  buffer->offset = 0U;
#line 52
  buffer->end = 0U;
#line 53
  return;
}
}
#line 57 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 61
  buffer_append_space(buffer, & cp, len);
#line 62
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 63
  return;
}
}
#line 71 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 75
  if (buffer->offset == buffer->end) {
#line 76
    buffer->offset = 0U;
#line 77
    buffer->end = 0U;
  }
  restart: 
#line 81
  if (buffer->end + len < buffer->alloc) {
#line 82
    *datap = buffer->buf + buffer->end;
#line 83
    buffer->end += len;
#line 84
    return;
  }
#line 90
  if (buffer->offset > buffer->alloc / 2U) {
#line 91
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 93
    buffer->end -= buffer->offset;
#line 94
    buffer->offset = 0U;
    goto restart;
  }
#line 98
  buffer->alloc += len + 32768U;
#line 99
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 99
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 105 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 108
  return (buffer->end - buffer->offset);
}
}
#line 113 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___0 , unsigned int len ) 
{ 

  {
#line 116
  if (len > buffer->end - buffer->offset) {
#line 117
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 118
  memcpy((void * __restrict  )buf___0, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 119
  buffer->offset += len;
#line 120
  return;
}
}
#line 124 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 127
  if (bytes > buffer->end - buffer->offset) {
#line 128
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 129
  buffer->offset += bytes;
#line 130
  return;
}
}
#line 134 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 137
  if (bytes > buffer->end - buffer->offset) {
#line 138
    fatal("buffer_get trying to get more bytes than in buffer");
  }
#line 139
  buffer->end -= bytes;
#line 140
  return;
}
}
#line 144 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 147
  return (buffer->buf + buffer->offset);
}
}
#line 152 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 156
  ucp = (unsigned char *)buffer->buf;
#line 158
  i = (int )buffer->offset;
#line 158
  while ((unsigned int )i < buffer->end) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 158
    i ++;
  }
#line 160
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 161
  return;
}
}
#line 1 "canohost.o"
#line 114 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 41 "packet.h"
int packet_get_connection_in(void) ;
#line 154
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 202
int packet_connection_is_on_socket(void) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 367 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 374
char const   *get_canonical_hostname(void) ;
#line 380
char const   *get_remote_ipaddr(void) ;
#line 383
int get_peer_port(int sock ) ;
#line 386
int get_remote_port(void) ;
#line 387
int get_local_port(void) ;
#line 507
void fatal_cleanup(void) ;
#line 28 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[64] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  socklen_t option_size ;
  int ipproto ;
  struct protoent *ip ;
  int tmp___20 ;
  char *tmp___21 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 47
  if ((int )from.ss_family == 10) {
#line 48
    from6 = (struct sockaddr_in6 *)(& from);
#line 52
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 52
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 52
        __x = 65535U;
#line 52
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 52
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 53
          from4 = (struct sockaddr_in *)(& from);
#line 57
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 58
          port = from6->sin6_port;
#line 60
          memset((void *)(& from), 0, sizeof(from));
#line 62
          from4->sin_family = (unsigned short)2;
#line 63
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 64
          from4->sin_port = port;
        }
      }
    }
  }
#line 69
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 69
  if (tmp___2 != 0) {
#line 71
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                         fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                         0U, 8U);
#line 74
  if (tmp___19 == 0) {
#line 77
    name[sizeof(name) - 1U] = (char )'\000';
#line 82
    i = 0;
#line 82
    while (name[i]) {
#line 83
      tmp___6 = __ctype_b_loc();
#line 83
      if ((int const   )*(*tmp___6 + (int )name[i]) & 256) {
#line 84
        if (sizeof(name[i]) > 1U) {
#line 84
          __res = tolower((int )name[i]);
        } else {
#line 84
          tmp___5 = __ctype_tolower_loc();
#line 84
          __res = (int )*(*tmp___5 + (int )name[i]);
        }
#line 84
        name[i] = (char )__res;
      }
#line 82
      i ++;
    }
#line 95
    memset((void *)(& hints), 0, sizeof(hints));
#line 96
    hints.ai_family = (int )from.ss_family;
#line 97
    hints.ai_socktype = 1;
#line 98
    tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                          (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 98
    if (tmp___7 != 0) {
#line 99
      log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 100
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
#line 104
    ai = aitop;
#line 104
    while (ai) {
#line 105
      tmp___8 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                            (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                            0U, 1U);
#line 107
      if (tmp___8 == 0) {
#line 107
        if (0) {
#line 107
          __s1_len = strlen((char const   *)(ntop));
#line 107
          __s2_len = strlen((char const   *)(ntop2));
#line 107
          if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
            goto _L___0;
          } else {
#line 107
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 107
              if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 107
                tmp___18 = 1;
              } else {
#line 107
                if (__s2_len >= 4U) {
#line 107
                  tmp___18 = 1;
                } else {
#line 107
                  tmp___18 = 0;
                }
              }
            } else {
#line 107
              tmp___18 = 0;
            }
          }
#line 107
          if (tmp___18) {
#line 107
            tmp___14 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
          } else {
#line 107
            tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
            tmp___14 = tmp___17;
          }
        } else {
#line 107
          tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
          tmp___14 = tmp___17;
        }
#line 107
        if (tmp___14 == 0) {
#line 108
          break;
        }
      }
#line 104
      ai = ai->ai_next;
    }
#line 110
    freeaddrinfo(aitop);
#line 112
    if (! ai) {
#line 114
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          ntop, name);
#line 116
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 122
    strlcpy(name, (char const   *)(ntop), sizeof(name));
#line 123
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 140
  if ((int )from.ss_family == 2) {
#line 147
    ip = getprotobyname("ip");
#line 147
    if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 148
      ipproto = ip->p_proto;
    } else {
#line 150
      ipproto = 0;
    }
#line 151
    option_size = sizeof(options___0);
#line 152
    tmp___20 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                          (socklen_t * __restrict  )(& option_size));
#line 152
    if (tmp___20 >= 0) {
#line 152
      if (option_size != 0U) {
#line 154
        cp = text;
#line 156
        ucp = options___0;
#line 156
        while (option_size > 0U) {
#line 157
          sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x",
                  *ucp);
#line 156
          ucp ++;
#line 156
          option_size --;
#line 156
          cp += 3;
        }
#line 158
        log("Connection from %.100s with IP options:%.800s", ntop, text);
#line 160
        packet_disconnect("Connection from %.100s with IP options:%.800s", ntop, text);
      }
    }
  }
#line 165
  tmp___21 = xstrdup((char const   *)(name));
#line 165
  return (tmp___21);
}
}
#line 177 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 174 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 180
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 181
    return ((char const   *)canonical_host_name);
  }
#line 184
  tmp___0 = packet_connection_is_on_socket();
#line 184
  if (tmp___0) {
#line 185
    tmp = packet_get_connection_in();
#line 185
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 187
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 189
  return ((char const   *)canonical_host_name);
}
}
#line 200 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 197 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  int socket___0 ;
  char ntop[1025] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 207
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 208
    return ((char const   *)canonical_host_ip);
  }
#line 211
  tmp = packet_connection_is_on_socket();
#line 211
  if (! tmp) {
#line 212
    canonical_host_ip = xstrdup("UNKNOWN");
#line 213
    return ((char const   *)canonical_host_ip);
  }
#line 216
  socket___0 = packet_get_connection_in();
#line 219
  fromlen = sizeof(from);
#line 220
  memset((void *)(& from), 0, sizeof(from));
#line 221
  tmp___2 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 221
  if (tmp___2 < 0) {
#line 222
    tmp___0 = __errno_location();
#line 222
    tmp___1 = strerror(*tmp___0);
#line 222
    debug("getpeername failed: %.100s", tmp___1);
#line 223
    fatal_cleanup();
  }
#line 226
  tmp___3 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 226
  if (tmp___3 != 0) {
#line 228
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 230
  canonical_host_ip = xstrdup((char const   *)(ntop));
#line 233
  return ((char const   *)canonical_host_ip);
}
}
#line 238 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 246
  fromlen = sizeof(from);
#line 247
  memset((void *)(& from), 0, sizeof(from));
#line 248
  if (local) {
#line 249
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 249
    if (tmp___1 < 0) {
#line 250
      tmp = __errno_location();
#line 250
      tmp___0 = strerror(*tmp);
#line 250
      error("getsockname failed: %.100s", tmp___0);
#line 251
      return (0);
    }
  } else {
#line 254
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 254
    if (tmp___4 < 0) {
#line 255
      tmp___2 = __errno_location();
#line 255
      tmp___3 = strerror(*tmp___2);
#line 255
      debug("getpeername failed: %.100s", tmp___3);
#line 256
      fatal_cleanup();
    }
  }
#line 260
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 260
  if (tmp___5 != 0) {
#line 262
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 263
  tmp___6 = atoi((char const   *)(strport));
#line 263
  return (tmp___6);
}
}
#line 268 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 275
  tmp = packet_connection_is_on_socket();
#line 275
  if (! tmp) {
#line 276
    return (65535);
  }
#line 279
  tmp___0 = packet_get_connection_in();
#line 279
  tmp___1 = get_sock_port(tmp___0, local);
#line 279
  return (tmp___1);
}
}
#line 282 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 285
  tmp = get_sock_port(sock, 0);
#line 285
  return (tmp);
}
}
#line 288 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 291
  tmp = get_port(0);
#line 291
  return (tmp);
}
}
#line 294 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 297
  tmp = get_port(1);
#line 297
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 503 "ssh.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 514
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 522
void channel_set_options(int hostname_in_open ) ;
#line 529
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 532
void channel_free(int channel ) ;
#line 535
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 541
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 544
void channel_output_poll(void) ;
#line 551
void channel_input_data(int payload_len ) ;
#line 554
int channel_not_very_much_buffered_data(void) ;
#line 557
void channel_input_close(void) ;
#line 560
void channel_input_close_confirmation(void) ;
#line 563
void channel_input_open_confirmation(void) ;
#line 566
void channel_input_open_failure(void) ;
#line 570
void channel_stop_listening(void) ;
#line 576
void channel_close_all(void) ;
#line 579
int channel_max_fd(void) ;
#line 582
int channel_still_open(void) ;
#line 589
char *channel_open_message(void) ;
#line 596
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) ;
#line 606
void channel_request_remote_forwarding(u_short port , char const   *host , u_short remote_port ) ;
#line 615
void channel_permit_all_opens(void) ;
#line 622
void channel_input_port_forward_request(int is_root ) ;
#line 629
void channel_input_port_open(int payload_len ) ;
#line 642
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 649
void x11_input_open(int payload_len ) ;
#line 661
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) ;
#line 664
void auth_request_forwarding(void) ;
#line 671
char *auth_get_socket_name(void) ;
#line 677
void auth_input_request_forwarding(struct passwd *pw ) ;
#line 680
void auth_input_open_request(void) ;
#line 749
int IPv4or6 ;
#line 80 "packet.h"
int packet_is_interactive(void) ;
#line 83
void packet_start(int type ) ;
#line 89
void packet_put_int(unsigned int value ) ;
#line 95
void packet_put_string(char const   *buf___0 , unsigned int len ) ;
#line 101
void packet_send(void) ;
#line 110
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 132
unsigned int packet_get_int(void) ;
#line 146
char *packet_get_string(unsigned int *length_ptr ) ;
#line 172
void packet_write_wait(void) ;
#line 181
int max_packet_size ;
#line 22 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 28
void restore_uid(void) ;
#line 76 "nchan.h"
void chan_rcvd_oclose(Channel *c ) ;
#line 77
void chan_read_failed(Channel *c ) ;
#line 78
void chan_ibuf_empty(Channel *c ) ;
#line 81
void chan_rcvd_ieof(Channel *c ) ;
#line 82
void chan_write_failed(Channel *c ) ;
#line 83
void chan_obuf_empty(Channel *c ) ;
#line 85
void chan_init_iostates(Channel *c ) ;
#line 34 "compat.h"
int compat13 ;
#line 44 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 51 "channels.c"
static int channels_alloc  =    0;
#line 57 "channels.c"
static int channel_max_fd_value  =    0;
#line 60 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 61 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 64 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 67 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 68 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 74 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 75 "channels.c"
unsigned int x11_fake_data_len  ;
#line 89 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 91 "channels.c"
static int num_permitted_opens  =    0;
#line 97 "channels.c"
static int all_opens_permitted  =    0;
#line 100 "channels.c"
static int have_hostname_in_open  =    0;
#line 104 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 107
  have_hostname_in_open = hostname_in_open;
#line 108
  return;
}
}
#line 116 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 119
  all_opens_permitted = 1;
#line 120
  return;
}
}
#line 127 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 134
  if (sock > channel_max_fd_value) {
#line 135
    channel_max_fd_value = sock;
  }
#line 139
  if (channels_alloc == 0) {
#line 140
    channels_alloc = 10;
#line 141
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 141
    channels = (Channel *)tmp;
#line 142
    i = 0;
#line 142
    while (i < channels_alloc) {
#line 143
      (channels + i)->type = 0;
#line 142
      i ++;
    }
#line 148
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 151
  found = -1;
#line 151
  i = 0;
#line 151
  while (i < channels_alloc) {
#line 152
    if ((channels + i)->type == 0) {
#line 154
      found = i;
#line 155
      break;
    }
#line 151
    i ++;
  }
#line 157
  if (found == -1) {
#line 159
    found = channels_alloc;
#line 160
    channels_alloc += 10;
#line 161
    debug("channel: expanding %d", channels_alloc);
#line 162
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 162
    channels = (Channel *)tmp___0;
#line 163
    i = found;
#line 163
    while (i < channels_alloc) {
#line 164
      (channels + i)->type = 0;
#line 163
      i ++;
    }
  }
#line 167
  c = channels + found;
#line 168
  buffer_init(& c->input);
#line 169
  buffer_init(& c->output);
#line 170
  chan_init_iostates(c);
#line 171
  c->self = found;
#line 172
  c->type = type;
#line 173
  c->sock = sock;
#line 174
  c->remote_id = -1;
#line 175
  c->remote_name = remote_name;
#line 176
  debug("channel %d: new [%s]", found, remote_name);
#line 177
  return (found);
}
}
#line 182 "channels.c"
void channel_free(int channel ) 
{ 

  {
#line 185
  if (channel < 0) {
#line 187
    packet_disconnect("channel free: bad local channel %d", channel);
  } else {
#line 185
    if (channel >= channels_alloc) {
#line 187
      packet_disconnect("channel free: bad local channel %d", channel);
    } else {
#line 185
      if ((channels + channel)->type == 0) {
#line 187
        packet_disconnect("channel free: bad local channel %d", channel);
      }
    }
  }
#line 189
  if (compat13) {
#line 190
    shutdown((channels + channel)->sock, 2);
  }
#line 191
  close((channels + channel)->sock);
#line 192
  buffer_free(& (channels + channel)->input);
#line 193
  buffer_free(& (channels + channel)->output);
#line 194
  (channels + channel)->type = 0;
#line 195
  if ((channels + channel)->remote_name) {
#line 196
    xfree((void *)(channels + channel)->remote_name);
#line 197
    (channels + channel)->remote_name = (char *)((void *)0);
  }
#line 199
  return;
}
}
#line 206 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *ch ;
  unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;
  unsigned int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 214
  i = 0;
#line 214
  while (i < channels_alloc) {
#line 215
    ch = channels + i;
    redo: 
#line 217
    switch (ch->type) {
    case 1: 
    case 2: 
    case 7: 
#line 221
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 222
    break;
    case 4: 
#line 225
    if (compat13) {
#line 226
      tmp = buffer_len(& ch->input);
#line 226
      if (tmp < (unsigned int )max_packet_size) {
#line 227
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 228
      tmp___0 = buffer_len(& ch->output);
#line 228
      if (tmp___0 > 0U) {
#line 229
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 230
      break;
    }
#line 233
    if (ch->istate == 1) {
#line 234
      tmp___1 = buffer_len(& ch->input);
#line 234
      if (tmp___1 < (unsigned int )max_packet_size) {
#line 235
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 236
    if (ch->ostate == 16) {
      goto _L;
    } else {
#line 236
      if (ch->ostate == 32) {
        _L: /* CIL Label */ 
#line 238
        tmp___2 = buffer_len(& ch->output);
#line 238
        if (tmp___2 > 0U) {
#line 239
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
#line 240
          if (ch->ostate == 32) {
#line 241
            chan_obuf_empty(ch);
          }
        }
      }
    }
#line 244
    break;
    case 10: 
#line 247
    if (! compat13) {
#line 248
      fatal("cannot happen: IN_DRAIN");
    }
#line 249
    tmp___3 = buffer_len(& ch->input);
#line 249
    if (tmp___3 == 0U) {
#line 250
      packet_start(24);
#line 251
      packet_put_int((unsigned int )ch->remote_id);
#line 252
      packet_send();
#line 253
      ch->type = 5;
#line 254
      debug("Closing channel %d after input drain.", ch->self);
#line 255
      break;
    }
#line 257
    break;
    case 11: 
#line 260
    if (! compat13) {
#line 261
      fatal("cannot happen: OUT_DRAIN");
    }
#line 262
    tmp___4 = buffer_len(& ch->output);
#line 262
    if (tmp___4 == 0U) {
#line 263
      channel_free(i);
#line 264
      break;
    }
#line 266
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 267
    break;
    case 9: 
#line 281
    tmp___5 = buffer_len(& ch->output);
#line 281
    if (tmp___5 < 12U) {
#line 282
      break;
    }
#line 285
    tmp___6 = buffer_ptr(& ch->output);
#line 285
    ucp = (unsigned char *)tmp___6;
#line 286
    if ((int )*(ucp + 0) == 66) {
#line 287
      proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 288
      data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
    } else {
#line 289
      if ((int )*(ucp + 0) == 108) {
#line 290
        proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 291
        data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
      } else {
#line 293
        debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 295
        ch->type = 4;
        goto reject;
      }
    }
#line 300
    tmp___7 = buffer_len(& ch->output);
#line 300
    if (tmp___7 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 302
      break;
    }
#line 305
    tmp___8 = strlen((char const   *)x11_saved_proto);
#line 305
    if (proto_len != tmp___8) {
#line 307
      debug("X11 connection uses different authentication protocol.");
#line 308
      ch->type = 4;
      goto reject;
    } else {
#line 305
      tmp___9 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                       proto_len);
#line 305
      if (tmp___9 != 0) {
#line 307
        debug("X11 connection uses different authentication protocol.");
#line 308
        ch->type = 4;
        goto reject;
      }
    }
#line 312
    if (data_len != x11_fake_data_len) {
#line 315
      debug("X11 auth data does not match fake data.");
#line 316
      ch->type = 4;
      goto reject;
    } else {
#line 312
      tmp___10 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                        (void const   *)x11_fake_data, x11_fake_data_len);
#line 312
      if (tmp___10 != 0) {
#line 315
        debug("X11 auth data does not match fake data.");
#line 316
        ch->type = 4;
        goto reject;
      }
    }
#line 320
    if (x11_fake_data_len != x11_saved_data_len) {
#line 321
      error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 323
      ch->type = 4;
      goto reject;
    }
#line 331
    memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
           x11_saved_data_len);
#line 335
    ch->type = 4;
    goto redo;
    reject: 
#line 343
    log("X11 connection rejected because of wrong authentication.\r\n");
#line 344
    buffer_clear(& ch->input);
#line 345
    buffer_clear(& ch->output);
#line 346
    if (compat13) {
#line 347
      close(ch->sock);
#line 348
      ch->sock = -1;
#line 349
      ch->type = 5;
#line 350
      packet_start(24);
#line 351
      packet_put_int((unsigned int )ch->remote_id);
#line 352
      packet_send();
    } else {
#line 354
      debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
#line 355
      chan_read_failed(ch);
#line 356
      chan_write_failed(ch);
#line 357
      debug("X11 rejected %d i%d/o%d", ch->self, ch->istate, ch->ostate);
    }
#line 359
    break;
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 214
    i ++;
  }
#line 366
  return;
}
}
#line 373 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int i ;
  int newch ;
  int len ;
  socklen_t addrlen ;
  Channel *ch ;
  char buf___0[16384] ;
  char *remote_hostname ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  register char __result ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  register char __result___0 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  register char __result___1 ;
  unsigned int tmp___13 ;
  register char __result___2 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned int tmp___16 ;
  register char __result___3 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  char *tmp___19 ;
  unsigned int tmp___20 ;
  register char __result___4 ;
  unsigned int tmp___21 ;

  {
#line 383
  i = 0;
#line 383
  while (i < channels_alloc) {
#line 384
    ch = channels + i;
#line 385
    switch (ch->type) {
    case 1: 
#line 388
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 388
    if (__result) {
#line 389
      debug("X11 connection requested.");
#line 390
      addrlen = sizeof(addr);
#line 391
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 392
      if (newsock < 0) {
#line 393
        tmp = __errno_location();
#line 393
        tmp___0 = strerror(*tmp);
#line 393
        error("accept: %.100s", tmp___0);
#line 394
        break;
      }
#line 396
      remote_hostname = get_remote_hostname(newsock);
#line 397
      tmp___1 = get_peer_port(newsock);
#line 397
      snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"X11 connection from %.200s port %d",
               remote_hostname, tmp___1);
#line 399
      xfree((void *)remote_hostname);
#line 400
      tmp___2 = xstrdup((char const   *)(buf___0));
#line 400
      newch = channel_allocate(3, newsock, tmp___2);
#line 402
      packet_start(27);
#line 403
      packet_put_int((unsigned int )newch);
#line 404
      if (have_hostname_in_open) {
#line 405
        tmp___3 = strlen((char const   *)(buf___0));
#line 405
        packet_put_string((char const   *)(buf___0), tmp___3);
      }
#line 406
      packet_send();
    }
#line 408
    break;
    case 2: 
#line 415
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 415
    if (__result___0) {
#line 416
      debug("Connection to port %d forwarding to %.100s port %d requested.", ch->listening_port,
            ch->path, ch->host_port);
#line 418
      addrlen = sizeof(addr);
#line 419
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 420
      if (newsock < 0) {
#line 421
        tmp___4 = __errno_location();
#line 421
        tmp___5 = strerror(*tmp___4);
#line 421
        error("accept: %.100s", tmp___5);
#line 422
        break;
      }
#line 424
      remote_hostname = get_remote_hostname(newsock);
#line 425
      tmp___6 = get_peer_port(newsock);
#line 425
      snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"listen port %d for %.100s port %d, connect from %.200s port %d",
               ch->listening_port, ch->path, ch->host_port, remote_hostname, tmp___6);
#line 428
      xfree((void *)remote_hostname);
#line 429
      tmp___7 = xstrdup((char const   *)(buf___0));
#line 429
      newch = channel_allocate(3, newsock, tmp___7);
#line 431
      packet_start(29);
#line 432
      packet_put_int((unsigned int )newch);
#line 433
      tmp___8 = strlen((char const   *)(ch->path));
#line 433
      packet_put_string((char const   *)(ch->path), tmp___8);
#line 434
      packet_put_int((unsigned int )ch->host_port);
#line 435
      if (have_hostname_in_open) {
#line 436
        tmp___9 = strlen((char const   *)(buf___0));
#line 436
        packet_put_string((char const   *)(buf___0), tmp___9);
      }
#line 437
      packet_send();
    }
#line 439
    break;
    case 7: 
#line 446
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 446
    if (__result___1) {
#line 447
      addrlen = sizeof(addr);
#line 448
      newsock = accept(ch->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 449
      if (newsock < 0) {
#line 450
        tmp___10 = __errno_location();
#line 450
        tmp___11 = strerror(*tmp___10);
#line 450
        error("accept from auth socket: %.100s", tmp___11);
#line 451
        break;
      }
#line 453
      tmp___12 = xstrdup("accepted auth socket");
#line 453
      newch = channel_allocate(3, newsock, tmp___12);
#line 455
      packet_start(31);
#line 456
      packet_put_int((unsigned int )newch);
#line 457
      packet_send();
    }
#line 459
    break;
    case 4: 
#line 472
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___2): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 472
    if (__result___2) {
#line 473
      len = read(ch->sock, (void *)(buf___0), sizeof(buf___0));
#line 474
      if (len <= 0) {
#line 475
        if (compat13) {
#line 476
          tmp___13 = buffer_len(& ch->output);
#line 476
          buffer_consume(& ch->output, tmp___13);
#line 477
          ch->type = 10;
#line 478
          debug("Channel %d status set to input draining.", i);
        } else {
#line 480
          chan_read_failed(ch);
        }
#line 482
        break;
      }
#line 484
      buffer_append(& ch->input, (char const   *)(buf___0), (unsigned int )len);
    }
#line 487
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___3): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 487
    if (__result___3) {
#line 487
      tmp___17 = buffer_len(& ch->output);
#line 487
      if (tmp___17 > 0U) {
#line 488
        tmp___14 = buffer_len(& ch->output);
#line 488
        tmp___15 = buffer_ptr(& ch->output);
#line 488
        len = write(ch->sock, (void const   *)tmp___15, tmp___14);
#line 490
        if (len <= 0) {
#line 491
          if (compat13) {
#line 492
            tmp___16 = buffer_len(& ch->output);
#line 492
            buffer_consume(& ch->output, tmp___16);
#line 493
            debug("Channel %d status set to input draining.", i);
#line 494
            ch->type = 10;
          } else {
#line 496
            chan_write_failed(ch);
          }
#line 498
          break;
        }
#line 500
        buffer_consume(& ch->output, (unsigned int )len);
      }
    }
#line 502
    break;
    case 11: 
#line 505
    if (! compat13) {
#line 506
      fatal("cannot happen: OUT_DRAIN");
    }
#line 508
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___4): "r" ((unsigned int )ch->sock % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )ch->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 508
    if (__result___4) {
#line 508
      tmp___21 = buffer_len(& ch->output);
#line 508
      if (tmp___21 > 0U) {
#line 509
        tmp___18 = buffer_len(& ch->output);
#line 509
        tmp___19 = buffer_ptr(& ch->output);
#line 509
        len = write(ch->sock, (void const   *)tmp___19, tmp___18);
#line 511
        if (len <= 0) {
#line 512
          tmp___20 = buffer_len(& ch->output);
#line 512
          buffer_consume(& ch->output, tmp___20);
        } else {
#line 514
          buffer_consume(& ch->output, (unsigned int )len);
        }
      }
    }
#line 516
    break;
    case 9: 
    case 0: 
    default: ;
    goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 383
    i ++;
  }
#line 524
  return;
}
}
#line 528 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *ch ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 534
  i = 0;
#line 534
  while (i < channels_alloc) {
#line 535
    ch = channels + i;
#line 538
    if (compat13) {
#line 539
      if (ch->type != 4) {
#line 539
        if (ch->type != 10) {
          goto __Cont;
        }
      }
    } else {
#line 543
      if (ch->type != 4) {
        goto __Cont;
      }
#line 545
      if (ch->istate != 1) {
#line 545
        if (ch->istate != 2) {
          goto __Cont;
        }
      }
    }
#line 551
    tmp = buffer_len(& ch->input);
#line 551
    len = (int )tmp;
#line 552
    if (len > 0) {
#line 554
      tmp___0 = packet_is_interactive();
#line 554
      if (tmp___0) {
#line 555
        if (len > 1024) {
#line 556
          len = 512;
        }
      } else {
#line 559
        if (len > max_packet_size / 2) {
#line 560
          len = max_packet_size / 2;
        }
      }
#line 562
      packet_start(23);
#line 563
      packet_put_int((unsigned int )ch->remote_id);
#line 564
      tmp___1 = buffer_ptr(& ch->input);
#line 564
      packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 565
      packet_send();
#line 566
      buffer_consume(& ch->input, (unsigned int )len);
    } else {
#line 567
      if (ch->istate == 2) {
#line 568
        if (compat13) {
#line 569
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 574
        chan_ibuf_empty(ch);
      }
    }
    __Cont: /* CIL Label */ 
#line 534
    i ++;
  }
#line 577
  return;
}
}
#line 585 "channels.c"
void channel_input_data(int payload_len ) 
{ int id ;
  char *data ;
  unsigned int data_len ;
  Channel *ch ;
  unsigned int tmp ;
  int _p ;
  int _e ;

  {
#line 594
  tmp = packet_get_int();
#line 594
  id = (int )tmp;
#line 595
  if (id < 0) {
#line 596
    packet_disconnect("Received data for nonexistent channel %d.", id);
  } else {
#line 595
    if (id >= channels_alloc) {
#line 596
      packet_disconnect("Received data for nonexistent channel %d.", id);
    }
  }
#line 597
  ch = channels + id;
#line 599
  if (ch->type == 0) {
#line 600
    packet_disconnect("Received data for free channel %d.", ch->self);
  }
#line 603
  if (ch->type != 4) {
#line 603
    if (ch->type != 9) {
#line 605
      return;
    }
  }
#line 608
  if (! compat13) {
#line 608
    if (ch->ostate != 16) {
#line 609
      return;
    }
  }
#line 612
  data = packet_get_string(& data_len);
#line 613
  while (1) {
#line 613
    _p = payload_len;
#line 613
    _e = (int )(8U + data_len);
#line 613
    if (_p != _e) {
#line 613
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 613);
#line 613
      packet_disconnect("Packet integrity error. (%d)", 23);
    }
#line 613
    break;
  }
#line 614
  buffer_append(& ch->output, (char const   *)data, data_len);
#line 615
  xfree((void *)data);
#line 616
  return;
}
}
#line 623 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *ch ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 629
  i = 0U;
#line 629
  while (i < (unsigned int )channels_alloc) {
#line 630
    ch = channels + i;
#line 631
    if (ch->type == 4) {
#line 632
      tmp = buffer_len(& ch->input);
#line 632
      if (tmp > (unsigned int )max_packet_size) {
#line 633
        return (0);
      }
#line 634
      tmp___0 = buffer_len(& ch->output);
#line 634
      if (tmp___0 > (unsigned int )max_packet_size) {
#line 635
        return (0);
      }
    }
#line 629
    i ++;
  }
#line 638
  return (1);
}
}
#line 643 "channels.c"
void channel_input_close(void) 
{ int channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 649
  tmp = packet_get_int();
#line 649
  channel = (int )tmp;
#line 650
  if (channel < 0) {
#line 652
    packet_disconnect("Received data for nonexistent channel %d.", channel);
  } else {
#line 650
    if (channel >= channels_alloc) {
#line 652
      packet_disconnect("Received data for nonexistent channel %d.", channel);
    } else {
#line 650
      if ((channels + channel)->type == 0) {
#line 652
        packet_disconnect("Received data for nonexistent channel %d.", channel);
      }
    }
  }
#line 654
  if (! compat13) {
#line 656
    chan_rcvd_ieof(channels + channel);
#line 657
    return;
  }
#line 664
  packet_start(25);
#line 665
  packet_put_int((unsigned int )(channels + channel)->remote_id);
#line 666
  packet_send();
#line 675
  if ((channels + channel)->type != 5) {
#line 680
    tmp___0 = buffer_len(& (channels + channel)->input);
#line 680
    buffer_consume(& (channels + channel)->input, tmp___0);
#line 682
    (channels + channel)->type = 11;
  }
#line 684
  return;
}
}
#line 688 "channels.c"
void channel_input_close_confirmation(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 694
  tmp = packet_get_int();
#line 694
  channel = (int )tmp;
#line 695
  if (channel < 0) {
#line 696
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      channel);
  } else {
#line 695
    if (channel >= channels_alloc) {
#line 696
      packet_disconnect("Received close confirmation for out-of-range channel %d.",
                        channel);
    }
  }
#line 699
  if (! compat13) {
#line 701
    chan_rcvd_oclose(channels + channel);
#line 702
    return;
  }
#line 704
  if ((channels + channel)->type != 5) {
#line 705
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      channel, (channels + channel)->type);
  }
#line 709
  channel_free(channel);
#line 710
  return;
}
}
#line 714 "channels.c"
void channel_input_open_confirmation(void) 
{ int channel ;
  int remote_channel ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 720
  tmp = packet_get_int();
#line 720
  channel = (int )tmp;
#line 721
  if (channel < 0) {
#line 723
    packet_disconnect("Received open confirmation for non-opening channel %d.", channel);
  } else {
#line 721
    if (channel >= channels_alloc) {
#line 723
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        channel);
    } else {
#line 721
      if ((channels + channel)->type != 3) {
#line 723
        packet_disconnect("Received open confirmation for non-opening channel %d.",
                          channel);
      }
    }
  }
#line 727
  tmp___0 = packet_get_int();
#line 727
  remote_channel = (int )tmp___0;
#line 730
  (channels + channel)->remote_id = remote_channel;
#line 731
  (channels + channel)->type = 4;
#line 732
  return;
}
}
#line 736 "channels.c"
void channel_input_open_failure(void) 
{ int channel ;
  unsigned int tmp ;

  {
#line 742
  tmp = packet_get_int();
#line 742
  channel = (int )tmp;
#line 743
  if (channel < 0) {
#line 745
    packet_disconnect("Received open failure for non-opening channel %d.", channel);
  } else {
#line 743
    if (channel >= channels_alloc) {
#line 745
      packet_disconnect("Received open failure for non-opening channel %d.", channel);
    } else {
#line 743
      if ((channels + channel)->type != 3) {
#line 745
        packet_disconnect("Received open failure for non-opening channel %d.", channel);
      }
    }
  }
#line 749
  channel_free(channel);
#line 750
  return;
}
}
#line 757 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 761
  i = 0;
#line 761
  while (i < channels_alloc) {
#line 762
    switch ((channels + i)->type) {
    case 7: 
#line 764
    close((channels + i)->sock);
#line 765
    remove((char const   *)((channels + i)->path));
#line 766
    channel_free(i);
#line 767
    break;
    case 2: 
    case 1: 
#line 770
    close((channels + i)->sock);
#line 771
    channel_free(i);
#line 772
    break;
    default: ;
#line 774
    break;
    }
#line 761
    i ++;
  }
#line 777
  return;
}
}
#line 784 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 788
  i = 0;
#line 788
  while (i < channels_alloc) {
#line 789
    if ((channels + i)->type != 0) {
#line 790
      close((channels + i)->sock);
    }
#line 788
    i ++;
  }
#line 792
  return;
}
}
#line 796 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 799
  return (channel_max_fd_value);
}
}
#line 804 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 808
  i = 0U;
#line 808
  while (i < (unsigned int )channels_alloc) {
#line 809
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
#line 819
    return (1);
    case 10: 
    case 11: 
#line 822
    if (! compat13) {
#line 823
      fatal("cannot happen: OUT_DRAIN");
    }
#line 824
    return (1);
    default: 
#line 826
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 808
    i ++;
  }
#line 829
  return (0);
}
}
#line 838 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___0[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 845
  buffer_init(& buffer);
#line 846
  snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"The following connections are open:\r\n");
#line 847
  tmp = strlen((char const   *)(buf___0));
#line 847
  buffer_append(& buffer, (char const   *)(buf___0), tmp);
#line 848
  i = 0;
#line 848
  while (i < channels_alloc) {
#line 849
    c = channels + i;
#line 850
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 7: 
    goto __Cont;
    case 3: 
    case 4: 
    case 9: 
    case 10: 
    case 11: 
#line 862
    tmp___0 = buffer_len(& c->output);
#line 862
    tmp___1 = buffer_len(& c->input);
#line 862
    snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0);
#line 867
    tmp___2 = strlen((char const   *)(buf___0));
#line 867
    buffer_append(& buffer, (char const   *)(buf___0), tmp___2);
    goto __Cont;
    default: 
#line 870
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 848
    i ++;
  }
#line 874
  buffer_append(& buffer, "\000", 1U);
#line 875
  tmp___3 = buffer_ptr(& buffer);
#line 875
  cp = xstrdup((char const   *)tmp___3);
#line 876
  buffer_free(& buffer);
#line 877
  return (cp);
}
}
#line 885 "channels.c"
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 889
  on = 1;
#line 894
  tmp = strlen(host);
#line 894
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 895
    packet_disconnect("Forward host name too long.");
  }
#line 901
  memset((void *)(& hints), 0, sizeof(hints));
#line 902
  hints.ai_family = IPv4or6;
#line 903
  if (gateway_ports) {
#line 903
    hints.ai_flags = 1;
  } else {
#line 903
    hints.ai_flags = 0;
  }
#line 904
  hints.ai_socktype = 1;
#line 905
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 906
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 906
  if (tmp___0 != 0) {
#line 907
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 909
  success = 0;
#line 910
  ai = aitop;
#line 910
  while (ai) {
#line 911
    if (ai->ai_family != 2) {
#line 911
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 913
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 913
    if (tmp___1 != 0) {
#line 915
      error("channel_request_local_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 919
    sock = socket(ai->ai_family, 1, 0);
#line 920
    if (sock < 0) {
#line 922
      tmp___2 = __errno_location();
#line 922
      tmp___3 = strerror(*tmp___2);
#line 922
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 929
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 930
    linger.l_onoff = 1;
#line 931
    linger.l_linger = 5;
#line 932
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 933
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 936
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 936
    if (tmp___8 < 0) {
#line 938
      if (! ai->ai_next) {
#line 939
        tmp___4 = __errno_location();
#line 939
        tmp___5 = strerror(*tmp___4);
#line 939
        error("bind: %.100s", tmp___5);
      } else {
#line 941
        tmp___6 = __errno_location();
#line 941
        tmp___7 = strerror(*tmp___6);
#line 941
        verbose("bind: %.100s", tmp___7);
      }
#line 943
      close(sock);
      goto __Cont;
    }
#line 947
    tmp___11 = listen(sock, 5);
#line 947
    if (tmp___11 < 0) {
#line 948
      tmp___9 = __errno_location();
#line 948
      tmp___10 = strerror(*tmp___9);
#line 948
      error("listen: %.100s", tmp___10);
#line 949
      close(sock);
      goto __Cont;
    }
#line 953
    tmp___12 = xstrdup("port listener");
#line 953
    ch = channel_allocate(2, sock, tmp___12);
#line 955
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 956
    (channels + ch)->host_port = (int )host_port;
#line 957
    (channels + ch)->listening_port = (int )port;
#line 958
    success = 1;
    __Cont: /* CIL Label */ 
#line 910
    ai = ai->ai_next;
  }
#line 960
  if (success == 0) {
#line 961
    packet_disconnect("cannot listen port: %d", port);
  }
#line 962
  freeaddrinfo(aitop);
#line 963
  return;
}
}
#line 970 "channels.c"
void channel_request_remote_forwarding(u_short port , char const   *host , u_short remote_port ) 
{ int payload_len ;
  size_t tmp ;

  {
#line 976
  if (num_permitted_opens >= 100) {
#line 977
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 979
  permitted_opens[num_permitted_opens].host = xstrdup(host);
#line 980
  permitted_opens[num_permitted_opens].port = remote_port;
#line 981
  num_permitted_opens ++;
#line 984
  packet_start(28);
#line 985
  packet_put_int((unsigned int )port);
#line 986
  tmp = strlen(host);
#line 986
  packet_put_string(host, tmp);
#line 987
  packet_put_int((unsigned int )remote_port);
#line 988
  packet_send();
#line 989
  packet_write_wait();
#line 995
  packet_read_expect(& payload_len, 14);
#line 996
  return;
}
}
#line 1004 "channels.c"
void channel_input_port_forward_request(int is_root ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1011
  tmp = packet_get_int();
#line 1011
  port = (unsigned short )tmp;
#line 1012
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 1013
  tmp___0 = packet_get_int();
#line 1013
  host_port = (unsigned short )tmp___0;
#line 1019
  if ((int )port < 1024) {
#line 1019
    if (! is_root) {
#line 1020
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1026
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, 0);
#line 1029
  xfree((void *)hostname);
#line 1030
  return;
}
}
#line 1038 "channels.c"
void channel_input_port_open(int payload_len ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  u_short host_port ;
  char *host ;
  char *originator_string ;
  unsigned int host_len ;
  unsigned int originator_len ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
#line 1041
  sock = 0;
#line 1050
  tmp = packet_get_int();
#line 1050
  remote_channel = (int )tmp;
#line 1053
  host = packet_get_string(& host_len);
#line 1056
  tmp___0 = packet_get_int();
#line 1056
  host_port = (unsigned short )tmp___0;
#line 1059
  if (have_hostname_in_open) {
#line 1060
    originator_string = packet_get_string(& originator_len);
#line 1061
    originator_len += 4U;
  } else {
#line 1063
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1064
    originator_len = 0U;
  }
#line 1067
  while (1) {
#line 1067
    _p = payload_len;
#line 1067
    _e = (int )(((8U + host_len) + 4U) + originator_len);
#line 1067
    if (_p != _e) {
#line 1067
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1069);
#line 1067
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1067
    break;
  }
#line 1072
  if (! all_opens_permitted) {
#line 1074
    i = 0;
#line 1074
    while (i < num_permitted_opens) {
#line 1076
      if ((int )permitted_opens[i].port == (int )host_port) {
#line 1076
        if (0) {
#line 1076
          __s1_len = strlen((char const   *)permitted_opens[i].host);
#line 1076
          __s2_len = strlen((char const   *)host);
#line 1076
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host + 1)) - (unsigned int )((void const   *)permitted_opens[i].host) == 1U)) {
            goto _L___0;
          } else {
#line 1076
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1076
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1076
                tmp___10 = 1;
              } else {
#line 1076
                if (__s2_len >= 4U) {
#line 1076
                  tmp___10 = 1;
                } else {
#line 1076
                  tmp___10 = 0;
                }
              }
            } else {
#line 1076
              tmp___10 = 0;
            }
          }
#line 1076
          if (tmp___10) {
#line 1076
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
          } else {
#line 1076
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 1076
            tmp___6 = tmp___9;
          }
        } else {
#line 1076
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host, (char const   *)host);
#line 1076
          tmp___6 = tmp___9;
        }
#line 1076
        if (tmp___6 == 0) {
#line 1077
          break;
        }
      }
#line 1074
      i ++;
    }
#line 1080
    if (i >= num_permitted_opens) {
#line 1082
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1084
      packet_start(22);
#line 1085
      packet_put_int((unsigned int )remote_channel);
#line 1086
      packet_send();
    }
  }
#line 1090
  memset((void *)(& hints), 0, sizeof(hints));
#line 1091
  hints.ai_family = IPv4or6;
#line 1092
  hints.ai_socktype = 1;
#line 1093
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           host_port);
#line 1094
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1094
  if (gaierr != 0) {
#line 1095
    tmp___11 = gai_strerror(gaierr);
#line 1095
    error("%.100s: unknown host (%s)", host, tmp___11);
    goto fail;
  }
#line 1099
  ai = aitop;
#line 1099
  while (ai) {
#line 1100
    if (ai->ai_family != 2) {
#line 1100
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1102
    tmp___12 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                           sizeof(strport), 3U);
#line 1102
    if (tmp___12 != 0) {
#line 1104
      error("channel_input_port_open: getnameinfo failed");
      goto __Cont;
    }
#line 1108
    sock = socket(ai->ai_family, 1, 0);
#line 1109
    if (sock < 0) {
#line 1110
      tmp___13 = __errno_location();
#line 1110
      tmp___14 = strerror(*tmp___13);
#line 1110
      error("socket: %.100s", tmp___14);
      goto __Cont;
    }
#line 1114
    tmp___17 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1114
    if (tmp___17 < 0) {
#line 1115
      tmp___15 = __errno_location();
#line 1115
      tmp___16 = strerror(*tmp___15);
#line 1115
      error("connect %.100s port %s: %.100s", ntop, strport, tmp___16);
#line 1117
      close(sock);
      goto __Cont;
    }
#line 1120
    break;
    __Cont: /* CIL Label */ 
#line 1099
    ai = ai->ai_next;
  }
#line 1123
  freeaddrinfo(aitop);
#line 1125
  if (! ai) {
#line 1126
    error("connect %.100s port %d: failed.", host, host_port);
    goto fail;
  }
#line 1133
  newch = channel_allocate(4, sock, originator_string);
#line 1134
  (channels + newch)->remote_id = remote_channel;
#line 1137
  packet_start(21);
#line 1138
  packet_put_int((unsigned int )remote_channel);
#line 1139
  packet_put_int((unsigned int )newch);
#line 1140
  packet_send();
#line 1143
  xfree((void *)host);
#line 1145
  return;
  fail: 
#line 1149
  xfree((void *)host);
#line 1152
  packet_start(22);
#line 1153
  packet_put_int((unsigned int )remote_channel);
#line 1154
  packet_send();
#line 1155
  return;
}
}
#line 1165 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1172
  num_socks = 0;
#line 1176
  display_number = x11_display_offset;
#line 1176
  while (display_number < 1000) {
#line 1179
    port = (unsigned short )(6000 + display_number);
#line 1180
    memset((void *)(& hints), 0, sizeof(hints));
#line 1181
    hints.ai_family = IPv4or6;
#line 1182
    hints.ai_flags = 1;
#line 1183
    hints.ai_socktype = 1;
#line 1184
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 1185
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1185
    if (gaierr != 0) {
#line 1186
      tmp = gai_strerror(gaierr);
#line 1186
      error("getaddrinfo: %.100s", tmp);
#line 1187
      return ((char *)((void *)0));
    }
#line 1189
    ai = aitop;
#line 1189
    while (ai) {
#line 1190
      if (ai->ai_family != 2) {
#line 1190
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 1192
      sock = socket(ai->ai_family, 1, 0);
#line 1193
      if (sock < 0) {
#line 1194
        tmp___2 = __errno_location();
#line 1194
        if (*tmp___2 != 22) {
#line 1195
          tmp___0 = __errno_location();
#line 1195
          tmp___1 = strerror(*tmp___0);
#line 1195
          error("socket: %.100s", tmp___1);
#line 1196
          return ((char *)((void *)0));
        } else {
#line 1198
          debug("Socket family %d not supported [X11 disp create]", ai->ai_family);
          goto __Cont;
        }
      }
#line 1202
      tmp___5 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1202
      if (tmp___5 < 0) {
#line 1203
        tmp___3 = __errno_location();
#line 1203
        tmp___4 = strerror(*tmp___3);
#line 1203
        debug("bind port %d: %.100s", port, tmp___4);
#line 1204
        shutdown(sock, 2);
#line 1205
        close(sock);
#line 1207
        if (ai->ai_next) {
          goto __Cont;
        }
#line 1210
        n___0 = 0;
#line 1210
        while (n___0 < num_socks) {
#line 1211
          shutdown(socks[n___0], 2);
#line 1212
          close(socks[n___0]);
#line 1210
          n___0 ++;
        }
#line 1214
        num_socks = 0;
#line 1215
        break;
      }
#line 1217
      tmp___6 = num_socks;
#line 1217
      num_socks ++;
#line 1217
      socks[tmp___6] = sock;
#line 1222
      break;
      __Cont: /* CIL Label */ 
#line 1189
      ai = ai->ai_next;
    }
#line 1225
    if (num_socks > 0) {
#line 1226
      break;
    }
#line 1176
    display_number ++;
  }
#line 1228
  if (display_number >= 1000) {
#line 1229
    error("Failed to allocate internet-domain X11 display socket.");
#line 1230
    return ((char *)((void *)0));
  }
#line 1233
  n___0 = 0;
#line 1233
  while (n___0 < num_socks) {
#line 1234
    sock = socks[n___0];
#line 1235
    tmp___9 = listen(sock, 5);
#line 1235
    if (tmp___9 < 0) {
#line 1236
      tmp___7 = __errno_location();
#line 1236
      tmp___8 = strerror(*tmp___7);
#line 1236
      error("listen: %.100s", tmp___8);
#line 1237
      shutdown(sock, 2);
#line 1238
      close(sock);
#line 1239
      return ((char *)((void *)0));
    }
#line 1233
    n___0 ++;
  }
#line 1245
  tmp___12 = gethostname(hostname, sizeof(hostname));
#line 1245
  if (tmp___12 < 0) {
#line 1246
    tmp___10 = __errno_location();
#line 1246
    tmp___11 = strerror(*tmp___10);
#line 1246
    fatal("gethostname: %.100s", tmp___11);
  }
#line 1283
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1288
  n___0 = 0;
#line 1288
  while (n___0 < num_socks) {
#line 1289
    sock = socks[n___0];
#line 1290
    tmp___13 = xstrdup("X11 inet listener");
#line 1290
    channel_allocate(1, sock, tmp___13);
#line 1288
    n___0 ++;
  }
#line 1295
  tmp___14 = xstrdup((char const   *)(display));
#line 1295
  return (tmp___14);
}
}
#line 1306
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1306 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1302 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1316
  path = x_sockets;
#line 1316
  while (*path) {
#line 1317
    sock = socket(1, 1, 0);
#line 1318
    if (sock < 0) {
#line 1319
      tmp = __errno_location();
#line 1319
      tmp___0 = strerror(*tmp);
#line 1319
      error("socket: %.100s", tmp___0);
    }
#line 1320
    memset((void *)(& addr), 0, sizeof(addr));
#line 1321
    addr.sun_family = (unsigned short)1;
#line 1322
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1323
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1323
    if (tmp___1 == 0) {
#line 1324
      return (sock);
    }
#line 1325
    close(sock);
#line 1316
    path ++;
  }
#line 1327
  tmp___2 = __errno_location();
#line 1327
  tmp___3 = strerror(*tmp___2);
#line 1327
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1328
  return (-1);
}
}
#line 1338 "channels.c"
void x11_input_open(int payload_len ) 
{ int remote_channel ;
  int display_number ;
  int sock ;
  int newch ;
  char const   *display ;
  char buf___0[1024] ;
  char *cp ;
  char *remote_host ;
  unsigned int remote_len ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;

  {
#line 1341
  sock = 0;
#line 1350
  tmp = packet_get_int();
#line 1350
  remote_channel = (int )tmp;
#line 1353
  if (have_hostname_in_open) {
#line 1354
    remote_host = packet_get_string(& remote_len);
#line 1355
    remote_len += 4U;
  } else {
#line 1357
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 1358
    remote_len = 0U;
  }
#line 1361
  debug("Received X11 open request.");
#line 1362
  while (1) {
#line 1362
    _p = payload_len;
#line 1362
    _e = (int )(4U + remote_len);
#line 1362
    if (_p != _e) {
#line 1362
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1362);
#line 1362
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 1362
    break;
  }
#line 1365
  tmp___0 = getenv("DISPLAY");
#line 1365
  display = (char const   *)tmp___0;
#line 1366
  if (! display) {
#line 1367
    error("DISPLAY not set.");
    goto fail;
  }
#line 1379
  if (0) {
#line 1379
    if (0) {
#line 1379
      __s1_len___0 = strlen(display);
#line 1379
      __s2_len___0 = strlen("unix:");
#line 1379
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1379
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1379
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1379
            tmp___26 = 1;
          } else {
#line 1379
            if (__s2_len___0 >= 4U) {
#line 1379
              tmp___26 = 1;
            } else {
#line 1379
              tmp___26 = 0;
            }
          }
        } else {
#line 1379
          tmp___26 = 0;
        }
      }
#line 1379
      if (tmp___26) {
#line 1379
        tmp___22 = __builtin_strcmp(display, "unix:");
      } else {
#line 1379
        tmp___25 = __builtin_strcmp(display, "unix:");
#line 1379
        tmp___22 = tmp___25;
      }
    } else {
#line 1379
      tmp___25 = __builtin_strcmp(display, "unix:");
#line 1379
      tmp___22 = tmp___25;
    }
#line 1379
    tmp___16 = tmp___22;
  } else {
#line 1379
    tmp___16 = strncmp(display, "unix:", 5U);
  }
#line 1379
  if (tmp___16 == 0) {
    goto _L___3;
  } else {
#line 1379
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1382
      tmp___1 = strrchr(display, ':');
#line 1382
      tmp___2 = sscanf((char const   * __restrict  )(tmp___1 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1382
      if (tmp___2 != 1) {
#line 1383
        error("Could not parse display number from DISPLAY: %.100s", display);
        goto fail;
      }
#line 1388
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1389
      if (sock < 0) {
        goto fail;
      }
      goto success;
    }
  }
#line 1399
  __builtin_strncpy(buf___0, display, sizeof(buf___0));
#line 1400
  buf___0[sizeof(buf___0) - 1U] = (char)0;
#line 1401
  tmp___30 = __builtin_strchr(buf___0, ':');
#line 1401
  cp = tmp___30;
#line 1402
  if (! cp) {
#line 1403
    error("Could not find \':\' in DISPLAY: %.100s", display);
    goto fail;
  }
#line 1406
  *cp = (char)0;
#line 1408
  tmp___31 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1408
  if (tmp___31 != 1) {
#line 1409
    error("Could not parse display number from DISPLAY: %.100s", display);
    goto fail;
  }
#line 1415
  memset((void *)(& hints), 0, sizeof(hints));
#line 1416
  hints.ai_family = IPv4or6;
#line 1417
  hints.ai_socktype = 1;
#line 1418
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 1419
  gaierr = getaddrinfo((char const   * __restrict  )(buf___0), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1419
  if (gaierr != 0) {
#line 1420
    tmp___32 = gai_strerror(gaierr);
#line 1420
    error("%.100s: unknown host. (%s)", buf___0, tmp___32);
    goto fail;
  }
#line 1423
  ai = aitop;
#line 1423
  while (ai) {
#line 1425
    sock = socket(ai->ai_family, 1, 0);
#line 1426
    if (sock < 0) {
#line 1427
      tmp___33 = __errno_location();
#line 1427
      tmp___34 = strerror(*tmp___33);
#line 1427
      debug("socket: %.100s", tmp___34);
      goto __Cont;
    }
#line 1431
    tmp___37 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1431
    if (tmp___37 < 0) {
#line 1432
      tmp___35 = __errno_location();
#line 1432
      tmp___36 = strerror(*tmp___35);
#line 1432
      debug("connect %.100s port %d: %.100s", buf___0, 6000 + display_number, tmp___36);
#line 1434
      close(sock);
      goto __Cont;
    }
#line 1438
    break;
    __Cont: /* CIL Label */ 
#line 1423
    ai = ai->ai_next;
  }
#line 1441
  freeaddrinfo(aitop);
#line 1442
  if (! ai) {
#line 1443
    tmp___38 = __errno_location();
#line 1443
    tmp___39 = strerror(*tmp___38);
#line 1443
    error("connect %.100s port %d: %.100s", buf___0, 6000 + display_number, tmp___39);
    goto fail;
  }
  success: 
#line 1451
  if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 1452
    newch = channel_allocate(4, sock, remote_host);
  } else {
#line 1454
    newch = channel_allocate(9, sock, remote_host);
  }
#line 1455
  (channels + newch)->remote_id = remote_channel;
#line 1458
  packet_start(21);
#line 1459
  packet_put_int((unsigned int )remote_channel);
#line 1460
  packet_put_int((unsigned int )newch);
#line 1461
  packet_send();
#line 1463
  return;
  fail: 
#line 1467
  packet_start(22);
#line 1468
  packet_put_int((unsigned int )remote_channel);
#line 1469
  packet_send();
#line 1470
  return;
}
}
#line 1477 "channels.c"
void x11_request_forwarding_with_spoofing(char const   *proto , char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 1480
  tmp = strlen(data);
#line 1480
  data_len = tmp / 2U;
#line 1485
  rand___0 = (u_int32_t )0;
#line 1487
  tmp___0 = getenv("DISPLAY");
#line 1487
  cp = (char const   *)tmp___0;
#line 1488
  if (cp) {
#line 1489
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 1489
    cp = (char const   *)tmp___2;
  }
#line 1490
  if (cp) {
#line 1491
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 1491
    cp = (char const   *)tmp___4;
  }
#line 1492
  if (cp) {
#line 1493
    screen_number = atoi(cp + 1);
  } else {
#line 1495
    screen_number = 0;
  }
#line 1498
  x11_saved_proto = xstrdup(proto);
#line 1504
  tmp___5 = xmalloc(data_len);
#line 1504
  x11_saved_data = (char *)tmp___5;
#line 1505
  tmp___6 = xmalloc(data_len);
#line 1505
  x11_fake_data = (char *)tmp___6;
#line 1506
  i = 0U;
#line 1506
  while (i < data_len) {
#line 1507
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 1507
    if (tmp___7 != 1) {
#line 1508
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 1509
    if (i % 4U == 0U) {
#line 1510
      rand___0 = arc4random();
    }
#line 1511
    *(x11_saved_data + i) = (char )value;
#line 1512
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 1513
    rand___0 >>= 8;
#line 1506
    i ++;
  }
#line 1515
  x11_saved_data_len = data_len;
#line 1516
  x11_fake_data_len = data_len;
#line 1519
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 1519
  new_data = (char *)tmp___8;
#line 1520
  i = 0U;
#line 1520
  while (i < data_len) {
#line 1521
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 1520
    i ++;
  }
#line 1524
  packet_start(34);
#line 1525
  tmp___9 = strlen(proto);
#line 1525
  packet_put_string(proto, tmp___9);
#line 1526
  tmp___10 = strlen((char const   *)new_data);
#line 1526
  packet_put_string((char const   *)new_data, tmp___10);
#line 1527
  packet_put_int((unsigned int )screen_number);
#line 1528
  packet_send();
#line 1529
  packet_write_wait();
#line 1530
  xfree((void *)new_data);
#line 1531
  return;
}
}
#line 1535 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 1538
  packet_start(30);
#line 1539
  packet_send();
#line 1540
  packet_write_wait();
#line 1541
  return;
}
}
#line 1549 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 1552
  return (channel_forwarded_auth_socket_name);
}
}
#line 1557 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 1560
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 1561
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 1562
  return;
}
}
#line 1569 "channels.c"
void auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 1575
  tmp = auth_get_socket_name();
#line 1575
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 1576
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 1579
  temporarily_use_uid(pw->pw_uid);
#line 1582
  tmp___0 = xmalloc(100U);
#line 1582
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 1583
  tmp___1 = xmalloc(100U);
#line 1583
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 1584
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 1587
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 1587
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 1588
    tmp___2 = __errno_location();
#line 1588
    tmp___3 = strerror(*tmp___2);
#line 1588
    packet_disconnect("mkdtemp: %.100s", tmp___3);
  }
#line 1589
  tmp___5 = getpid();
#line 1589
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 1592
  tmp___8 = atexit(& cleanup_socket);
#line 1592
  if (tmp___8 < 0) {
#line 1593
    tmp___6 = __errno_location();
#line 1593
    saved = *tmp___6;
#line 1594
    cleanup_socket();
#line 1595
    tmp___7 = strerror(saved);
#line 1595
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 1598
  sock = socket(1, 1, 0);
#line 1599
  if (sock < 0) {
#line 1600
    tmp___9 = __errno_location();
#line 1600
    tmp___10 = strerror(*tmp___9);
#line 1600
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 1603
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 1604
  sunaddr.sun_family = (unsigned short)1;
#line 1605
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 1608
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 1608
  if (tmp___13 < 0) {
#line 1609
    tmp___11 = __errno_location();
#line 1609
    tmp___12 = strerror(*tmp___11);
#line 1609
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 1612
  restore_uid();
#line 1615
  tmp___16 = listen(sock, 5);
#line 1615
  if (tmp___16 < 0) {
#line 1616
    tmp___14 = __errno_location();
#line 1616
    tmp___15 = strerror(*tmp___14);
#line 1616
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 1619
  tmp___17 = xstrdup("auth socket");
#line 1619
  newch = channel_allocate(7, sock, tmp___17);
#line 1621
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 1623
  return;
}
}
#line 1627 "channels.c"
void auth_input_open_request(void) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  unsigned int tmp ;

  {
#line 1634
  tmp = packet_get_int();
#line 1634
  remch = (int )tmp;
#line 1640
  sock = ssh_get_authentication_socket();
#line 1648
  if (sock < 0) {
#line 1649
    packet_start(22);
#line 1650
    packet_put_int((unsigned int )remch);
#line 1651
    packet_send();
#line 1652
    return;
  }
#line 1654
  debug("Forwarding authentication connection.");
#line 1661
  dummyname = xstrdup("authentication agent connection");
#line 1663
  newch = channel_allocate(4, sock, dummyname);
#line 1664
  (channels + newch)->remote_id = remch;
#line 1667
  packet_start(21);
#line 1668
  packet_put_int((unsigned int )remch);
#line 1669
  packet_put_int((unsigned int )newch);
#line 1670
  packet_send();
#line 1671
  return;
}
}
#line 1 "cipher.o"
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 71 "cipher.h"
int cipher_number(char const   *name ) ;
#line 77
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) ;
#line 103
void (*cipher_attack_detected)(char const   *fmt  , ...) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 40 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 49
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 51
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks1, & iv1, 1);
#line 52
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 54
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 0);
#line 55
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 57
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks3, iv3, 1);
#line 58
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 59
  return;
}
}
#line 61 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 70
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 72
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks3, iv3, 0);
#line 73
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 75
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 1);
#line 76
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 78
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks1, & iv1, 0);
#line 81
  return;
}
}
#line 87 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_74 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 91
  dst = (u_int32_t *)dst_;
#line 98
  n___0 /= 8;
#line 98
  while (n___0 > 0) {
#line 99
    tmp = src;
#line 99
    src ++;
#line 99
    t.c[3] = (char )*tmp;
#line 100
    tmp___0 = src;
#line 100
    src ++;
#line 100
    t.c[2] = (char )*tmp___0;
#line 101
    tmp___1 = src;
#line 101
    src ++;
#line 101
    t.c[1] = (char )*tmp___1;
#line 102
    tmp___2 = src;
#line 102
    src ++;
#line 102
    t.c[0] = (char )*tmp___2;
#line 103
    tmp___3 = dst;
#line 103
    dst ++;
#line 103
    *tmp___3 = t.i;
#line 105
    tmp___4 = src;
#line 105
    src ++;
#line 105
    t.c[3] = (char )*tmp___4;
#line 106
    tmp___5 = src;
#line 106
    src ++;
#line 106
    t.c[2] = (char )*tmp___5;
#line 107
    tmp___6 = src;
#line 107
    src ++;
#line 107
    t.c[1] = (char )*tmp___6;
#line 108
    tmp___7 = src;
#line 108
    src ++;
#line 108
    t.c[0] = (char )*tmp___7;
#line 109
    tmp___8 = dst;
#line 109
    dst ++;
#line 109
    *tmp___8 = t.i;
#line 98
    n___0 --;
  }
#line 111
  return;
}
}
#line 113 "cipher.c"
void (*cipher_attack_detected)(char const   *fmt  , ...)  =    (void (*)(char const   *fmt  , ...))(& fatal);
#line 115 "cipher.c"
__inline static void detect_cbc_attack(unsigned char const   *src , unsigned int len ) 
{ 

  {
#line 119
  return;
#line 121
  log("CRC-32 CBC insertion attack detected");
#line 122
  (*cipher_attack_detected)("CRC-32 CBC insertion attack detected");
}
}
#line 129 "cipher.c"
static char *cipher_names[7]  = {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish"};
#line 146 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int mask ;

  {
#line 149
  mask = 0U;
#line 150
  mask |= (unsigned int )(1 << 3);
#line 151
  mask |= (unsigned int )(1 << 6);
#line 152
  return (mask);
}
}
#line 157 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 160
  if (cipher < 0) {
#line 162
    fatal("cipher_name: bad cipher number: %d", cipher);
  } else {
#line 160
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 162
      fatal("cipher_name: bad cipher number: %d", cipher);
    } else {
#line 160
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 162
        fatal("cipher_name: bad cipher number: %d", cipher);
      }
    }
  }
#line 163
  return ((char const   *)cipher_names[cipher]);
}
}
#line 171 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 175
  i = 0;
#line 175
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 176
    if (0) {
#line 176
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 176
      __s2_len = strlen(name);
#line 176
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 176
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 176
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 176
            tmp___8 = 1;
          } else {
#line 176
            if (__s2_len >= 4U) {
#line 176
              tmp___8 = 1;
            } else {
#line 176
              tmp___8 = 0;
            }
          }
        } else {
#line 176
          tmp___8 = 0;
        }
      }
#line 176
      if (tmp___8) {
#line 176
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 176
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 176
        tmp___4 = tmp___7;
      }
    } else {
#line 176
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 176
      tmp___4 = tmp___7;
    }
#line 176
    if (tmp___4 == 0) {
#line 176
      tmp___9 = cipher_mask();
#line 176
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 178
        return (i);
      }
    }
#line 175
    i ++;
  }
#line 179
  return (-1);
}
}
#line 187 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ,
                           int for_encryption ) 
{ MD5_CTX md ;
  unsigned char digest[16] ;
  size_t tmp ;

  {
#line 194
  MD5_Init(& md);
#line 195
  tmp = strlen(passphrase);
#line 195
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 196
  MD5_Final(digest, & md);
#line 198
  cipher_set_key(context, cipher, (unsigned char const   *)(digest), 16, for_encryption);
#line 200
  memset((void *)(digest), 0, sizeof(digest));
#line 201
  memset((void *)(& md), 0, sizeof(md));
#line 202
  return;
}
}
#line 206 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen , int for_encryption ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;
  char const   *tmp___0 ;

  {
#line 213
  context->type = (unsigned int )cipher;
#line 217
  memset((void *)(padded), 0, sizeof(padded));
#line 218
  if ((unsigned int )keylen < sizeof(padded)) {
#line 218
    tmp = (unsigned int )keylen;
  } else {
#line 218
    tmp = sizeof(padded);
  }
#line 218
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 221
  switch (cipher) {
  case 0: 
#line 227
  break;
  case 3: 
#line 235
  if (keylen < 16) {
#line 236
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 237
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 238
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 239
  if (keylen <= 16) {
#line 240
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 242
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 243
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 244
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 245
  break;
  case 6: 
#line 248
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 249
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 250
  break;
  default: 
#line 253
  tmp___0 = cipher_name(cipher);
#line 253
  fatal("cipher_set_key: unknown cipher: %s", tmp___0);
  }
#line 255
  memset((void *)(padded), 0, sizeof(padded));
#line 256
  return;
}
}
#line 260 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 264
  if ((len & 7U) != 0U) {
#line 265
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 267
  switch ((int )context->type) {
  case 0: 
#line 269
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 270
  break;
  case 3: 
#line 273
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 277
  break;
  case 6: 
#line 280
  swap_bytes(src, dest, (int )len);
#line 281
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 284
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 285
  break;
  default: 
#line 288
  tmp = cipher_name((int )context->type);
#line 288
  fatal("cipher_encrypt: unknown cipher: %s", tmp);
  }
#line 290
  return;
}
}
#line 294 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 298
  if ((len & 7U) != 0U) {
#line 299
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 301
  switch ((int )context->type) {
  case 0: 
#line 303
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 304
  break;
  case 3: 
#line 308
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 312
  break;
  case 6: 
#line 315
  detect_cbc_attack(src, len);
#line 316
  swap_bytes(src, dest, (int )len);
#line 317
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 320
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 321
  break;
  default: 
#line 324
  tmp = cipher_name((int )context->type);
#line 324
  fatal("cipher_decrypt: unknown cipher: %s", tmp);
  }
#line 326
  return;
}
}
#line 1 "compat.o"
#line 35 "compat.c"
int compat13  =    0;
#line 37 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 40
  verbose("Enabling compatibility mode for protocol 1.3");
#line 41
  compat13 = 1;
#line 42
  return;
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 31 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 34
  debug("Enabling compression at level %d.", level);
#line 35
  if (level < 1) {
#line 36
    fatal("Bad compression level %d.", level);
  } else {
#line 35
    if (level > 9) {
#line 36
      fatal("Bad compression level %d.", level);
    }
  }
#line 37
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 38
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 39
  return;
}
}
#line 43 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 46
  if (outgoing_stream.total_in == 0UL) {
#line 46
    tmp = 0.0;
  } else {
#line 46
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 46
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 50
  if (incoming_stream.total_out == 0UL) {
#line 50
    tmp___0 = 0.0;
  } else {
#line 50
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 50
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 54
  inflateEnd(& incoming_stream);
#line 55
  deflateEnd(& outgoing_stream);
#line 56
  return;
}
}
#line 67 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___0[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 74
  tmp = buffer_len(input_buffer);
#line 74
  if (tmp == 0U) {
#line 75
    return;
  }
#line 78
  tmp___0 = buffer_ptr(input_buffer);
#line 78
  outgoing_stream.next_in = (unsigned char *)tmp___0;
#line 79
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 82
  while (1) {
#line 84
    outgoing_stream.next_out = (unsigned char *)(buf___0);
#line 85
    outgoing_stream.avail_out = sizeof(buf___0);
#line 88
    status = deflate(& outgoing_stream, 1);
#line 89
    switch (status) {
    case 0: 
#line 92
    buffer_append(output_buffer, (char const   *)(buf___0), sizeof(buf___0) - outgoing_stream.avail_out);
#line 94
    break;
    case 1: 
#line 96
    fatal("buffer_compress: deflate returned Z_STREAM_END");
    case -2: 
#line 99
    fatal("buffer_compress: deflate returned Z_STREAM_ERROR");
    case -5: 
#line 102
    fatal("buffer_compress: deflate returned Z_BUF_ERROR");
    default: 
#line 105
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 82
    if (! (outgoing_stream.avail_out == 0U)) {
#line 82
      break;
    }
  }
#line 110
  return;
}
}
#line 121 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___0[4096] ;
  int status ;
  char *tmp ;

  {
#line 127
  tmp = buffer_ptr(input_buffer);
#line 127
  incoming_stream.next_in = (unsigned char *)tmp;
#line 128
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 130
  incoming_stream.next_out = (unsigned char *)(buf___0);
#line 131
  incoming_stream.avail_out = sizeof(buf___0);
#line 133
  while (1) {
#line 134
    status = inflate(& incoming_stream, 1);
#line 135
    switch (status) {
    case 0: 
#line 137
    buffer_append(output_buffer, (char const   *)(buf___0), sizeof(buf___0) - incoming_stream.avail_out);
#line 139
    incoming_stream.next_out = (unsigned char *)(buf___0);
#line 140
    incoming_stream.avail_out = sizeof(buf___0);
#line 141
    break;
    case 1: 
#line 143
    fatal("buffer_uncompress: inflate returned Z_STREAM_END");
    case -3: 
#line 146
    fatal("buffer_uncompress: inflate returned Z_DATA_ERROR");
    case -2: 
#line 149
    fatal("buffer_uncompress: inflate returned Z_STREAM_ERROR");
    case -5: 
#line 157
    return;
    case -4: 
#line 159
    fatal("buffer_uncompress: inflate returned Z_MEM_ERROR");
    default: 
#line 162
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 25 "crc32.h"
unsigned int crc32(unsigned char const   *s , unsigned int len ) ;
#line 53 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 53 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 110 "crc32.c"
unsigned int crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 116
  crc32val = 0U;
#line 117
  i = 0U;
#line 117
  while (i < len) {
#line 118
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 117
    i ++;
  }
#line 120
  return (crc32val);
}
}
#line 1 "deattack.o"
#line 27 "deattack.h"
int detect_attack(unsigned char *buf___0 , u_int32_t len , unsigned char *IV ) ;
#line 49 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 52
  b ^= *a;
#line 53
  *a = crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 54
  return;
}
}
#line 57 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf___0 , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  crc = 0U;
#line 65
  if (IV) {
#line 65
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 65
    if (! tmp) {
#line 66
      crc_update(& crc, 1U);
#line 67
      crc_update(& crc, 0U);
    }
  }
#line 69
  c = buf___0;
#line 69
  while ((unsigned int )c < (unsigned int )(buf___0 + len)) {
#line 70
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 70
    if (tmp___0) {
#line 74
      crc_update(& crc, 0U);
#line 75
      crc_update(& crc, 0U);
    } else {
#line 71
      crc_update(& crc, 1U);
#line 72
      crc_update(& crc, 0U);
    }
#line 69
    c += 8;
  }
#line 78
  return (crc == 0U);
}
}
#line 86 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 87 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 83 "deattack.c"
int detect_attack(unsigned char *buf___0 , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (len > 262144U) {
#line 95
    fatal("detect_attack: bad length %d", len);
  } else {
#line 93
    if (len % 8U != 0U) {
#line 95
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 97
  l = (unsigned int )n;
#line 97
  while (l < ((len / 8U) * 3U) / 2U) {
#line 97
    l <<= 2;
  }
#line 100
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 101
    debug("Installing crc compensation attack detector.");
#line 102
    n = (unsigned short )l;
#line 103
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 103
    h = (u_int16_t *)tmp;
  } else {
#line 105
    if (l > (u_int32_t )n) {
#line 106
      n = (unsigned short )l;
#line 107
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 107
      h = (u_int16_t *)tmp___0;
    }
  }
#line 111
  if (len <= 56U) {
#line 112
    c = buf___0;
#line 112
    while ((unsigned int )c < (unsigned int )(buf___0 + len)) {
#line 113
      if (IV) {
#line 113
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 113
        if (! tmp___2) {
#line 114
          tmp___1 = check_crc(c, buf___0, len, (unsigned char *)IV);
#line 114
          if (tmp___1) {
#line 115
            return (1);
          } else {
#line 117
            break;
          }
        }
      }
#line 119
      d = buf___0;
#line 119
      while ((unsigned int )d < (unsigned int )c) {
#line 120
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 120
        if (! tmp___4) {
#line 121
          tmp___3 = check_crc(c, buf___0, len, (unsigned char *)IV);
#line 121
          if (tmp___3) {
#line 122
            return (1);
          } else {
#line 124
            break;
          }
        }
#line 119
        d += 8;
      }
#line 112
      c += 8;
    }
#line 128
    return (0);
  }
#line 130
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 132
  if (IV) {
#line 133
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 135
  c = buf___0;
#line 135
  j = 0U;
#line 135
  while ((unsigned int )c < (unsigned int )(buf___0 + len)) {
#line 136
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 136
    while ((int )*(h + i) != 65535) {
#line 138
      if ((int )*(h + i) == 65534) {
#line 139
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 139
        if (! tmp___6) {
#line 140
          tmp___5 = check_crc(c, buf___0, len, (unsigned char *)IV);
#line 140
          if (tmp___5) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
      } else {
#line 145
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___0 + (int )*(h + i) * 8),
                         8U);
#line 145
        if (! tmp___8) {
#line 146
          tmp___7 = check_crc(c, buf___0, len, (unsigned char *)IV);
#line 146
          if (tmp___7) {
#line 147
            return (1);
          } else {
#line 149
            break;
          }
        }
      }
#line 136
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 152
    *(h + i) = (unsigned short )j;
#line 135
    c += 8;
#line 135
    j ++;
  }
#line 154
  return (0);
}
}
#line 1 "fake-getaddrinfo.o"
#line 1 "fake-getnameinfo.o"
#line 1 "fingerprint.o"
#line 51 "fingerprint.c"
static char retval[80]  ;
#line 48 "fingerprint.c"
char *fingerprint(BIGNUM *e , BIGNUM *n___0 ) 
{ MD5_CTX md ;
  unsigned char d[16] ;
  unsigned char *buf___0 ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 57
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 57
  nlen = (tmp + 7) / 8;
#line 58
  tmp___0 = BN_num_bits((BIGNUM const   *)e);
#line 58
  elen = (tmp___0 + 7) / 8;
#line 60
  tmp___1 = xmalloc((unsigned int )(nlen + elen));
#line 60
  buf___0 = (unsigned char *)tmp___1;
#line 62
  BN_bn2bin((BIGNUM const   *)n___0, buf___0);
#line 63
  BN_bn2bin((BIGNUM const   *)e, buf___0 + nlen);
#line 65
  MD5_Init(& md);
#line 66
  MD5_Update(& md, (void const   *)buf___0, (unsigned int )(nlen + elen));
#line 67
  MD5_Final(d, & md);
#line 68
  snprintf((char * __restrict  )(retval), sizeof(retval), (char const   * __restrict  )"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
           d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11],
           d[12], d[13], d[14], d[15]);
#line 71
  memset((void *)buf___0, 0, (unsigned int )(nlen + elen));
#line 72
  xfree((void *)buf___0);
#line 73
  return (retval);
}
}
#line 1 "hostfile.o"
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 361 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 396
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 407
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                                  BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) ;
#line 415
int add_host_to_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                         BIGNUM *n___0 ) ;
#line 686
int match_pattern(char const   *s , char const   *pattern ) ;
#line 30 "hostfile.c"
int auth_rsa_read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 33
  cp = *cpp;
#line 37
  while (1) {
#line 37
    if (! ((int )*cp == 32)) {
#line 37
      if (! ((int )*cp == 9)) {
#line 37
        break;
      }
    }
#line 37
    cp ++;
  }
#line 41
  if ((int )*cp < 48) {
#line 42
    return (0);
  } else {
#line 41
    if ((int )*cp > 57) {
#line 42
      return (0);
    }
  }
#line 45
  *cpp = cp;
#line 48
  while (1) {
#line 48
    if ((int )*cp >= 48) {
#line 48
      if (! ((int )*cp <= 57)) {
#line 48
        break;
      }
    } else {
#line 48
      break;
    }
#line 48
    cp ++;
  }
#line 52
  old = (int )*cp;
#line 53
  *cp = (char)0;
#line 56
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 56
  if (tmp == 0) {
#line 57
    return (0);
  }
#line 60
  *cp = (char )old;
#line 63
  *cpp = cp;
#line 64
  return (1);
}
}
#line 72 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ unsigned int bits ;
  char *cp ;
  int tmp ;
  int tmp___0 ;

  {
#line 79
  cp = *cpp;
#line 79
  while (1) {
#line 79
    if (! ((int )*cp == 32)) {
#line 79
      if (! ((int )*cp == 9)) {
#line 79
        break;
      }
    }
#line 79
    cp ++;
  }
#line 83
  if ((int )*cp < 48) {
#line 84
    return (0);
  } else {
#line 83
    if ((int )*cp > 57) {
#line 84
      return (0);
    }
  }
#line 85
  bits = 0U;
#line 85
  while (1) {
#line 85
    if ((int )*cp >= 48) {
#line 85
      if (! ((int )*cp <= 57)) {
#line 85
        break;
      }
    } else {
#line 85
      break;
    }
#line 86
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 85
    cp ++;
  }
#line 89
  tmp = auth_rsa_read_bignum(& cp, e);
#line 89
  if (! tmp) {
#line 90
    return (0);
  }
#line 93
  tmp___0 = auth_rsa_read_bignum(& cp, n___0);
#line 93
  if (! tmp___0) {
#line 94
    return (0);
  }
#line 97
  while (1) {
#line 97
    if (! ((int )*cp == 32)) {
#line 97
      if (! ((int )*cp == 9)) {
#line 97
        break;
      }
    }
#line 97
    cp ++;
  }
#line 101
  *cpp = cp;
#line 102
  *bitsp = bits;
#line 103
  return (1);
}
}
#line 113 "hostfile.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 121
  got_positive = 0;
#line 122
  i = 0U;
#line 122
  while (i < len) {
#line 124
    if ((int const   )*(pattern + i) == 33) {
#line 125
      negated = 1;
#line 126
      i ++;
    } else {
#line 128
      negated = 0;
    }
#line 134
    subi = 0U;
#line 134
    while (1) {
#line 134
      if (i < len) {
#line 134
        if (subi < sizeof(sub) - 1U) {
#line 134
          if (! ((int const   )*(pattern + i) != 44)) {
#line 134
            break;
          }
        } else {
#line 134
          break;
        }
      } else {
#line 134
        break;
      }
#line 137
      tmp___6 = __ctype_b_loc();
#line 137
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 137
        if (sizeof(*(pattern + i)) > 1U) {
#line 137
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 137
          tmp___5 = __ctype_tolower_loc();
#line 137
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 137
        sub[subi] = (char )__res___0;
      } else {
#line 137
        sub[subi] = (char )*(pattern + i);
      }
#line 134
      subi ++;
#line 134
      i ++;
    }
#line 139
    if (subi >= sizeof(sub) - 1U) {
#line 140
      return (0);
    }
#line 143
    if (i < len) {
#line 143
      if ((int const   )*(pattern + i) == 44) {
#line 144
        i ++;
      }
    }
#line 147
    sub[subi] = (char )'\000';
#line 150
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 150
    if (tmp___7) {
#line 151
      if (negated) {
#line 152
        return (0);
      } else {
#line 154
        got_positive = 1;
      }
    }
  }
#line 162
  return (got_positive);
}
}
#line 172 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                                  BIGNUM *n___0 , BIGNUM *ke , BIGNUM *kn ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 178
  linenum = 0;
#line 184
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 185
  if (! f) {
#line 186
    return (1);
  }
#line 189
  hostlen = strlen(host);
#line 196
  end_return = 1;
#line 199
  while (1) {
#line 199
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 199
    if (! tmp___6) {
#line 199
      break;
    }
#line 200
    cp = line;
#line 201
    linenum ++;
#line 204
    while (1) {
#line 204
      if (! ((int )*cp == 32)) {
#line 204
        if (! ((int )*cp == 9)) {
#line 204
          break;
        }
      }
#line 204
      cp ++;
    }
#line 206
    if (! *cp) {
#line 207
      continue;
    } else {
#line 206
      if ((int )*cp == 35) {
#line 207
        continue;
      } else {
#line 206
        if ((int )*cp == 10) {
#line 207
          continue;
        }
      }
    }
#line 210
    cp2 = cp;
#line 210
    while (1) {
#line 210
      if (*cp2) {
#line 210
        if ((int )*cp2 != 32) {
#line 210
          if (! ((int )*cp2 != 9)) {
#line 210
            break;
          }
        } else {
#line 210
          break;
        }
      } else {
#line 210
        break;
      }
#line 210
      cp2 ++;
    }
#line 214
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 214
    if (! tmp) {
#line 215
      continue;
    }
#line 218
    cp = cp2;
#line 224
    tmp___0 = auth_rsa_read_key(& cp, & kbits, ke, kn);
#line 224
    if (! tmp___0) {
#line 225
      continue;
    }
#line 227
    tmp___3 = BN_num_bits((BIGNUM const   *)kn);
#line 227
    if (kbits != (unsigned int )tmp___3) {
#line 228
      tmp___1 = BN_num_bits((BIGNUM const   *)kn);
#line 228
      error("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
            filename, linenum, host, tmp___1, kbits);
#line 231
      tmp___2 = BN_num_bits((BIGNUM const   *)kn);
#line 231
      error("Warning: replace %d with %d in %s, line %d.", kbits, tmp___2, filename,
            linenum);
    }
#line 235
    tmp___4 = BN_cmp((BIGNUM const   *)ke, (BIGNUM const   *)e);
#line 235
    if (tmp___4 == 0) {
#line 235
      tmp___5 = BN_cmp((BIGNUM const   *)kn, (BIGNUM const   *)n___0);
#line 235
      if (tmp___5 == 0) {
#line 237
        fclose(f);
#line 238
        return (0);
      }
    }
#line 245
    end_return = 2;
  }
#line 248
  fclose(f);
#line 254
  return (end_return);
}
}
#line 262 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , BIGNUM *e ,
                         BIGNUM *n___0 ) 
{ FILE *f ;
  char *buf___0 ;
  unsigned int bits ;
  int tmp ;

  {
#line 271
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 272
  if (! f) {
#line 273
    return (0);
  }
#line 276
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 276
  bits = (unsigned int )tmp;
#line 279
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %u ", host, bits);
#line 280
  buf___0 = BN_bn2dec((BIGNUM const   *)e);
#line 281
  if ((unsigned int )buf___0 == (unsigned int )((void *)0)) {
#line 282
    error("add_host_to_hostfile: BN_bn2dec(e) failed");
#line 283
    fclose(f);
#line 284
    return (0);
  }
#line 286
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", buf___0);
#line 287
  free((void *)buf___0);
#line 288
  buf___0 = BN_bn2dec((BIGNUM const   *)n___0);
#line 289
  if ((unsigned int )buf___0 == (unsigned int )((void *)0)) {
#line 290
    error("add_host_to_hostfile: BN_bn2dec(n) failed");
#line 291
    fclose(f);
#line 292
    return (0);
  }
#line 294
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s\n", buf___0);
#line 295
  free((void *)buf___0);
#line 298
  fclose(f);
#line 299
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 493 "ssh.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 496
SyslogFacility log_facility_number(char *name ) ;
#line 497
LogLevel log_level_number(char *name ) ;
#line 517
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 13 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 17
  __builtin_va_start(args, fmt);
#line 18
  do_log(1, fmt, args);
#line 19
  __builtin_va_end(args);
#line 20
  fatal_cleanup();
#line 21
  return;
}
}
#line 25 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 29
  __builtin_va_start(args, fmt);
#line 30
  do_log(2, fmt, args);
#line 31
  __builtin_va_end(args);
#line 32
  return;
}
}
#line 36 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 40
  __builtin_va_start(args, fmt);
#line 41
  do_log(3, fmt, args);
#line 42
  __builtin_va_end(args);
#line 43
  return;
}
}
#line 47 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 51
  __builtin_va_start(args, fmt);
#line 52
  do_log(4, fmt, args);
#line 53
  __builtin_va_end(args);
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(5, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 75 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 79 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 84
  tmp = xmalloc(sizeof(*cu));
#line 84
  cu = (struct fatal_cleanup *)tmp;
#line 85
  cu->proc = proc;
#line 86
  cu->context = context;
#line 87
  cu->next = fatal_cleanups;
#line 88
  fatal_cleanups = cu;
#line 89
  return;
}
}
#line 93 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 98
  cup = & fatal_cleanups;
#line 98
  while (*cup) {
#line 99
    cu = *cup;
#line 100
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 100
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 101
        *cup = cu->next;
#line 102
        xfree((void *)cu);
#line 103
        return;
      }
    }
#line 98
    cup = & cu->next;
  }
#line 106
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 108
  return;
}
}
#line 115 "log.c"
static int called  =    0;
#line 111 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 117
  if (called) {
#line 118
    exit(255);
  }
#line 119
  called = 1;
#line 121
  cu = fatal_cleanups;
#line 121
  while (cu) {
#line 122
    next_cu = cu->next;
#line 123
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 125
    (*(cu->proc))(cu->context);
#line 121
    cu = next_cu;
  }
#line 127
  exit(255);
}
}
#line 132 "log.c"
static struct __anonstruct_log_facilities_74 log_facilities[12]  = 
#line 132
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 150 "log.c"
static struct __anonstruct_log_levels_75 log_levels[7]  = {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 164 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 168
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 169
    i = 0;
#line 169
    while (log_facilities[i].name) {
#line 170
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 170
      if (tmp == 0) {
#line 171
        return (log_facilities[i].val);
      }
#line 169
      i ++;
    }
  }
#line 172
  return ((enum __anonenum_SyslogFacility_72 )-1);
}
}
#line 175 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 179
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 180
    i = 0;
#line 180
    while (log_levels[i].name) {
#line 181
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 181
      if (tmp == 0) {
#line 182
        return (log_levels[i].val);
      }
#line 180
      i ++;
    }
  }
#line 183
  return ((enum __anonenum_LogLevel_73 )-1);
}
}
#line 1 "match.o"
#line 26 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 29
  while (1) {
#line 31
    if (! *pattern) {
#line 32
      return (! *s);
    }
#line 34
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 49
          while (*s) {
#line 50
            if ((int const   )*s == (int const   )*pattern) {
#line 50
              tmp = match_pattern(s + 1, pattern + 1);
#line 50
              if (tmp) {
#line 52
                return (1);
              }
            }
#line 49
            s ++;
          }
#line 54
          return (0);
        }
      }
#line 60
      while (*s) {
#line 61
        tmp___0 = match_pattern(s, pattern);
#line 61
        if (tmp___0) {
#line 62
          return (1);
        }
#line 60
        s ++;
      }
#line 64
      return (0);
    }
#line 70
    if (! *s) {
#line 71
      return (0);
    }
#line 74
    if ((int const   )*pattern != 63) {
#line 74
      if ((int const   )*pattern != (int const   )*s) {
#line 75
        return (0);
      }
    }
#line 78
    s ++;
#line 79
    pattern ++;
  }
}
}
#line 1 "mpaux.o"
#line 32 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ unsigned int host_key_bytes ;
  int tmp ;
  unsigned int session_key_bytes ;
  int tmp___0 ;
  unsigned int bytes ;
  unsigned char *buf___0 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 38
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 38
  host_key_bytes = (unsigned int )((tmp + 7) / 8);
#line 39
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 39
  session_key_bytes = (unsigned int )((tmp___0 + 7) / 8);
#line 40
  bytes = host_key_bytes + session_key_bytes;
#line 41
  tmp___1 = xmalloc(bytes);
#line 41
  buf___0 = (unsigned char *)tmp___1;
#line 44
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___0);
#line 45
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___0 + host_key_bytes);
#line 46
  MD5_Init(& md);
#line 47
  MD5_Update(& md, (void const   *)buf___0, bytes);
#line 48
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 49
  MD5_Final((unsigned char *)session_id___0, & md);
#line 50
  memset((void *)buf___0, 0, bytes);
#line 51
  xfree((void *)buf___0);
#line 52
  return;
}
}
#line 1 "nchan.o"
#line 40 "nchan.c"
static void chan_send_ieof(Channel *c ) ;
#line 41
static void chan_send_oclose(Channel *c ) ;
#line 42
static void chan_shutdown_write(Channel *c ) ;
#line 43
static void chan_shutdown_read(Channel *c ) ;
#line 44
static void chan_delete_if_full_closed(Channel *c ) ;
#line 51 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 54
  switch (c->istate) {
  case 4: 
#line 56
  debug("channel %d: INPUT_WAIT_OCLOSE -> INPUT_CLOSED [rcvd OCLOSE]", c->self);
#line 57
  c->istate = 8;
#line 58
  break;
  case 1: 
#line 60
  debug("channel %d: INPUT_OPEN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
#line 61
  chan_shutdown_read(c);
#line 62
  chan_send_ieof(c);
#line 63
  c->istate = 8;
#line 64
  break;
  case 2: 
#line 67
  log("channel %d: INPUT_WAIT_DRAIN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
#line 68
  debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_CLOSED [rvcd OCLOSE, send IEOF]", c->self);
#line 69
  chan_send_ieof(c);
#line 70
  c->istate = 8;
#line 71
  break;
  default: 
#line 73
  error("protocol error: chan_rcvd_oclose %d for istate %d", c->self, c->istate);
#line 74
  return;
  }
#line 76
  chan_delete_if_full_closed(c);
#line 77
  return;
}
}
#line 78 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 81
  switch (c->istate) {
  case 1: 
#line 83
  debug("channel %d: INPUT_OPEN -> INPUT_WAIT_DRAIN [read failed]", c->self);
#line 84
  chan_shutdown_read(c);
#line 85
  c->istate = 2;
#line 86
  break;
  default: 
#line 88
  error("internal error: we do not read, but chan_read_failed %d for istate %d", c->self,
        c->istate);
#line 90
  break;
  }
#line 92
  return;
}
}
#line 93 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 96
  tmp = buffer_len(& c->input);
#line 96
  if (tmp) {
#line 97
    error("internal error: chan_ibuf_empty %d for non empty buffer", c->self);
#line 98
    return;
  }
#line 100
  switch (c->istate) {
  case 2: 
#line 102
  debug("channel %d: INPUT_WAIT_DRAIN -> INPUT_WAIT_OCLOSE [inbuf empty, send IEOF]",
        c->self);
#line 103
  chan_send_ieof(c);
#line 104
  c->istate = 4;
#line 105
  break;
  default: 
#line 107
  error("internal error: chan_ibuf_empty %d for istate %d", c->self, c->istate);
#line 108
  break;
  }
#line 110
  return;
}
}
#line 113 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ 

  {
#line 116
  switch (c->ostate) {
  case 16: 
#line 118
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_DRAIN [rvcd IEOF]", c->self);
#line 119
  c->ostate = 32;
#line 120
  break;
  case 64: 
#line 122
  debug("channel %d: OUTPUT_WAIT_IEOF -> OUTPUT_CLOSED [rvcd IEOF]", c->self);
#line 123
  c->ostate = 128;
#line 124
  chan_delete_if_full_closed(c);
#line 125
  break;
  default: 
#line 127
  error("protocol error: chan_rcvd_ieof %d for ostate %d", c->self, c->ostate);
#line 128
  break;
  }
#line 130
  return;
}
}
#line 131 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 134
  switch (c->ostate) {
  case 16: 
#line 136
  debug("channel %d: OUTPUT_OPEN -> OUTPUT_WAIT_IEOF [write failed]", c->self);
#line 137
  chan_send_oclose(c);
#line 138
  c->ostate = 64;
#line 139
  break;
  case 32: 
#line 141
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [write failed]", c->self);
#line 142
  chan_send_oclose(c);
#line 143
  c->ostate = 128;
#line 144
  chan_delete_if_full_closed(c);
#line 145
  break;
  default: 
#line 147
  error("internal error: chan_write_failed %d for ostate %d", c->self, c->ostate);
#line 148
  break;
  }
#line 150
  return;
}
}
#line 151 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ unsigned int tmp ;

  {
#line 154
  tmp = buffer_len(& c->output);
#line 154
  if (tmp) {
#line 155
    debug("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 156
    return;
  }
#line 158
  switch (c->ostate) {
  case 32: 
#line 160
  debug("channel %d: OUTPUT_WAIT_DRAIN -> OUTPUT_CLOSED [obuf empty, send OCLOSE]",
        c->self);
#line 161
  chan_send_oclose(c);
#line 162
  c->ostate = 128;
#line 163
  chan_delete_if_full_closed(c);
#line 164
  break;
  default: 
#line 166
  error("internal error: chan_obuf_empty %d for ostate %d", c->self, c->ostate);
#line 167
  break;
  }
#line 169
  return;
}
}
#line 174 "nchan.c"
static void chan_send_ieof(Channel *c ) 
{ 

  {
#line 177
  switch (c->istate) {
  case 1: 
  case 2: 
#line 180
  packet_start(24);
#line 181
  packet_put_int((unsigned int )c->remote_id);
#line 182
  packet_send();
#line 183
  break;
  default: 
#line 185
  error("internal error: channel %d: cannot send IEOF for istate %d", c->self, c->istate);
#line 186
  break;
  }
#line 188
  return;
}
}
#line 189 "nchan.c"
static void chan_send_oclose(Channel *c ) 
{ unsigned int tmp ;

  {
#line 192
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 195
  chan_shutdown_write(c);
#line 196
  tmp = buffer_len(& c->output);
#line 196
  buffer_consume(& c->output, tmp);
#line 197
  packet_start(25);
#line 198
  packet_put_int((unsigned int )c->remote_id);
#line 199
  packet_send();
#line 200
  break;
  default: 
#line 202
  error("internal error: channel %d: cannot send OCLOSE for ostate %d", c->self, c->istate);
#line 203
  break;
  }
#line 205
  return;
}
}
#line 208 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 212
  debug("channel %d: shutdown_write", c->self);
#line 213
  tmp___1 = shutdown(c->sock, 1);
#line 213
  if (tmp___1 < 0) {
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    debug("chan_shutdown_write failed for #%d/fd%d: %.100s", c->self, c->sock, tmp___0);
  }
#line 216
  return;
}
}
#line 217 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 220
  debug("channel %d: shutdown_read", c->self);
#line 221
  tmp___1 = shutdown(c->sock, 0);
#line 221
  if (tmp___1 < 0) {
#line 222
    tmp = __errno_location();
#line 222
    tmp___0 = strerror(*tmp);
#line 222
    error("chan_shutdown_read failed for #%d/fd%d [i%d o%d]: %.100s", c->self, c->sock,
          c->istate, c->ostate, tmp___0);
  }
#line 224
  return;
}
}
#line 225 "nchan.c"
static void chan_delete_if_full_closed(Channel *c ) 
{ 

  {
#line 228
  if (c->istate == 8) {
#line 228
    if (c->ostate == 128) {
#line 229
      debug("channel %d: full closed", c->self);
#line 230
      channel_free(c->self);
    }
  }
#line 232
  return;
}
}
#line 233 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 236
  c->ostate = 16;
#line 237
  c->istate = 1;
#line 238
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 35 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 38
void packet_set_nonblocking(void) ;
#line 44
int packet_get_connection_out(void) ;
#line 50
void packet_close(void) ;
#line 57
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) ;
#line 65
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 68
unsigned int packet_get_protocol_flags(void) ;
#line 71
void packet_start_compression(int level ) ;
#line 77
void packet_set_interactive(int interactive , int keepalives ) ;
#line 86
void packet_put_char(int value ) ;
#line 92
void packet_put_bignum(BIGNUM *value ) ;
#line 104
int packet_read(int *payload_len_ptr ) ;
#line 120
int packet_read_poll(int *payload_len_ptr ) ;
#line 126
void packet_process_incoming(char const   *buf___0 , unsigned int len ) ;
#line 129
unsigned int packet_get_char(void) ;
#line 138
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 166
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 169
void packet_write_poll(void) ;
#line 175
int packet_have_data_to_write(void) ;
#line 178
int packet_not_very_much_data_to_write(void) ;
#line 182
int packet_set_maxsize(int s ) ;
#line 203
int packet_connection_is_ipv4(void) ;
#line 38 "packet.c"
static int connection_in  =    -1;
#line 39 "packet.c"
static int connection_out  =    -1;
#line 45 "packet.c"
static int cipher_type  =    0;
#line 48 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 51 "packet.c"
static CipherContext receive_context  ;
#line 54 "packet.c"
static CipherContext send_context  ;
#line 57 "packet.c"
static Buffer input  ;
#line 60 "packet.c"
static Buffer output  ;
#line 63 "packet.c"
static Buffer outgoing_packet  ;
#line 66 "packet.c"
static Buffer incoming_packet  ;
#line 69 "packet.c"
static Buffer compression_buffer  ;
#line 72 "packet.c"
static int packet_compression  =    0;
#line 75 "packet.c"
int max_packet_size  =    32768;
#line 78 "packet.c"
static int initialized  =    0;
#line 81 "packet.c"
static int interactive_mode  =    0;
#line 88 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 91
  connection_in = fd_in;
#line 92
  connection_out = fd_out;
#line 93
  cipher_type = 0;
#line 94
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 1);
#line 95
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0, 0);
#line 96
  if (! initialized) {
#line 97
    initialized = 1;
#line 98
    buffer_init(& input);
#line 99
    buffer_init(& output);
#line 100
    buffer_init(& outgoing_packet);
#line 101
    buffer_init(& incoming_packet);
  }
#line 104
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 105
  return;
}
}
#line 109 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 116
  if (connection_in == connection_out) {
#line 117
    return (1);
  }
#line 118
  fromlen = sizeof(from);
#line 119
  memset((void *)(& from), 0, sizeof(from));
#line 120
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 120
  if (tmp < 0) {
#line 121
    return (0);
  }
#line 122
  tolen = sizeof(to);
#line 123
  memset((void *)(& to), 0, sizeof(to));
#line 124
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 124
  if (tmp___0 < 0) {
#line 125
    return (0);
  }
#line 126
  if (fromlen != tolen) {
#line 127
    return (0);
  } else {
#line 126
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 126
    if (tmp___1 != 0) {
#line 127
      return (0);
    }
  }
#line 128
  if ((int )from.ss_family != 2) {
#line 128
    if ((int )from.ss_family != 10) {
#line 129
      return (0);
    }
  }
#line 130
  return (1);
}
}
#line 135 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 139
  tolen = sizeof(to);
#line 141
  memset((void *)(& to), 0, sizeof(to));
#line 142
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 142
  if (tmp < 0) {
#line 143
    return (0);
  }
#line 144
  if ((int )to.ss_family != 2) {
#line 145
    return (0);
  }
#line 146
  return (1);
}
}
#line 151 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 155
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 155
  if (tmp___1 < 0) {
#line 156
    tmp = __errno_location();
#line 156
    tmp___0 = strerror(*tmp);
#line 156
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 158
  if (connection_out != connection_in) {
#line 159
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 159
    if (tmp___4 < 0) {
#line 160
      tmp___2 = __errno_location();
#line 160
      tmp___3 = strerror(*tmp___2);
#line 160
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 162
  return;
}
}
#line 166 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 169
  return (connection_in);
}
}
#line 174 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 177
  return (connection_out);
}
}
#line 182 "packet.c"
void packet_close(void) 
{ 

  {
#line 185
  if (! initialized) {
#line 186
    return;
  }
#line 187
  initialized = 0;
#line 188
  if (connection_in == connection_out) {
#line 189
    shutdown(connection_out, 2);
#line 190
    close(connection_out);
  } else {
#line 192
    close(connection_in);
#line 193
    close(connection_out);
  }
#line 195
  buffer_free(& input);
#line 196
  buffer_free(& output);
#line 197
  buffer_free(& outgoing_packet);
#line 198
  buffer_free(& incoming_packet);
#line 199
  if (packet_compression) {
#line 200
    buffer_free(& compression_buffer);
#line 201
    buffer_compress_uninit();
  }
#line 203
  return;
}
}
#line 207 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 210
  remote_protocol_flags = protocol_flags;
#line 211
  channel_set_options((protocol_flags & 2U) != 0U);
#line 212
  return;
}
}
#line 216 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 219
  return (remote_protocol_flags);
}
}
#line 227 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 230
  if (packet_compression) {
#line 231
    fatal("Compression already enabled.");
  }
#line 232
  packet_compression = 1;
#line 233
  buffer_init(& compression_buffer);
#line 234
  buffer_compress_init(level);
#line 235
  return;
}
}
#line 242 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 246
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 247
  return;
}
}
#line 254 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 260
  if (bytes % 8U != 0U) {
#line 261
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  }
#line 268
  switch ((int )cc->type) {
  case 0: 
#line 270
  i = 0;
#line 271
  break;
  default: 
#line 273
  i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
#line 274
  break;
  }
#line 277
  if (i == 1) {
#line 278
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 280
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 281
  return;
}
}
#line 289 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) 
{ 

  {
#line 294
  cipher_set_key(& receive_context, cipher, key, (int )keylen, 0);
#line 295
  cipher_set_key(& send_context, cipher, key, (int )keylen, 1);
#line 296
  return;
}
}
#line 300 "packet.c"
void packet_start(int type ) 
{ char buf___0[9] ;

  {
#line 305
  buffer_clear(& outgoing_packet);
#line 306
  memset((void *)(buf___0), 0, 8U);
#line 307
  buf___0[8] = (char )type;
#line 308
  buffer_append(& outgoing_packet, (char const   *)(buf___0), 9U);
#line 309
  return;
}
}
#line 313 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 316
  ch = (char )value;
#line 317
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 318
  return;
}
}
#line 322 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 325
  buffer_put_int(& outgoing_packet, value);
#line 326
  return;
}
}
#line 330 "packet.c"
void packet_put_string(char const   *buf___0 , unsigned int len ) 
{ 

  {
#line 333
  buffer_put_string(& outgoing_packet, (void const   *)buf___0, len);
#line 334
  return;
}
}
#line 338 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 341
  buffer_put_bignum(& outgoing_packet, value);
#line 342
  return;
}
}
#line 349 "packet.c"
void packet_send(void) 
{ char buf___0[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 355
  rand___0 = (u_int32_t )0;
#line 361
  if (packet_compression) {
#line 362
    buffer_clear(& compression_buffer);
#line 364
    buffer_consume(& outgoing_packet, 8U);
#line 366
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 367
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 368
    buffer_clear(& outgoing_packet);
#line 369
    tmp = buffer_len(& compression_buffer);
#line 369
    tmp___0 = buffer_ptr(& compression_buffer);
#line 369
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 373
  tmp___1 = buffer_len(& outgoing_packet);
#line 373
  len = (int )((tmp___1 + 4U) - 8U);
#line 376
  padding = 8 - len % 8;
#line 377
  if (cipher_type != 0) {
#line 378
    cp = buffer_ptr(& outgoing_packet);
#line 379
    i = 0;
#line 379
    while (i < padding) {
#line 380
      if (i % 4 == 0) {
#line 381
        rand___0 = arc4random();
      }
#line 382
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 383
      rand___0 >>= 8;
#line 379
      i ++;
    }
  }
#line 386
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 389
  tmp___2 = buffer_len(& outgoing_packet);
#line 389
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 389
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 391
  while (1) {
#line 391
    buf___0[0] = (char )(checksum >> 24);
#line 391
    buf___0[1] = (char )(checksum >> 16);
#line 391
    buf___0[2] = (char )(checksum >> 8);
#line 391
    buf___0[3] = (char )checksum;
#line 391
    break;
  }
#line 392
  buffer_append(& outgoing_packet, (char const   *)(buf___0), 4U);
#line 400
  while (1) {
#line 400
    buf___0[0] = (char )(len >> 24);
#line 400
    buf___0[1] = (char )(len >> 16);
#line 400
    buf___0[2] = (char )(len >> 8);
#line 400
    buf___0[3] = (char )len;
#line 400
    break;
  }
#line 401
  buffer_append(& output, (char const   *)(buf___0), 4U);
#line 402
  tmp___4 = buffer_len(& outgoing_packet);
#line 402
  buffer_append_space(& output, & cp, tmp___4);
#line 403
  tmp___5 = buffer_len(& outgoing_packet);
#line 403
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 403
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 411
  buffer_clear(& outgoing_packet);
#line 418
  return;
}
}
#line 426 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf___0[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 434
  packet_write_wait();
#line 437
  while (1) {
#line 439
    type = packet_read_poll(payload_len_ptr);
#line 440
    if (type == 14) {
      goto _L;
    } else {
#line 440
      if (type == 15) {
        goto _L;
      } else {
#line 440
        if (type == 19) {
          goto _L;
        } else {
#line 440
          if (type == 33) {
            _L: /* CIL Label */ 
#line 444
            while (1) {
#line 444
              _p = *payload_len_ptr;
#line 444
              _e = 0;
#line 444
              if (_p != _e) {
#line 444
                log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                    444);
#line 444
                packet_disconnect("Packet integrity error. (%d)", type);
              }
#line 444
              break;
            }
          }
        }
      }
    }
#line 446
    if (type != 0) {
#line 447
      return (type);
    }
#line 452
    while (1) {
#line 452
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 452
      break;
    }
#line 453
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 456
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 459
    len = read(connection_in, (void *)(buf___0), sizeof(buf___0));
#line 460
    if (len == 0) {
#line 461
      tmp = get_remote_ipaddr();
#line 461
      log("Connection closed by %.200s", tmp);
#line 462
      fatal_cleanup();
    }
#line 464
    if (len < 0) {
#line 465
      tmp___0 = __errno_location();
#line 465
      tmp___1 = strerror(*tmp___0);
#line 465
      fatal("Read from socket failed: %.100s", tmp___1);
    }
#line 467
    packet_process_incoming((char const   *)(buf___0), (unsigned int )len);
  }
}
}
#line 477 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 482
  type = packet_read(payload_len_ptr);
#line 483
  if (type != expected_type) {
#line 484
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 486
  return;
}
}
#line 503 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf___0[8] ;
  char *cp ;
  char *msg ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;

  {
  restart: 
#line 514
  tmp = buffer_len(& input);
#line 514
  if (tmp < 12U) {
#line 515
    return (0);
  }
#line 517
  tmp___0 = buffer_ptr(& input);
#line 517
  ucp = (unsigned char *)tmp___0;
#line 518
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 519
  if (len < 5U) {
#line 520
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 519
    if (len > 262144U) {
#line 520
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 521
  padded_len = (len + 8U) & 4294967288U;
#line 524
  tmp___1 = buffer_len(& input);
#line 524
  if (tmp___1 < 4U + padded_len) {
#line 525
    return (0);
  }
#line 530
  buffer_consume(& input, 4U);
#line 533
  buffer_clear(& incoming_packet);
#line 534
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 535
  tmp___2 = buffer_ptr(& input);
#line 535
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 536
  buffer_consume(& input, padded_len);
#line 544
  tmp___3 = buffer_len(& incoming_packet);
#line 544
  tmp___4 = buffer_ptr(& incoming_packet);
#line 544
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 548
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 552
  tmp___6 = buffer_len(& incoming_packet);
#line 552
  if (len != tmp___6) {
#line 553
    tmp___5 = buffer_len(& incoming_packet);
#line 553
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 556
  tmp___7 = buffer_ptr(& incoming_packet);
#line 556
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 557
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 558
  if (checksum != stored_checksum) {
#line 559
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 560
  buffer_consume_end(& incoming_packet, 4U);
#line 563
  if (packet_compression) {
#line 564
    buffer_clear(& compression_buffer);
#line 565
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 566
    buffer_clear(& incoming_packet);
#line 567
    tmp___8 = buffer_len(& compression_buffer);
#line 567
    tmp___9 = buffer_ptr(& compression_buffer);
#line 567
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 571
  buffer_get(& incoming_packet, buf___0, 1U);
#line 574
  tmp___10 = buffer_len(& incoming_packet);
#line 574
  *payload_len_ptr = (int )tmp___10;
#line 577
  if ((int )((unsigned char )buf___0[0]) == 1) {
#line 578
    msg = packet_get_string((unsigned int *)((void *)0));
#line 579
    log("Received disconnect: %.900s", msg);
#line 580
    xfree((void *)msg);
#line 581
    fatal_cleanup();
  }
#line 585
  if ((int )((unsigned char )buf___0[0]) == 32) {
    goto restart;
  }
#line 589
  if ((int )((unsigned char )buf___0[0]) == 36) {
#line 590
    msg = packet_get_string((unsigned int *)((void *)0));
#line 591
    debug("Remote: %.900s", msg);
#line 592
    xfree((void *)msg);
    goto restart;
  }
#line 596
  return ((int )((unsigned char )buf___0[0]));
}
}
#line 604 "packet.c"
void packet_process_incoming(char const   *buf___0 , unsigned int len ) 
{ 

  {
#line 607
  buffer_append(& input, buf___0, len);
#line 608
  return;
}
}
#line 612 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 616
  buffer_get(& incoming_packet, & ch, 1U);
#line 617
  return ((unsigned int )((unsigned char )ch));
}
}
#line 622 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 625
  tmp = buffer_get_int(& incoming_packet);
#line 625
  return (tmp);
}
}
#line 633 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 636
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 637
  return;
}
}
#line 646 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 649
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 649
  return (tmp);
}
}
#line 661 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___0[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 667
  __builtin_va_start(args, fmt);
#line 668
  vsnprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )fmt,
            args);
#line 669
  __builtin_va_end(args);
#line 671
  packet_start(36);
#line 672
  tmp = strlen((char const   *)(buf___0));
#line 672
  packet_put_string((char const   *)(buf___0), tmp);
#line 673
  packet_send();
#line 674
  packet_write_wait();
#line 675
  return;
}
}
#line 689 "packet.c"
static int disconnecting  =    0;
#line 684 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___0[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 690
  if (disconnecting) {
#line 691
    fatal("packet_disconnect called recursively.");
  }
#line 692
  disconnecting = 1;
#line 698
  __builtin_va_start(args, fmt);
#line 699
  vsnprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )fmt,
            args);
#line 700
  __builtin_va_end(args);
#line 703
  packet_start(1);
#line 704
  tmp = strlen((char const   *)(buf___0));
#line 704
  packet_put_string((char const   *)(buf___0), tmp);
#line 705
  packet_send();
#line 706
  packet_write_wait();
#line 709
  channel_stop_listening();
#line 712
  packet_close();
#line 715
  log("Disconnecting: %.100s", buf___0);
#line 716
  fatal_cleanup();
#line 717
  return;
}
}
#line 721 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 724
  tmp = buffer_len(& output);
#line 724
  len = (int )tmp;
#line 725
  if (len > 0) {
#line 726
    tmp___0 = buffer_ptr(& output);
#line 726
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 727
    if (len <= 0) {
#line 728
      tmp___3 = __errno_location();
#line 728
      if (*tmp___3 == 11) {
#line 729
        return;
      } else {
#line 731
        tmp___1 = __errno_location();
#line 731
        tmp___2 = strerror(*tmp___1);
#line 731
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 733
    buffer_consume(& output, (unsigned int )len);
  }
#line 735
  return;
}
}
#line 742 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 745
  packet_write_poll();
#line 746
  while (1) {
#line 746
    tmp = packet_have_data_to_write();
#line 746
    if (! tmp) {
#line 746
      break;
    }
#line 748
    while (1) {
#line 748
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 748
      break;
    }
#line 749
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 750
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 751
    packet_write_poll();
  }
#line 753
  return;
}
}
#line 757 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 760
  tmp = buffer_len(& output);
#line 760
  return (tmp != 0U);
}
}
#line 765 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 768
  if (interactive_mode) {
#line 769
    tmp = buffer_len(& output);
#line 769
    return (tmp < 16384U);
  } else {
#line 771
    tmp___0 = buffer_len(& output);
#line 771
    return (tmp___0 < 131072U);
  }
}
}
#line 776 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int lowdelay ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int throughput ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 779
  on = 1;
#line 782
  interactive_mode = interactive;
#line 785
  tmp = packet_connection_is_on_socket();
#line 785
  if (! tmp) {
#line 786
    return;
  }
#line 787
  if (keepalives) {
#line 789
    tmp___2 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 789
    if (tmp___2 < 0) {
#line 791
      tmp___0 = __errno_location();
#line 791
      tmp___1 = strerror(*tmp___0);
#line 791
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___1);
    }
  }
#line 796
  tmp___3 = packet_connection_is_ipv4();
#line 796
  if (! tmp___3) {
#line 797
    return;
  }
#line 798
  if (interactive) {
#line 803
    lowdelay = 16;
#line 804
    tmp___6 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 804
    if (tmp___6 < 0) {
#line 806
      tmp___4 = __errno_location();
#line 806
      tmp___5 = strerror(*tmp___4);
#line 806
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___5);
    }
#line 807
    tmp___9 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 807
    if (tmp___9 < 0) {
#line 809
      tmp___7 = __errno_location();
#line 809
      tmp___8 = strerror(*tmp___7);
#line 809
      error("setsockopt TCP_NODELAY: %.100s", tmp___8);
    }
  } else {
#line 815
    throughput = 8;
#line 816
    tmp___12 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 816
    if (tmp___12 < 0) {
#line 818
      tmp___10 = __errno_location();
#line 818
      tmp___11 = strerror(*tmp___10);
#line 818
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___11);
    }
  }
#line 820
  return;
}
}
#line 824 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 827
  return (interactive_mode);
}
}
#line 833 "packet.c"
static int called___0  =    0;
#line 830 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 834
  if (called___0) {
#line 835
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 836
    return (-1);
  }
#line 838
  if (s < 4096) {
#line 839
    log("packet_set_maxsize: bad size %d", s);
#line 840
    return (-1);
  } else {
#line 838
    if (s > 1048576) {
#line 839
      log("packet_set_maxsize: bad size %d", s);
#line 840
      return (-1);
    }
  }
#line 842
  log("packet_set_maxsize: setting to %d", s);
#line 843
  max_packet_size = s;
#line 844
  return (s);
}
}
#line 1 "radix.o"
#line 1 "random.o"
#line 110 "random.c"
static int random_pool  ;
#line 108 "random.c"
void get_random_bytes(unsigned char *buf___0 , int len ) 
{ int c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 113
  random_pool = open("/dev/urandom", 0);
#line 114
  if (random_pool == -1) {
#line 115
    tmp = __errno_location();
#line 115
    tmp___0 = strerror(*tmp);
#line 115
    fatal("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
  }
#line 117
  c = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___0, (unsigned int )len);
#line 118
  if (c <= 0) {
#line 119
    tmp___1 = __errno_location();
#line 119
    tmp___2 = strerror(*tmp___1);
#line 119
    fatal("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
  }
#line 121
  close(random_pool);
#line 122
  return;
}
}
#line 1 "readpass.o"
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 431 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 40 "readpass.c"
int volatile   intr  ;
#line 42 "readpass.c"
void intcatch(void) 
{ 

  {
#line 45
  intr = (int volatile   )1;
#line 46
  return;
}
}
#line 53 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf___0[1024] ;
  char *p ;
  char ch ;
  struct termios tio ;
  struct termios saved_tio ;
  sigset_t oset ;
  sigset_t nset ;
  struct sigaction sa ;
  struct sigaction osa ;
  int input___0 ;
  int output___0 ;
  int echo ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  __pid_t tmp___3 ;

  {
#line 60
  echo = 0;
#line 62
  if (from_stdin) {
#line 63
    input___0 = 0;
#line 64
    output___0 = 2;
  } else {
#line 66
    output___0 = open("/dev/tty", 2);
#line 66
    input___0 = output___0;
  }
#line 68
  if (input___0 == -1) {
#line 69
    fatal("You have no controlling tty.  Cannot read passphrase.\n");
  }
#line 72
  sigemptyset(& nset);
#line 73
  sigaddset(& nset, 20);
#line 74
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 75
  memset((void *)(& sa), 0, sizeof(sa));
#line 76
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& intcatch);
#line 77
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& osa));
#line 79
  intr = (int volatile   )0;
#line 81
  tmp = tcgetattr(input___0, & saved_tio);
#line 81
  if (tmp == 0) {
#line 81
    if (saved_tio.c_lflag & 8U) {
#line 82
      echo = 1;
#line 83
      tio = saved_tio;
#line 84
      tio.c_lflag &= 4294967175U;
#line 85
      tcsetattr(input___0, 0, (struct termios  const  *)(& tio));
    }
  }
#line 88
  fflush(stdout);
#line 90
  tmp___0 = strlen(prompt);
#line 90
  write(output___0, (void const   *)prompt, tmp___0);
#line 91
  p = buf___0;
#line 91
  while (1) {
#line 91
    tmp___2 = read(input___0, (void *)(& ch), 1U);
#line 91
    if (tmp___2 == 1) {
#line 91
      if (! ((int )ch != 10)) {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
#line 92
    if (intr) {
#line 93
      break;
    }
#line 94
    if ((unsigned int )p < (unsigned int )((buf___0 + sizeof(buf___0)) - 1)) {
#line 95
      tmp___1 = p;
#line 95
      p ++;
#line 95
      *tmp___1 = ch;
    }
  }
#line 97
  *p = (char )'\000';
#line 98
  if (! intr) {
#line 99
    write(output___0, (void const   *)"\n", 1U);
  }
#line 102
  if (echo) {
#line 103
    tcsetattr(input___0, 0, (struct termios  const  *)(& saved_tio));
  }
#line 104
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 105
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 107
  if (intr) {
#line 108
    tmp___3 = getpid();
#line 108
    kill(tmp___3, 2);
#line 109
    sigemptyset(& nset);
#line 111
    sigsuspend((sigset_t const   *)(& nset));
  }
#line 114
  if (! from_stdin) {
#line 115
    close(input___0);
  }
#line 116
  p = xstrdup((char const   *)(buf___0));
#line 117
  memset((void *)(buf___0), 0, sizeof(buf___0));
#line 118
  return (p);
}
}
#line 1 "rsa.o"
#line 452 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 490
__inline static int putchar(int __c ) ;
#line 75 "/usr/include/bits/stdio.h"
__inline static int putchar(int __c ) 
{ int tmp ;

  {
#line 78
  tmp = _IO_putc(__c, stdout);
#line 78
  return (tmp);
}
}
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 104 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 36 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 42
void rsa_set_verbose(int verbose___0 ) ;
#line 44
int rsa_alive(void) ;
#line 46
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 47
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 45 "rsa.c"
int rsa_verbose  =    1;
#line 50 "rsa.c"
void seed_rng(void) 
{ char buf___0[64] ;

  {
#line 55
  get_random_bytes((unsigned char *)(buf___0), (int )sizeof(buf___0));
#line 56
  RAND_seed((void const   *)(buf___0), (int )sizeof(buf___0));
#line 57
  memset((void *)(buf___0), 0, sizeof(buf___0));
#line 58
  return;
}
}
#line 60 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 65
  seed_rng();
#line 66
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 67
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 68
    return (0);
  }
#line 69
  RSA_free(key);
#line 70
  return (1);
}
}
#line 76 "rsa.c"
void keygen_progress(int p , int n___0 , void *arg ) 
{ char progress_chars[6] ;

  {
#line 79
  progress_chars[0] = (char )'.';
#line 79
  progress_chars[1] = (char )'o';
#line 79
  progress_chars[2] = (char )'+';
#line 79
  progress_chars[3] = (char )'O';
#line 79
  progress_chars[4] = (char )'?';
#line 79
  progress_chars[5] = (char )'\000';
#line 81
  if (p < 0) {
#line 82
    p = (int )(sizeof(progress_chars) - 2U);
  } else {
#line 81
    if ((unsigned int )p > sizeof(progress_chars) - 2U) {
#line 82
      p = (int )(sizeof(progress_chars) - 2U);
    }
  }
#line 84
  putchar((int )progress_chars[p]);
#line 85
  fflush(stdout);
#line 86
  return;
}
}
#line 94 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 99
  seed_rng();
#line 101
  if (rsa_verbose) {
#line 102
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 103
    fflush(stdout);
#line 104
    key = RSA_generate_key((int )bits, 35UL, & keygen_progress, (void *)0);
#line 105
    printf((char const   * __restrict  )"\n");
  } else {
#line 107
    key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                           (void *)0);
  }
#line 109
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 110
    fatal("rsa_generate_key: key generation failed.");
  }
#line 113
  pub->n = BN_new();
#line 114
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 115
  pub->e = BN_new();
#line 116
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 119
  prv->n = BN_new();
#line 120
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 121
  prv->e = BN_new();
#line 122
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 123
  prv->d = BN_new();
#line 124
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 125
  prv->p = BN_new();
#line 126
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 127
  prv->q = BN_new();
#line 128
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 130
  prv->dmp1 = BN_new();
#line 131
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 133
  prv->dmq1 = BN_new();
#line 134
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 136
  prv->iqmp = BN_new();
#line 137
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 139
  RSA_free(key);
#line 141
  if (rsa_verbose) {
#line 142
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 143
  return;
}
}
#line 145 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 151
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 151
  if (tmp < 2) {
#line 152
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 151
    if ((key->e)->top > 0) {
#line 151
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 152
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 152
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 154
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 154
  olen = (tmp___0 + 7) / 8;
#line 155
  tmp___1 = xmalloc((unsigned int )olen);
#line 155
  outbuf = (unsigned char *)tmp___1;
#line 157
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 157
  ilen = (tmp___2 + 7) / 8;
#line 158
  tmp___3 = xmalloc((unsigned int )ilen);
#line 158
  inbuf = (unsigned char *)tmp___3;
#line 159
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 161
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 161
  if (len <= 0) {
#line 163
    fatal("rsa_public_encrypt() failed");
  }
#line 165
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 167
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 168
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 169
  xfree((void *)outbuf);
#line 170
  xfree((void *)inbuf);
#line 171
  return;
}
}
#line 173 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 179
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 179
  olen = (tmp + 7) / 8;
#line 180
  tmp___0 = xmalloc((unsigned int )olen);
#line 180
  outbuf = (unsigned char *)tmp___0;
#line 182
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 182
  ilen = (tmp___1 + 7) / 8;
#line 183
  tmp___2 = xmalloc((unsigned int )ilen);
#line 183
  inbuf = (unsigned char *)tmp___2;
#line 184
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 186
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 186
  if (len <= 0) {
#line 188
    fatal("rsa_private_decrypt() failed");
  }
#line 190
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 192
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 193
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 194
  xfree((void *)outbuf);
#line 195
  xfree((void *)inbuf);
#line 196
  return;
}
}
#line 200 "rsa.c"
void rsa_set_verbose(int verbose___0 ) 
{ 

  {
#line 203
  rsa_verbose = verbose___0;
#line 204
  return;
}
}
#line 1 "tildexpand.o"
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 692 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 18 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 29
  if ((int const   )*(filename + 0) != 126) {
#line 30
    tmp = xstrdup(filename);
#line 30
    return (tmp);
  }
#line 33
  filename ++;
#line 36
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 36
  cp = (char const   *)tmp___1;
#line 37
  if (cp) {
#line 38
    userlen = (unsigned int )(cp - filename);
  } else {
#line 40
    userlen = strlen(filename);
  }
#line 41
  if (userlen == 0U) {
#line 42
    pw = getpwuid(my_uid);
  } else {
#line 45
    if (userlen > sizeof(user) - 1U) {
#line 46
      fatal("User name after tilde too long.");
    }
#line 47
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 48
    user[userlen] = (char)0;
#line 49
    pw = getpwnam((char const   *)(user));
  }
#line 51
  if (! pw) {
#line 52
    fatal("Unknown user %100s.", user);
  }
#line 55
  if (! cp) {
#line 57
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 57
    return (tmp___2);
  }
#line 60
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 60
  tmp___4 = strlen(cp + 1);
#line 60
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 61
  if (len > 4096) {
#line 62
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 63
  tmp___5 = xmalloc((unsigned int )len);
#line 63
  expanded = (char *)tmp___5;
#line 64
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 65
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 186 "packet.h"
void tty_make_modes(int fd ) ;
#line 189
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 26 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 29
  switch ((int )speed) {
  case 0: 
#line 31
  return (0);
  case 1: 
#line 33
  return (50);
  case 2: 
#line 35
  return (75);
  case 3: 
#line 37
  return (110);
  case 4: 
#line 39
  return (134);
  case 5: 
#line 41
  return (150);
  case 6: 
#line 43
  return (200);
  case 7: 
#line 45
  return (300);
  case 8: 
#line 47
  return (600);
  case 9: 
#line 49
  return (1200);
  case 10: 
#line 51
  return (1800);
  case 11: 
#line 53
  return (2400);
  case 12: 
#line 55
  return (4800);
  case 13: 
#line 57
  return (9600);
  case 14: 
#line 61
  return (19200);
  case 15: 
#line 71
  return (38400);
  case 4097: 
#line 93
  return (57600);
  case 4098: 
#line 101
  return (115200);
  case 4099: 
#line 105
  return (230400);
  default: ;
#line 108
  return (9600);
  }
}
}
#line 115 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 118
  switch (baud) {
  case 0: 
#line 120
  return (0U);
  case 50: 
#line 122
  return (1U);
  case 75: 
#line 124
  return (2U);
  case 110: 
#line 126
  return (3U);
  case 134: 
#line 128
  return (4U);
  case 150: 
#line 130
  return (5U);
  case 200: 
#line 132
  return (6U);
  case 300: 
#line 134
  return (7U);
  case 600: 
#line 136
  return (8U);
  case 1200: 
#line 138
  return (9U);
  case 1800: 
#line 140
  return (10U);
  case 2400: 
#line 142
  return (11U);
  case 4800: 
#line 144
  return (12U);
  case 9600: 
#line 146
  return (13U);
  case 19200: 
#line 150
  return (14U);
  case 38400: 
#line 160
  return (15U);
  case 57600: 
#line 182
  return (4097U);
  case 115200: 
#line 190
  return (4098U);
  case 230400: 
#line 194
  return (4099U);
  default: ;
#line 197
  return (13U);
  }
}
}
#line 206 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 212
  tmp___1 = tcgetattr(fd, & tio);
#line 212
  if (tmp___1 < 0) {
#line 213
    packet_put_char(0);
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    log("tcgetattr: %.100s", tmp___0);
#line 215
    return;
  }
#line 218
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 218
  baud = speed_to_baud(tmp___2);
#line 219
  packet_put_char(193);
#line 220
  packet_put_int((unsigned int )baud);
#line 221
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 221
  baud = speed_to_baud(tmp___3);
#line 222
  packet_put_char(192);
#line 223
  packet_put_int((unsigned int )baud);
#line 37 "ttymodes.h"
  packet_put_char(1);
#line 37
  packet_put_char((int )tio.c_cc[0]);
#line 38
  packet_put_char(2);
#line 38
  packet_put_char((int )tio.c_cc[1]);
#line 39
  packet_put_char(3);
#line 39
  packet_put_char((int )tio.c_cc[2]);
#line 41
  packet_put_char(4);
#line 41
  packet_put_char((int )tio.c_cc[3]);
#line 43
  packet_put_char(5);
#line 43
  packet_put_char((int )tio.c_cc[4]);
#line 45
  packet_put_char(6);
#line 45
  packet_put_char((int )tio.c_cc[11]);
#line 48
  packet_put_char(7);
#line 48
  packet_put_char((int )tio.c_cc[16]);
#line 50
  packet_put_char(8);
#line 50
  packet_put_char((int )tio.c_cc[8]);
#line 51
  packet_put_char(9);
#line 51
  packet_put_char((int )tio.c_cc[9]);
#line 53
  packet_put_char(10);
#line 53
  packet_put_char((int )tio.c_cc[10]);
#line 59
  packet_put_char(12);
#line 59
  packet_put_char((int )tio.c_cc[12]);
#line 62
  packet_put_char(13);
#line 62
  packet_put_char((int )tio.c_cc[14]);
#line 65
  packet_put_char(14);
#line 65
  packet_put_char((int )tio.c_cc[15]);
#line 77
  packet_put_char(18);
#line 77
  packet_put_char((int )tio.c_cc[13]);
#line 81
  packet_put_char(30);
#line 81
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 82
  packet_put_char(31);
#line 82
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 83
  packet_put_char(32);
#line 83
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 84
  packet_put_char(33);
#line 84
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 85
  packet_put_char(34);
#line 85
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 86
  packet_put_char(35);
#line 86
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 87
  packet_put_char(36);
#line 87
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 89
  packet_put_char(37);
#line 89
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 91
  packet_put_char(38);
#line 91
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 92
  packet_put_char(39);
#line 92
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 93
  packet_put_char(40);
#line 93
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 95
  packet_put_char(41);
#line 95
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 98
  packet_put_char(50);
#line 98
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 99
  packet_put_char(51);
#line 99
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 101
  packet_put_char(52);
#line 101
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 103
  packet_put_char(53);
#line 103
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 104
  packet_put_char(54);
#line 104
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 105
  packet_put_char(55);
#line 105
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 106
  packet_put_char(56);
#line 106
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 107
  packet_put_char(57);
#line 107
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 108
  packet_put_char(58);
#line 108
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 110
  packet_put_char(59);
#line 110
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 113
  packet_put_char(60);
#line 113
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 116
  packet_put_char(61);
#line 116
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 119
  packet_put_char(62);
#line 119
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 122
  packet_put_char(70);
#line 122
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 124
  packet_put_char(71);
#line 124
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 126
  packet_put_char(72);
#line 126
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 128
  packet_put_char(73);
#line 128
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 131
  packet_put_char(74);
#line 131
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 134
  packet_put_char(75);
#line 134
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 137
  packet_put_char(90);
#line 137
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 138
  packet_put_char(91);
#line 138
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 139
  packet_put_char(92);
#line 139
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 140
  packet_put_char(93);
#line 140
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 243 "ttymodes.c"
  packet_put_char(0);
#line 244
  return;
}
}
#line 250 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 255
  n_bytes = 0;
#line 256
  failure = 0;
#line 263
  tmp = tcgetattr(fd, & tio);
#line 263
  if (tmp < 0) {
#line 264
    failure = -1;
  }
#line 266
  while (1) {
#line 267
    n_bytes ++;
#line 268
    tmp___0 = packet_get_char();
#line 268
    opcode = (int )tmp___0;
#line 269
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 274
    n_bytes += 4;
#line 275
    tmp___1 = packet_get_int();
#line 275
    baud = (int )tmp___1;
#line 276
    if (failure != -1) {
#line 276
      tmp___2 = baud_to_speed(baud);
#line 276
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 276
      if (tmp___3 < 0) {
#line 277
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 278
    break;
    case 193: 
#line 281
    n_bytes += 4;
#line 282
    tmp___4 = packet_get_int();
#line 282
    baud = (int )tmp___4;
#line 283
    if (failure != -1) {
#line 283
      tmp___5 = baud_to_speed(baud);
#line 283
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 283
      if (tmp___6 < 0) {
#line 284
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 285
    break;
    case 1: 
#line 37 "ttymodes.h"
    n_bytes ++;
#line 37
    tmp___7 = packet_get_char();
#line 37
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 37
    break;
    case 2: 
#line 38
    n_bytes ++;
#line 38
    tmp___8 = packet_get_char();
#line 38
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 38
    break;
    case 3: 
#line 39
    n_bytes ++;
#line 39
    tmp___9 = packet_get_char();
#line 39
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 39
    break;
    case 4: 
#line 41
    n_bytes ++;
#line 41
    tmp___10 = packet_get_char();
#line 41
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 41
    break;
    case 5: 
#line 43
    n_bytes ++;
#line 43
    tmp___11 = packet_get_char();
#line 43
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 43
    break;
    case 6: 
#line 45
    n_bytes ++;
#line 45
    tmp___12 = packet_get_char();
#line 45
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 45
    break;
    case 7: 
#line 48
    n_bytes ++;
#line 48
    tmp___13 = packet_get_char();
#line 48
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 48
    break;
    case 8: 
#line 50
    n_bytes ++;
#line 50
    tmp___14 = packet_get_char();
#line 50
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 50
    break;
    case 9: 
#line 51
    n_bytes ++;
#line 51
    tmp___15 = packet_get_char();
#line 51
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 51
    break;
    case 10: 
#line 53
    n_bytes ++;
#line 53
    tmp___16 = packet_get_char();
#line 53
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 53
    break;
    case 12: 
#line 59
    n_bytes ++;
#line 59
    tmp___17 = packet_get_char();
#line 59
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 59
    break;
    case 13: 
#line 62
    n_bytes ++;
#line 62
    tmp___18 = packet_get_char();
#line 62
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 62
    break;
    case 14: 
#line 65
    n_bytes ++;
#line 65
    tmp___19 = packet_get_char();
#line 65
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 65
    break;
    case 18: 
#line 77
    n_bytes ++;
#line 77
    tmp___20 = packet_get_char();
#line 77
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 77
    break;
    case 30: 
#line 81
    n_bytes ++;
#line 81
    tmp___21 = packet_get_char();
#line 81
    if (tmp___21) {
#line 81
      tio.c_iflag |= 4U;
    } else {
#line 81
      tio.c_iflag &= 4294967291U;
    }
#line 81
    break;
    case 31: 
#line 82
    n_bytes ++;
#line 82
    tmp___22 = packet_get_char();
#line 82
    if (tmp___22) {
#line 82
      tio.c_iflag |= 8U;
    } else {
#line 82
      tio.c_iflag &= 4294967287U;
    }
#line 82
    break;
    case 32: 
#line 83
    n_bytes ++;
#line 83
    tmp___23 = packet_get_char();
#line 83
    if (tmp___23) {
#line 83
      tio.c_iflag |= 16U;
    } else {
#line 83
      tio.c_iflag &= 4294967279U;
    }
#line 83
    break;
    case 33: 
#line 84
    n_bytes ++;
#line 84
    tmp___24 = packet_get_char();
#line 84
    if (tmp___24) {
#line 84
      tio.c_iflag |= 32U;
    } else {
#line 84
      tio.c_iflag &= 4294967263U;
    }
#line 84
    break;
    case 34: 
#line 85
    n_bytes ++;
#line 85
    tmp___25 = packet_get_char();
#line 85
    if (tmp___25) {
#line 85
      tio.c_iflag |= 64U;
    } else {
#line 85
      tio.c_iflag &= 4294967231U;
    }
#line 85
    break;
    case 35: 
#line 86
    n_bytes ++;
#line 86
    tmp___26 = packet_get_char();
#line 86
    if (tmp___26) {
#line 86
      tio.c_iflag |= 128U;
    } else {
#line 86
      tio.c_iflag &= 4294967167U;
    }
#line 86
    break;
    case 36: 
#line 87
    n_bytes ++;
#line 87
    tmp___27 = packet_get_char();
#line 87
    if (tmp___27) {
#line 87
      tio.c_iflag |= 256U;
    } else {
#line 87
      tio.c_iflag &= 4294967039U;
    }
#line 87
    break;
    case 37: 
#line 89
    n_bytes ++;
#line 89
    tmp___28 = packet_get_char();
#line 89
    if (tmp___28) {
#line 89
      tio.c_iflag |= 512U;
    } else {
#line 89
      tio.c_iflag &= 4294966783U;
    }
#line 89
    break;
    case 38: 
#line 91
    n_bytes ++;
#line 91
    tmp___29 = packet_get_char();
#line 91
    if (tmp___29) {
#line 91
      tio.c_iflag |= 1024U;
    } else {
#line 91
      tio.c_iflag &= 4294966271U;
    }
#line 91
    break;
    case 39: 
#line 92
    n_bytes ++;
#line 92
    tmp___30 = packet_get_char();
#line 92
    if (tmp___30) {
#line 92
      tio.c_iflag |= 2048U;
    } else {
#line 92
      tio.c_iflag &= 4294965247U;
    }
#line 92
    break;
    case 40: 
#line 93
    n_bytes ++;
#line 93
    tmp___31 = packet_get_char();
#line 93
    if (tmp___31) {
#line 93
      tio.c_iflag |= 4096U;
    } else {
#line 93
      tio.c_iflag &= 4294963199U;
    }
#line 93
    break;
    case 41: 
#line 95
    n_bytes ++;
#line 95
    tmp___32 = packet_get_char();
#line 95
    if (tmp___32) {
#line 95
      tio.c_iflag |= 8192U;
    } else {
#line 95
      tio.c_iflag &= 4294959103U;
    }
#line 95
    break;
    case 50: 
#line 98
    n_bytes ++;
#line 98
    tmp___33 = packet_get_char();
#line 98
    if (tmp___33) {
#line 98
      tio.c_lflag |= 1U;
    } else {
#line 98
      tio.c_lflag &= 4294967294U;
    }
#line 98
    break;
    case 51: 
#line 99
    n_bytes ++;
#line 99
    tmp___34 = packet_get_char();
#line 99
    if (tmp___34) {
#line 99
      tio.c_lflag |= 2U;
    } else {
#line 99
      tio.c_lflag &= 4294967293U;
    }
#line 99
    break;
    case 52: 
#line 101
    n_bytes ++;
#line 101
    tmp___35 = packet_get_char();
#line 101
    if (tmp___35) {
#line 101
      tio.c_lflag |= 4U;
    } else {
#line 101
      tio.c_lflag &= 4294967291U;
    }
#line 101
    break;
    case 53: 
#line 103
    n_bytes ++;
#line 103
    tmp___36 = packet_get_char();
#line 103
    if (tmp___36) {
#line 103
      tio.c_lflag |= 8U;
    } else {
#line 103
      tio.c_lflag &= 4294967287U;
    }
#line 103
    break;
    case 54: 
#line 104
    n_bytes ++;
#line 104
    tmp___37 = packet_get_char();
#line 104
    if (tmp___37) {
#line 104
      tio.c_lflag |= 16U;
    } else {
#line 104
      tio.c_lflag &= 4294967279U;
    }
#line 104
    break;
    case 55: 
#line 105
    n_bytes ++;
#line 105
    tmp___38 = packet_get_char();
#line 105
    if (tmp___38) {
#line 105
      tio.c_lflag |= 32U;
    } else {
#line 105
      tio.c_lflag &= 4294967263U;
    }
#line 105
    break;
    case 56: 
#line 106
    n_bytes ++;
#line 106
    tmp___39 = packet_get_char();
#line 106
    if (tmp___39) {
#line 106
      tio.c_lflag |= 64U;
    } else {
#line 106
      tio.c_lflag &= 4294967231U;
    }
#line 106
    break;
    case 57: 
#line 107
    n_bytes ++;
#line 107
    tmp___40 = packet_get_char();
#line 107
    if (tmp___40) {
#line 107
      tio.c_lflag |= 128U;
    } else {
#line 107
      tio.c_lflag &= 4294967167U;
    }
#line 107
    break;
    case 58: 
#line 108
    n_bytes ++;
#line 108
    tmp___41 = packet_get_char();
#line 108
    if (tmp___41) {
#line 108
      tio.c_lflag |= 256U;
    } else {
#line 108
      tio.c_lflag &= 4294967039U;
    }
#line 108
    break;
    case 59: 
#line 110
    n_bytes ++;
#line 110
    tmp___42 = packet_get_char();
#line 110
    if (tmp___42) {
#line 110
      tio.c_lflag |= 32768U;
    } else {
#line 110
      tio.c_lflag &= 4294934527U;
    }
#line 110
    break;
    case 60: 
#line 113
    n_bytes ++;
#line 113
    tmp___43 = packet_get_char();
#line 113
    if (tmp___43) {
#line 113
      tio.c_lflag |= 512U;
    } else {
#line 113
      tio.c_lflag &= 4294966783U;
    }
#line 113
    break;
    case 61: 
#line 116
    n_bytes ++;
#line 116
    tmp___44 = packet_get_char();
#line 116
    if (tmp___44) {
#line 116
      tio.c_lflag |= 2048U;
    } else {
#line 116
      tio.c_lflag &= 4294965247U;
    }
#line 116
    break;
    case 62: 
#line 119
    n_bytes ++;
#line 119
    tmp___45 = packet_get_char();
#line 119
    if (tmp___45) {
#line 119
      tio.c_lflag |= 16384U;
    } else {
#line 119
      tio.c_lflag &= 4294950911U;
    }
#line 119
    break;
    case 70: 
#line 122
    n_bytes ++;
#line 122
    tmp___46 = packet_get_char();
#line 122
    if (tmp___46) {
#line 122
      tio.c_oflag |= 1U;
    } else {
#line 122
      tio.c_oflag &= 4294967294U;
    }
#line 122
    break;
    case 71: 
#line 124
    n_bytes ++;
#line 124
    tmp___47 = packet_get_char();
#line 124
    if (tmp___47) {
#line 124
      tio.c_oflag |= 2U;
    } else {
#line 124
      tio.c_oflag &= 4294967293U;
    }
#line 124
    break;
    case 72: 
#line 126
    n_bytes ++;
#line 126
    tmp___48 = packet_get_char();
#line 126
    if (tmp___48) {
#line 126
      tio.c_oflag |= 4U;
    } else {
#line 126
      tio.c_oflag &= 4294967291U;
    }
#line 126
    break;
    case 73: 
#line 128
    n_bytes ++;
#line 128
    tmp___49 = packet_get_char();
#line 128
    if (tmp___49) {
#line 128
      tio.c_oflag |= 8U;
    } else {
#line 128
      tio.c_oflag &= 4294967287U;
    }
#line 128
    break;
    case 74: 
#line 131
    n_bytes ++;
#line 131
    tmp___50 = packet_get_char();
#line 131
    if (tmp___50) {
#line 131
      tio.c_oflag |= 16U;
    } else {
#line 131
      tio.c_oflag &= 4294967279U;
    }
#line 131
    break;
    case 75: 
#line 134
    n_bytes ++;
#line 134
    tmp___51 = packet_get_char();
#line 134
    if (tmp___51) {
#line 134
      tio.c_oflag |= 32U;
    } else {
#line 134
      tio.c_oflag &= 4294967263U;
    }
#line 134
    break;
    case 90: 
#line 137
    n_bytes ++;
#line 137
    tmp___52 = packet_get_char();
#line 137
    if (tmp___52) {
#line 137
      tio.c_cflag |= 32U;
    } else {
#line 137
      tio.c_cflag &= 4294967263U;
    }
#line 137
    break;
    case 91: 
#line 138
    n_bytes ++;
#line 138
    tmp___53 = packet_get_char();
#line 138
    if (tmp___53) {
#line 138
      tio.c_cflag |= 48U;
    } else {
#line 138
      tio.c_cflag &= 4294967247U;
    }
#line 138
    break;
    case 92: 
#line 139
    n_bytes ++;
#line 139
    tmp___54 = packet_get_char();
#line 139
    if (tmp___54) {
#line 139
      tio.c_cflag |= 256U;
    } else {
#line 139
      tio.c_cflag &= 4294967039U;
    }
#line 139
    break;
    case 93: 
#line 140
    n_bytes ++;
#line 140
    tmp___55 = packet_get_char();
#line 140
    if (tmp___55) {
#line 140
      tio.c_cflag |= 512U;
    } else {
#line 140
      tio.c_cflag &= 4294966783U;
    }
#line 140
    break;
    default: 
#line 313 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 320
        n_bytes ++;
#line 321
        packet_get_char();
#line 322
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 329
          n_bytes += 4;
#line 330
          packet_get_int();
#line 331
          break;
        }
      }
    }
#line 341
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 342
    while (1) {
#line 342
      _p = 0;
#line 342
      _e = 1;
#line 342
      if (_p != _e) {
#line 342
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 342);
#line 342
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 342
      break;
    }
    goto set;
    }
  }
  set: 
#line 348
  if (*n_bytes_ptr != n_bytes) {
#line 349
    *n_bytes_ptr = n_bytes;
#line 350
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 34 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 30 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 38 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 43
  saved_euid = geteuid();
#line 46
  tmp___1 = seteuid(uid);
#line 46
  if (tmp___1 == -1) {
#line 47
    tmp = __errno_location();
#line 47
    tmp___0 = strerror(*tmp);
#line 47
    debug("seteuid %d: %.100s", (int )uid, tmp___0);
  }
#line 57
  return;
}
}
#line 62 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 67
  tmp___1 = seteuid(saved_euid);
#line 67
  if (tmp___1 < 0) {
#line 68
    tmp = __errno_location();
#line 68
    tmp___0 = strerror(*tmp);
#line 68
    debug("seteuid %d: %.100s", (int )saved_euid, tmp___0);
  }
#line 77
  return;
}
}
#line 83 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 86
  tmp___1 = setuid(uid);
#line 86
  if (tmp___1 < 0) {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror(*tmp);
#line 87
    debug("setuid %d: %.100s", (int )uid, tmp___0);
  }
#line 88
  return;
}
}
#line 1 "xmalloc.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 15 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 18
  tmp = malloc(size);
#line 18
  ptr = tmp;
#line 19
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 20
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 21
  return (ptr);
}
}
#line 24 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 31
  new_ptr = realloc(ptr, new_size);
#line 32
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 33
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 34
  return (new_ptr);
}
}
#line 37 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 40
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 41
    fatal("xfree: NULL pointer given as argument");
  }
#line 42
  free(ptr);
#line 43
  return;
}
}
#line 45 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 48
  tmp = strlen(str);
#line 48
  len = (int )(tmp + 1U);
#line 50
  tmp___0 = xmalloc((unsigned int )len);
#line 50
  cp = (char *)tmp___0;
#line 51
  strlcpy(cp, str, (unsigned int )len);
#line 52
  return (cp);
}
}
#line 1 "sshd.o"
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 747
extern void perror(char const   *__s ) ;
#line 759
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 103
extern struct group *getgrgid(__gid_t __gid ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 279 "ssh.h"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___0 ,
                                  unsigned int bufsize ) ;
#line 287
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) ;
#line 295
void record_logout(int pid , char const   *ttyname___0 ) ;
#line 334
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 340
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , BIGNUM *client_host_key_e ,
                    BIGNUM *client_host_key_n ) ;
#line 355
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 490
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 701
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 6 "auth-pam.h"
void start_pam(struct passwd *pw ) ;
#line 7
void finish_pam(void) ;
#line 8
int auth_pam_password(struct passwd *pw , char const   *password ) ;
#line 9
char **fetch_pam_environment(void) ;
#line 10
int do_pam_account(char *username , char *remote_user ) ;
#line 11
void do_pam_session(char *username , char const   *ttyname___0 ) ;
#line 12
void do_pam_setcred(void) ;
#line 13
void print_pam_messages(void) ;
#line 27 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 33
void pty_release(char const   *ttyname___0 ) ;
#line 39
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 42
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 46
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 95 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 101
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 104
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 40 "sshd.c"
static char *xauthfile  =    (char *)((void *)0);
#line 43 "sshd.c"
ServerOptions options  ;
#line 46 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 55 "sshd.c"
int IPv4or6  =    0;
#line 64 "sshd.c"
int debug_flag  =    0;
#line 67 "sshd.c"
int inetd_flag  =    0;
#line 70 "sshd.c"
int log_stderr  =    0;
#line 73 "sshd.c"
char *av0  ;
#line 76 "sshd.c"
char **saved_argv  ;
#line 83 "sshd.c"
int listen_socks[16]  ;
#line 84 "sshd.c"
int num_listen_socks  =    0;
#line 90 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 93 "sshd.c"
int no_port_forwarding_flag  =    0;
#line 94 "sshd.c"
int no_agent_forwarding_flag  =    0;
#line 95 "sshd.c"
int no_x11_forwarding_flag  =    0;
#line 96 "sshd.c"
int no_pty_flag  =    0;
#line 99 "sshd.c"
char *forced_command  =    (char *)((void *)0);
#line 102 "sshd.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 105 "sshd.c"
unsigned char session_id[16]  ;
#line 115 "sshd.c"
struct __anonstruct_sensitive_data_76 sensitive_data  ;
#line 124 "sshd.c"
int key_used  =    0;
#line 127 "sshd.c"
int received_sighup  =    0;
#line 131 "sshd.c"
RSA *public_key  ;
#line 134
void do_ssh_kex(void) ;
#line 135
void do_authentication(void) ;
#line 136
void do_authloop(struct passwd *pw ) ;
#line 137
void do_fake_authloop(char *user ) ;
#line 138
void do_authenticated(struct passwd *pw ) ;
#line 139
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) ;
#line 143
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) ;
#line 146
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 153 "sshd.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 156
  debug("xauthfile_cleanup_proc called");
#line 158
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 160
    unlink((char const   *)xauthfile);
#line 161
    p = strrchr((char const   *)xauthfile, '/');
#line 162
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 163
      *p = (char )'\000';
#line 164
      rmdir((char const   *)xauthfile);
    }
#line 166
    xfree((void *)xauthfile);
#line 167
    xauthfile = (char *)((void *)0);
  }
#line 169
  return;
}
}
#line 174 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 178
  i = 0;
#line 178
  while (i < num_listen_socks) {
#line 179
    close(listen_socks[i]);
#line 178
    i ++;
  }
#line 180
  num_listen_socks = -1;
#line 181
  return;
}
}
#line 188 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 191
  received_sighup = 1;
#line 192
  signal(1, & sighup_handler);
#line 193
  return;
}
}
#line 199 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 202
  log("Received SIGHUP; restarting.");
#line 203
  close_listen_socks();
#line 204
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 205
  tmp = __errno_location();
#line 205
  tmp___0 = strerror(*tmp);
#line 205
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 206
  exit(1);
}
}
#line 214 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 217
  log("Received signal %d; terminating.", sig);
#line 218
  close_listen_socks();
#line 219
  exit(255);
}
}
#line 226 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 229
  tmp = __errno_location();
#line 229
  save_errno = *tmp;
#line 232
  while (1) {
#line 232
    tmp___0 = waitpid(-1, & status, 1);
#line 232
    if (! (tmp___0 > 0)) {
#line 232
      break;
    }
  }
#line 235
  signal(17, & main_sigchld_handler);
#line 236
  tmp___1 = __errno_location();
#line 236
  *tmp___1 = save_errno;
#line 237
  return;
}
}
#line 242 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 246
  packet_close();
#line 249
  tmp = get_remote_ipaddr();
#line 249
  fatal("Timeout before authentication for %s.", tmp);
#line 250
  return;
}
}
#line 258 "sshd.c"
static char buf[1024]  ;
#line 255 "sshd.c"
char *get_authname(int type ) 
{ 

  {
#line 259
  switch (type) {
  case 9: 
#line 261
  return ((char *)"password");
  case 6: 
#line 263
  return ((char *)"rsa");
  case 35: 
#line 265
  return ((char *)"rhosts-rsa");
  case 5: 
#line 267
  return ((char *)"rhosts");
  }
#line 277
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 278
  return (buf);
}
}
#line 288 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 291
  tmp = __errno_location();
#line 291
  save_errno = *tmp;
#line 294
  if (key_used) {
#line 296
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 298
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 299
      RSA_free(sensitive_data.private_key);
    }
#line 300
    sensitive_data.private_key = RSA_new();
#line 302
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 303
      RSA_free(public_key);
    }
#line 304
    public_key = RSA_new();
#line 306
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 308
    arc4random_stir();
#line 309
    key_used = 0;
#line 310
    log("RSA key generation complete.");
  }
#line 313
  signal(14, & key_regeneration_alarm);
#line 314
  alarm((unsigned int )options.key_regeneration_time);
#line 315
  tmp___0 = __errno_location();
#line 315
  *tmp___0 = save_errno;
#line 316
  return;
}
}
#line 321 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int i ;
  int fdsetsz ;
  int pid ;
  int on ;
  socklen_t fromlen ;
  int remote_major ;
  int remote_minor ;
  int silentrsa ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char buf___0[100] ;
  char remote_version[100] ;
  char const   *remote_ip ;
  int remote_port ;
  char *comment ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  char *tmp ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int fd ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int s1 ;
  int s2 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  __pid_t tmp___29 ;
  void *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  int tmp___34 ;
  register char __result ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  int *tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  size_t tmp___44 ;
  ssize_t tmp___45 ;
  size_t tmp___46 ;
  ssize_t tmp___47 ;
  char *s ;
  size_t tmp___48 ;
  int tmp___49 ;
  char *s___0 ;
  size_t tmp___50 ;

  {
#line 326
  sock_in = 0;
#line 326
  sock_out = 0;
#line 326
  on = 1;
#line 329
  silentrsa = 0;
#line 344
  saved_argv = av;
#line 345
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 345
  if (tmp___1) {
#line 346
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 346
    av0 = tmp + 1;
  } else {
#line 348
    av0 = *(av + 0);
  }
#line 351
  initialize_server_options(& options);
#line 354
  while (1) {
#line 354
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:diqQ46");
#line 354
    if (! (opt != -1)) {
#line 354
      break;
    }
#line 355
    switch (opt) {
    case 52: 
#line 357
    IPv4or6 = 2;
#line 358
    break;
    case 54: 
#line 360
    IPv4or6 = 10;
#line 361
    break;
    case 102: 
#line 363
    config_file_name = optarg;
#line 364
    break;
    case 100: 
#line 366
    debug_flag = 1;
#line 367
    options.log_level = 5;
#line 368
    break;
    case 105: 
#line 370
    inetd_flag = 1;
#line 371
    break;
    case 81: 
#line 373
    silentrsa = 1;
#line 374
    break;
    case 113: 
#line 376
    options.log_level = 0;
#line 377
    break;
    case 98: 
#line 379
    options.server_key_bits = atoi((char const   *)optarg);
#line 380
    break;
    case 112: 
#line 382
    options.ports_from_cmdline = 1U;
#line 383
    if (options.num_ports >= 256U) {
#line 384
      fatal("too many ports.\n");
    }
#line 385
    tmp___2 = options.num_ports;
#line 385
    (options.num_ports) ++;
#line 385
    tmp___3 = atoi((char const   *)optarg);
#line 385
    options.ports[tmp___2] = (unsigned short )tmp___3;
#line 386
    break;
    case 103: 
#line 388
    options.login_grace_time = atoi((char const   *)optarg);
#line 389
    break;
    case 107: 
#line 391
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 392
    break;
    case 104: 
#line 394
    options.host_key_file = optarg;
#line 395
    break;
    case 86: 
#line 397
    client_version_string = optarg;
#line 399
    inetd_flag = 1;
#line 400
    break;
    case 63: 
    default: 
#line 403
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH-1.2.3");
#line 404
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 405
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 406
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 407
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 408
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 409
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 410
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 411
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 412
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 413
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 414
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 416
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 417
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 418
    exit(1);
    }
  }
#line 426
  if ((int )options.log_facility == -1) {
#line 426
    tmp___4 = 2;
  } else {
#line 426
    tmp___4 = (int )options.log_facility;
  }
#line 426
  if ((int )options.log_level == -1) {
#line 426
    tmp___5 = 3;
  } else {
#line 426
    tmp___5 = (int )options.log_level;
  }
#line 426
  log_init(av0, (enum __anonenum_LogLevel_73 )tmp___5, (enum __anonenum_SyslogFacility_72 )tmp___4,
           ! inetd_flag);
#line 432
  tmp___6 = rsa_alive();
#line 432
  if (tmp___6 == 0) {
#line 433
    if (silentrsa == 0) {
#line 434
      printf((char const   * __restrict  )"sshd: no RSA support in libssl and libcrypto -- exiting.  See ssl(8)\n");
    }
#line 435
    log("no RSA support in libssl and libcrypto -- exiting.  See ssl(8)");
#line 436
    exit(1);
  }
#line 439
  read_server_config(& options, (char const   *)config_file_name);
#line 442
  fill_default_server_options(& options);
#line 445
  if (options.server_key_bits < 512) {
#line 447
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 448
    exit(1);
  } else {
#line 445
    if (options.server_key_bits > 32768) {
#line 447
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 448
      exit(1);
    }
  }
#line 451
  if (optind < ac) {
#line 452
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 453
    exit(1);
  }
#line 456
  debug("sshd version %.100s", "OpenSSH-1.2.3");
#line 458
  sensitive_data.host_key = RSA_new();
#line 459
  tmp___7 = __errno_location();
#line 459
  *tmp___7 = 0;
#line 461
  tmp___10 = load_private_key((char const   *)options.host_key_file, "", sensitive_data.host_key,
                              & comment);
#line 461
  if (! tmp___10) {
#line 463
    tmp___8 = __errno_location();
#line 463
    tmp___9 = strerror(*tmp___8);
#line 463
    error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___9);
#line 465
    exit(1);
  }
#line 467
  xfree((void *)comment);
#line 471
  if (debug_flag) {
#line 471
    if (! inetd_flag) {
#line 472
      log_stderr = 1;
    }
  }
#line 473
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 478
  if (! debug_flag) {
#line 478
    if (! inetd_flag) {
#line 482
      tmp___13 = daemon(0, 0);
#line 482
      if (tmp___13 < 0) {
#line 483
        tmp___11 = __errno_location();
#line 483
        tmp___12 = strerror(*tmp___11);
#line 483
        fatal("daemon() failed: %.200s", tmp___12);
      }
#line 487
      fd = open("/dev/tty", 258);
#line 488
      if (fd >= 0) {
#line 489
        ioctl(fd, 21538UL, (void *)0);
#line 490
        close(fd);
      }
    }
  }
#line 495
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 500
  tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 500
  if (options.server_key_bits > tmp___15 - 128) {
#line 500
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 500
    if (options.server_key_bits < tmp___16 + 128) {
#line 504
      tmp___14 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 504
      options.server_key_bits = tmp___14 + 128;
#line 506
      debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
    }
  }
#line 510
  rsa_set_verbose(0);
#line 513
  arc4random_stir();
#line 517
  chdir("/");
#line 520
  cipher_attack_detected = (void (*)(char const   *fmt  , ...))(& packet_disconnect);
#line 523
  if (inetd_flag) {
#line 525
    s1 = dup(0);
#line 526
    s2 = dup(s1);
#line 527
    sock_in = dup(0);
#line 528
    sock_out = dup(1);
#line 532
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 534
    public_key = RSA_new();
#line 535
    sensitive_data.private_key = RSA_new();
#line 537
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 538
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 540
    arc4random_stir();
#line 541
    log("RSA key generation complete.");
  } else {
#line 543
    ai = options.listen_addrs;
#line 543
    while (ai) {
#line 544
      if (ai->ai_family != 2) {
#line 544
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 546
      if (num_listen_socks >= 16) {
#line 547
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 549
      tmp___17 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 549
      if (tmp___17 != 0) {
#line 552
        error("getnameinfo failed");
        goto __Cont;
      }
#line 556
      listen_sock = socket(ai->ai_family, 1, 0);
#line 557
      if (listen_sock < 0) {
#line 559
        tmp___18 = __errno_location();
#line 559
        tmp___19 = strerror(*tmp___18);
#line 559
        verbose("socket: %.100s", tmp___19);
        goto __Cont;
      }
#line 562
      tmp___22 = fcntl(listen_sock, 4, 2048);
#line 562
      if (tmp___22 < 0) {
#line 563
        tmp___20 = __errno_location();
#line 563
        tmp___21 = strerror(*tmp___20);
#line 563
        error("listen_sock O_NONBLOCK: %s", tmp___21);
#line 564
        close(listen_sock);
        goto __Cont;
      }
#line 573
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 575
      linger.l_onoff = 1;
#line 576
      linger.l_linger = 5;
#line 577
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 580
      debug("Bind to port %s on %s.", strport, ntop);
#line 583
      tmp___25 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 583
      if (tmp___25 < 0) {
#line 583
        if (! ai->ai_next) {
#line 585
          tmp___23 = __errno_location();
#line 585
          tmp___24 = strerror(*tmp___23);
#line 585
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___24);
#line 587
          close(listen_sock);
          goto __Cont;
        }
      }
#line 590
      listen_socks[num_listen_socks] = listen_sock;
#line 591
      num_listen_socks ++;
#line 594
      log("Server listening on %s port %s.", ntop, strport);
#line 595
      tmp___28 = listen(listen_sock, 5);
#line 595
      if (tmp___28 < 0) {
#line 596
        tmp___26 = __errno_location();
#line 596
        tmp___27 = strerror(*tmp___26);
#line 596
        fatal("listen: %.100s", tmp___27);
      }
      __Cont: /* CIL Label */ 
#line 543
      ai = ai->ai_next;
    }
#line 599
    freeaddrinfo(options.listen_addrs);
#line 601
    if (! num_listen_socks) {
#line 602
      fatal("Cannot bind any address.");
    }
#line 604
    if (! debug_flag) {
#line 612
      f = fopen((char const   * __restrict  )"/var/run/sshd.pid", (char const   * __restrict  )"w");
#line 613
      if (f) {
#line 614
        tmp___29 = getpid();
#line 614
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___29);
#line 615
        fclose(f);
      }
    }
#line 619
    public_key = RSA_new();
#line 620
    sensitive_data.private_key = RSA_new();
#line 622
    log("Generating %d bit RSA key.", options.server_key_bits);
#line 623
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 625
    arc4random_stir();
#line 626
    log("RSA key generation complete.");
#line 629
    signal(14, & key_regeneration_alarm);
#line 630
    alarm((unsigned int )options.key_regeneration_time);
#line 633
    signal(1, & sighup_handler);
#line 634
    signal(15, & sigterm_handler);
#line 635
    signal(3, & sigterm_handler);
#line 638
    signal(17, & main_sigchld_handler);
#line 641
    maxfd = 0;
#line 642
    i = 0;
#line 642
    while (i < num_listen_socks) {
#line 643
      if (listen_socks[i] > maxfd) {
#line 644
        maxfd = listen_socks[i];
      }
#line 642
      i ++;
    }
#line 645
    fdsetsz = (int )((((unsigned int )maxfd + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 646
    tmp___30 = xmalloc((unsigned int )fdsetsz);
#line 646
    fdset = (fd_set *)tmp___30;
#line 652
    while (1) {
#line 653
      if (received_sighup) {
#line 654
        sighup_restart();
      }
#line 656
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 657
      i = 0;
#line 657
      while (i < num_listen_socks) {
#line 658
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 657
        i ++;
      }
#line 659
      tmp___34 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 659
      if (tmp___34 < 0) {
#line 660
        tmp___33 = __errno_location();
#line 660
        if (*tmp___33 != 4) {
#line 661
          tmp___31 = __errno_location();
#line 661
          tmp___32 = strerror(*tmp___31);
#line 661
          error("select: %.100s", tmp___32);
        }
        goto __Cont___0;
      }
#line 664
      i = 0;
#line 664
      while (i < num_listen_socks) {
#line 665
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 665
        if (! __result) {
          goto __Cont___1;
        }
#line 667
        fromlen = sizeof(from);
#line 668
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 670
        if (newsock < 0) {
#line 671
          tmp___37 = __errno_location();
#line 671
          if (*tmp___37 != 4) {
#line 671
            tmp___38 = __errno_location();
#line 671
            if (*tmp___38 != 11) {
#line 672
              tmp___35 = __errno_location();
#line 672
              tmp___36 = strerror(*tmp___35);
#line 672
              error("accept: %.100s", tmp___36);
            }
          }
          goto __Cont___1;
        }
#line 675
        tmp___41 = fcntl(newsock, 4, 0);
#line 675
        if (tmp___41 < 0) {
#line 676
          tmp___39 = __errno_location();
#line 676
          tmp___40 = strerror(*tmp___39);
#line 676
          error("newsock del O_NONBLOCK: %s", tmp___40);
          goto __Cont___1;
        }
#line 683
        if (debug_flag) {
#line 689
          debug("Server will not fork when running in debugging mode.");
#line 690
          close_listen_socks();
#line 691
          sock_in = newsock;
#line 692
          sock_out = newsock;
#line 693
          pid = getpid();
#line 694
          break;
        } else {
#line 701
          pid = fork();
#line 701
          if (pid == 0) {
#line 707
            close_listen_socks();
#line 708
            sock_in = newsock;
#line 709
            sock_out = newsock;
#line 710
            log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 711
            break;
          }
        }
#line 716
        if (pid < 0) {
#line 717
          tmp___42 = __errno_location();
#line 717
          tmp___43 = strerror(*tmp___42);
#line 717
          error("fork: %.100s", tmp___43);
        } else {
#line 719
          debug("Forked child %d.", pid);
        }
#line 722
        key_used = 1;
#line 724
        arc4random_stir();
#line 727
        close(newsock);
        __Cont___1: /* CIL Label */ 
#line 664
        i ++;
      }
#line 730
      if (num_listen_socks < 0) {
#line 731
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
  }
#line 742
  alarm(0U);
#line 743
  signal(14, (void (*)(int  ))0);
#line 744
  signal(1, (void (*)(int  ))0);
#line 745
  signal(15, (void (*)(int  ))0);
#line 746
  signal(3, (void (*)(int  ))0);
#line 747
  signal(17, (void (*)(int  ))0);
#line 755
  linger.l_onoff = 1;
#line 756
  linger.l_linger = 5;
#line 757
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 763
  packet_set_connection(sock_in, sock_out);
#line 765
  remote_port = get_remote_port();
#line 766
  remote_ip = get_remote_ipaddr();
#line 786
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 796
  signal(14, & grace_alarm_handler);
#line 797
  if (! debug_flag) {
#line 798
    alarm((unsigned int )options.login_grace_time);
  }
#line 800
  if ((unsigned int )client_version_string != (unsigned int )((void *)0)) {
#line 802
    strlcpy(buf___0, (char const   *)client_version_string, sizeof(buf___0));
  } else {
#line 805
    snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
             1, 5, "OpenSSH-1.2.3");
#line 807
    tmp___44 = strlen((char const   *)(buf___0));
#line 807
    tmp___45 = atomicio((ssize_t (*)())(& write), sock_out, (void *)(buf___0), tmp___44);
#line 807
    tmp___46 = strlen((char const   *)(buf___0));
#line 807
    if ((size_t )tmp___45 != tmp___46) {
#line 808
      log("Could not write ident string to %s.", remote_ip);
#line 809
      fatal_cleanup();
    }
#line 813
    i = 0;
#line 813
    while ((unsigned int )i < sizeof(buf___0) - 1U) {
#line 814
      tmp___47 = read(sock_in, (void *)(& buf___0[i]), 1U);
#line 814
      if (tmp___47 != 1) {
#line 815
        log("Did not receive ident string from %s.", remote_ip);
#line 816
        fatal_cleanup();
      }
#line 818
      if ((int )buf___0[i] == 13) {
#line 819
        buf___0[i] = (char )'\n';
#line 820
        buf___0[i + 1] = (char)0;
#line 821
        break;
      }
#line 823
      if ((int )buf___0[i] == 10) {
#line 825
        buf___0[i + 1] = (char)0;
#line 826
        break;
      }
#line 813
      i ++;
    }
#line 829
    buf___0[sizeof(buf___0) - 1U] = (char)0;
  }
#line 836
  tmp___49 = sscanf((char const   * __restrict  )(buf___0), (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 836
  if (tmp___49 != 3) {
#line 838
    s = (char *)"Protocol mismatch.\n";
#line 840
    tmp___48 = strlen((char const   *)s);
#line 840
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___48);
#line 841
    close(sock_in);
#line 842
    close(sock_out);
#line 843
    log("Bad protocol version identification \'%.100s\' from %s", buf___0, remote_ip);
#line 845
    fatal_cleanup();
  }
#line 847
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 849
  if (remote_major != 1) {
#line 850
    s___0 = (char *)"Protocol major versions differ.\n";
#line 852
    tmp___50 = strlen((char const   *)s___0);
#line 852
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s___0, tmp___50);
#line 853
    close(sock_in);
#line 854
    close(sock_out);
#line 855
    log("Protocol major versions differ for %s: %d vs. %d", remote_ip, 1, remote_major);
#line 857
    fatal_cleanup();
  }
#line 860
  if (remote_major == 1) {
#line 860
    if (remote_minor < 3) {
#line 861
      packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
    }
  }
#line 863
  if (remote_major == 1) {
#line 863
    if (remote_minor == 3) {
#line 865
      enable_compat13();
    }
  }
#line 874
  if (remote_port >= 1024) {
#line 876
    options.rhosts_authentication = 0;
#line 877
    options.rhosts_rsa_authentication = 0;
  } else {
#line 874
    if (remote_port < 512) {
#line 876
      options.rhosts_authentication = 0;
#line 877
      options.rhosts_rsa_authentication = 0;
    }
  }
#line 887
  packet_set_nonblocking();
#line 890
  do_ssh_kex();
#line 893
  do_authentication();
#line 902
  if (xauthfile) {
#line 903
    xauthfile_cleanup_proc((void *)0);
  }
#line 906
  verbose("Closing connection to %.100s", remote_ip);
#line 909
  finish_pam();
#line 912
  packet_close();
#line 913
  exit(0);
}
}
#line 919 "sshd.c"
void do_ssh_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char cookie[8] ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;

  {
#line 928
  rand___0 = (u_int32_t )0;
#line 939
  i = 0;
#line 939
  while (i < 8) {
#line 940
    if (i % 4 == 0) {
#line 941
      rand___0 = arc4random();
    }
#line 942
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 943
    rand___0 >>= 8;
#line 939
    i ++;
  }
#line 951
  packet_start(2);
#line 952
  i = 0;
#line 952
  while (i < 8) {
#line 953
    packet_put_char((int )cookie[i]);
#line 952
    i ++;
  }
#line 956
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 956
  packet_put_int((unsigned int )tmp);
#line 957
  packet_put_bignum(public_key->e);
#line 958
  packet_put_bignum(public_key->n);
#line 961
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 961
  packet_put_int((unsigned int )tmp___0);
#line 962
  packet_put_bignum((sensitive_data.host_key)->e);
#line 963
  packet_put_bignum((sensitive_data.host_key)->n);
#line 966
  packet_put_int(2U);
#line 969
  tmp___1 = cipher_mask();
#line 969
  packet_put_int(tmp___1);
#line 972
  auth_mask = 0U;
#line 973
  if (options.rhosts_authentication) {
#line 974
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 975
  if (options.rhosts_rsa_authentication) {
#line 976
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 977
  if (options.rsa_authentication) {
#line 978
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 993
  if (options.password_authentication) {
#line 994
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 995
  packet_put_int(auth_mask);
#line 998
  packet_send();
#line 999
  packet_write_wait();
#line 1001
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1001
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1001
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 1005
  packet_read_expect(& plen, 3);
#line 1008
  cipher_type___0 = packet_get_char();
#line 1010
  tmp___4 = cipher_mask();
#line 1010
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1011
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1015
  i = 0;
#line 1015
  while (i < 8) {
#line 1016
    tmp___5 = packet_get_char();
#line 1016
    if ((unsigned int )cookie[i] != tmp___5) {
#line 1017
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1015
    i ++;
  }
#line 1019
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1019
  debug("Encryption type: %.200s", tmp___6);
#line 1022
  session_key_int = BN_new();
#line 1023
  packet_get_bignum(session_key_int, & slen);
#line 1025
  protocol_flags = packet_get_int();
#line 1026
  packet_set_protocol_flags(protocol_flags);
#line 1028
  while (1) {
#line 1028
    _p = plen;
#line 1028
    _e = (9 + slen) + 4;
#line 1028
    if (_p != _e) {
#line 1028
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1028);
#line 1028
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1028
    break;
  }
#line 1034
  tmp___17 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1034
  if (tmp___17 > 0) {
#line 1036
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1036
    tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1036
    if (tmp___10 < tmp___11 + 128) {
#line 1038
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1038
      tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1038
      tmp___9 = get_remote_ipaddr();
#line 1038
      fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1044
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 1046
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1050
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1050
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1050
    if (tmp___15 < tmp___16 + 128) {
#line 1052
      tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1052
      tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1052
      tmp___14 = get_remote_ipaddr();
#line 1052
      fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___14, tmp___13, tmp___12, 128);
    }
#line 1058
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1060
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1064
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(cookie), (sensitive_data.host_key)->n,
                     (sensitive_data.private_key)->n);
#line 1069
  RSA_free(public_key);
#line 1070
  RSA_free(sensitive_data.private_key);
#line 1071
  RSA_free(sensitive_data.host_key);
#line 1078
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1079
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1079
  len = (tmp___18 + 7) / 8;
#line 1080
  if (len < 0) {
#line 1081
    tmp___19 = get_remote_ipaddr();
#line 1081
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
          tmp___19, len, sizeof(session_key));
  } else {
#line 1080
    if ((unsigned int )len > sizeof(session_key)) {
#line 1081
      tmp___19 = get_remote_ipaddr();
#line 1081
      fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
            tmp___19, len, sizeof(session_key));
    }
  }
#line 1084
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1085
  BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1088
  BN_clear_free(session_key_int);
#line 1091
  i = 0;
#line 1091
  while (i < 16) {
#line 1092
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1091
    i ++;
  }
#line 1095
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1098
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1100
  debug("Received session key; encryption turned on.");
#line 1103
  packet_start(14);
#line 1104
  packet_send();
#line 1105
  packet_write_wait();
#line 1106
  return;
}
}
#line 1118 "sshd.c"
static int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  struct group *grp ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1129
  if (! pw) {
#line 1130
    return (0);
  }
#line 1133
  tmp = stat((char const   * __restrict  )pw->pw_shell, (struct stat * __restrict  )(& st));
#line 1133
  if (tmp != 0) {
#line 1134
    return (0);
  }
#line 1135
  if (st.st_mode & 32768U) {
#line 1135
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 1136
      return (0);
    }
  } else {
#line 1136
    return (0);
  }
#line 1139
  if (options.num_deny_users > 0U) {
#line 1140
    if (! pw->pw_name) {
#line 1141
      return (0);
    }
#line 1142
    i = 0;
#line 1142
    while ((unsigned int )i < options.num_deny_users) {
#line 1143
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 1143
      if (tmp___0) {
#line 1144
        return (0);
      }
#line 1142
      i ++;
    }
  }
#line 1147
  if (options.num_allow_users > 0U) {
#line 1148
    if (! pw->pw_name) {
#line 1149
      return (0);
    }
#line 1150
    i = 0;
#line 1150
    while ((unsigned int )i < options.num_allow_users) {
#line 1151
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 1151
      if (tmp___1) {
#line 1152
        break;
      }
#line 1150
      i ++;
    }
#line 1154
    if ((unsigned int )i >= options.num_allow_users) {
#line 1155
      return (0);
    }
  }
#line 1158
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 1158
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 1159
      grp = getgrgid(pw->pw_gid);
#line 1160
      if (! grp) {
#line 1161
        return (0);
      }
#line 1164
      if (options.num_deny_groups > 0U) {
#line 1165
        if (! grp->gr_name) {
#line 1166
          return (0);
        }
#line 1167
        i = 0;
#line 1167
        while ((unsigned int )i < options.num_deny_groups) {
#line 1168
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 1168
          if (tmp___2) {
#line 1169
            return (0);
          }
#line 1167
          i ++;
        }
      }
#line 1175
      if (options.num_allow_groups > 0U) {
#line 1176
        if (! grp->gr_name) {
#line 1177
          return (0);
        }
#line 1178
        i = 0;
#line 1178
        while ((unsigned int )i < options.num_allow_groups) {
#line 1179
          tmp___3 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 1179
          if (tmp___3) {
#line 1180
            break;
          }
#line 1178
          i ++;
        }
#line 1183
        if ((unsigned int )i >= options.num_allow_groups) {
#line 1184
          return (0);
        }
      }
    }
  }
#line 1194
  return (1);
}
}
#line 1201 "sshd.c"
void do_authentication(void) 
{ struct passwd *pw ;
  struct passwd pwcopy ;
  int plen ;
  unsigned int ulen ;
  char *user ;
  int _p ;
  int _e ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 1210
  packet_read_expect(& plen, 4);
#line 1213
  user = packet_get_string(& ulen);
#line 1214
  while (1) {
#line 1214
    _p = plen;
#line 1214
    _e = (int )(4U + ulen);
#line 1214
    if (_p != _e) {
#line 1214
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1214);
#line 1214
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 1214
    break;
  }
#line 1216
  setproctitle("%s", user);
#line 1231
  pw = getpwnam((char const   *)user);
#line 1232
  if (! pw) {
#line 1233
    do_fake_authloop(user);
  } else {
#line 1232
    tmp = allowed_user(pw);
#line 1232
    if (! tmp) {
#line 1233
      do_fake_authloop(user);
    }
  }
#line 1234
  xfree((void *)user);
#line 1237
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 1238
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 1239
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 1240
  pwcopy.pw_uid = pw->pw_uid;
#line 1241
  pwcopy.pw_gid = pw->pw_gid;
#line 1242
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 1243
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 1244
  pw = & pwcopy;
#line 1247
  start_pam(pw);
#line 1254
  tmp___0 = getuid();
#line 1254
  if (tmp___0 != 0U) {
#line 1254
    tmp___1 = getuid();
#line 1254
    if (pw->pw_uid != tmp___1) {
#line 1255
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 1257
  debug("Attempting authentication for %.100s.", pw->pw_name);
#line 1260
  if (options.password_authentication) {
#line 1260
    tmp___3 = auth_pam_password(pw, "");
#line 1260
    if (tmp___3) {
#line 1270
      tmp___2 = get_remote_ipaddr();
#line 1270
      log("Login for user %s from %.100s, accepted without authentication.", pw->pw_name,
          tmp___2);
    } else {
#line 1276
      do_authloop(pw);
    }
  } else {
#line 1276
    do_authloop(pw);
  }
#line 1283
  packet_start(14);
#line 1284
  packet_send();
#line 1285
  packet_write_wait();
#line 1288
  do_authenticated(pw);
#line 1289
  return;
}
}
#line 1299 "sshd.c"
void do_authloop(struct passwd *pw ) 
{ int attempt ;
  unsigned int bits ;
  BIGNUM *client_host_key_e ;
  BIGNUM *client_host_key_n ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char user[1024] ;
  unsigned int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  unsigned int ulen ;
  int type ;
  void (*authlog)(char const   *fmt  , ...) ;
  int authenticated ;
  int _p ;
  int _e ;
  int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 1302
  attempt = 0;
#line 1306
  client_user = (char *)((void *)0);
#line 1306
  password = (char *)((void *)0);
#line 1311
  type = 0;
#line 1312
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 1315
  packet_start(15);
#line 1316
  packet_send();
#line 1317
  packet_write_wait();
#line 1319
  attempt = 1;
#line 1319
  while (1) {
#line 1320
    authenticated = 0;
#line 1321
    strlcpy(user, "", sizeof(user));
#line 1324
    type = packet_read(& plen);
#line 1327
    switch (type) {
    case 5: 
#line 1387
    if (! options.rhosts_authentication) {
#line 1388
      verbose("Rhosts authentication disabled.");
#line 1389
      break;
    }
#line 1397
    client_user = packet_get_string(& ulen);
#line 1398
    while (1) {
#line 1398
      _p = plen;
#line 1398
      _e = (int )(4U + ulen);
#line 1398
      if (_p != _e) {
#line 1398
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1398);
#line 1398
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1398
      break;
    }
#line 1402
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 1404
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 1405
    break;
    case 35: 
#line 1408
    if (! options.rhosts_rsa_authentication) {
#line 1409
      verbose("Rhosts with RSA authentication disabled.");
#line 1410
      break;
    }
#line 1417
    client_user = packet_get_string(& ulen);
#line 1420
    client_host_key_e = BN_new();
#line 1421
    client_host_key_n = BN_new();
#line 1422
    bits = packet_get_int();
#line 1423
    packet_get_bignum(client_host_key_e, & elen);
#line 1424
    packet_get_bignum(client_host_key_n, & nlen);
#line 1426
    tmp___0 = BN_num_bits((BIGNUM const   *)client_host_key_n);
#line 1426
    if (bits != (unsigned int )tmp___0) {
#line 1427
      tmp = BN_num_bits((BIGNUM const   *)client_host_key_n);
#line 1427
      error("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
            tmp, bits);
    }
#line 1429
    while (1) {
#line 1429
      _p___0 = plen;
#line 1429
      _e___0 = (int )((((4U + ulen) + 4U) + (unsigned int )elen) + (unsigned int )nlen);
#line 1429
      if (_p___0 != _e___0) {
#line 1429
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1429);
#line 1429
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1429
      break;
    }
#line 1431
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key_e,
                                    client_host_key_n);
#line 1433
    BN_clear_free(client_host_key_e);
#line 1434
    BN_clear_free(client_host_key_n);
#line 1436
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 1437
    break;
    case 6: 
#line 1440
    if (! options.rsa_authentication) {
#line 1441
      verbose("RSA authentication disabled.");
#line 1442
      break;
    }
#line 1445
    n___0 = BN_new();
#line 1446
    packet_get_bignum(n___0, & nlen);
#line 1447
    while (1) {
#line 1447
      _p___1 = plen;
#line 1447
      _e___1 = nlen;
#line 1447
      if (_p___1 != _e___1) {
#line 1447
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1447);
#line 1447
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1447
      break;
    }
#line 1448
    authenticated = auth_rsa(pw, n___0);
#line 1449
    BN_clear_free(n___0);
#line 1450
    break;
    case 9: 
#line 1453
    if (! options.password_authentication) {
#line 1454
      verbose("Password authentication disabled.");
#line 1455
      break;
    }
#line 1462
    password = packet_get_string(& dlen);
#line 1463
    while (1) {
#line 1463
      _p___2 = plen;
#line 1463
      _e___2 = (int )(4U + dlen);
#line 1463
      if (_p___2 != _e___2) {
#line 1463
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1463);
#line 1463
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1463
      break;
    }
#line 1467
    authenticated = auth_pam_password(pw, (char const   *)password);
#line 1472
    tmp___1 = strlen((char const   *)password);
#line 1472
    memset((void *)password, 0, tmp___1);
#line 1473
    xfree((void *)password);
#line 1474
    break;
    case 39: 
#line 1510
    log("TIS authentication unsupported.");
#line 1511
    break;
    default: 
#line 1519
    log("Unknown message during authentication: type %d", type);
#line 1520
    break;
    }
#line 1528
    if (authenticated) {
#line 1528
      if (pw->pw_uid == 0U) {
#line 1528
        if (! options.permit_root_login) {
#line 1529
          if (forced_command) {
#line 1530
            log("Root login accepted for forced command.");
          } else {
#line 1532
            authenticated = 0;
#line 1533
            tmp___2 = get_canonical_hostname();
#line 1533
            log("ROOT LOGIN REFUSED FROM %.200s", tmp___2);
          }
        }
      }
    }
#line 1539
    if (authenticated) {
#line 1542
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 1539
      if (attempt == 3) {
#line 1542
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 1539
        if (type == 9) {
#line 1542
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
#line 1544
    tmp___3 = get_remote_port();
#line 1544
    tmp___4 = get_remote_ipaddr();
#line 1544
    if (pw->pw_uid == 0U) {
#line 1544
      tmp___5 = "ROOT";
    } else {
#line 1544
      tmp___5 = (char const   *)pw->pw_name;
    }
#line 1544
    tmp___6 = get_authname(type);
#line 1544
    if (authenticated) {
#line 1544
      tmp___7 = "Accepted";
    } else {
#line 1544
      tmp___7 = "Failed";
    }
#line 1544
    (*authlog)("%s %s for %.200s from %.200s port %d%s", tmp___7, tmp___6, tmp___5,
               tmp___4, tmp___3, user);
#line 1553
    if (authenticated) {
#line 1554
      tmp___8 = do_pam_account(pw->pw_name, client_user);
#line 1554
      if (! tmp___8) {
#line 1555
        if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 1556
          xfree((void *)client_user);
#line 1557
          client_user = (char *)((void *)0);
        }
#line 1559
        do_fake_authloop(pw->pw_name);
      }
#line 1561
      return;
    }
#line 1569
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 1570
      xfree((void *)client_user);
#line 1571
      client_user = (char *)((void *)0);
    }
#line 1574
    if (attempt > 6) {
#line 1575
      packet_disconnect("Too many authentication failures for %.100s", pw->pw_name);
    }
#line 1578
    packet_start(15);
#line 1579
    packet_send();
#line 1580
    packet_write_wait();
#line 1319
    attempt ++;
  }
}
}
#line 1588 "sshd.c"
void do_fake_authloop(char *user ) 
{ int attempt ;
  int tmp ;
  char const   *tmp___0 ;
  int plen ;

  {
#line 1591
  attempt = 0;
#line 1593
  tmp = get_remote_port();
#line 1593
  tmp___0 = get_remote_ipaddr();
#line 1593
  log("Faking authloop for illegal user %.200s from %.200s port %d", user, tmp___0,
      tmp);
#line 1599
  packet_start(15);
#line 1600
  packet_send();
#line 1601
  packet_write_wait();
#line 1607
  attempt = 1;
#line 1607
  while (1) {
#line 1611
    packet_read(& plen);
#line 1637
    if (attempt > 6) {
#line 1638
      packet_disconnect("Too many authentication failures for %.100s", user);
    }
#line 1644
    packet_start(15);
#line 1645
    packet_send();
#line 1646
    packet_write_wait();
#line 1607
    attempt ++;
  }
#line 1654
  abort();
}
}
#line 1666 "sshd.c"
void pty_cleanup_proc(void *context ) 
{ struct pty_cleanup_context *cu ;

  {
#line 1669
  cu = (struct pty_cleanup_context *)context;
#line 1671
  debug("pty_cleanup_proc called");
#line 1674
  record_logout(cu->pid, cu->ttyname);
#line 1677
  pty_release(cu->ttyname);
#line 1678
  return;
}
}
#line 1681 "sshd.c"
static void pty_release_proc(void *tty ) 
{ char *ttyname___0 ;

  {
#line 1684
  ttyname___0 = (char *)tty;
#line 1685
  pty_release((char const   *)ttyname___0);
#line 1686
  return;
}
}
#line 1694 "sshd.c"
void do_authenticated(struct passwd *pw ) 
{ int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  int ptyfd ;
  int ttyfd ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int screen ;
  char ttyname___0[64] ;
  char *command ;
  char *term ;
  char *display ;
  char *proto ;
  char *data ;
  int plen ;
  unsigned int dlen ;
  int n_bytes ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  unsigned int proto_len ;
  unsigned int data_len ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  void *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int _p___3 ;
  int _e___3 ;
  int tmp___25 ;
  unsigned int dlen___0 ;
  int _p___4 ;
  int _e___4 ;

  {
#line 1698
  compression_level = 0;
#line 1698
  enable_compression_after_reply = 0;
#line 1699
  have_pty = 0;
#line 1699
  ptyfd = -1;
#line 1699
  ttyfd = -1;
#line 1702
  term = (char *)((void *)0);
#line 1702
  display = (char *)((void *)0);
#line 1702
  proto = (char *)((void *)0);
#line 1702
  data = (char *)((void *)0);
#line 1711
  alarm(0U);
#line 1720
  if (! no_port_forwarding_flag) {
#line 1721
    channel_permit_all_opens();
  }
#line 1727
  while (1) {
#line 1730
    type = packet_read(& plen);
#line 1733
    switch (type) {
    case 37: 
#line 1735
    while (1) {
#line 1735
      _p = plen;
#line 1735
      _e = 4;
#line 1735
      if (_p != _e) {
#line 1735
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1735);
#line 1735
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1735
      break;
    }
#line 1736
    tmp = packet_get_int();
#line 1736
    compression_level = (int )tmp;
#line 1737
    if (compression_level < 1) {
#line 1738
      packet_send_debug("Received illegal compression level %d.", compression_level);
      goto fail;
    } else {
#line 1737
      if (compression_level > 9) {
#line 1738
        packet_send_debug("Received illegal compression level %d.", compression_level);
        goto fail;
      }
    }
#line 1743
    enable_compression_after_reply = 1;
#line 1744
    break;
    case 10: 
#line 1747
    if (no_pty_flag) {
#line 1748
      debug("Allocating a pty not permitted for this authentication.");
      goto fail;
    }
#line 1751
    if (have_pty) {
#line 1752
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 1754
    debug("Allocating pty.");
#line 1757
    tmp___0 = pty_allocate(& ptyfd, & ttyfd, ttyname___0, (int )sizeof(ttyname___0));
#line 1757
    if (! tmp___0) {
#line 1759
      error("Failed to allocate pty.");
      goto fail;
    }
#line 1762
    fatal_add_cleanup(& pty_release_proc, (void *)(ttyname___0));
#line 1763
    pty_setowner(pw, (char const   *)(ttyname___0));
#line 1766
    term = packet_get_string(& dlen);
#line 1767
    while (1) {
#line 1767
      _p___0 = (int )dlen;
#line 1767
      tmp___1 = strlen((char const   *)term);
#line 1767
      _e___0 = (int )tmp___1;
#line 1767
      if (_p___0 != _e___0) {
#line 1767
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "sshd.c",
            1767);
#line 1767
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1767
      break;
    }
#line 1770
    n_bytes = (int )((unsigned int )plen - ((4U + dlen) + 16U));
#line 1772
    if (0) {
#line 1772
      __s1_len = strlen((char const   *)term);
#line 1772
      __s2_len = strlen("");
#line 1772
      if (! ((unsigned int )((void const   *)(term + 1)) - (unsigned int )((void const   *)term) == 1U)) {
        goto _L___0;
      } else {
#line 1772
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1772
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1772
            tmp___11 = 1;
          } else {
#line 1772
            if (__s2_len >= 4U) {
#line 1772
              tmp___11 = 1;
            } else {
#line 1772
              tmp___11 = 0;
            }
          }
        } else {
#line 1772
          tmp___11 = 0;
        }
      }
#line 1772
      if (tmp___11) {
#line 1772
        tmp___7 = __builtin_strcmp((char const   *)term, "");
      } else {
#line 1772
        tmp___10 = __builtin_strcmp((char const   *)term, "");
#line 1772
        tmp___7 = tmp___10;
      }
    } else {
#line 1772
      tmp___10 = __builtin_strcmp((char const   *)term, "");
#line 1772
      tmp___7 = tmp___10;
    }
#line 1772
    if (tmp___7 == 0) {
#line 1773
      xfree((void *)term);
#line 1774
      term = (char *)((void *)0);
    }
#line 1778
    tmp___12 = packet_get_int();
#line 1778
    row = (int )tmp___12;
#line 1779
    tmp___13 = packet_get_int();
#line 1779
    col = (int )tmp___13;
#line 1780
    tmp___14 = packet_get_int();
#line 1780
    xpixel = (int )tmp___14;
#line 1781
    tmp___15 = packet_get_int();
#line 1781
    ypixel = (int )tmp___15;
#line 1782
    pty_change_window_size(ptyfd, row, col, xpixel, ypixel);
#line 1785
    tty_parse_modes(ttyfd, & n_bytes);
#line 1786
    while (1) {
#line 1786
      _p___1 = plen;
#line 1786
      _e___1 = (int )(((4U + dlen) + 16U) + (unsigned int )n_bytes);
#line 1786
      if (_p___1 != _e___1) {
#line 1786
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "sshd.c",
            1786);
#line 1786
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1786
      break;
    }
#line 1789
    have_pty = 1;
#line 1790
    break;
    case 34: 
#line 1793
    if (! options.x11_forwarding) {
#line 1794
      packet_send_debug("X11 forwarding disabled in server configuration file.");
      goto fail;
    }
#line 1798
    if (no_x11_forwarding_flag) {
#line 1799
      packet_send_debug("X11 forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1802
    debug("Received request for X11 forwarding with auth spoofing.");
#line 1803
    if (display) {
#line 1804
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 1807
    proto = packet_get_string(& proto_len);
#line 1808
    data = packet_get_string(& data_len);
#line 1809
    while (1) {
#line 1809
      _p___2 = plen;
#line 1809
      _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 1809
      if (_p___2 != _e___2) {
#line 1809
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "sshd.c",
            1809);
#line 1809
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1809
      break;
    }
#line 1811
    tmp___17 = packet_get_protocol_flags();
#line 1811
    if (tmp___17 & 1U) {
#line 1812
      tmp___16 = packet_get_int();
#line 1812
      screen = (int )tmp___16;
    } else {
#line 1814
      screen = 0;
    }
#line 1815
    display = x11_create_display_inet(screen, options.x11_display_offset);
#line 1816
    if (! display) {
      goto fail;
    }
#line 1820
    tmp___18 = xmalloc(4096U);
#line 1820
    xauthfile = (char *)tmp___18;
#line 1821
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1822
    temporarily_use_uid(pw->pw_uid);
#line 1823
    tmp___21 = mkdtemp(xauthfile);
#line 1823
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
#line 1824
      restore_uid();
#line 1825
      tmp___19 = __errno_location();
#line 1825
      tmp___20 = strerror(*tmp___19);
#line 1825
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___20);
#line 1827
      xfree((void *)xauthfile);
#line 1828
      xauthfile = (char *)((void *)0);
      goto fail;
    }
#line 1831
    strlcat(xauthfile, "/cookies", 4096U);
#line 1832
    open((char const   *)xauthfile, 194, 384);
#line 1833
    restore_uid();
#line 1834
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 1835
    break;
    case 30: 
#line 1842
    if (no_agent_forwarding_flag) {
#line 1843
      debug("Authentication agent forwarding not permitted for this authentication.");
      goto fail;
    } else {
#line 1842
      if (compat13) {
#line 1843
        debug("Authentication agent forwarding not permitted for this authentication.");
        goto fail;
      }
    }
#line 1846
    debug("Received authentication agent forwarding request.");
#line 1847
    auth_input_request_forwarding(pw);
#line 1848
    break;
    case 28: 
#line 1851
    if (no_port_forwarding_flag) {
#line 1852
      debug("Port forwarding not permitted for this authentication.");
      goto fail;
    }
#line 1855
    debug("Received TCP/IP port forwarding request.");
#line 1856
    channel_input_port_forward_request(pw->pw_uid == 0U);
#line 1857
    break;
    case 38: 
#line 1860
    tmp___22 = packet_get_int();
#line 1860
    tmp___23 = packet_set_maxsize((int )tmp___22);
#line 1860
    if (tmp___23 < 0) {
      goto fail;
    }
#line 1862
    break;
    case 12: 
#line 1866
    if (have_pty) {
#line 1866
      tmp___24 = 1;
    } else {
#line 1866
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1866
        tmp___24 = 1;
      } else {
#line 1866
        tmp___24 = 0;
      }
    }
#line 1866
    packet_set_interactive(tmp___24, options.keepalives);
#line 1869
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1871
    debug("Forking shell.");
#line 1872
    while (1) {
#line 1872
      _p___3 = plen;
#line 1872
      _e___3 = 0;
#line 1872
      if (_p___3 != _e___3) {
#line 1872
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "sshd.c",
            1872);
#line 1872
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1872
      break;
    }
#line 1873
    if (have_pty) {
#line 1874
      do_exec_pty((char const   *)((void *)0), ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1876
      do_exec_no_pty((char const   *)((void *)0), pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1877
    return;
    case 13: 
#line 1881
    if (have_pty) {
#line 1881
      tmp___25 = 1;
    } else {
#line 1881
      if ((unsigned int )display != (unsigned int )((void *)0)) {
#line 1881
        tmp___25 = 1;
      } else {
#line 1881
        tmp___25 = 0;
      }
    }
#line 1881
    packet_set_interactive(tmp___25, options.keepalives);
#line 1884
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
      goto do_forced_command;
    }
#line 1889
    command = packet_get_string(& dlen___0);
#line 1890
    debug("Executing command \'%.500s\'", command);
#line 1891
    while (1) {
#line 1891
      _p___4 = plen;
#line 1891
      _e___4 = (int )(4U + dlen___0);
#line 1891
      if (_p___4 != _e___4) {
#line 1891
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "sshd.c",
            1891);
#line 1891
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1891
      break;
    }
#line 1893
    if (have_pty) {
#line 1894
      do_exec_pty((char const   *)command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1896
      do_exec_no_pty((char const   *)command, pw, (char const   *)display, (char const   *)proto,
                     (char const   *)data);
    }
#line 1897
    xfree((void *)command);
#line 1898
    return;
    default: 
#line 1905
    log("Unknown packet type received after authentication: %d", type);
    goto fail;
    }
#line 1910
    packet_start(14);
#line 1911
    packet_send();
#line 1912
    packet_write_wait();
#line 1915
    if (enable_compression_after_reply) {
#line 1916
      enable_compression_after_reply = 0;
#line 1917
      packet_start_compression(compression_level);
    }
#line 1919
    continue;
    fail: 
#line 1923
    packet_start(15);
#line 1924
    packet_send();
#line 1925
    packet_write_wait();
#line 1926
    continue;
    do_forced_command: 
#line 1933
    debug("Executing forced command: %.900s", forced_command);
#line 1934
    if (have_pty) {
#line 1935
      do_exec_pty((char const   *)forced_command, ptyfd, ttyfd, (char const   *)(ttyname___0),
                  pw, (char const   *)term, (char const   *)display, (char const   *)proto,
                  (char const   *)data);
    } else {
#line 1937
      do_exec_no_pty((char const   *)forced_command, pw, (char const   *)display,
                     (char const   *)proto, (char const   *)data);
    }
#line 1938
    return;
  }
}
}
#line 1947 "sshd.c"
void do_exec_no_pty(char const   *command , struct passwd *pw , char const   *display ,
                    char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;

  {
#line 1963
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 1963
  if (tmp___1 < 0) {
#line 1965
    tmp = __errno_location();
#line 1965
    tmp___0 = strerror(*tmp);
#line 1965
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 1963
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 1963
    if (tmp___2 < 0) {
#line 1965
      tmp = __errno_location();
#line 1965
      tmp___0 = strerror(*tmp);
#line 1965
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 1969
  setproctitle("%s@notty", pw->pw_name);
#line 1972
  do_pam_setcred();
#line 1976
  pid = fork();
#line 1976
  if (pid == 0) {
#line 1978
    log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 1984
    tmp___5 = setsid();
#line 1984
    if (tmp___5 < 0) {
#line 1985
      tmp___3 = __errno_location();
#line 1985
      tmp___4 = strerror(*tmp___3);
#line 1985
      error("setsid failed: %.100s", tmp___4);
    }
#line 2014
    close(inout[1]);
#line 2015
    close(err[1]);
#line 2016
    tmp___6 = dup2(inout[0], 0);
#line 2016
    if (tmp___6 < 0) {
#line 2017
      perror("dup2 stdin");
    }
#line 2018
    tmp___7 = dup2(inout[0], 1);
#line 2018
    if (tmp___7 < 0) {
#line 2019
      perror("dup2 stdout");
    }
#line 2020
    tmp___8 = dup2(err[0], 2);
#line 2020
    if (tmp___8 < 0) {
#line 2021
      perror("dup2 stderr");
    }
#line 2025
    do_child(command, pw, (char const   *)((void *)0), display, auth_proto, auth_data,
             (char const   *)((void *)0));
  }
#line 2028
  if (pid < 0) {
#line 2029
    tmp___9 = __errno_location();
#line 2029
    tmp___10 = strerror(*tmp___9);
#line 2029
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 2041
  close(inout[0]);
#line 2042
  close(err[0]);
#line 2048
  server_loop(pid, inout[1], inout[1], err[1]);
#line 2051
  return;
}
}
#line 2059 "sshd.c"
void do_exec_pty(char const   *command , int ptyfd , int ttyfd , char const   *ttyname___0 ,
                 struct passwd *pw , char const   *term , char const   *display ,
                 char const   *auth_proto , char const   *auth_data ) 
{ int pid ;
  int fdout___0 ;
  int ptymaster ;
  char const   *hostname ;
  time_t last_login_time ;
  char buf___0[100] ;
  char *time_string ;
  FILE *f ;
  char line[256] ;
  struct stat st ;
  int quiet_login ;
  struct sockaddr_storage from ;
  socklen_t fromlen ;
  struct pty_cleanup_context cleanup_context ;
  unsigned long tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___21 ;
  char *tmp___23 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;

  {
#line 2079
  hostname = get_canonical_hostname();
#line 2085
  if (! options.use_login) {
#line 2086
    tmp = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf___0, sizeof(buf___0));
#line 2086
    last_login_time = (long )tmp;
  }
#line 2089
  tmp___0 = strrchr(ttyname___0, '/');
#line 2089
  setproctitle("%s@%s", pw->pw_name, tmp___0 + 1);
#line 2092
  do_pam_session(pw->pw_name, ttyname___0);
#line 2093
  do_pam_setcred();
#line 2097
  pid = fork();
#line 2097
  if (pid == 0) {
#line 2098
    pid = getpid();
#line 2102
    log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 2105
    close(ptyfd);
#line 2108
    pty_make_controlling_tty(& ttyfd, ttyname___0);
#line 2111
    tmp___3 = fileno(stdin);
#line 2111
    tmp___4 = dup2(ttyfd, tmp___3);
#line 2111
    if (tmp___4 < 0) {
#line 2112
      tmp___1 = __errno_location();
#line 2112
      tmp___2 = strerror(*tmp___1);
#line 2112
      error("dup2 stdin failed: %.100s", tmp___2);
    }
#line 2115
    tmp___7 = fileno(stdout);
#line 2115
    tmp___8 = dup2(ttyfd, tmp___7);
#line 2115
    if (tmp___8 < 0) {
#line 2116
      tmp___5 = __errno_location();
#line 2116
      tmp___6 = strerror(*tmp___5);
#line 2116
      error("dup2 stdin failed: %.100s", tmp___6);
    }
#line 2119
    tmp___11 = fileno(stderr);
#line 2119
    tmp___12 = dup2(ttyfd, tmp___11);
#line 2119
    if (tmp___12 < 0) {
#line 2120
      tmp___9 = __errno_location();
#line 2120
      tmp___10 = strerror(*tmp___9);
#line 2120
      error("dup2 stdin failed: %.100s", tmp___10);
    }
#line 2123
    close(ttyfd);
#line 2130
    memset((void *)(& from), 0, sizeof(from));
#line 2131
    tmp___17 = packet_get_connection_in();
#line 2131
    tmp___18 = packet_get_connection_out();
#line 2131
    if (tmp___17 == tmp___18) {
#line 2132
      fromlen = sizeof(from);
#line 2133
      tmp___15 = packet_get_connection_in();
#line 2133
      tmp___16 = getpeername(tmp___15, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                             (socklen_t * __restrict  )(& fromlen));
#line 2133
      if (tmp___16 < 0) {
#line 2135
        tmp___13 = __errno_location();
#line 2135
        tmp___14 = strerror(*tmp___13);
#line 2135
        debug("getpeername: %.100s", tmp___14);
#line 2136
        fatal_cleanup();
      }
    }
#line 2140
    record_login(pid, ttyname___0, (char const   *)pw->pw_name, pw->pw_uid, hostname,
                 (struct sockaddr *)(& from));
#line 2144
    snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.200s/.hushlogin",
             pw->pw_dir);
#line 2145
    tmp___19 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 2145
    quiet_login = tmp___19 >= 0;
#line 2148
    if (! quiet_login) {
#line 2149
      print_pam_messages();
    }
#line 2160
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 2160
      if (last_login_time != 0L) {
#line 2160
        if (! quiet_login) {
#line 2160
          if (! options.use_login) {
#line 2163
            time_string = ctime((time_t const   *)(& last_login_time));
#line 2165
            tmp___23 = __builtin_strchr(time_string, '\n');
#line 2165
            if (tmp___23) {
#line 2166
              tmp___21 = __builtin_strchr(time_string, '\n');
#line 2166
              *tmp___21 = (char)0;
            }
#line 2169
            if (0) {
#line 2169
              __s1_len = strlen((char const   *)(buf___0));
#line 2169
              __s2_len = strlen("");
#line 2169
              if (! ((unsigned int )((void const   *)(buf___0 + 1)) - (unsigned int )((void const   *)(buf___0)) == 1U)) {
                goto _L___0;
              } else {
#line 2169
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 2169
                  if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 2169
                    tmp___33 = 1;
                  } else {
#line 2169
                    if (__s2_len >= 4U) {
#line 2169
                      tmp___33 = 1;
                    } else {
#line 2169
                      tmp___33 = 0;
                    }
                  }
                } else {
#line 2169
                  tmp___33 = 0;
                }
              }
#line 2169
              if (tmp___33) {
#line 2169
                tmp___29 = __builtin_strcmp((char const   *)(buf___0), "");
              } else {
#line 2169
                tmp___32 = __builtin_strcmp((char const   *)(buf___0), "");
#line 2169
                tmp___29 = tmp___32;
              }
            } else {
#line 2169
              tmp___32 = __builtin_strcmp((char const   *)(buf___0), "");
#line 2169
              tmp___29 = tmp___32;
            }
#line 2169
            if (tmp___29 == 0) {
#line 2170
              printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
            } else {
#line 2172
              printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
                     buf___0);
            }
          }
        }
      }
    }
#line 2180
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 2180
      if (options.print_motd) {
#line 2180
        if (! quiet_login) {
#line 2180
          if (! options.use_login) {
#line 2183
            f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 2184
            if (f) {
#line 2185
              while (1) {
#line 2185
                tmp___34 = fgets((char * __restrict  )(line), (int )sizeof(line),
                                 (FILE * __restrict  )f);
#line 2185
                if (! tmp___34) {
#line 2185
                  break;
                }
#line 2186
                fputs((char const   * __restrict  )(line), (FILE * __restrict  )stdout);
              }
#line 2187
              fclose(f);
            }
          }
        }
      }
    }
#line 2191
    do_child(command, pw, term, display, auth_proto, auth_data, ttyname___0);
  }
#line 2194
  if (pid < 0) {
#line 2195
    tmp___35 = __errno_location();
#line 2195
    tmp___36 = strerror(*tmp___35);
#line 2195
    packet_disconnect("fork failed: %.100s", tmp___36);
  }
#line 2197
  close(ttyfd);
#line 2203
  cleanup_context.pid = pid;
#line 2204
  cleanup_context.ttyname = ttyname___0;
#line 2205
  fatal_add_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2206
  fatal_remove_cleanup(& pty_release_proc, (void *)ttyname___0);
#line 2213
  fdout___0 = dup(ptyfd);
#line 2214
  if (fdout___0 < 0) {
#line 2215
    tmp___37 = __errno_location();
#line 2215
    tmp___38 = strerror(*tmp___37);
#line 2215
    packet_disconnect("dup #1 failed: %.100s", tmp___38);
  }
#line 2218
  ptymaster = dup(ptyfd);
#line 2219
  if (ptymaster < 0) {
#line 2220
    tmp___39 = __errno_location();
#line 2220
    tmp___40 = strerror(*tmp___39);
#line 2220
    packet_disconnect("dup #2 failed: %.100s", tmp___40);
  }
#line 2223
  server_loop(pid, ptyfd, fdout___0, -1);
#line 2227
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)(& cleanup_context));
#line 2230
  record_logout(pid, ttyname___0);
#line 2233
  pty_release(ttyname___0);
#line 2240
  tmp___43 = close(ptymaster);
#line 2240
  if (tmp___43 < 0) {
#line 2241
    tmp___41 = __errno_location();
#line 2241
    tmp___42 = strerror(*tmp___41);
#line 2241
    error("close(ptymaster): %s", tmp___42);
  }
#line 2242
  return;
}
}
#line 2248 "sshd.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 2260
  env = *envp;
#line 2261
  namelen = strlen(name);
#line 2262
  i = 0U;
#line 2262
  while (*(env + i)) {
#line 2263
    if (0) {
#line 2263
      if (0) {
#line 2263
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 2263
        __s2_len___0 = strlen(name);
#line 2263
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 2263
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 2263
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 2263
              tmp___22 = 1;
            } else {
#line 2263
              if (__s2_len___0 >= 4U) {
#line 2263
                tmp___22 = 1;
              } else {
#line 2263
                tmp___22 = 0;
              }
            }
          } else {
#line 2263
            tmp___22 = 0;
          }
        }
#line 2263
        if (tmp___22) {
#line 2263
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 2263
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2263
          tmp___18 = tmp___21;
        }
      } else {
#line 2263
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 2263
        tmp___18 = tmp___21;
      }
#line 2263
      tmp___12 = tmp___18;
    } else {
#line 2263
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 2263
    if (tmp___12 == 0) {
#line 2263
      if ((int )*(*(env + i) + namelen) == 61) {
#line 2264
        break;
      }
    }
#line 2262
    i ++;
  }
#line 2265
  if (*(env + i)) {
#line 2267
    xfree((void *)*(env + i));
  } else {
#line 2270
    if (i >= *envsizep - 1U) {
#line 2271
      *envsizep += 50U;
#line 2272
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 2272
      *envp = (char **)tmp___25;
#line 2272
      env = *envp;
    }
#line 2275
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 2279
  tmp___26 = strlen(name);
#line 2279
  tmp___27 = strlen(value);
#line 2279
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 2279
  *(env + i) = (char *)tmp___28;
#line 2280
  tmp___29 = strlen(name);
#line 2280
  tmp___30 = strlen(value);
#line 2280
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 2281
  return;
}
}
#line 2289 "sshd.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___0[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 2297
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 2298
  if (! f) {
#line 2299
    return;
  }
#line 2301
  while (1) {
#line 2301
    tmp___5 = fgets((char * __restrict  )(buf___0), (int )sizeof(buf___0), (FILE * __restrict  )f);
#line 2301
    if (! tmp___5) {
#line 2301
      break;
    }
#line 2302
    cp = buf___0;
#line 2302
    while (1) {
#line 2302
      if (! ((int )*cp == 32)) {
#line 2302
        if (! ((int )*cp == 9)) {
#line 2302
          break;
        }
      }
#line 2302
      cp ++;
    }
#line 2304
    if (! *cp) {
#line 2305
      continue;
    } else {
#line 2304
      if ((int )*cp == 35) {
#line 2305
        continue;
      } else {
#line 2304
        if ((int )*cp == 10) {
#line 2305
          continue;
        }
      }
    }
#line 2306
    tmp___2 = __builtin_strchr(cp, '\n');
#line 2306
    if (tmp___2) {
#line 2307
      tmp___0 = __builtin_strchr(cp, '\n');
#line 2307
      *tmp___0 = (char )'\000';
    }
#line 2308
    tmp___4 = __builtin_strchr(cp, '=');
#line 2308
    value = tmp___4;
#line 2309
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 2310
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___0);
#line 2311
      continue;
    }
#line 2314
    *value = (char )'\000';
#line 2315
    value ++;
#line 2316
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 2318
  fclose(f);
#line 2319
  return;
}
}
#line 2325 "sshd.c"
void do_pam_environment(char ***env , int *envsize ) 
{ char *equals ;
  char var_name[512] ;
  char var_val[512] ;
  char **pam_env ;
  int i ;
  size_t tmp ;

  {
#line 2331
  pam_env = fetch_pam_environment();
#line 2331
  if ((unsigned int )pam_env == (unsigned int )((void *)0)) {
#line 2332
    return;
  }
#line 2334
  i = 0;
#line 2334
  while ((unsigned int )*(pam_env + i) != (unsigned int )((void *)0)) {
#line 2335
    equals = strstr((char const   *)*(pam_env + i), "=");
#line 2335
    if ((unsigned int )equals == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 2338
    tmp = strlen((char const   *)*(pam_env + i));
#line 2338
    if (tmp < sizeof(var_name) - 1U) {
#line 2340
      memset((void *)(var_name), '\000', sizeof(var_name));
#line 2341
      memset((void *)(var_val), '\000', sizeof(var_val));
#line 2343
      __builtin_strncpy(var_name, (char const   *)*(pam_env + i), (unsigned int )(equals - *(pam_env + i)));
#line 2344
      strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equals + 1));
#line 2346
      debug("PAM environment: %s=%s", var_name, var_val);
#line 2348
      child_set_env(env, (unsigned int *)envsize, (char const   *)(var_name), (char const   *)(var_val));
    }
    __Cont: /* CIL Label */ 
#line 2334
    i ++;
  }
#line 2351
  return;
}
}
#line 2369
extern char **environ ;
#line 2359 "sshd.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *cp ;
  char buf___0[256] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char buf___1[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___27 ;
  char const   *tmp___28 ;

  {
#line 2364
  cp = (char const   *)((void *)0);
#line 2387
  tmp___1 = setlogin((char const   *)pw->pw_name);
#line 2387
  if (tmp___1 < 0) {
#line 2388
    tmp = __errno_location();
#line 2388
    tmp___0 = strerror(*tmp);
#line 2388
    error("setlogin failed: %s", tmp___0);
  }
#line 2393
  if (! options.use_login) {
#line 2394
    tmp___4 = getuid();
#line 2394
    if (tmp___4 == 0U) {
      goto _L;
    } else {
#line 2394
      tmp___5 = geteuid();
#line 2394
      if (tmp___5 == 0U) {
        _L: /* CIL Label */ 
#line 2395
        tmp___2 = setgid(pw->pw_gid);
#line 2395
        if (tmp___2 < 0) {
#line 2396
          perror("setgid");
#line 2397
          exit(1);
        }
#line 2400
        tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 2400
        if (tmp___3 < 0) {
#line 2401
          perror("initgroups");
#line 2402
          exit(1);
        }
#line 2404
        endgrent();
#line 2407
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 2409
    tmp___6 = getuid();
#line 2409
    if (tmp___6 != pw->pw_uid) {
#line 2410
      fatal("Failed to set uids to %d.", (int )pw->pw_uid);
    } else {
#line 2409
      tmp___7 = geteuid();
#line 2409
      if (tmp___7 != pw->pw_uid) {
#line 2410
        fatal("Failed to set uids to %d.", (int )pw->pw_uid);
      }
    }
  }
#line 2416
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 2416
    shell = "/bin/sh";
  } else {
#line 2416
    shell = (char const   *)pw->pw_shell;
  }
#line 2431
  envsize = 100U;
#line 2432
  tmp___8 = xmalloc(envsize * sizeof(char *));
#line 2432
  env = (char **)tmp___8;
#line 2433
  *(env + 0) = (char *)((void *)0);
#line 2435
  if (! options.use_login) {
#line 2437
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 2438
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 2439
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 2440
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 2442
    snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 2444
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___0));
#line 2447
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 2449
  tmp___10 = getenv("TZ");
#line 2449
  if (tmp___10) {
#line 2450
    tmp___9 = getenv("TZ");
#line 2450
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___9);
  }
#line 2453
  while (custom_environment) {
#line 2454
    ce = custom_environment;
#line 2455
    s = ce->s;
#line 2457
    i___0 = 0;
#line 2457
    while (1) {
#line 2457
      if ((int )*(s + i___0) != 61) {
#line 2457
        if (! *(s + i___0)) {
#line 2457
          break;
        }
      } else {
#line 2457
        break;
      }
#line 2457
      i___0 ++;
    }
#line 2458
    if ((int )*(s + i___0) == 61) {
#line 2459
      *(s + i___0) = (char)0;
#line 2460
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 2462
    custom_environment = ce->next;
#line 2463
    xfree((void *)ce->s);
#line 2464
    xfree((void *)ce);
  }
#line 2467
  tmp___11 = get_local_port();
#line 2467
  tmp___12 = get_remote_port();
#line 2467
  tmp___13 = get_remote_ipaddr();
#line 2467
  snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"%.50s %d %d",
           tmp___13, tmp___12, tmp___11);
#line 2469
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___0));
#line 2471
  if (ttyname___0) {
#line 2472
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 2473
  if (term) {
#line 2474
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 2475
  if (display) {
#line 2476
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 2501
  do_pam_environment(& env, (int *)(& envsize));
#line 2504
  if (xauthfile) {
#line 2505
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 2507
  tmp___15 = auth_get_socket_name();
#line 2507
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 2508
    tmp___14 = auth_get_socket_name();
#line 2508
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___14);
  }
#line 2511
  read_environment_file(& env, & envsize, "/etc/environment");
#line 2514
  if (! options.use_login) {
#line 2515
    snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 2516
    read_environment_file(& env, & envsize, (char const   *)(buf___0));
  }
#line 2518
  if (debug_flag) {
#line 2520
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 2521
    i = 0U;
#line 2521
    while (*(env + i)) {
#line 2522
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 2521
      i ++;
    }
  }
#line 2531
  tmp___19 = packet_get_connection_in();
#line 2531
  tmp___20 = packet_get_connection_out();
#line 2531
  if (tmp___19 == tmp___20) {
#line 2532
    tmp___16 = packet_get_connection_in();
#line 2532
    close(tmp___16);
  } else {
#line 2534
    tmp___17 = packet_get_connection_in();
#line 2534
    close(tmp___17);
#line 2535
    tmp___18 = packet_get_connection_out();
#line 2535
    close(tmp___18);
  }
#line 2542
  channel_close_all();
#line 2548
  endpwent();
#line 2556
  i = 3U;
#line 2556
  while (i < 64U) {
#line 2557
    close((int )i);
#line 2556
    i ++;
  }
#line 2560
  tmp___23 = chdir((char const   *)pw->pw_dir);
#line 2560
  if (tmp___23 < 0) {
#line 2561
    tmp___21 = __errno_location();
#line 2561
    tmp___22 = strerror(*tmp___21);
#line 2561
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___22);
  }
#line 2568
  environ = env;
#line 2574
  if (! options.use_login) {
#line 2575
    tmp___25 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 2575
    if (tmp___25 >= 0) {
#line 2576
      if (debug_flag) {
#line 2577
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 2579
      f = popen("/bin/sh .ssh/rc", "w");
#line 2580
      if (f) {
#line 2581
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2581
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2582
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 2583
        pclose(f);
      } else {
#line 2585
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 2586
      tmp___24 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 2586
      if (tmp___24 >= 0) {
#line 2587
        if (debug_flag) {
#line 2588
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 2590
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 2591
        if (f) {
#line 2592
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2592
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2593
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 2594
          pclose(f);
        } else {
#line 2596
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 2601
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 2601
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 2602
            if (debug_flag) {
#line 2603
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      "/usr/bin//xauth", display, auth_proto, auth_data);
            }
#line 2606
            f = popen("/usr/bin//xauth -q -", "w");
#line 2607
            if (f) {
#line 2608
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      display, auth_proto, auth_data);
#line 2609
              pclose(f);
            } else {
#line 2611
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s -q -\n",
                      "/usr/bin//xauth");
            }
          }
        }
      }
    }
#line 2617
    tmp___26 = strrchr(shell, '/');
#line 2617
    cp = (char const   *)tmp___26;
#line 2618
    if (cp) {
#line 2619
      cp ++;
    } else {
#line 2621
      cp = shell;
    }
  }
#line 2628
  if (! command) {
#line 2629
    if (! options.use_login) {
#line 2636
      if (ttyname___0) {
#line 2636
        if (options.check_mail) {
#line 2639
          mailbox = getenv("MAIL");
#line 2640
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 2641
            tmp___27 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 2641
            if (tmp___27 != 0) {
#line 2642
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 2641
              if (mailstat.st_size == 0L) {
#line 2642
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 2643
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 2644
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 2646
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 2650
      buf___1[0] = (char )'-';
#line 2651
      __builtin_strncpy(buf___1 + 1, cp, sizeof(buf___1) - 1U);
#line 2652
      buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 2655
      argv[0] = buf___1;
#line 2656
      argv[1] = (char *)((void *)0);
#line 2657
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2660
      perror(shell);
#line 2661
      exit(1);
    } else {
#line 2666
      tmp___28 = get_remote_ipaddr();
#line 2666
      execl("/usr/bin/login", "login", "-h", tmp___28, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 2671
      perror("login");
#line 2672
      exit(1);
    }
  }
#line 2679
  argv[0] = (char *)cp;
#line 2680
  argv[1] = (char *)"-c";
#line 2681
  argv[2] = (char *)command;
#line 2682
  argv[3] = (char *)((void *)0);
#line 2683
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 2684
  perror(shell);
#line 2685
  exit(1);
}
}
#line 1 "auth-rhosts.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 33 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___0[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 42
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 43
  if (! f) {
#line 44
    return (0);
  }
#line 46
  while (1) {
#line 46
    tmp___50 = fgets((char * __restrict  )(buf___0), (int )sizeof(buf___0), (FILE * __restrict  )f);
#line 46
    if (! tmp___50) {
#line 46
      break;
    }
#line 51
    cp = buf___0;
#line 51
    while (1) {
#line 51
      if (! ((int )*cp == 32)) {
#line 51
        if (! ((int )*cp == 9)) {
#line 51
          break;
        }
      }
#line 51
      cp ++;
    }
#line 53
    if ((int )*cp == 35) {
#line 54
      continue;
    } else {
#line 53
      if ((int )*cp == 10) {
#line 54
        continue;
      } else {
#line 53
        if (! *cp) {
#line 54
          continue;
        }
      }
    }
#line 60
    if (0) {
#line 60
      if (0) {
#line 60
        __s1_len___0 = strlen((char const   *)cp);
#line 60
        __s2_len___0 = strlen("NO_PLUS");
#line 60
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 60
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 60
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 60
              tmp___22 = 1;
            } else {
#line 60
              if (__s2_len___0 >= 4U) {
#line 60
                tmp___22 = 1;
              } else {
#line 60
                tmp___22 = 0;
              }
            }
          } else {
#line 60
            tmp___22 = 0;
          }
        }
#line 60
        if (tmp___22) {
#line 60
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 60
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
          tmp___18 = tmp___21;
        }
      } else {
#line 60
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
        tmp___18 = tmp___21;
      }
#line 60
      tmp___12 = tmp___18;
    } else {
#line 60
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 60
    if (tmp___12 == 0) {
#line 61
      continue;
    }
#line 67
    tmp___25 = sscanf((char const   * __restrict  )(buf___0), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 67
    switch (tmp___25) {
    case 0: 
#line 69
    packet_send_debug("Found empty line in %.100s.", filename);
#line 70
    continue;
    case 1: 
#line 73
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 74
    break;
    case 2: 
#line 77
    break;
    case 3: 
#line 79
    packet_send_debug("Found garbage in %.100s.", filename);
#line 80
    continue;
    default: ;
#line 83
    continue;
    }
#line 86
    host = hostbuf;
#line 87
    user = userbuf;
#line 88
    negated = 0;
#line 91
    if ((int )*(host + 0) == 45) {
#line 92
      negated = 1;
#line 93
      host ++;
    } else {
#line 94
      if ((int )*(host + 0) == 43) {
#line 95
        host ++;
      }
    }
#line 97
    if ((int )*(user + 0) == 45) {
#line 98
      negated = 1;
#line 99
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 106
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 106
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
        continue;
      }
    }
#line 111
    if ((int )*(host + 0) == 64) {
#line 112
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 112
      if (! tmp___26) {
#line 112
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 112
        if (! tmp___27) {
#line 114
          continue;
        }
      }
    } else {
#line 115
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 115
      if (tmp___28) {
#line 115
        if (0) {
#line 115
          __s1_len___1 = strlen((char const   *)host);
#line 115
          __s2_len___1 = strlen(ipaddr);
#line 115
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 115
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 115
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 115
                tmp___38 = 1;
              } else {
#line 115
                if (__s2_len___1 >= 4U) {
#line 115
                  tmp___38 = 1;
                } else {
#line 115
                  tmp___38 = 0;
                }
              }
            } else {
#line 115
              tmp___38 = 0;
            }
          }
#line 115
          if (tmp___38) {
#line 115
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 115
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
            tmp___34 = tmp___37;
          }
        } else {
#line 115
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
          tmp___34 = tmp___37;
        }
#line 115
        if (tmp___34 != 0) {
#line 116
          continue;
        }
      }
    }
#line 119
    if ((int )*(user + 0) == 64) {
#line 120
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 120
      if (! tmp___39) {
#line 121
        continue;
      }
    } else {
#line 122
      if (0) {
#line 122
        __s1_len___2 = strlen((char const   *)user);
#line 122
        __s2_len___2 = strlen(client_user);
#line 122
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 122
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 122
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 122
              tmp___49 = 1;
            } else {
#line 122
              if (__s2_len___2 >= 4U) {
#line 122
                tmp___49 = 1;
              } else {
#line 122
                tmp___49 = 0;
              }
            }
          } else {
#line 122
            tmp___49 = 0;
          }
        }
#line 122
        if (tmp___49) {
#line 122
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 122
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
          tmp___45 = tmp___48;
        }
      } else {
#line 122
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
        tmp___45 = tmp___48;
      }
#line 122
      if (tmp___45 != 0) {
#line 123
        continue;
      }
    }
#line 126
    fclose(f);
#line 129
    if (negated) {
#line 130
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 132
      return (0);
    }
#line 135
    return (1);
  }
#line 139
  fclose(f);
#line 140
  return (0);
}
}
#line 156 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 149 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf___0[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 160
  temporarily_use_uid(pw->pw_uid);
#line 166
  rhosts_file_index = 0U;
#line 166
  while (rhosts_files[rhosts_file_index]) {
#line 169
    snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 171
    tmp = stat((char const   * __restrict  )(buf___0), (struct stat * __restrict  )(& st));
#line 171
    if (tmp >= 0) {
#line 172
      break;
    }
#line 166
    rhosts_file_index ++;
  }
#line 175
  restore_uid();
#line 178
  if (! rhosts_files[rhosts_file_index]) {
#line 178
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 178
    if (tmp___0 < 0) {
#line 178
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 178
      if (tmp___1 < 0) {
#line 181
        return (0);
      }
    }
  }
#line 183
  hostname = get_canonical_hostname();
#line 184
  ipaddr = get_remote_ipaddr();
#line 187
  if (pw->pw_uid != 0U) {
#line 188
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 188
    if (tmp___2) {
#line 190
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 192
      return (1);
    }
#line 194
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 194
    if (tmp___3) {
#line 196
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 198
      return (1);
    }
  }
#line 205
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 205
  if (tmp___4 < 0) {
#line 206
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 208
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 210
    return (0);
  }
#line 212
  if (options.strict_modes) {
#line 212
    if (st.st_uid != 0U) {
#line 212
      if (st.st_uid != pw->pw_uid) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 212
      if ((st.st_mode & 18U) != 0U) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      }
    }
  }
#line 222
  temporarily_use_uid(pw->pw_uid);
#line 225
  rhosts_file_index = 0U;
#line 225
  while (rhosts_files[rhosts_file_index]) {
#line 228
    snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 230
    tmp___5 = stat((char const   * __restrict  )(buf___0), (struct stat * __restrict  )(& st));
#line 230
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 239
    if (options.strict_modes) {
#line 239
      if (st.st_uid != 0U) {
#line 239
        if (st.st_uid != pw->pw_uid) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___0);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___0);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 239
        if ((st.st_mode & 18U) != 0U) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___0);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___0);
          goto __Cont;
        }
      }
    }
#line 248
    if (options.ignore_rhosts) {
#line 249
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 254
    tmp___6 = check_rhosts_file((char const   *)(buf___0), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 254
    if (tmp___6) {
#line 255
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 258
      restore_uid();
#line 259
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 225
    rhosts_file_index ++;
  }
#line 264
  restore_uid();
#line 265
  return (0);
}
}
#line 1 "auth-krb4.o"
#line 1 "auth-pam.o"
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 182
extern char ** __attribute__((__nonnull__(1))) pam_getenvlist(pam_handle_t *pamh ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 35
extern int __attribute__((__nonnull__(1)))  pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 19 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 21
void pam_cleanup_proc(void *context ) ;
#line 24 "auth-pam.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 28 "auth-pam.c"
static struct pam_handle_t *pamh  =    (struct pam_handle_t *)((void *)0);
#line 29 "auth-pam.c"
static char const   *pampasswd  =    (char const   *)((void *)0);
#line 30 "auth-pam.c"
static char *pamconv_msg  =    (char *)((void *)0);
#line 34 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ struct pam_response *reply ;
  int count ;
  size_t msg_len ;
  char *p ;
  void *tmp ;
  size_t n___0 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 43
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 43
  reply = (struct pam_response *)tmp;
#line 44
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 45
    return (19);
  }
#line 47
  count = 0;
#line 47
  while (count < num_msg) {
#line 48
    switch ((int )(*(msg + count))->msg_style) {
    case 1: 
#line 50
    if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 51
      free((void *)reply);
#line 52
      return (19);
    }
#line 54
    (reply + count)->resp_retcode = 0;
#line 55
    (reply + count)->resp = xstrdup(pampasswd);
#line 56
    break;
    case 4: 
#line 59
    (reply + count)->resp_retcode = 0;
#line 60
    (reply + count)->resp = xstrdup("");
#line 62
    if ((unsigned int )(*(msg + count))->msg == (unsigned int )((void *)0)) {
#line 63
      break;
    }
#line 65
    debug("Adding PAM message: %s", (*(msg + count))->msg);
#line 67
    msg_len = strlen((char const   *)(*(msg + count))->msg);
#line 68
    if (pamconv_msg) {
#line 69
      tmp___0 = strlen((char const   *)pamconv_msg);
#line 69
      n___0 = tmp___0;
#line 70
      tmp___1 = xrealloc((void *)pamconv_msg, (n___0 + msg_len) + 2U);
#line 70
      pamconv_msg = (char *)tmp___1;
#line 71
      p = pamconv_msg + n___0;
    } else {
#line 73
      tmp___2 = xmalloc(msg_len + 2U);
#line 73
      p = (char *)tmp___2;
#line 73
      pamconv_msg = p;
    }
#line 75
    memcpy((void * __restrict  )p, (void const   * __restrict  )(*(msg + count))->msg,
           msg_len);
#line 76
    *(p + msg_len) = (char )'\n';
#line 77
    *(p + (msg_len + 1U)) = (char )'\000';
#line 78
    break;
    case 2: 
    case 3: 
    default: 
#line 83
    free((void *)reply);
#line 84
    return (19);
    }
#line 47
    count ++;
  }
#line 88
  *resp = reply;
#line 90
  return (0);
}
}
#line 94 "auth-pam.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;

  {
#line 98
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 100
    tmp = pam_close_session((pam_handle_t *)pamh, 0);
#line 100
    pam_retval = (int )tmp;
#line 101
    if (pam_retval != 0) {
#line 102
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 102
      log("Cannot close PAM session: %.200s", tmp___0);
    }
#line 106
    tmp___1 = pam_setcred((pam_handle_t *)pamh, 4);
#line 106
    pam_retval = (int )tmp___1;
#line 107
    if (pam_retval != 0) {
#line 108
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 108
      log("Cannot delete credentials: %.200s", tmp___2);
    }
#line 112
    tmp___3 = pam_end((pam_handle_t *)pamh, pam_retval);
#line 112
    pam_retval = (int )tmp___3;
#line 113
    if (pam_retval != 0) {
#line 114
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 114
      log("Cannot release PAM authentication: %.200s", tmp___4);
    }
  }
#line 118
  return;
}
}
#line 121 "auth-pam.c"
int auth_pam_password(struct passwd *pw , char const   *password ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 127
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 128
    return (0);
  }
#line 129
  if (pw->pw_uid == 0U) {
#line 129
    if (options.permit_root_login == 2) {
#line 130
      return (0);
    }
  }
#line 131
  if ((int const   )*password == 0) {
#line 131
    if (options.permit_empty_passwd == 0) {
#line 132
      return (0);
    }
  }
#line 134
  pampasswd = password;
#line 136
  tmp = pam_authenticate((pam_handle_t *)pamh, 0);
#line 136
  pam_retval = (int )tmp;
#line 137
  if (pam_retval == 0) {
#line 138
    debug("PAM Password authentication accepted for user \"%.100s\"", pw->pw_name);
#line 139
    return (1);
  } else {
#line 141
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 141
    debug("PAM Password authentication for \"%.100s\" failed: %s", pw->pw_name, tmp___0);
#line 143
    return (0);
  }
}
}
#line 148 "auth-pam.c"
int do_pam_account(char *username , char *remote_user ) 
{ int pam_retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 152
  tmp = get_canonical_hostname();
#line 152
  debug("PAM setting rhost to \"%.200s\"", tmp);
#line 153
  tmp___0 = get_canonical_hostname();
#line 153
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 4, (void const   *)tmp___0);
#line 153
  pam_retval = (int )tmp___1;
#line 155
  if (pam_retval != 0) {
#line 156
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 156
    fatal("PAM set rhost failed: %.200s", tmp___2);
  }
#line 159
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 160
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 161
    tmp___3 = pam_set_item((pam_handle_t *)pamh, 8, (void const   *)remote_user);
#line 161
    pam_retval = (int )tmp___3;
#line 162
    if (pam_retval != 0) {
#line 163
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 163
      fatal("PAM set ruser failed: %.200s", tmp___4);
    }
  }
#line 167
  tmp___5 = pam_acct_mgmt((pam_handle_t *)pamh, 0);
#line 167
  pam_retval = (int )tmp___5;
#line 168
  if (pam_retval != 0) {
#line 169
    tmp___6 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 169
    log("PAM rejected by account configuration: %.200s", tmp___6);
#line 170
    return (0);
  }
#line 173
  return (1);
}
}
#line 177 "auth-pam.c"
void do_pam_session(char *username , char const   *ttyname___0 ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 181
  if ((unsigned int )ttyname___0 != (unsigned int )((void *)0)) {
#line 182
    debug("PAM setting tty to \"%.200s\"", ttyname___0);
#line 183
    tmp = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)ttyname___0);
#line 183
    pam_retval = (int )tmp;
#line 184
    if (pam_retval != 0) {
#line 185
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 185
      fatal("PAM set tty failed: %.200s", tmp___0);
    }
  }
#line 188
  tmp___1 = pam_open_session((pam_handle_t *)pamh, 0);
#line 188
  pam_retval = (int )tmp___1;
#line 189
  if (pam_retval != 0) {
#line 190
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 190
    fatal("PAM session setup failed: %.200s", tmp___2);
  }
#line 191
  return;
}
}
#line 194 "auth-pam.c"
void do_pam_setcred(void) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 198
  debug("PAM establishing creds");
#line 199
  tmp = pam_setcred((pam_handle_t *)pamh, 2);
#line 199
  pam_retval = (int )tmp;
#line 200
  if (pam_retval != 0) {
#line 201
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 201
    fatal("PAM setcred failed: %.200s", tmp___0);
  }
#line 202
  return;
}
}
#line 205 "auth-pam.c"
void finish_pam(void) 
{ 

  {
#line 207
  pam_cleanup_proc((void *)0);
#line 208
  fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
#line 209
  return;
}
}
#line 212 "auth-pam.c"
void start_pam(struct passwd *pw ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1,3,4)))  tmp ;
  char const   *tmp___0 ;

  {
#line 216
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 218
  tmp = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                  (pam_handle_t **)(& pamh));
#line 218
  pam_retval = (int )tmp;
#line 219
  if (pam_retval != 0) {
#line 220
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 220
    fatal("PAM initialisation failed: %.200s", tmp___0);
  }
#line 222
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 223
  return;
}
}
#line 226 "auth-pam.c"
char **fetch_pam_environment(void) 
{ char ** __attribute__((__nonnull__(1))) tmp ;

  {
#line 228
  tmp = pam_getenvlist((pam_handle_t *)pamh);
#line 228
  return ((char **)tmp);
}
}
#line 233 "auth-pam.c"
void print_pam_messages(void) 
{ 

  {
#line 235
  if ((unsigned int )pamconv_msg != (unsigned int )((void *)0)) {
#line 236
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )pamconv_msg);
  }
#line 237
  return;
}
}
#line 1 "auth-passwd.o"
#line 1 "auth-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 424 "ssh.h"
int auth_rsa_challenge_dialog(BIGNUM *e , BIGNUM *n___0 ) ;
#line 68 "auth-rsa.c"
int auth_rsa_challenge_dialog(BIGNUM *e , BIGNUM *n___0 ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  RSA *pk ;
  BN_CTX *ctx ;
  unsigned char buf___0[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 79
  encrypted_challenge = BN_new();
#line 80
  challenge = BN_new();
#line 83
  BN_rand(challenge, 256, 0, 0);
#line 84
  ctx = BN_CTX_new();
#line 85
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)n___0,
         ctx);
#line 86
  BN_CTX_free(ctx);
#line 89
  pk = RSA_new();
#line 90
  pk->e = BN_new();
#line 91
  BN_copy(pk->e, (BIGNUM const   *)e);
#line 92
  pk->n = BN_new();
#line 93
  BN_copy(pk->n, (BIGNUM const   *)n___0);
#line 96
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 97
  RSA_free(pk);
#line 100
  packet_start(7);
#line 101
  packet_put_bignum(encrypted_challenge);
#line 102
  packet_send();
#line 103
  BN_clear_free(encrypted_challenge);
#line 104
  packet_write_wait();
#line 107
  packet_read_expect(& plen, 8);
#line 108
  while (1) {
#line 108
    _p = plen;
#line 108
    _e = 16;
#line 108
    if (_p != _e) {
#line 108
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 108);
#line 108
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 108
    break;
  }
#line 109
  i = 0U;
#line 109
  while (i < 16U) {
#line 110
    tmp = packet_get_char();
#line 110
    response[i] = (unsigned char )tmp;
#line 109
    i ++;
  }
#line 113
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 113
  len = (tmp___0 + 7) / 8;
#line 114
  if (len <= 0) {
#line 115
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 114
    if (len > 32) {
#line 115
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 116
  memset((void *)(buf___0), 0, 32U);
#line 117
  BN_bn2bin((BIGNUM const   *)challenge, (buf___0 + 32) - len);
#line 118
  MD5_Init(& md);
#line 119
  MD5_Update(& md, (void const   *)(buf___0), 32U);
#line 120
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 121
  MD5_Final(mdbuf, & md);
#line 122
  BN_clear_free(challenge);
#line 125
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 125
  if (tmp___1 != 0) {
#line 127
    return (0);
  }
#line 130
  return (1);
}
}
#line 186 "auth-rsa.c"
static char const   *check[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 139 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[1024] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  BIGNUM *e ;
  BIGNUM *n___0 ;
  int tmp ;
  int fail ;
  char buf___0[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___26 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___43 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t tmp___72 ;
  size_t tmp___78 ;
  int tmp___96 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___102 ;
  int tmp___105 ;
  int tmp___106 ;
  size_t tmp___107 ;
  size_t tmp___113 ;
  int tmp___131 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___137 ;
  int tmp___140 ;
  int tmp___141 ;
  size_t tmp___142 ;
  int i___0 ;
  size_t tmp___148 ;
  size_t tmp___149 ;
  void *tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  char *tmp___153 ;
  int tmp___171 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___177 ;
  int tmp___180 ;
  int tmp___181 ;
  size_t tmp___182 ;
  int i___1 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___188 ;
  size_t tmp___189 ;
  void *tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  char *tmp___193 ;
  void *tmp___194 ;
  int tmp___212 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___218 ;
  int tmp___221 ;
  int tmp___222 ;
  size_t tmp___223 ;
  char *patterns ;
  size_t tmp___229 ;
  void *tmp___230 ;
  int i___2 ;
  size_t tmp___231 ;
  int tmp___232 ;
  int tmp___233 ;
  char *tmp___234 ;
  char const   *tmp___235 ;
  char const   *tmp___236 ;
  char const   *tmp___237 ;
  struct envstring *ce ;
  size_t tmp___238 ;
  char const   *tmp___239 ;
  int tmp___240 ;
  size_t tmp___241 ;
  char const   *tmp___242 ;
  int tmp___243 ;
  int tmp___261 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___267 ;
  int tmp___270 ;
  int tmp___271 ;
  size_t tmp___272 ;
  char *tmp___278 ;

  {
#line 147
  linenum = 0UL;
#line 152
  temporarily_use_uid(pw->pw_uid);
#line 155
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 159
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 159
  if (tmp < 0) {
#line 161
    restore_uid();
#line 162
    return (0);
  }
#line 165
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 166
  if (! f) {
#line 168
    restore_uid();
#line 169
    packet_send_debug("Could not open %.900s for reading.", file);
#line 170
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 171
    return (0);
  }
#line 173
  if (options.strict_modes) {
#line 174
    fail = 0;
#line 177
    tmp___1 = fileno(f);
#line 177
    tmp___2 = fstat(tmp___1, & st);
#line 177
    if (tmp___2 < 0) {
#line 180
      snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 182
      fail = 1;
    } else {
#line 177
      if (st.st_uid != 0U) {
#line 177
        if (st.st_uid != pw->pw_uid) {
#line 180
          snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 182
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 177
        if ((st.st_mode & 18U) != 0U) {
#line 180
          snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 182
          fail = 1;
        } else {
#line 189
          i = 0;
#line 189
          while (check[i]) {
#line 190
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check[i]);
#line 191
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 191
            if (tmp___0 < 0) {
#line 194
              snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 196
              fail = 1;
#line 197
              break;
            } else {
#line 191
              if (st.st_uid != 0U) {
#line 191
                if (st.st_uid != pw->pw_uid) {
#line 194
                  snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 196
                  fail = 1;
#line 197
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 191
                if ((st.st_mode & 18U) != 0U) {
#line 194
                  snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 196
                  fail = 1;
#line 197
                  break;
                }
              }
            }
#line 189
            i ++;
          }
        }
      }
    }
#line 201
    if (fail) {
#line 202
      log((char const   *)(buf___0));
#line 203
      packet_send_debug((char const   *)(buf___0));
#line 204
      restore_uid();
#line 205
      return (0);
    }
  }
#line 209
  authenticated = 0;
#line 211
  e = BN_new();
#line 212
  n___0 = BN_new();
#line 219
  while (1) {
#line 219
    tmp___278 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 219
    if (! tmp___278) {
#line 219
      break;
    }
#line 223
    linenum ++;
#line 226
    cp = line;
#line 226
    while (1) {
#line 226
      if (! ((int )*cp == 32)) {
#line 226
        if (! ((int )*cp == 9)) {
#line 226
          break;
        }
      }
#line 226
      cp ++;
    }
#line 228
    if (! *cp) {
#line 229
      continue;
    } else {
#line 228
      if ((int )*cp == 10) {
#line 229
        continue;
      } else {
#line 228
        if ((int )*cp == 35) {
#line 229
          continue;
        }
      }
    }
#line 237
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 237
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 238
        quoted = 0;
#line 239
        options___0 = cp;
#line 240
        while (1) {
#line 240
          if (*cp) {
#line 240
            if (! quoted) {
#line 240
              if ((int )*cp != 32) {
#line 240
                if (! ((int )*cp != 9)) {
#line 240
                  break;
                }
              } else {
#line 240
                break;
              }
            }
          } else {
#line 240
            break;
          }
#line 241
          if ((int )*cp == 92) {
#line 241
            if ((int )*(cp + 1) == 34) {
#line 242
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 243
            if ((int )*cp == 34) {
#line 244
              quoted = ! quoted;
            }
          }
#line 240
          cp ++;
        }
      } else {
#line 247
        options___0 = (char *)((void *)0);
      }
    }
#line 250
    tmp___3 = auth_rsa_read_key(& cp, & bits, e, n___0);
#line 250
    if (! tmp___3) {
#line 251
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 253
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 255
      continue;
    }
#line 260
    tmp___4 = BN_cmp((BIGNUM const   *)n___0, (BIGNUM const   *)client_n);
#line 260
    if (tmp___4 != 0) {
#line 261
      continue;
    }
#line 264
    tmp___6 = BN_num_bits((BIGNUM const   *)n___0);
#line 264
    if (bits != (unsigned int )tmp___6) {
#line 265
      tmp___5 = BN_num_bits((BIGNUM const   *)n___0);
#line 265
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 272
    tmp___7 = auth_rsa_challenge_dialog(e, n___0);
#line 272
    if (! tmp___7) {
#line 274
      verbose("Wrong response to RSA authentication challenge.");
#line 275
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 276
      continue;
    }
#line 284
    authenticated = 1;
#line 287
    if (options___0) {
#line 288
      while (1) {
#line 288
        if (*options___0) {
#line 288
          if ((int )*options___0 != 32) {
#line 288
            if (! ((int )*options___0 != 9)) {
#line 288
              break;
            }
          } else {
#line 288
            break;
          }
        } else {
#line 288
          break;
        }
#line 289
        cp = (char *)"no-port-forwarding";
#line 290
        if (0) {
#line 290
          if (0) {
#line 290
            __s1_len___0 = strlen((char const   *)options___0);
#line 290
            __s2_len___0 = strlen((char const   *)cp);
#line 290
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___6;
            } else {
#line 290
              if (__s1_len___0 >= 4U) {
                _L___6: /* CIL Label */ 
#line 290
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 290
                  tmp___36 = 1;
                } else {
#line 290
                  if (__s2_len___0 >= 4U) {
#line 290
                    tmp___36 = 1;
                  } else {
#line 290
                    tmp___36 = 0;
                  }
                }
              } else {
#line 290
                tmp___36 = 0;
              }
            }
#line 290
            if (tmp___36) {
#line 290
              tmp___32 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 290
              tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 290
              tmp___32 = tmp___35;
            }
          } else {
#line 290
            tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 290
            tmp___32 = tmp___35;
          }
#line 290
          tmp___26 = tmp___32;
        } else {
#line 290
          tmp___37 = strlen((char const   *)cp);
#line 290
          tmp___26 = strncmp((char const   *)options___0, (char const   *)cp, tmp___37);
        }
#line 290
        if (tmp___26 == 0) {
#line 291
          packet_send_debug("Port forwarding disabled.");
#line 292
          no_port_forwarding_flag = 1;
#line 293
          tmp___8 = strlen((char const   *)cp);
#line 293
          options___0 += tmp___8;
          goto next_option;
        }
#line 296
        cp = (char *)"no-agent-forwarding";
#line 297
        if (0) {
#line 297
          if (0) {
#line 297
            __s1_len___2 = strlen((char const   *)options___0);
#line 297
            __s2_len___2 = strlen((char const   *)cp);
#line 297
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___10;
            } else {
#line 297
              if (__s1_len___2 >= 4U) {
                _L___10: /* CIL Label */ 
#line 297
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 297
                  tmp___71 = 1;
                } else {
#line 297
                  if (__s2_len___2 >= 4U) {
#line 297
                    tmp___71 = 1;
                  } else {
#line 297
                    tmp___71 = 0;
                  }
                }
              } else {
#line 297
                tmp___71 = 0;
              }
            }
#line 297
            if (tmp___71) {
#line 297
              tmp___67 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 297
              tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 297
              tmp___67 = tmp___70;
            }
          } else {
#line 297
            tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 297
            tmp___67 = tmp___70;
          }
#line 297
          tmp___61 = tmp___67;
        } else {
#line 297
          tmp___72 = strlen((char const   *)cp);
#line 297
          tmp___61 = strncmp((char const   *)options___0, (char const   *)cp, tmp___72);
        }
#line 297
        if (tmp___61 == 0) {
#line 298
          packet_send_debug("Agent forwarding disabled.");
#line 299
          no_agent_forwarding_flag = 1;
#line 300
          tmp___43 = strlen((char const   *)cp);
#line 300
          options___0 += tmp___43;
          goto next_option;
        }
#line 303
        cp = (char *)"no-X11-forwarding";
#line 304
        if (0) {
#line 304
          if (0) {
#line 304
            __s1_len___4 = strlen((char const   *)options___0);
#line 304
            __s2_len___4 = strlen((char const   *)cp);
#line 304
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___14;
            } else {
#line 304
              if (__s1_len___4 >= 4U) {
                _L___14: /* CIL Label */ 
#line 304
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 304
                  tmp___106 = 1;
                } else {
#line 304
                  if (__s2_len___4 >= 4U) {
#line 304
                    tmp___106 = 1;
                  } else {
#line 304
                    tmp___106 = 0;
                  }
                }
              } else {
#line 304
                tmp___106 = 0;
              }
            }
#line 304
            if (tmp___106) {
#line 304
              tmp___102 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 304
              tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 304
              tmp___102 = tmp___105;
            }
          } else {
#line 304
            tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 304
            tmp___102 = tmp___105;
          }
#line 304
          tmp___96 = tmp___102;
        } else {
#line 304
          tmp___107 = strlen((char const   *)cp);
#line 304
          tmp___96 = strncmp((char const   *)options___0, (char const   *)cp, tmp___107);
        }
#line 304
        if (tmp___96 == 0) {
#line 305
          packet_send_debug("X11 forwarding disabled.");
#line 306
          no_x11_forwarding_flag = 1;
#line 307
          tmp___78 = strlen((char const   *)cp);
#line 307
          options___0 += tmp___78;
          goto next_option;
        }
#line 310
        cp = (char *)"no-pty";
#line 311
        if (0) {
#line 311
          if (0) {
#line 311
            __s1_len___6 = strlen((char const   *)options___0);
#line 311
            __s2_len___6 = strlen((char const   *)cp);
#line 311
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___18;
            } else {
#line 311
              if (__s1_len___6 >= 4U) {
                _L___18: /* CIL Label */ 
#line 311
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 311
                  tmp___141 = 1;
                } else {
#line 311
                  if (__s2_len___6 >= 4U) {
#line 311
                    tmp___141 = 1;
                  } else {
#line 311
                    tmp___141 = 0;
                  }
                }
              } else {
#line 311
                tmp___141 = 0;
              }
            }
#line 311
            if (tmp___141) {
#line 311
              tmp___137 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 311
              tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 311
              tmp___137 = tmp___140;
            }
          } else {
#line 311
            tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 311
            tmp___137 = tmp___140;
          }
#line 311
          tmp___131 = tmp___137;
        } else {
#line 311
          tmp___142 = strlen((char const   *)cp);
#line 311
          tmp___131 = strncmp((char const   *)options___0, (char const   *)cp, tmp___142);
        }
#line 311
        if (tmp___131 == 0) {
#line 312
          packet_send_debug("Pty allocation disabled.");
#line 313
          no_pty_flag = 1;
#line 314
          tmp___113 = strlen((char const   *)cp);
#line 314
          options___0 += tmp___113;
          goto next_option;
        }
#line 317
        cp = (char *)"command=\"";
#line 318
        if (0) {
#line 318
          if (0) {
#line 318
            __s1_len___8 = strlen((char const   *)options___0);
#line 318
            __s2_len___8 = strlen((char const   *)cp);
#line 318
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___22;
            } else {
#line 318
              if (__s1_len___8 >= 4U) {
                _L___22: /* CIL Label */ 
#line 318
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 318
                  tmp___181 = 1;
                } else {
#line 318
                  if (__s2_len___8 >= 4U) {
#line 318
                    tmp___181 = 1;
                  } else {
#line 318
                    tmp___181 = 0;
                  }
                }
              } else {
#line 318
                tmp___181 = 0;
              }
            }
#line 318
            if (tmp___181) {
#line 318
              tmp___177 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 318
              tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 318
              tmp___177 = tmp___180;
            }
          } else {
#line 318
            tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 318
            tmp___177 = tmp___180;
          }
#line 318
          tmp___171 = tmp___177;
        } else {
#line 318
          tmp___182 = strlen((char const   *)cp);
#line 318
          tmp___171 = strncmp((char const   *)options___0, (char const   *)cp, tmp___182);
        }
#line 318
        if (tmp___171 == 0) {
#line 320
          tmp___148 = strlen((char const   *)cp);
#line 320
          options___0 += tmp___148;
#line 321
          tmp___149 = strlen((char const   *)options___0);
#line 321
          tmp___150 = xmalloc(tmp___149 + 1U);
#line 321
          forced_command = (char *)tmp___150;
#line 322
          i___0 = 0;
#line 323
          while (*options___0) {
#line 324
            if ((int )*options___0 == 34) {
#line 325
              break;
            }
#line 326
            if ((int )*options___0 == 92) {
#line 326
              if ((int )*(options___0 + 1) == 34) {
#line 327
                options___0 += 2;
#line 328
                tmp___151 = i___0;
#line 328
                i___0 ++;
#line 328
                *(forced_command + tmp___151) = (char )'\"';
#line 329
                continue;
              }
            }
#line 331
            tmp___152 = i___0;
#line 331
            i___0 ++;
#line 331
            tmp___153 = options___0;
#line 331
            options___0 ++;
#line 331
            *(forced_command + tmp___152) = *tmp___153;
          }
#line 333
          if (! *options___0) {
#line 334
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 336
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 338
            continue;
          }
#line 340
          *(forced_command + i___0) = (char)0;
#line 341
          packet_send_debug("Forced command: %.900s", forced_command);
#line 342
          options___0 ++;
          goto next_option;
        }
#line 345
        cp = (char *)"environment=\"";
#line 346
        if (0) {
#line 346
          if (0) {
#line 346
            __s1_len___10 = strlen((char const   *)options___0);
#line 346
            __s2_len___10 = strlen((char const   *)cp);
#line 346
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___26;
            } else {
#line 346
              if (__s1_len___10 >= 4U) {
                _L___26: /* CIL Label */ 
#line 346
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 346
                  tmp___222 = 1;
                } else {
#line 346
                  if (__s2_len___10 >= 4U) {
#line 346
                    tmp___222 = 1;
                  } else {
#line 346
                    tmp___222 = 0;
                  }
                }
              } else {
#line 346
                tmp___222 = 0;
              }
            }
#line 346
            if (tmp___222) {
#line 346
              tmp___218 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 346
              tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 346
              tmp___218 = tmp___221;
            }
          } else {
#line 346
            tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 346
            tmp___218 = tmp___221;
          }
#line 346
          tmp___212 = tmp___218;
        } else {
#line 346
          tmp___223 = strlen((char const   *)cp);
#line 346
          tmp___212 = strncmp((char const   *)options___0, (char const   *)cp, tmp___223);
        }
#line 346
        if (tmp___212 == 0) {
#line 350
          tmp___188 = strlen((char const   *)cp);
#line 350
          options___0 += tmp___188;
#line 351
          tmp___189 = strlen((char const   *)options___0);
#line 351
          tmp___190 = xmalloc(tmp___189 + 1U);
#line 351
          s = (char *)tmp___190;
#line 352
          i___1 = 0;
#line 353
          while (*options___0) {
#line 354
            if ((int )*options___0 == 34) {
#line 355
              break;
            }
#line 356
            if ((int )*options___0 == 92) {
#line 356
              if ((int )*(options___0 + 1) == 34) {
#line 357
                options___0 += 2;
#line 358
                tmp___191 = i___1;
#line 358
                i___1 ++;
#line 358
                *(s + tmp___191) = (char )'\"';
#line 359
                continue;
              }
            }
#line 361
            tmp___192 = i___1;
#line 361
            i___1 ++;
#line 361
            tmp___193 = options___0;
#line 361
            options___0 ++;
#line 361
            *(s + tmp___192) = *tmp___193;
          }
#line 363
          if (! *options___0) {
#line 364
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 366
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 368
            continue;
          }
#line 370
          *(s + i___1) = (char)0;
#line 371
          packet_send_debug("Adding to environment: %.900s", s);
#line 372
          debug("Adding to environment: %.900s", s);
#line 373
          options___0 ++;
#line 374
          tmp___194 = xmalloc(sizeof(struct envstring ));
#line 374
          new_envstring = (struct envstring *)tmp___194;
#line 375
          new_envstring->s = s;
#line 376
          new_envstring->next = custom_environment;
#line 377
          custom_environment = new_envstring;
          goto next_option;
        }
#line 380
        cp = (char *)"from=\"";
#line 381
        if (0) {
#line 381
          if (0) {
#line 381
            __s1_len___12 = strlen((char const   *)options___0);
#line 381
            __s2_len___12 = strlen((char const   *)cp);
#line 381
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___30;
            } else {
#line 381
              if (__s1_len___12 >= 4U) {
                _L___30: /* CIL Label */ 
#line 381
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 381
                  tmp___271 = 1;
                } else {
#line 381
                  if (__s2_len___12 >= 4U) {
#line 381
                    tmp___271 = 1;
                  } else {
#line 381
                    tmp___271 = 0;
                  }
                }
              } else {
#line 381
                tmp___271 = 0;
              }
            }
#line 381
            if (tmp___271) {
#line 381
              tmp___267 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 381
              tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 381
              tmp___267 = tmp___270;
            }
          } else {
#line 381
            tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 381
            tmp___267 = tmp___270;
          }
#line 381
          tmp___261 = tmp___267;
        } else {
#line 381
          tmp___272 = strlen((char const   *)cp);
#line 381
          tmp___261 = strncmp((char const   *)options___0, (char const   *)cp, tmp___272);
        }
#line 381
        if (tmp___261 == 0) {
#line 382
          tmp___229 = strlen((char const   *)options___0);
#line 382
          tmp___230 = xmalloc(tmp___229 + 1U);
#line 382
          patterns = (char *)tmp___230;
#line 384
          tmp___231 = strlen((char const   *)cp);
#line 384
          options___0 += tmp___231;
#line 385
          i___2 = 0;
#line 386
          while (*options___0) {
#line 387
            if ((int )*options___0 == 34) {
#line 388
              break;
            }
#line 389
            if ((int )*options___0 == 92) {
#line 389
              if ((int )*(options___0 + 1) == 34) {
#line 390
                options___0 += 2;
#line 391
                tmp___232 = i___2;
#line 391
                i___2 ++;
#line 391
                *(patterns + tmp___232) = (char )'\"';
#line 392
                continue;
              }
            }
#line 394
            tmp___233 = i___2;
#line 394
            i___2 ++;
#line 394
            tmp___234 = options___0;
#line 394
            options___0 ++;
#line 394
            *(patterns + tmp___233) = *tmp___234;
          }
#line 396
          if (! *options___0) {
#line 397
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 399
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 401
            continue;
          }
#line 403
          *(patterns + i___2) = (char)0;
#line 404
          options___0 ++;
#line 405
          tmp___238 = strlen((char const   *)patterns);
#line 405
          tmp___239 = get_canonical_hostname();
#line 405
          tmp___240 = match_hostname(tmp___239, (char const   *)patterns, tmp___238);
#line 405
          if (! tmp___240) {
#line 405
            tmp___241 = strlen((char const   *)patterns);
#line 405
            tmp___242 = get_remote_ipaddr();
#line 405
            tmp___243 = match_hostname(tmp___242, (char const   *)patterns, tmp___241);
#line 405
            if (! tmp___243) {
#line 409
              tmp___235 = get_remote_ipaddr();
#line 409
              tmp___236 = get_canonical_hostname();
#line 409
              log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___236, tmp___235);
#line 412
              tmp___237 = get_canonical_hostname();
#line 412
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___237);
#line 414
              xfree((void *)patterns);
#line 416
              authenticated = 0;
#line 417
              no_agent_forwarding_flag = 0;
#line 418
              no_port_forwarding_flag = 0;
#line 419
              no_pty_flag = 0;
#line 420
              no_x11_forwarding_flag = 0;
#line 421
              while (custom_environment) {
#line 422
                ce = custom_environment;
#line 423
                custom_environment = ce->next;
#line 424
                xfree((void *)ce->s);
#line 425
                xfree((void *)ce);
              }
#line 427
              if (forced_command) {
#line 428
                xfree((void *)forced_command);
#line 429
                forced_command = (char *)((void *)0);
              }
#line 431
              break;
            }
          }
#line 433
          xfree((void *)patterns);
          goto next_option;
        }
        bad_option: 
#line 438
        log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
            linenum, options___0);
#line 440
        packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                          linenum, options___0);
#line 442
        authenticated = 0;
#line 443
        break;
        next_option: 
#line 450
        if (! *options___0) {
#line 451
          fatal("Bugs in auth-rsa.c option processing.");
        }
#line 452
        if ((int )*options___0 == 32) {
#line 453
          break;
        } else {
#line 452
          if ((int )*options___0 == 9) {
#line 453
            break;
          }
        }
#line 454
        if ((int )*options___0 != 44) {
          goto bad_option;
        }
#line 456
        options___0 ++;
#line 458
        continue;
      }
    }
#line 465
    if (authenticated) {
#line 466
      break;
    }
  }
#line 470
  restore_uid();
#line 473
  fclose(f);
#line 475
  BN_clear_free(n___0);
#line 476
  BN_clear_free(e);
#line 478
  if (authenticated) {
#line 479
    packet_send_debug("RSA authentication accepted.");
  }
#line 482
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 458 "/usr/include/openssl/bn.h"
extern void BN_free(BIGNUM *a ) ;
#line 31 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , BIGNUM *client_host_key_e ,
                    BIGNUM *client_host_key_n ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  BIGNUM *ke ;
  BIGNUM *kn ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 40
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 43
  tmp = auth_rhosts(pw, client_user);
#line 43
  if (! tmp) {
#line 44
    return (0);
  }
#line 46
  canonical_hostname = get_canonical_hostname();
#line 48
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 52
  ke = BN_new();
#line 53
  kn = BN_new();
#line 54
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_host_key_e, client_host_key_n, ke, kn);
#line 59
  if ((int )host_status != 0) {
#line 59
    if (! options.ignore_user_known_hosts) {
#line 61
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 61
      user_hostfile = tmp___0;
#line 66
      if (options.strict_modes) {
#line 66
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 66
        if (tmp___1 == 0) {
#line 66
          if (st.st_uid != 0U) {
#line 66
            if (st.st_uid != pw->pw_uid) {
#line 70
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 66
            if ((st.st_mode & 18U) != 0U) {
#line 70
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 74
              temporarily_use_uid(pw->pw_uid);
#line 75
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_host_key_e,
                                                   client_host_key_n, ke, kn);
#line 78
              restore_uid();
            }
          }
        } else {
#line 74
          temporarily_use_uid(pw->pw_uid);
#line 75
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_host_key_e, client_host_key_n,
                                               ke, kn);
#line 78
          restore_uid();
        }
      } else {
#line 74
        temporarily_use_uid(pw->pw_uid);
#line 75
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_host_key_e, client_host_key_n,
                                             ke, kn);
#line 78
        restore_uid();
      }
#line 80
      xfree((void *)user_hostfile);
    }
  }
#line 82
  BN_free(ke);
#line 83
  BN_free(kn);
#line 85
  if ((int )host_status != 0) {
#line 86
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 87
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 88
    return (0);
  }
#line 93
  tmp___2 = auth_rsa_challenge_dialog(client_host_key_e, client_host_key_n);
#line 93
  if (! tmp___2) {
#line 94
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 96
    return (0);
  }
#line 103
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 105
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 106
  return (1);
}
}
#line 1 "pty.o"
#line 280 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 57 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 49 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char buf___0[64] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 57
  i = openpty(ptyfd, ttyfd, buf___0, (void *)0, (void *)0);
#line 58
  if (i < 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("openpty: %.100s", tmp___0);
#line 60
    return (0);
  }
#line 62
  strlcpy(namebuf, (char const   *)(buf___0), (unsigned int )namebuflen);
#line 63
  return (1);
}
}
#line 189 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 192
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 192
  if (tmp___1 < 0) {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 194
  tmp___4 = chmod(ttyname___0, 438U);
#line 194
  if (tmp___4 < 0) {
#line 195
    tmp___2 = __errno_location();
#line 195
    tmp___3 = strerror(*tmp___2);
#line 195
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 196
  return;
}
}
#line 200 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 207
  fd = open("/dev/tty", 258);
#line 208
  if (fd >= 0) {
#line 209
    ioctl(fd, 21538UL, (void *)0);
#line 210
    close(fd);
  }
#line 213
  tmp___1 = setsid();
#line 213
  if (tmp___1 < 0) {
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    error("setsid: %.100s", tmp___0);
  }
#line 220
  fd = open("/dev/tty", 258);
#line 221
  if (fd >= 0) {
#line 222
    error("Failed to disconnect from controlling tty.");
#line 223
    close(fd);
  }
#line 227
  debug("Setting controlling tty using TIOCSCTTY.");
#line 233
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 235
  fd = open(ttyname___0, 2);
#line 236
  if (fd < 0) {
#line 237
    tmp___2 = __errno_location();
#line 237
    tmp___3 = strerror(*tmp___2);
#line 237
    error("%.100s: %.100s", ttyname___0, tmp___3);
  } else {
#line 239
    close(fd);
  }
#line 242
  fd = open("/dev/tty", 1);
#line 243
  if (fd < 0) {
#line 244
    tmp___4 = __errno_location();
#line 244
    tmp___5 = strerror(*tmp___4);
#line 244
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___5);
  } else {
#line 247
    close(fd);
  }
#line 249
  return;
}
}
#line 253 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 258
  w.ws_row = (unsigned short )row;
#line 259
  w.ws_col = (unsigned short )col;
#line 260
  w.ws_xpixel = (unsigned short )xpixel;
#line 261
  w.ws_ypixel = (unsigned short )ypixel;
#line 262
  ioctl(ptyfd, 21524UL, & w);
#line 263
  return;
}
}
#line 265 "pty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 273
  grp = getgrnam("tty");
#line 274
  if (grp) {
#line 275
    gid = grp->gr_gid;
#line 276
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 278
    gid = pw->pw_gid;
#line 279
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 283
  tmp___1 = chown(ttyname___0, pw->pw_uid, gid);
#line 283
  if (tmp___1 < 0) {
#line 284
    tmp = __errno_location();
#line 284
    tmp___0 = strerror(*tmp);
#line 284
    fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid, tmp___0);
  }
#line 286
  tmp___4 = chmod(ttyname___0, mode);
#line 286
  if (tmp___4 < 0) {
#line 287
    tmp___2 = __errno_location();
#line 287
    tmp___3 = strerror(*tmp___2);
#line 287
    fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___3);
  }
#line 289
  return;
}
}
#line 1 "log-server.o"
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "log-server.c"
extern char *__progname ;
#line 31 "log-server.c"
static LogLevel log_level  =    3;
#line 32 "log-server.c"
static int log_on_stderr  =    0;
#line 33 "log-server.c"
static int log_facility  =    4 << 3;
#line 41 "log-server.c"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 44
  switch ((int )level) {
  case 0: 
  case 2: 
  case 1: 
  case 3: 
  case 4: 
  case 5: 
#line 51
  log_level = level;
#line 52
  break;
  default: 
#line 54
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 56
  exit(1);
  }
#line 58
  switch ((int )facility) {
  case 0: 
#line 60
  log_facility = 3 << 3;
#line 61
  break;
  case 1: 
#line 63
  log_facility = 1 << 3;
#line 64
  break;
  case 2: 
#line 66
  log_facility = 4 << 3;
#line 67
  break;
  case 3: 
#line 69
  log_facility = 16 << 3;
#line 70
  break;
  case 4: 
#line 72
  log_facility = 17 << 3;
#line 73
  break;
  case 5: 
#line 75
  log_facility = 18 << 3;
#line 76
  break;
  case 6: 
#line 78
  log_facility = 19 << 3;
#line 79
  break;
  case 7: 
#line 81
  log_facility = 20 << 3;
#line 82
  break;
  case 8: 
#line 84
  log_facility = 21 << 3;
#line 85
  break;
  case 9: 
#line 87
  log_facility = 22 << 3;
#line 88
  break;
  case 10: 
#line 90
  log_facility = 23 << 3;
#line 91
  break;
  default: 
#line 93
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 95
  exit(1);
  }
#line 97
  log_on_stderr = on_stderr;
#line 98
  return;
}
}
#line 102 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 107
  txt = (char *)((void *)0);
#line 108
  pri = 6;
#line 110
  if ((int )level > (int )log_level) {
#line 111
    return;
  }
#line 112
  switch ((int )level) {
  case 2: 
#line 114
  txt = (char *)"error";
#line 115
  pri = 3;
#line 116
  break;
  case 1: 
#line 118
  txt = (char *)"fatal";
#line 119
  pri = 3;
#line 120
  break;
  case 3: 
  case 4: 
#line 123
  pri = 6;
#line 124
  break;
  case 5: 
#line 126
  txt = (char *)"debug";
#line 127
  pri = 7;
#line 128
  break;
  default: 
#line 130
  txt = (char *)"internal error";
#line 131
  pri = 3;
#line 132
  break;
  }
#line 134
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 135
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 136
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 138
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 140
  if (log_on_stderr) {
#line 141
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  }
#line 142
  openlog((char const   *)__progname, 1, log_facility);
#line 143
  syslog(pri, "%.500s", msgbuf);
#line 144
  closelog();
#line 145
  return;
}
}
#line 1 "login.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 52 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___0 ,
                                  unsigned int bufsize ) 
{ struct lastlog ll ;
  char *lastlog ;
  int fd ;
  ssize_t tmp ;

  {
#line 64
  lastlog = (char *)"/var/log/lastlog";
#line 65
  *(buf___0 + 0) = (char )'\000';
#line 68
  fd = open((char const   *)lastlog, 0);
#line 69
  if (fd < 0) {
#line 70
    return (0UL);
  }
#line 71
  lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)), 0);
#line 78
  tmp = read(fd, (void *)(& ll), sizeof(ll));
#line 78
  if ((unsigned int )tmp != sizeof(ll)) {
#line 79
    close(fd);
#line 80
    return (0UL);
  }
#line 82
  close(fd);
#line 83
  if (bufsize > sizeof(ll.ll_host) + 1U) {
#line 84
    bufsize = sizeof(ll.ll_host) + 1U;
  }
#line 85
  __builtin_strncpy(buf___0, (char const   *)(ll.ll_host), bufsize - 1U);
#line 86
  *(buf___0 + (bufsize - 1U)) = (char)0;
#line 87
  return ((unsigned long )ll.ll_time);
}
}
#line 138 "login.c"
void record_login(int pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct lastlog ll ;
  char *lastlog ;
  struct utmp u ;
  struct sockaddr_in *in ;
  struct sockaddr_in6 *in6 ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 155
  memset((void *)(& u), 0, sizeof(u));
#line 156
  __builtin_strncpy(u.ut_line, ttyname___0 + 5, sizeof(u.ut_line));
#line 158
  __builtin_strncpy(u.ut_id, ttyname___0 + 8, sizeof(u.ut_id));
#line 160
  __builtin_strncpy(u.ut_user, user, sizeof(u.ut_user));
#line 162
  gettimeofday((struct timeval * __restrict  )(& u.ut_tv), (struct timezone * __restrict  )((void *)0));
#line 167
  u.ut_pid = pid;
#line 170
  if (uid == 4294967295U) {
#line 170
    u.ut_type = (short)8;
  } else {
#line 170
    u.ut_type = (short)7;
  }
#line 173
  __builtin_strncpy(u.ut_host, host, sizeof(u.ut_host));
#line 176
  if (addr) {
#line 177
    switch ((int )addr->sa_family) {
    case 2: 
#line 179
    in = (struct sockaddr_in *)addr;
#line 180
    memcpy((void * __restrict  )(& u.ut_addr_v6[0]), (void const   * __restrict  )(& in->sin_addr),
           sizeof(& in->sin_addr));
#line 181
    break;
    case 10: 
#line 185
    in6 = (struct sockaddr_in6 *)addr;
#line 186
    memcpy((void * __restrict  )(u.ut_addr_v6), (void const   * __restrict  )(& in6->sin6_addr),
           sizeof(& in6->sin6_addr));
#line 187
    break;
    default: ;
#line 191
    break;
    }
  }
#line 238
  login((struct utmp  const  *)(& u));
#line 242
  lastlog = (char *)"/var/log/lastlog";
#line 245
  if (0) {
#line 245
    __s1_len = strlen(user);
#line 245
    __s2_len = strlen("");
#line 245
    if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
      goto _L___0;
    } else {
#line 245
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 245
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 245
          tmp___11 = 1;
        } else {
#line 245
          if (__s2_len >= 4U) {
#line 245
            tmp___11 = 1;
          } else {
#line 245
            tmp___11 = 0;
          }
        }
      } else {
#line 245
        tmp___11 = 0;
      }
    }
#line 245
    if (tmp___11) {
#line 245
      tmp___7 = __builtin_strcmp(user, "");
    } else {
#line 245
      tmp___10 = __builtin_strcmp(user, "");
#line 245
      tmp___7 = tmp___10;
    }
  } else {
#line 245
    tmp___10 = __builtin_strcmp(user, "");
#line 245
    tmp___7 = tmp___10;
  }
#line 245
  if (tmp___7 != 0) {
#line 251
    memset((void *)(& ll), 0, sizeof(ll));
#line 254
    ll.ll_time = time((time_t *)((void *)0));
#line 255
    __builtin_strncpy(ll.ll_line, ttyname___0 + 5, sizeof(ll.ll_line));
#line 256
    __builtin_strncpy(ll.ll_host, host, sizeof(ll.ll_host));
#line 262
    fd = open((char const   *)lastlog, 2);
#line 263
    if (fd >= 0) {
#line 264
      lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)),
            0);
#line 266
      tmp___1 = write(fd, (void const   *)(& ll), sizeof(ll));
#line 266
      if ((unsigned int )tmp___1 != sizeof(ll)) {
#line 267
        tmp = __errno_location();
#line 267
        tmp___0 = strerror(*tmp);
#line 267
        log("Could not write %.100s: %.100s", lastlog, tmp___0);
      }
#line 268
      close(fd);
    }
  }
#line 272
  return;
}
}
#line 276 "login.c"
void record_logout(int pid , char const   *ttyname___0 ) 
{ char const   *line ;
  int tmp ;

  {
#line 280
  line = ttyname___0 + 5;
#line 281
  tmp = logout(line);
#line 281
  if (tmp) {
#line 282
    logwtmp(line, "", "");
  }
#line 286
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "servconf.o"
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 22 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) ;
#line 26 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 29
  memset((void *)options___0, 0, sizeof(*options___0));
#line 30
  options___0->num_ports = 0U;
#line 31
  options___0->ports_from_cmdline = 0U;
#line 32
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 33
  options___0->host_key_file = (char *)((void *)0);
#line 34
  options___0->server_key_bits = -1;
#line 35
  options___0->login_grace_time = -1;
#line 36
  options___0->key_regeneration_time = -1;
#line 37
  options___0->permit_root_login = -1;
#line 38
  options___0->ignore_rhosts = -1;
#line 39
  options___0->ignore_user_known_hosts = -1;
#line 40
  options___0->print_motd = -1;
#line 41
  options___0->check_mail = -1;
#line 42
  options___0->x11_forwarding = -1;
#line 43
  options___0->x11_display_offset = -1;
#line 44
  options___0->strict_modes = -1;
#line 45
  options___0->keepalives = -1;
#line 46
  options___0->log_facility = (enum __anonenum_SyslogFacility_72 )-1;
#line 47
  options___0->log_level = (enum __anonenum_LogLevel_73 )-1;
#line 48
  options___0->rhosts_authentication = -1;
#line 49
  options___0->rhosts_rsa_authentication = -1;
#line 50
  options___0->rsa_authentication = -1;
#line 60
  options___0->password_authentication = -1;
#line 64
  options___0->permit_empty_passwd = -1;
#line 65
  options___0->use_login = -1;
#line 66
  options___0->num_allow_users = 0U;
#line 67
  options___0->num_deny_users = 0U;
#line 68
  options___0->num_allow_groups = 0U;
#line 69
  options___0->num_deny_groups = 0U;
#line 70
  return;
}
}
#line 72 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ unsigned int tmp ;

  {
#line 75
  if (options___0->num_ports == 0U) {
#line 76
    tmp = options___0->num_ports;
#line 76
    (options___0->num_ports) ++;
#line 76
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 77
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 78
    add_listen_addr(options___0, (char *)((void *)0));
  }
#line 79
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 80
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 81
  if (options___0->server_key_bits == -1) {
#line 82
    options___0->server_key_bits = 768;
  }
#line 83
  if (options___0->login_grace_time == -1) {
#line 84
    options___0->login_grace_time = 600;
  }
#line 85
  if (options___0->key_regeneration_time == -1) {
#line 86
    options___0->key_regeneration_time = 3600;
  }
#line 87
  if (options___0->permit_root_login == -1) {
#line 88
    options___0->permit_root_login = 1;
  }
#line 89
  if (options___0->ignore_rhosts == -1) {
#line 90
    options___0->ignore_rhosts = 1;
  }
#line 91
  if (options___0->ignore_user_known_hosts == -1) {
#line 92
    options___0->ignore_user_known_hosts = 0;
  }
#line 93
  if (options___0->check_mail == -1) {
#line 94
    options___0->check_mail = 0;
  }
#line 95
  if (options___0->print_motd == -1) {
#line 96
    options___0->print_motd = 1;
  }
#line 97
  if (options___0->x11_forwarding == -1) {
#line 98
    options___0->x11_forwarding = 0;
  }
#line 99
  if (options___0->x11_display_offset == -1) {
#line 100
    options___0->x11_display_offset = 10;
  }
#line 101
  if (options___0->strict_modes == -1) {
#line 102
    options___0->strict_modes = 1;
  }
#line 103
  if (options___0->keepalives == -1) {
#line 104
    options___0->keepalives = 1;
  }
#line 105
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 106
    options___0->log_facility = 2;
  }
#line 107
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 108
    options___0->log_level = 3;
  }
#line 109
  if (options___0->rhosts_authentication == -1) {
#line 110
    options___0->rhosts_authentication = 0;
  }
#line 111
  if (options___0->rhosts_rsa_authentication == -1) {
#line 112
    options___0->rhosts_rsa_authentication = 0;
  }
#line 113
  if (options___0->rsa_authentication == -1) {
#line 114
    options___0->rsa_authentication = 1;
  }
#line 129
  if (options___0->password_authentication == -1) {
#line 130
    options___0->password_authentication = 1;
  }
#line 135
  if (options___0->permit_empty_passwd == -1) {
#line 136
    options___0->permit_empty_passwd = 0;
  }
#line 137
  if (options___0->use_login == -1) {
#line 138
    options___0->use_login = 0;
  }
#line 139
  return;
}
}
#line 166 "servconf.c"
static struct __anonstruct_keywords_76 keywords[29]  = 
#line 166
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"ignoreuserknownhosts", 28}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 218 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  int tmp ;

  {
#line 224
  i = 0U;
#line 224
  while (keywords[i].name) {
#line 225
    tmp = strcasecmp(cp, keywords[i].name);
#line 225
    if (tmp == 0) {
#line 226
      return (keywords[i].opcode);
    }
#line 224
    i ++;
  }
#line 228
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 230
  return (0);
}
}
#line 236 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int i ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 245
  if (options___0->num_ports == 0U) {
#line 246
    tmp = options___0->num_ports;
#line 246
    (options___0->num_ports) ++;
#line 246
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 247
  i = 0;
#line 247
  while ((unsigned int )i < options___0->num_ports) {
#line 248
    memset((void *)(& hints), 0, sizeof(hints));
#line 249
    hints.ai_family = IPv4or6;
#line 250
    hints.ai_socktype = 1;
#line 251
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 251
      hints.ai_flags = 1;
    } else {
#line 251
      hints.ai_flags = 0;
    }
#line 252
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             options___0->ports[i]);
#line 253
    gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 253
    if (gaierr != 0) {
#line 254
      tmp___0 = gai_strerror(gaierr);
#line 254
      if (addr) {
#line 254
        tmp___1 = (char const   *)addr;
      } else {
#line 254
        tmp___1 = "<NULL>";
      }
#line 254
      fatal("bad addr or host: %s (%s)\n", tmp___1, tmp___0);
    }
#line 257
    ai = aitop;
#line 257
    while (ai->ai_next) {
#line 257
      ai = ai->ai_next;
    }
#line 259
    ai->ai_next = options___0->listen_addrs;
#line 260
    options___0->listen_addrs = aitop;
#line 247
    i ++;
  }
#line 262
  return;
}
}
#line 266 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  __uid_t tmp___33 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___59 ;
  int tmp___62 ;
  int tmp___63 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___79 ;
  int tmp___82 ;
  int tmp___83 ;
  SyslogFacility tmp___84 ;
  char const   *tmp___85 ;
  LogLevel tmp___86 ;
  char const   *tmp___87 ;
  unsigned int tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;

  {
#line 273
  bad_options = 0;
#line 276
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 277
  if (! f) {
#line 278
    perror(filename);
#line 279
    exit(1);
  }
#line 281
  linenum = 0;
#line 282
  while (1) {
#line 282
    tmp___93 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 282
    if (! tmp___93) {
#line 282
      break;
    }
#line 283
    linenum ++;
#line 284
    tmp___30 = __builtin_strspn((char const   *)(line), " \t\r\n");
#line 284
    cp = line + tmp___30;
#line 285
    if (! *cp) {
#line 286
      continue;
    } else {
#line 285
      if ((int )*cp == 35) {
#line 286
        continue;
      }
    }
#line 287
    cp = strtok((char * __restrict  )cp, (char const   * __restrict  )" \t\r\n");
#line 288
    opcode = parse_token((char const   *)cp, filename, linenum);
#line 289
    switch ((int )opcode) {
    case 0: 
#line 291
    bad_options ++;
#line 292
    continue;
    case 1: 
#line 295
    if (options___0->ports_from_cmdline) {
#line 296
      continue;
    }
#line 297
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 298
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 300
    if (options___0->num_ports >= 256U) {
#line 301
      fatal("%s line %d: too many ports.\n", filename, linenum);
    }
#line 303
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 304
    if (! cp) {
#line 305
      fatal("%s line %d: missing port number.\n", filename, linenum);
    }
#line 307
    tmp___31 = options___0->num_ports;
#line 307
    (options___0->num_ports) ++;
#line 307
    tmp___32 = atoi((char const   *)cp);
#line 307
    options___0->ports[tmp___31] = (unsigned short )tmp___32;
#line 308
    break;
    case 3: 
#line 311
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 313
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 314
    if (! cp) {
#line 315
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 317
      exit(1);
    }
#line 319
    value = atoi((char const   *)cp);
#line 320
    if (*intptr == -1) {
#line 321
      *intptr = value;
    }
#line 322
    break;
    case 4: 
#line 325
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 329
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 333
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 334
    if (! cp) {
#line 335
      fatal("%s line %d: missing inet addr.\n", filename, linenum);
    }
#line 337
    add_listen_addr(options___0, cp);
#line 338
    break;
    case 2: 
#line 341
    charptr = & options___0->host_key_file;
#line 342
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 343
    if (! cp) {
#line 344
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 346
      exit(1);
    }
#line 348
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 349
      tmp___33 = getuid();
#line 349
      *charptr = tilde_expand_filename((char const   *)cp, tmp___33);
    }
#line 350
    break;
    case 20: 
#line 353
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 355
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 356
    break;
    case 6: 
#line 359
    intptr = & options___0->permit_root_login;
#line 360
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 361
    if (! cp) {
#line 362
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 364
      exit(1);
    }
#line 366
    if (0) {
#line 366
      __s1_len___1 = strlen((char const   *)cp);
#line 366
      __s2_len___1 = strlen("without-password");
#line 366
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___4;
      } else {
#line 366
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 366
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 366
            tmp___63 = 1;
          } else {
#line 366
            if (__s2_len___1 >= 4U) {
#line 366
              tmp___63 = 1;
            } else {
#line 366
              tmp___63 = 0;
            }
          }
        } else {
#line 366
          tmp___63 = 0;
        }
      }
#line 366
      if (tmp___63) {
#line 366
        tmp___59 = __builtin_strcmp((char const   *)cp, "without-password");
      } else {
#line 366
        tmp___62 = __builtin_strcmp((char const   *)cp, "without-password");
#line 366
        tmp___59 = tmp___62;
      }
    } else {
#line 366
      tmp___62 = __builtin_strcmp((char const   *)cp, "without-password");
#line 366
      tmp___59 = tmp___62;
    }
#line 366
    if (tmp___59 == 0) {
#line 367
      value = 2;
    } else {
#line 368
      if (0) {
#line 368
        __s1_len___0 = strlen((char const   *)cp);
#line 368
        __s2_len___0 = strlen("yes");
#line 368
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 368
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 368
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 368
              tmp___53 = 1;
            } else {
#line 368
              if (__s2_len___0 >= 4U) {
#line 368
                tmp___53 = 1;
              } else {
#line 368
                tmp___53 = 0;
              }
            }
          } else {
#line 368
            tmp___53 = 0;
          }
        }
#line 368
        if (tmp___53) {
#line 368
          tmp___49 = __builtin_strcmp((char const   *)cp, "yes");
        } else {
#line 368
          tmp___52 = __builtin_strcmp((char const   *)cp, "yes");
#line 368
          tmp___49 = tmp___52;
        }
      } else {
#line 368
        tmp___52 = __builtin_strcmp((char const   *)cp, "yes");
#line 368
        tmp___49 = tmp___52;
      }
#line 368
      if (tmp___49 == 0) {
#line 369
        value = 1;
      } else {
#line 370
        if (0) {
#line 370
          __s1_len = strlen((char const   *)cp);
#line 370
          __s2_len = strlen("no");
#line 370
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___0;
          } else {
#line 370
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 370
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 370
                tmp___43 = 1;
              } else {
#line 370
                if (__s2_len >= 4U) {
#line 370
                  tmp___43 = 1;
                } else {
#line 370
                  tmp___43 = 0;
                }
              }
            } else {
#line 370
              tmp___43 = 0;
            }
          }
#line 370
          if (tmp___43) {
#line 370
            tmp___39 = __builtin_strcmp((char const   *)cp, "no");
          } else {
#line 370
            tmp___42 = __builtin_strcmp((char const   *)cp, "no");
#line 370
            tmp___39 = tmp___42;
          }
        } else {
#line 370
          tmp___42 = __builtin_strcmp((char const   *)cp, "no");
#line 370
          tmp___39 = tmp___42;
        }
#line 370
        if (tmp___39 == 0) {
#line 371
          value = 0;
        } else {
#line 373
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, cp);
#line 375
          exit(1);
        }
      }
    }
#line 377
    if (*intptr == -1) {
#line 378
      *intptr = value;
    }
#line 379
    break;
    case 15: 
#line 382
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 384
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 385
    if (! cp) {
#line 386
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 388
      exit(1);
    }
#line 390
    if (0) {
#line 390
      __s1_len___3 = strlen((char const   *)cp);
#line 390
      __s2_len___3 = strlen("yes");
#line 390
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___8;
      } else {
#line 390
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 390
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 390
            tmp___83 = 1;
          } else {
#line 390
            if (__s2_len___3 >= 4U) {
#line 390
              tmp___83 = 1;
            } else {
#line 390
              tmp___83 = 0;
            }
          }
        } else {
#line 390
          tmp___83 = 0;
        }
      }
#line 390
      if (tmp___83) {
#line 390
        tmp___79 = __builtin_strcmp((char const   *)cp, "yes");
      } else {
#line 390
        tmp___82 = __builtin_strcmp((char const   *)cp, "yes");
#line 390
        tmp___79 = tmp___82;
      }
    } else {
#line 390
      tmp___82 = __builtin_strcmp((char const   *)cp, "yes");
#line 390
      tmp___79 = tmp___82;
    }
#line 390
    if (tmp___79 == 0) {
#line 391
      value = 1;
    } else {
#line 392
      if (0) {
#line 392
        __s1_len___2 = strlen((char const   *)cp);
#line 392
        __s2_len___2 = strlen("no");
#line 392
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___6;
        } else {
#line 392
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 392
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 392
              tmp___73 = 1;
            } else {
#line 392
              if (__s2_len___2 >= 4U) {
#line 392
                tmp___73 = 1;
              } else {
#line 392
                tmp___73 = 0;
              }
            }
          } else {
#line 392
            tmp___73 = 0;
          }
        }
#line 392
        if (tmp___73) {
#line 392
          tmp___69 = __builtin_strcmp((char const   *)cp, "no");
        } else {
#line 392
          tmp___72 = __builtin_strcmp((char const   *)cp, "no");
#line 392
          tmp___69 = tmp___72;
        }
      } else {
#line 392
        tmp___72 = __builtin_strcmp((char const   *)cp, "no");
#line 392
        tmp___69 = tmp___72;
      }
#line 392
      if (tmp___69 == 0) {
#line 393
        value = 0;
      } else {
#line 395
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, cp);
#line 397
        exit(1);
      }
    }
#line 399
    if (*intptr == -1) {
#line 400
      *intptr = value;
    }
#line 401
    break;
    case 28: 
#line 404
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 408
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 412
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 416
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 12: 
#line 444
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 448
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 458
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 462
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 466
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 18: 
#line 470
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 474
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 478
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 482
    intptr = & options___0->use_login;
    goto parse_flag;
    case 7: 
#line 486
    intptr = (int *)(& options___0->log_facility);
#line 487
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 488
    tmp___84 = log_facility_number(cp);
#line 488
    value = (int )tmp___84;
#line 489
    if (value == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 490
      if (cp) {
#line 490
        tmp___85 = (char const   *)cp;
      } else {
#line 490
        tmp___85 = "<NONE>";
      }
#line 490
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___85);
    }
#line 492
    if (*intptr == -1) {
#line 493
      *intptr = (int )((enum __anonenum_SyslogFacility_72 )value);
    }
#line 494
    break;
    case 8: 
#line 497
    intptr = (int *)(& options___0->log_level);
#line 498
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 499
    tmp___86 = log_level_number(cp);
#line 499
    value = (int )tmp___86;
#line 500
    if (value == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 501
      if (cp) {
#line 501
        tmp___87 = (char const   *)cp;
      } else {
#line 501
        tmp___87 = "<NONE>";
      }
#line 501
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___87);
    }
#line 503
    if (*intptr == -1) {
#line 504
      *intptr = (int )((enum __anonenum_LogLevel_73 )value);
    }
#line 505
    break;
    case 24: 
#line 508
    while (1) {
#line 508
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 508
      if (! cp) {
#line 508
        break;
      }
#line 509
      if (options___0->num_allow_users >= 256U) {
#line 510
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow users.\n",
                filename, linenum);
#line 512
        exit(1);
      }
#line 514
      tmp___88 = options___0->num_allow_users;
#line 514
      (options___0->num_allow_users) ++;
#line 514
      options___0->allow_users[tmp___88] = xstrdup((char const   *)cp);
    }
#line 516
    break;
    case 25: 
#line 519
    while (1) {
#line 519
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 519
      if (! cp) {
#line 519
        break;
      }
#line 520
      if (options___0->num_deny_users >= 256U) {
#line 521
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny users.\n",
                filename, linenum);
#line 523
        exit(1);
      }
#line 525
      tmp___89 = options___0->num_deny_users;
#line 525
      (options___0->num_deny_users) ++;
#line 525
      options___0->deny_users[tmp___89] = xstrdup((char const   *)cp);
    }
#line 527
    break;
    case 26: 
#line 530
    while (1) {
#line 530
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 530
      if (! cp) {
#line 530
        break;
      }
#line 531
      if (options___0->num_allow_groups >= 256U) {
#line 532
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many allow groups.\n",
                filename, linenum);
#line 534
        exit(1);
      }
#line 536
      tmp___90 = options___0->num_allow_groups;
#line 536
      (options___0->num_allow_groups) ++;
#line 536
      options___0->allow_groups[tmp___90] = xstrdup((char const   *)cp);
    }
#line 538
    break;
    case 27: 
#line 541
    while (1) {
#line 541
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 541
      if (! cp) {
#line 541
        break;
      }
#line 542
      if (options___0->num_deny_groups >= 256U) {
#line 543
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: too many deny groups.\n",
                filename, linenum);
#line 545
        exit(1);
      }
#line 547
      tmp___91 = options___0->num_deny_groups;
#line 547
      (options___0->num_deny_groups) ++;
#line 547
      options___0->deny_groups[tmp___91] = xstrdup((char const   *)cp);
    }
#line 549
    break;
    default: 
#line 552
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, cp, opcode);
#line 554
    exit(1);
    }
#line 556
    tmp___92 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 556
    if ((unsigned int )tmp___92 != (unsigned int )((void *)0)) {
#line 557
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line.\n",
              filename, linenum);
#line 559
      exit(1);
    }
  }
#line 562
  fclose(f);
#line 563
  if (bad_options > 0) {
#line 564
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 566
    exit(1);
  }
#line 568
  return;
}
}
#line 1 "serverloop.o"
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 17 "serverloop.c"
static Buffer stdin_buffer  ;
#line 18 "serverloop.c"
static Buffer stdout_buffer  ;
#line 19 "serverloop.c"
static Buffer stderr_buffer  ;
#line 20 "serverloop.c"
static int fdin  ;
#line 21 "serverloop.c"
static int fdout  ;
#line 23 "serverloop.c"
static int fderr  ;
#line 24 "serverloop.c"
static long stdin_bytes  =    0L;
#line 25 "serverloop.c"
static long stdout_bytes  =    0L;
#line 26 "serverloop.c"
static long stderr_bytes  =    0L;
#line 27 "serverloop.c"
static long fdout_bytes  =    0L;
#line 28 "serverloop.c"
static int stdin_eof  =    0;
#line 29 "serverloop.c"
static int fdout_eof  =    0;
#line 30 "serverloop.c"
static int fderr_eof  =    0;
#line 31 "serverloop.c"
static int connection_in___0  ;
#line 32 "serverloop.c"
static int connection_out___0  ;
#line 33 "serverloop.c"
static unsigned int buffer_high  ;
#line 34 "serverloop.c"
static int max_fd  ;
#line 45 "serverloop.c"
static int child_pid  ;
#line 46 "serverloop.c"
static int volatile   child_terminated  ;
#line 47 "serverloop.c"
static int volatile   child_has_selected  ;
#line 48 "serverloop.c"
static int volatile   child_wait_status  ;
#line 50 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int wait_pid ;
  union __anonunion_76 __constr_expr_0 ;
  union __anonunion_77 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 53
  tmp = __errno_location();
#line 53
  save_errno = *tmp;
#line 55
  debug("Received SIGCHLD.");
#line 56
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 57
  if (wait_pid != -1) {
#line 58
    if (wait_pid != child_pid) {
#line 59
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 61
    __constr_expr_0.__in = child_wait_status;
#line 61
    if ((__constr_expr_0.__i & 127) == 0) {
#line 63
      child_terminated = (int volatile   )1;
    } else {
#line 61
      __constr_expr_1.__in = child_wait_status;
#line 61
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 63
        child_terminated = (int volatile   )1;
      }
    }
#line 64
    child_has_selected = (int volatile   )0;
  }
#line 66
  signal(17, & sigchld_handler);
#line 67
  tmp___0 = __errno_location();
#line 67
  *tmp___0 = save_errno;
#line 68
  return;
}
}
#line 73 "serverloop.c"
void process_buffered_input_packets(void) 
{ int type ;
  char *data ;
  unsigned int data_len ;
  int row ;
  int col ;
  int xpixel ;
  int ypixel ;
  int payload_len ;
  int _p ;
  int _e ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _p___2 ;
  int _e___2 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int _p___5 ;
  int _e___5 ;

  {
#line 83
  while (1) {
#line 83
    type = packet_read_poll(& payload_len);
#line 83
    if (! (type != 0)) {
#line 83
      break;
    }
#line 84
    switch (type) {
    case 16: 
#line 88
    if (fdin == -1) {
#line 89
      break;
    }
#line 90
    data = packet_get_string(& data_len);
#line 91
    while (1) {
#line 91
      _p = payload_len;
#line 91
      _e = (int )(4U + data_len);
#line 91
      if (_p != _e) {
#line 91
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c",
            91);
#line 91
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 91
      break;
    }
#line 92
    buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 93
    memset((void *)data, 0, data_len);
#line 94
    xfree((void *)data);
#line 95
    break;
    case 19: 
#line 103
    debug("EOF received for stdin.");
#line 104
    while (1) {
#line 104
      _p___0 = payload_len;
#line 104
      _e___0 = 0;
#line 104
      if (_p___0 != _e___0) {
#line 104
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "serverloop.c",
            104);
#line 104
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 104
      break;
    }
#line 105
    stdin_eof = 1;
#line 106
    break;
    case 11: 
#line 109
    debug("Window change received.");
#line 110
    while (1) {
#line 110
      _p___1 = payload_len;
#line 110
      _e___1 = 16;
#line 110
      if (_p___1 != _e___1) {
#line 110
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "serverloop.c",
            110);
#line 110
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 110
      break;
    }
#line 111
    tmp = packet_get_int();
#line 111
    row = (int )tmp;
#line 112
    tmp___0 = packet_get_int();
#line 112
    col = (int )tmp___0;
#line 113
    tmp___1 = packet_get_int();
#line 113
    xpixel = (int )tmp___1;
#line 114
    tmp___2 = packet_get_int();
#line 114
    ypixel = (int )tmp___2;
#line 115
    if (fdin != -1) {
#line 116
      pty_change_window_size(fdin, row, col, xpixel, ypixel);
    }
#line 117
    break;
    case 29: 
#line 120
    debug("Received port open request.");
#line 121
    channel_input_port_open(payload_len);
#line 122
    break;
    case 21: 
#line 125
    debug("Received channel open confirmation.");
#line 126
    while (1) {
#line 126
      _p___2 = payload_len;
#line 126
      _e___2 = 8;
#line 126
      if (_p___2 != _e___2) {
#line 126
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "serverloop.c",
            126);
#line 126
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 126
      break;
    }
#line 127
    channel_input_open_confirmation();
#line 128
    break;
    case 22: 
#line 131
    debug("Received channel open failure.");
#line 132
    while (1) {
#line 132
      _p___3 = payload_len;
#line 132
      _e___3 = 4;
#line 132
      if (_p___3 != _e___3) {
#line 132
        log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "serverloop.c",
            132);
#line 132
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 132
      break;
    }
#line 133
    channel_input_open_failure();
#line 134
    break;
    case 23: 
#line 137
    channel_input_data(payload_len);
#line 138
    break;
    case 24: 
#line 141
    debug("Received channel close.");
#line 142
    while (1) {
#line 142
      _p___4 = payload_len;
#line 142
      _e___4 = 4;
#line 142
      if (_p___4 != _e___4) {
#line 142
        log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "serverloop.c",
            142);
#line 142
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 142
      break;
    }
#line 143
    channel_input_close();
#line 144
    break;
    case 25: 
#line 147
    debug("Received channel close confirmation.");
#line 148
    while (1) {
#line 148
      _p___5 = payload_len;
#line 148
      _e___5 = 4;
#line 148
      if (_p___5 != _e___5) {
#line 148
        log("Packet integrity error (%d != %d) at %s:%d", _p___5, _e___5, "serverloop.c",
            148);
#line 148
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 148
      break;
    }
#line 149
    channel_input_close_confirmation();
#line 150
    break;
    default: 
#line 162
    packet_disconnect("Protocol error during session: type %d", type);
    }
  }
#line 166
  return;
}
}
#line 172 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 178
  while (1) {
#line 178
    tmp___2 = buffer_len(& stderr_buffer);
#line 178
    if (tmp___2 > 0U) {
#line 178
      tmp___3 = packet_not_very_much_data_to_write();
#line 178
      if (! tmp___3) {
#line 178
        break;
      }
    } else {
#line 178
      break;
    }
#line 180
    tmp = buffer_len(& stderr_buffer);
#line 180
    len = (int )tmp;
#line 181
    tmp___0 = packet_is_interactive();
#line 181
    if (tmp___0) {
#line 182
      if (len > 512) {
#line 183
        len = 512;
      }
    } else {
#line 186
      if (len > max_packet_size) {
#line 187
        len = max_packet_size;
      }
    }
#line 189
    packet_start(18);
#line 190
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 190
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 191
    packet_send();
#line 192
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 193
    stderr_bytes += (long )len;
  }
#line 195
  return;
}
}
#line 201 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 207
  while (1) {
#line 207
    tmp___2 = buffer_len(& stdout_buffer);
#line 207
    if (tmp___2 > 0U) {
#line 207
      tmp___3 = packet_not_very_much_data_to_write();
#line 207
      if (! tmp___3) {
#line 207
        break;
      }
    } else {
#line 207
      break;
    }
#line 209
    tmp = buffer_len(& stdout_buffer);
#line 209
    len = (int )tmp;
#line 210
    tmp___0 = packet_is_interactive();
#line 210
    if (tmp___0) {
#line 211
      if (len > 512) {
#line 212
        len = 512;
      }
    } else {
#line 215
      if (len > max_packet_size) {
#line 216
        len = max_packet_size;
      }
    }
#line 218
    packet_start(17);
#line 219
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 219
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 220
    packet_send();
#line 221
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 222
    stdout_bytes += (long )len;
  }
#line 224
  return;
}
}
#line 232 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  retry_select: 
#line 243
  while (1) {
#line 243
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 243
    break;
  }
#line 249
  tmp = buffer_len(& stdin_buffer);
#line 249
  if (tmp < 4096U) {
#line 249
    tmp___0 = channel_not_very_much_buffered_data();
#line 249
    if (tmp___0) {
#line 251
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 257
  tmp___1 = packet_not_very_much_data_to_write();
#line 257
  if (tmp___1) {
#line 258
    if (! fdout_eof) {
#line 259
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 260
    if (! fderr_eof) {
#line 261
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 263
  while (1) {
#line 263
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 263
    break;
  }
#line 266
  channel_prepare_select(readset, writeset);
#line 272
  tmp___2 = packet_have_data_to_write();
#line 272
  if (tmp___2) {
#line 273
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 277
  if (fdin != -1) {
#line 277
    tmp___3 = buffer_len(& stdin_buffer);
#line 277
    if (tmp___3 > 0U) {
#line 278
      __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 281
  tmp___4 = channel_max_fd();
#line 281
  if (tmp___4 > max_fd) {
#line 282
    max_fd = channel_max_fd();
  }
#line 288
  if (child_terminated) {
#line 288
    tmp___5 = packet_not_very_much_data_to_write();
#line 288
    if (tmp___5) {
#line 289
      if (max_time_milliseconds == 0U) {
#line 290
        max_time_milliseconds = 100U;
      }
    }
  }
#line 292
  if (max_time_milliseconds == 0U) {
#line 293
    tvp = (struct timeval *)((void *)0);
  } else {
#line 295
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 296
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 297
    tvp = & tv;
  }
#line 301
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 303
  if (ret < 0) {
#line 304
    tmp___8 = __errno_location();
#line 304
    if (*tmp___8 != 4) {
#line 305
      tmp___6 = __errno_location();
#line 305
      tmp___7 = strerror(*tmp___6);
#line 305
      error("select: %.100s", tmp___7);
    } else {
      goto retry_select;
    }
  }
#line 310
  if (child_terminated) {
#line 311
    child_has_selected = (int volatile   )1;
  }
#line 312
  return;
}
}
#line 318 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___0[16384] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register char __result ;
  register char __result___0 ;
  register char __result___1 ;

  {
#line 325
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 325
  if (__result) {
#line 326
    len = read(connection_in___0, (void *)(buf___0), sizeof(buf___0));
#line 327
    if (len == 0) {
#line 328
      verbose("Connection closed by remote host.");
#line 329
      fatal_cleanup();
    }
#line 335
    if (len < 0) {
#line 335
      tmp = __errno_location();
#line 335
      if (*tmp == 11) {
#line 336
        len = 0;
      }
    }
#line 338
    if (len < 0) {
#line 339
      tmp___0 = __errno_location();
#line 339
      tmp___1 = strerror(*tmp___0);
#line 339
      verbose("Read error from remote host: %.100s", tmp___1);
#line 340
      fatal_cleanup();
    }
#line 343
    packet_process_incoming((char const   *)(buf___0), (unsigned int )len);
  }
#line 346
  if (! fdout_eof) {
#line 346
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 346
    if (__result___0) {
#line 347
      len = read(fdout, (void *)(buf___0), sizeof(buf___0));
#line 348
      if (len <= 0) {
#line 349
        fdout_eof = 1;
      } else {
#line 351
        buffer_append(& stdout_buffer, (char const   *)(buf___0), (unsigned int )len);
#line 352
        fdout_bytes += (long )len;
      }
    }
  }
#line 356
  if (! fderr_eof) {
#line 356
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 356
    if (__result___1) {
#line 357
      len = read(fderr, (void *)(buf___0), sizeof(buf___0));
#line 358
      if (len <= 0) {
#line 359
        fderr_eof = 1;
      } else {
#line 361
        buffer_append(& stderr_buffer, (char const   *)(buf___0), (unsigned int )len);
      }
    }
  }
#line 363
  return;
}
}
#line 368 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;

  {
#line 374
  if (fdin != -1) {
#line 374
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 374
    if (__result) {
#line 375
      tmp = buffer_len(& stdin_buffer);
#line 375
      tmp___0 = buffer_ptr(& stdin_buffer);
#line 375
      len = write(fdin, (void const   *)tmp___0, tmp);
#line 377
      if (len <= 0) {
#line 381
        if (fdout == -1) {
#line 382
          close(fdin);
        } else {
#line 384
          shutdown(fdin, 1);
        }
#line 386
        fdin = -1;
      } else {
#line 389
        buffer_consume(& stdin_buffer, (unsigned int )len);
#line 391
        stdin_bytes += (long )len;
      }
    }
  }
#line 395
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 395
  if (__result___0) {
#line 396
    packet_write_poll();
  }
#line 397
  return;
}
}
#line 403 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 407
  tmp___2 = buffer_len(& stdout_buffer);
#line 407
  if (tmp___2 > 0U) {
#line 408
    packet_start(17);
#line 409
    tmp = buffer_len(& stdout_buffer);
#line 409
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 409
    packet_put_string((char const   *)tmp___0, tmp);
#line 411
    packet_send();
#line 413
    tmp___1 = buffer_len(& stdout_buffer);
#line 413
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 416
  tmp___6 = buffer_len(& stderr_buffer);
#line 416
  if (tmp___6 > 0U) {
#line 417
    packet_start(18);
#line 418
    tmp___3 = buffer_len(& stderr_buffer);
#line 418
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 418
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 420
    packet_send();
#line 422
    tmp___5 = buffer_len(& stderr_buffer);
#line 422
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 425
  packet_write_wait();
#line 426
  return;
}
}
#line 435 "serverloop.c"
void server_loop(int pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ int wait_status ;
  int wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  fd_set readset ;
  fd_set writeset ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_78 __constr_expr_0 ;
  union __anonunion_79 __constr_expr_1 ;
  int plen ;
  union __anonunion_80 __constr_expr_2 ;
  union __anonunion_81 __constr_expr_3 ;
  union __anonunion_82 __constr_expr_4 ;

  {
#line 439
  waiting_termination = 0;
#line 445
  debug("Entering interactive session.");
#line 448
  child_pid = pid;
#line 449
  child_terminated = (int volatile   )0;
#line 450
  child_has_selected = (int volatile   )0;
#line 451
  signal(17, & sigchld_handler);
#line 454
  fdin = fdin_arg;
#line 455
  fdout = fdout_arg;
#line 456
  fderr = fderr_arg;
#line 457
  connection_in___0 = packet_get_connection_in();
#line 458
  connection_out___0 = packet_get_connection_out();
#line 460
  previous_stdout_buffer_bytes = 0U;
#line 463
  tmp = packet_is_interactive();
#line 463
  if (tmp) {
#line 464
    buffer_high = 4096U;
  } else {
#line 466
    buffer_high = 65536U;
  }
#line 469
  max_fd = fdin;
#line 470
  if (fdout > max_fd) {
#line 471
    max_fd = fdout;
  }
#line 472
  if (fderr != -1) {
#line 472
    if (fderr > max_fd) {
#line 473
      max_fd = fderr;
    }
  }
#line 474
  if (connection_in___0 > max_fd) {
#line 475
    max_fd = connection_in___0;
  }
#line 476
  if (connection_out___0 > max_fd) {
#line 477
    max_fd = connection_out___0;
  }
#line 480
  buffer_init(& stdin_buffer);
#line 481
  buffer_init(& stdout_buffer);
#line 482
  buffer_init(& stderr_buffer);
#line 490
  if (fderr == -1) {
#line 491
    fderr_eof = 1;
  }
#line 494
  while (1) {
#line 498
    process_buffered_input_packets();
#line 504
    if (stdin_eof) {
#line 504
      if (fdin != -1) {
#line 504
        tmp___0 = buffer_len(& stdin_buffer);
#line 504
        if (tmp___0 == 0U) {
#line 508
          if (fdout == -1) {
#line 509
            close(fdin);
          } else {
#line 511
            shutdown(fdin, 1);
          }
#line 513
          fdin = -1;
        }
      }
    }
#line 516
    make_packets_from_stderr_data();
#line 525
    max_time_milliseconds = 0U;
#line 526
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 527
    if (stdout_buffer_bytes != 0U) {
#line 527
      if (stdout_buffer_bytes < 256U) {
#line 527
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 530
          max_time_milliseconds = 10U;
        } else {
#line 533
          make_packets_from_stdout_data();
        }
      } else {
#line 533
        make_packets_from_stdout_data();
      }
    } else {
#line 533
      make_packets_from_stdout_data();
    }
#line 535
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 538
    tmp___1 = packet_not_very_much_data_to_write();
#line 538
    if (tmp___1) {
#line 539
      channel_output_poll();
    }
#line 546
    if (fdout_eof) {
#line 546
      if (fderr_eof) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 546
      if (child_terminated) {
#line 546
        if (child_has_selected) {
          _L: /* CIL Label */ 
#line 546
          tmp___5 = packet_have_data_to_write();
#line 546
          if (! tmp___5) {
#line 546
            tmp___6 = buffer_len(& stdout_buffer);
#line 546
            if (tmp___6 == 0U) {
#line 546
              tmp___7 = buffer_len(& stderr_buffer);
#line 546
              if (tmp___7 == 0U) {
#line 551
                tmp___2 = channel_still_open();
#line 551
                if (! tmp___2) {
                  goto quit;
                }
#line 553
                if (! waiting_termination) {
#line 554
                  s = "Waiting for forwarded connections to terminate...\r\n";
#line 556
                  waiting_termination = 1;
#line 557
                  tmp___3 = strlen(s);
#line 557
                  buffer_append(& stderr_buffer, s, tmp___3);
#line 560
                  cp = channel_open_message();
#line 561
                  tmp___4 = strlen((char const   *)cp);
#line 561
                  buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 562
                  xfree((void *)cp);
                }
              }
            }
          }
        }
      }
    }
#line 566
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 570
    channel_after_select(& readset, & writeset);
#line 573
    process_input(& readset);
#line 576
    process_output(& writeset);
  }
  quit: 
#line 583
  drain_output();
#line 585
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 589
  buffer_free(& stdin_buffer);
#line 590
  buffer_free(& stdout_buffer);
#line 591
  buffer_free(& stderr_buffer);
#line 594
  if (fdout != -1) {
#line 595
    close(fdout);
  }
#line 596
  fdout = -1;
#line 597
  fdout_eof = 1;
#line 598
  if (fderr != -1) {
#line 599
    close(fderr);
  }
#line 600
  fderr = -1;
#line 601
  fderr_eof = 1;
#line 602
  if (fdin != -1) {
#line 603
    close(fdin);
  }
#line 604
  fdin = -1;
#line 607
  channel_stop_listening();
#line 610
  wait_pid = wait((union wait *)(& wait_status));
#line 611
  if (wait_pid < 0) {
#line 617
    if (child_terminated) {
#line 618
      wait_status = (int )child_wait_status;
    } else {
#line 620
      tmp___8 = __errno_location();
#line 620
      tmp___9 = strerror(*tmp___8);
#line 620
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 623
    if (wait_pid != pid) {
#line 624
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 629
  signal(17, (void (*)(int  ))0);
#line 632
  __constr_expr_2.__in = wait_status;
#line 632
  if ((__constr_expr_2.__i & 127) == 0) {
#line 634
    __constr_expr_0.__in = wait_status;
#line 634
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 635
    packet_start(20);
#line 636
    __constr_expr_1.__in = wait_status;
#line 636
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 637
    packet_send();
#line 638
    packet_write_wait();
#line 647
    while (1) {
#line 649
      type = packet_read(& plen);
#line 647
      if (! (type != 33)) {
#line 647
        break;
      }
    }
#line 653
    debug("Received exit confirmation.");
#line 654
    return;
  }
#line 657
  __constr_expr_4.__in = wait_status;
#line 657
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 658
    __constr_expr_3.__in = wait_status;
#line 658
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 662
  packet_disconnect("wait returned status %04x.", wait_status);
#line 664
  return;
}
}
#line 1 "bsd-login.o"
#line 1 "md5crypt.o"
