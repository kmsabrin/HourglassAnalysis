/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 49 "./openbsd-compat/glob.h"
struct __anonstruct_glob_t_62 {
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 49 "./openbsd-compat/glob.h"
typedef struct __anonstruct_glob_t_62 glob_t;
#line 114 "openbsd-compat/glob.c"
typedef u_short Char;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_64 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_64 cb ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 19 "buffer.h"
struct __anonstruct_Buffer_67 {
   char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "buffer.h"
typedef struct __anonstruct_Buffer_67 Buffer;
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 51 "key.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 53 "authfd.h"
struct __anonstruct_AuthenticationConnection_68 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 53 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_68 AuthenticationConnection;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_65 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_65 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_66 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_66 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_73 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_73 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 37 "rijndael.h"
typedef unsigned int u32;
#line 40 "rijndael.h"
struct __anonstruct_rijndael_ctx_75 {
   int decrypt ;
   int Nr ;
   u32 ek[60] ;
   u32 dk[60] ;
};
#line 40 "rijndael.h"
typedef struct __anonstruct_rijndael_ctx_75 rijndael_ctx;
#line 62 "cipher.h"
struct Cipher;
#line 62 "cipher.h"
typedef struct Cipher Cipher;
#line 63
struct CipherContext;
#line 63 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct __anonstruct_des_77 {
   DES_key_schedule key ;
   DES_cblock iv ;
};
#line 65 "cipher.h"
struct __anonstruct_des3_78 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_key_schedule key3 ;
   DES_cblock iv1 ;
   DES_cblock iv2 ;
   DES_cblock iv3 ;
};
#line 65 "cipher.h"
struct __anonstruct_bf_79 {
   struct bf_key_st key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_cast_80 {
   CAST_KEY key ;
   u_char iv[8] ;
};
#line 65 "cipher.h"
struct __anonstruct_rijndael_81 {
   u_char iv[16] ;
   rijndael_ctx enc ;
   rijndael_ctx dec ;
};
#line 65 "cipher.h"
union __anonunion_u_76 {
   struct __anonstruct_des_77 des ;
   struct __anonstruct_des3_78 des3 ;
   struct __anonstruct_bf_79 bf ;
   struct __anonstruct_cast_80 cast ;
   struct __anonstruct_rijndael_81 rijndael ;
   RC4_KEY rc4 ;
};
#line 65 "cipher.h"
struct CipherContext {
   union __anonunion_u_76 u ;
   Cipher *cipher ;
};
#line 96 "cipher.h"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   void (*setkey)(CipherContext * , u_char const   * , u_int  ) ;
   void (*setiv)(CipherContext * , u_char const   * , u_int  ) ;
   void (*encrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
   void (*decrypt)(CipherContext * , u_char * , u_char const   * , u_int  ) ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 61 "channels.h"
struct Channel;
#line 62 "channels.h"
typedef struct Channel Channel;
#line 64 "channels.h"
typedef void channel_callback_fn(int  , void * );
#line 65 "channels.h"
typedef int channel_filter_fn(struct Channel * , char * , int  );
#line 67 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int isatty ;
   int force_drain ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[30] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *detach_user ;
   channel_filter_fn *input_filter ;
};
#line 223 "channels.h"
typedef void chan_event_fn(Channel * );
#line 88 "channels.c"
struct __anonstruct_ForwardPermission_70 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 88 "channels.c"
typedef struct __anonstruct_ForwardPermission_70 ForwardPermission;
#line 692 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 902 "channels.c"
struct __anonstruct_s4_req_71 {
   u_int8_t version ;
   u_int8_t command ;
   u_int16_t dest_port ;
   struct in_addr dest_addr ;
};
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 44 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 343 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 407 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 410 "/usr/include/regex.h"
typedef int regoff_t;
#line 434 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_64 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 434 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_64 regmatch_t;
#line 66 "compat.c"
struct __anonstruct_check_68 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 31 "dispatch.h"
typedef void dispatch_fn(int  , int  , void * );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 65 "kex.h"
struct Mac;
#line 65 "kex.h"
typedef struct Mac Mac;
#line 77 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD *md ;
   int mac_len ;
   u_char *key ;
   int key_len ;
};
#line 37 "mac.c"
struct __anonstruct_macs_79 {
   char *name ;
   EVP_MD *(*mdfunc)(void) ;
   int truncatebits ;
};
#line 17 "hostfile.h"
enum __anonenum_HostStatus_66 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 17 "hostfile.h"
typedef enum __anonenum_HostStatus_66 HostStatus;
#line 39 "key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
#line 64 "kex.h"
struct Kex;
#line 64 "kex.h"
typedef struct Kex Kex;
#line 66
struct Comp;
#line 66 "kex.h"
typedef struct Comp Comp;
#line 67
struct Enc;
#line 67 "kex.h"
typedef struct Enc Enc;
#line 68
struct Newkeys;
#line 68 "kex.h"
typedef struct Newkeys Newkeys;
#line 70 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_char *key ;
   u_char *iv ;
};
#line 85 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 90 "kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 95 "kex.h"
struct Kex {
   u_char *session_id ;
   int session_id_len ;
   Newkeys *newkeys[2] ;
   int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   int done ;
   int flags ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 21 "log.h"
enum __anonenum_SyslogFacility_63 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_AUTHPRIV = 3,
    SYSLOG_FACILITY_LOCAL0 = 4,
    SYSLOG_FACILITY_LOCAL1 = 5,
    SYSLOG_FACILITY_LOCAL2 = 6,
    SYSLOG_FACILITY_LOCAL3 = 7,
    SYSLOG_FACILITY_LOCAL4 = 8,
    SYSLOG_FACILITY_LOCAL5 = 9,
    SYSLOG_FACILITY_LOCAL6 = 10,
    SYSLOG_FACILITY_LOCAL7 = 11
} ;
#line 21 "log.h"
typedef enum __anonenum_SyslogFacility_63 SyslogFacility;
#line 38
enum __anonenum_LogLevel_64 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7
} ;
#line 38 "log.h"
typedef enum __anonenum_LogLevel_64 LogLevel;
#line 53 "log.c"
struct __anonstruct_log_facilities_65 {
   char const   *name ;
   SyslogFacility val ;
};
#line 74 "log.c"
struct __anonstruct_log_levels_66 {
   char const   *name ;
   LogLevel val ;
};
#line 190 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_27 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_28 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_30 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_31 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_25 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_26 _kill ;
   struct __anonstruct__timer_27 _timer ;
   struct __anonstruct__rt_28 _rt ;
   struct __anonstruct__sigchld_29 _sigchld ;
   struct __anonstruct__sigfault_30 _sigfault ;
   struct __anonstruct__sigpoll_31 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_25 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_43 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_43 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 26 "misc.h"
struct arglist;
#line 26 "misc.h"
typedef struct arglist arglist;
#line 27 "misc.h"
struct arglist {
   char **list ;
   int num ;
   int nalloc ;
};
#line 35 "misc.h"
typedef void (*mysig_t)(int  );
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 35 "rijndael.h"
typedef unsigned char u8;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "servconf.h"
struct __anonstruct_ServerOptions_68 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   char *xauth_location ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   char *banner ;
   int reverse_mapping_check ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   int pam_authentication_via_kbd_int ;
};
#line 36 "servconf.h"
typedef struct __anonstruct_ServerOptions_68 ServerOptions;
#line 158 "sshd.c"
struct __anonstruct_sensitive_data_82 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 43 "auth.h"
struct Authctxt;
#line 43 "auth.h"
typedef struct Authctxt Authctxt;
#line 46 "auth.h"
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
};
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 68 "auth2.c"
struct Authmethod;
#line 68 "auth2.c"
typedef struct Authmethod Authmethod;
#line 69 "auth2.c"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 44 "auth.h"
struct KbdintDevice;
#line 44 "auth.h"
typedef struct KbdintDevice KbdintDevice;
#line 79 "auth.h"
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
#line 59 "auth2-chall.c"
struct KbdintAuthctxt;
#line 59 "auth2-chall.c"
typedef struct KbdintAuthctxt KbdintAuthctxt;
#line 60 "auth2-chall.c"
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
};
#line 20 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 53 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 73 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[64] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 223 "servconf.c"
enum __anonenum_ServerOpCodes_80 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sChallengeResponseAuthentication = 12,
    sPasswordAuthentication = 13,
    sKbdInteractiveAuthentication = 14,
    sListenAddress = 15,
    sPrintMotd = 16,
    sPrintLastLog = 17,
    sIgnoreRhosts = 18,
    sX11Forwarding = 19,
    sX11DisplayOffset = 20,
    sStrictModes = 21,
    sEmptyPasswd = 22,
    sKeepAlives = 23,
    sUseLogin = 24,
    sAllowTcpForwarding = 25,
    sAllowUsers = 26,
    sDenyUsers = 27,
    sAllowGroups = 28,
    sDenyGroups = 29,
    sIgnoreUserKnownHosts = 30,
    sCiphers = 31,
    sMacs = 32,
    sProtocol = 33,
    sPidFile = 34,
    sGatewayPorts = 35,
    sPubkeyAuthentication = 36,
    sXAuthLocation = 37,
    sSubsystem = 38,
    sMaxStartups = 39,
    sBanner = 40,
    sReverseMappingCheck = 41,
    sHostbasedAuthentication = 42,
    sHostbasedUsesNameFromPacketOnly = 43,
    sClientAliveInterval = 44,
    sClientAliveCountMax = 45,
    sAuthorizedKeysFile = 46,
    sAuthorizedKeysFile2 = 47,
    sDeprecated = 48,
    sPAMAuthenticationViaKbdInt = 49
} ;
#line 223 "servconf.c"
typedef enum __anonenum_ServerOpCodes_80 ServerOpCodes;
#line 253 "servconf.c"
struct __anonstruct_keywords_81 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 640 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 642 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 638 "serverloop.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 664 "serverloop.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 663 "serverloop.c"
union __anonunion_86 {
   int __in ;
   int __i ;
};
#line 98 "session.c"
struct Session;
#line 98 "session.c"
typedef struct Session Session;
#line 99 "session.c"
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int is_subsystem ;
};
#line 1879 "session.c"
union __anonunion_71 {
   int __in ;
   int __i ;
};
#line 1884 "session.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 1886 "session.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 1881 "session.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 1876 "session.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 1 "bsd-arc4random.o"
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 33 "./openbsd-compat/bsd-arc4random.h"
unsigned int arc4random(void) ;
#line 34
void arc4random_stir(void) ;
#line 30 "./entropy.h"
void seed_rng(void) ;
#line 54 "./log.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 42 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 43 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 48 "openbsd-compat/bsd-arc4random.c"
static int first_time  =    1;
#line 45 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 47
  r = 0U;
#line 50
  if (rc4_ready <= 0) {
#line 51
    if (! first_time) {
#line 52
      seed_rng();
    }
#line 53
    first_time = 0;
#line 54
    arc4random_stir();
  }
#line 57
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 59
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 61
  return (r);
}
}
#line 64 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 68
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 69
  tmp___0 = RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 69
  if (! tmp___0) {
#line 70
    tmp = ERR_get_error();
#line 70
    fatal("Couldn\'t obtain random bytes (error %ld)", tmp);
  }
#line 72
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 73
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 75
  rc4_ready = 1 << 24;
#line 76
  return;
}
}
#line 1 "bsd-cray.o"
#line 1 "bsd-cygwin_util.o"
#line 1 "bsd-misc.o"
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 32 "./openbsd-compat/bsd-misc.h"
char *get_progname(char *argv0___0 ) ;
#line 34 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 31 "openbsd-compat/bsd-misc.c"
char *get_progname(char *argv0___0 ) 
{ 

  {
#line 36
  return (__progname);
}
}
#line 52
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 52 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 54
  return (0);
}
}
#line 1 "bsd-nextstep.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-waitpid.o"
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 10 "openbsd-compat/base64.h"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) ;
#line 12
int b64_pton(char const   *src , u_char *target , size_t targsize ) ;
#line 65 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 65 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 132 "openbsd-compat/base64.c"
int b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 135
  datalength = (size_t )0;
#line 140
  while (2U < srclength) {
#line 141
    tmp = src;
#line 141
    src ++;
#line 141
    input___0[0] = (unsigned char )*tmp;
#line 142
    tmp___0 = src;
#line 142
    src ++;
#line 142
    input___0[1] = (unsigned char )*tmp___0;
#line 143
    tmp___1 = src;
#line 143
    src ++;
#line 143
    input___0[2] = (unsigned char )*tmp___1;
#line 144
    srclength -= 3U;
#line 146
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 147
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 148
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 149
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 150
    if (! ((int )output___0[0] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[1] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[2] < 64)) {
#line 152
      abort();
    }
#line 153
    if (! ((int )output___0[3] < 64)) {
#line 153
      abort();
    }
#line 155
    if (datalength + 4U > targsize) {
#line 156
      return (-1);
    }
#line 157
    tmp___2 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 158
    tmp___3 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 159
    tmp___4 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 160
    tmp___5 = datalength;
#line 160
    datalength ++;
#line 160
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 164
  if (0U != srclength) {
#line 166
    input___0[2] = (unsigned char )'\000';
#line 166
    input___0[1] = input___0[2];
#line 166
    input___0[0] = input___0[1];
#line 167
    i = 0;
#line 167
    while ((size_t )i < srclength) {
#line 168
      tmp___6 = src;
#line 168
      src ++;
#line 168
      input___0[i] = (unsigned char )*tmp___6;
#line 167
      i ++;
    }
#line 170
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 171
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 172
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 173
    if (! ((int )output___0[0] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[1] < 64)) {
#line 174
      abort();
    }
#line 175
    if (! ((int )output___0[2] < 64)) {
#line 175
      abort();
    }
#line 177
    if (datalength + 4U > targsize) {
#line 178
      return (-1);
    }
#line 179
    tmp___7 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 180
    tmp___8 = datalength;
#line 180
    datalength ++;
#line 180
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 181
    if (srclength == 1U) {
#line 182
      tmp___9 = datalength;
#line 182
      datalength ++;
#line 182
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 184
      tmp___10 = datalength;
#line 184
      datalength ++;
#line 184
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 185
    tmp___11 = datalength;
#line 185
    datalength ++;
#line 185
    *(target + tmp___11) = (char )Pad64;
  }
#line 187
  if (datalength >= targsize) {
#line 188
    return (-1);
  }
#line 189
  *(target + datalength) = (char )'\000';
#line 190
  return ((int )datalength);
}
}
#line 199 "openbsd-compat/base64.c"
int b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 205
  state = 0;
#line 206
  tarindex = 0;
#line 208
  while (1) {
#line 208
    tmp___2 = src;
#line 208
    src ++;
#line 208
    ch = (int )*tmp___2;
#line 208
    if (! (ch != 0)) {
#line 208
      break;
    }
#line 209
    tmp = __ctype_b_loc();
#line 209
    if ((int const   )*(*tmp + ch) & 8192) {
#line 210
      continue;
    }
#line 212
    if (ch == (int )Pad64) {
#line 213
      break;
    }
#line 215
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 215
    pos = tmp___1;
#line 216
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 217
      return (-1);
    }
#line 219
    switch (state) {
    case 0: 
#line 221
    if (target) {
#line 222
      if ((size_t )tarindex >= targsize) {
#line 223
        return (-1);
      }
#line 224
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 226
    state = 1;
#line 227
    break;
    case 1: 
#line 229
    if (target) {
#line 230
      if ((size_t )(tarindex + 1) >= targsize) {
#line 231
        return (-1);
      }
#line 232
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 233
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 236
    tarindex ++;
#line 237
    state = 2;
#line 238
    break;
    case 2: 
#line 240
    if (target) {
#line 241
      if ((size_t )(tarindex + 1) >= targsize) {
#line 242
        return (-1);
      }
#line 243
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 244
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 247
    tarindex ++;
#line 248
    state = 3;
#line 249
    break;
    case 3: 
#line 251
    if (target) {
#line 252
      if ((size_t )tarindex >= targsize) {
#line 253
        return (-1);
      }
#line 254
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 256
    tarindex ++;
#line 257
    state = 0;
#line 258
    break;
    }
  }
#line 267
  if (ch == (int )Pad64) {
#line 268
    tmp___3 = src;
#line 268
    src ++;
#line 268
    ch = (int )*tmp___3;
#line 269
    switch (state) {
    case 0: 
    case 1: 
#line 272
    return (-1);
    case 2: 
#line 276
    while (ch != 0) {
#line 277
      tmp___5 = __ctype_b_loc();
#line 277
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 278
        break;
      }
#line 276
      tmp___4 = src;
#line 276
      src ++;
#line 276
      ch = (int )*tmp___4;
    }
#line 280
    if (ch != (int )Pad64) {
#line 281
      return (-1);
    }
#line 282
    tmp___6 = src;
#line 282
    src ++;
#line 282
    ch = (int )*tmp___6;
    case 3: 
#line 291
    while (ch != 0) {
#line 292
      tmp___8 = __ctype_b_loc();
#line 292
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 293
        return (-1);
      }
#line 291
      tmp___7 = src;
#line 291
      src ++;
#line 291
      ch = (int )*tmp___7;
    }
#line 301
    if (target) {
#line 301
      if ((int )*(target + tarindex) != 0) {
#line 302
        return (-1);
      }
    }
    }
  } else {
#line 309
    if (state != 0) {
#line 310
      return (-1);
    }
  }
#line 313
  return (tarindex);
}
}
#line 1 "bindresvport.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 9 "./openbsd-compat/bindresvport.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 55 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 69
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 70
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 71
    sa = (struct sockaddr *)(& myaddr);
#line 73
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 73
    if (tmp == -1) {
#line 74
      return (-1);
    }
#line 76
    af = (int )sa->sa_family;
#line 77
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 79
    af = (int )sa->sa_family;
  }
#line 81
  if (af == 2) {
#line 82
    sin = (struct sockaddr_in *)sa;
#line 83
    salen = sizeof(struct sockaddr_in );
#line 84
    portp = & sin->sin_port;
  } else {
#line 85
    if (af == 10) {
#line 86
      sin6 = (struct sockaddr_in6 *)sa;
#line 87
      salen = sizeof(struct sockaddr_in6 );
#line 88
      portp = & sin6->sin6_port;
    } else {
#line 90
      tmp___0 = __errno_location();
#line 90
      *tmp___0 = 96;
#line 91
      return (-1);
    }
  }
#line 93
  sa->sa_family = (unsigned short )af;
#line 95
  __x = *portp;
#line 95
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 95
  port = __v;
#line 96
  if ((int )port == 0) {
#line 97
    tmp___1 = arc4random();
#line 97
    port = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 100
  error___0 = -1;
#line 102
  i = 0;
#line 102
  while (i < 424) {
#line 103
    __x___0 = port;
#line 103
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 103
    *portp = __v___0;
#line 105
    error___0 = bind(sd, (struct sockaddr  const  *)sa, salen);
#line 108
    if (error___0 == 0) {
#line 109
      break;
    }
#line 112
    if (error___0 < 0) {
#line 112
      tmp___2 = __errno_location();
#line 112
      if (! (*tmp___2 == 98)) {
#line 112
        tmp___3 = __errno_location();
#line 112
        if (! (*tmp___3 == 22)) {
#line 113
          break;
        }
      }
    }
#line 115
    port = (u_int16_t )((int )port + 1);
#line 116
    if ((int )port > 1023) {
#line 117
      port = (unsigned short)600;
    }
#line 102
    i ++;
  }
#line 120
  return (error___0);
}
}
#line 1 "daemon.o"
#line 1 "dirname.o"
#line 1 "getcwd.o"
#line 1 "getgrouplist.o"
#line 1 "getopt.o"
#line 10 "./openbsd-compat/getopt.h"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 45 "openbsd-compat/getopt.c"
int opterr  =    1;
#line 45 "openbsd-compat/getopt.c"
int optind  =    1;
#line 45 "openbsd-compat/getopt.c"
int optopt  ;
#line 45 "openbsd-compat/getopt.c"
int optreset  ;
#line 49 "openbsd-compat/getopt.c"
char *optarg  ;
#line 66 "openbsd-compat/getopt.c"
static char *place  =    (char *)"";
#line 59 "openbsd-compat/getopt.c"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ char *oli ;
  char *tmp ;
  char *tmp___1 ;

  {
#line 69
  if (optreset) {
    goto _L;
  } else {
#line 69
    if (! *place) {
      _L: /* CIL Label */ 
#line 70
      optreset = 0;
#line 71
      if (optind >= nargc) {
#line 72
        place = (char *)"";
#line 73
        return (-1);
      } else {
#line 71
        place = (char *)*(nargv + optind);
#line 71
        if ((int )*place != 45) {
#line 72
          place = (char *)"";
#line 73
          return (-1);
        }
      }
#line 75
      if (*(place + 1)) {
#line 75
        place ++;
#line 75
        if ((int )*place == 45) {
#line 76
          optind ++;
#line 77
          place = (char *)"";
#line 78
          return (-1);
        }
      }
    }
  }
#line 81
  tmp = place;
#line 81
  place ++;
#line 81
  optopt = (int )*tmp;
#line 81
  if (optopt == 58) {
    goto _L___0;
  } else {
#line 81
    tmp___1 = __builtin_strchr((char *)ostr, optopt);
#line 81
    oli = tmp___1;
#line 81
    if (! oli) {
      _L___0: /* CIL Label */ 
#line 87
      if (optopt == 45) {
#line 88
        return (-1);
      }
#line 89
      if (! *place) {
#line 90
        optind ++;
      }
#line 91
      if (opterr) {
#line 91
        if ((int const   )*ostr != 58) {
#line 92
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- %c\n",
                  __progname, optopt);
        }
      }
#line 94
      return ('?');
    }
  }
#line 96
  oli ++;
#line 96
  if ((int )*oli != 58) {
#line 97
    optarg = (char *)((void *)0);
#line 98
    if (! *place) {
#line 99
      optind ++;
    }
  } else {
#line 102
    if (*place) {
#line 103
      optarg = place;
    } else {
#line 104
      optind ++;
#line 104
      if (nargc <= optind) {
#line 105
        place = (char *)"";
#line 106
        if ((int const   )*ostr == 58) {
#line 107
          return (':');
        }
#line 108
        if (opterr) {
#line 109
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  __progname, optopt);
        }
#line 112
        return ('?');
      } else {
#line 115
        optarg = (char *)*(nargv + optind);
      }
    }
#line 116
    place = (char *)"";
#line 117
    optind ++;
  }
#line 119
  return (optopt);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "glob.o"
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 259
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 384
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 443
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 443
  return (tmp);
}
}
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 600 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 94 "./openbsd-compat/glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 95
void globfree(glob_t *pglob ) ;
#line 40 "openbsd-compat/glob.c"
static long get_arg_max(void) 
{ 

  {
#line 44
  return (131072L);
}
}
#line 139
static int compare(void const   *p , void const   *q ) ;
#line 140
static int g_Ctoc(Char const   *str , char *buf___2 , u_int len ) ;
#line 141
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 142
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 143
static Char *g_strchr(Char *str , int ch ) ;
#line 144
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 145
static int glob0(Char const   *pattern , glob_t *pglob ) ;
#line 146
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 147
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 149
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) ;
#line 151
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) ;
#line 152
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) ;
#line 154
static int globexp1(Char const   *pattern , glob_t *pglob ) ;
#line 155
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) ;
#line 156
static int match(Char *name , Char *pat , Char *patend ) ;
#line 161 "openbsd-compat/glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ u_char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  Char *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  u_char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 171
  patnext = (u_char const   *)((u_char *)pattern);
#line 172
  if (! (flags & 1)) {
#line 173
    pglob->gl_pathc = 0;
#line 174
    pglob->gl_pathv = (char **)((void *)0);
#line 175
    if (! (flags & 2)) {
#line 176
      pglob->gl_offs = 0;
    }
  }
#line 178
  pglob->gl_flags = flags & -257;
#line 179
  pglob->gl_errfunc = errfunc;
#line 180
  pglob->gl_matchc = 0;
#line 182
  bufnext = patbuf;
#line 183
  bufend = (bufnext + 4096) - 1;
#line 184
  if (flags & 4096) {
#line 185
    while (1) {
#line 185
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 185
        tmp___0 = patnext;
#line 185
        patnext ++;
#line 185
        c = (int )*tmp___0;
#line 185
        if (! (c != 0)) {
#line 185
          break;
        }
      } else {
#line 185
        break;
      }
#line 186
      tmp = bufnext;
#line 186
      bufnext ++;
#line 186
      *tmp = (unsigned short )c;
    }
  } else {
#line 189
    while (1) {
#line 189
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 189
        tmp___4 = patnext;
#line 189
        patnext ++;
#line 189
        c = (int )*tmp___4;
#line 189
        if (! (c != 0)) {
#line 189
          break;
        }
      } else {
#line 189
        break;
      }
#line 190
      if (c == 92) {
#line 191
        tmp___1 = patnext;
#line 191
        patnext ++;
#line 191
        c = (int )*tmp___1;
#line 191
        if (c == 0) {
#line 192
          c = '\\';
#line 193
          patnext --;
        }
#line 195
        tmp___2 = bufnext;
#line 195
        bufnext ++;
#line 195
        *tmp___2 = (unsigned short )(c | 16384);
      } else {
#line 197
        tmp___3 = bufnext;
#line 197
        bufnext ++;
#line 197
        *tmp___3 = (unsigned short )c;
      }
    }
  }
#line 199
  *bufnext = (unsigned short )'\000';
#line 201
  if (flags & 128) {
#line 202
    tmp___5 = globexp1((Char const   *)(patbuf), pglob);
#line 202
    return (tmp___5);
  } else {
#line 204
    tmp___6 = glob0((Char const   *)(patbuf), pglob);
#line 204
    return (tmp___6);
  }
}
}
#line 212 "openbsd-compat/glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob ) 
{ Char const   *ptr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  int tmp___2 ;

  {
#line 217
  ptr = pattern;
#line 221
  if ((int const   )*(pattern + 0) == 123) {
#line 221
    if ((int const   )*(pattern + 1) == 125) {
#line 221
      if ((int const   )*(pattern + 2) == 0) {
#line 222
        tmp = glob0(pattern, pglob);
#line 222
        return (tmp);
      }
    }
  }
#line 224
  while (1) {
#line 224
    tmp___1 = g_strchr((Char *)ptr, '{');
#line 224
    ptr = (Char const   *)tmp___1;
#line 224
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 224
      break;
    }
#line 225
    tmp___0 = globexp2(ptr, pattern, pglob, & rv);
#line 225
    if (! tmp___0) {
#line 226
      return (rv);
    }
  }
#line 228
  tmp___2 = glob0(pattern, pglob);
#line 228
  return (tmp___2);
}
}
#line 237 "openbsd-compat/glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) 
{ int i ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  Char const   *tmp___2 ;
  Char *tmp___3 ;
  Char const   *tmp___4 ;
  Char *tmp___5 ;
  Char const   *tmp___6 ;

  {
#line 249
  lm = patbuf;
#line 249
  pm = pattern;
#line 249
  while ((unsigned int )pm != (unsigned int )ptr) {
#line 249
    tmp = lm;
#line 249
    lm ++;
#line 249
    tmp___0 = pm;
#line 249
    pm ++;
#line 249
    *tmp = (unsigned short )*tmp___0;
  }
#line 251
  *lm = (unsigned short )'\000';
#line 252
  ls = lm;
#line 255
  i = 0;
#line 255
  ptr ++;
#line 255
  pe = ptr;
#line 255
  while (*pe) {
#line 256
    if ((int const   )*pe == 91) {
#line 258
      tmp___1 = pe;
#line 258
      pe ++;
#line 258
      pm = tmp___1;
#line 258
      while (1) {
#line 258
        if ((int const   )*pe != 93) {
#line 258
          if (! ((int const   )*pe != 0)) {
#line 258
            break;
          }
        } else {
#line 258
          break;
        }
#line 258
        pe ++;
      }
#line 260
      if ((int const   )*pe == 0) {
#line 265
        pe = pm;
      }
    } else {
#line 267
      if ((int const   )*pe == 123) {
#line 268
        i ++;
      } else {
#line 269
        if ((int const   )*pe == 125) {
#line 270
          if (i == 0) {
#line 271
            break;
          }
#line 272
          i --;
        }
      }
    }
#line 255
    pe ++;
  }
#line 276
  if (i != 0) {
#line 277
    *rv = glob0((Char const   *)(patbuf), pglob);
#line 278
    return (0);
  } else {
#line 276
    if ((int const   )*pe == 0) {
#line 277
      *rv = glob0((Char const   *)(patbuf), pglob);
#line 278
      return (0);
    }
  }
#line 281
  i = 0;
#line 281
  pm = ptr;
#line 281
  pl = pm;
#line 281
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 282
    switch ((int )*pm) {
    case 91: 
#line 285
    tmp___2 = pm;
#line 285
    pm ++;
#line 285
    pl = tmp___2;
#line 285
    while (1) {
#line 285
      if ((int const   )*pm != 93) {
#line 285
        if (! ((int const   )*pm != 0)) {
#line 285
          break;
        }
      } else {
#line 285
        break;
      }
#line 285
      pm ++;
    }
#line 287
    if ((int const   )*pm == 0) {
#line 292
      pm = pl;
    }
#line 294
    break;
    case 123: 
#line 297
    i ++;
#line 298
    break;
    case 125: 
#line 301
    if (i) {
#line 302
      i --;
#line 303
      break;
    }
    case 44: 
#line 307
    if (i) {
#line 307
      if ((int const   )*pm == 44) {
#line 308
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 311
      lm = ls;
#line 311
      while ((unsigned int )pl < (unsigned int )pm) {
#line 311
        tmp___3 = lm;
#line 311
        lm ++;
#line 311
        tmp___4 = pl;
#line 311
        pl ++;
#line 311
        *tmp___3 = (unsigned short )*tmp___4;
      }
#line 318
      pl = pe + 1;
#line 318
      while (1) {
#line 318
        tmp___5 = lm;
#line 318
        lm ++;
#line 318
        tmp___6 = pl;
#line 318
        pl ++;
#line 318
        *tmp___5 = (unsigned short )*tmp___6;
#line 318
        if (! ((int )*tmp___5 != 0)) {
#line 318
          break;
        }
      }
#line 325
      *rv = globexp1((Char const   *)(patbuf), pglob);
#line 328
      pl = pm + 1;
    }
#line 330
    break;
    default: ;
#line 333
    break;
    }
#line 281
    pm ++;
  }
#line 336
  *rv = 0;
#line 337
  return (0);
}
}
#line 345 "openbsd-compat/glob.c"
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) 
{ struct passwd *pwd ;
  char *h___0 ;
  Char const   *p ;
  Char *b ;
  Char *eb ;
  char *tmp ;
  Char const   *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  Char *tmp___4 ;
  char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;

  {
#line 357
  if ((int const   )*pattern != 126) {
#line 358
    return (pattern);
  } else {
#line 357
    if (! (pglob->gl_flags & 2048)) {
#line 358
      return (pattern);
    }
  }
#line 361
  eb = patbuf + (patbuf_len - 1U);
#line 362
  p = pattern + 1;
#line 362
  h___0 = (char *)patbuf;
#line 362
  while (1) {
#line 362
    if ((unsigned int )h___0 < (unsigned int )((char *)eb)) {
#line 362
      if (*p) {
#line 362
        if (! ((int const   )*p != 47)) {
#line 362
          break;
        }
      } else {
#line 362
        break;
      }
    } else {
#line 362
      break;
    }
#line 362
    tmp = h___0;
#line 362
    h___0 ++;
#line 362
    tmp___0 = p;
#line 362
    p ++;
#line 362
    *tmp = (char )*tmp___0;
  }
#line 366
  *h___0 = (char )'\000';
#line 373
  if ((int )*((char *)patbuf + 0) == 0) {
#line 381
    tmp___2 = getuid();
#line 381
    tmp___3 = geteuid();
#line 381
    if (tmp___2 != tmp___3) {
      goto _L;
    } else {
#line 381
      h___0 = getenv("HOME");
#line 381
      if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 382
        tmp___1 = getuid();
#line 382
        pwd = getpwuid(tmp___1);
#line 382
        if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 383
          return (pattern);
        } else {
#line 385
          h___0 = pwd->pw_dir;
        }
      }
    }
  } else {
#line 391
    pwd = getpwnam((char const   *)((char *)patbuf));
#line 391
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 392
      return (pattern);
    } else {
#line 394
      h___0 = pwd->pw_dir;
    }
  }
#line 398
  b = patbuf;
#line 398
  while (1) {
#line 398
    if ((unsigned int )b < (unsigned int )eb) {
#line 398
      if (! *h___0) {
#line 398
        break;
      }
    } else {
#line 398
      break;
    }
#line 398
    tmp___4 = b;
#line 398
    b ++;
#line 398
    tmp___5 = h___0;
#line 398
    h___0 ++;
#line 398
    *tmp___4 = (unsigned short )*tmp___5;
  }
#line 402
  while (1) {
#line 402
    if ((unsigned int )b < (unsigned int )eb) {
#line 402
      tmp___6 = b;
#line 402
      b ++;
#line 402
      tmp___7 = p;
#line 402
      p ++;
#line 402
      *tmp___6 = (unsigned short )*tmp___7;
#line 402
      if (! ((int )*tmp___6 != 0)) {
#line 402
        break;
      }
    } else {
#line 402
      break;
    }
  }
#line 404
  *b = (unsigned short )'\000';
#line 406
  return ((Char const   *)patbuf);
}
}
#line 417 "openbsd-compat/glob.c"
static int glob0(Char const   *pattern , glob_t *pglob ) 
{ Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  size_t limit ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 425
  limit = (size_t )0;
#line 427
  qpatnext = globtilde(pattern, patbuf, 4096U, pglob);
#line 428
  oldpathc = pglob->gl_pathc;
#line 429
  bufnext = patbuf;
#line 432
  while (1) {
#line 432
    tmp___12 = qpatnext;
#line 432
    qpatnext ++;
#line 432
    c = (int )*tmp___12;
#line 432
    if (! (c != 0)) {
#line 432
      break;
    }
#line 433
    switch (c) {
    case 91: 
#line 435
    c = (int )*qpatnext;
#line 436
    if (c == 33) {
#line 437
      qpatnext ++;
    }
#line 438
    if ((int const   )*qpatnext == 0) {
      goto _L;
    } else {
#line 438
      tmp___0 = g_strchr((Char *)qpatnext + 1, ']');
#line 438
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 440
        tmp = bufnext;
#line 440
        bufnext ++;
#line 440
        *tmp = (unsigned short )'[';
#line 441
        if (c == 33) {
#line 442
          qpatnext --;
        }
#line 443
        break;
      }
    }
#line 445
    tmp___1 = bufnext;
#line 445
    bufnext ++;
#line 445
    *tmp___1 = (unsigned short)32859;
#line 446
    if (c == 33) {
#line 447
      tmp___2 = bufnext;
#line 447
      bufnext ++;
#line 447
      *tmp___2 = (unsigned short)32801;
    }
#line 448
    tmp___3 = qpatnext;
#line 448
    qpatnext ++;
#line 448
    c = (int )*tmp___3;
#line 449
    while (1) {
#line 450
      tmp___4 = bufnext;
#line 450
      bufnext ++;
#line 450
      *tmp___4 = (unsigned short )(c & 255);
#line 451
      if ((int const   )*qpatnext == 45) {
#line 451
        c = (int )*(qpatnext + 1);
#line 451
        if (c != 93) {
#line 453
          tmp___5 = bufnext;
#line 453
          bufnext ++;
#line 453
          *tmp___5 = (unsigned short)32813;
#line 454
          tmp___6 = bufnext;
#line 454
          bufnext ++;
#line 454
          *tmp___6 = (unsigned short )(c & 255);
#line 455
          qpatnext += 2;
        }
      }
#line 449
      tmp___7 = qpatnext;
#line 449
      qpatnext ++;
#line 449
      c = (int )*tmp___7;
#line 449
      if (! (c != 93)) {
#line 449
        break;
      }
    }
#line 458
    pglob->gl_flags |= 256;
#line 459
    tmp___8 = bufnext;
#line 459
    bufnext ++;
#line 459
    *tmp___8 = (unsigned short)32861;
#line 460
    break;
    case 63: 
#line 462
    pglob->gl_flags |= 256;
#line 463
    tmp___9 = bufnext;
#line 463
    bufnext ++;
#line 463
    *tmp___9 = (unsigned short)32831;
#line 464
    break;
    case 42: 
#line 466
    pglob->gl_flags |= 256;
#line 470
    if ((unsigned int )bufnext == (unsigned int )(patbuf)) {
#line 471
      tmp___10 = bufnext;
#line 471
      bufnext ++;
#line 471
      *tmp___10 = (unsigned short)32810;
    } else {
#line 470
      if ((int )*(bufnext + -1) != 32810) {
#line 471
        tmp___10 = bufnext;
#line 471
        bufnext ++;
#line 471
        *tmp___10 = (unsigned short)32810;
      }
    }
#line 472
    break;
    default: 
#line 474
    tmp___11 = bufnext;
#line 474
    bufnext ++;
#line 474
    *tmp___11 = (unsigned short )(c & 255);
#line 475
    break;
    }
  }
#line 478
  *bufnext = (unsigned short )'\000';
#line 483
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, & limit);
#line 483
  if (err != 0) {
#line 484
    return (err);
  }
#line 492
  if (pglob->gl_pathc == oldpathc) {
#line 493
    if (pglob->gl_flags & 16) {
#line 496
      tmp___13 = globextend(pattern, pglob, & limit);
#line 496
      return (tmp___13);
    } else {
#line 493
      if (pglob->gl_flags & 512) {
#line 493
        if (! (pglob->gl_flags & 256)) {
#line 496
          tmp___13 = globextend(pattern, pglob, & limit);
#line 496
          return (tmp___13);
        } else {
#line 498
          return (-3);
        }
      } else {
#line 498
        return (-3);
      }
    }
  }
#line 500
  if (! (pglob->gl_flags & 32)) {
#line 501
    qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (unsigned int )(pglob->gl_pathc - oldpathc),
          sizeof(char *), & compare);
  }
#line 503
  return (0);
}
}
#line 506 "openbsd-compat/glob.c"
static int compare(void const   *p , void const   *q ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 510
  if (0) {
#line 510
    __s1_len = strlen((char const   *)*((char **)p));
#line 510
    __s2_len = strlen((char const   *)*((char **)q));
#line 510
    if (! ((unsigned int )((void const   *)(*((char **)p) + 1)) - (unsigned int )((void const   *)*((char **)p)) == 1U)) {
      goto _L___0;
    } else {
#line 510
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 510
        if (! ((unsigned int )((void const   *)(*((char **)q) + 1)) - (unsigned int )((void const   *)*((char **)q)) == 1U)) {
#line 510
          tmp___8 = 1;
        } else {
#line 510
          if (__s2_len >= 4U) {
#line 510
            tmp___8 = 1;
          } else {
#line 510
            tmp___8 = 0;
          }
        }
      } else {
#line 510
        tmp___8 = 0;
      }
    }
#line 510
    if (tmp___8) {
#line 510
      tmp___4 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
    } else {
#line 510
      tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 510
      tmp___4 = tmp___7;
    }
  } else {
#line 510
    tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 510
    tmp___4 = tmp___7;
  }
#line 510
  return (tmp___4);
}
}
#line 513 "openbsd-compat/glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ Char pathbuf[4096] ;
  int tmp ;

  {
#line 522
  if ((int )*pattern == 0) {
#line 523
    return (0);
  }
#line 524
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp);
#line 524
  return (tmp);
}
}
#line 534 "openbsd-compat/glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  int tmp___7 ;

  {
#line 550
  anymeta = 0;
#line 550
  while (1) {
#line 551
    if ((int )*pattern == 0) {
#line 552
      *pathend = (unsigned short )'\000';
#line 553
      tmp = g_lstat(pathbuf, & sb, pglob);
#line 553
      if (tmp) {
#line 554
        return (0);
      }
#line 556
      if (pglob->gl_flags & 8) {
#line 556
        if ((int )*(pathend + -1) != 47) {
#line 556
          if ((sb.st_mode & 61440U) == 16384U) {
            goto _L;
          } else {
#line 556
            if ((sb.st_mode & 61440U) == 40960U) {
#line 556
              tmp___1 = g_stat(pathbuf, & sb, pglob);
#line 556
              if (tmp___1 == 0) {
#line 556
                if ((sb.st_mode & 61440U) == 16384U) {
                  _L: /* CIL Label */ 
#line 561
                  if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 562
                    return (1);
                  }
#line 563
                  tmp___0 = pathend;
#line 563
                  pathend ++;
#line 563
                  *tmp___0 = (unsigned short )'/';
#line 564
                  *pathend = (unsigned short )'\000';
                }
              }
            }
          }
        }
      }
#line 566
      (pglob->gl_matchc) ++;
#line 567
      tmp___2 = globextend((Char const   *)pathbuf, pglob, limitp);
#line 567
      return (tmp___2);
    }
#line 571
    q = pathend;
#line 572
    p = pattern;
#line 573
    while (1) {
#line 573
      if ((int )*p != 0) {
#line 573
        if (! ((int )*p != 47)) {
#line 573
          break;
        }
      } else {
#line 573
        break;
      }
#line 574
      if (((int )*p & 32768) != 0) {
#line 575
        anymeta = 1;
      }
#line 576
      if ((unsigned int )(q + 1) > (unsigned int )pathend_last) {
#line 577
        return (1);
      }
#line 578
      tmp___3 = q;
#line 578
      q ++;
#line 578
      tmp___4 = p;
#line 578
      p ++;
#line 578
      *tmp___3 = *tmp___4;
    }
#line 581
    if (! anymeta) {
#line 582
      pathend = q;
#line 583
      pattern = p;
#line 584
      while ((int )*pattern == 47) {
#line 585
        if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 586
          return (1);
        }
#line 587
        tmp___5 = pathend;
#line 587
        pathend ++;
#line 587
        tmp___6 = pattern;
#line 587
        pattern ++;
#line 587
        *tmp___5 = *tmp___6;
      }
    } else {
#line 591
      tmp___7 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, pattern_last,
                      p, pattern_last, pglob, limitp);
#line 591
      return (tmp___7);
    }
  }
}
}
#line 598 "openbsd-compat/glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , Char *restpattern , Char *restpattern_last ,
                 glob_t *pglob , size_t *limitp ) 
{ register struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___2[4096] ;
  struct dirent *(*readdirfunc)() ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  register u_char *sc ;
  register Char *dc ;
  Char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 619
  if ((unsigned int )pathend > (unsigned int )pathend_last) {
#line 620
    return (1);
  }
#line 621
  *pathend = (unsigned short )'\000';
#line 622
  tmp = __errno_location();
#line 622
  *tmp = 0;
#line 624
  dirp = g_opendir(pathbuf, pglob);
#line 624
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 626
    if (pglob->gl_errfunc) {
#line 627
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___2, sizeof(buf___2));
#line 627
      if (tmp___0) {
#line 628
        return (-2);
      }
#line 629
      tmp___1 = __errno_location();
#line 629
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___2), *tmp___1);
#line 629
      if (tmp___2) {
#line 631
        return (-2);
      } else {
#line 629
        if (pglob->gl_flags & 4) {
#line 631
          return (-2);
        }
      }
    }
#line 633
    return (0);
  }
#line 636
  err = 0;
#line 639
  if (pglob->gl_flags & 64) {
#line 640
    readdirfunc = (struct dirent *(*)())pglob->gl_readdir;
  } else {
#line 642
    readdirfunc = (struct dirent *(*)())(& readdir);
  }
#line 643
  while (1) {
#line 643
    dp = (*readdirfunc)(dirp);
#line 643
    if (! dp) {
#line 643
      break;
    }
#line 648
    if ((int )dp->d_name[0] == 46) {
#line 648
      if ((int )*pattern != 46) {
#line 649
        continue;
      }
    }
#line 650
    dc = pathend;
#line 651
    sc = (u_char *)(dp->d_name);
#line 652
    while (1) {
#line 652
      if ((unsigned int )dc < (unsigned int )pathend_last) {
#line 652
        tmp___3 = dc;
#line 652
        dc ++;
#line 652
        tmp___4 = sc;
#line 652
        sc ++;
#line 652
        *tmp___3 = (unsigned short )*tmp___4;
#line 652
        if (! ((int )*tmp___3 != 0)) {
#line 652
          break;
        }
      } else {
#line 652
        break;
      }
    }
#line 654
    if ((unsigned int )dc >= (unsigned int )pathend_last) {
#line 655
      *dc = (unsigned short )'\000';
#line 656
      err = 1;
#line 657
      break;
    }
#line 660
    tmp___5 = match(pathend, pattern, restpattern);
#line 660
    if (! tmp___5) {
#line 661
      *pathend = (unsigned short )'\000';
#line 662
      continue;
    }
#line 664
    dc --;
#line 664
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp);
#line 666
    if (err) {
#line 667
      break;
    }
  }
#line 670
  if (pglob->gl_flags & 64) {
#line 671
    (*(pglob->gl_closedir))((void *)dirp);
  } else {
#line 673
    closedir(dirp);
  }
#line 674
  return (err);
}
}
#line 692 "openbsd-compat/glob.c"
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) 
{ register char **pathv ;
  register int i ;
  u_int newsize ;
  u_int len ;
  char *copy ;
  Char const   *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  Char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 704
  newsize = sizeof(*pathv) * (unsigned int )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 705
  if (pglob->gl_pathv) {
#line 705
    tmp___1 = realloc((void *)((char *)pglob->gl_pathv), newsize);
#line 705
    pathv = (char **)tmp___1;
  } else {
#line 705
    tmp___2 = malloc(newsize);
#line 705
    pathv = (char **)tmp___2;
  }
#line 707
  if ((unsigned int )pathv == (unsigned int )((void *)0)) {
#line 708
    if (pglob->gl_pathv) {
#line 709
      free((void *)pglob->gl_pathv);
#line 710
      pglob->gl_pathv = (char **)((void *)0);
    }
#line 712
    return (-1);
  }
#line 715
  if ((unsigned int )pglob->gl_pathv == (unsigned int )((void *)0)) {
#line 715
    if (pglob->gl_offs > 0) {
#line 717
      pathv += pglob->gl_offs;
#line 718
      i = pglob->gl_offs;
#line 718
      while (1) {
#line 718
        i --;
#line 718
        if (! (i >= 0)) {
#line 718
          break;
        }
#line 719
        pathv --;
#line 719
        *pathv = (char *)((void *)0);
      }
    }
  }
#line 721
  pglob->gl_pathv = pathv;
#line 723
  p = path;
#line 723
  while (1) {
#line 723
    tmp___3 = p;
#line 723
    p ++;
#line 723
    if (! *tmp___3) {
#line 723
      break;
    }
  }
#line 725
  len = (unsigned int )(p - path);
#line 726
  *limitp += len;
#line 727
  tmp___6 = malloc(len);
#line 727
  copy = (char *)tmp___6;
#line 727
  if ((unsigned int )copy != (unsigned int )((void *)0)) {
#line 728
    tmp___4 = g_Ctoc(path, copy, len);
#line 728
    if (tmp___4) {
#line 729
      free((void *)copy);
#line 730
      return (-1);
    }
#line 732
    tmp___5 = pglob->gl_pathc;
#line 732
    (pglob->gl_pathc) ++;
#line 732
    *(pathv + (pglob->gl_offs + tmp___5)) = copy;
  }
#line 734
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 736
  if (pglob->gl_flags & 8192) {
#line 736
    tmp___8 = get_arg_max();
#line 736
    if (newsize + *limitp >= (unsigned int )tmp___8) {
#line 738
      tmp___7 = __errno_location();
#line 738
      *tmp___7 = 0;
#line 739
      return (-1);
    }
  }
#line 742
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 742
    tmp___9 = -1;
  } else {
#line 742
    tmp___9 = 0;
  }
#line 742
  return (tmp___9);
}
}
#line 750 "openbsd-compat/glob.c"
static int match(Char *name , Char *pat , Char *patend ) 
{ int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  Char *tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;

  {
#line 757
  while ((unsigned int )pat < (unsigned int )patend) {
#line 758
    tmp = pat;
#line 758
    pat ++;
#line 758
    c = *tmp;
#line 759
    switch ((int )c & 65535) {
    case (unsigned short)32810: 
#line 761
    if ((unsigned int )pat == (unsigned int )patend) {
#line 762
      return (1);
    }
#line 763
    while (1) {
#line 764
      tmp___0 = match(name, pat, patend);
#line 764
      if (tmp___0) {
#line 765
        return (1);
      }
#line 763
      tmp___1 = name;
#line 763
      name ++;
#line 763
      if (! ((int )*tmp___1 != 0)) {
#line 763
        break;
      }
    }
#line 768
    return (0);
    case (unsigned short)32831: 
#line 770
    tmp___2 = name;
#line 770
    name ++;
#line 770
    if ((int )*tmp___2 == 0) {
#line 771
      return (0);
    }
#line 772
    break;
    case (unsigned short)32859: 
#line 774
    ok = 0;
#line 775
    tmp___3 = name;
#line 775
    name ++;
#line 775
    k = *tmp___3;
#line 775
    if ((int )k == 0) {
#line 776
      return (0);
    }
#line 777
    negate_range = ((int )*pat & 65535) == 32801;
#line 777
    if (negate_range != 0) {
#line 778
      pat ++;
    }
#line 779
    while (1) {
#line 779
      tmp___4 = pat;
#line 779
      pat ++;
#line 779
      c = *tmp___4;
#line 779
      if (! (((int )c & 65535) != 32861)) {
#line 779
        break;
      }
#line 780
      if (((int )*pat & 65535) == 32813) {
#line 781
        if ((int )c <= (int )k) {
#line 781
          if ((int )k <= (int )*(pat + 1)) {
#line 782
            ok = 1;
          }
        }
#line 783
        pat += 2;
      } else {
#line 784
        if ((int )c == (int )k) {
#line 785
          ok = 1;
        }
      }
    }
#line 786
    if (ok == negate_range) {
#line 787
      return (0);
    }
#line 788
    break;
    default: 
#line 790
    tmp___5 = name;
#line 790
    name ++;
#line 790
    if ((int )*tmp___5 != (int )c) {
#line 791
      return (0);
    }
#line 792
    break;
    }
  }
#line 795
  return ((int )*name == 0);
}
}
#line 799 "openbsd-compat/glob.c"
void globfree(glob_t *pglob ) 
{ register int i ;
  register char **pp ;
  int tmp ;

  {
#line 806
  if ((unsigned int )pglob->gl_pathv != (unsigned int )((void *)0)) {
#line 807
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 808
    i = pglob->gl_pathc;
#line 808
    while (1) {
#line 808
      tmp = i;
#line 808
      i --;
#line 808
      if (! tmp) {
#line 808
        break;
      }
#line 809
      if (*pp) {
#line 810
        free((void *)*pp);
      }
#line 808
      pp ++;
    }
#line 811
    free((void *)pglob->gl_pathv);
#line 812
    pglob->gl_pathv = (char **)((void *)0);
  }
#line 814
  return;
}
}
#line 816 "openbsd-compat/glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ char buf___2[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 823
  if (! *str) {
#line 824
    strcpy((char * __restrict  )(buf___2), (char const   * __restrict  )".");
  } else {
#line 826
    tmp = g_Ctoc((Char const   *)str, buf___2, sizeof(buf___2));
#line 826
    if (tmp) {
#line 827
      return ((DIR *)((void *)0));
    }
  }
#line 830
  if (pglob->gl_flags & 64) {
#line 831
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___2));
#line 831
    return ((DIR *)tmp___0);
  }
#line 833
  tmp___1 = opendir((char const   *)(buf___2));
#line 833
  return (tmp___1);
}
}
#line 836 "openbsd-compat/glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___2[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 844
  tmp = g_Ctoc((Char const   *)fn, buf___2, sizeof(buf___2));
#line 844
  if (tmp) {
#line 845
    return (-1);
  }
#line 846
  if (pglob->gl_flags & 64) {
#line 847
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___2), sb);
#line 847
    return (tmp___0);
  }
#line 848
  tmp___1 = lstat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )sb);
#line 848
  return (tmp___1);
}
}
#line 851 "openbsd-compat/glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___2[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 859
  tmp = g_Ctoc((Char const   *)fn, buf___2, sizeof(buf___2));
#line 859
  if (tmp) {
#line 860
    return (-1);
  }
#line 861
  if (pglob->gl_flags & 64) {
#line 862
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___2), sb);
#line 862
    return (tmp___0);
  }
#line 863
  tmp___1 = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )sb);
#line 863
  return (tmp___1);
}
}
#line 866 "openbsd-compat/glob.c"
static Char *g_strchr(Char *str , int ch ) 
{ Char *tmp ;

  {
#line 871
  while (1) {
#line 872
    if ((int )*str == ch) {
#line 873
      return (str);
    }
#line 871
    tmp = str;
#line 871
    str ++;
#line 871
    if (! *tmp) {
#line 871
      break;
    }
  }
#line 875
  return ((Char *)((void *)0));
}
}
#line 878 "openbsd-compat/glob.c"
static int g_Ctoc(Char const   *str , char *buf___2 , u_int len ) 
{ char *tmp ;
  Char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 885
  while (1) {
#line 885
    tmp___1 = len;
#line 885
    len --;
#line 885
    if (! tmp___1) {
#line 885
      break;
    }
#line 886
    tmp = buf___2;
#line 886
    buf___2 ++;
#line 886
    tmp___0 = str;
#line 886
    str ++;
#line 886
    *tmp = (char )*tmp___0;
#line 886
    if ((int )*tmp == 0) {
#line 887
      return (0);
    }
  }
#line 889
  return (1);
}
}
#line 1 "inet_aton.o"
#line 1 "inet_ntoa.o"
#line 1 "inet_ntop.o"
#line 1 "mktemp.o"
#line 1 "readpassphrase.o"
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 44 "./openbsd-compat/readpassphrase.h"
char *readpassphrase(char const   *prompt , char *buf___2 , size_t bufsiz , int flags ) ;
#line 45 "openbsd-compat/readpassphrase.c"
char *readpassphrase(char const   *prompt , char *buf___2 , size_t bufsiz , int flags ) 
{ struct termios term ;
  char ch ;
  char *p ;
  char *end ;
  u_char status ;
  int echo ;
  int input___0 ;
  int output___0 ;
  sigset_t oset ;
  sigset_t nset ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int __res ;
  __int32_t const   **tmp___6 ;
  int __res___0 ;
  __int32_t const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  ssize_t tmp___12 ;

  {
#line 61
  if (bufsiz == 0U) {
#line 62
    tmp = __errno_location();
#line 62
    *tmp = 22;
#line 63
    return ((char *)((void *)0));
  }
#line 70
  output___0 = open("/dev/tty", 2);
#line 70
  input___0 = output___0;
#line 70
  if (input___0 == -1) {
#line 71
    if (flags & 2) {
#line 72
      tmp___0 = __errno_location();
#line 72
      *tmp___0 = 25;
#line 73
      return ((char *)((void *)0));
    }
#line 75
    input___0 = 0;
#line 76
    output___0 = 2;
  }
#line 84
  sigemptyset(& nset);
#line 85
  sigaddset(& nset, 2);
#line 86
  sigaddset(& nset, 20);
#line 87
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 90
  echo = 0;
#line 92
  status = (unsigned char )'\000';
#line 94
  tmp___1 = tcgetattr(input___0, & term);
#line 94
  if (tmp___1 == 0) {
#line 95
    if (! (flags & 1)) {
#line 95
      if (term.c_lflag & 8U) {
#line 96
        echo = 1;
#line 97
        term.c_lflag &= 4294967287U;
      }
    }
#line 105
    tcsetattr(input___0, 2, (struct termios  const  *)(& term));
  }
#line 107
  if (! (flags & 1)) {
#line 108
    tmp___2 = tcgetattr(input___0, & term);
#line 108
    if (tmp___2 == 0) {
#line 108
      if (term.c_lflag & 8U) {
#line 109
        echo = 1;
#line 110
        term.c_lflag &= 4294967287U;
#line 111
        tcsetattr(input___0, 2, (struct termios  const  *)(& term));
      }
    }
  }
#line 115
  tmp___3 = strlen(prompt);
#line 115
  write(output___0, (void const   *)prompt, tmp___3);
#line 116
  end = (buf___2 + bufsiz) - 1;
#line 117
  p = buf___2;
#line 117
  while (1) {
#line 117
    tmp___12 = read(input___0, (void *)(& ch), 1U);
#line 117
    if (tmp___12 == 1) {
#line 117
      if ((int )ch != 10) {
#line 117
        if (! ((int )ch != 13)) {
#line 117
          break;
        }
      } else {
#line 117
        break;
      }
    } else {
#line 117
      break;
    }
#line 118
    if ((unsigned int )p < (unsigned int )end) {
#line 119
      if (flags & 16) {
#line 120
        ch = (char )((int )ch & 127);
      }
#line 121
      tmp___10 = __ctype_b_loc();
#line 121
      if ((int const   )*(*tmp___10 + (int )ch) & 1024) {
#line 122
        if (flags & 4) {
#line 123
          if (sizeof(ch) > 1U) {
#line 123
            __res = tolower((int )ch);
          } else {
#line 123
            tmp___6 = __ctype_tolower_loc();
#line 123
            __res = (int )*(*tmp___6 + (int )ch);
          }
#line 123
          ch = (char )__res;
        }
#line 124
        if (flags & 8) {
#line 125
          if (sizeof(ch) > 1U) {
#line 125
            __res___0 = toupper((int )ch);
          } else {
#line 125
            tmp___9 = __ctype_toupper_loc();
#line 125
            __res___0 = (int )*(*tmp___9 + (int )ch);
          }
#line 125
          ch = (char )__res___0;
        }
      }
#line 127
      tmp___11 = p;
#line 127
      p ++;
#line 127
      *tmp___11 = ch;
    }
  }
#line 130
  *p = (char )'\000';
#line 132
  if (echo) {
    goto _L;
  } else {
#line 132
    if ((int )status != 0) {
      _L: /* CIL Label */ 
#line 136
      if (echo) {
#line 137
        write(output___0, (void const   *)"\n", 1U);
#line 138
        term.c_lflag |= 8U;
      }
#line 144
      tcsetattr(input___0, 2, (struct termios  const  *)(& term));
    }
  }
#line 146
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 147
  if (input___0 != 0) {
#line 148
    close(input___0);
  }
#line 149
  return (buf___2);
}
}
#line 1 "realpath.o"
#line 1 "rresvport.o"
#line 1 "setenv.o"
#line 1 "setproctitle.o"
#line 9 "./openbsd-compat/setproctitle.h"
void setproctitle(char const   *fmt  , ...) ;
#line 71 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 101
  return;
}
}
#line 1 "sigact.o"
#line 1 "strlcat.o"
#line 9 "openbsd-compat/strlcat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 48 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 54
  d = dst;
#line 55
  s = src;
#line 56
  n___0 = siz;
#line 60
  while (1) {
#line 60
    tmp = n___0;
#line 60
    n___0 --;
#line 60
    if (tmp != 0U) {
#line 60
      if (! ((int )*d != 0)) {
#line 60
        break;
      }
    } else {
#line 60
      break;
    }
#line 61
    d ++;
  }
#line 62
  dlen = (unsigned int )(d - dst);
#line 63
  n___0 = siz - dlen;
#line 65
  if (n___0 == 0U) {
#line 66
    tmp___0 = strlen(s);
#line 66
    return (dlen + tmp___0);
  }
#line 67
  while ((int const   )*s != 0) {
#line 68
    if (n___0 != 1U) {
#line 69
      tmp___1 = d;
#line 69
      d ++;
#line 69
      *tmp___1 = (char )*s;
#line 70
      n___0 --;
    }
#line 72
    s ++;
  }
#line 74
  *d = (char )'\000';
#line 76
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#line 9 "openbsd-compat/strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 46 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 52
  d = dst;
#line 53
  s = src;
#line 54
  n___0 = siz;
#line 57
  if (n___0 != 0U) {
#line 57
    n___0 --;
#line 57
    if (n___0 != 0U) {
#line 58
      while (1) {
#line 59
        tmp = d;
#line 59
        d ++;
#line 59
        tmp___0 = s;
#line 59
        s ++;
#line 59
        *tmp = (char )*tmp___0;
#line 59
        if ((int )*tmp == 0) {
#line 60
          break;
        }
#line 58
        n___0 --;
#line 58
        if (! (n___0 != 0U)) {
#line 58
          break;
        }
      }
    }
  }
#line 65
  if (n___0 == 0U) {
#line 66
    if (siz != 0U) {
#line 67
      *d = (char )'\000';
    }
#line 68
    while (1) {
#line 68
      tmp___1 = s;
#line 68
      s ++;
#line 68
      if (! *tmp___1) {
#line 68
        break;
      }
    }
  }
#line 72
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#line 5 "./openbsd-compat/strmode.h"
void strmode(mode_t mode , char *p ) ;
#line 45 "openbsd-compat/strmode.c"
void strmode(mode_t mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 49
  switch ((int )(mode & 61440U)) {
  case 16384: 
#line 51
  tmp = p;
#line 51
  p ++;
#line 51
  *tmp = (char )'d';
#line 52
  break;
  case 8192: 
#line 54
  tmp___0 = p;
#line 54
  p ++;
#line 54
  *tmp___0 = (char )'c';
#line 55
  break;
  case 24576: 
#line 57
  tmp___1 = p;
#line 57
  p ++;
#line 57
  *tmp___1 = (char )'b';
#line 58
  break;
  case 32768: 
#line 60
  tmp___2 = p;
#line 60
  p ++;
#line 60
  *tmp___2 = (char )'-';
#line 61
  break;
  case 40960: 
#line 63
  tmp___3 = p;
#line 63
  p ++;
#line 63
  *tmp___3 = (char )'l';
#line 64
  break;
  case 49152: 
#line 67
  tmp___4 = p;
#line 67
  p ++;
#line 67
  *tmp___4 = (char )'s';
#line 68
  break;
  case 4096: 
#line 72
  tmp___5 = p;
#line 72
  p ++;
#line 72
  *tmp___5 = (char )'p';
#line 73
  break;
  default: 
#line 81
  tmp___6 = p;
#line 81
  p ++;
#line 81
  *tmp___6 = (char )'?';
#line 82
  break;
  }
#line 85
  if (mode & 256U) {
#line 86
    tmp___7 = p;
#line 86
    p ++;
#line 86
    *tmp___7 = (char )'r';
  } else {
#line 88
    tmp___8 = p;
#line 88
    p ++;
#line 88
    *tmp___8 = (char )'-';
  }
#line 89
  if (mode & 128U) {
#line 90
    tmp___9 = p;
#line 90
    p ++;
#line 90
    *tmp___9 = (char )'w';
  } else {
#line 92
    tmp___10 = p;
#line 92
    p ++;
#line 92
    *tmp___10 = (char )'-';
  }
#line 93
  switch ((int )(mode & 2112U)) {
  case 0: 
#line 95
  tmp___11 = p;
#line 95
  p ++;
#line 95
  *tmp___11 = (char )'-';
#line 96
  break;
  case 64: 
#line 98
  tmp___12 = p;
#line 98
  p ++;
#line 98
  *tmp___12 = (char )'x';
#line 99
  break;
  case 2048: 
#line 101
  tmp___13 = p;
#line 101
  p ++;
#line 101
  *tmp___13 = (char )'S';
#line 102
  break;
  case 2112: 
#line 104
  tmp___14 = p;
#line 104
  p ++;
#line 104
  *tmp___14 = (char )'s';
#line 105
  break;
  }
#line 108
  if (mode & (unsigned int )(256 >> 3)) {
#line 109
    tmp___15 = p;
#line 109
    p ++;
#line 109
    *tmp___15 = (char )'r';
  } else {
#line 111
    tmp___16 = p;
#line 111
    p ++;
#line 111
    *tmp___16 = (char )'-';
  }
#line 112
  if (mode & (unsigned int )(128 >> 3)) {
#line 113
    tmp___17 = p;
#line 113
    p ++;
#line 113
    *tmp___17 = (char )'w';
  } else {
#line 115
    tmp___18 = p;
#line 115
    p ++;
#line 115
    *tmp___18 = (char )'-';
  }
#line 116
  switch ((int )(mode & (unsigned int )((64 >> 3) | 1024))) {
  case 0: 
#line 118
  tmp___19 = p;
#line 118
  p ++;
#line 118
  *tmp___19 = (char )'-';
#line 119
  break;
  case 64 >> 3: 
#line 121
  tmp___20 = p;
#line 121
  p ++;
#line 121
  *tmp___20 = (char )'x';
#line 122
  break;
  case 1024: 
#line 124
  tmp___21 = p;
#line 124
  p ++;
#line 124
  *tmp___21 = (char )'S';
#line 125
  break;
  case (64 >> 3) | 1024: 
#line 127
  tmp___22 = p;
#line 127
  p ++;
#line 127
  *tmp___22 = (char )'s';
#line 128
  break;
  }
#line 131
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 132
    tmp___23 = p;
#line 132
    p ++;
#line 132
    *tmp___23 = (char )'r';
  } else {
#line 134
    tmp___24 = p;
#line 134
    p ++;
#line 134
    *tmp___24 = (char )'-';
  }
#line 135
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 136
    tmp___25 = p;
#line 136
    p ++;
#line 136
    *tmp___25 = (char )'w';
  } else {
#line 138
    tmp___26 = p;
#line 138
    p ++;
#line 138
    *tmp___26 = (char )'-';
  }
#line 139
  switch ((int )(mode & (unsigned int )(((64 >> 3) >> 3) | 512))) {
  case 0: 
#line 141
  tmp___27 = p;
#line 141
  p ++;
#line 141
  *tmp___27 = (char )'-';
#line 142
  break;
  case (64 >> 3) >> 3: 
#line 144
  tmp___28 = p;
#line 144
  p ++;
#line 144
  *tmp___28 = (char )'x';
#line 145
  break;
  case 512: 
#line 147
  tmp___29 = p;
#line 147
  p ++;
#line 147
  *tmp___29 = (char )'T';
#line 148
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 150
  tmp___30 = p;
#line 150
  p ++;
#line 150
  *tmp___30 = (char )'t';
#line 151
  break;
  }
#line 153
  tmp___31 = p;
#line 153
  p ++;
#line 153
  *tmp___31 = (char )' ';
#line 154
  *p = (char )'\000';
#line 155
  return;
}
}
#line 1 "strsep.o"
#line 1 "atomicio.o"
#line 31 "atomicio.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 34 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 41
  s = (char *)_s;
#line 42
  pos = 0;
#line 44
  while (n___0 > (size_t )pos) {
#line 45
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 46
    switch (res) {
    case -1: 
#line 49
    tmp = __errno_location();
#line 49
    if (*tmp == 4) {
#line 53
      continue;
    } else {
#line 49
      tmp___0 = __errno_location();
#line 49
      if (*tmp___0 == 11) {
#line 53
        continue;
      } else {
#line 49
        tmp___1 = __errno_location();
#line 49
        if (*tmp___1 == 11) {
#line 53
          continue;
        }
      }
    }
    case 0: 
#line 55
    return (res);
    default: 
#line 57
    pos += res;
    }
  }
#line 60
  return (pos);
}
}
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 27
void buffer_clear(Buffer *buffer ) ;
#line 28
void buffer_free(Buffer *buffer ) ;
#line 30
u_int buffer_len(Buffer *buffer ) ;
#line 31
char *buffer_ptr(Buffer *buffer ) ;
#line 33
void buffer_append(Buffer *buffer , char const   *data , u_int len ) ;
#line 21 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 22
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 24
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 27
u_int buffer_get_int(Buffer *buffer ) ;
#line 28
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 35
int buffer_get_char(Buffer *buffer ) ;
#line 37
void buffer_put_char(Buffer *buffer , int value ) ;
#line 39
char *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 41
void buffer_put_string(Buffer *buffer , void const   *buf___2 , u_int len ) ;
#line 42
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 22 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 24
void xfree(void *ptr ) ;
#line 58 "key.h"
Key *key_new(int type ) ;
#line 72
Key *key_from_blob(u_char *blob , int blen ) ;
#line 73
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) ;
#line 74
char *key_ssh_name(Key *k ) ;
#line 59 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 60
void ssh_close_authentication_socket(int sock ) ;
#line 62
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 63
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 64
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) ;
#line 65
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 66
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) ;
#line 67
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 68
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 69
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) ;
#line 70
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ) ;
#line 72
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 76
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , int *lenp ,
                   u_char *data , int datalen ) ;
#line 63 "compat.h"
int datafellows ;
#line 55 "log.h"
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 56
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 57 "authfd.c"
int decode_reply(int type ) ;
#line 66 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 73
  tmp = getenv("SSH_AUTH_SOCK");
#line 73
  authsocket = (char const   *)tmp;
#line 74
  if (! authsocket) {
#line 75
    return (-1);
  }
#line 77
  sunaddr.sun_family = (unsigned short)1;
#line 78
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 80
  sock = socket(1, 1, 0);
#line 81
  if (sock < 0) {
#line 82
    return (-1);
  }
#line 85
  tmp___0 = fcntl(sock, 2, 1);
#line 85
  if (tmp___0 == -1) {
#line 86
    close(sock);
#line 87
    return (-1);
  }
#line 89
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 89
  if (tmp___1 < 0) {
#line 90
    close(sock);
#line 91
    return (-1);
  }
#line 93
  return (sock);
}
}
#line 96 "authfd.c"
static int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ int l ;
  int len ;
  char buf___2[1024] ;
  u_int tmp ;
  ssize_t tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  u_int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 103
  tmp = buffer_len(request);
#line 103
  len = (int )tmp;
#line 104
  while (1) {
#line 104
    buf___2[0] = (char )(len >> 24);
#line 104
    buf___2[1] = (char )(len >> 16);
#line 104
    buf___2[2] = (char )(len >> 8);
#line 104
    buf___2[3] = (char )len;
#line 104
    break;
  }
#line 107
  tmp___0 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___2), 4U);
#line 107
  if (tmp___0 != 4) {
#line 110
    error("Error writing to authentication socket.");
#line 111
    return (0);
  } else {
#line 107
    tmp___1 = buffer_len(request);
#line 107
    tmp___2 = buffer_ptr(request);
#line 107
    tmp___3 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___2, tmp___1);
#line 107
    tmp___4 = buffer_len(request);
#line 107
    if ((u_int )tmp___3 != tmp___4) {
#line 110
      error("Error writing to authentication socket.");
#line 111
      return (0);
    }
  }
#line 117
  len = 4;
#line 118
  while (len > 0) {
#line 119
    l = read(auth->fd, (void *)((buf___2 + 4) - len), (unsigned int )len);
#line 120
    if (l == -1) {
#line 120
      tmp___5 = __errno_location();
#line 120
      if (*tmp___5 == 11) {
#line 121
        continue;
      } else {
#line 120
        tmp___6 = __errno_location();
#line 120
        if (*tmp___6 == 4) {
#line 121
          continue;
        }
      }
    }
#line 122
    if (l <= 0) {
#line 123
      error("Error reading response length from authentication socket.");
#line 124
      return (0);
    }
#line 126
    len -= l;
  }
#line 130
  len = (int )(((((unsigned long )((unsigned char )buf___2[0]) << 24) | ((unsigned long )((unsigned char )buf___2[1]) << 16)) | ((unsigned long )((unsigned char )buf___2[2]) << 8)) | (unsigned long )((unsigned char )buf___2[3]));
#line 131
  if (len > 262144) {
#line 132
    fatal("Authentication response too long: %d", len);
  }
#line 135
  buffer_clear(reply);
#line 136
  while (len > 0) {
#line 137
    l = len;
#line 138
    if ((unsigned int )l > sizeof(buf___2)) {
#line 139
      l = (int )sizeof(buf___2);
    }
#line 140
    l = read(auth->fd, (void *)(buf___2), (unsigned int )l);
#line 141
    if (l == -1) {
#line 141
      tmp___7 = __errno_location();
#line 141
      if (*tmp___7 == 11) {
#line 142
        continue;
      } else {
#line 141
        tmp___8 = __errno_location();
#line 141
        if (*tmp___8 == 4) {
#line 142
          continue;
        }
      }
    }
#line 143
    if (l <= 0) {
#line 144
      error("Error reading response from authentication socket.");
#line 145
      return (0);
    }
#line 147
    buffer_append(reply, (char const   *)(buf___2), (unsigned int )l);
#line 148
    len -= l;
  }
#line 150
  return (1);
}
}
#line 159 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 162
  tmp = getenv("SSH_AUTH_SOCK");
#line 162
  if (tmp) {
#line 163
    close(sock);
  }
#line 164
  return;
}
}
#line 174 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 180
  sock = ssh_get_authentication_socket();
#line 186
  if (sock < 0) {
#line 187
    return ((AuthenticationConnection *)((void *)0));
  }
#line 189
  tmp = xmalloc(sizeof(*auth));
#line 189
  auth = (AuthenticationConnection *)tmp;
#line 190
  auth->fd = sock;
#line 191
  buffer_init(& auth->identities);
#line 192
  auth->howmany = 0;
#line 194
  return (auth);
}
}
#line 202 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 205
  buffer_free(& auth->identities);
#line 206
  close(auth->fd);
#line 207
  xfree((void *)auth);
#line 208
  return;
}
}
#line 214 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 217
  code1 = 0;
#line 217
  code2 = 0;
#line 220
  switch (version) {
  case 1: 
#line 222
  code1 = 1;
#line 223
  code2 = 2;
#line 224
  break;
  case 2: 
#line 226
  code1 = 11;
#line 227
  code2 = 12;
#line 228
  break;
  default: ;
#line 230
  return (0);
  }
#line 237
  buffer_init(& request);
#line 238
  buffer_put_char(& request, code1);
#line 240
  buffer_clear(& auth->identities);
#line 241
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 241
  if (tmp == 0) {
#line 242
    buffer_free(& request);
#line 243
    return (0);
  }
#line 245
  buffer_free(& request);
#line 248
  type = buffer_get_char(& auth->identities);
#line 249
  if (type == 5) {
#line 250
    return (0);
  } else {
#line 249
    if (type == 102) {
#line 250
      return (0);
    } else {
#line 249
      if (type == 30) {
#line 250
        return (0);
      } else {
#line 251
        if (type != code2) {
#line 252
          fatal("Bad authentication reply message type: %d", type);
        }
      }
    }
  }
#line 256
  tmp___0 = buffer_get_int(& auth->identities);
#line 256
  auth->howmany = (int )tmp___0;
#line 257
  if (auth->howmany > 1024) {
#line 258
    fatal("Too many identities in authentication reply: %d", auth->howmany);
  }
#line 261
  return (auth->howmany);
}
}
#line 264 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 268
  tmp___0 = ssh_get_num_identities(auth, version);
#line 268
  if (tmp___0 > 0) {
#line 269
    tmp = ssh_get_next_identity(auth, comment, version);
#line 269
    return (tmp);
  }
#line 270
  return ((Key *)((void *)0));
}
}
#line 273 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version ) 
{ u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 279
  key = (Key *)((void *)0);
#line 282
  if (auth->howmany <= 0) {
#line 283
    return ((Key *)((void *)0));
  }
#line 289
  switch (version) {
  case 1: 
#line 291
  key = key_new(0);
#line 292
  bits = buffer_get_int(& auth->identities);
#line 293
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 294
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 295
  *comment = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 296
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 296
  if (bits != (u_int )tmp___0) {
#line 297
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 297
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 299
  break;
  case 2: 
#line 301
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 301
  blob = (u_char *)tmp___1;
#line 302
  *comment = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 303
  key = key_from_blob(blob, (int )blen);
#line 304
  xfree((void *)blob);
#line 305
  break;
  default: ;
#line 307
  return ((Key *)((void *)0));
#line 308
  break;
  }
#line 311
  (auth->howmany) --;
#line 312
  return (key);
}
}
#line 323 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 331
  success = 0;
#line 335
  if (key->type != 0) {
#line 336
    return (0);
  }
#line 337
  if (response_type == 0U) {
#line 338
    log("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 339
    return (0);
  }
#line 341
  buffer_init(& buffer);
#line 342
  buffer_put_char(& buffer, 3);
#line 343
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 343
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 344
  buffer_put_bignum(& buffer, (key->rsa)->e);
#line 345
  buffer_put_bignum(& buffer, (key->rsa)->n);
#line 346
  buffer_put_bignum(& buffer, challenge);
#line 347
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 348
  buffer_put_int(& buffer, response_type);
#line 350
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 350
  if (tmp___0 == 0) {
#line 351
    buffer_free(& buffer);
#line 352
    return (0);
  }
#line 354
  type = buffer_get_char(& buffer);
#line 356
  if (type == 5) {
#line 357
    log("Agent admitted failure to authenticate using the key.");
  } else {
#line 356
    if (type == 102) {
#line 357
      log("Agent admitted failure to authenticate using the key.");
    } else {
#line 356
      if (type == 30) {
#line 357
        log("Agent admitted failure to authenticate using the key.");
      } else {
#line 358
        if (type != 4) {
#line 359
          fatal("Bad authentication response: %d", type);
        } else {
#line 361
          success = 1;
#line 366
          i = 0;
#line 366
          while (i < 16) {
#line 367
            tmp___1 = buffer_get_char(& buffer);
#line 367
            *(response + i) = (unsigned char )tmp___1;
#line 366
            i ++;
          }
        }
      }
    }
  }
#line 369
  buffer_free(& buffer);
#line 370
  return (success);
}
}
#line 374 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , int *lenp ,
                   u_char *data , int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 384
  flags = 0;
#line 385
  ret = -1;
#line 387
  tmp = key_to_blob(key, & blob, & blen);
#line 387
  if (tmp == 0) {
#line 388
    return (-1);
  }
#line 390
  if (datafellows & 1) {
#line 391
    flags = 1;
  }
#line 393
  buffer_init(& msg);
#line 394
  buffer_put_char(& msg, 13);
#line 395
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 396
  buffer_put_string(& msg, (void const   *)data, (unsigned int )datalen);
#line 397
  buffer_put_int(& msg, (unsigned int )flags);
#line 398
  xfree((void *)blob);
#line 400
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 400
  if (tmp___0 == 0) {
#line 401
    buffer_free(& msg);
#line 402
    return (-1);
  }
#line 404
  type = buffer_get_char(& msg);
#line 405
  if (type == 5) {
#line 406
    log("Agent admitted failure to sign using the key.");
  } else {
#line 405
    if (type == 102) {
#line 406
      log("Agent admitted failure to sign using the key.");
    } else {
#line 405
      if (type == 30) {
#line 406
        log("Agent admitted failure to sign using the key.");
      } else {
#line 407
        if (type != 14) {
#line 408
          fatal("Bad authentication response: %d", type);
        } else {
#line 410
          ret = 0;
#line 411
          tmp___1 = buffer_get_string(& msg, (u_int *)lenp);
#line 411
          *sigp = (u_char *)tmp___1;
        }
      }
    }
  }
#line 413
  buffer_free(& msg);
#line 414
  return (ret);
}
}
#line 419 "authfd.c"
static void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;

  {
#line 422
  buffer_clear(b);
#line 423
  buffer_put_char(b, 7);
#line 424
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 424
  buffer_put_int(b, (unsigned int )tmp);
#line 425
  buffer_put_bignum(b, key->n);
#line 426
  buffer_put_bignum(b, key->e);
#line 427
  buffer_put_bignum(b, key->d);
#line 429
  buffer_put_bignum(b, key->iqmp);
#line 430
  buffer_put_bignum(b, key->q);
#line 431
  buffer_put_bignum(b, key->p);
#line 432
  buffer_put_cstring(b, comment);
#line 433
  return;
}
}
#line 435 "authfd.c"
static void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char *tmp ;

  {
#line 438
  buffer_clear(b);
#line 439
  buffer_put_char(b, 17);
#line 440
  tmp = key_ssh_name(key);
#line 440
  buffer_put_cstring(b, (char const   *)tmp);
#line 441
  switch (key->type) {
  case 1: 
#line 443
  buffer_put_bignum2(b, (key->rsa)->n);
#line 444
  buffer_put_bignum2(b, (key->rsa)->e);
#line 445
  buffer_put_bignum2(b, (key->rsa)->d);
#line 446
  buffer_put_bignum2(b, (key->rsa)->iqmp);
#line 447
  buffer_put_bignum2(b, (key->rsa)->p);
#line 448
  buffer_put_bignum2(b, (key->rsa)->q);
#line 449
  break;
  case 2: 
#line 451
  buffer_put_bignum2(b, (key->dsa)->p);
#line 452
  buffer_put_bignum2(b, (key->dsa)->q);
#line 453
  buffer_put_bignum2(b, (key->dsa)->g);
#line 454
  buffer_put_bignum2(b, (key->dsa)->pub_key);
#line 455
  buffer_put_bignum2(b, (key->dsa)->priv_key);
#line 456
  break;
  }
#line 458
  buffer_put_cstring(b, comment);
#line 459
  return;
}
}
#line 466 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ Buffer msg ;
  int type ;
  int tmp ;
  int tmp___0 ;

  {
#line 472
  buffer_init(& msg);
#line 474
  switch (key->type) {
  case 0: 
#line 476
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 477
  break;
  case 1: 
  case 2: 
#line 480
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 481
  break;
  default: 
#line 483
  buffer_free(& msg);
#line 484
  return (0);
#line 485
  break;
  }
#line 487
  tmp = ssh_request_reply(auth, & msg, & msg);
#line 487
  if (tmp == 0) {
#line 488
    buffer_free(& msg);
#line 489
    return (0);
  }
#line 491
  type = buffer_get_char(& msg);
#line 492
  buffer_free(& msg);
#line 493
  tmp___0 = decode_reply(type);
#line 493
  return (tmp___0);
}
}
#line 501 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 509
  buffer_init(& msg);
#line 511
  if (key->type == 0) {
#line 512
    buffer_put_char(& msg, 8);
#line 513
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 513
    buffer_put_int(& msg, (unsigned int )tmp);
#line 514
    buffer_put_bignum(& msg, (key->rsa)->e);
#line 515
    buffer_put_bignum(& msg, (key->rsa)->n);
  } else {
#line 516
    if (key->type == 2) {
#line 517
      key_to_blob(key, & blob, & blen);
#line 518
      buffer_put_char(& msg, 18);
#line 519
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 520
      xfree((void *)blob);
    } else {
#line 516
      if (key->type == 1) {
#line 517
        key_to_blob(key, & blob, & blen);
#line 518
        buffer_put_char(& msg, 18);
#line 519
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 520
        xfree((void *)blob);
      } else {
#line 522
        buffer_free(& msg);
#line 523
        return (0);
      }
    }
  }
#line 525
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 525
  if (tmp___0 == 0) {
#line 526
    buffer_free(& msg);
#line 527
    return (0);
  }
#line 529
  type = buffer_get_char(& msg);
#line 530
  buffer_free(& msg);
#line 531
  tmp___1 = decode_reply(type);
#line 531
  return (tmp___1);
}
}
#line 534 "authfd.c"
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ) 
{ Buffer msg ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 540
  buffer_init(& msg);
#line 541
  if (add) {
#line 541
    tmp = 20;
  } else {
#line 541
    tmp = 21;
  }
#line 541
  buffer_put_char(& msg, tmp);
#line 543
  buffer_put_cstring(& msg, reader_id);
#line 544
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 544
  if (tmp___0 == 0) {
#line 545
    buffer_free(& msg);
#line 546
    return (0);
  }
#line 548
  type = buffer_get_char(& msg);
#line 549
  buffer_free(& msg);
#line 550
  tmp___1 = decode_reply(type);
#line 550
  return (tmp___1);
}
}
#line 558 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 563
  if (version == 1) {
#line 563
    tmp = 9;
  } else {
#line 563
    tmp = 19;
  }
#line 563
  code = tmp;
#line 567
  buffer_init(& msg);
#line 568
  buffer_put_char(& msg, code);
#line 570
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 570
  if (tmp___0 == 0) {
#line 571
    buffer_free(& msg);
#line 572
    return (0);
  }
#line 574
  type = buffer_get_char(& msg);
#line 575
  buffer_free(& msg);
#line 576
  tmp___1 = decode_reply(type);
#line 576
  return (tmp___1);
}
}
#line 579 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 582
  switch (type) {
  case 5: 
  case 102: 
  case 30: 
#line 586
  log("SSH_AGENT_FAILURE");
#line 587
  return (0);
  case 6: 
#line 589
  return (1);
  default: 
#line 591
  fatal("Bad response from authentication agent: %d", type);
  }
#line 594
  return (0);
}
}
#line 1 "authfile.o"
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 248
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 109 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 115
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 116
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 117
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) ;
#line 25 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 34 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , u_int len ) ;
#line 59 "key.h"
Key *key_new_private(int type ) ;
#line 60
void key_free(Key *k ) ;
#line 63
char *key_type(Key *k ) ;
#line 65
int key_read(Key *ret , char **cpp ) ;
#line 58 "log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 60
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 18 "authfile.h"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) ;
#line 19
Key *key_load_public(char const   *filename , char **commentp ) ;
#line 20
Key *key_load_public_type(int type , char const   *filename , char **commentp ) ;
#line 21
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) ;
#line 22
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) ;
#line 55 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 55 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 65 "authfile.c"
static int key_save_private_rsa1(Key *key , char const   *filename , char const   *passphrase ,
                                 char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___2[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  u_int tmp___18 ;
  char *tmp___19 ;
  ssize_t tmp___20 ;
  u_int tmp___21 ;

  {
#line 80
  if (0) {
#line 80
    __s1_len = strlen(passphrase);
#line 80
    __s2_len = strlen("");
#line 80
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 80
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 80
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 80
          tmp___8 = 1;
        } else {
#line 80
          if (__s2_len >= 4U) {
#line 80
            tmp___8 = 1;
          } else {
#line 80
            tmp___8 = 0;
          }
        }
      } else {
#line 80
        tmp___8 = 0;
      }
    }
#line 80
    if (tmp___8) {
#line 80
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 80
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 80
      tmp___4 = tmp___7;
    }
  } else {
#line 80
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 80
    tmp___4 = tmp___7;
  }
#line 80
  if (tmp___4 == 0) {
#line 81
    cipher = cipher_by_number(0);
  } else {
#line 83
    cipher = cipher_by_number(3);
  }
#line 84
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 85
    fatal("save_private_key_rsa: bad cipher");
  }
#line 88
  buffer_init(& buffer);
#line 91
  rand___0 = arc4random();
#line 92
  buf___2[0] = (char )(rand___0 & 255U);
#line 93
  buf___2[1] = (char )((rand___0 >> 8) & 255U);
#line 94
  buf___2[2] = buf___2[0];
#line 95
  buf___2[3] = buf___2[1];
#line 96
  buffer_append(& buffer, (char const   *)(buf___2), 4U);
#line 103
  buffer_put_bignum(& buffer, (key->rsa)->d);
#line 104
  buffer_put_bignum(& buffer, (key->rsa)->iqmp);
#line 105
  buffer_put_bignum(& buffer, (key->rsa)->q);
#line 106
  buffer_put_bignum(& buffer, (key->rsa)->p);
#line 109
  while (1) {
#line 109
    tmp___9 = buffer_len(& buffer);
#line 109
    if (! (tmp___9 % 8U != 0U)) {
#line 109
      break;
    }
#line 110
    buffer_put_char(& buffer, 0);
  }
#line 113
  buffer_init(& encrypted);
#line 116
  i = 0;
#line 116
  while (authfile_id_string[i]) {
#line 117
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 116
    i ++;
  }
#line 118
  buffer_put_char(& encrypted, 0);
#line 121
  buffer_put_char(& encrypted, cipher->number);
#line 122
  buffer_put_int(& encrypted, 0U);
#line 125
  tmp___10 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 125
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 126
  buffer_put_bignum(& encrypted, (key->rsa)->n);
#line 127
  buffer_put_bignum(& encrypted, (key->rsa)->e);
#line 128
  buffer_put_cstring(& encrypted, comment);
#line 131
  tmp___11 = buffer_len(& buffer);
#line 131
  buffer_append_space(& encrypted, & cp, tmp___11);
#line 133
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 134
  tmp___12 = buffer_len(& buffer);
#line 134
  tmp___13 = buffer_ptr(& buffer);
#line 134
  cipher_encrypt(& ciphercontext, (u_char *)cp, (u_char const   *)((u_char *)tmp___13),
                 tmp___12);
#line 136
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 139
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 140
  buffer_free(& buffer);
#line 142
  fd = open(filename, 577, 384);
#line 143
  if (fd < 0) {
#line 144
    tmp___14 = __errno_location();
#line 144
    tmp___15 = strerror(*tmp___14);
#line 144
    error("open %s failed: %s.", filename, tmp___15);
#line 145
    return (0);
  }
#line 147
  tmp___18 = buffer_len(& encrypted);
#line 147
  tmp___19 = buffer_ptr(& encrypted);
#line 147
  tmp___20 = write(fd, (void const   *)tmp___19, tmp___18);
#line 147
  tmp___21 = buffer_len(& encrypted);
#line 147
  if ((u_int )tmp___20 != tmp___21) {
#line 149
    tmp___16 = __errno_location();
#line 149
    tmp___17 = strerror(*tmp___16);
#line 149
    error("write to key file %s failed: %s", filename, tmp___17);
#line 151
    buffer_free(& encrypted);
#line 152
    close(fd);
#line 153
    unlink(filename);
#line 154
    return (0);
  }
#line 156
  close(fd);
#line 157
  buffer_free(& encrypted);
#line 158
  return (1);
}
}
#line 162 "authfile.c"
static int key_save_private_pem(Key *key , char const   *filename , char const   *_passphrase ,
                                char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  char *passphrase ;
  char *tmp___0 ;
  EVP_CIPHER *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 168
  success = 0;
#line 169
  tmp = strlen(_passphrase);
#line 169
  len = (int )tmp;
#line 170
  if (len > 0) {
#line 170
    tmp___0 = (char *)_passphrase;
  } else {
#line 170
    tmp___0 = (char *)((void *)0);
  }
#line 170
  passphrase = tmp___0;
#line 171
  if (len > 0) {
#line 171
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 171
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 171
  cipher = (EVP_CIPHER *)tmp___2;
#line 173
  if (len > 0) {
#line 173
    if (len <= 4) {
#line 174
      error("passphrase too short: have %d bytes, need > 4", len);
#line 175
      return (0);
    }
  }
#line 177
  fd = open(filename, 577, 384);
#line 178
  if (fd < 0) {
#line 179
    tmp___3 = __errno_location();
#line 179
    tmp___4 = strerror(*tmp___3);
#line 179
    error("open %s failed: %s.", filename, tmp___4);
#line 180
    return (0);
  }
#line 182
  fp = fdopen(fd, "w");
#line 183
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 184
    tmp___5 = __errno_location();
#line 184
    tmp___6 = strerror(*tmp___5);
#line 184
    error("fdopen %s failed: %s.", filename, tmp___6);
#line 185
    close(fd);
#line 186
    return (0);
  }
#line 188
  switch (key->type) {
  case 2: 
#line 190
  success = PEM_write_DSAPrivateKey(fp, key->dsa, (EVP_CIPHER const   *)cipher, (unsigned char *)passphrase,
                                    len, (pem_password_cb *)((void *)0), (void *)0);
#line 192
  break;
  case 1: 
#line 194
  success = PEM_write_RSAPrivateKey(fp, key->rsa, (EVP_CIPHER const   *)cipher, (unsigned char *)passphrase,
                                    len, (pem_password_cb *)((void *)0), (void *)0);
#line 196
  break;
  }
#line 198
  fclose(fp);
#line 199
  return (success);
}
}
#line 202 "authfile.c"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 206
  switch (key->type) {
  case 0: 
#line 208
  tmp = key_save_private_rsa1(key, filename, passphrase, comment);
#line 208
  return (tmp);
#line 210
  break;
  case 2: 
  case 1: 
#line 213
  tmp___0 = key_save_private_pem(key, filename, passphrase, comment);
#line 213
  return (tmp___0);
#line 215
  break;
  default: ;
#line 217
  break;
  }
#line 219
  error("key_save_private: cannot save key type %d", key->type);
#line 220
  return (0);
}
}
#line 229 "authfile.c"
static Key *key_load_public_rsa1(int fd , char const   *filename , char **commentp ) 
{ Buffer buffer ;
  Key *pub ;
  char *cp ;
  int i ;
  off_t len ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 238
  len = lseek(fd, 0L, 2);
#line 239
  lseek(fd, 0L, 0);
#line 241
  buffer_init(& buffer);
#line 242
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 244
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 244
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 245
    tmp = __errno_location();
#line 245
    tmp___0 = strerror(*tmp);
#line 245
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 247
    buffer_free(& buffer);
#line 248
    return ((Key *)((void *)0));
  }
#line 252
  if ((unsigned long )len < (unsigned long )sizeof(authfile_id_string)) {
#line 253
    debug3("No RSA1 key file %.200s.", filename);
#line 254
    buffer_free(& buffer);
#line 255
    return ((Key *)((void *)0));
  }
#line 261
  i = 0;
#line 261
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 262
    tmp___2 = buffer_get_char(& buffer);
#line 262
    if (tmp___2 != (int )authfile_id_string[i]) {
#line 263
      debug3("No RSA1 key file %.200s.", filename);
#line 264
      buffer_free(& buffer);
#line 265
      return ((Key *)((void *)0));
    }
#line 261
    i ++;
  }
#line 268
  buffer_get_char(& buffer);
#line 269
  buffer_get_int(& buffer);
#line 272
  buffer_get_int(& buffer);
#line 273
  pub = key_new(0);
#line 274
  buffer_get_bignum(& buffer, (pub->rsa)->n);
#line 275
  buffer_get_bignum(& buffer, (pub->rsa)->e);
#line 276
  if (commentp) {
#line 277
    *commentp = buffer_get_string(& buffer, (u_int *)((void *)0));
  }
#line 280
  buffer_free(& buffer);
#line 281
  return (pub);
}
}
#line 285 "authfile.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ Key *pub ;
  int fd ;

  {
#line 291
  if (type == 0) {
#line 292
    fd = open(filename, 0);
#line 293
    if (fd < 0) {
#line 294
      return ((Key *)((void *)0));
    }
#line 295
    pub = key_load_public_rsa1(fd, filename, commentp);
#line 296
    close(fd);
#line 297
    return (pub);
  }
#line 299
  return ((Key *)((void *)0));
}
}
#line 309 "authfile.c"
static Key *key_load_private_rsa1(int fd , char const   *filename , char const   *passphrase ,
                                  char **commentp ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  Key *prv ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  BIGNUM const   *tmp___19 ;
  BIGNUM const   *tmp___20 ;

  {
#line 321
  prv = (Key *)((void *)0);
#line 323
  len = lseek(fd, 0L, 2);
#line 324
  lseek(fd, 0L, 0);
#line 326
  buffer_init(& buffer);
#line 327
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 329
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 329
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 330
    tmp = __errno_location();
#line 330
    tmp___0 = strerror(*tmp);
#line 330
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 332
    buffer_free(& buffer);
#line 333
    close(fd);
#line 334
    return ((Key *)((void *)0));
  }
#line 338
  if ((unsigned long )len < (unsigned long )sizeof(authfile_id_string)) {
#line 339
    debug3("No RSA1 key file %.200s.", filename);
#line 340
    buffer_free(& buffer);
#line 341
    close(fd);
#line 342
    return ((Key *)((void *)0));
  }
#line 348
  i = 0;
#line 348
  while ((unsigned int )i < sizeof(authfile_id_string)) {
#line 349
    tmp___2 = buffer_get_char(& buffer);
#line 349
    if (tmp___2 != (int )authfile_id_string[i]) {
#line 350
      debug3("No RSA1 key file %.200s.", filename);
#line 351
      buffer_free(& buffer);
#line 352
      close(fd);
#line 353
      return ((Key *)((void *)0));
    }
#line 348
    i ++;
  }
#line 357
  cipher_type = buffer_get_char(& buffer);
#line 358
  buffer_get_int(& buffer);
#line 361
  buffer_get_int(& buffer);
#line 362
  prv = key_new_private(0);
#line 364
  buffer_get_bignum(& buffer, (prv->rsa)->n);
#line 365
  buffer_get_bignum(& buffer, (prv->rsa)->e);
#line 366
  if (commentp) {
#line 367
    *commentp = buffer_get_string(& buffer, (u_int *)((void *)0));
  } else {
#line 369
    tmp___3 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 369
    xfree((void *)tmp___3);
  }
#line 372
  cipher = cipher_by_number(cipher_type);
#line 373
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 374
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type, filename);
#line 376
    buffer_free(& buffer);
    goto fail;
  }
#line 380
  buffer_init(& decrypted);
#line 381
  tmp___4 = buffer_len(& buffer);
#line 381
  buffer_append_space(& decrypted, & cp, tmp___4);
#line 384
  cipher_set_key_string(& ciphercontext, cipher, passphrase);
#line 385
  tmp___5 = buffer_len(& buffer);
#line 385
  tmp___6 = buffer_ptr(& buffer);
#line 385
  cipher_decrypt(& ciphercontext, (u_char *)cp, (u_char const   *)((u_char *)tmp___6),
                 tmp___5);
#line 387
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 388
  buffer_free(& buffer);
#line 390
  check1 = buffer_get_char(& decrypted);
#line 391
  check2 = buffer_get_char(& decrypted);
#line 392
  tmp___17 = buffer_get_char(& decrypted);
#line 392
  if (check1 != tmp___17) {
    goto _L___1;
  } else {
#line 392
    tmp___18 = buffer_get_char(& decrypted);
#line 392
    if (check2 != tmp___18) {
      _L___1: /* CIL Label */ 
#line 394
      if (0) {
#line 394
        __s1_len = strlen(passphrase);
#line 394
        __s2_len = strlen("");
#line 394
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 394
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 394
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 394
              tmp___16 = 1;
            } else {
#line 394
              if (__s2_len >= 4U) {
#line 394
                tmp___16 = 1;
              } else {
#line 394
                tmp___16 = 0;
              }
            }
          } else {
#line 394
            tmp___16 = 0;
          }
        }
#line 394
        if (tmp___16) {
#line 394
          tmp___12 = __builtin_strcmp(passphrase, "");
        } else {
#line 394
          tmp___15 = __builtin_strcmp(passphrase, "");
#line 394
          tmp___12 = tmp___15;
        }
      } else {
#line 394
        tmp___15 = __builtin_strcmp(passphrase, "");
#line 394
        tmp___12 = tmp___15;
      }
#line 394
      if (tmp___12 != 0) {
#line 395
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 398
      buffer_free(& decrypted);
      goto fail;
    }
  }
#line 402
  buffer_get_bignum(& decrypted, (prv->rsa)->d);
#line 403
  buffer_get_bignum(& decrypted, (prv->rsa)->iqmp);
#line 405
  buffer_get_bignum(& decrypted, (prv->rsa)->q);
#line 406
  buffer_get_bignum(& decrypted, (prv->rsa)->p);
#line 409
  ctx = BN_CTX_new();
#line 410
  aux = BN_new();
#line 412
  tmp___19 = BN_value_one();
#line 412
  BN_sub(aux, (BIGNUM const   *)(prv->rsa)->q, tmp___19);
#line 413
  BN_div((BIGNUM *)((void *)0), (prv->rsa)->dmq1, (BIGNUM const   *)(prv->rsa)->d,
         (BIGNUM const   *)aux, ctx);
#line 415
  tmp___20 = BN_value_one();
#line 415
  BN_sub(aux, (BIGNUM const   *)(prv->rsa)->p, tmp___20);
#line 416
  BN_div((BIGNUM *)((void *)0), (prv->rsa)->dmp1, (BIGNUM const   *)(prv->rsa)->d,
         (BIGNUM const   *)aux, ctx);
#line 418
  BN_clear_free(aux);
#line 419
  BN_CTX_free(ctx);
#line 421
  buffer_free(& decrypted);
#line 422
  close(fd);
#line 423
  return (prv);
  fail: 
#line 426
  if (commentp) {
#line 427
    xfree((void *)*commentp);
  }
#line 428
  close(fd);
#line 429
  key_free(prv);
#line 430
  return ((Key *)((void *)0));
}
}
#line 433 "authfile.c"
static Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) 
{ FILE *fp ;
  EVP_PKEY *pk ;
  Key *prv ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 438
  pk = (EVP_PKEY *)((void *)0);
#line 439
  prv = (Key *)((void *)0);
#line 440
  name = (char *)"<no key>";
#line 442
  fp = fdopen(fd, "r");
#line 443
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 444
    tmp = __errno_location();
#line 444
    tmp___0 = strerror(*tmp);
#line 444
    error("fdopen failed: %s", tmp___0);
#line 445
    close(fd);
#line 446
    return ((Key *)((void *)0));
  }
#line 448
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 449
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 450
    debug("PEM_read_PrivateKey failed");
#line 451
    ERR_get_error();
  } else {
#line 452
    if (pk->type == 6) {
#line 452
      if (type == 3) {
#line 454
        prv = key_new(3);
#line 455
        prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 456
        prv->type = 1;
#line 457
        name = (char *)"rsa w/o comment";
      } else {
#line 452
        if (type == 1) {
#line 454
          prv = key_new(3);
#line 455
          prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 456
          prv->type = 1;
#line 457
          name = (char *)"rsa w/o comment";
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 461
      if (pk->type == 116) {
#line 461
        if (type == 3) {
#line 463
          prv = key_new(3);
#line 464
          prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 465
          prv->type = 2;
#line 466
          name = (char *)"dsa w/o comment";
        } else {
#line 461
          if (type == 2) {
#line 463
            prv = key_new(3);
#line 464
            prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 465
            prv->type = 2;
#line 466
            name = (char *)"dsa w/o comment";
          } else {
#line 471
            error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d",
                  pk->save_type);
          }
        }
      } else {
#line 471
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 474
  fclose(fp);
#line 475
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 476
    EVP_PKEY_free(pk);
  }
#line 477
  if ((unsigned int )prv != (unsigned int )((void *)0)) {
#line 477
    if (commentp) {
#line 478
      *commentp = xstrdup((char const   *)name);
    }
  }
#line 479
  if (prv) {
#line 479
    tmp___3 = key_type(prv);
#line 479
    tmp___2 = (char const   *)tmp___3;
  } else {
#line 479
    tmp___2 = "<unknown>";
  }
#line 479
  debug("read PEM private key done: type %s", tmp___2);
#line 481
  return (prv);
}
}
#line 484 "authfile.c"
static int key_perm_ok(int fd , char const   *filename ) 
{ struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 489
  tmp = fstat(fd, & st);
#line 489
  if (tmp < 0) {
#line 490
    return (0);
  }
#line 499
  tmp___0 = getuid();
#line 499
  if (st.st_uid == tmp___0) {
#line 499
    if ((st.st_mode & 63U) != 0U) {
#line 500
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 501
      error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 502
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 503
      error("Permissions 0%3.3o for \'%s\' are too open.", st.st_mode & 511U, filename);
#line 505
      error("It is recommended that your private key files are NOT accessible by others.");
#line 506
      error("This private key will be ignored.");
#line 507
      return (0);
    }
  }
#line 509
  return (1);
}
}
#line 512 "authfile.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp ) 
{ int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 518
  fd = open(filename, 0);
#line 519
  if (fd < 0) {
#line 520
    return ((Key *)((void *)0));
  }
#line 521
  tmp = key_perm_ok(fd, filename);
#line 521
  if (! tmp) {
#line 522
    error("bad permissions: ignore key: %s", filename);
#line 523
    close(fd);
#line 524
    return ((Key *)((void *)0));
  }
#line 526
  switch (type) {
  case 0: 
#line 528
  tmp___0 = key_load_private_rsa1(fd, filename, passphrase, commentp);
#line 528
  return (tmp___0);
#line 531
  break;
  case 2: 
  case 1: 
  case 3: 
#line 535
  tmp___1 = key_load_private_pem(fd, type, passphrase, commentp);
#line 535
  return (tmp___1);
#line 537
  break;
  default: 
#line 539
  close(fd);
#line 540
  break;
  }
#line 542
  return ((Key *)((void *)0));
}
}
#line 545 "authfile.c"
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) 
{ Key *pub ;
  Key *prv ;
  int fd ;
  int tmp ;

  {
#line 552
  fd = open(filename, 0);
#line 553
  if (fd < 0) {
#line 554
    return ((Key *)((void *)0));
  }
#line 555
  tmp = key_perm_ok(fd, filename);
#line 555
  if (! tmp) {
#line 556
    error("bad permissions: ignore key: %s", filename);
#line 557
    close(fd);
#line 558
    return ((Key *)((void *)0));
  }
#line 560
  pub = key_load_public_rsa1(fd, filename, commentp);
#line 561
  lseek(fd, 0L, 0);
#line 562
  if ((unsigned int )pub == (unsigned int )((void *)0)) {
#line 564
    prv = key_load_private_pem(fd, 3, passphrase, (char **)((void *)0));
#line 566
    if (commentp) {
#line 566
      if (prv) {
#line 567
        *commentp = xstrdup(filename);
      }
    }
  } else {
#line 570
    key_free(pub);
#line 572
    prv = key_load_private_rsa1(fd, filename, passphrase, (char **)((void *)0));
  }
#line 574
  return (prv);
}
}
#line 577 "authfile.c"
static int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ FILE *f ;
  char line[4096] ;
  char *cp ;
  int tmp ;
  char *tmp___0 ;

  {
#line 584
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 585
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 586
    while (1) {
#line 586
      tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 586
      if (! tmp___0) {
#line 586
        break;
      }
#line 587
      line[sizeof(line) - 1U] = (char )'\000';
#line 588
      cp = line;
#line 589
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 593
      continue;
      }
#line 596
      while (1) {
#line 596
        if (*cp) {
#line 596
          if (! ((int )*cp == 32)) {
#line 596
            if (! ((int )*cp == 9)) {
#line 596
              break;
            }
          }
        } else {
#line 596
          break;
        }
#line 596
        cp ++;
      }
#line 598
      if (*cp) {
#line 599
        tmp = key_read(k, & cp);
#line 599
        if (tmp == 1) {
#line 600
          if (commentp) {
#line 601
            *commentp = xstrdup(filename);
          }
#line 602
          fclose(f);
#line 603
          return (1);
        }
      }
    }
#line 607
    fclose(f);
  }
#line 609
  return (0);
}
}
#line 613 "authfile.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ Key *pub ;
  char file[4096] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 619
  pub = key_load_public_type(0, filename, commentp);
#line 620
  if ((unsigned int )pub != (unsigned int )((void *)0)) {
#line 621
    return (pub);
  }
#line 622
  pub = key_new(3);
#line 623
  tmp = key_try_load_public(pub, filename, commentp);
#line 623
  if (tmp == 1) {
#line 624
    return (pub);
  }
#line 625
  tmp___0 = strlcpy(file, filename, sizeof(file));
#line 625
  if (tmp___0 < sizeof(file)) {
#line 625
    tmp___1 = strlcat(file, ".pub", sizeof(file));
#line 625
    if (tmp___1 < sizeof(file)) {
#line 625
      tmp___2 = key_try_load_public(pub, (char const   *)(file), commentp);
#line 625
      if (tmp___2 == 1) {
#line 628
        return (pub);
      }
    }
  }
#line 629
  key_free(pub);
#line 630
  return ((Key *)((void *)0));
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 36 "buffer.h"
void buffer_get(Buffer *buffer , char *buf___2 , u_int len ) ;
#line 38
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 25 "bufaux.h"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 31
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 32
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 52 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___2 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 55
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 55
  bits = tmp;
#line 56
  bin_size = (bits + 7) / 8;
#line 57
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 57
  buf___2 = (u_char *)tmp___0;
#line 62
  oi = BN_bn2bin((BIGNUM const   *)value, buf___2);
#line 63
  if (oi != bin_size) {
#line 64
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 68
  while (1) {
#line 68
    msg[0] = (char )(bits >> 8);
#line 68
    msg[1] = (char )bits;
#line 68
    break;
  }
#line 69
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 71
  buffer_append(buffer, (char const   *)((char *)buf___2), (unsigned int )oi);
#line 73
  memset((void *)buf___2, 0, (unsigned int )bin_size);
#line 74
  xfree((void *)buf___2);
#line 75
  return;
}
}
#line 80 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  u_char buf___2[2] ;
  u_char *bin ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 87
  buffer_get(buffer, (char *)(buf___2), 2U);
#line 88
  bits = (int )(((unsigned long )buf___2[0] << 8) | (unsigned long )buf___2[1]);
#line 90
  bytes = (bits + 7) / 8;
#line 91
  tmp = buffer_len(buffer);
#line 91
  if (tmp < (u_int )bytes) {
#line 92
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 93
  tmp___0 = buffer_ptr(buffer);
#line 93
  bin = (u_char *)tmp___0;
#line 94
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 95
  buffer_consume(buffer, (unsigned int )bytes);
#line 97
  return (2 + bytes);
}
}
#line 103 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  u_char *buf___2 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  u_char *uc ;
  int tmp___1 ;

  {
#line 106
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 106
  bytes = (tmp + 7) / 8 + 1;
#line 107
  tmp___0 = xmalloc((unsigned int )bytes);
#line 107
  buf___2 = (u_char *)tmp___0;
#line 109
  hasnohigh = 0;
#line 110
  *(buf___2 + 0) = (unsigned char )'\000';
#line 112
  oi = BN_bn2bin((BIGNUM const   *)value, buf___2 + 1);
#line 113
  if (oi != bytes - 1) {
#line 114
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 116
  if ((int )*(buf___2 + 1) & 128) {
#line 116
    hasnohigh = 0;
  } else {
#line 116
    hasnohigh = 1;
  }
#line 117
  if (value->neg) {
#line 120
    uc = buf___2;
#line 121
    log("negativ!");
#line 122
    i = bytes - 1;
#line 122
    carry = 1;
#line 122
    while (i >= 0) {
#line 123
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 124
      if (carry) {
#line 125
        *(uc + i) = (u_char )((int )*(uc + i) + 1);
#line 125
        if (*(uc + i)) {
#line 125
          tmp___1 = 0;
        } else {
#line 125
          tmp___1 = 1;
        }
#line 125
        carry = tmp___1;
      }
#line 122
      i --;
    }
  }
#line 128
  buffer_put_string(buffer, (void const   *)(buf___2 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 129
  memset((void *)buf___2, 0, (unsigned int )bytes);
#line 130
  xfree((void *)buf___2);
#line 131
  return;
}
}
#line 133 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  u_char *bin ;
  char *tmp ;

  {
#line 138
  tmp = buffer_get_string(buffer, (u_int *)(& len));
#line 138
  bin = (u_char *)tmp;
#line 139
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 140
  xfree((void *)bin);
#line 141
  return (len);
}
}
#line 147 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_char buf___2[4] ;

  {
#line 151
  buffer_get(buffer, (char *)(buf___2), 4U);
#line 152
  return ((unsigned int )(((((unsigned long )buf___2[0] << 24) | ((unsigned long )buf___2[1] << 16)) | ((unsigned long )buf___2[2] << 8)) | (unsigned long )buf___2[3]));
}
}
#line 156 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_char buf___2[8] ;

  {
#line 160
  buffer_get(buffer, (char *)(buf___2), 8U);
#line 161
  return (((((((((unsigned long long )buf___2[0] << 56) | ((unsigned long long )buf___2[1] << 48)) | ((unsigned long long )buf___2[2] << 40)) | ((unsigned long long )buf___2[3] << 32)) | ((unsigned long long )buf___2[4] << 24)) | ((unsigned long long )buf___2[5] << 16)) | ((unsigned long long )buf___2[6] << 8)) | (unsigned long long )buf___2[7]);
}
}
#line 168 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___2[4] ;

  {
#line 172
  while (1) {
#line 172
    buf___2[0] = (char )(value >> 24);
#line 172
    buf___2[1] = (char )(value >> 16);
#line 172
    buf___2[2] = (char )(value >> 8);
#line 172
    buf___2[3] = (char )value;
#line 172
    break;
  }
#line 173
  buffer_append(buffer, (char const   *)(buf___2), 4U);
#line 174
  return;
}
}
#line 177 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___2[8] ;

  {
#line 181
  while (1) {
#line 181
    buf___2[0] = (char )(value >> 56);
#line 181
    buf___2[1] = (char )(value >> 48);
#line 181
    buf___2[2] = (char )(value >> 40);
#line 181
    buf___2[3] = (char )(value >> 32);
#line 181
    buf___2[4] = (char )(value >> 24);
#line 181
    buf___2[5] = (char )(value >> 16);
#line 181
    buf___2[6] = (char )(value >> 8);
#line 181
    buf___2[7] = (char )value;
#line 181
    break;
  }
#line 182
  buffer_append(buffer, (char const   *)(buf___2), 8U);
#line 183
  return;
}
}
#line 194 "bufaux.c"
char *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ u_int len ;
  char *value ;
  void *tmp ;

  {
#line 200
  len = buffer_get_int(buffer);
#line 201
  if (len > 262144U) {
#line 202
    fatal("Received packet with bad string length %d", len);
  }
#line 204
  tmp = xmalloc(len + 1U);
#line 204
  value = (char *)tmp;
#line 206
  buffer_get(buffer, value, len);
#line 208
  *(value + len) = (char)0;
#line 210
  if (length_ptr) {
#line 211
    *length_ptr = len;
  }
#line 212
  return (value);
}
}
#line 218 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___2 , u_int len ) 
{ 

  {
#line 221
  buffer_put_int(buffer, len);
#line 222
  buffer_append(buffer, (char const   *)buf___2, len);
#line 223
  return;
}
}
#line 224 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 227
  tmp = strlen(s);
#line 227
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 228
  return;
}
}
#line 233 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 237
  buffer_get(buffer, & ch, 1U);
#line 238
  return ((int )((unsigned char )ch));
}
}
#line 244 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 247
  ch = (char )value;
#line 248
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 249
  return;
}
}
#line 1 "buffer.o"
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 23 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 39 "buffer.h"
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 41
void buffer_dump(Buffer *buffer ) ;
#line 23 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 26
  buffer->alloc = 4096U;
#line 27
  tmp = xmalloc(buffer->alloc);
#line 27
  buffer->buf = (char *)tmp;
#line 28
  buffer->offset = 0U;
#line 29
  buffer->end = 0U;
#line 30
  return;
}
}
#line 34 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 37
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 38
  xfree((void *)buffer->buf);
#line 39
  return;
}
}
#line 46 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 49
  buffer->offset = 0U;
#line 50
  buffer->end = 0U;
#line 51
  return;
}
}
#line 55 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , u_int len ) 
{ char *cp ;

  {
#line 59
  buffer_append_space(buffer, & cp, len);
#line 60
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 61
  return;
}
}
#line 69 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , u_int len ) 
{ void *tmp ;

  {
#line 73
  if (buffer->offset == buffer->end) {
#line 74
    buffer->offset = 0U;
#line 75
    buffer->end = 0U;
  }
  restart: 
#line 79
  if (buffer->end + len < buffer->alloc) {
#line 80
    *datap = buffer->buf + buffer->end;
#line 81
    buffer->end += len;
#line 82
    return;
  }
#line 88
  if (buffer->offset > buffer->alloc / 2U) {
#line 89
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 91
    buffer->end -= buffer->offset;
#line 92
    buffer->offset = 0U;
    goto restart;
  }
#line 96
  buffer->alloc += len + 32768U;
#line 97
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 97
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 103 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 106
  return (buffer->end - buffer->offset);
}
}
#line 111 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___2 , u_int len ) 
{ 

  {
#line 114
  if (len > buffer->end - buffer->offset) {
#line 115
    fatal("buffer_get: trying to get more bytes %d than in buffer %d", len, buffer->end - buffer->offset);
  }
#line 117
  memcpy((void * __restrict  )buf___2, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 118
  buffer->offset += len;
#line 119
  return;
}
}
#line 123 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 126
  if (bytes > buffer->end - buffer->offset) {
#line 127
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 128
  buffer->offset += bytes;
#line 129
  return;
}
}
#line 133 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 136
  if (bytes > buffer->end - buffer->offset) {
#line 137
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 138
  buffer->end -= bytes;
#line 139
  return;
}
}
#line 143 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 146
  return (buffer->buf + buffer->offset);
}
}
#line 151 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  u_char *ucp ;

  {
#line 155
  ucp = (u_char *)buffer->buf;
#line 157
  i = (int )buffer->offset;
#line 157
  while ((u_int )i < buffer->end) {
#line 158
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(ucp + i));
#line 159
    if (((u_int )i - buffer->offset) % 16U == 15U) {
#line 160
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
    } else {
#line 161
      if (((u_int )i - buffer->offset) % 2U == 1U) {
#line 162
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
      }
    }
#line 157
    i ++;
  }
#line 164
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
#line 165
  return;
}
}
#line 1 "canohost.o"
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 23 "packet.h"
int packet_get_connection_in(void) ;
#line 54
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 62
int packet_connection_is_on_socket(void) ;
#line 62 "log.h"
void fatal_cleanup(void) ;
#line 15 "canohost.h"
char const   *get_canonical_hostname(int reverse_mapping_check ) ;
#line 16
char const   *get_remote_ipaddr(void) ;
#line 17
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int reverse_mapping_check ) ;
#line 19
char *get_peer_ipaddr(int socket___0 ) ;
#line 20
int get_peer_port(int sock ) ;
#line 21
char *get_local_ipaddr(int socket___0 ) ;
#line 22
char *get_local_name(int socket___0 ) ;
#line 24
int get_remote_port(void) ;
#line 25
int get_local_port(void) ;
#line 22 "canohost.c"
static void check_ip_options(int socket___0 , char *ipaddr ) ;
#line 29 "canohost.c"
static char *get_remote_hostname(int socket___0 , int reverse_mapping_check ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int __res ;
  __int32_t const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 46
  if ((int )from.ss_family == 10) {
#line 47
    from6 = (struct sockaddr_in6 *)(& from);
#line 51
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 51
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 51
        __x = 65535U;
#line 51
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 51
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 52
          from4 = (struct sockaddr_in *)(& from);
#line 56
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 57
          port = from6->sin6_port;
#line 59
          memset((void *)(& from), 0, sizeof(from));
#line 61
          from4->sin_family = (unsigned short)2;
#line 62
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 63
          from4->sin_port = port;
        }
      }
    }
  }
#line 67
  if ((int )from.ss_family == 2) {
#line 68
    check_ip_options(socket___0, ntop);
  }
#line 70
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 70
  if (tmp___2 != 0) {
#line 72
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  debug3("Trying to reverse map address %.100s.", ntop);
#line 76
  tmp___4 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 76
  if (tmp___4 != 0) {
#line 79
    log("Could not reverse map address %.100s.", ntop);
#line 80
    tmp___3 = xstrdup((char const   *)(ntop));
#line 80
    return (tmp___3);
  }
#line 84
  name[sizeof(name) - 1U] = (char )'\000';
#line 89
  i = 0;
#line 89
  while (name[i]) {
#line 90
    tmp___8 = __ctype_b_loc();
#line 90
    if ((int const   )*(*tmp___8 + (int )name[i]) & 256) {
#line 91
      if (sizeof(name[i]) > 1U) {
#line 91
        __res = tolower((int )name[i]);
      } else {
#line 91
        tmp___7 = __ctype_tolower_loc();
#line 91
        __res = (int )*(*tmp___7 + (int )name[i]);
      }
#line 91
      name[i] = (char )__res;
    }
#line 89
    i ++;
  }
#line 93
  if (! reverse_mapping_check) {
#line 94
    tmp___9 = xstrdup((char const   *)(name));
#line 94
    return (tmp___9);
  }
#line 104
  memset((void *)(& hints), 0, sizeof(hints));
#line 105
  hints.ai_family = (int )from.ss_family;
#line 106
  hints.ai_socktype = 1;
#line 107
  tmp___11 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 107
  if (tmp___11 != 0) {
#line 108
    log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
        name);
#line 110
    tmp___10 = xstrdup((char const   *)(ntop));
#line 110
    return (tmp___10);
  }
#line 113
  ai = aitop;
#line 113
  while (ai) {
#line 114
    tmp___12 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 116
    if (tmp___12 == 0) {
#line 116
      if (0) {
#line 116
        __s1_len = strlen((char const   *)(ntop));
#line 116
        __s2_len = strlen((char const   *)(ntop2));
#line 116
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 116
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 116
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 116
              tmp___22 = 1;
            } else {
#line 116
              if (__s2_len >= 4U) {
#line 116
                tmp___22 = 1;
              } else {
#line 116
                tmp___22 = 0;
              }
            }
          } else {
#line 116
            tmp___22 = 0;
          }
        }
#line 116
        if (tmp___22) {
#line 116
          tmp___18 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 116
          tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 116
          tmp___18 = tmp___21;
        }
      } else {
#line 116
        tmp___21 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 116
        tmp___18 = tmp___21;
      }
#line 116
      if (tmp___18 == 0) {
#line 117
        break;
      }
    }
#line 113
    ai = ai->ai_next;
  }
#line 119
  freeaddrinfo(aitop);
#line 121
  if (! ai) {
#line 123
    log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
        ntop, name);
#line 126
    tmp___23 = xstrdup((char const   *)(ntop));
#line 126
    return (tmp___23);
  }
#line 128
  tmp___24 = xstrdup((char const   *)(name));
#line 128
  return (tmp___24);
}
}
#line 143 "canohost.c"
static void check_ip_options(int socket___0 , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 152
  ip = getprotobyname("ip");
#line 152
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 153
    ipproto = ip->p_proto;
  } else {
#line 155
    ipproto = 0;
  }
#line 156
  option_size = sizeof(options___0);
#line 157
  tmp = getsockopt(socket___0, ipproto, 4, (void * __restrict  )((void *)(options___0)),
                   (socklen_t * __restrict  )(& option_size));
#line 157
  if (tmp >= 0) {
#line 157
    if (option_size != 0U) {
#line 159
      text[0] = (char )'\000';
#line 160
      i = 0;
#line 160
      while ((socklen_t )i < option_size) {
#line 161
        snprintf((char * __restrict  )(text + i * 3), sizeof(text) - (unsigned int )(i * 3),
                 (char const   * __restrict  )" %2.2x", options___0[i]);
#line 160
        i ++;
      }
#line 163
      log("Connection from %.100s with IP options:%.800s", ipaddr, text);
#line 165
      packet_disconnect("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 168
  return;
}
}
#line 179 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 180 "canohost.c"
static int reverse_mapping_checked  =    0;
#line 176 "canohost.c"
char const   *get_canonical_hostname(int reverse_mapping_check ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 183
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 184
    if (reverse_mapping_checked != reverse_mapping_check) {
#line 185
      xfree((void *)canonical_host_name);
    } else {
#line 187
      return ((char const   *)canonical_host_name);
    }
  }
#line 191
  tmp___0 = packet_connection_is_on_socket();
#line 191
  if (tmp___0) {
#line 192
    tmp = packet_get_connection_in();
#line 192
    canonical_host_name = get_remote_hostname(tmp, reverse_mapping_check);
  } else {
#line 195
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 197
  reverse_mapping_checked = reverse_mapping_check;
#line 198
  return ((char const   *)canonical_host_name);
}
}
#line 205 "canohost.c"
static char *get_socket_address(int socket___0 , int remote___0 , int flags ) 
{ struct sockaddr_storage addr ;
  socklen_t addrlen ;
  char ntop[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 213
  addrlen = sizeof(addr);
#line 214
  memset((void *)(& addr), 0, sizeof(addr));
#line 216
  if (remote___0) {
#line 217
    tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 217
    if (tmp___1 < 0) {
#line 219
      tmp = __errno_location();
#line 219
      tmp___0 = strerror(*tmp);
#line 219
      debug("get_socket_ipaddr: getpeername failed: %.100s", tmp___0);
#line 221
      return ((char *)((void *)0));
    }
  } else {
#line 224
    tmp___4 = getsockname(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 224
    if (tmp___4 < 0) {
#line 226
      tmp___2 = __errno_location();
#line 226
      tmp___3 = strerror(*tmp___2);
#line 226
      debug("get_socket_ipaddr: getsockname failed: %.100s", tmp___3);
#line 228
      return ((char *)((void *)0));
    }
  }
#line 232
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                        addrlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, (unsigned int )flags);
#line 232
  if (tmp___5 != 0) {
#line 234
    error("get_socket_ipaddr: getnameinfo %d failed", flags);
#line 235
    return ((char *)((void *)0));
  }
#line 237
  tmp___6 = xstrdup((char const   *)(ntop));
#line 237
  return (tmp___6);
}
}
#line 240 "canohost.c"
char *get_peer_ipaddr(int socket___0 ) 
{ char *tmp ;

  {
#line 243
  tmp = get_socket_address(socket___0, 1, 1);
#line 243
  return (tmp);
}
}
#line 246 "canohost.c"
char *get_local_ipaddr(int socket___0 ) 
{ char *tmp ;

  {
#line 249
  tmp = get_socket_address(socket___0, 0, 1);
#line 249
  return (tmp);
}
}
#line 252 "canohost.c"
char *get_local_name(int socket___0 ) 
{ char *tmp ;

  {
#line 255
  tmp = get_socket_address(socket___0, 0, 8);
#line 255
  return (tmp);
}
}
#line 266 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 263 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 269
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 270
    tmp___0 = packet_connection_is_on_socket();
#line 270
    if (tmp___0) {
#line 271
      tmp = packet_get_connection_in();
#line 271
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 273
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 274
        fatal_cleanup();
      }
    } else {
#line 277
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 280
  return ((char const   *)canonical_host_ip);
}
}
#line 286 "canohost.c"
static char const   *remote  =    "";
#line 283 "canohost.c"
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int reverse_mapping_check ) 
{ size_t tmp ;

  {
#line 287
  if (utmp_len___0 > 0U) {
#line 288
    remote = get_canonical_hostname(reverse_mapping_check);
  }
#line 289
  if (utmp_len___0 == 0U) {
#line 290
    remote = get_remote_ipaddr();
  } else {
#line 289
    tmp = strlen(remote);
#line 289
    if (tmp > utmp_len___0) {
#line 290
      remote = get_remote_ipaddr();
    }
  }
#line 291
  return (remote);
}
}
#line 296 "canohost.c"
static int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 304
  fromlen = sizeof(from);
#line 305
  memset((void *)(& from), 0, sizeof(from));
#line 306
  if (local) {
#line 307
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 307
    if (tmp___1 < 0) {
#line 308
      tmp = __errno_location();
#line 308
      tmp___0 = strerror(*tmp);
#line 308
      error("getsockname failed: %.100s", tmp___0);
#line 309
      return (0);
    }
  } else {
#line 312
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 312
    if (tmp___4 < 0) {
#line 313
      tmp___2 = __errno_location();
#line 313
      tmp___3 = strerror(*tmp___2);
#line 313
      debug("getpeername failed: %.100s", tmp___3);
#line 314
      fatal_cleanup();
    }
  }
#line 318
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 318
  if (tmp___5 != 0) {
#line 320
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 321
  tmp___6 = atoi((char const   *)(strport));
#line 321
  return (tmp___6);
}
}
#line 326 "canohost.c"
static int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 333
  tmp = packet_connection_is_on_socket();
#line 333
  if (! tmp) {
#line 334
    return (65535);
  }
#line 337
  tmp___0 = packet_get_connection_in();
#line 337
  tmp___1 = get_sock_port(tmp___0, local);
#line 337
  return (tmp___1);
}
}
#line 340 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 343
  tmp = get_sock_port(sock, 0);
#line 343
  return (tmp);
}
}
#line 346 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 349
  tmp = get_port(0);
#line 349
  return (tmp);
}
}
#line 352 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 355
  tmp = get_port(1);
#line 355
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 745
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 407 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 28 "packet.h"
u_int packet_get_protocol_flags(void) ;
#line 31
int packet_is_interactive(void) ;
#line 33
void packet_start(u_char type ) ;
#line 34
void packet_put_char(int value ) ;
#line 35
void packet_put_int(u_int value ) ;
#line 38
void packet_put_string(char const   *buf___2 , u_int len ) ;
#line 39
void packet_put_cstring(char const   *str ) ;
#line 41
void packet_send(void) ;
#line 43
int packet_read(int *payload_len_ptr ) ;
#line 49
u_int packet_get_int(void) ;
#line 53
char *packet_get_string(u_int *length_ptr ) ;
#line 55
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 58
void packet_write_wait(void) ;
#line 64
int packet_remaining(void) ;
#line 65
void packet_send_ignore(int nbytes ) ;
#line 71
int max_packet_size ;
#line 18 "uidswap.h"
void temporarily_use_uid(struct passwd *pw ) ;
#line 19
void restore_uid(void) ;
#line 57 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 59
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 63
void fatal_add_cleanup(void (*proc)(void * ) , void *context ) ;
#line 64
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 17 "misc.h"
void set_nonblock(int fd ) ;
#line 141 "channels.h"
Channel *channel_lookup(int id ) ;
#line 142
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                     int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 143
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) ;
#line 144
void channel_free(Channel *c ) ;
#line 145
void channel_free_all(void) ;
#line 146
void channel_detach_all(void) ;
#line 147
void channel_stop_listening(void) ;
#line 149
void channel_send_open(int id ) ;
#line 150
void channel_request(int id , char *service , int wantconfirm ) ;
#line 151
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 152
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 153
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 154
void channel_register_filter(int id , channel_filter_fn *fn ) ;
#line 155
void channel_cancel_cleanup(int id ) ;
#line 156
int channel_close_fd(int *fdp ) ;
#line 160
void channel_input_channel_request(int type , int plen , void *ctxt ) ;
#line 161
void channel_input_close(int type , int plen , void *ctxt ) ;
#line 162
void channel_input_close_confirmation(int type , int plen , void *ctxt ) ;
#line 163
void channel_input_data(int type , int plen , void *ctxt ) ;
#line 164
void channel_input_extended_data(int type , int plen , void *ctxt ) ;
#line 165
void channel_input_ieof(int type , int plen , void *ctxt ) ;
#line 166
void channel_input_oclose(int type , int plen , void *ctxt ) ;
#line 167
void channel_input_open_confirmation(int type , int plen , void *ctxt ) ;
#line 168
void channel_input_open_failure(int type , int plen , void *ctxt ) ;
#line 169
void channel_input_port_open(int type , int plen , void *ctxt ) ;
#line 170
void channel_input_window_adjust(int type , int plen , void *ctxt ) ;
#line 174
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int *nallocp , int rekeying ) ;
#line 175
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 176
void channel_output_poll(void) ;
#line 178
int channel_not_very_much_buffered_data(void) ;
#line 179
void channel_close_all(void) ;
#line 181
int channel_still_open(void) ;
#line 182
char *channel_open_message(void) ;
#line 183
int channel_find_open(void) ;
#line 186
void channel_permit_all_opens(void) ;
#line 187
void channel_add_permitted_opens(char *host , int port ) ;
#line 188
void channel_clear_permitted_opens(void) ;
#line 189
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 190
int channel_connect_to(char const   *host , u_short port ) ;
#line 191
int channel_connect_by_listen_address(u_short listen_port ) ;
#line 192
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 193
int channel_request_local_forwarding(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) ;
#line 194
int channel_request_forwarding(char const   *listen_address , u_short listen_port ,
                               char const   *host_to_connect , u_short port_to_connect ,
                               int gateway_ports , int remote_fwd ) ;
#line 200
int x11_connect_display(void) ;
#line 202
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 203
void x11_input_open(int type , int plen , void *ctxt ) ;
#line 205
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 206
void deny_input_open(int type , int plen , void *ctxt ) ;
#line 210
void auth_request_forwarding(void) ;
#line 211
char *auth_get_socket_name(void) ;
#line 212
void auth_sock_cleanup_proc(void *_pw ) ;
#line 213
int auth_input_request_forwarding(struct passwd *pw ) ;
#line 214
void auth_input_open_request(int type , int plen , void *ctxt ) ;
#line 218
int chan_is_dead(Channel *c ) ;
#line 219
void chan_mark_dead(Channel *c ) ;
#line 220
void chan_init_iostates(Channel *c ) ;
#line 221
void chan_init(void) ;
#line 226
chan_event_fn *chan_rcvd_oclose ;
#line 227
chan_event_fn *chan_read_failed ;
#line 228
chan_event_fn *chan_ibuf_empty ;
#line 231
chan_event_fn *chan_rcvd_ieof ;
#line 232
chan_event_fn *chan_write_failed ;
#line 233
chan_event_fn *chan_obuf_empty ;
#line 61 "compat.h"
int compat13 ;
#line 62
int compat20 ;
#line 65 "channels.c"
static Channel **channels  =    (Channel **)((void *)0);
#line 71 "channels.c"
static int channels_alloc  =    0;
#line 77 "channels.c"
static int channel_max_fd  =    0;
#line 95 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 98 "channels.c"
static int num_permitted_opens  =    0;
#line 104 "channels.c"
static int all_opens_permitted  =    0;
#line 113 "channels.c"
static char *x11_saved_proto  =    (char *)((void *)0);
#line 116 "channels.c"
static char *x11_saved_data  =    (char *)((void *)0);
#line 117 "channels.c"
static u_int x11_saved_data_len  =    (u_int )0;
#line 123 "channels.c"
static char *x11_fake_data  =    (char *)((void *)0);
#line 124 "channels.c"
static u_int x11_fake_data_len  ;
#line 132 "channels.c"
static char *auth_sock_name  =    (char *)((void *)0);
#line 133 "channels.c"
static char *auth_sock_dir  =    (char *)((void *)0);
#line 136
int IPv4or6 ;
#line 139
static void port_open_helper(Channel *c , char *rtype ) ;
#line 143 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 148
  if (id < 0) {
#line 149
    log("channel_lookup: %d: bad id", id);
#line 150
    return ((Channel *)((void *)0));
  } else {
#line 148
    if (id > channels_alloc) {
#line 149
      log("channel_lookup: %d: bad id", id);
#line 150
      return ((Channel *)((void *)0));
    }
  }
#line 152
  c = *(channels + id);
#line 153
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 154
    log("channel_lookup: %d: bad id: channel free", id);
#line 155
    return ((Channel *)((void *)0));
  }
#line 157
  return (c);
}
}
#line 165 "channels.c"
static void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                                 int nonblock ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 170
  if (channel_max_fd > rfd) {
#line 170
    channel_max_fd = channel_max_fd;
  } else {
#line 170
    channel_max_fd = rfd;
  }
#line 171
  if (channel_max_fd > wfd) {
#line 171
    channel_max_fd = channel_max_fd;
  } else {
#line 171
    channel_max_fd = wfd;
  }
#line 172
  if (channel_max_fd > efd) {
#line 172
    channel_max_fd = channel_max_fd;
  } else {
#line 172
    channel_max_fd = efd;
  }
#line 176
  c->rfd = rfd;
#line 177
  c->wfd = wfd;
#line 178
  if (rfd == wfd) {
#line 178
    c->sock = rfd;
  } else {
#line 178
    c->sock = -1;
  }
#line 179
  c->efd = efd;
#line 180
  c->extended_usage = extusage;
#line 183
  if (nonblock) {
#line 183
    tmp___0 = isatty(c->rfd);
#line 183
    if (tmp___0) {
#line 184
      debug("channel %d: rfd %d isatty", c->self, c->rfd);
#line 185
      c->isatty = 1;
#line 186
      tmp = isatty(c->wfd);
#line 186
      if (! tmp) {
#line 187
        error("channel %d: wfd %d is not a tty?", c->self, c->wfd);
      }
    } else {
#line 191
      c->isatty = 0;
    }
  } else {
#line 191
    c->isatty = 0;
  }
#line 195
  if (nonblock) {
#line 196
    if (rfd != -1) {
#line 197
      set_nonblock(rfd);
    }
#line 198
    if (wfd != -1) {
#line 199
      set_nonblock(wfd);
    }
#line 200
    if (efd != -1) {
#line 201
      set_nonblock(efd);
    }
  }
#line 203
  return;
}
}
#line 210 "channels.c"
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                     int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 218
  if (channels_alloc == 0) {
#line 219
    chan_init();
#line 220
    channels_alloc = 10;
#line 221
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel *));
#line 221
    channels = (Channel **)tmp;
#line 222
    i = 0;
#line 222
    while (i < channels_alloc) {
#line 223
      *(channels + i) = (Channel *)((void *)0);
#line 222
      i ++;
    }
#line 224
    fatal_add_cleanup((void (*)(void * ))(& channel_free_all), (void *)0);
  }
#line 227
  found = -1;
#line 227
  i = 0;
#line 227
  while (i < channels_alloc) {
#line 228
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
#line 230
      found = i;
#line 231
      break;
    }
#line 227
    i ++;
  }
#line 233
  if (found == -1) {
#line 235
    found = channels_alloc;
#line 236
    channels_alloc += 10;
#line 237
    debug2("channel: expanding %d", channels_alloc);
#line 238
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel *));
#line 238
    channels = (Channel **)tmp___0;
#line 239
    i = found;
#line 239
    while (i < channels_alloc) {
#line 240
      *(channels + i) = (Channel *)((void *)0);
#line 239
      i ++;
    }
  }
#line 243
  tmp___1 = xmalloc(sizeof(Channel ));
#line 243
  *(channels + found) = (Channel *)tmp___1;
#line 243
  c = *(channels + found);
#line 244
  buffer_init(& c->input);
#line 245
  buffer_init(& c->output);
#line 246
  buffer_init(& c->extended);
#line 247
  chan_init_iostates(c);
#line 248
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 249
  c->self = found;
#line 250
  c->type = type;
#line 251
  c->ctype = ctype;
#line 252
  c->local_window = window;
#line 253
  c->local_window_max = window;
#line 254
  c->local_consumed = 0;
#line 255
  c->local_maxpacket = maxpack;
#line 256
  c->remote_id = -1;
#line 257
  c->remote_name = remote_name;
#line 258
  c->remote_window = 0;
#line 259
  c->remote_maxpacket = 0;
#line 260
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 261
  c->cb_arg = (void *)0;
#line 262
  c->cb_event = 0;
#line 263
  c->force_drain = 0;
#line 264
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 265
  c->input_filter = (channel_filter_fn *)((void *)0);
#line 266
  debug("channel %d: new [%s]", found, remote_name);
#line 267
  return (c);
}
}
#line 270 "channels.c"
static int channel_find_maxfd(void) 
{ int i ;
  int max ;
  Channel *c ;

  {
#line 273
  max = 0;
#line 276
  i = 0;
#line 276
  while (i < channels_alloc) {
#line 277
    c = *(channels + i);
#line 278
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 279
      if (max > c->rfd) {
#line 279
        max = max;
      } else {
#line 279
        max = c->rfd;
      }
#line 280
      if (max > c->wfd) {
#line 280
        max = max;
      } else {
#line 280
        max = c->wfd;
      }
#line 281
      if (max > c->efd) {
#line 281
        max = max;
      } else {
#line 281
        max = c->efd;
      }
    }
#line 276
    i ++;
  }
#line 284
  return (max);
}
}
#line 287 "channels.c"
int channel_close_fd(int *fdp ) 
{ int ret ;
  int fd ;

  {
#line 290
  ret = 0;
#line 290
  fd = *fdp;
#line 292
  if (fd != -1) {
#line 293
    ret = close(fd);
#line 294
    *fdp = -1;
#line 295
    if (fd == channel_max_fd) {
#line 296
      channel_max_fd = channel_find_maxfd();
    }
  }
#line 298
  return (ret);
}
}
#line 303 "channels.c"
static void channel_close_fds(Channel *c ) 
{ 

  {
#line 306
  debug3("channel_close_fds: channel %d: r %d w %d e %d", c->self, c->rfd, c->wfd,
         c->efd);
#line 309
  channel_close_fd(& c->sock);
#line 310
  channel_close_fd(& c->rfd);
#line 311
  channel_close_fd(& c->wfd);
#line 312
  channel_close_fd(& c->efd);
#line 313
  return;
}
}
#line 317 "channels.c"
void channel_free(Channel *c ) 
{ char *s ;
  int i ;
  int n___0 ;
  char const   *tmp ;

  {
#line 323
  n___0 = 0;
#line 323
  i = 0;
#line 323
  while (i < channels_alloc) {
#line 324
    if (*(channels + i)) {
#line 325
      n___0 ++;
    }
#line 323
    i ++;
  }
#line 326
  if (c->remote_name) {
#line 326
    tmp = (char const   *)c->remote_name;
  } else {
#line 326
    tmp = "???";
  }
#line 326
  debug("channel_free: channel %d: %s, nchannels %d", c->self, tmp, n___0);
#line 329
  s = channel_open_message();
#line 330
  debug3("channel_free: status: %s", s);
#line 331
  xfree((void *)s);
#line 333
  if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 334
    debug("channel_free: channel %d: detaching channel user", c->self);
#line 335
    (*(c->detach_user))(c->self, (void *)0);
  }
#line 337
  if (c->sock != -1) {
#line 338
    shutdown(c->sock, 2);
  }
#line 339
  channel_close_fds(c);
#line 340
  buffer_free(& c->input);
#line 341
  buffer_free(& c->output);
#line 342
  buffer_free(& c->extended);
#line 343
  if (c->remote_name) {
#line 344
    xfree((void *)c->remote_name);
#line 345
    c->remote_name = (char *)((void *)0);
  }
#line 347
  *(channels + c->self) = (Channel *)((void *)0);
#line 348
  xfree((void *)c);
#line 349
  return;
}
}
#line 351 "channels.c"
void channel_free_all(void) 
{ int i ;

  {
#line 356
  i = 0;
#line 356
  while (i < channels_alloc) {
#line 357
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 358
      channel_free(*(channels + i));
    }
#line 356
    i ++;
  }
#line 359
  return;
}
}
#line 361 "channels.c"
void channel_detach_all(void) 
{ int i ;
  Channel *c ;

  {
#line 367
  i = 0;
#line 367
  while (i < channels_alloc) {
#line 368
    c = *(channels + i);
#line 369
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 369
      if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 370
        debug("channel_detach_all: channel %d", c->self);
#line 371
        (*(c->detach_user))(c->self, (void *)0);
#line 372
        c->detach_user = (channel_callback_fn *)((void *)0);
      }
    }
#line 367
    i ++;
  }
#line 375
  return;
}
}
#line 382 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 387
  i = 0;
#line 387
  while (i < channels_alloc) {
#line 388
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 389
      channel_close_fds(*(channels + i));
    }
#line 387
    i ++;
  }
#line 390
  return;
}
}
#line 396 "channels.c"
void channel_stop_listening(void) 
{ int i ;
  Channel *c ;

  {
#line 402
  i = 0;
#line 402
  while (i < channels_alloc) {
#line 403
    c = *(channels + i);
#line 404
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 405
      switch (c->type) {
      case 6: 
      case 2: 
      case 11: 
      case 1: 
#line 410
      channel_close_fd(& c->sock);
#line 411
      channel_free(c);
#line 412
      break;
      }
    }
#line 402
    i ++;
  }
#line 416
  return;
}
}
#line 423 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 429
  i = 0U;
#line 429
  while (i < (u_int )channels_alloc) {
#line 430
    c = *(channels + i);
#line 431
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 431
      if (c->type == 4) {
#line 432
        if (! compat20) {
#line 432
          tmp___0 = buffer_len(& c->input);
#line 432
          if (tmp___0 > (u_int )max_packet_size) {
#line 433
            tmp = buffer_len(& c->input);
#line 433
            debug("channel %d: big input buffer %d", c->self, tmp);
#line 435
            return (0);
          }
        }
#line 437
        tmp___2 = buffer_len(& c->output);
#line 437
        if (tmp___2 > (u_int )max_packet_size) {
#line 438
          tmp___1 = buffer_len(& c->output);
#line 438
          debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 440
          return (0);
        }
      }
    }
#line 429
    i ++;
  }
#line 444
  return (1);
}
}
#line 449 "channels.c"
int channel_still_open(void) 
{ int i ;
  Channel *c ;

  {
#line 455
  i = 0;
#line 455
  while (i < channels_alloc) {
#line 456
    c = *(channels + i);
#line 457
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 459
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 13: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
#line 470
    if (! compat20) {
#line 471
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 476
    return (1);
    case 8: 
    case 9: 
#line 479
    if (! compat13) {
#line 480
      fatal("cannot happen: OUT_DRAIN");
    }
#line 481
    return (1);
    default: 
#line 483
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 455
    i ++;
  }
#line 487
  return (0);
}
}
#line 492 "channels.c"
int channel_find_open(void) 
{ int i ;
  Channel *c ;

  {
#line 498
  i = 0;
#line 498
  while (i < channels_alloc) {
#line 499
    c = *(channels + i);
#line 500
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 502
    switch (c->type) {
    case 5: 
    case 13: 
    case 1: 
    case 2: 
    case 11: 
    case 3: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
    case 6: 
    case 4: 
    case 7: 
#line 516
    return (i);
    case 8: 
    case 9: 
#line 519
    if (! compat13) {
#line 520
      fatal("cannot happen: OUT_DRAIN");
    }
#line 521
    return (i);
    default: 
#line 523
    fatal("channel_find_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 498
    i ++;
  }
#line 527
  return (-1);
}
}
#line 537 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  Channel *c ;
  char buf___2[1024] ;
  char *cp ;
  int i ;
  size_t tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 545
  buffer_init(& buffer);
#line 546
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"The following connections are open:\r\n");
#line 547
  tmp = strlen((char const   *)(buf___2));
#line 547
  buffer_append(& buffer, (char const   *)(buf___2), tmp);
#line 548
  i = 0;
#line 548
  while (i < channels_alloc) {
#line 549
    c = *(channels + i);
#line 550
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 552
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 14: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 13: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 568
    tmp___0 = buffer_len(& c->output);
#line 568
    tmp___1 = buffer_len(& c->input);
#line 568
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 574
    tmp___2 = strlen((char const   *)(buf___2));
#line 574
    buffer_append(& buffer, (char const   *)(buf___2), tmp___2);
    goto __Cont;
    default: 
#line 577
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 548
    i ++;
  }
#line 581
  buffer_append(& buffer, "\000", 1U);
#line 582
  tmp___3 = buffer_ptr(& buffer);
#line 582
  cp = xstrdup((char const   *)tmp___3);
#line 583
  buffer_free(& buffer);
#line 584
  return (cp);
}
}
#line 587 "channels.c"
void channel_send_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 590
  tmp = channel_lookup(id);
#line 590
  c = tmp;
#line 591
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 592
    log("channel_send_open: %d: bad id", id);
#line 593
    return;
  }
#line 595
  debug("send channel open %d", id);
#line 596
  packet_start((unsigned char)90);
#line 597
  packet_put_cstring((char const   *)c->ctype);
#line 598
  packet_put_int((unsigned int )c->self);
#line 599
  packet_put_int((unsigned int )c->local_window);
#line 600
  packet_put_int((unsigned int )c->local_maxpacket);
#line 601
  packet_send();
#line 602
  return;
}
}
#line 604 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 607
  channel_request_start(id, service, wantconfirm);
#line 608
  packet_send();
#line 609
  debug("channel request %d: %s", id, service);
#line 610
  return;
}
}
#line 611 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 614
  tmp = channel_lookup(id);
#line 614
  c = tmp;
#line 615
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 616
    log("channel_request: %d: bad id", id);
#line 617
    return;
  }
#line 619
  packet_start((unsigned char)98);
#line 620
  packet_put_int((unsigned int )c->remote_id);
#line 621
  packet_put_cstring((char const   *)service);
#line 622
  packet_put_char(wantconfirm);
#line 623
  return;
}
}
#line 624 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 627
  tmp = channel_lookup(id);
#line 627
  c = tmp;
#line 628
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 629
    log("channel_register_callback: %d: bad id", id);
#line 630
    return;
  }
#line 632
  c->cb_event = mtype;
#line 633
  c->cb_fn = fn;
#line 634
  c->cb_arg = arg;
#line 635
  return;
}
}
#line 636 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 639
  tmp = channel_lookup(id);
#line 639
  c = tmp;
#line 640
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 641
    log("channel_register_cleanup: %d: bad id", id);
#line 642
    return;
  }
#line 644
  c->detach_user = fn;
#line 645
  return;
}
}
#line 646 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 649
  tmp = channel_lookup(id);
#line 649
  c = tmp;
#line 650
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 651
    log("channel_cancel_cleanup: %d: bad id", id);
#line 652
    return;
  }
#line 654
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 655
  return;
}
}
#line 656 "channels.c"
void channel_register_filter(int id , channel_filter_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 659
  tmp = channel_lookup(id);
#line 659
  c = tmp;
#line 660
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 661
    log("channel_register_filter: %d: bad id", id);
#line 662
    return;
  }
#line 664
  c->input_filter = fn;
#line 665
  return;
}
}
#line 667 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 671
  tmp = channel_lookup(id);
#line 671
  c = tmp;
#line 672
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 673
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 672
    if (c->type != 10) {
#line 673
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 674
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 675
  c->type = 4;
#line 677
  c->local_window_max = c->local_maxpacket * 2;
#line 677
  c->local_window = c->local_window_max;
#line 678
  packet_start((unsigned char)93);
#line 679
  packet_put_int((unsigned int )c->remote_id);
#line 680
  packet_put_int((unsigned int )c->local_window);
#line 681
  packet_send();
#line 682
  return;
}
}
#line 693 "channels.c"
chan_fn *channel_pre[15]  ;
#line 694 "channels.c"
chan_fn *channel_post[15]  ;
#line 696 "channels.c"
static void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 699
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 700
  return;
}
}
#line 702 "channels.c"
static void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 705
  debug3("channel %d: waiting for connection", c->self);
#line 706
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 707
  return;
}
}
#line 709 "channels.c"
static void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 712
  tmp = buffer_len(& c->input);
#line 712
  if (tmp < (u_int )max_packet_size) {
#line 713
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 714
  tmp___0 = buffer_len(& c->output);
#line 714
  if (tmp___0 > 0U) {
#line 715
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 716
  return;
}
}
#line 718 "channels.c"
static void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 722
  if (c->istate == 1) {
#line 723
    tmp = buffer_len(& c->input);
#line 723
    if (tmp < (u_int )max_packet_size) {
#line 724
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 725
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 725
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 727
      tmp___0 = buffer_len(& c->output);
#line 727
      if (tmp___0 > 0U) {
#line 728
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 729
        if (c->ostate == 32) {
#line 730
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 733
  return;
}
}
#line 735 "channels.c"
static void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 738
  if (c->istate == 1) {
#line 738
    if (c->remote_window > 0) {
#line 738
      tmp = buffer_len(& c->input);
#line 738
      if (tmp < (u_int )c->remote_window) {
#line 741
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 742
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 742
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 744
      tmp___0 = buffer_len(& c->output);
#line 744
      if (tmp___0 > 0U) {
#line 745
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 746
        if (c->ostate == 32) {
#line 747
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 751
  if (c->efd != -1) {
#line 752
    if (c->extended_usage == 2) {
#line 752
      tmp___2 = buffer_len(& c->extended);
#line 752
      if (tmp___2 > 0U) {
#line 754
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 755
      if (c->extended_usage == 1) {
#line 755
        tmp___1 = buffer_len(& c->extended);
#line 755
        if (tmp___1 < (u_int )c->remote_window) {
#line 757
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 759
  return;
}
}
#line 761 "channels.c"
static void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 764
  tmp = buffer_len(& c->input);
#line 764
  if (tmp == 0U) {
#line 765
    packet_start((unsigned char)24);
#line 766
    packet_put_int((unsigned int )c->remote_id);
#line 767
    packet_send();
#line 768
    c->type = 5;
#line 769
    debug("channel %d: closing after input drain.", c->self);
  }
#line 771
  return;
}
}
#line 773 "channels.c"
static void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 776
  tmp = buffer_len(& c->output);
#line 776
  if (tmp == 0U) {
#line 777
    chan_mark_dead(c);
  } else {
#line 779
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 780
  return;
}
}
#line 791 "channels.c"
static int x11_open_helper(Buffer *b ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 798
  tmp = buffer_len(b);
#line 798
  if (tmp < 12U) {
#line 799
    return (0);
  }
#line 802
  tmp___0 = buffer_ptr(b);
#line 802
  ucp = (u_char *)tmp___0;
#line 803
  if ((int )*(ucp + 0) == 66) {
#line 804
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 805
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 806
    if ((int )*(ucp + 0) == 108) {
#line 807
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 808
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 810
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 812
      return (-1);
    }
  }
#line 816
  tmp___1 = buffer_len(b);
#line 816
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 818
    return (0);
  }
#line 821
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 821
  if (proto_len != tmp___2) {
#line 823
    debug("X11 connection uses different authentication protocol.");
#line 824
    return (-1);
  } else {
#line 821
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 821
    if (tmp___3 != 0) {
#line 823
      debug("X11 connection uses different authentication protocol.");
#line 824
      return (-1);
    }
  }
#line 827
  if (data_len != x11_fake_data_len) {
#line 830
    debug("X11 auth data does not match fake data.");
#line 831
    return (-1);
  } else {
#line 827
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 827
    if (tmp___4 != 0) {
#line 830
      debug("X11 auth data does not match fake data.");
#line 831
      return (-1);
    }
  }
#line 834
  if (x11_fake_data_len != x11_saved_data_len) {
#line 835
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 837
    return (-1);
  }
#line 844
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 846
  return (1);
}
}
#line 849 "channels.c"
static void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 852
  tmp = x11_open_helper(& c->output);
#line 852
  ret = tmp;
#line 853
  if (ret == 1) {
#line 855
    c->type = 4;
#line 856
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 857
    if (ret == -1) {
#line 862
      log("X11 connection rejected because of wrong authentication.");
#line 863
      buffer_clear(& c->input);
#line 864
      buffer_clear(& c->output);
#line 865
      channel_close_fd(& c->sock);
#line 866
      c->sock = -1;
#line 867
      c->type = 5;
#line 868
      packet_start((unsigned char)24);
#line 869
      packet_put_int((unsigned int )c->remote_id);
#line 870
      packet_send();
    }
  }
#line 872
  return;
}
}
#line 874 "channels.c"
static void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 877
  tmp = x11_open_helper(& c->output);
#line 877
  ret = tmp;
#line 881
  if (ret == 1) {
#line 882
    c->type = 4;
#line 883
    if (compat20) {
#line 884
      channel_pre_open_20(c, readset, writeset);
    } else {
#line 886
      channel_pre_open_15(c, readset, writeset);
    }
  } else {
#line 887
    if (ret == -1) {
#line 888
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 889
      (*chan_read_failed)(c);
#line 890
      (*chan_write_failed)(c);
#line 891
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 893
  return;
}
}
#line 896 "channels.c"
static int channel_decode_socks4(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  u_char *host ;
  int len ;
  int have ;
  int i ;
  int found ;
  char username[256] ;
  struct __anonstruct_s4_req_71 s4_req ;
  struct __anonstruct_s4_req_71 s4_rsp ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 909
  debug2("channel %d: decode socks4", c->self);
#line 911
  tmp = buffer_len(& c->input);
#line 911
  have = (int )tmp;
#line 912
  len = (int )sizeof(s4_req);
#line 913
  if (have < len) {
#line 914
    return (0);
  }
#line 915
  tmp___0 = buffer_ptr(& c->input);
#line 915
  p = (u_char *)tmp___0;
#line 916
  found = 0;
#line 916
  i = len;
#line 916
  while (i < have) {
#line 917
    if ((int )*(p + i) == 0) {
#line 918
      found = 1;
#line 919
      break;
    }
#line 921
    if (i > 1024) {
#line 923
      debug("channel %d: decode socks4: too long", c->self);
#line 925
      return (-1);
    }
#line 916
    i ++;
  }
#line 928
  if (! found) {
#line 929
    return (0);
  }
#line 930
  buffer_get(& c->input, (char *)(& s4_req.version), 1U);
#line 931
  buffer_get(& c->input, (char *)(& s4_req.command), 1U);
#line 932
  buffer_get(& c->input, (char *)(& s4_req.dest_port), 2U);
#line 933
  buffer_get(& c->input, (char *)(& s4_req.dest_addr), 4U);
#line 934
  tmp___1 = buffer_len(& c->input);
#line 934
  have = (int )tmp___1;
#line 935
  tmp___2 = buffer_ptr(& c->input);
#line 935
  p = (u_char *)tmp___2;
#line 936
  tmp___3 = strlen((char const   *)p);
#line 936
  len = (int )tmp___3;
#line 937
  debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
#line 938
  if (len > have) {
#line 939
    fatal("channel %d: decode socks4: len %d > have %d", c->self, len, have);
  }
#line 941
  strlcpy(username, (char const   *)p, sizeof(username));
#line 942
  buffer_consume(& c->input, (unsigned int )len);
#line 943
  buffer_consume(& c->input, 1U);
#line 945
  tmp___4 = inet_ntoa(s4_req.dest_addr);
#line 945
  host = (u_char *)tmp___4;
#line 946
  strlcpy(c->path, (char const   *)host, sizeof(c->path));
#line 947
  __x = s4_req.dest_port;
#line 947
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 947
  c->host_port = (int )__v;
#line 949
  debug("channel %d: dynamic request: socks4 host %s port %u command %u", c->self,
        host, c->host_port, s4_req.command);
#line 952
  if ((int )s4_req.command != 1) {
#line 953
    debug("channel %d: cannot handle: socks4 cn %d", c->self, s4_req.command);
#line 955
    return (-1);
  }
#line 957
  s4_rsp.version = (unsigned char)0;
#line 958
  s4_rsp.command = (unsigned char)90;
#line 959
  s4_rsp.dest_port = (unsigned short)0;
#line 960
  s4_rsp.dest_addr.s_addr = 0U;
#line 961
  buffer_append(& c->output, (char const   *)((char *)(& s4_rsp)), sizeof(s4_rsp));
#line 962
  return (1);
}
}
#line 966 "channels.c"
static void channel_pre_dynamic(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  int have ;
  int ret ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 972
  tmp = buffer_len(& c->input);
#line 972
  have = (int )tmp;
#line 974
  debug2("channel %d: pre_dynamic: have %d", c->self, have);
#line 977
  if (have < 4) {
#line 979
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 980
    return;
  }
#line 983
  tmp___0 = buffer_ptr(& c->input);
#line 983
  p = (u_char *)tmp___0;
#line 984
  switch ((int )*(p + 0)) {
  case 4: 
#line 986
  ret = channel_decode_socks4(c, readset, writeset);
#line 987
  break;
  default: 
#line 989
  ret = -1;
#line 990
  break;
  }
#line 992
  if (ret < 0) {
#line 993
    chan_mark_dead(c);
  } else {
#line 994
    if (ret == 0) {
#line 995
      debug2("channel %d: pre_dynamic: need more", c->self);
#line 997
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    } else {
#line 1000
      c->type = 3;
#line 1001
      port_open_helper(c, (char *)"direct-tcpip");
    }
  }
#line 1003
  return;
}
}
#line 1006 "channels.c"
static void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  socklen_t addrlen ;
  char buf___2[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  register char __result ;

  {
#line 1016
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1016
  if (__result) {
#line 1017
    debug("X11 connection requested.");
#line 1018
    addrlen = sizeof(addr);
#line 1019
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1020
    if (newsock < 0) {
#line 1021
      tmp = __errno_location();
#line 1021
      tmp___0 = strerror(*tmp);
#line 1021
      error("accept: %.100s", tmp___0);
#line 1022
      return;
    }
#line 1024
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 1025
    remote_port = get_peer_port(newsock);
#line 1026
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 1029
    tmp___1 = xstrdup((char const   *)(buf___2));
#line 1029
    nc = channel_new((char *)"accepted x11 socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, tmp___1, 1);
#line 1033
    if ((unsigned int )nc == (unsigned int )((void *)0)) {
#line 1034
      close(newsock);
#line 1035
      xfree((void *)remote_ipaddr);
#line 1036
      return;
    }
#line 1038
    if (compat20) {
#line 1039
      packet_start((unsigned char)90);
#line 1040
      packet_put_cstring("x11");
#line 1041
      packet_put_int((unsigned int )nc->self);
#line 1042
      packet_put_int((unsigned int )c->local_window_max);
#line 1043
      packet_put_int((unsigned int )c->local_maxpacket);
#line 1045
      packet_put_cstring((char const   *)remote_ipaddr);
#line 1046
      if (datafellows & 8) {
#line 1047
        debug("ssh2 x11 bug compat mode");
      } else {
#line 1049
        packet_put_int((unsigned int )remote_port);
      }
#line 1051
      packet_send();
    } else {
#line 1053
      packet_start((unsigned char)27);
#line 1054
      packet_put_int((unsigned int )nc->self);
#line 1055
      tmp___2 = packet_get_protocol_flags();
#line 1055
      if (tmp___2 & 2U) {
#line 1057
        packet_put_cstring((char const   *)(buf___2));
      }
#line 1058
      packet_send();
    }
#line 1060
    xfree((void *)remote_ipaddr);
  }
#line 1062
  return;
}
}
#line 1064 "channels.c"
static void port_open_helper(Channel *c , char *rtype ) 
{ int direct ;
  char buf___2[1024] ;
  char *remote_ipaddr ;
  char *tmp ;
  u_short remote_port ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;

  {
#line 1069
  tmp = get_peer_ipaddr(c->sock);
#line 1069
  remote_ipaddr = tmp;
#line 1070
  tmp___0 = get_peer_port(c->sock);
#line 1070
  remote_port = (u_short )tmp___0;
#line 1072
  if (0) {
#line 1072
    __s1_len = strlen((char const   *)rtype);
#line 1072
    __s2_len = strlen("direct-tcpip");
#line 1072
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 1072
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1072
        if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1072
          tmp___10 = 1;
        } else {
#line 1072
          if (__s2_len >= 4U) {
#line 1072
            tmp___10 = 1;
          } else {
#line 1072
            tmp___10 = 0;
          }
        }
      } else {
#line 1072
        tmp___10 = 0;
      }
    }
#line 1072
    if (tmp___10) {
#line 1072
      tmp___6 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
    } else {
#line 1072
      tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1072
      tmp___6 = tmp___9;
    }
  } else {
#line 1072
    tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1072
    tmp___6 = tmp___9;
  }
#line 1072
  direct = tmp___6 == 0;
#line 1074
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%s: listening port %d for %.100s port %d, connect from %.200s port %d",
           rtype, c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 1080
  xfree((void *)c->remote_name);
#line 1081
  c->remote_name = xstrdup((char const   *)(buf___2));
#line 1083
  if (compat20) {
#line 1084
    packet_start((unsigned char)90);
#line 1085
    packet_put_cstring((char const   *)rtype);
#line 1086
    packet_put_int((unsigned int )c->self);
#line 1087
    packet_put_int((unsigned int )c->local_window_max);
#line 1088
    packet_put_int((unsigned int )c->local_maxpacket);
#line 1089
    if (direct) {
#line 1091
      packet_put_cstring((char const   *)(c->path));
#line 1092
      packet_put_int((unsigned int )c->host_port);
    } else {
#line 1095
      packet_put_cstring((char const   *)(c->path));
#line 1096
      packet_put_int((unsigned int )c->listening_port);
    }
#line 1099
    packet_put_cstring((char const   *)remote_ipaddr);
#line 1100
    packet_put_int((unsigned int )remote_port);
#line 1101
    packet_send();
  } else {
#line 1103
    packet_start((unsigned char)29);
#line 1104
    packet_put_int((unsigned int )c->self);
#line 1105
    packet_put_cstring((char const   *)(c->path));
#line 1106
    packet_put_int((unsigned int )c->host_port);
#line 1107
    tmp___11 = packet_get_protocol_flags();
#line 1107
    if (tmp___11 & 2U) {
#line 1109
      packet_put_cstring((char const   *)c->remote_name);
    }
#line 1110
    packet_send();
  }
#line 1112
  xfree((void *)remote_ipaddr);
#line 1113
  return;
}
}
#line 1118 "channels.c"
static void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  int nextstate ;
  socklen_t addrlen ;
  char *rtype ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 1127
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1127
  if (__result) {
#line 1128
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 1132
    if (c->type == 11) {
#line 1132
      rtype = (char *)"forwarded-tcpip";
    } else {
#line 1132
      rtype = (char *)"direct-tcpip";
    }
#line 1134
    if (c->host_port == 0) {
#line 1134
      if (c->type != 11) {
#line 1134
        nextstate = 13;
      } else {
#line 1134
        nextstate = 3;
      }
    } else {
#line 1134
      nextstate = 3;
    }
#line 1138
    addrlen = sizeof(addr);
#line 1139
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1140
    if (newsock < 0) {
#line 1141
      tmp = __errno_location();
#line 1141
      tmp___0 = strerror(*tmp);
#line 1141
      error("accept: %.100s", tmp___0);
#line 1142
      return;
    }
#line 1144
    tmp___1 = xstrdup((char const   *)rtype);
#line 1144
    nc = channel_new(rtype, nextstate, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, tmp___1, 1);
#line 1148
    if ((unsigned int )nc == (unsigned int )((void *)0)) {
#line 1149
      error("channel_post_port_listener: no new channel:");
#line 1150
      close(newsock);
#line 1151
      return;
    }
#line 1153
    nc->listening_port = c->listening_port;
#line 1154
    nc->host_port = c->host_port;
#line 1155
    strlcpy(nc->path, (char const   *)(c->path), sizeof(nc->path));
#line 1157
    if (nextstate != 13) {
#line 1158
      port_open_helper(nc, rtype);
    }
  }
#line 1160
  return;
}
}
#line 1166 "channels.c"
static void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  char *name ;
  int newsock ;
  struct sockaddr addr ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1175
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1175
  if (__result) {
#line 1176
    addrlen = sizeof(addr);
#line 1177
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1178
    if (newsock < 0) {
#line 1179
      tmp = __errno_location();
#line 1179
      tmp___0 = strerror(*tmp);
#line 1179
      error("accept from auth socket: %.100s", tmp___0);
#line 1180
      return;
    }
#line 1182
    name = xstrdup("accepted auth socket");
#line 1183
    nc = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, name, 1);
#line 1187
    if ((unsigned int )nc == (unsigned int )((void *)0)) {
#line 1188
      error("channel_post_auth_listener: channel_new failed");
#line 1189
      xfree((void *)name);
#line 1190
      close(newsock);
    }
#line 1192
    if (compat20) {
#line 1193
      packet_start((unsigned char)90);
#line 1194
      packet_put_cstring("auth-agent@openssh.com");
#line 1195
      packet_put_int((unsigned int )nc->self);
#line 1196
      packet_put_int((unsigned int )c->local_window_max);
#line 1197
      packet_put_int((unsigned int )c->local_maxpacket);
    } else {
#line 1199
      packet_start((unsigned char)31);
#line 1200
      packet_put_int((unsigned int )nc->self);
    }
#line 1202
    packet_send();
  }
#line 1204
  return;
}
}
#line 1206 "channels.c"
static void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  socklen_t sz ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register char __result ;

  {
#line 1209
  err = 0;
#line 1210
  sz = sizeof(err);
#line 1212
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1212
  if (__result) {
#line 1213
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )((char *)(& err)), (socklen_t * __restrict  )(& sz));
#line 1213
    if (tmp___0 < 0) {
#line 1215
      tmp = __errno_location();
#line 1215
      err = *tmp;
#line 1216
      error("getsockopt SO_ERROR failed");
    }
#line 1218
    if (err == 0) {
#line 1219
      debug("channel %d: connected", c->self);
#line 1220
      c->type = 4;
#line 1221
      if (compat20) {
#line 1222
        packet_start((unsigned char)91);
#line 1223
        packet_put_int((unsigned int )c->remote_id);
#line 1224
        packet_put_int((unsigned int )c->self);
#line 1225
        packet_put_int((unsigned int )c->local_window);
#line 1226
        packet_put_int((unsigned int )c->local_maxpacket);
      } else {
#line 1228
        packet_start((unsigned char)21);
#line 1229
        packet_put_int((unsigned int )c->remote_id);
#line 1230
        packet_put_int((unsigned int )c->self);
      }
    } else {
#line 1233
      tmp___1 = strerror(err);
#line 1233
      debug("channel %d: not connected: %s", c->self, tmp___1);
#line 1235
      if (compat20) {
#line 1236
        packet_start((unsigned char)92);
#line 1237
        packet_put_int((unsigned int )c->remote_id);
#line 1238
        packet_put_int(2U);
#line 1239
        if (! (datafellows & 131072)) {
#line 1240
          tmp___2 = strerror(err);
#line 1240
          packet_put_cstring((char const   *)tmp___2);
#line 1241
          packet_put_cstring("");
        }
      } else {
#line 1244
        packet_start((unsigned char)22);
#line 1245
        packet_put_int((unsigned int )c->remote_id);
      }
#line 1247
      chan_mark_dead(c);
    }
#line 1249
    packet_send();
  }
#line 1251
  return;
}
}
#line 1253 "channels.c"
static int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___2[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  register char __result ;

  {
#line 1260
  if (c->rfd != -1) {
#line 1260
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1260
    if (__result) {
#line 1261
      len = read(c->rfd, (void *)(buf___2), sizeof(buf___2));
#line 1262
      if (len < 0) {
#line 1262
        tmp = __errno_location();
#line 1262
        if (*tmp == 4) {
#line 1263
          return (1);
        } else {
#line 1262
          tmp___0 = __errno_location();
#line 1262
          if (*tmp___0 == 11) {
#line 1263
            return (1);
          }
        }
      }
#line 1264
      if (len <= 0) {
#line 1265
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 1267
        if (c->type != 4) {
#line 1268
          debug("channel %d: not open", c->self);
#line 1269
          chan_mark_dead(c);
#line 1270
          return (-1);
        } else {
#line 1271
          if (compat13) {
#line 1272
            tmp___1 = buffer_len(& c->output);
#line 1272
            buffer_consume(& c->output, tmp___1);
#line 1273
            c->type = 8;
#line 1274
            debug("channel %d: input draining.", c->self);
          } else {
#line 1276
            (*chan_read_failed)(c);
          }
        }
#line 1278
        return (-1);
      }
#line 1280
      if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 1281
        tmp___2 = (*(c->input_filter))(c, buf___2, len);
#line 1281
        if (tmp___2 == -1) {
#line 1282
          debug("channel %d: filter stops", c->self);
#line 1283
          (*chan_read_failed)(c);
        }
      } else {
#line 1286
        buffer_append(& c->input, (char const   *)(buf___2), (unsigned int )len);
      }
    }
  }
#line 1289
  return (1);
}
}
#line 1291 "channels.c"
static int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  register char __result ;
  u_int tmp___4 ;

  {
#line 1301
  if (c->wfd != -1) {
#line 1301
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1301
    if (__result) {
#line 1301
      tmp___4 = buffer_len(& c->output);
#line 1301
      if (tmp___4 > 0U) {
#line 1303
        tmp = buffer_ptr(& c->output);
#line 1303
        data = (u_char *)tmp;
#line 1304
        dlen = buffer_len(& c->output);
#line 1305
        len = write(c->wfd, (void const   *)data, dlen);
#line 1306
        if (len < 0) {
#line 1306
          tmp___0 = __errno_location();
#line 1306
          if (*tmp___0 == 4) {
#line 1307
            return (1);
          } else {
#line 1306
            tmp___1 = __errno_location();
#line 1306
            if (*tmp___1 == 11) {
#line 1307
              return (1);
            }
          }
        }
#line 1308
        if (len <= 0) {
#line 1309
          if (c->type != 4) {
#line 1310
            debug("channel %d: not open", c->self);
#line 1311
            chan_mark_dead(c);
#line 1312
            return (-1);
          } else {
#line 1313
            if (compat13) {
#line 1314
              tmp___2 = buffer_len(& c->output);
#line 1314
              buffer_consume(& c->output, tmp___2);
#line 1315
              debug("channel %d: input draining.", c->self);
#line 1316
              c->type = 8;
            } else {
#line 1318
              (*chan_write_failed)(c);
            }
          }
#line 1320
          return (-1);
        }
#line 1322
        if (compat20) {
#line 1322
          if (c->isatty) {
#line 1322
            if (dlen >= 1U) {
#line 1322
              if ((int )*(data + 0) != 13) {
#line 1323
                tmp___3 = tcgetattr(c->wfd, & tio);
#line 1323
                if (tmp___3 == 0) {
#line 1323
                  if (! (tio.c_lflag & 8U)) {
#line 1323
                    if (tio.c_lflag & 2U) {
#line 1331
                      packet_send_ignore(4 + len);
#line 1332
                      packet_send();
                    }
                  }
                }
              }
            }
          }
        }
#line 1335
        buffer_consume(& c->output, (unsigned int )len);
#line 1336
        if (compat20) {
#line 1336
          if (len > 0) {
#line 1337
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 1340
  return (1);
}
}
#line 1342 "channels.c"
static int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___2[16384] ;
  int len ;
  u_int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___5 ;

  {
#line 1349
  if (c->efd != -1) {
#line 1351
    if (c->extended_usage == 2) {
#line 1351
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1351
      if (__result___0) {
#line 1351
        tmp___5 = buffer_len(& c->extended);
#line 1351
        if (tmp___5 > 0U) {
#line 1353
          tmp = buffer_len(& c->extended);
#line 1353
          tmp___0 = buffer_ptr(& c->extended);
#line 1353
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 1355
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 1357
          if (len < 0) {
#line 1357
            tmp___1 = __errno_location();
#line 1357
            if (*tmp___1 == 4) {
#line 1358
              return (1);
            } else {
#line 1357
              tmp___2 = __errno_location();
#line 1357
              if (*tmp___2 == 11) {
#line 1358
                return (1);
              }
            }
          }
#line 1359
          if (len <= 0) {
#line 1360
            debug2("channel %d: closing write-efd %d", c->self, c->efd);
#line 1362
            channel_close_fd(& c->efd);
          } else {
#line 1364
            buffer_consume(& c->extended, (unsigned int )len);
#line 1365
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1368
      if (c->extended_usage == 1) {
#line 1368
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1368
        if (__result) {
#line 1369
          len = read(c->efd, (void *)(buf___2), sizeof(buf___2));
#line 1370
          debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 1372
          if (len < 0) {
#line 1372
            tmp___3 = __errno_location();
#line 1372
            if (*tmp___3 == 4) {
#line 1373
              return (1);
            } else {
#line 1372
              tmp___4 = __errno_location();
#line 1372
              if (*tmp___4 == 11) {
#line 1373
                return (1);
              }
            }
          }
#line 1374
          if (len <= 0) {
#line 1375
            debug2("channel %d: closing read-efd %d", c->self, c->efd);
#line 1377
            channel_close_fd(& c->efd);
          } else {
#line 1379
            buffer_append(& c->extended, (char const   *)(buf___2), (unsigned int )len);
          }
        }
      }
    }
  }
#line 1383
  return (1);
}
}
#line 1385 "channels.c"
static int channel_check_window(Channel *c ) 
{ 

  {
#line 1388
  if (c->type == 4) {
#line 1388
    if (! (c->flags & 3)) {
#line 1388
      if (c->local_window < c->local_window_max / 2) {
#line 1388
        if (c->local_consumed > 0) {
#line 1392
          packet_start((unsigned char)93);
#line 1393
          packet_put_int((unsigned int )c->remote_id);
#line 1394
          packet_put_int((unsigned int )c->local_consumed);
#line 1395
          packet_send();
#line 1396
          debug2("channel %d: window %d sent adjust %d", c->self, c->local_window,
                 c->local_consumed);
#line 1399
          c->local_window += c->local_consumed;
#line 1400
          c->local_consumed = 0;
        }
      }
    }
  }
#line 1402
  return (1);
}
}
#line 1405 "channels.c"
static void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1408
  channel_handle_rfd(c, readset, writeset);
#line 1409
  channel_handle_wfd(c, readset, writeset);
#line 1410
  return;
}
}
#line 1412 "channels.c"
static void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1415
  channel_handle_rfd(c, readset, writeset);
#line 1416
  channel_handle_wfd(c, readset, writeset);
#line 1417
  channel_handle_efd(c, readset, writeset);
#line 1419
  channel_check_window(c);
#line 1420
  return;
}
}
#line 1422 "channels.c"
static void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  register char __result ;
  u_int tmp___2 ;

  {
#line 1427
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1427
  if (__result) {
#line 1427
    tmp___2 = buffer_len(& c->output);
#line 1427
    if (tmp___2 > 0U) {
#line 1428
      tmp = buffer_len(& c->output);
#line 1428
      tmp___0 = buffer_ptr(& c->output);
#line 1428
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 1430
      if (len <= 0) {
#line 1431
        tmp___1 = buffer_len(& c->output);
#line 1431
        buffer_consume(& c->output, tmp___1);
      } else {
#line 1433
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 1435
  return;
}
}
#line 1437 "channels.c"
static void channel_handler_init_20(void) 
{ 

  {
#line 1440
  channel_pre[4] = & channel_pre_open_20;
#line 1441
  channel_pre[7] = & channel_pre_x11_open;
#line 1442
  channel_pre[2] = & channel_pre_listener;
#line 1443
  channel_pre[11] = & channel_pre_listener;
#line 1444
  channel_pre[1] = & channel_pre_listener;
#line 1445
  channel_pre[6] = & channel_pre_listener;
#line 1446
  channel_pre[12] = & channel_pre_connecting;
#line 1447
  channel_pre[13] = & channel_pre_dynamic;
#line 1449
  channel_post[4] = & channel_post_open_2;
#line 1450
  channel_post[2] = & channel_post_port_listener;
#line 1451
  channel_post[11] = & channel_post_port_listener;
#line 1452
  channel_post[1] = & channel_post_x11_listener;
#line 1453
  channel_post[6] = & channel_post_auth_listener;
#line 1454
  channel_post[12] = & channel_post_connecting;
#line 1455
  channel_post[13] = & channel_post_open_2;
#line 1456
  return;
}
}
#line 1458 "channels.c"
static void channel_handler_init_13(void) 
{ 

  {
#line 1461
  channel_pre[4] = & channel_pre_open_13;
#line 1462
  channel_pre[7] = & channel_pre_x11_open_13;
#line 1463
  channel_pre[1] = & channel_pre_listener;
#line 1464
  channel_pre[2] = & channel_pre_listener;
#line 1465
  channel_pre[6] = & channel_pre_listener;
#line 1466
  channel_pre[8] = & channel_pre_input_draining;
#line 1467
  channel_pre[9] = & channel_pre_output_draining;
#line 1468
  channel_pre[12] = & channel_pre_connecting;
#line 1469
  channel_pre[13] = & channel_pre_dynamic;
#line 1471
  channel_post[4] = & channel_post_open_1;
#line 1472
  channel_post[1] = & channel_post_x11_listener;
#line 1473
  channel_post[2] = & channel_post_port_listener;
#line 1474
  channel_post[6] = & channel_post_auth_listener;
#line 1475
  channel_post[9] = & channel_post_output_drain_13;
#line 1476
  channel_post[12] = & channel_post_connecting;
#line 1477
  channel_post[13] = & channel_post_open_1;
#line 1478
  return;
}
}
#line 1480 "channels.c"
static void channel_handler_init_15(void) 
{ 

  {
#line 1483
  channel_pre[4] = & channel_pre_open_15;
#line 1484
  channel_pre[7] = & channel_pre_x11_open;
#line 1485
  channel_pre[1] = & channel_pre_listener;
#line 1486
  channel_pre[2] = & channel_pre_listener;
#line 1487
  channel_pre[6] = & channel_pre_listener;
#line 1488
  channel_pre[12] = & channel_pre_connecting;
#line 1489
  channel_pre[13] = & channel_pre_dynamic;
#line 1491
  channel_post[1] = & channel_post_x11_listener;
#line 1492
  channel_post[2] = & channel_post_port_listener;
#line 1493
  channel_post[6] = & channel_post_auth_listener;
#line 1494
  channel_post[4] = & channel_post_open_1;
#line 1495
  channel_post[12] = & channel_post_connecting;
#line 1496
  channel_post[13] = & channel_post_open_1;
#line 1497
  return;
}
}
#line 1499 "channels.c"
static void channel_handler_init(void) 
{ int i ;

  {
#line 1503
  i = 0;
#line 1503
  while (i < 15) {
#line 1504
    channel_pre[i] = (chan_fn *)((void *)0);
#line 1505
    channel_post[i] = (chan_fn *)((void *)0);
#line 1503
    i ++;
  }
#line 1507
  if (compat20) {
#line 1508
    channel_handler_init_20();
  } else {
#line 1509
    if (compat13) {
#line 1510
      channel_handler_init_13();
    } else {
#line 1512
      channel_handler_init_15();
    }
  }
#line 1513
  return;
}
}
#line 1518
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 1518 "channels.c"
static int did_init  =    0;
#line 1515 "channels.c"
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;
  int tmp ;

  {
#line 1522
  if (! did_init) {
#line 1523
    channel_handler_init();
#line 1524
    did_init = 1;
  }
#line 1526
  i = 0;
#line 1526
  while (i < channels_alloc) {
#line 1527
    c = *(channels + i);
#line 1528
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1530
    if ((unsigned int )*(ftab + c->type) != (unsigned int )((void *)0)) {
#line 1531
      (*(*(ftab + c->type)))(c, readset, writeset);
    }
#line 1532
    tmp = chan_is_dead(c);
#line 1532
    if (tmp) {
#line 1538
      if (c->wfd != -1) {
#line 1539
        __asm__  volatile   ("btrl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 1540
      if (c->rfd != -1) {
#line 1541
        __asm__  volatile   ("btrl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 1542
      if (c->efd != -1) {
#line 1543
        if (c->extended_usage == 1) {
#line 1544
          __asm__  volatile   ("btrl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 1545
        if (c->extended_usage == 2) {
#line 1546
          __asm__  volatile   ("btrl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
#line 1548
      channel_free(c);
    }
    __Cont: /* CIL Label */ 
#line 1526
    i ++;
  }
#line 1551
  return;
}
}
#line 1557 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            int *nallocp , int rekeying ) 
{ int n___0 ;
  u_int sz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1564
  if (*maxfdp > channel_max_fd) {
#line 1564
    n___0 = *maxfdp;
  } else {
#line 1564
    n___0 = channel_max_fd;
  }
#line 1566
  sz = (((unsigned int )(n___0 + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask );
#line 1568
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
#line 1569
    tmp = xrealloc((void *)*readsetp, sz);
#line 1569
    *readsetp = (fd_set *)tmp;
#line 1570
    tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1570
    *writesetp = (fd_set *)tmp___0;
#line 1571
    *nallocp = (int )sz;
  } else {
#line 1568
    if (sz > (u_int )*nallocp) {
#line 1569
      tmp = xrealloc((void *)*readsetp, sz);
#line 1569
      *readsetp = (fd_set *)tmp;
#line 1570
      tmp___0 = xrealloc((void *)*writesetp, sz);
#line 1570
      *writesetp = (fd_set *)tmp___0;
#line 1571
      *nallocp = (int )sz;
    }
  }
#line 1573
  *maxfdp = n___0;
#line 1574
  memset((void *)*readsetp, 0, sz);
#line 1575
  memset((void *)*writesetp, 0, sz);
#line 1577
  if (! rekeying) {
#line 1578
    channel_handler(channel_pre, *readsetp, *writesetp);
  }
#line 1579
  return;
}
}
#line 1585 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1588
  channel_handler(channel_post, readset, writeset);
#line 1589
  return;
}
}
#line 1594 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;

  {
#line 1600
  i = 0;
#line 1600
  while (i < channels_alloc) {
#line 1601
    c = *(channels + i);
#line 1602
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1609
    if (compat13) {
#line 1610
      if (c->type != 4) {
#line 1610
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1614
      if (c->type != 4) {
        goto __Cont;
      }
    }
#line 1617
    if (compat20) {
#line 1617
      if (c->flags & 3) {
#line 1620
        debug2("channel %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 1625
    if (c->istate == 1) {
      goto _L___0;
    } else {
#line 1625
      if (c->istate == 2) {
        _L___0: /* CIL Label */ 
#line 1625
        tmp___2 = buffer_len(& c->input);
#line 1625
        len = (int )tmp___2;
#line 1625
        if (len > 0) {
#line 1632
          if (compat20) {
#line 1633
            if (len > c->remote_window) {
#line 1634
              len = c->remote_window;
            }
#line 1635
            if (len > c->remote_maxpacket) {
#line 1636
              len = c->remote_maxpacket;
            }
          } else {
#line 1638
            tmp = packet_is_interactive();
#line 1638
            if (tmp) {
#line 1639
              if (len > 1024) {
#line 1640
                len = 512;
              }
            } else {
#line 1643
              if (len > max_packet_size / 2) {
#line 1644
                len = max_packet_size / 2;
              }
            }
          }
#line 1647
          if (len > 0) {
#line 1648
            if (compat20) {
#line 1648
              tmp___0 = 94;
            } else {
#line 1648
              tmp___0 = 23;
            }
#line 1648
            packet_start((unsigned char )tmp___0);
#line 1650
            packet_put_int((unsigned int )c->remote_id);
#line 1651
            tmp___1 = buffer_ptr(& c->input);
#line 1651
            packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 1652
            packet_send();
#line 1653
            buffer_consume(& c->input, (unsigned int )len);
#line 1654
            c->remote_window -= len;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1656
        if (c->istate == 2) {
#line 1657
          if (compat13) {
#line 1658
            fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
          }
#line 1663
          (*chan_ibuf_empty)(c);
        }
      }
    }
#line 1666
    if (compat20) {
#line 1666
      if (c->remote_window > 0) {
#line 1666
        tmp___5 = buffer_len(& c->extended);
#line 1666
        len = (int )tmp___5;
#line 1666
        if (len > 0) {
#line 1666
          if (c->extended_usage == 1) {
#line 1670
            tmp___3 = buffer_len(& c->extended);
#line 1670
            debug2("channel %d: rwin %d elen %d euse %d", c->self, c->remote_window,
                   tmp___3, c->extended_usage);
#line 1673
            if (len > c->remote_window) {
#line 1674
              len = c->remote_window;
            }
#line 1675
            if (len > c->remote_maxpacket) {
#line 1676
              len = c->remote_maxpacket;
            }
#line 1677
            packet_start((unsigned char)95);
#line 1678
            packet_put_int((unsigned int )c->remote_id);
#line 1679
            packet_put_int(1U);
#line 1680
            tmp___4 = buffer_ptr(& c->extended);
#line 1680
            packet_put_string((char const   *)tmp___4, (unsigned int )len);
#line 1681
            packet_send();
#line 1682
            buffer_consume(& c->extended, (unsigned int )len);
#line 1683
            c->remote_window -= len;
#line 1684
            debug2("channel %d: sent ext data %d", c->self, len);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1600
    i ++;
  }
#line 1687
  return;
}
}
#line 1692 "channels.c"
void channel_input_data(int type , int plen , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1701
  tmp = packet_get_int();
#line 1701
  id = (int )tmp;
#line 1702
  c = channel_lookup(id);
#line 1703
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1704
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 1707
  if (c->type != 4) {
#line 1707
    if (c->type != 7) {
#line 1709
      return;
    }
  }
#line 1712
  if (! compat13) {
#line 1712
    if (c->ostate != 16) {
#line 1713
      return;
    }
  }
#line 1716
  data = packet_get_string(& data_len);
#line 1717
  while (1) {
#line 1717
    tmp___0 = packet_remaining();
#line 1717
    _len = tmp___0;
#line 1717
    if (_len > 0) {
#line 1717
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1717);
#line 1717
      packet_disconnect("Packet integrity error.");
    }
#line 1717
    break;
  }
#line 1719
  if (compat20) {
#line 1720
    if (data_len > (u_int )c->local_maxpacket) {
#line 1721
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1724
    if (data_len > (u_int )c->local_window) {
#line 1725
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1727
      xfree((void *)data);
#line 1728
      return;
    }
#line 1730
    c->local_window = (int )((u_int )c->local_window - data_len);
  } else {
#line 1732
    while (1) {
#line 1732
      _p = plen;
#line 1732
      _e = (int )(8U + data_len);
#line 1732
      if (_p != _e) {
#line 1732
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1732);
#line 1732
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1732
      break;
    }
  }
#line 1734
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1735
  xfree((void *)data);
#line 1736
  return;
}
}
#line 1738 "channels.c"
void channel_input_extended_data(int type , int plen , void *ctxt ) 
{ int id ;
  int tcode ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1748
  tmp = packet_get_int();
#line 1748
  id = (int )tmp;
#line 1749
  c = channel_lookup(id);
#line 1751
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1752
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1753
  if (c->type != 4) {
#line 1754
    log("channel %d: ext data for non open", id);
#line 1755
    return;
  }
#line 1757
  tmp___0 = packet_get_int();
#line 1757
  tcode = (int )tmp___0;
#line 1758
  if (c->efd == -1) {
#line 1761
    log("channel %d: bad ext data", c->self);
#line 1762
    return;
  } else {
#line 1758
    if (c->extended_usage != 2) {
#line 1761
      log("channel %d: bad ext data", c->self);
#line 1762
      return;
    } else {
#line 1758
      if (tcode != 1) {
#line 1761
        log("channel %d: bad ext data", c->self);
#line 1762
        return;
      }
    }
  }
#line 1764
  data = packet_get_string(& data_len);
#line 1765
  while (1) {
#line 1765
    tmp___1 = packet_remaining();
#line 1765
    _len = tmp___1;
#line 1765
    if (_len > 0) {
#line 1765
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1765);
#line 1765
      packet_disconnect("Packet integrity error.");
    }
#line 1765
    break;
  }
#line 1766
  if (data_len > (u_int )c->local_window) {
#line 1767
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1769
    xfree((void *)data);
#line 1770
    return;
  }
#line 1772
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 1773
  c->local_window = (int )((u_int )c->local_window - data_len);
#line 1774
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1775
  xfree((void *)data);
#line 1776
  return;
}
}
#line 1778 "channels.c"
void channel_input_ieof(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;

  {
#line 1784
  while (1) {
#line 1784
    _p = plen;
#line 1784
    _e = 4;
#line 1784
    if (_p != _e) {
#line 1784
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1784);
#line 1784
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1784
    break;
  }
#line 1786
  tmp = packet_get_int();
#line 1786
  id = (int )tmp;
#line 1787
  c = channel_lookup(id);
#line 1788
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1789
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1790
  (*chan_rcvd_ieof)(c);
#line 1793
  if (c->force_drain) {
#line 1794
    debug("channel %d: FORCE input drain", c->self);
#line 1795
    c->istate = 2;
  }
#line 1798
  return;
}
}
#line 1800 "channels.c"
void channel_input_close(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 1806
  while (1) {
#line 1806
    _p = plen;
#line 1806
    _e = 4;
#line 1806
    if (_p != _e) {
#line 1806
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1806);
#line 1806
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1806
    break;
  }
#line 1808
  tmp = packet_get_int();
#line 1808
  id = (int )tmp;
#line 1809
  c = channel_lookup(id);
#line 1810
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1811
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1817
  packet_start((unsigned char)25);
#line 1818
  packet_put_int((unsigned int )c->remote_id);
#line 1819
  packet_send();
#line 1828
  if (c->type != 5) {
#line 1833
    tmp___0 = buffer_len(& c->input);
#line 1833
    buffer_consume(& c->input, tmp___0);
#line 1834
    c->type = 9;
  }
#line 1836
  return;
}
}
#line 1839 "channels.c"
void channel_input_oclose(int type , int plen , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1842
  tmp = packet_get_int();
#line 1842
  id = (int )tmp;
#line 1843
  tmp___0 = channel_lookup(id);
#line 1843
  c = tmp___0;
#line 1844
  while (1) {
#line 1844
    _p = plen;
#line 1844
    _e = 4;
#line 1844
    if (_p != _e) {
#line 1844
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1844);
#line 1844
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1844
    break;
  }
#line 1845
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1846
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1847
  (*chan_rcvd_oclose)(c);
#line 1848
  return;
}
}
#line 1850 "channels.c"
void channel_input_close_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1853
  tmp = packet_get_int();
#line 1853
  id = (int )tmp;
#line 1854
  tmp___0 = channel_lookup(id);
#line 1854
  c = tmp___0;
#line 1856
  while (1) {
#line 1856
    tmp___1 = packet_remaining();
#line 1856
    _len = tmp___1;
#line 1856
    if (_len > 0) {
#line 1856
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1856);
#line 1856
      packet_disconnect("Packet integrity error.");
    }
#line 1856
    break;
  }
#line 1857
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1858
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1860
  if (c->type != 5) {
#line 1861
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1863
  channel_free(c);
#line 1864
  return;
}
}
#line 1866 "channels.c"
void channel_input_open_confirmation(int type , int plen , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1872
  if (! compat20) {
#line 1873
    while (1) {
#line 1873
      _p = plen;
#line 1873
      _e = 8;
#line 1873
      if (_p != _e) {
#line 1873
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1873);
#line 1873
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1873
      break;
    }
  }
#line 1875
  tmp = packet_get_int();
#line 1875
  id = (int )tmp;
#line 1876
  c = channel_lookup(id);
#line 1878
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1879
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1878
    if (c->type != 3) {
#line 1879
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1881
  tmp___0 = packet_get_int();
#line 1881
  remote_id = (int )tmp___0;
#line 1883
  c->remote_id = remote_id;
#line 1884
  c->type = 4;
#line 1886
  if (compat20) {
#line 1887
    tmp___1 = packet_get_int();
#line 1887
    c->remote_window = (int )tmp___1;
#line 1888
    tmp___2 = packet_get_int();
#line 1888
    c->remote_maxpacket = (int )tmp___2;
#line 1889
    while (1) {
#line 1889
      tmp___3 = packet_remaining();
#line 1889
      _len = tmp___3;
#line 1889
      if (_len > 0) {
#line 1889
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1889);
#line 1889
        packet_disconnect("Packet integrity error.");
      }
#line 1889
      break;
    }
#line 1890
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1890
      if (c->cb_event == type) {
#line 1891
        debug2("callback start");
#line 1892
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1893
        debug2("callback done");
      }
    }
#line 1895
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1898
  return;
}
}
#line 1900 "channels.c"
static char *reason2txt(int reason ) 
{ 

  {
#line 1903
  switch (reason) {
  case 1: 
#line 1905
  return ((char *)"administratively prohibited");
  case 2: 
#line 1907
  return ((char *)"connect failed");
  case 3: 
#line 1909
  return ((char *)"unknown channel type");
  case 4: 
#line 1911
  return ((char *)"resource shortage");
  }
#line 1913
  return ((char *)"unknown reason");
}
}
#line 1916 "channels.c"
void channel_input_open_failure(int type , int plen , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
#line 1920
  msg = (char *)((void *)0);
#line 1920
  lang = (char *)((void *)0);
#line 1923
  if (! compat20) {
#line 1924
    while (1) {
#line 1924
      _p = plen;
#line 1924
      _e = 4;
#line 1924
      if (_p != _e) {
#line 1924
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1924);
#line 1924
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1924
      break;
    }
  }
#line 1926
  tmp = packet_get_int();
#line 1926
  id = (int )tmp;
#line 1927
  c = channel_lookup(id);
#line 1929
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1930
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1929
    if (c->type != 3) {
#line 1930
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1932
  if (compat20) {
#line 1933
    tmp___0 = packet_get_int();
#line 1933
    reason = (int )tmp___0;
#line 1934
    if (! (datafellows & 131072)) {
#line 1935
      msg = packet_get_string((u_int *)((void *)0));
#line 1936
      lang = packet_get_string((u_int *)((void *)0));
    }
#line 1938
    while (1) {
#line 1938
      tmp___1 = packet_remaining();
#line 1938
      _len = tmp___1;
#line 1938
      if (_len > 0) {
#line 1938
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1938);
#line 1938
        packet_disconnect("Packet integrity error.");
      }
#line 1938
      break;
    }
#line 1939
    if (msg) {
#line 1939
      tmp___2 = (char const   *)msg;
    } else {
#line 1939
      tmp___2 = "";
    }
#line 1939
    if (msg) {
#line 1939
      tmp___3 = ": ";
    } else {
#line 1939
      tmp___3 = "";
    }
#line 1939
    tmp___4 = reason2txt(reason);
#line 1939
    log("channel %d: open failed: %s%s%s", id, tmp___4, tmp___3, tmp___2);
#line 1941
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 1942
      xfree((void *)msg);
    }
#line 1943
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 1944
      xfree((void *)lang);
    }
  }
#line 1947
  channel_free(c);
#line 1948
  return;
}
}
#line 1950 "channels.c"
void channel_input_channel_request(int type , int plen , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1956
  tmp = packet_get_int();
#line 1956
  id = (int )tmp;
#line 1957
  c = channel_lookup(id);
#line 1959
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1961
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1959
    if (c->type != 4) {
#line 1959
      if (c->type != 10) {
#line 1961
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1963
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1963
    if (c->cb_event == type) {
#line 1964
      debug2("callback start");
#line 1965
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1966
      debug2("callback done");
    } else {
#line 1968
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1968
      service = tmp___0;
#line 1969
      debug("channel %d: rcvd request for %s", c->self, service);
#line 1970
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1971
      xfree((void *)service);
    }
  } else {
#line 1968
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1968
    service = tmp___0;
#line 1969
    debug("channel %d: rcvd request for %s", c->self, service);
#line 1970
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1971
    xfree((void *)service);
  }
#line 1973
  return;
}
}
#line 1975 "channels.c"
void channel_input_window_adjust(int type , int plen , void *ctxt ) 
{ Channel *c ;
  int id ;
  int adjust ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1981
  if (! compat20) {
#line 1982
    return;
  }
#line 1985
  tmp = packet_get_int();
#line 1985
  id = (int )tmp;
#line 1986
  c = channel_lookup(id);
#line 1988
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1989
    log("Received window adjust for non-open channel %d.", id);
#line 1991
    return;
  } else {
#line 1988
    if (c->type != 4) {
#line 1989
      log("Received window adjust for non-open channel %d.", id);
#line 1991
      return;
    }
  }
#line 1993
  tmp___0 = packet_get_int();
#line 1993
  adjust = (int )tmp___0;
#line 1994
  while (1) {
#line 1994
    tmp___1 = packet_remaining();
#line 1994
    _len = tmp___1;
#line 1994
    if (_len > 0) {
#line 1994
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1994);
#line 1994
      packet_disconnect("Packet integrity error.");
    }
#line 1994
    break;
  }
#line 1995
  debug2("channel %d: rcvd adjust %d", id, adjust);
#line 1996
  c->remote_window += adjust;
#line 1997
  return;
}
}
#line 1999 "channels.c"
void channel_input_port_open(int type , int plen , void *ctxt ) 
{ Channel *c ;
  u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_id ;
  int sock ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 2002
  c = (Channel *)((void *)0);
#line 2005
  sock = -1;
#line 2007
  tmp = packet_get_int();
#line 2007
  remote_id = (int )tmp;
#line 2008
  host = packet_get_string((u_int *)((void *)0));
#line 2009
  tmp___0 = packet_get_int();
#line 2009
  host_port = (unsigned short )tmp___0;
#line 2011
  tmp___1 = packet_get_protocol_flags();
#line 2011
  if (tmp___1 & 2U) {
#line 2012
    originator_string = packet_get_string((u_int *)((void *)0));
  } else {
#line 2014
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 2016
  while (1) {
#line 2016
    tmp___2 = packet_remaining();
#line 2016
    _len = tmp___2;
#line 2016
    if (_len > 0) {
#line 2016
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          2016);
#line 2016
      packet_disconnect("Packet integrity error.");
    }
#line 2016
    break;
  }
#line 2017
  sock = channel_connect_to((char const   *)host, host_port);
#line 2018
  if (sock != -1) {
#line 2019
    c = channel_new((char *)"connected socket", 12, sock, sock, -1, 0, 0, 0, originator_string,
                    1);
#line 2022
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2023
      error("channel_input_port_open: channel_new failed");
#line 2024
      close(sock);
    } else {
#line 2026
      c->remote_id = remote_id;
    }
  }
#line 2029
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2030
    packet_start((unsigned char)22);
#line 2031
    packet_put_int((unsigned int )remote_id);
#line 2032
    packet_send();
  }
#line 2034
  xfree((void *)host);
#line 2035
  return;
}
}
#line 2044 "channels.c"
int channel_request_local_forwarding(u_short listen_port , char const   *host_to_connect ,
                                     u_short port_to_connect , int gateway_ports ) 
{ int tmp ;

  {
#line 2048
  tmp = channel_request_forwarding((char const   *)((void *)0), listen_port, host_to_connect,
                                   port_to_connect, gateway_ports, 0);
#line 2048
  return (tmp);
}
}
#line 2058 "channels.c"
int channel_request_forwarding(char const   *listen_address , u_short listen_port ,
                               char const   *host_to_connect , u_short port_to_connect ,
                               int gateway_ports , int remote_fwd ) 
{ Channel *c ;
  int success ;
  int sock ;
  int on ;
  int type ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  char const   *host ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 2065
  on = 1;
#line 2071
  success = 0;
#line 2073
  if (remote_fwd) {
#line 2074
    host = listen_address;
#line 2075
    type = 11;
  } else {
#line 2077
    host = host_to_connect;
#line 2078
    type = 2;
  }
#line 2081
  tmp = strlen(host);
#line 2081
  if (tmp > 29U) {
#line 2082
    error("Forward host name too long.");
#line 2083
    return (success);
  }
#line 2091
  memset((void *)(& hints), 0, sizeof(hints));
#line 2092
  hints.ai_family = IPv4or6;
#line 2093
  if (gateway_ports) {
#line 2093
    hints.ai_flags = 1;
  } else {
#line 2093
    hints.ai_flags = 0;
  }
#line 2094
  hints.ai_socktype = 1;
#line 2095
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 2096
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2096
  if (tmp___0 != 0) {
#line 2097
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 2099
  ai = aitop;
#line 2099
  while (ai) {
#line 2100
    if (ai->ai_family != 2) {
#line 2100
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2102
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2102
    if (tmp___1 != 0) {
#line 2104
      error("channel_request_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 2108
    sock = socket(ai->ai_family, 1, 0);
#line 2109
    if (sock < 0) {
#line 2111
      tmp___2 = __errno_location();
#line 2111
      tmp___3 = strerror(*tmp___2);
#line 2111
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 2118
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 2119
    linger.l_onoff = 1;
#line 2120
    linger.l_linger = 5;
#line 2121
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 2122
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 2125
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2125
    if (tmp___8 < 0) {
#line 2127
      if (! ai->ai_next) {
#line 2128
        tmp___4 = __errno_location();
#line 2128
        tmp___5 = strerror(*tmp___4);
#line 2128
        error("bind: %.100s", tmp___5);
      } else {
#line 2130
        tmp___6 = __errno_location();
#line 2130
        tmp___7 = strerror(*tmp___6);
#line 2130
        verbose("bind: %.100s", tmp___7);
      }
#line 2132
      close(sock);
      goto __Cont;
    }
#line 2136
    tmp___11 = listen(sock, 5);
#line 2136
    if (tmp___11 < 0) {
#line 2137
      tmp___9 = __errno_location();
#line 2137
      tmp___10 = strerror(*tmp___9);
#line 2137
      error("listen: %.100s", tmp___10);
#line 2138
      close(sock);
      goto __Cont;
    }
#line 2142
    tmp___12 = xstrdup("port listener");
#line 2142
    c = channel_new((char *)"port listener", type, sock, sock, -1, 32768, 16384, 0,
                    tmp___12, 1);
#line 2145
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2146
      error("channel_request_forwarding: channel_new failed");
#line 2147
      close(sock);
      goto __Cont;
    }
#line 2150
    strlcpy(c->path, host, sizeof(c->path));
#line 2151
    c->host_port = (int )port_to_connect;
#line 2152
    c->listening_port = (int )listen_port;
#line 2153
    success = 1;
    __Cont: /* CIL Label */ 
#line 2099
    ai = ai->ai_next;
  }
#line 2155
  if (success == 0) {
#line 2156
    error("channel_request_forwarding: cannot listen to port: %d", listen_port);
  }
#line 2158
  freeaddrinfo(aitop);
#line 2159
  return (success);
}
}
#line 2167 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  int type ;
  int success ;
  char const   *address_to_bind ;

  {
#line 2171
  success = 0;
#line 2174
  if (num_permitted_opens >= 100) {
#line 2175
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2178
  if (compat20) {
#line 2179
    address_to_bind = "0.0.0.0";
#line 2180
    packet_start((unsigned char)80);
#line 2181
    packet_put_cstring("tcpip-forward");
#line 2182
    packet_put_char(0);
#line 2183
    packet_put_cstring(address_to_bind);
#line 2184
    packet_put_int((unsigned int )listen_port);
#line 2185
    packet_send();
#line 2186
    packet_write_wait();
#line 2188
    success = 1;
  } else {
#line 2190
    packet_start((unsigned char)28);
#line 2191
    packet_put_int((unsigned int )listen_port);
#line 2192
    packet_put_cstring(host_to_connect);
#line 2193
    packet_put_int((unsigned int )port_to_connect);
#line 2194
    packet_send();
#line 2195
    packet_write_wait();
#line 2198
    type = packet_read(& payload_len);
#line 2199
    switch (type) {
    case 14: 
#line 2201
    success = 1;
#line 2202
    break;
    case 15: 
#line 2204
    log("Warning: Server denied remote port forwarding.");
#line 2205
    break;
    default: 
#line 2208
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 2212
  if (success) {
#line 2213
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 2214
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 2215
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 2216
    num_permitted_opens ++;
  }
#line 2218
  return;
}
}
#line 2226 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 2233
  tmp = packet_get_int();
#line 2233
  port = (unsigned short )tmp;
#line 2234
  hostname = packet_get_string((u_int *)((void *)0));
#line 2235
  tmp___0 = packet_get_int();
#line 2235
  host_port = (unsigned short )tmp___0;
#line 2242
  if ((int )port < 1024) {
#line 2242
    if (! is_root) {
#line 2243
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 2247
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 2250
  xfree((void *)hostname);
#line 2251
  return;
}
}
#line 2258 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 2261
  if (num_permitted_opens == 0) {
#line 2262
    all_opens_permitted = 1;
  }
#line 2263
  return;
}
}
#line 2265 "channels.c"
void channel_add_permitted_opens(char *host , int port ) 
{ 

  {
#line 2268
  if (num_permitted_opens >= 100) {
#line 2269
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2270
  debug("allow port forwarding to host %s port %d", host, port);
#line 2272
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2273
  permitted_opens[num_permitted_opens].port_to_connect = (unsigned short )port;
#line 2274
  num_permitted_opens ++;
#line 2276
  all_opens_permitted = 0;
#line 2277
  return;
}
}
#line 2279 "channels.c"
void channel_clear_permitted_opens(void) 
{ int i ;

  {
#line 2284
  i = 0;
#line 2284
  while (i < num_permitted_opens) {
#line 2285
    xfree((void *)permitted_opens[i].host_to_connect);
#line 2284
    i ++;
  }
#line 2286
  num_permitted_opens = 0;
#line 2288
  return;
}
}
#line 2292 "channels.c"
static int connect_to(char const   *host , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 2298
  sock = -1;
#line 2300
  memset((void *)(& hints), 0, sizeof(hints));
#line 2301
  hints.ai_family = IPv4or6;
#line 2302
  hints.ai_socktype = 1;
#line 2303
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 2304
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2304
  if (gaierr != 0) {
#line 2305
    tmp = gai_strerror(gaierr);
#line 2305
    error("connect_to %.100s: unknown host (%s)", host, tmp);
#line 2307
    return (-1);
  }
#line 2309
  ai = aitop;
#line 2309
  while (ai) {
#line 2310
    if (ai->ai_family != 2) {
#line 2310
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2312
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2312
    if (tmp___0 != 0) {
#line 2314
      error("connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 2317
    sock = socket(ai->ai_family, 1, 0);
#line 2318
    if (sock < 0) {
#line 2319
      tmp___1 = __errno_location();
#line 2319
      tmp___2 = strerror(*tmp___1);
#line 2319
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 2322
    tmp___5 = fcntl(sock, 4, 2048);
#line 2322
    if (tmp___5 < 0) {
#line 2323
      tmp___3 = __errno_location();
#line 2323
      tmp___4 = strerror(*tmp___3);
#line 2323
      fatal("connect_to: F_SETFL: %s", tmp___4);
    }
#line 2324
    tmp___8 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2324
    if (tmp___8 < 0) {
#line 2324
      tmp___9 = __errno_location();
#line 2324
      if (*tmp___9 != 115) {
#line 2326
        tmp___6 = __errno_location();
#line 2326
        tmp___7 = strerror(*tmp___6);
#line 2326
        error("connect_to %.100s port %s: %.100s", ntop, strport, tmp___7);
#line 2328
        close(sock);
        goto __Cont;
      }
    }
#line 2331
    break;
    __Cont: /* CIL Label */ 
#line 2309
    ai = ai->ai_next;
  }
#line 2334
  freeaddrinfo(aitop);
#line 2335
  if (! ai) {
#line 2336
    error("connect_to %.100s port %d: failed.", host, port);
#line 2337
    return (-1);
  }
#line 2340
  return (sock);
}
}
#line 2343 "channels.c"
int channel_connect_by_listen_address(u_short listen_port ) 
{ int i ;
  int tmp ;

  {
#line 2348
  i = 0;
#line 2348
  while (i < num_permitted_opens) {
#line 2349
    if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 2350
      tmp = connect_to((char const   *)permitted_opens[i].host_to_connect, permitted_opens[i].port_to_connect);
#line 2350
      return (tmp);
    }
#line 2348
    i ++;
  }
#line 2353
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 2355
  return (-1);
}
}
#line 2359 "channels.c"
int channel_connect_to(char const   *host , u_short port ) 
{ int i ;
  int permit ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2364
  permit = all_opens_permitted;
#line 2365
  if (! permit) {
#line 2366
    i = 0;
#line 2366
    while (i < num_permitted_opens) {
#line 2368
      if ((int )permitted_opens[i].port_to_connect == (int )port) {
#line 2368
        if (0) {
#line 2368
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 2368
          __s2_len = strlen(host);
#line 2368
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 2368
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2368
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2368
                tmp___8 = 1;
              } else {
#line 2368
                if (__s2_len >= 4U) {
#line 2368
                  tmp___8 = 1;
                } else {
#line 2368
                  tmp___8 = 0;
                }
              }
            } else {
#line 2368
              tmp___8 = 0;
            }
          }
#line 2368
          if (tmp___8) {
#line 2368
            tmp___4 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
          } else {
#line 2368
            tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
#line 2368
            tmp___4 = tmp___7;
          }
        } else {
#line 2368
          tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     host);
#line 2368
          tmp___4 = tmp___7;
        }
#line 2368
        if (tmp___4 == 0) {
#line 2369
          permit = 1;
        }
      }
#line 2366
      i ++;
    }
  }
#line 2372
  if (! permit) {
#line 2373
    log("Received request to connect to host %.100s port %d, but the request was denied.",
        host, port);
#line 2375
    return (-1);
  }
#line 2377
  tmp___9 = connect_to(host, port);
#line 2377
  return (tmp___9);
}
}
#line 2387 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 2394
  num_socks = 0;
#line 2398
  display_number = x11_display_offset;
#line 2398
  while (display_number < 1000) {
#line 2401
    port = (unsigned short )(6000 + display_number);
#line 2402
    memset((void *)(& hints), 0, sizeof(hints));
#line 2403
    hints.ai_family = IPv4or6;
#line 2404
    hints.ai_flags = 1;
#line 2405
    hints.ai_socktype = 1;
#line 2406
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 2407
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2407
    if (gaierr != 0) {
#line 2408
      tmp = gai_strerror(gaierr);
#line 2408
      error("getaddrinfo: %.100s", tmp);
#line 2409
      return ((char *)((void *)0));
    }
#line 2411
    ai = aitop;
#line 2411
    while (ai) {
#line 2412
      if (ai->ai_family != 2) {
#line 2412
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 2414
      sock = socket(ai->ai_family, 1, 0);
#line 2415
      if (sock < 0) {
#line 2416
        tmp___2 = __errno_location();
#line 2416
        if (*tmp___2 != 22) {
#line 2416
          tmp___3 = __errno_location();
#line 2416
          if (*tmp___3 != 97) {
#line 2417
            tmp___0 = __errno_location();
#line 2417
            tmp___1 = strerror(*tmp___0);
#line 2417
            error("socket: %.100s", tmp___1);
#line 2418
            return ((char *)((void *)0));
          } else {
#line 2420
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 2420
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 2425
      tmp___6 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2425
      if (tmp___6 < 0) {
#line 2426
        tmp___4 = __errno_location();
#line 2426
        tmp___5 = strerror(*tmp___4);
#line 2426
        debug("bind port %d: %.100s", port, tmp___5);
#line 2427
        shutdown(sock, 2);
#line 2428
        close(sock);
#line 2430
        if (ai->ai_next) {
          goto __Cont;
        }
#line 2433
        n___0 = 0;
#line 2433
        while (n___0 < num_socks) {
#line 2434
          shutdown(socks[n___0], 2);
#line 2435
          close(socks[n___0]);
#line 2433
          n___0 ++;
        }
#line 2437
        num_socks = 0;
#line 2438
        break;
      }
#line 2440
      tmp___7 = num_socks;
#line 2440
      num_socks ++;
#line 2440
      socks[tmp___7] = sock;
#line 2445
      break;
      __Cont: /* CIL Label */ 
#line 2411
      ai = ai->ai_next;
    }
#line 2448
    freeaddrinfo(aitop);
#line 2449
    if (num_socks > 0) {
#line 2450
      break;
    }
#line 2398
    display_number ++;
  }
#line 2452
  if (display_number >= 1000) {
#line 2453
    error("Failed to allocate internet-domain X11 display socket.");
#line 2454
    return ((char *)((void *)0));
  }
#line 2457
  n___0 = 0;
#line 2457
  while (n___0 < num_socks) {
#line 2458
    sock = socks[n___0];
#line 2459
    tmp___10 = listen(sock, 5);
#line 2459
    if (tmp___10 < 0) {
#line 2460
      tmp___8 = __errno_location();
#line 2460
      tmp___9 = strerror(*tmp___8);
#line 2460
      error("listen: %.100s", tmp___9);
#line 2461
      shutdown(sock, 2);
#line 2462
      close(sock);
#line 2463
      return ((char *)((void *)0));
    }
#line 2457
    n___0 ++;
  }
#line 2468
  tmp___13 = gethostname(hostname, sizeof(hostname));
#line 2468
  if (tmp___13 < 0) {
#line 2469
    tmp___11 = __errno_location();
#line 2469
    tmp___12 = strerror(*tmp___11);
#line 2469
    fatal("gethostname: %.100s", tmp___12);
  }
#line 2506
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 2511
  n___0 = 0;
#line 2511
  while (n___0 < num_socks) {
#line 2512
    sock = socks[n___0];
#line 2513
    tmp___14 = xstrdup("X11 inet listener");
#line 2513
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___14,
                1);
#line 2511
    n___0 ++;
  }
#line 2520
  tmp___15 = xstrdup((char const   *)(display));
#line 2520
  return (tmp___15);
}
}
#line 2530
static int connect_local_xsocket(u_int dnr ) ;
#line 2530 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 2527 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2540
  path = x_sockets;
#line 2540
  while (*path) {
#line 2541
    sock = socket(1, 1, 0);
#line 2542
    if (sock < 0) {
#line 2543
      tmp = __errno_location();
#line 2543
      tmp___0 = strerror(*tmp);
#line 2543
      error("socket: %.100s", tmp___0);
    }
#line 2544
    memset((void *)(& addr), 0, sizeof(addr));
#line 2545
    addr.sun_family = (unsigned short)1;
#line 2546
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 2547
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 2547
    if (tmp___1 == 0) {
#line 2548
      return (sock);
    }
#line 2549
    close(sock);
#line 2540
    path ++;
  }
#line 2551
  tmp___2 = __errno_location();
#line 2551
  tmp___3 = strerror(*tmp___2);
#line 2551
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 2552
  return (-1);
}
}
#line 2555 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___2[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2558
  sock = 0;
#line 2566
  tmp = getenv("DISPLAY");
#line 2566
  display = (char const   *)tmp;
#line 2567
  if (! display) {
#line 2568
    error("DISPLAY not set.");
#line 2569
    return (-1);
  }
#line 2580
  if (0) {
#line 2580
    if (0) {
#line 2580
      __s1_len___0 = strlen(display);
#line 2580
      __s2_len___0 = strlen("unix:");
#line 2580
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 2580
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 2580
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 2580
            tmp___25 = 1;
          } else {
#line 2580
            if (__s2_len___0 >= 4U) {
#line 2580
              tmp___25 = 1;
            } else {
#line 2580
              tmp___25 = 0;
            }
          }
        } else {
#line 2580
          tmp___25 = 0;
        }
      }
#line 2580
      if (tmp___25) {
#line 2580
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 2580
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 2580
        tmp___21 = tmp___24;
      }
    } else {
#line 2580
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 2580
      tmp___21 = tmp___24;
    }
#line 2580
    tmp___15 = tmp___21;
  } else {
#line 2580
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 2580
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 2580
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 2583
      tmp___0 = strrchr(display, ':');
#line 2583
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 2583
      if (tmp___1 != 1) {
#line 2584
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 2586
        return (-1);
      }
#line 2589
      sock = connect_local_xsocket((unsigned int )display_number);
#line 2590
      if (sock < 0) {
#line 2591
        return (-1);
      }
#line 2594
      return (sock);
    }
  }
#line 2600
  __builtin_strncpy(buf___2, display, sizeof(buf___2));
#line 2601
  buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 2602
  tmp___29 = __builtin_strchr(buf___2, ':');
#line 2602
  cp = tmp___29;
#line 2603
  if (! cp) {
#line 2604
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 2605
    return (-1);
  }
#line 2607
  *cp = (char)0;
#line 2609
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 2609
  if (tmp___30 != 1) {
#line 2610
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 2612
    return (-1);
  }
#line 2616
  memset((void *)(& hints), 0, sizeof(hints));
#line 2617
  hints.ai_family = IPv4or6;
#line 2618
  hints.ai_socktype = 1;
#line 2619
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 2620
  gaierr = getaddrinfo((char const   * __restrict  )(buf___2), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2620
  if (gaierr != 0) {
#line 2621
    tmp___31 = gai_strerror(gaierr);
#line 2621
    error("%.100s: unknown host. (%s)", buf___2, tmp___31);
#line 2622
    return (-1);
  }
#line 2624
  ai = aitop;
#line 2624
  while (ai) {
#line 2626
    sock = socket(ai->ai_family, 1, 0);
#line 2627
    if (sock < 0) {
#line 2628
      tmp___32 = __errno_location();
#line 2628
      tmp___33 = strerror(*tmp___32);
#line 2628
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 2632
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 2632
    if (tmp___36 < 0) {
#line 2633
      tmp___34 = __errno_location();
#line 2633
      tmp___35 = strerror(*tmp___34);
#line 2633
      debug("connect %.100s port %d: %.100s", buf___2, 6000 + display_number, tmp___35);
#line 2635
      close(sock);
      goto __Cont;
    }
#line 2639
    break;
    __Cont: /* CIL Label */ 
#line 2624
    ai = ai->ai_next;
  }
#line 2641
  freeaddrinfo(aitop);
#line 2642
  if (! ai) {
#line 2643
    tmp___37 = __errno_location();
#line 2643
    tmp___38 = strerror(*tmp___37);
#line 2643
    error("connect %.100s port %d: %.100s", buf___2, 6000 + display_number, tmp___38);
#line 2645
    return (-1);
  }
#line 2647
  return (sock);
}
}
#line 2656 "channels.c"
void x11_input_open(int type , int plen , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *remote_host ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2659
  c = (Channel *)((void *)0);
#line 2660
  sock = 0;
#line 2663
  debug("Received X11 open request.");
#line 2665
  tmp = packet_get_int();
#line 2665
  remote_id = (int )tmp;
#line 2667
  tmp___0 = packet_get_protocol_flags();
#line 2667
  if (tmp___0 & 2U) {
#line 2668
    remote_host = packet_get_string((u_int *)((void *)0));
  } else {
#line 2670
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 2672
  while (1) {
#line 2672
    tmp___1 = packet_remaining();
#line 2672
    _len = tmp___1;
#line 2672
    if (_len > 0) {
#line 2672
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          2672);
#line 2672
      packet_disconnect("Packet integrity error.");
    }
#line 2672
    break;
  }
#line 2675
  sock = x11_connect_display();
#line 2676
  if (sock != -1) {
#line 2678
    c = channel_new((char *)"connected x11 socket", 7, sock, sock, -1, 0, 0, 0, remote_host,
                    1);
#line 2681
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2682
      error("x11_input_open: channel_new failed");
#line 2683
      close(sock);
    } else {
#line 2685
      c->remote_id = remote_id;
#line 2686
      c->force_drain = 1;
    }
  }
#line 2689
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2691
    packet_start((unsigned char)22);
#line 2692
    packet_put_int((unsigned int )remote_id);
  } else {
#line 2695
    packet_start((unsigned char)21);
#line 2696
    packet_put_int((unsigned int )remote_id);
#line 2697
    packet_put_int((unsigned int )c->self);
  }
#line 2699
  packet_send();
#line 2700
  return;
}
}
#line 2703 "channels.c"
void deny_input_open(int type , int plen , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 2706
  tmp = packet_get_int();
#line 2706
  rchan = (int )tmp;
#line 2707
  switch (type) {
  case 31: 
#line 2709
  error("Warning: ssh server tried agent forwarding.");
#line 2710
  break;
  case 27: 
#line 2712
  error("Warning: ssh server tried X11 forwarding.");
#line 2713
  break;
  default: 
#line 2715
  error("deny_input_open: type %d plen %d", type, plen);
#line 2716
  break;
  }
#line 2718
  error("Warning: this is probably a break in attempt by a malicious server.");
#line 2719
  packet_start((unsigned char)22);
#line 2720
  packet_put_int((unsigned int )rchan);
#line 2721
  packet_send();
#line 2722
  return;
}
}
#line 2729 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  u_int len ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2733
  tmp = strlen(data);
#line 2733
  data_len = tmp / 2U;
#line 2738
  rand___0 = (u_int32_t )0;
#line 2740
  tmp___0 = getenv("DISPLAY");
#line 2740
  cp = (char const   *)tmp___0;
#line 2741
  if (cp) {
#line 2742
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2742
    cp = (char const   *)tmp___2;
  }
#line 2743
  if (cp) {
#line 2744
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2744
    cp = (char const   *)tmp___4;
  }
#line 2745
  if (cp) {
#line 2746
    screen_number = atoi(cp + 1);
  } else {
#line 2748
    screen_number = 0;
  }
#line 2751
  x11_saved_proto = xstrdup(proto);
#line 2757
  tmp___5 = xmalloc(data_len);
#line 2757
  x11_saved_data = (char *)tmp___5;
#line 2758
  tmp___6 = xmalloc(data_len);
#line 2758
  x11_fake_data = (char *)tmp___6;
#line 2759
  i = 0U;
#line 2759
  while (i < data_len) {
#line 2760
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2760
    if (tmp___7 != 1) {
#line 2761
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2762
    if (i % 4U == 0U) {
#line 2763
      rand___0 = arc4random();
    }
#line 2764
    *(x11_saved_data + i) = (char )value;
#line 2765
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2766
    rand___0 >>= 8;
#line 2759
    i ++;
  }
#line 2768
  x11_saved_data_len = data_len;
#line 2769
  x11_fake_data_len = data_len;
#line 2772
  len = 2U * data_len + 1U;
#line 2773
  tmp___8 = xmalloc(len);
#line 2773
  new_data = (char *)tmp___8;
#line 2774
  i = 0U;
#line 2774
  while (i < data_len) {
#line 2775
    snprintf((char * __restrict  )(new_data + 2U * i), len - 2U * i, (char const   * __restrict  )"%02x",
             (unsigned char )*(x11_fake_data + i));
#line 2774
    i ++;
  }
#line 2779
  if (compat20) {
#line 2780
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2781
    packet_put_char(0);
  } else {
#line 2783
    packet_start((unsigned char)34);
  }
#line 2785
  packet_put_cstring(proto);
#line 2786
  packet_put_cstring((char const   *)new_data);
#line 2787
  packet_put_int((unsigned int )screen_number);
#line 2788
  packet_send();
#line 2789
  packet_write_wait();
#line 2790
  xfree((void *)new_data);
#line 2791
  return;
}
}
#line 2798 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2801
  packet_start((unsigned char)30);
#line 2802
  packet_send();
#line 2803
  packet_write_wait();
#line 2804
  return;
}
}
#line 2812 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2815
  return (auth_sock_name);
}
}
#line 2820 "channels.c"
void auth_sock_cleanup_proc(void *_pw ) 
{ struct passwd *pw ;

  {
#line 2823
  pw = (struct passwd *)_pw;
#line 2825
  if (auth_sock_name) {
#line 2826
    temporarily_use_uid(pw);
#line 2827
    unlink((char const   *)auth_sock_name);
#line 2828
    rmdir((char const   *)auth_sock_dir);
#line 2829
    auth_sock_name = (char *)((void *)0);
#line 2830
    restore_uid();
  }
#line 2832
  return;
}
}
#line 2839 "channels.c"
int auth_input_request_forwarding(struct passwd *pw ) 
{ Channel *nc ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
#line 2846
  tmp = auth_get_socket_name();
#line 2846
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2847
    error("authentication forwarding requested twice.");
#line 2848
    return (0);
  }
#line 2852
  temporarily_use_uid(pw);
#line 2855
  tmp___0 = xmalloc(4096U);
#line 2855
  auth_sock_name = (char *)tmp___0;
#line 2856
  tmp___1 = xmalloc(4096U);
#line 2856
  auth_sock_dir = (char *)tmp___1;
#line 2857
  strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXX", 4096U);
#line 2860
  tmp___4 = mkdtemp(auth_sock_dir);
#line 2860
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2861
    tmp___2 = __errno_location();
#line 2861
    tmp___3 = strerror(*tmp___2);
#line 2861
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___3);
#line 2863
    restore_uid();
#line 2864
    xfree((void *)auth_sock_name);
#line 2865
    xfree((void *)auth_sock_dir);
#line 2866
    auth_sock_name = (char *)((void *)0);
#line 2867
    auth_sock_dir = (char *)((void *)0);
#line 2868
    return (0);
  }
#line 2870
  tmp___5 = getpid();
#line 2870
  snprintf((char * __restrict  )auth_sock_name, 4096U, (char const   * __restrict  )"%s/agent.%d",
           auth_sock_dir, tmp___5);
#line 2874
  fatal_add_cleanup(& auth_sock_cleanup_proc, (void *)pw);
#line 2877
  sock = socket(1, 1, 0);
#line 2878
  if (sock < 0) {
#line 2879
    tmp___6 = __errno_location();
#line 2879
    tmp___7 = strerror(*tmp___6);
#line 2879
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2882
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2883
  sunaddr.sun_family = (unsigned short)1;
#line 2884
  __builtin_strncpy(sunaddr.sun_path, (char const   *)auth_sock_name, sizeof(sunaddr.sun_path));
#line 2887
  tmp___10 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2887
  if (tmp___10 < 0) {
#line 2888
    tmp___8 = __errno_location();
#line 2888
    tmp___9 = strerror(*tmp___8);
#line 2888
    packet_disconnect("bind: %.100s", tmp___9);
  }
#line 2891
  restore_uid();
#line 2894
  tmp___13 = listen(sock, 5);
#line 2894
  if (tmp___13 < 0) {
#line 2895
    tmp___11 = __errno_location();
#line 2895
    tmp___12 = strerror(*tmp___11);
#line 2895
    packet_disconnect("listen: %.100s", tmp___12);
  }
#line 2898
  tmp___14 = xstrdup("auth socket");
#line 2898
  nc = channel_new((char *)"auth socket", 6, sock, sock, -1, 4096, 2048, 0, tmp___14,
                   1);
#line 2902
  if ((unsigned int )nc == (unsigned int )((void *)0)) {
#line 2903
    error("auth_input_request_forwarding: channel_new failed");
#line 2904
    auth_sock_cleanup_proc((void *)pw);
#line 2905
    fatal_remove_cleanup(& auth_sock_cleanup_proc, (void *)pw);
#line 2906
    close(sock);
#line 2907
    return (0);
  }
#line 2909
  strlcpy(nc->path, (char const   *)auth_sock_name, sizeof(nc->path));
#line 2910
  return (1);
}
}
#line 2915 "channels.c"
void auth_input_open_request(int type , int plen , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *name ;
  int _p ;
  int _e ;
  u_int tmp ;

  {
#line 2918
  c = (Channel *)((void *)0);
#line 2922
  while (1) {
#line 2922
    _p = plen;
#line 2922
    _e = 4;
#line 2922
    if (_p != _e) {
#line 2922
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2922);
#line 2922
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2922
    break;
  }
#line 2925
  tmp = packet_get_int();
#line 2925
  remote_id = (int )tmp;
#line 2931
  sock = ssh_get_authentication_socket();
#line 2939
  if (sock >= 0) {
#line 2940
    name = xstrdup("authentication agent connection");
#line 2941
    c = channel_new((char *)"", 4, sock, sock, -1, 0, 0, 0, name, 1);
#line 2943
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2944
      error("auth_input_open_request: channel_new failed");
#line 2945
      xfree((void *)name);
#line 2946
      close(sock);
    } else {
#line 2948
      c->remote_id = remote_id;
#line 2949
      c->force_drain = 1;
    }
  }
#line 2952
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2953
    packet_start((unsigned char)22);
#line 2954
    packet_put_int((unsigned int )remote_id);
  } else {
#line 2957
    debug("Forwarding authentication connection.");
#line 2958
    packet_start((unsigned char)21);
#line 2959
    packet_put_int((unsigned int )remote_id);
#line 2960
    packet_put_int((unsigned int )c->self);
  }
#line 2962
  packet_send();
#line 2963
  return;
}
}
#line 1 "cipher.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 141 "/usr/include/openssl/des.h"
extern void DES_ncbc_encrypt(unsigned char const   *input , unsigned char *output ,
                             long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                             int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 47 "rijndael.h"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int encrypt ) ;
#line 48
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 49
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 107 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 108
Cipher *cipher_by_name(char const   *name ) ;
#line 110
int cipher_number(char const   *name ) ;
#line 111
char *cipher_name(int id ) ;
#line 112
int ciphers_valid(char const   *names ) ;
#line 113
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 47 "cipher.c"
static void none_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 50
  return;
}
}
#line 51 "cipher.c"
static void none_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 54
  return;
}
}
#line 55 "cipher.c"
static void none_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 58
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 59
  return;
}
}
#line 65
static void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) ;
#line 65 "cipher.c"
static int dowarn  =    1;
#line 62 "cipher.c"
static void des_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 66
  if (dowarn) {
#line 67
    error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 69
    dowarn = 0;
  }
#line 71
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des.key);
#line 72
  return;
}
}
#line 73 "cipher.c"
static void des_ssh1_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 76
  memset((void *)(cc->u.des.iv), 0, sizeof(cc->u.des.iv));
#line 77
  return;
}
}
#line 78 "cipher.c"
static void des_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                             u_int len ) 
{ 

  {
#line 81
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 1);
#line 83
  return;
}
}
#line 84 "cipher.c"
static void des_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                             u_int len ) 
{ 

  {
#line 87
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des.key, & cc->u.des.iv, 0);
#line 89
  return;
}
}
#line 92 "cipher.c"
static void des3_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 95
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 96
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 97
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
#line 98
  return;
}
}
#line 99 "cipher.c"
static void des3_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 102
  memset((void *)(cc->u.des3.iv1), 0, sizeof(cc->u.des3.iv1));
#line 103
  memset((void *)(cc->u.des3.iv2), 0, sizeof(cc->u.des3.iv2));
#line 104
  memset((void *)(cc->u.des3.iv3), 0, sizeof(cc->u.des3.iv3));
#line 105
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 106
    return;
  }
#line 107
  memcpy((void * __restrict  )(cc->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 108
  return;
}
}
#line 109 "cipher.c"
static void des3_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                             u_int len ) 
{ 

  {
#line 112
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 1);
#line 115
  return;
}
}
#line 116 "cipher.c"
static void des3_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                             u_int len ) 
{ 

  {
#line 119
  DES_ede3_cbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.key2,
                       & cc->u.des3.key3, & cc->u.des3.iv3, 0);
#line 122
  return;
}
}
#line 138 "cipher.c"
static void des3_ssh1_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 141
  DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key1);
#line 142
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & cc->u.des3.key2);
#line 143
  if (keylen <= 16U) {
#line 144
    DES_set_key((const_DES_cblock *)((void *)key), & cc->u.des3.key3);
  } else {
#line 146
    DES_set_key((const_DES_cblock *)((void *)(key + 16)), & cc->u.des3.key3);
  }
#line 147
  return;
}
}
#line 148 "cipher.c"
static void des3_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                              u_int len ) 
{ 

  {
#line 152
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des3.key1, & cc->u.des3.iv1, 1);
#line 154
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                   & cc->u.des3.iv2, 0);
#line 156
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key3,
                   & cc->u.des3.iv3, 1);
#line 158
  return;
}
}
#line 159 "cipher.c"
static void des3_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                              u_int len ) 
{ 

  {
#line 163
  DES_ncbc_encrypt(src, dest, (long )len, & cc->u.des3.key3, & cc->u.des3.iv3, 0);
#line 165
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key2,
                   & cc->u.des3.iv2, 1);
#line 167
  DES_ncbc_encrypt((unsigned char const   *)dest, dest, (long )len, & cc->u.des3.key1,
                   & cc->u.des3.iv1, 0);
#line 169
  return;
}
}
#line 172 "cipher.c"
static void blowfish_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 175
  BF_set_key(& cc->u.bf.key, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 176
  return;
}
}
#line 177 "cipher.c"
static void blowfish_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 180
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 181
    memset((void *)(cc->u.bf.iv), 0, 8U);
  } else {
#line 183
    memcpy((void * __restrict  )(cc->u.bf.iv), (void const   * __restrict  )((char *)iv),
           8U);
  }
#line 184
  return;
}
}
#line 185 "cipher.c"
static void blowfish_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                                 u_int len ) 
{ 

  {
#line 189
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 191
  return;
}
}
#line 192 "cipher.c"
static void blowfish_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                                 u_int len ) 
{ 

  {
#line 196
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 198
  return;
}
}
#line 204 "cipher.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 210
  n___0 /= 4;
#line 210
  while (n___0 > 0) {
#line 211
    tmp = src;
#line 211
    src ++;
#line 211
    c[3] = (char )*tmp;
#line 212
    tmp___0 = src;
#line 212
    src ++;
#line 212
    c[2] = (char )*tmp___0;
#line 213
    tmp___1 = src;
#line 213
    src ++;
#line 213
    c[1] = (char )*tmp___1;
#line 214
    tmp___2 = src;
#line 214
    src ++;
#line 214
    c[0] = (char )*tmp___2;
#line 216
    tmp___3 = dst;
#line 216
    dst ++;
#line 216
    *tmp___3 = (unsigned char )c[0];
#line 217
    tmp___4 = dst;
#line 217
    dst ++;
#line 217
    *tmp___4 = (unsigned char )c[1];
#line 218
    tmp___5 = dst;
#line 218
    dst ++;
#line 218
    *tmp___5 = (unsigned char )c[2];
#line 219
    tmp___6 = dst;
#line 219
    dst ++;
#line 219
    *tmp___6 = (unsigned char )c[3];
#line 210
    n___0 --;
  }
#line 221
  return;
}
}
#line 223 "cipher.c"
static void blowfish_ssh1_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                                  u_int len ) 
{ 

  {
#line 227
  swap_bytes(src, dest, (int )len);
#line 228
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 1);
#line 230
  swap_bytes((u_char const   *)dest, dest, (int )len);
#line 231
  return;
}
}
#line 232 "cipher.c"
static void blowfish_ssh1_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                                  u_int len ) 
{ 

  {
#line 236
  swap_bytes(src, dest, (int )len);
#line 237
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& cc->u.bf.key),
                 cc->u.bf.iv, 0);
#line 239
  swap_bytes((u_char const   *)dest, dest, (int )len);
#line 240
  return;
}
}
#line 243 "cipher.c"
static void arcfour_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 246
  RC4_set_key(& cc->u.rc4, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 247
  return;
}
}
#line 248 "cipher.c"
static void arcfour_crypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                          u_int len ) 
{ 

  {
#line 251
  RC4(& cc->u.rc4, (unsigned long )len, (unsigned char const   *)((u_char *)src),
      dest);
#line 252
  return;
}
}
#line 255 "cipher.c"
static void cast_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 258
  CAST_set_key(& cc->u.cast.key, (int )keylen, (unsigned char const   *)((u_char *)key));
#line 259
  return;
}
}
#line 260 "cipher.c"
static void cast_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 263
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 264
    fatal("no IV for %s.", (cc->cipher)->name);
  }
#line 265
  memcpy((void * __restrict  )(cc->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 266
  return;
}
}
#line 267 "cipher.c"
static void cast_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                             u_int len ) 
{ 

  {
#line 270
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 1);
#line 272
  return;
}
}
#line 273 "cipher.c"
static void cast_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                             u_int len ) 
{ 

  {
#line 276
  CAST_cbc_encrypt(src, dest, (long )len, & cc->u.cast.key, cc->u.cast.iv, 0);
#line 278
  return;
}
}
#line 283 "cipher.c"
static void rijndael_setkey(CipherContext *cc , u_char const   *key , u_int keylen ) 
{ 

  {
#line 286
  rijndael_set_key(& cc->u.rijndael.enc, (u_char *)((char *)key), (int )(8U * keylen),
                   1);
#line 287
  rijndael_set_key(& cc->u.rijndael.dec, (u_char *)((char *)key), (int )(8U * keylen),
                   0);
#line 288
  return;
}
}
#line 289 "cipher.c"
static void rijndael_setiv(CipherContext *cc , u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 292
  if ((unsigned int )iv == (unsigned int )((void *)0)) {
#line 293
    fatal("bad/no IV for %s.", (cc->cipher)->name);
  } else {
#line 292
    if (ivlen != 16U) {
#line 293
      fatal("bad/no IV for %s.", (cc->cipher)->name);
    }
  }
#line 294
  memcpy((void * __restrict  )(cc->u.rijndael.iv), (void const   * __restrict  )iv,
         16U);
#line 295
  return;
}
}
#line 296 "cipher.c"
static void rijndael_cbc_encrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                                 u_int len ) 
{ rijndael_ctx *ctx ;
  u_char *iv ;
  u_char in[16] ;
  u_char *cprev ;
  u_char *cnow ;
  u_char *plain ;
  int i ;
  int j ;
  int blocks ;

  {
#line 300
  ctx = & cc->u.rijndael.enc;
#line 301
  iv = cc->u.rijndael.iv;
#line 304
  blocks = (int )(len / 16U);
#line 306
  if (len == 0U) {
#line 307
    return;
  }
#line 308
  if (len % 16U) {
#line 309
    fatal("rijndael_cbc_encrypt: bad len %d", len);
  }
#line 310
  cnow = dest;
#line 311
  plain = (u_char *)src;
#line 312
  cprev = iv;
#line 313
  i = 0;
#line 313
  while (i < blocks) {
#line 315
    j = 0;
#line 315
    while (j < 16) {
#line 316
      in[j] = (unsigned char )((int )*(plain + j) ^ (int )*(cprev + j));
#line 315
      j ++;
    }
#line 317
    rijndael_encrypt(ctx, in, cnow);
#line 318
    cprev = cnow;
#line 313
    i ++;
#line 313
    plain += 16;
#line 313
    cnow += 16;
  }
#line 320
  memcpy((void * __restrict  )iv, (void const   * __restrict  )cprev, 16U);
#line 321
  return;
}
}
#line 322 "cipher.c"
static void rijndael_cbc_decrypt(CipherContext *cc , u_char *dest , u_char const   *src ,
                                 u_int len ) 
{ rijndael_ctx *ctx ;
  u_char *iv ;
  u_char ivsaved[16] ;
  u_char *cnow ;
  u_char *plain ;
  u_char *ivp ;
  int i ;
  int j ;
  int blocks ;

  {
#line 326
  ctx = & cc->u.rijndael.dec;
#line 327
  iv = cc->u.rijndael.iv;
#line 329
  cnow = (u_char *)((src + len) - 16);
#line 330
  plain = (dest + len) - 16;
#line 332
  blocks = (int )(len / 16U);
#line 334
  if (len == 0U) {
#line 335
    return;
  }
#line 336
  if (len % 16U) {
#line 337
    fatal("rijndael_cbc_decrypt: bad len %d", len);
  }
#line 338
  memcpy((void * __restrict  )(ivsaved), (void const   * __restrict  )cnow, 16U);
#line 339
  i = blocks;
#line 339
  while (i > 0) {
#line 341
    rijndael_decrypt(ctx, cnow, plain);
#line 342
    if (i == 1) {
#line 342
      ivp = iv;
    } else {
#line 342
      ivp = cnow - 16;
    }
#line 343
    j = 0;
#line 343
    while (j < 16) {
#line 344
      *(plain + j) = (unsigned char )((int )*(plain + j) ^ (int )*(ivp + j));
#line 343
      j ++;
    }
#line 339
    i --;
#line 339
    cnow -= 16;
#line 339
    plain -= 16;
  }
#line 346
  memcpy((void * __restrict  )iv, (void const   * __restrict  )(ivsaved), 16U);
#line 347
  return;
}
}
#line 349 "cipher.c"
Cipher ciphers[16]  = 
#line 349
  {      {(char *)"none", 0, (u_int )8, (u_int )0, & none_setkey, & none_setiv, & none_crypt,
      & none_crypt}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, & des_ssh1_setkey, & des_ssh1_setiv,
      & des_ssh1_encrypt, & des_ssh1_decrypt}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, & des3_ssh1_setkey, & des3_setiv,
      & des3_ssh1_encrypt, & des3_ssh1_decrypt}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_ssh1_encrypt, & blowfish_ssh1_decrypt}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, & des3_setkey, & des3_setiv,
      & des3_cbc_encrypt, & des3_cbc_decrypt}, 
        {(char *)"blowfish-cbc", -3, (u_int )8, (u_int )16, & blowfish_setkey, & blowfish_setiv,
      & blowfish_cbc_encrypt, & blowfish_cbc_decrypt}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, & cast_setkey, & cast_setiv,
      & cast_cbc_encrypt, & cast_cbc_decrypt}, 
        {(char *)"arcfour", -3, (u_int )8, (u_int )16, & arcfour_setkey, & none_setiv,
      & arcfour_crypt, & arcfour_crypt}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael128-cbc", -3, (u_int )16, (u_int )16, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael192-cbc", -3, (u_int )16, (u_int )24, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael256-cbc", -3, (u_int )16, (u_int )32, & rijndael_setkey, & rijndael_setiv,
      & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)"rijndael-cbc@lysator.liu.se", -3, (u_int )16, (u_int )32, & rijndael_setkey,
      & rijndael_setiv, & rijndael_cbc_encrypt, & rijndael_cbc_decrypt}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (void (*)(CipherContext * , u_char const   * ,
                                                               u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char const   * , u_int  ))((void *)0), (void (*)(CipherContext * ,
                                                                                     u_char * ,
                                                                                     u_char const   * ,
                                                                                     u_int  ))((void *)0),
      (void (*)(CipherContext * , u_char * , u_char const   * , u_int  ))((void *)0)}};
#line 416 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 419
  mask = (u_int )0;
#line 420
  mask |= (unsigned int )(1 << 3);
#line 421
  mask |= (unsigned int )(1 << 6);
#line 422
  if (client) {
#line 423
    mask |= (unsigned int )(1 << 2);
  }
#line 425
  return (mask);
}
}
#line 428 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 432
  c = ciphers;
#line 432
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 433
    tmp = strcasecmp((char const   *)c->name, name);
#line 433
    if (tmp == 0) {
#line 434
      return (c);
    }
#line 432
    c ++;
  }
#line 435
  return ((Cipher *)((void *)0));
}
}
#line 438 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 442
  c = ciphers;
#line 442
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 443
    if (c->number == id) {
#line 444
      return (c);
    }
#line 442
    c ++;
  }
#line 445
  return ((Cipher *)((void *)0));
}
}
#line 449 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *ciphers___0 ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 456
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 457
    return (0);
  } else {
#line 456
    if (0) {
#line 456
      __s1_len = strlen(names);
#line 456
      __s2_len = strlen("");
#line 456
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 456
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 456
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 456
            tmp___8 = 1;
          } else {
#line 456
            if (__s2_len >= 4U) {
#line 456
              tmp___8 = 1;
            } else {
#line 456
              tmp___8 = 0;
            }
          }
        } else {
#line 456
          tmp___8 = 0;
        }
      }
#line 456
      if (tmp___8) {
#line 456
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 456
        tmp___7 = __builtin_strcmp(names, "");
#line 456
        tmp___4 = tmp___7;
      }
    } else {
#line 456
      tmp___7 = __builtin_strcmp(names, "");
#line 456
      tmp___4 = tmp___7;
    }
#line 456
    if (tmp___4 == 0) {
#line 457
      return (0);
    }
  }
#line 458
  cp = xstrdup(names);
#line 458
  ciphers___0 = cp;
#line 459
  tmp___24 = __strsep_g(& cp, ",");
#line 459
  p = tmp___24;
#line 459
  while (1) {
#line 459
    if (p) {
#line 459
      if (! ((int )*p != 0)) {
#line 459
        break;
      }
    } else {
#line 459
      break;
    }
#line 461
    c = cipher_by_name((char const   *)p);
#line 462
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 463
      debug("bad cipher %s [%s]", p, names);
#line 464
      xfree((void *)ciphers___0);
#line 465
      return (0);
    } else {
#line 462
      if (c->number != -3) {
#line 463
        debug("bad cipher %s [%s]", p, names);
#line 464
        xfree((void *)ciphers___0);
#line 465
        return (0);
      } else {
#line 467
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 460
    tmp___40 = __strsep_g(& cp, ",");
#line 460
    p = tmp___40;
  }
#line 470
  debug3("ciphers ok: [%s]", names);
#line 471
  xfree((void *)ciphers___0);
#line 472
  return (1);
}
}
#line 480 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 484
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 485
    return (-1);
  }
#line 486
  c = cipher_by_name(name);
#line 487
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 487
    tmp = -1;
  } else {
#line 487
    tmp = c->number;
  }
#line 487
  return (tmp);
}
}
#line 490 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 493
  tmp = cipher_by_number(id);
#line 493
  c = tmp;
#line 494
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 494
    tmp___0 = "<unknown>";
  } else {
#line 494
    tmp___0 = (char const   *)c->name;
  }
#line 494
  return ((char *)tmp___0);
}
}
#line 497 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen ) 
{ 

  {
#line 501
  if (keylen < cipher->key_len) {
#line 502
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 504
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 504
    if (ivlen < cipher->block_size) {
#line 505
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 507
  cc->cipher = cipher;
#line 508
  (*(cipher->setkey))(cc, key, keylen);
#line 509
  (*(cipher->setiv))(cc, iv, ivlen);
#line 510
  return;
}
}
#line 512 "cipher.c"
void cipher_encrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 515
  if (len % (cc->cipher)->block_size) {
#line 516
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 517
  (*((cc->cipher)->encrypt))(cc, dest, src, len);
#line 518
  return;
}
}
#line 520 "cipher.c"
void cipher_decrypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ 

  {
#line 523
  if (len % (cc->cipher)->block_size) {
#line 524
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 525
  (*((cc->cipher)->decrypt))(cc, dest, src, len);
#line 526
  return;
}
}
#line 533 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 540
  MD5_Init(& md);
#line 541
  tmp = strlen(passphrase);
#line 541
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 542
  MD5_Final(digest___1, & md);
#line 544
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U);
#line 546
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 547
  memset((void *)(& md), 0, sizeof(md));
#line 548
  return;
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 537 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 541
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 546
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 549
extern void regfree(regex_t *__preg ) ;
#line 55 "compat.h"
void enable_compat13(void) ;
#line 56
void enable_compat20(void) ;
#line 57
void compat_datafellows(char const   *version ) ;
#line 58
int proto_spec(char const   *spec ) ;
#line 59
char *compat_cipher_proposal(char *cipher_prop ) ;
#line 43 "compat.c"
int compat13  =    0;
#line 44 "compat.c"
int compat20  =    0;
#line 45 "compat.c"
int datafellows  =    0;
#line 47 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 50
  verbose("Enabling compatibility mode for protocol 2.0");
#line 51
  compat20 = 1;
#line 52
  return;
}
}
#line 53 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 56
  verbose("Enabling compatibility mode for protocol 1.3");
#line 57
  compat13 = 1;
#line 58
  return;
}
}
#line 66 "compat.c"
static struct __anonstruct_check_68 check[29]  = 
#line 66
  {      {(char *)"^OpenSSH[-_]2\\.[012]", 49296}, 
        {(char *)"^OpenSSH_2\\.3\\.0", 53376}, 
        {(char *)"^OpenSSH_2\\.3\\.", 53248}, 
        {(char *)"^OpenSSH_2\\.5\\.[01]p1", 53248}, 
        {(char *)"^OpenSSH_2\\.5\\.[012]", 49152}, 
        {(char *)"^OpenSSH_2\\.5\\.3", 32768}, 
        {(char *)"^OpenSSH", 0}, 
        {(char *)"MindTerm", 0}, 
        {(char *)"^2\\.1\\.0", 73813}, 
        {(char *)"^2\\.1 ", 73813}, 
        {(char *)"^2\\.0\\.1[3-9]", 1253983}, 
        {(char *)"^2\\.0\\.1[1-2]", 1188479}, 
        {(char *)"^2\\.0\\.", 1450623}, 
        {(char *)"^2\\.[23]\\.0", 8260}, 
        {(char *)"^2\\.3\\.", 8256}, 
        {(char *)"^2\\.[2-9]\\.", 64}, 
        {(char *)"^3\\.0\\.", 64}, 
        {(char *)"^2\\.4$", 16}, 
        {(char *)"^3\\.0 SecureCRT", 16}, 
        {(char *)"^1\\.7 SecureFX", 16}, 
        {(char *)"^1\\.2\\.1[89]", 256}, 
        {(char *)"^1\\.2\\.2[012]", 256}, 
        {(char *)"^1\\.3\\.2", 256}, 
        {(char *)"^SSH Compatible Server", 1024}, 
        {(char *)"^OSU_0", 1024}, 
        {(char *)"^OSU_1\\.[0-4]", 1024}, 
        {(char *)"^OSU_1\\.5alpha[1-3]", 1024}, 
        {(char *)"^SSH_Version_Mapper", 2048}, 
        {(char *)((void *)0), 0}};
#line 60 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  int ret ;
  char ebuf[1024] ;
  regex_t reg ;

  {
#line 132
  i = 0;
#line 132
  while (check[i].pat) {
#line 133
    ret = regcomp((regex_t * __restrict  )(& reg), (char const   * __restrict  )check[i].pat,
                  1 | (((1 << 1) << 1) << 1));
#line 134
    if (ret != 0) {
#line 135
      regerror(ret, (regex_t const   * __restrict  )(& reg), (char * __restrict  )(ebuf),
               sizeof(ebuf));
#line 136
      ebuf[sizeof(ebuf) - 1U] = (char )'\000';
#line 137
      error("regerror: %s", ebuf);
      goto __Cont;
    }
#line 140
    ret = regexec((regex_t const   * __restrict  )(& reg), (char const   * __restrict  )version,
                  0U, (regmatch_t * __restrict  )((void *)0), 0);
#line 141
    regfree(& reg);
#line 142
    if (ret == 0) {
#line 143
      debug("match: %s pat %s", version, check[i].pat);
#line 144
      datafellows = check[i].bugs;
#line 145
      return;
    }
    __Cont: /* CIL Label */ 
#line 132
    i ++;
  }
#line 148
  debug("no match: %s", version);
#line 149
  return;
}
}
#line 152 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 156
  ret = 0;
#line 158
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 159
    return (ret);
  }
#line 160
  s = xstrdup(spec);
#line 160
  q = s;
#line 161
  tmp___14 = __strsep_g(& q, ",");
#line 161
  p = tmp___14;
#line 161
  while (1) {
#line 161
    if (p) {
#line 161
      if (! ((int )*p != 0)) {
#line 161
        break;
      }
    } else {
#line 161
      break;
    }
#line 162
    tmp___31 = atoi((char const   *)p);
#line 162
    switch (tmp___31) {
    case 1: 
#line 164
    if (ret == 0) {
#line 165
      ret |= 2;
    }
#line 166
    ret |= 1;
#line 167
    break;
    case 2: 
#line 169
    ret |= 4;
#line 170
    break;
    default: 
#line 172
    log("ignoring bad proto spec: \'%s\'.", p);
#line 173
    break;
    }
#line 161
    tmp___30 = __strsep_g(& q, ",");
#line 161
    p = tmp___30;
  }
#line 176
  xfree((void *)s);
#line 177
  return (ret);
}
}
#line 180 "compat.c"
char *compat_cipher_proposal(char *cipher_prop ) 
{ char *orig_prop ;
  char *fix_ciphers ;
  char *cp ;
  char *tmp ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___41 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___69 ;

  {
#line 187
  if (! (datafellows & 4096)) {
#line 188
    return (cipher_prop);
  }
#line 190
  tmp___0 = strlen((char const   *)cipher_prop);
#line 190
  len = tmp___0 + 1U;
#line 191
  tmp___1 = xmalloc(len);
#line 191
  fix_ciphers = (char *)tmp___1;
#line 192
  *fix_ciphers = (char )'\000';
#line 193
  orig_prop = xstrdup((char const   *)cipher_prop);
#line 193
  tmp = orig_prop;
#line 194
  while (1) {
#line 194
    tmp___69 = __strsep_g(& tmp, ",");
#line 194
    cp = tmp___69;
#line 194
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 194
      break;
    }
#line 195
    if (0) {
#line 195
      if (0) {
#line 195
        __s1_len___0 = strlen((char const   *)cp);
#line 195
        __s2_len___0 = strlen("aes");
#line 195
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 195
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 195
            if (! ((unsigned int )((void const   *)("aes" + 1)) - (unsigned int )((void const   *)"aes") == 1U)) {
#line 195
              tmp___25 = 1;
            } else {
#line 195
              if (__s2_len___0 >= 4U) {
#line 195
                tmp___25 = 1;
              } else {
#line 195
                tmp___25 = 0;
              }
            }
          } else {
#line 195
            tmp___25 = 0;
          }
        }
#line 195
        if (tmp___25) {
#line 195
          tmp___21 = __builtin_strcmp((char const   *)cp, "aes");
        } else {
#line 195
          tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 195
          tmp___21 = tmp___24;
        }
      } else {
#line 195
        tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 195
        tmp___21 = tmp___24;
      }
#line 195
      tmp___15 = tmp___21;
    } else {
#line 195
      tmp___15 = strncmp((char const   *)cp, "aes", 3U);
    }
#line 195
    if (tmp___15) {
#line 195
      if (0) {
#line 195
        if (0) {
#line 195
          __s1_len___2 = strlen((char const   *)cp);
#line 195
          __s2_len___2 = strlen("rijndael");
#line 195
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___6;
          } else {
#line 195
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 195
              if (! ((unsigned int )((void const   *)("rijndael" + 1)) - (unsigned int )((void const   *)"rijndael") == 1U)) {
#line 195
                tmp___51 = 1;
              } else {
#line 195
                if (__s2_len___2 >= 4U) {
#line 195
                  tmp___51 = 1;
                } else {
#line 195
                  tmp___51 = 0;
                }
              }
            } else {
#line 195
              tmp___51 = 0;
            }
          }
#line 195
          if (tmp___51) {
#line 195
            tmp___47 = __builtin_strcmp((char const   *)cp, "rijndael");
          } else {
#line 195
            tmp___50 = __builtin_strcmp((char const   *)cp, "rijndael");
#line 195
            tmp___47 = tmp___50;
          }
        } else {
#line 195
          tmp___50 = __builtin_strcmp((char const   *)cp, "rijndael");
#line 195
          tmp___47 = tmp___50;
        }
#line 195
        tmp___41 = tmp___47;
      } else {
#line 195
        tmp___41 = strncmp((char const   *)cp, "rijndael", 8U);
      }
#line 195
      if (tmp___41) {
#line 196
        if (*fix_ciphers) {
#line 197
          strlcat(fix_ciphers, ",", len);
        }
#line 198
        strlcat(fix_ciphers, (char const   *)cp, len);
      }
    }
  }
#line 201
  xfree((void *)orig_prop);
#line 202
  debug2("Original cipher proposal: %s", cipher_prop);
#line 203
  debug2("Compat cipher proposal: %s", fix_ciphers);
#line 204
  if (! *fix_ciphers) {
#line 205
    fatal("No available ciphers found.");
  }
#line 207
  return (fix_ciphers);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 19 "compress.h"
void buffer_compress_init_send(int level ) ;
#line 20
void buffer_compress_init_recv(void) ;
#line 21
void buffer_compress_uninit(void) ;
#line 22
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 23
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 22 "compress.c"
static z_stream incoming_stream  ;
#line 23 "compress.c"
static z_stream outgoing_stream  ;
#line 24 "compress.c"
static int compress_init_send_called  =    0;
#line 25 "compress.c"
static int compress_init_recv_called  =    0;
#line 32 "compress.c"
void buffer_compress_init_send(int level ) 
{ 

  {
#line 35
  if (compress_init_send_called == 1) {
#line 36
    deflateEnd(& incoming_stream);
  }
#line 37
  compress_init_send_called = 1;
#line 38
  debug("Enabling compression at level %d.", level);
#line 39
  if (level < 1) {
#line 40
    fatal("Bad compression level %d.", level);
  } else {
#line 39
    if (level > 9) {
#line 40
      fatal("Bad compression level %d.", level);
    }
  }
#line 41
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 42
  return;
}
}
#line 43 "compress.c"
void buffer_compress_init_recv(void) 
{ 

  {
#line 46
  if (compress_init_recv_called == 1) {
#line 47
    inflateEnd(& incoming_stream);
  }
#line 48
  compress_init_recv_called = 1;
#line 49
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 50
  return;
}
}
#line 54 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 57
  if (outgoing_stream.total_in == 0UL) {
#line 57
    tmp = 0.0;
  } else {
#line 57
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 57
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 61
  if (incoming_stream.total_out == 0UL) {
#line 61
    tmp___0 = 0.0;
  } else {
#line 61
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 61
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 65
  if (compress_init_recv_called == 1) {
#line 66
    inflateEnd(& incoming_stream);
  }
#line 67
  if (compress_init_send_called == 1) {
#line 68
    deflateEnd(& outgoing_stream);
  }
#line 69
  return;
}
}
#line 80 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___2[4096] ;
  int status ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 87
  tmp = buffer_len(input_buffer);
#line 87
  if (tmp == 0U) {
#line 88
    return;
  }
#line 91
  tmp___0 = buffer_ptr(input_buffer);
#line 91
  outgoing_stream.next_in = (u_char *)tmp___0;
#line 92
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 95
  while (1) {
#line 97
    outgoing_stream.next_out = (u_char *)(buf___2);
#line 98
    outgoing_stream.avail_out = sizeof(buf___2);
#line 101
    status = deflate(& outgoing_stream, 1);
#line 102
    switch (status) {
    case 0: 
#line 105
    buffer_append(output_buffer, (char const   *)(buf___2), sizeof(buf___2) - outgoing_stream.avail_out);
#line 107
    break;
    default: 
#line 109
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 95
    if (! (outgoing_stream.avail_out == 0U)) {
#line 95
      break;
    }
  }
#line 113
  return;
}
}
#line 124 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___2[4096] ;
  int status ;
  char *tmp ;

  {
#line 130
  tmp = buffer_ptr(input_buffer);
#line 130
  incoming_stream.next_in = (u_char *)tmp;
#line 131
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 133
  while (1) {
#line 135
    incoming_stream.next_out = (u_char *)(buf___2);
#line 136
    incoming_stream.avail_out = sizeof(buf___2);
#line 138
    status = inflate(& incoming_stream, 1);
#line 139
    switch (status) {
    case 0: 
#line 141
    buffer_append(output_buffer, (char const   *)(buf___2), sizeof(buf___2) - incoming_stream.avail_out);
#line 143
    break;
    case -5: 
#line 150
    return;
    default: 
#line 152
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 19 "crc32.h"
u_int ssh_crc32(u_char const   *s , u_int len ) ;
#line 46 "crc32.c"
static u_int crc32_tab[256]  = 
#line 46 "crc32.c"
  {      (u_int )0L,      (u_int )1996959894L,      (u_int )3993919788UL,      (u_int )2567524794UL, 
        (u_int )124634137L,      (u_int )1886057615L,      (u_int )3915621685UL,      (u_int )2657392035UL, 
        (u_int )249268274L,      (u_int )2044508324L,      (u_int )3772115230UL,      (u_int )2547177864UL, 
        (u_int )162941995L,      (u_int )2125561021L,      (u_int )3887607047UL,      (u_int )2428444049UL, 
        (u_int )498536548L,      (u_int )1789927666L,      (u_int )4089016648UL,      (u_int )2227061214UL, 
        (u_int )450548861L,      (u_int )1843258603L,      (u_int )4107580753UL,      (u_int )2211677639UL, 
        (u_int )325883990L,      (u_int )1684777152L,      (u_int )4251122042UL,      (u_int )2321926636UL, 
        (u_int )335633487L,      (u_int )1661365465L,      (u_int )4195302755UL,      (u_int )2366115317UL, 
        (u_int )997073096L,      (u_int )1281953886L,      (u_int )3579855332UL,      (u_int )2724688242UL, 
        (u_int )1006888145L,      (u_int )1258607687L,      (u_int )3524101629UL,      (u_int )2768942443UL, 
        (u_int )901097722L,      (u_int )1119000684L,      (u_int )3686517206UL,      (u_int )2898065728UL, 
        (u_int )853044451L,      (u_int )1172266101L,      (u_int )3705015759UL,      (u_int )2882616665UL, 
        (u_int )651767980L,      (u_int )1373503546L,      (u_int )3369554304UL,      (u_int )3218104598UL, 
        (u_int )565507253L,      (u_int )1454621731L,      (u_int )3485111705UL,      (u_int )3099436303UL, 
        (u_int )671266974L,      (u_int )1594198024L,      (u_int )3322730930UL,      (u_int )2970347812UL, 
        (u_int )795835527L,      (u_int )1483230225L,      (u_int )3244367275UL,      (u_int )3060149565UL, 
        (u_int )1994146192L,      (u_int )31158534L,      (u_int )2563907772UL,      (u_int )4023717930UL, 
        (u_int )1907459465L,      (u_int )112637215L,      (u_int )2680153253UL,      (u_int )3904427059UL, 
        (u_int )2013776290L,      (u_int )251722036L,      (u_int )2517215374UL,      (u_int )3775830040UL, 
        (u_int )2137656763L,      (u_int )141376813L,      (u_int )2439277719UL,      (u_int )3865271297UL, 
        (u_int )1802195444L,      (u_int )476864866L,      (u_int )2238001368UL,      (u_int )4066508878UL, 
        (u_int )1812370925L,      (u_int )453092731L,      (u_int )2181625025UL,      (u_int )4111451223UL, 
        (u_int )1706088902L,      (u_int )314042704L,      (u_int )2344532202UL,      (u_int )4240017532UL, 
        (u_int )1658658271L,      (u_int )366619977L,      (u_int )2362670323UL,      (u_int )4224994405UL, 
        (u_int )1303535960L,      (u_int )984961486L,      (u_int )2747007092UL,      (u_int )3569037538UL, 
        (u_int )1256170817L,      (u_int )1037604311L,      (u_int )2765210733UL,      (u_int )3554079995UL, 
        (u_int )1131014506L,      (u_int )879679996L,      (u_int )2909243462UL,      (u_int )3663771856UL, 
        (u_int )1141124467L,      (u_int )855842277L,      (u_int )2852801631UL,      (u_int )3708648649UL, 
        (u_int )1342533948L,      (u_int )654459306L,      (u_int )3188396048UL,      (u_int )3373015174UL, 
        (u_int )1466479909L,      (u_int )544179635L,      (u_int )3110523913UL,      (u_int )3462522015UL, 
        (u_int )1591671054L,      (u_int )702138776L,      (u_int )2966460450UL,      (u_int )3352799412UL, 
        (u_int )1504918807L,      (u_int )783551873L,      (u_int )3082640443UL,      (u_int )3233442989UL, 
        (u_int )3988292384UL,      (u_int )2596254646UL,      (u_int )62317068L,      (u_int )1957810842L, 
        (u_int )3939845945UL,      (u_int )2647816111UL,      (u_int )81470997L,      (u_int )1943803523L, 
        (u_int )3814918930UL,      (u_int )2489596804UL,      (u_int )225274430L,      (u_int )2053790376L, 
        (u_int )3826175755UL,      (u_int )2466906013UL,      (u_int )167816743L,      (u_int )2097651377L, 
        (u_int )4027552580UL,      (u_int )2265490386UL,      (u_int )503444072L,      (u_int )1762050814L, 
        (u_int )4150417245UL,      (u_int )2154129355UL,      (u_int )426522225L,      (u_int )1852507879L, 
        (u_int )4275313526UL,      (u_int )2312317920UL,      (u_int )282753626L,      (u_int )1742555852L, 
        (u_int )4189708143UL,      (u_int )2394877945UL,      (u_int )397917763L,      (u_int )1622183637L, 
        (u_int )3604390888UL,      (u_int )2714866558UL,      (u_int )953729732L,      (u_int )1340076626L, 
        (u_int )3518719985UL,      (u_int )2797360999UL,      (u_int )1068828381L,      (u_int )1219638859L, 
        (u_int )3624741850UL,      (u_int )2936675148UL,      (u_int )906185462L,      (u_int )1090812512L, 
        (u_int )3747672003UL,      (u_int )2825379669UL,      (u_int )829329135L,      (u_int )1181335161L, 
        (u_int )3412177804UL,      (u_int )3160834842UL,      (u_int )628085408L,      (u_int )1382605366L, 
        (u_int )3423369109UL,      (u_int )3138078467UL,      (u_int )570562233L,      (u_int )1426400815L, 
        (u_int )3317316542UL,      (u_int )2998733608UL,      (u_int )733239954L,      (u_int )1555261956L, 
        (u_int )3268935591UL,      (u_int )3050360625UL,      (u_int )752459403L,      (u_int )1541320221L, 
        (u_int )2607071920UL,      (u_int )3965973030UL,      (u_int )1969922972L,      (u_int )40735498L, 
        (u_int )2617837225UL,      (u_int )3943577151UL,      (u_int )1913087877L,      (u_int )83908371L, 
        (u_int )2512341634UL,      (u_int )3803740692UL,      (u_int )2075208622L,      (u_int )213261112L, 
        (u_int )2463272603UL,      (u_int )3855990285UL,      (u_int )2094854071L,      (u_int )198958881L, 
        (u_int )2262029012UL,      (u_int )4057260610UL,      (u_int )1759359992L,      (u_int )534414190L, 
        (u_int )2176718541UL,      (u_int )4139329115UL,      (u_int )1873836001L,      (u_int )414664567L, 
        (u_int )2282248934UL,      (u_int )4279200368UL,      (u_int )1711684554L,      (u_int )285281116L, 
        (u_int )2405801727UL,      (u_int )4167216745UL,      (u_int )1634467795L,      (u_int )376229701L, 
        (u_int )2685067896UL,      (u_int )3608007406UL,      (u_int )1308918612L,      (u_int )956543938L, 
        (u_int )2808555105UL,      (u_int )3495958263UL,      (u_int )1231636301L,      (u_int )1047427035L, 
        (u_int )2932959818UL,      (u_int )3654703836UL,      (u_int )1088359270L,      (u_int )936918000L, 
        (u_int )2847714899UL,      (u_int )3736837829UL,      (u_int )1202900863L,      (u_int )817233897L, 
        (u_int )3183342108UL,      (u_int )3401237130UL,      (u_int )1404277552L,      (u_int )615818150L, 
        (u_int )3134207493UL,      (u_int )3453421203UL,      (u_int )1423857449L,      (u_int )601450431L, 
        (u_int )3009837614UL,      (u_int )3294710456UL,      (u_int )1567103746L,      (u_int )711928724L, 
        (u_int )3020668471UL,      (u_int )3272380065UL,      (u_int )1510334235L,      (u_int )755167117L};
#line 103 "crc32.c"
u_int ssh_crc32(u_char const   *s , u_int len ) 
{ u_int i ;
  u_int crc32val ;

  {
#line 109
  crc32val = 0U;
#line 110
  i = 0U;
#line 110
  while (i < len) {
#line 111
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 110
    i ++;
  }
#line 113
  return (crc32val);
}
}
#line 1 "deattack.o"
#line 29 "deattack.h"
int detect_attack(u_char *buf___2 , u_int32_t len , u_char *IV ) ;
#line 49 "deattack.c"
static void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 52
  b ^= *a;
#line 53
  *a = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 54
  return;
}
}
#line 57 "deattack.c"
static int check_crc(u_char *S , u_char *buf___2 , u_int32_t len , u_char *IV ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  crc = 0U;
#line 65
  if (IV) {
#line 65
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 65
    if (! tmp) {
#line 66
      crc_update(& crc, 1U);
#line 67
      crc_update(& crc, 0U);
    }
  }
#line 69
  c = buf___2;
#line 69
  while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 70
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 70
    if (tmp___0) {
#line 74
      crc_update(& crc, 0U);
#line 75
      crc_update(& crc, 0U);
    } else {
#line 71
      crc_update(& crc, 1U);
#line 72
      crc_update(& crc, 0U);
    }
#line 69
    c += 8;
  }
#line 78
  return (crc == 0U);
}
}
#line 86 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 87 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 83 "deattack.c"
int detect_attack(u_char *buf___2 , u_int32_t len , u_char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (len > 262144U) {
#line 95
    fatal("detect_attack: bad length %d", len);
  } else {
#line 93
    if (len % 8U != 0U) {
#line 95
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 97
  l = n;
#line 97
  while (l < ((len / 8U) * 3U) / 2U) {
#line 97
    l <<= 2;
  }
#line 100
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 101
    debug("Installing crc compensation attack detector.");
#line 102
    n = l;
#line 103
    tmp = xmalloc(n * 2U);
#line 103
    h = (u_int16_t *)tmp;
  } else {
#line 105
    if (l > n) {
#line 106
      n = l;
#line 107
      tmp___0 = xrealloc((void *)h, n * 2U);
#line 107
      h = (u_int16_t *)tmp___0;
    }
  }
#line 111
  if (len <= 56U) {
#line 112
    c = buf___2;
#line 112
    while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 113
      if (IV) {
#line 113
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 113
        if (! tmp___2) {
#line 114
          tmp___1 = check_crc(c, buf___2, len, (u_char *)IV);
#line 114
          if (tmp___1) {
#line 115
            return (1);
          } else {
#line 117
            break;
          }
        }
      }
#line 119
      d = buf___2;
#line 119
      while ((unsigned int )d < (unsigned int )c) {
#line 120
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 120
        if (! tmp___4) {
#line 121
          tmp___3 = check_crc(c, buf___2, len, (u_char *)IV);
#line 121
          if (tmp___3) {
#line 122
            return (1);
          } else {
#line 124
            break;
          }
        }
#line 119
        d += 8;
      }
#line 112
      c += 8;
    }
#line 128
    return (0);
  }
#line 130
  memset((void *)h, 255, n * 2U);
#line 132
  if (IV) {
#line 133
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )(n - 1U))) = (unsigned short)65534;
  }
#line 135
  c = buf___2;
#line 135
  j = 0U;
#line 135
  while ((unsigned int )c < (unsigned int )(buf___2 + len)) {
#line 136
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )(n - 1U));
#line 136
    while ((int )*(h + i) != 65535) {
#line 138
      if ((int )*(h + i) == 65534) {
#line 139
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 139
        if (! tmp___6) {
#line 140
          tmp___5 = check_crc(c, buf___2, len, (u_char *)IV);
#line 140
          if (tmp___5) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
      } else {
#line 145
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___2 + (int )*(h + i) * 8),
                         8U);
#line 145
        if (! tmp___8) {
#line 146
          tmp___7 = check_crc(c, buf___2, len, (u_char *)IV);
#line 146
          if (tmp___7) {
#line 147
            return (1);
          } else {
#line 149
            break;
          }
        }
      }
#line 136
      i = (i + 1U) & (n - 1U);
    }
#line 152
    *(h + i) = (unsigned short )j;
#line 135
    c += 8;
#line 135
    j ++;
  }
#line 154
  return (0);
}
}
#line 1 "dh.o"
#line 660 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 457
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 458
extern void BN_free(BIGNUM *a ) ;
#line 459
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 35 "dh.h"
DH *choose_dh(int min , int wantbits , int max ) ;
#line 36
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) ;
#line 37
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) ;
#line 38
DH *dh_new_group1(void) ;
#line 40
void dh_gen_key(DH *dh , int need ) ;
#line 41
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 43
int dh_estimate(int bits ) ;
#line 16 "misc.h"
char *strdelim(char **s ) ;
#line 42 "dh.c"
static int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___0 ;
  char *prime ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  char *tmp___78 ;
  char *tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;

  {
#line 48
  cp = line;
#line 49
  arg = strdelim(& cp);
#line 51
  if ((int )*arg == 0) {
#line 52
    arg = strdelim(& cp);
  }
#line 53
  if (! *arg) {
#line 54
    return (0);
  } else {
#line 53
    if ((int )*arg == 35) {
#line 54
      return (0);
    }
  }
#line 57
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 57
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 59
  tmp___14 = __strsep_g(& cp, " ");
#line 59
  arg = tmp___14;
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___30 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___30;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___46 = __strsep_g(& cp, " ");
#line 65
  arg = tmp___46;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 68
  tmp___62 = __strsep_g(& cp, " ");
#line 68
  strsize = tmp___62;
#line 69
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 69
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 69
      dhg->size = atoi((char const   *)strsize);
#line 69
      if (dhg->size == 0) {
        goto fail;
      }
    }
  }
#line 73
  (dhg->size) ++;
#line 74
  tmp___78 = __strsep_g(& cp, " ");
#line 74
  gen___0 = tmp___78;
#line 75
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 75
    if ((int )*gen___0 == 0) {
      goto fail;
    }
  }
#line 77
  tmp___94 = __strsep_g(& cp, " ");
#line 77
  prime = tmp___94;
#line 78
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 78
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 81
  dhg->g = BN_new();
#line 82
  dhg->p = BN_new();
#line 83
  tmp___95 = BN_hex2bn(& dhg->g, (char const   *)gen___0);
#line 83
  if (tmp___95 == 0) {
    goto failclean;
  }
#line 86
  tmp___96 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 86
  if (tmp___96 == 0) {
    goto failclean;
  }
#line 89
  tmp___97 = BN_num_bits((BIGNUM const   *)dhg->p);
#line 89
  if (tmp___97 != dhg->size) {
    goto failclean;
  }
#line 92
  return (1);
  failclean: 
#line 95
  BN_free(dhg->g);
#line 96
  BN_free(dhg->p);
  fail: 
#line 98
  error("Bad prime description in line %d", linenum);
#line 99
  return (0);
}
}
#line 102 "dh.c"
DH *choose_dh(int min , int wantbits , int max ) 
{ FILE *f ;
  char line[2048] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  DH *tmp___6 ;

  {
#line 111
  f = fopen((char const   * __restrict  )"/usr/local/etc/moduli", (char const   * __restrict  )"r");
#line 111
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 111
    f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 111
    if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 113
      log("WARNING: %s does not exist, using old modulus", "/usr/local/etc/moduli");
#line 114
      tmp = dh_new_group1();
#line 114
      return (tmp);
    }
  }
#line 117
  linenum = 0;
#line 118
  bestcount = 0;
#line 118
  best = bestcount;
#line 119
  while (1) {
#line 119
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 119
    if (! tmp___1) {
#line 119
      break;
    }
#line 120
    linenum ++;
#line 121
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 121
    if (! tmp___0) {
#line 122
      continue;
    }
#line 123
    BN_free(dhg.g);
#line 124
    BN_free(dhg.p);
#line 126
    if (dhg.size > max) {
#line 127
      continue;
    } else {
#line 126
      if (dhg.size < min) {
#line 127
        continue;
      }
    }
#line 129
    if (dhg.size > wantbits) {
#line 129
      if (dhg.size < best) {
#line 131
        best = dhg.size;
#line 132
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 129
      if (dhg.size > best) {
#line 129
        if (best < wantbits) {
#line 131
          best = dhg.size;
#line 132
          bestcount = 0;
        }
      }
    }
#line 134
    if (dhg.size == best) {
#line 135
      bestcount ++;
    }
  }
#line 137
  rewind(f);
#line 139
  if (bestcount == 0) {
#line 140
    fclose(f);
#line 141
    log("WARNING: no suitable primes in %s", "/usr/local/etc/primes");
#line 142
    return ((DH *)((void *)0));
  }
#line 145
  linenum = 0;
#line 146
  tmp___2 = arc4random();
#line 146
  which = (int )(tmp___2 % (unsigned int )bestcount);
#line 147
  while (1) {
#line 147
    tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 147
    if (! tmp___5) {
#line 147
      break;
    }
#line 148
    tmp___3 = parse_prime(linenum, line, & dhg);
#line 148
    if (! tmp___3) {
#line 149
      continue;
    }
#line 150
    if (dhg.size > max) {
#line 153
      BN_free(dhg.g);
#line 154
      BN_free(dhg.p);
#line 155
      continue;
    } else {
#line 150
      if (dhg.size < min) {
#line 153
        BN_free(dhg.g);
#line 154
        BN_free(dhg.p);
#line 155
        continue;
      } else {
#line 150
        if (dhg.size != best) {
#line 153
          BN_free(dhg.g);
#line 154
          BN_free(dhg.p);
#line 155
          continue;
        } else {
#line 150
          tmp___4 = linenum;
#line 150
          linenum ++;
#line 150
          if (tmp___4 != which) {
#line 153
            BN_free(dhg.g);
#line 154
            BN_free(dhg.p);
#line 155
            continue;
          }
        }
      }
    }
#line 157
    break;
  }
#line 159
  fclose(f);
#line 160
  if (linenum != which + 1) {
#line 161
    fatal("WARNING: line %d disappeared in %s, giving up", which, "/usr/local/etc/primes");
  }
#line 164
  tmp___6 = dh_new_group(dhg.g, dhg.p);
#line 164
  return (tmp___6);
}
}
#line 169 "dh.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 173
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 173
  n___0 = tmp;
#line 174
  bits_set = 0;
#line 176
  if (dh_pub->neg) {
#line 177
    log("invalid public DH value: negativ");
#line 178
    return (0);
  }
#line 180
  i = 0;
#line 180
  while (i <= n___0) {
#line 181
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 181
    if (tmp___0) {
#line 182
      bits_set ++;
    }
#line 180
    i ++;
  }
#line 183
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 183
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 186
  if (bits_set > 1) {
#line 186
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 186
    if (tmp___2 == -1) {
#line 187
      return (1);
    }
  }
#line 188
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 188
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 189
  return (0);
}
}
#line 192 "dh.c"
void dh_gen_key(DH *dh , int need ) 
{ int i ;
  int bits_set ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 195
  bits_set = 0;
#line 195
  tries = 0;
#line 197
  if ((unsigned int )dh->p == (unsigned int )((void *)0)) {
#line 198
    fatal("dh_gen_key: dh->p == NULL");
  }
#line 199
  tmp___0 = BN_num_bits((BIGNUM const   *)dh->p);
#line 199
  if (2 * need >= tmp___0) {
#line 200
    tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 200
    fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
  }
#line 202
  while (1) {
#line 203
    if ((unsigned int )dh->priv_key != (unsigned int )((void *)0)) {
#line 204
      BN_free(dh->priv_key);
    }
#line 205
    dh->priv_key = BN_new();
#line 206
    if ((unsigned int )dh->priv_key == (unsigned int )((void *)0)) {
#line 207
      fatal("dh_gen_key: BN_new failed");
    }
#line 209
    tmp___1 = BN_rand(dh->priv_key, 2 * need, 0, 0);
#line 209
    if (! tmp___1) {
#line 210
      fatal("dh_gen_key: BN_rand failed");
    }
#line 211
    tmp___2 = DH_generate_key(dh);
#line 211
    if (tmp___2 == 0) {
#line 212
      fatal("DH_generate_key");
    }
#line 213
    i = 0;
#line 213
    while (1) {
#line 213
      tmp___4 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 213
      if (! (i <= tmp___4)) {
#line 213
        break;
      }
#line 214
      tmp___3 = BN_is_bit_set((BIGNUM const   *)dh->priv_key, i);
#line 214
      if (tmp___3) {
#line 215
        bits_set ++;
      }
#line 213
      i ++;
    }
#line 216
    tmp___5 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 216
    debug("dh_gen_key: priv key bits set: %d/%d", bits_set, tmp___5);
#line 218
    tmp___6 = tries;
#line 218
    tries ++;
#line 218
    if (tmp___6 > 10) {
#line 219
      fatal("dh_gen_key: too many bad keys: giving up");
    }
#line 202
    tmp___7 = dh_pub_is_valid(dh, dh->pub_key);
#line 202
    if (tmp___7) {
#line 202
      break;
    }
  }
#line 221
  return;
}
}
#line 223 "dh.c"
DH *dh_new_group_asc(char const   *gen___0 , char const   *modulus ) 
{ DH *dh ;
  int tmp ;
  int tmp___0 ;

  {
#line 228
  dh = DH_new();
#line 229
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 230
    fatal("DH_new");
  }
#line 232
  tmp = BN_hex2bn(& dh->p, modulus);
#line 232
  if (tmp == 0) {
#line 233
    fatal("BN_hex2bn p");
  }
#line 234
  tmp___0 = BN_hex2bn(& dh->g, gen___0);
#line 234
  if (tmp___0 == 0) {
#line 235
    fatal("BN_hex2bn g");
  }
#line 237
  return (dh);
}
}
#line 245 "dh.c"
DH *dh_new_group(BIGNUM *gen___0 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 250
  dh = DH_new();
#line 251
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 252
    fatal("DH_new");
  }
#line 253
  dh->p = modulus;
#line 254
  dh->g = gen___0;
#line 256
  return (dh);
}
}
#line 262 "dh.c"
static char *gen  =    (char *)"2";
#line 262 "dh.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 259 "dh.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 270
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 270
  return (tmp);
}
}
#line 279 "dh.c"
int dh_estimate(int bits ) 
{ 

  {
#line 283
  if (bits < 64) {
#line 284
    return (512);
  }
#line 285
  if (bits < 128) {
#line 286
    return (1024);
  }
#line 287
  if (bits < 192) {
#line 288
    return (2048);
  }
#line 289
  return (4096);
}
}
#line 1 "dispatch.o"
#line 33 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 34
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 35
void dispatch_run(int mode , int *done , void *ctxt ) ;
#line 36
void dispatch_protocol_error(int type , int plen , void *ctxt ) ;
#line 45 "packet.h"
int packet_read_poll(int *payload_len_ptr ) ;
#line 37 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 39 "dispatch.c"
void dispatch_protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 42
  fatal("dispatch_protocol_error: type %d plen %d", type, plen);
#line 43
  return;
}
}
#line 44 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 48
  i = 0;
#line 48
  while (i < 255) {
#line 49
    dispatch[i] = dflt;
#line 48
    i ++;
  }
#line 50
  return;
}
}
#line 51 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 54
  dispatch[type] = fn;
#line 55
  return;
}
}
#line 56 "dispatch.c"
void dispatch_run(int mode , int *done , void *ctxt ) 
{ int plen ;
  int type ;

  {
#line 59
  while (1) {
#line 63
    if (mode == 0) {
#line 64
      type = packet_read(& plen);
    } else {
#line 66
      type = packet_read_poll(& plen);
#line 67
      if (type == 0) {
#line 68
        return;
      }
    }
#line 70
    if (type > 0) {
#line 70
      if (type < 255) {
#line 70
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 71
          (*(dispatch[type]))(type, plen, ctxt);
        } else {
#line 73
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 73
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 73
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 74
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 74
      if (*done) {
#line 75
        return;
      }
    }
  }
}
}
#line 1 "mac.o"
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 611
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 27
int mac_init(Mac *mac , char *name ) ;
#line 28
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 37 "mac.c"
struct __anonstruct_macs_79 macs[7]  = {      {(char *)"hmac-sha1", (EVP_MD *(*)(void))(& EVP_sha1), 0}, 
        {(char *)"hmac-sha1-96", (EVP_MD *(*)(void))(& EVP_sha1), 96}, 
        {(char *)"hmac-md5", (EVP_MD *(*)(void))(& EVP_md5), 0}, 
        {(char *)"hmac-md5-96", (EVP_MD *(*)(void))(& EVP_md5), 96}, 
        {(char *)"hmac-ripemd160", (EVP_MD *(*)(void))(& EVP_ripemd160), 0}, 
        {(char *)"hmac-ripemd160@openssh.com", (EVP_MD *(*)(void))(& EVP_ripemd160),
      0}, 
        {(char *)((void *)0), (EVP_MD *(*)(void))((void *)0), 0}};
#line 51 "mac.c"
int mac_init(Mac *mac , char *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 55
  i = 0;
#line 55
  while (macs[i].name) {
#line 56
    if (0) {
#line 56
      __s1_len = strlen((char const   *)name);
#line 56
      __s2_len = strlen((char const   *)macs[i].name);
#line 56
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 56
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 56
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 56
            tmp___8 = 1;
          } else {
#line 56
            if (__s2_len >= 4U) {
#line 56
              tmp___8 = 1;
            } else {
#line 56
              tmp___8 = 0;
            }
          }
        } else {
#line 56
          tmp___8 = 0;
        }
      }
#line 56
      if (tmp___8) {
#line 56
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 56
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
        tmp___4 = tmp___7;
      }
    } else {
#line 56
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 56
      tmp___4 = tmp___7;
    }
#line 56
    if (tmp___4 == 0) {
#line 57
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 58
        mac->md = (*(macs[i].mdfunc))();
#line 59
        mac->mac_len = (mac->md)->md_size;
#line 59
        mac->key_len = mac->mac_len;
#line 60
        if (macs[i].truncatebits != 0) {
#line 61
          mac->mac_len = macs[i].truncatebits / 8;
        }
      }
#line 63
      debug2("mac_init: found %s", name);
#line 64
      return (0);
    }
#line 55
    i ++;
  }
#line 67
  debug2("mac_init: unknown %s", name);
#line 68
  return (-1);
}
}
#line 75 "mac.c"
static u_char m[64]  ;
#line 71 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ HMAC_CTX c ;
  u_char b[4] ;

  {
#line 78
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 79
    fatal("mac_compute: no key");
  }
#line 80
  if ((unsigned int )mac->mac_len > sizeof(m)) {
#line 81
    fatal("mac_compute: mac too long");
  }
#line 82
  HMAC_Init(& c, (void const   *)mac->key, mac->key_len, (EVP_MD const   *)mac->md);
#line 83
  while (1) {
#line 83
    b[0] = (unsigned char )(seqno >> 24);
#line 83
    b[1] = (unsigned char )(seqno >> 16);
#line 83
    b[2] = (unsigned char )(seqno >> 8);
#line 83
    b[3] = (unsigned char )seqno;
#line 83
    break;
  }
#line 84
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 85
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 86
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 87
  HMAC_CTX_cleanup(& c);
#line 88
  return (m);
}
}
#line 93 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 98
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 99
    return (0);
  } else {
#line 98
    if (0) {
#line 98
      __s1_len = strlen(names);
#line 98
      __s2_len = strlen("");
#line 98
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 98
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 98
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            if (__s2_len >= 4U) {
#line 98
              tmp___8 = 1;
            } else {
#line 98
              tmp___8 = 0;
            }
          }
        } else {
#line 98
          tmp___8 = 0;
        }
      }
#line 98
      if (tmp___8) {
#line 98
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 98
        tmp___7 = __builtin_strcmp(names, "");
#line 98
        tmp___4 = tmp___7;
      }
    } else {
#line 98
      tmp___7 = __builtin_strcmp(names, "");
#line 98
      tmp___4 = tmp___7;
    }
#line 98
    if (tmp___4 == 0) {
#line 99
      return (0);
    }
  }
#line 100
  cp = xstrdup(names);
#line 100
  maclist = cp;
#line 101
  tmp___24 = __strsep_g(& cp, ",");
#line 101
  p = tmp___24;
#line 101
  while (1) {
#line 101
    if (p) {
#line 101
      if (! ((int )*p != 0)) {
#line 101
        break;
      }
    } else {
#line 101
      break;
    }
#line 103
    tmp___41 = mac_init((Mac *)((void *)0), p);
#line 103
    if (tmp___41 < 0) {
#line 104
      debug("bad mac %s [%s]", p, names);
#line 105
      xfree((void *)maclist);
#line 106
      return (0);
    } else {
#line 108
      debug3("mac ok: %s [%s]", p, names);
    }
#line 102
    tmp___40 = __strsep_g(& cp, ",");
#line 102
    p = tmp___40;
  }
#line 111
  debug3("macs ok: [%s]", names);
#line 112
  xfree((void *)maclist);
#line 113
  return (1);
}
}
#line 1 "hostfile.o"
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 18 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 61 "key.h"
int key_equal(Key *a , Key *b ) ;
#line 64
int key_write(Key *key , FILE *f ) ;
#line 66
u_int key_size(Key *k ) ;
#line 21 "hostfile.h"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) ;
#line 23
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 24
int auth_rsa_read_key(char **cpp , u_int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 52 "hostfile.c"
static int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret ) 
{ char *cp ;
  int tmp ;

  {
#line 58
  cp = *cpp;
#line 58
  while (1) {
#line 58
    if (! ((int )*cp == 32)) {
#line 58
      if (! ((int )*cp == 9)) {
#line 58
        break;
      }
    }
#line 58
    cp ++;
  }
#line 61
  tmp = key_read(ret, & cp);
#line 61
  if (tmp != 1) {
#line 62
    return (0);
  }
#line 65
  while (1) {
#line 65
    if (! ((int )*cp == 32)) {
#line 65
      if (! ((int )*cp == 9)) {
#line 65
        break;
      }
    }
#line 65
    cp ++;
  }
#line 69
  *cpp = cp;
#line 70
  *bitsp = key_size(ret);
#line 71
  return (1);
}
}
#line 74 "hostfile.c"
int auth_rsa_read_key(char **cpp , u_int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 77
  tmp = key_new(0);
#line 77
  k = tmp;
#line 78
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 78
  ret = tmp___0;
#line 79
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 80
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 81
  key_free(k);
#line 82
  return (ret);
}
}
#line 85 "hostfile.c"
static int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                              int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 88
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 89
    return (1);
  } else {
#line 88
    if (key->type != 0) {
#line 89
      return (1);
    } else {
#line 88
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 89
        return (1);
      }
    }
  }
#line 90
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 90
  if (bits != tmp___1) {
#line 91
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 91
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 94
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 94
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 97
  return (1);
}
}
#line 107 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 113
  linenum = 0;
#line 118
  debug3("check_host_in_hostfile: filename %s", filename);
#line 119
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 120
    fatal("no key to look up");
  }
#line 122
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 123
  if (! f) {
#line 124
    return (1);
  }
#line 131
  end_return = 1;
#line 134
  while (1) {
#line 134
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 134
    if (! tmp___3) {
#line 134
      break;
    }
#line 135
    cp = line;
#line 136
    linenum ++;
#line 139
    while (1) {
#line 139
      if (! ((int )*cp == 32)) {
#line 139
        if (! ((int )*cp == 9)) {
#line 139
          break;
        }
      }
#line 139
      cp ++;
    }
#line 141
    if (! *cp) {
#line 142
      continue;
    } else {
#line 141
      if ((int )*cp == 35) {
#line 142
        continue;
      } else {
#line 141
        if ((int )*cp == 10) {
#line 142
          continue;
        }
      }
    }
#line 145
    cp2 = cp;
#line 145
    while (1) {
#line 145
      if (*cp2) {
#line 145
        if ((int )*cp2 != 32) {
#line 145
          if (! ((int )*cp2 != 9)) {
#line 145
            break;
          }
        } else {
#line 145
          break;
        }
      } else {
#line 145
        break;
      }
#line 145
      cp2 ++;
    }
#line 149
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 149
    if (tmp != 1) {
#line 150
      continue;
    }
#line 153
    cp = cp2;
#line 159
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 159
    if (! tmp___0) {
#line 160
      continue;
    }
#line 161
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 161
    if (! tmp___1) {
#line 162
      continue;
    }
#line 164
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 165
      *numret = linenum;
    }
#line 168
    tmp___2 = key_equal(key, found);
#line 168
    if (tmp___2) {
#line 170
      debug3("check_host_in_hostfile: match line %d", linenum);
#line 171
      fclose(f);
#line 172
      return (0);
    }
#line 179
    end_return = 2;
  }
#line 182
  fclose(f);
#line 188
  return (end_return);
}
}
#line 196 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 200
  success = 0;
#line 201
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 202
    return (1);
  }
#line 203
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 204
  if (! f) {
#line 205
    return (0);
  }
#line 206
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 207
  tmp = key_write(key, f);
#line 207
  if (tmp) {
#line 208
    success = 1;
  } else {
#line 210
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 212
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 213
  fclose(f);
#line 214
  return (success);
}
}
#line 1 "key.o"
#line 496 "/usr/include/openssl/bn.h"
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 192
extern void DSA_free(DSA *r ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 62 "key.h"
char *key_fingerprint(Key *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) ;
#line 68
Key *key_generate(int type , u_int bits ) ;
#line 69
Key *key_from_private(Key *k ) ;
#line 70
int key_type_from_name(char *name ) ;
#line 75
int key_names_valid2(char const   *names ) ;
#line 77
int key_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 78
int key_verify(Key *key , u_char *signature , int signaturelen , u_char *data , int datalen ) ;
#line 29 "ssh-dss.h"
int ssh_dss_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 30
int ssh_dss_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) ;
#line 29 "ssh-rsa.h"
int ssh_rsa_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) ;
#line 30
int ssh_rsa_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) ;
#line 29 "uuencode.h"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) ;
#line 30
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 49 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 55
  tmp = xmalloc(sizeof(*k));
#line 55
  k = (Key *)tmp;
#line 56
  k->type = type;
#line 57
  k->flags = 0;
#line 58
  k->dsa = (DSA *)((void *)0);
#line 59
  k->rsa = (RSA *)((void *)0);
#line 60
  switch (k->type) {
  case 0: 
  case 1: 
#line 63
  rsa = RSA_new();
#line 64
  rsa->n = BN_new();
#line 65
  rsa->e = BN_new();
#line 66
  k->rsa = rsa;
#line 67
  break;
  case 2: 
#line 69
  dsa = DSA_new();
#line 70
  dsa->p = BN_new();
#line 71
  dsa->q = BN_new();
#line 72
  dsa->g = BN_new();
#line 73
  dsa->pub_key = BN_new();
#line 74
  k->dsa = dsa;
#line 75
  break;
  case 3: 
#line 77
  break;
  default: 
#line 79
  fatal("key_new: bad key type %d", k->type);
#line 80
  break;
  }
#line 82
  return (k);
}
}
#line 84 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 87
  tmp = key_new(type);
#line 87
  k = tmp;
#line 88
  switch (k->type) {
  case 0: 
  case 1: 
#line 91
  (k->rsa)->d = BN_new();
#line 92
  (k->rsa)->iqmp = BN_new();
#line 93
  (k->rsa)->q = BN_new();
#line 94
  (k->rsa)->p = BN_new();
#line 95
  (k->rsa)->dmq1 = BN_new();
#line 96
  (k->rsa)->dmp1 = BN_new();
#line 97
  break;
  case 2: 
#line 99
  (k->dsa)->priv_key = BN_new();
#line 100
  break;
  case 3: 
#line 102
  break;
  default: ;
#line 104
  break;
  }
#line 106
  return (k);
}
}
#line 108 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 111
  switch (k->type) {
  case 0: 
  case 1: 
#line 114
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 115
    RSA_free(k->rsa);
  }
#line 116
  k->rsa = (RSA *)((void *)0);
#line 117
  break;
  case 2: 
#line 119
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 120
    DSA_free(k->dsa);
  }
#line 121
  k->dsa = (DSA *)((void *)0);
#line 122
  break;
  case 3: 
#line 124
  break;
  default: 
#line 126
  fatal("key_free: bad key type %d", k->type);
#line 127
  break;
  }
#line 129
  xfree((void *)k);
#line 130
  return;
}
}
#line 131 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 134
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 135
    return (0);
  } else {
#line 134
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 135
      return (0);
    } else {
#line 134
      if (a->type != b->type) {
#line 135
        return (0);
      }
    }
  }
#line 136
  switch (a->type) {
  case 0: 
  case 1: 
#line 139
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 139
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 139
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 139
      if (tmp == 0) {
#line 139
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 139
        if (tmp___0 == 0) {
#line 139
          tmp___1 = 1;
        } else {
#line 139
          tmp___1 = 0;
        }
      } else {
#line 139
        tmp___1 = 0;
      }
    } else {
#line 139
      tmp___1 = 0;
    }
  } else {
#line 139
    tmp___1 = 0;
  }
#line 139
  return (tmp___1);
#line 142
  break;
  case 2: 
#line 144
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 144
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 144
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 144
      if (tmp___2 == 0) {
#line 144
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 144
        if (tmp___3 == 0) {
#line 144
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 144
          if (tmp___4 == 0) {
#line 144
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 144
            if (tmp___5 == 0) {
#line 144
              tmp___6 = 1;
            } else {
#line 144
              tmp___6 = 0;
            }
          } else {
#line 144
            tmp___6 = 0;
          }
        } else {
#line 144
          tmp___6 = 0;
        }
      } else {
#line 144
        tmp___6 = 0;
      }
    } else {
#line 144
      tmp___6 = 0;
    }
  } else {
#line 144
    tmp___6 = 0;
  }
#line 144
  return (tmp___6);
#line 149
  break;
  default: 
#line 151
  fatal("key_equal: bad key type %d", a->type);
#line 152
  break;
  }
#line 154
  return (0);
}
}
#line 157 "key.c"
static u_char *key_fingerprint_raw(Key *k , enum fp_type dgst_type , size_t *dgst_raw_length ) 
{ EVP_MD *md ;
  EVP_MD_CTX ctx ;
  u_char *blob ;
  u_char *retval ;
  int len ;
  int nlen ;
  int elen ;
  EVP_MD const   *tmp ;
  EVP_MD const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 160
  md = (EVP_MD *)((void *)0);
#line 162
  blob = (u_char *)((void *)0);
#line 163
  retval = (u_char *)((void *)0);
#line 164
  len = 0;
#line 167
  *dgst_raw_length = 0U;
#line 169
  switch ((int )dgst_type) {
  case 1: 
#line 171
  tmp = EVP_md5();
#line 171
  md = (EVP_MD *)tmp;
#line 172
  break;
  case 0: 
#line 174
  tmp___0 = EVP_sha1();
#line 174
  md = (EVP_MD *)tmp___0;
#line 175
  break;
  default: 
#line 177
  fatal("key_fingerprint_raw: bad digest type %d", dgst_type);
  }
#line 180
  switch (k->type) {
  case 0: 
#line 182
  tmp___1 = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 182
  nlen = (tmp___1 + 7) / 8;
#line 183
  tmp___2 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 183
  elen = (tmp___2 + 7) / 8;
#line 184
  len = nlen + elen;
#line 185
  tmp___3 = xmalloc((unsigned int )len);
#line 185
  blob = (u_char *)tmp___3;
#line 186
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 187
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 188
  break;
  case 2: 
  case 1: 
#line 191
  key_to_blob(k, & blob, (u_int *)(& len));
#line 192
  break;
  case 3: 
#line 194
  return (retval);
#line 195
  break;
  default: 
#line 197
  fatal("key_fingerprint_raw: bad key type %d", k->type);
#line 198
  break;
  }
#line 200
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 201
    tmp___4 = xmalloc(64U);
#line 201
    retval = (u_char *)tmp___4;
#line 202
    EVP_DigestInit(& ctx, (EVP_MD const   *)md);
#line 203
    EVP_DigestUpdate(& ctx, (void const   *)blob, (unsigned int )len);
#line 204
    EVP_DigestFinal(& ctx, retval, (unsigned int *)((void *)0));
#line 205
    *dgst_raw_length = (unsigned int )md->md_size;
#line 206
    memset((void *)blob, 0, (unsigned int )len);
#line 207
    xfree((void *)blob);
  } else {
#line 209
    fatal("key_fingerprint_raw: blob is null");
  }
#line 211
  return (retval);
}
}
#line 214 "key.c"
static char *key_fingerprint_hex(u_char *dgst_raw , size_t dgst_raw_len ) 
{ char *retval ;
  int i ;
  void *tmp ;
  char hex[4] ;

  {
#line 220
  tmp = xmalloc(dgst_raw_len * 3U + 1U);
#line 220
  retval = (char *)tmp;
#line 221
  *(retval + 0) = (char )'\000';
#line 222
  i = 0;
#line 222
  while ((size_t )i < dgst_raw_len) {
#line 224
    snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
             *(dgst_raw + i));
#line 225
    strlcat(retval, (char const   *)(hex), dgst_raw_len * 3U);
#line 222
    i ++;
  }
#line 227
  *(retval + (dgst_raw_len * 3U - 1U)) = (char )'\000';
#line 228
  return (retval);
}
}
#line 231 "key.c"
static char *key_fingerprint_bubblebabble(u_char *dgst_raw , size_t dgst_raw_len ) 
{ char vowels[6] ;
  char consonants[17] ;
  u_int i ;
  u_int j ;
  u_int rounds ;
  u_int seed ;
  char *retval ;
  void *tmp ;
  u_int tmp___0 ;
  u_int idx0 ;
  u_int idx1 ;
  u_int idx2 ;
  u_int idx3 ;
  u_int idx4 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;

  {
#line 234
  vowels[0] = (char )'a';
#line 234
  vowels[1] = (char )'e';
#line 234
  vowels[2] = (char )'i';
#line 234
  vowels[3] = (char )'o';
#line 234
  vowels[4] = (char )'u';
#line 234
  vowels[5] = (char )'y';
#line 235
  consonants[0] = (char )'b';
#line 235
  consonants[1] = (char )'c';
#line 235
  consonants[2] = (char )'d';
#line 235
  consonants[3] = (char )'f';
#line 235
  consonants[4] = (char )'g';
#line 235
  consonants[5] = (char )'h';
#line 235
  consonants[6] = (char )'k';
#line 235
  consonants[7] = (char )'l';
#line 235
  consonants[8] = (char )'m';
#line 235
  consonants[9] = (char )'n';
#line 235
  consonants[10] = (char )'p';
#line 235
  consonants[11] = (char )'r';
#line 235
  consonants[12] = (char )'s';
#line 235
  consonants[13] = (char )'t';
#line 235
  consonants[14] = (char )'v';
#line 235
  consonants[15] = (char )'z';
#line 235
  consonants[16] = (char )'x';
#line 237
  j = (u_int )0;
#line 237
  seed = (u_int )1;
#line 240
  rounds = dgst_raw_len / 2U + 1U;
#line 241
  tmp = xmalloc(sizeof(char ) * (rounds * 6U));
#line 241
  retval = (char *)tmp;
#line 242
  tmp___0 = j;
#line 242
  j ++;
#line 242
  *(retval + tmp___0) = (char )'x';
#line 243
  i = 0U;
#line 243
  while (i < rounds) {
#line 245
    if (i + 1U < rounds) {
      goto _L;
    } else {
#line 245
      if (dgst_raw_len % 2U != 0U) {
        _L: /* CIL Label */ 
#line 246
        idx0 = ((((unsigned int )*(dgst_raw + 2U * i) >> 6) & 3U) + seed) % 6U;
#line 248
        idx1 = ((unsigned int )*(dgst_raw + 2U * i) >> 2) & 15U;
#line 249
        idx2 = (((unsigned int )*(dgst_raw + 2U * i) & 3U) + seed / 6U) % 6U;
#line 251
        tmp___1 = j;
#line 251
        j ++;
#line 251
        *(retval + tmp___1) = vowels[idx0];
#line 252
        tmp___2 = j;
#line 252
        j ++;
#line 252
        *(retval + tmp___2) = consonants[idx1];
#line 253
        tmp___3 = j;
#line 253
        j ++;
#line 253
        *(retval + tmp___3) = vowels[idx2];
#line 254
        if (i + 1U < rounds) {
#line 255
          idx3 = ((unsigned int )*(dgst_raw + (2U * i + 1U)) >> 4) & 15U;
#line 256
          idx4 = (unsigned int )*(dgst_raw + (2U * i + 1U)) & 15U;
#line 257
          tmp___4 = j;
#line 257
          j ++;
#line 257
          *(retval + tmp___4) = consonants[idx3];
#line 258
          tmp___5 = j;
#line 258
          j ++;
#line 258
          *(retval + tmp___5) = (char )'-';
#line 259
          tmp___6 = j;
#line 259
          j ++;
#line 259
          *(retval + tmp___6) = consonants[idx4];
#line 260
          seed = (seed * 5U + ((unsigned int )*(dgst_raw + 2U * i) * 7U + (unsigned int )*(dgst_raw + (2U * i + 1U)))) % 36U;
        }
      } else {
#line 265
        idx0 = seed % 6U;
#line 266
        idx1 = 16U;
#line 267
        idx2 = seed / 6U;
#line 268
        tmp___7 = j;
#line 268
        j ++;
#line 268
        *(retval + tmp___7) = vowels[idx0];
#line 269
        tmp___8 = j;
#line 269
        j ++;
#line 269
        *(retval + tmp___8) = consonants[idx1];
#line 270
        tmp___9 = j;
#line 270
        j ++;
#line 270
        *(retval + tmp___9) = vowels[idx2];
      }
    }
#line 243
    i ++;
  }
#line 273
  tmp___10 = j;
#line 273
  j ++;
#line 273
  *(retval + tmp___10) = (char )'x';
#line 274
  tmp___11 = j;
#line 274
  j ++;
#line 274
  *(retval + tmp___11) = (char )'\000';
#line 275
  return (retval);
}
}
#line 278 "key.c"
char *key_fingerprint(Key *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) 
{ char *retval ;
  u_char *dgst_raw ;
  size_t dgst_raw_len ;

  {
#line 281
  retval = (char *)((void *)0);
#line 285
  dgst_raw = key_fingerprint_raw(k, dgst_type, & dgst_raw_len);
#line 286
  if (! dgst_raw) {
#line 287
    fatal("key_fingerprint: null from key_fingerprint_raw()");
  }
#line 288
  switch ((int )dgst_rep) {
  case 0: 
#line 290
  retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
#line 291
  break;
  case 1: 
#line 293
  retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
#line 294
  break;
  default: 
#line 296
  fatal("key_fingerprint_ex: bad digest representation %d", dgst_rep);
#line 298
  break;
  }
#line 300
  memset((void *)dgst_raw, 0, dgst_raw_len);
#line 301
  xfree((void *)dgst_raw);
#line 302
  return (retval);
}
}
#line 312 "key.c"
static int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 315
  cp = *cpp;
#line 319
  while (1) {
#line 319
    if (! ((int )*cp == 32)) {
#line 319
      if (! ((int )*cp == 9)) {
#line 319
        break;
      }
    }
#line 319
    cp ++;
  }
#line 323
  if ((int )*cp < 48) {
#line 324
    return (0);
  } else {
#line 323
    if ((int )*cp > 57) {
#line 324
      return (0);
    }
  }
#line 327
  *cpp = cp;
#line 330
  while (1) {
#line 330
    if ((int )*cp >= 48) {
#line 330
      if (! ((int )*cp <= 57)) {
#line 330
        break;
      }
    } else {
#line 330
      break;
    }
#line 330
    cp ++;
  }
#line 334
  old = (int )*cp;
#line 335
  *cp = (char)0;
#line 338
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 338
  if (tmp == 0) {
#line 339
    return (0);
  }
#line 342
  *cp = (char )old;
#line 345
  *cpp = cp;
#line 346
  return (1);
}
}
#line 348 "key.c"
static int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___2 ;
  char *tmp ;

  {
#line 351
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 351
  buf___2 = tmp;
#line 352
  if ((unsigned int )buf___2 == (unsigned int )((void *)0)) {
#line 353
    error("write_bignum: BN_bn2dec() failed");
#line 354
    return (0);
  }
#line 356
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___2);
#line 357
  xfree((void *)buf___2);
#line 358
  return (1);
}
}
#line 362 "key.c"
int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 366
  success = -1;
#line 372
  cp = *cpp;
#line 374
  switch (ret->type) {
  case 0: 
#line 377
  if ((int )*cp < 48) {
#line 378
    return (-1);
  } else {
#line 377
    if ((int )*cp > 57) {
#line 378
      return (-1);
    }
  }
#line 379
  bits = 0U;
#line 379
  while (1) {
#line 379
    if ((int )*cp >= 48) {
#line 379
      if (! ((int )*cp <= 57)) {
#line 379
        break;
      }
    } else {
#line 379
      break;
    }
#line 380
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 379
    cp ++;
  }
#line 381
  if (bits == 0U) {
#line 382
    return (-1);
  }
#line 383
  *cpp = cp;
#line 385
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 385
  if (! tmp) {
#line 386
    return (-1);
  }
#line 387
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 387
  if (! tmp___0) {
#line 388
    return (-1);
  }
#line 389
  success = 1;
#line 390
  break;
  case 3: 
  case 1: 
  case 2: 
#line 394
  tmp___2 = __builtin_strchr(cp, ' ');
#line 394
  space = tmp___2;
#line 395
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 396
    debug3("key_read: no space");
#line 397
    return (-1);
  }
#line 399
  *space = (char )'\000';
#line 400
  type = key_type_from_name(cp);
#line 401
  *space = (char )' ';
#line 402
  if (type == 3) {
#line 403
    debug3("key_read: no key found");
#line 404
    return (-1);
  }
#line 406
  cp = space + 1;
#line 407
  if ((int )*cp == 0) {
#line 408
    debug3("key_read: short string");
#line 409
    return (-1);
  }
#line 411
  if (ret->type == 3) {
#line 412
    ret->type = type;
  } else {
#line 413
    if (ret->type != type) {
#line 415
      debug3("key_read: type mismatch");
#line 416
      return (-1);
    }
  }
#line 418
  tmp___3 = strlen((char const   *)cp);
#line 418
  len = (int )(2U * tmp___3);
#line 419
  tmp___4 = xmalloc((unsigned int )len);
#line 419
  blob = (u_char *)tmp___4;
#line 420
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 421
  if (n___0 < 0) {
#line 422
    error("key_read: uudecode %s failed", cp);
#line 423
    return (-1);
  }
#line 425
  k = key_from_blob(blob, n___0);
#line 426
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 427
    error("key_read: key_from_blob %s failed", cp);
#line 428
    return (-1);
  }
#line 430
  xfree((void *)blob);
#line 431
  if (k->type != type) {
#line 432
    error("key_read: type mismatch: encoding error");
#line 433
    key_free(k);
#line 434
    return (-1);
  }
#line 437
  if (ret->type == 1) {
#line 438
    if ((unsigned int )ret->rsa != (unsigned int )((void *)0)) {
#line 439
      RSA_free(ret->rsa);
    }
#line 440
    ret->rsa = k->rsa;
#line 441
    k->rsa = (RSA *)((void *)0);
#line 442
    success = 1;
  } else {
#line 447
    if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 448
      DSA_free(ret->dsa);
    }
#line 449
    ret->dsa = k->dsa;
#line 450
    k->dsa = (DSA *)((void *)0);
#line 451
    success = 1;
  }
#line 457
  if (success != 1) {
#line 458
    break;
  }
#line 459
  key_free(k);
#line 461
  while (1) {
#line 461
    if (! ((int )*cp == 32)) {
#line 461
      if (! ((int )*cp == 9)) {
#line 461
        break;
      }
    }
#line 462
    cp ++;
  }
#line 463
  while (1) {
#line 463
    if ((int )*cp != 0) {
#line 463
      if ((int )*cp != 32) {
#line 463
        if (! ((int )*cp != 9)) {
#line 463
          break;
        }
      } else {
#line 463
        break;
      }
    } else {
#line 463
      break;
    }
#line 464
    cp ++;
  }
#line 465
  *cpp = cp;
#line 466
  break;
  default: 
#line 468
  fatal("key_read: bad key type: %d", ret->type);
#line 469
  break;
  }
#line 471
  return (success);
}
}
#line 473 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  u_int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  u_char *blob ;
  u_char *uu ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 476
  success = 0;
#line 477
  bits = (u_int )0;
#line 479
  if (key->type == 0) {
#line 479
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 481
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 481
      bits = (unsigned int )tmp;
#line 482
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 483
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 483
      if (tmp___0) {
#line 483
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 483
        if (tmp___1) {
#line 485
          success = 1;
        } else {
#line 487
          error("key_write: failed for RSA key");
        }
      } else {
#line 487
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 489
    if (key->type == 2) {
#line 489
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 489
      if (key->type == 1) {
#line 489
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 493
          key_to_blob(key, & blob, (u_int *)(& len));
#line 494
          tmp___2 = xmalloc((unsigned int )(2 * len));
#line 494
          uu = (u_char *)tmp___2;
#line 495
          n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 496
          if (n___0 > 0) {
#line 497
            tmp___3 = key_ssh_name(key);
#line 497
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 498
            success = 1;
          }
#line 500
          xfree((void *)blob);
#line 501
          xfree((void *)uu);
        }
      }
    }
  }
#line 503
  return (success);
}
}
#line 505 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 508
  switch (k->type) {
  case 0: 
#line 510
  return ((char *)"RSA1");
#line 511
  break;
  case 1: 
#line 513
  return ((char *)"RSA");
#line 514
  break;
  case 2: 
#line 516
  return ((char *)"DSA");
#line 517
  break;
  }
#line 519
  return ((char *)"unknown");
}
}
#line 521 "key.c"
char *key_ssh_name(Key *k ) 
{ 

  {
#line 524
  switch (k->type) {
  case 1: 
#line 526
  return ((char *)"ssh-rsa");
#line 527
  break;
  case 2: 
#line 529
  return ((char *)"ssh-dss");
#line 530
  break;
  }
#line 532
  return ((char *)"ssh-unknown");
}
}
#line 534 "key.c"
u_int key_size(Key *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 536
  switch (k->type) {
  case 0: 
  case 1: 
#line 539
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 539
  return ((unsigned int )tmp);
#line 540
  break;
  case 2: 
#line 542
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 542
  return ((unsigned int )tmp___0);
#line 543
  break;
  }
#line 545
  return (0U);
}
}
#line 548 "key.c"
static RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 552
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 553
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 554
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 555
  return (private);
}
}
#line 558 "key.c"
static DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 561
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 561
  private = tmp;
#line 562
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 563
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 564
  tmp___0 = DSA_generate_key(private);
#line 564
  if (! tmp___0) {
#line 565
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 566
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 567
    fatal("dsa_generate_private_key: NULL.");
  }
#line 568
  return (private);
}
}
#line 571 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 574
  tmp = key_new(3);
#line 574
  k = tmp;
#line 575
  switch (type) {
  case 2: 
#line 577
  k->dsa = dsa_generate_private_key(bits);
#line 578
  break;
  case 1: 
  case 0: 
#line 581
  k->rsa = rsa_generate_private_key(bits);
#line 582
  break;
  default: 
#line 584
  fatal("key_generate: unknown type %d", type);
  }
#line 586
  k->type = type;
#line 587
  return (k);
}
}
#line 590 "key.c"
Key *key_from_private(Key *k ) 
{ Key *n___0 ;

  {
#line 593
  n___0 = (Key *)((void *)0);
#line 594
  switch (k->type) {
  case 2: 
#line 596
  n___0 = key_new(k->type);
#line 597
  BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 598
  BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 599
  BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 600
  BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 601
  break;
  case 1: 
  case 0: 
#line 604
  n___0 = key_new(k->type);
#line 605
  BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 606
  BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 607
  break;
  default: 
#line 609
  fatal("key_from_private: unknown type %d", k->type);
#line 610
  break;
  }
#line 612
  return (n___0);
}
}
#line 615 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 618
  if (0) {
#line 618
    __s1_len___3 = strlen((char const   *)name);
#line 618
    __s2_len___3 = strlen("rsa1");
#line 618
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 618
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 618
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 618
          tmp___48 = 1;
        } else {
#line 618
          if (__s2_len___3 >= 4U) {
#line 618
            tmp___48 = 1;
          } else {
#line 618
            tmp___48 = 0;
          }
        }
      } else {
#line 618
        tmp___48 = 0;
      }
    }
#line 618
    if (tmp___48) {
#line 618
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 618
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 618
      tmp___44 = tmp___47;
    }
  } else {
#line 618
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 618
    tmp___44 = tmp___47;
  }
#line 618
  if (tmp___44 == 0) {
#line 619
    return (0);
  } else {
#line 620
    if (0) {
#line 620
      __s1_len___2 = strlen((char const   *)name);
#line 620
      __s2_len___2 = strlen("rsa");
#line 620
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 620
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 620
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 620
            tmp___38 = 1;
          } else {
#line 620
            if (__s2_len___2 >= 4U) {
#line 620
              tmp___38 = 1;
            } else {
#line 620
              tmp___38 = 0;
            }
          }
        } else {
#line 620
          tmp___38 = 0;
        }
      }
#line 620
      if (tmp___38) {
#line 620
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 620
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 620
        tmp___34 = tmp___37;
      }
    } else {
#line 620
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 620
      tmp___34 = tmp___37;
    }
#line 620
    if (tmp___34 == 0) {
#line 621
      return (1);
    } else {
#line 622
      if (0) {
#line 622
        __s1_len___1 = strlen((char const   *)name);
#line 622
        __s2_len___1 = strlen("dsa");
#line 622
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 622
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 622
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 622
              tmp___28 = 1;
            } else {
#line 622
              if (__s2_len___1 >= 4U) {
#line 622
                tmp___28 = 1;
              } else {
#line 622
                tmp___28 = 0;
              }
            }
          } else {
#line 622
            tmp___28 = 0;
          }
        }
#line 622
        if (tmp___28) {
#line 622
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 622
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 622
          tmp___24 = tmp___27;
        }
      } else {
#line 622
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 622
        tmp___24 = tmp___27;
      }
#line 622
      if (tmp___24 == 0) {
#line 623
        return (2);
      } else {
#line 624
        if (0) {
#line 624
          __s1_len___0 = strlen((char const   *)name);
#line 624
          __s2_len___0 = strlen("ssh-rsa");
#line 624
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 624
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 624
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 624
                tmp___18 = 1;
              } else {
#line 624
                if (__s2_len___0 >= 4U) {
#line 624
                  tmp___18 = 1;
                } else {
#line 624
                  tmp___18 = 0;
                }
              }
            } else {
#line 624
              tmp___18 = 0;
            }
          }
#line 624
          if (tmp___18) {
#line 624
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 624
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 624
            tmp___14 = tmp___17;
          }
        } else {
#line 624
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 624
          tmp___14 = tmp___17;
        }
#line 624
        if (tmp___14 == 0) {
#line 625
          return (1);
        } else {
#line 626
          if (0) {
#line 626
            __s1_len = strlen((char const   *)name);
#line 626
            __s2_len = strlen("ssh-dss");
#line 626
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 626
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 626
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 626
                  tmp___8 = 1;
                } else {
#line 626
                  if (__s2_len >= 4U) {
#line 626
                    tmp___8 = 1;
                  } else {
#line 626
                    tmp___8 = 0;
                  }
                }
              } else {
#line 626
                tmp___8 = 0;
              }
            }
#line 626
            if (tmp___8) {
#line 626
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 626
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 626
              tmp___4 = tmp___7;
            }
          } else {
#line 626
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 626
            tmp___4 = tmp___7;
          }
#line 626
          if (tmp___4 == 0) {
#line 627
            return (2);
          }
        }
      }
    }
  }
#line 629
  debug2("key_type_from_name: unknown key type \'%s\'", name);
#line 630
  return (3);
}
}
#line 633 "key.c"
int key_names_valid2(char const   *names ) 
{ char *s ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 638
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 639
    return (0);
  } else {
#line 638
    if (0) {
#line 638
      __s1_len = strlen(names);
#line 638
      __s2_len = strlen("");
#line 638
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 638
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 638
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 638
            tmp___8 = 1;
          } else {
#line 638
            if (__s2_len >= 4U) {
#line 638
              tmp___8 = 1;
            } else {
#line 638
              tmp___8 = 0;
            }
          }
        } else {
#line 638
          tmp___8 = 0;
        }
      }
#line 638
      if (tmp___8) {
#line 638
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 638
        tmp___7 = __builtin_strcmp(names, "");
#line 638
        tmp___4 = tmp___7;
      }
    } else {
#line 638
      tmp___7 = __builtin_strcmp(names, "");
#line 638
      tmp___4 = tmp___7;
    }
#line 638
    if (tmp___4 == 0) {
#line 639
      return (0);
    }
  }
#line 640
  cp = xstrdup(names);
#line 640
  s = cp;
#line 641
  tmp___24 = __strsep_g(& cp, ",");
#line 641
  p = tmp___24;
#line 641
  while (1) {
#line 641
    if (p) {
#line 641
      if (! ((int )*p != 0)) {
#line 641
        break;
      }
    } else {
#line 641
      break;
    }
#line 643
    tmp___41 = key_type_from_name(p);
#line 643
    switch (tmp___41) {
    case 0: 
    case 3: 
#line 646
    xfree((void *)s);
#line 647
    return (0);
    }
#line 642
    tmp___40 = __strsep_g(& cp, ",");
#line 642
    p = tmp___40;
  }
#line 650
  debug3("key names ok: [%s]", names);
#line 651
  xfree((void *)s);
#line 652
  return (1);
}
}
#line 655 "key.c"
Key *key_from_blob(u_char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  int type ;
  Key *key ;
  u_int tmp ;

  {
#line 661
  key = (Key *)((void *)0);
#line 666
  buffer_init(& b);
#line 667
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 668
  ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 669
  type = key_type_from_name(ktype);
#line 671
  switch (type) {
  case 1: 
#line 673
  key = key_new(type);
#line 674
  buffer_get_bignum2(& b, (key->rsa)->e);
#line 675
  buffer_get_bignum2(& b, (key->rsa)->n);
#line 679
  break;
  case 2: 
#line 681
  key = key_new(type);
#line 682
  buffer_get_bignum2(& b, (key->dsa)->p);
#line 683
  buffer_get_bignum2(& b, (key->dsa)->q);
#line 684
  buffer_get_bignum2(& b, (key->dsa)->g);
#line 685
  buffer_get_bignum2(& b, (key->dsa)->pub_key);
#line 689
  break;
  case 3: 
#line 691
  key = key_new(type);
#line 692
  break;
  default: 
#line 694
  error("key_from_blob: cannot handle type %s", ktype);
#line 695
  break;
  }
#line 697
  tmp = buffer_len(& b);
#line 697
  rlen = (int )tmp;
#line 698
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 698
    if (rlen != 0) {
#line 699
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
#line 700
  xfree((void *)ktype);
#line 701
  buffer_free(& b);
#line 702
  return (key);
}
}
#line 705 "key.c"
int key_to_blob(Key *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  u_char *buf___2 ;
  char *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 712
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 713
    error("key_to_blob: key == NULL");
#line 714
    return (0);
  }
#line 716
  buffer_init(& b);
#line 717
  switch (key->type) {
  case 2: 
#line 719
  tmp = key_ssh_name(key);
#line 719
  buffer_put_cstring(& b, (char const   *)tmp);
#line 720
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 721
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 722
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 723
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 724
  break;
  case 1: 
#line 726
  tmp___0 = key_ssh_name(key);
#line 726
  buffer_put_cstring(& b, (char const   *)tmp___0);
#line 727
  buffer_put_bignum2(& b, (key->rsa)->e);
#line 728
  buffer_put_bignum2(& b, (key->rsa)->n);
#line 729
  break;
  default: 
#line 731
  error("key_to_blob: unsupported key type %d", key->type);
#line 732
  buffer_free(& b);
#line 733
  return (0);
  }
#line 735
  tmp___1 = buffer_len(& b);
#line 735
  len = (int )tmp___1;
#line 736
  tmp___2 = xmalloc((unsigned int )len);
#line 736
  buf___2 = (u_char *)tmp___2;
#line 737
  tmp___3 = buffer_ptr(& b);
#line 737
  memcpy((void * __restrict  )buf___2, (void const   * __restrict  )tmp___3, (unsigned int )len);
#line 738
  tmp___4 = buffer_ptr(& b);
#line 738
  memset((void *)tmp___4, 0, (unsigned int )len);
#line 739
  buffer_free(& b);
#line 740
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 741
    *lenp = (unsigned int )len;
  }
#line 742
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 743
    *blobp = buf___2;
  }
#line 744
  return (len);
}
}
#line 747 "key.c"
int key_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 753
  switch (key->type) {
  case 2: 
#line 755
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 755
  return (tmp);
#line 756
  break;
  case 1: 
#line 758
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 758
  return (tmp___0);
#line 759
  break;
  default: 
#line 761
  error("key_sign: illegal key type %d", key->type);
#line 762
  return (-1);
#line 763
  break;
  }
#line 765
  return (0);
}
}
#line 767 "key.c"
int key_verify(Key *key , u_char *signature , int signaturelen , u_char *data , int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 773
  if (signaturelen == 0) {
#line 774
    return (-1);
  }
#line 776
  switch (key->type) {
  case 2: 
#line 778
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 778
  return (tmp);
#line 779
  break;
  case 1: 
#line 781
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 781
  return (tmp___0);
#line 782
  break;
  default: 
#line 784
  error("key_verify: illegal key type %d", key->type);
#line 785
  return (-1);
#line 786
  break;
  }
#line 788
  return (0);
}
}
#line 1 "kex.o"
#line 40 "packet.h"
void packet_put_raw(char const   *buf___2 , u_int len ) ;
#line 44
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 48
u_int packet_get_char(void) ;
#line 52
char *packet_get_raw(int *length_ptr ) ;
#line 114 "kex.h"
Kex *kex_setup(char **proposal ) ;
#line 115
void kex_finish(Kex *kex ) ;
#line 117
void kex_send_kexinit(Kex *kex ) ;
#line 118
void kex_input_kexinit(int type , int plen , void *ctxt ) ;
#line 119
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) ;
#line 121
void kexdh(Kex *kex ) ;
#line 122
void kexgex(Kex *kex ) ;
#line 124
Newkeys *kex_get_newkeys(int mode ) ;
#line 21 "match.h"
char *match_list(char const   *client , char const   *server , u_int *next ) ;
#line 47 "kex.c"
static void kex_kexinit_finish(Kex *kex ) ;
#line 48
static void kex_choose_conf(Kex *kex ) ;
#line 51 "kex.c"
static void kex_prop2buf(Buffer *b , char **proposal ) 
{ u_int32_t rand___0 ;
  int i ;

  {
#line 54
  rand___0 = (u_int32_t )0;
#line 57
  buffer_clear(b);
#line 58
  i = 0;
#line 58
  while (i < 16) {
#line 59
    if (i % 4 == 0) {
#line 60
      rand___0 = arc4random();
    }
#line 61
    buffer_put_char(b, (int )(rand___0 & 255U));
#line 62
    rand___0 >>= 8;
#line 58
    i ++;
  }
#line 64
  i = 0;
#line 64
  while (i < 10) {
#line 65
    buffer_put_cstring(b, (char const   *)*(proposal + i));
#line 64
    i ++;
  }
#line 66
  buffer_put_char(b, 0);
#line 67
  buffer_put_int(b, 0U);
#line 68
  return;
}
}
#line 71 "kex.c"
static char **kex_buf2prop(Buffer *raw ) 
{ Buffer b ;
  int i ;
  char **proposal ;
  void *tmp ;
  u_int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;

  {
#line 78
  tmp = xmalloc(10U * sizeof(char *));
#line 78
  proposal = (char **)tmp;
#line 80
  buffer_init(& b);
#line 81
  tmp___0 = buffer_len(raw);
#line 81
  tmp___1 = buffer_ptr(raw);
#line 81
  buffer_append(& b, (char const   *)tmp___1, tmp___0);
#line 83
  i = 0;
#line 83
  while (i < 16) {
#line 84
    buffer_get_char(& b);
#line 83
    i ++;
  }
#line 86
  i = 0;
#line 86
  while (i < 10) {
#line 87
    *(proposal + i) = buffer_get_string(& b, (u_int *)((void *)0));
#line 88
    debug2("kex_parse_kexinit: %s", *(proposal + i));
#line 86
    i ++;
  }
#line 91
  i = buffer_get_char(& b);
#line 92
  debug2("kex_parse_kexinit: first_kex_follows %d ", i);
#line 93
  tmp___2 = buffer_get_int(& b);
#line 93
  i = (int )tmp___2;
#line 94
  debug2("kex_parse_kexinit: reserved %d ", i);
#line 95
  buffer_free(& b);
#line 96
  return (proposal);
}
}
#line 99 "kex.c"
static void kex_prop_free(char **proposal ) 
{ int i ;

  {
#line 104
  i = 0;
#line 104
  while (i < 10) {
#line 105
    xfree((void *)*(proposal + i));
#line 104
    i ++;
  }
#line 106
  xfree((void *)proposal);
#line 107
  return;
}
}
#line 109 "kex.c"
static void kex_protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 112
  error("Hm, kex protocol error: type %d plen %d", type, plen);
#line 113
  return;
}
}
#line 115 "kex.c"
static void kex_clear_dispatch(void) 
{ int i ;

  {
#line 121
  i = 30;
#line 121
  while (i <= 49) {
#line 122
    dispatch_set(i, & kex_protocol_error);
#line 121
    i ++;
  }
#line 123
  return;
}
}
#line 125 "kex.c"
void kex_finish(Kex *kex ) 
{ int plen ;

  {
#line 130
  kex_clear_dispatch();
#line 132
  packet_start((unsigned char)21);
#line 133
  packet_send();
#line 135
  debug("SSH2_MSG_NEWKEYS sent");
#line 137
  debug("waiting for SSH2_MSG_NEWKEYS");
#line 138
  packet_read_expect(& plen, 21);
#line 139
  debug("SSH2_MSG_NEWKEYS received");
#line 141
  kex->done = 1;
#line 142
  buffer_clear(& kex->peer);
#line 144
  kex->flags &= -2;
#line 145
  xfree((void *)kex->name);
#line 146
  kex->name = (char *)((void *)0);
#line 147
  return;
}
}
#line 149 "kex.c"
void kex_send_kexinit(Kex *kex ) 
{ u_int tmp ;
  char *tmp___0 ;

  {
#line 152
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 153
    error("kex_send_kexinit: no kex, cannot rekey");
#line 154
    return;
  }
#line 156
  if (kex->flags & 1) {
#line 157
    debug("KEX_INIT_SENT");
#line 158
    return;
  }
#line 160
  kex->done = 0;
#line 161
  packet_start((unsigned char)20);
#line 162
  tmp = buffer_len(& kex->my);
#line 162
  tmp___0 = buffer_ptr(& kex->my);
#line 162
  packet_put_raw((char const   *)tmp___0, tmp);
#line 163
  packet_send();
#line 164
  debug("SSH2_MSG_KEXINIT sent");
#line 165
  kex->flags |= 1;
#line 166
  return;
}
}
#line 168 "kex.c"
void kex_input_kexinit(int type , int plen , void *ctxt ) 
{ char *ptr ;
  int dlen ;
  int i ;
  Kex *kex ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 174
  kex = (Kex *)ctxt;
#line 176
  debug("SSH2_MSG_KEXINIT received");
#line 177
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 178
    fatal("kex_input_kexinit: no kex, cannot rekey");
  }
#line 180
  ptr = packet_get_raw(& dlen);
#line 181
  buffer_append(& kex->peer, (char const   *)ptr, (unsigned int )dlen);
#line 184
  i = 0;
#line 184
  while (i < 16) {
#line 185
    packet_get_char();
#line 184
    i ++;
  }
#line 186
  i = 0;
#line 186
  while (i < 10) {
#line 187
    tmp = packet_get_string((u_int *)((void *)0));
#line 187
    xfree((void *)tmp);
#line 186
    i ++;
  }
#line 188
  packet_get_char();
#line 189
  packet_get_int();
#line 190
  while (1) {
#line 190
    tmp___0 = packet_remaining();
#line 190
    _len = tmp___0;
#line 190
    if (_len > 0) {
#line 190
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c", 190);
#line 190
      packet_disconnect("Packet integrity error.");
    }
#line 190
    break;
  }
#line 192
  kex_kexinit_finish(kex);
#line 193
  return;
}
}
#line 195 "kex.c"
Kex *kex_setup(char **proposal ) 
{ Kex *kex ;
  void *tmp ;

  {
#line 200
  tmp = xmalloc(sizeof(*kex));
#line 200
  kex = (Kex *)tmp;
#line 201
  memset((void *)kex, 0, sizeof(*kex));
#line 202
  buffer_init(& kex->peer);
#line 203
  buffer_init(& kex->my);
#line 204
  kex_prop2buf(& kex->my, proposal);
#line 205
  kex->done = 0;
#line 207
  kex_send_kexinit(kex);
#line 208
  kex_clear_dispatch();
#line 209
  dispatch_set(20, & kex_input_kexinit);
#line 211
  return (kex);
}
}
#line 214 "kex.c"
static void kex_kexinit_finish(Kex *kex ) 
{ 

  {
#line 217
  if (! (kex->flags & 1)) {
#line 218
    kex_send_kexinit(kex);
  }
#line 220
  kex_choose_conf(kex);
#line 222
  switch (kex->kex_type) {
  case 0: 
#line 224
  kexdh(kex);
#line 225
  break;
  case 1: 
#line 227
  kexgex(kex);
#line 228
  break;
  default: 
#line 230
  fatal("Unsupported key exchange %d", kex->kex_type);
  }
#line 232
  return;
}
}
#line 234 "kex.c"
static void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 237
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 237
  name = tmp;
#line 238
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 239
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 240
  enc->cipher = cipher_by_name((char const   *)name);
#line 241
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 242
    fatal("matching cipher is not supported: %s", name);
  }
#line 243
  enc->name = name;
#line 244
  enc->enabled = 0;
#line 245
  enc->iv = (u_char *)((void *)0);
#line 246
  enc->key = (u_char *)((void *)0);
#line 247
  return;
}
}
#line 248 "kex.c"
static void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 251
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 251
  name = tmp;
#line 252
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 253
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 254
  tmp___0 = mac_init(mac, name);
#line 254
  if (tmp___0 < 0) {
#line 255
    fatal("unsupported mac %s", name);
  }
#line 257
  if (datafellows & 4) {
#line 258
    mac->key_len = 16;
  }
#line 259
  mac->name = name;
#line 260
  mac->key = (u_char *)((void *)0);
#line 261
  mac->enabled = 0;
#line 262
  return;
}
}
#line 263 "kex.c"
static void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 266
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 266
  name = tmp;
#line 267
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 268
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 269
  if (0) {
#line 269
    __s1_len___0 = strlen((char const   *)name);
#line 269
    __s2_len___0 = strlen("zlib");
#line 269
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 269
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 269
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 269
          tmp___19 = 1;
        } else {
#line 269
          if (__s2_len___0 >= 4U) {
#line 269
            tmp___19 = 1;
          } else {
#line 269
            tmp___19 = 0;
          }
        }
      } else {
#line 269
        tmp___19 = 0;
      }
    }
#line 269
    if (tmp___19) {
#line 269
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 269
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 269
      tmp___15 = tmp___18;
    }
  } else {
#line 269
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 269
    tmp___15 = tmp___18;
  }
#line 269
  if (tmp___15 == 0) {
#line 270
    comp->type = 1;
  } else {
#line 271
    if (0) {
#line 271
      __s1_len = strlen((char const   *)name);
#line 271
      __s2_len = strlen("none");
#line 271
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 271
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 271
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 271
            tmp___9 = 1;
          } else {
#line 271
            if (__s2_len >= 4U) {
#line 271
              tmp___9 = 1;
            } else {
#line 271
              tmp___9 = 0;
            }
          }
        } else {
#line 271
          tmp___9 = 0;
        }
      }
#line 271
      if (tmp___9) {
#line 271
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 271
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 271
        tmp___5 = tmp___8;
      }
    } else {
#line 271
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 271
      tmp___5 = tmp___8;
    }
#line 271
    if (tmp___5 == 0) {
#line 272
      comp->type = 0;
    } else {
#line 274
      fatal("unsupported comp %s", name);
    }
  }
#line 276
  comp->name = name;
#line 277
  return;
}
}
#line 278 "kex.c"
static void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 281
  k->name = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 282
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 283
    fatal("no kex alg");
  }
#line 284
  if (0) {
#line 284
    __s1_len___0 = strlen((char const   *)k->name);
#line 284
    __s2_len___0 = strlen("diffie-hellman-group1-sha1");
#line 284
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___2;
    } else {
#line 284
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 284
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 284
          tmp___18 = 1;
        } else {
#line 284
          if (__s2_len___0 >= 4U) {
#line 284
            tmp___18 = 1;
          } else {
#line 284
            tmp___18 = 0;
          }
        }
      } else {
#line 284
        tmp___18 = 0;
      }
    }
#line 284
    if (tmp___18) {
#line 284
      tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 284
      tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 284
      tmp___14 = tmp___17;
    }
  } else {
#line 284
    tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 284
    tmp___14 = tmp___17;
  }
#line 284
  if (tmp___14 == 0) {
#line 285
    k->kex_type = 0;
  } else {
#line 286
    if (0) {
#line 286
      __s1_len = strlen((char const   *)k->name);
#line 286
      __s2_len = strlen("diffie-hellman-group-exchange-sha1");
#line 286
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___0;
      } else {
#line 286
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 286
          if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 286
            tmp___8 = 1;
          } else {
#line 286
            if (__s2_len >= 4U) {
#line 286
              tmp___8 = 1;
            } else {
#line 286
              tmp___8 = 0;
            }
          }
        } else {
#line 286
          tmp___8 = 0;
        }
      }
#line 286
      if (tmp___8) {
#line 286
        tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
      } else {
#line 286
        tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 286
        tmp___4 = tmp___7;
      }
    } else {
#line 286
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 286
      tmp___4 = tmp___7;
    }
#line 286
    if (tmp___4 == 0) {
#line 287
      k->kex_type = 1;
    } else {
#line 289
      fatal("bad kex alg %s", k->name);
    }
  }
#line 290
  return;
}
}
#line 291 "kex.c"
static void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 294
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 294
  hostkeyalg = tmp;
#line 295
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 296
    fatal("no hostkey alg");
  }
#line 297
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 298
  if (k->hostkey_type == 3) {
#line 299
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 300
  xfree((void *)hostkeyalg);
#line 301
  return;
}
}
#line 303 "kex.c"
static void kex_choose_conf(Kex *kex ) 
{ Newkeys *newkeys___0 ;
  char **my ;
  char **peer ;
  char **cprop ;
  char **sprop ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int mode ;
  int ctos ;
  int need ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 314
  my = kex_buf2prop(& kex->my);
#line 315
  peer = kex_buf2prop(& kex->peer);
#line 317
  if (kex->server) {
#line 318
    cprop = peer;
#line 319
    sprop = my;
  } else {
#line 321
    cprop = my;
#line 322
    sprop = peer;
  }
#line 326
  mode = 0;
#line 326
  while (mode < 2) {
#line 327
    tmp = xmalloc(sizeof(*newkeys___0));
#line 327
    newkeys___0 = (Newkeys *)tmp;
#line 328
    memset((void *)newkeys___0, 0, sizeof(*newkeys___0));
#line 329
    kex->newkeys[mode] = newkeys___0;
#line 330
    if (! kex->server) {
#line 330
      if (mode == 1) {
#line 330
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 330
      if (kex->server) {
#line 330
        if (mode == 0) {
#line 330
          tmp___0 = 1;
        } else {
#line 330
          tmp___0 = 0;
        }
      } else {
#line 330
        tmp___0 = 0;
      }
    }
#line 330
    ctos = tmp___0;
#line 331
    if (ctos) {
#line 331
      nenc = 2;
    } else {
#line 331
      nenc = 3;
    }
#line 332
    if (ctos) {
#line 332
      nmac = 4;
    } else {
#line 332
      nmac = 5;
    }
#line 333
    if (ctos) {
#line 333
      ncomp = 6;
    } else {
#line 333
      ncomp = 7;
    }
#line 334
    choose_enc(& newkeys___0->enc, *(cprop + nenc), *(sprop + nenc));
#line 335
    choose_mac(& newkeys___0->mac, *(cprop + nmac), *(sprop + nmac));
#line 336
    choose_comp(& newkeys___0->comp, *(cprop + ncomp), *(sprop + ncomp));
#line 337
    if (ctos) {
#line 337
      tmp___1 = "client->server";
    } else {
#line 337
      tmp___1 = "server->client";
    }
#line 337
    debug("kex: %s %s %s %s", tmp___1, newkeys___0->enc.name, newkeys___0->mac.name,
          newkeys___0->comp.name);
#line 326
    mode ++;
  }
#line 343
  choose_kex(kex, *(cprop + 0), *(sprop + 0));
#line 344
  choose_hostkeyalg(kex, *(cprop + 1), *(sprop + 1));
#line 346
  need = 0;
#line 347
  mode = 0;
#line 347
  while (mode < 2) {
#line 348
    newkeys___0 = kex->newkeys[mode];
#line 349
    if ((u_int )need < (newkeys___0->enc.cipher)->key_len) {
#line 350
      need = (int )(newkeys___0->enc.cipher)->key_len;
    }
#line 351
    if ((u_int )need < (newkeys___0->enc.cipher)->block_size) {
#line 352
      need = (int )(newkeys___0->enc.cipher)->block_size;
    }
#line 353
    if (need < newkeys___0->mac.key_len) {
#line 354
      need = newkeys___0->mac.key_len;
    }
#line 347
    mode ++;
  }
#line 357
  kex->we_need = need;
#line 359
  kex_prop_free(my);
#line 360
  kex_prop_free(peer);
#line 361
  return;
}
}
#line 363 "kex.c"
static u_char *derive_key(Kex *kex , int id , int need , u_char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;

  {
#line 367
  tmp = EVP_sha1();
#line 367
  evp_md = (EVP_MD *)tmp;
#line 369
  c = (char )id;
#line 371
  mdsz = evp_md->md_size;
#line 372
  tmp___0 = xmalloc((unsigned int )(((need + (mdsz - 1)) / mdsz) * mdsz));
#line 372
  digest___1 = (u_char *)tmp___0;
#line 374
  buffer_init(& b);
#line 375
  buffer_put_bignum2(& b, shared_secret);
#line 378
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 379
  if (! (datafellows & 262144)) {
#line 380
    tmp___1 = buffer_len(& b);
#line 380
    tmp___2 = buffer_ptr(& b);
#line 380
    EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
  }
#line 381
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 382
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 383
  EVP_DigestUpdate(& md, (void const   *)kex->session_id, (unsigned int )kex->session_id_len);
#line 384
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 391
  have = mdsz;
#line 391
  while (need > have) {
#line 392
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 393
    if (! (datafellows & 262144)) {
#line 394
      tmp___3 = buffer_len(& b);
#line 394
      tmp___4 = buffer_ptr(& b);
#line 394
      EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
    }
#line 395
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 396
    EVP_DigestUpdate(& md, (void const   *)digest___1, (unsigned int )have);
#line 397
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 391
    have += mdsz;
  }
#line 399
  buffer_free(& b);
#line 404
  return (digest___1);
}
}
#line 407 "kex.c"
Newkeys *current_keys[2]  ;
#line 410 "kex.c"
void kex_derive_keys(Kex *kex , u_char *hash , BIGNUM *shared_secret ) 
{ u_char *keys[6] ;
  int i ;
  int mode ;
  int ctos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 416
  i = 0;
#line 416
  while (i < 6) {
#line 417
    keys[i] = derive_key(kex, 65 + i, kex->we_need, hash, shared_secret);
#line 416
    i ++;
  }
#line 419
  debug("kex_derive_keys");
#line 420
  mode = 0;
#line 420
  while (mode < 2) {
#line 421
    current_keys[mode] = kex->newkeys[mode];
#line 422
    kex->newkeys[mode] = (Newkeys *)((void *)0);
#line 423
    if (! kex->server) {
#line 423
      if (mode == 1) {
#line 423
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 423
      if (kex->server) {
#line 423
        if (mode == 0) {
#line 423
          tmp = 1;
        } else {
#line 423
          tmp = 0;
        }
      } else {
#line 423
        tmp = 0;
      }
    }
#line 423
    ctos = tmp;
#line 424
    if (ctos) {
#line 424
      tmp___0 = 0;
    } else {
#line 424
      tmp___0 = 1;
    }
#line 424
    (current_keys[mode])->enc.iv = keys[tmp___0];
#line 425
    if (ctos) {
#line 425
      tmp___1 = 2;
    } else {
#line 425
      tmp___1 = 3;
    }
#line 425
    (current_keys[mode])->enc.key = keys[tmp___1];
#line 426
    if (ctos) {
#line 426
      tmp___2 = 4;
    } else {
#line 426
      tmp___2 = 5;
    }
#line 426
    (current_keys[mode])->mac.key = keys[tmp___2];
#line 420
    mode ++;
  }
#line 428
  return;
}
}
#line 430 "kex.c"
Newkeys *kex_get_newkeys(int mode ) 
{ Newkeys *ret ;

  {
#line 435
  ret = current_keys[mode];
#line 436
  current_keys[mode] = (Newkeys *)((void *)0);
#line 437
  return (ret);
}
}
#line 1 "kexdh.o"
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 37 "packet.h"
void packet_put_bignum2(BIGNUM *value ) ;
#line 51
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 53 "kexdh.c"
static u_char digest[64]  ;
#line 41 "kexdh.c"
static u_char *kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                           char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                           u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                           BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  char *tmp___1 ;

  {
#line 54
  tmp = EVP_sha1();
#line 54
  evp_md = (EVP_MD *)tmp;
#line 57
  buffer_init(& b);
#line 58
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 59
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 62
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 63
  buffer_put_char(& b, 20);
#line 64
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 65
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 66
  buffer_put_char(& b, 20);
#line 67
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 69
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 70
  buffer_put_bignum2(& b, client_dh_pub);
#line 71
  buffer_put_bignum2(& b, server_dh_pub);
#line 72
  buffer_put_bignum2(& b, shared_secret);
#line 77
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 78
  tmp___0 = buffer_len(& b);
#line 78
  tmp___1 = buffer_ptr(& b);
#line 78
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 79
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 81
  buffer_free(& b);
#line 86
  return (digest);
}
}
#line 91 "kexdh.c"
static void kexdh_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  DH *dh ;
  Key *server_host_key ;
  u_char *server_host_key_blob ;
  u_char *signature ;
  u_char *kbuf ;
  u_char *hash ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  int dlen ;
  int plen ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  char *tmp___8 ;
  u_int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;

  {
#line 94
  dh_server_pub = (BIGNUM *)((void *)0);
#line 94
  shared_secret = (BIGNUM *)((void *)0);
#line 97
  server_host_key_blob = (u_char *)((void *)0);
#line 97
  signature = (u_char *)((void *)0);
#line 103
  dh = dh_new_group1();
#line 104
  dh_gen_key(dh, kex->we_need * 8);
#line 105
  packet_start((unsigned char)30);
#line 106
  packet_put_bignum2(dh->pub_key);
#line 107
  packet_send();
#line 109
  debug("sending SSH2_MSG_KEXDH_INIT");
#line 117
  debug("expecting SSH2_MSG_KEXDH_REPLY");
#line 118
  packet_read_expect(& plen, 31);
#line 121
  tmp = packet_get_string(& sbloblen);
#line 121
  server_host_key_blob = (u_char *)tmp;
#line 122
  server_host_key = key_from_blob(server_host_key_blob, (int )sbloblen);
#line 123
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 124
    fatal("cannot decode server_host_key_blob");
  }
#line 126
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 127
    fatal("cannot verify server_host_key");
  }
#line 128
  tmp___0 = (*(kex->verify_host_key))(server_host_key);
#line 128
  if (tmp___0 == -1) {
#line 129
    fatal("server_host_key verification failed");
  }
#line 132
  dh_server_pub = BN_new();
#line 133
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 134
    fatal("dh_server_pub == NULL");
  }
#line 135
  packet_get_bignum2(dh_server_pub, & dlen);
#line 145
  tmp___1 = packet_get_string(& slen);
#line 145
  signature = (u_char *)tmp___1;
#line 146
  while (1) {
#line 146
    tmp___2 = packet_remaining();
#line 146
    _len = tmp___2;
#line 146
    if (_len > 0) {
#line 146
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdh.c",
          146);
#line 146
      packet_disconnect("Packet integrity error.");
    }
#line 146
    break;
  }
#line 148
  tmp___3 = dh_pub_is_valid(dh, dh_server_pub);
#line 148
  if (! tmp___3) {
#line 149
    packet_disconnect("bad server public DH value");
  }
#line 151
  tmp___4 = DH_size((DH const   *)dh);
#line 151
  klen = (unsigned int )tmp___4;
#line 152
  tmp___5 = xmalloc(klen);
#line 152
  kbuf = (u_char *)tmp___5;
#line 153
  tmp___6 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 153
  kout = (unsigned int )tmp___6;
#line 157
  shared_secret = BN_new();
#line 158
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 159
  memset((void *)kbuf, 0, klen);
#line 160
  xfree((void *)kbuf);
#line 163
  tmp___7 = buffer_len(& kex->peer);
#line 163
  tmp___8 = buffer_ptr(& kex->peer);
#line 163
  tmp___9 = buffer_len(& kex->my);
#line 163
  tmp___10 = buffer_ptr(& kex->my);
#line 163
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, tmp___10,
                     (int )tmp___9, tmp___8, (int )tmp___7, server_host_key_blob,
                     (int )sbloblen, dh->pub_key, dh_server_pub, shared_secret);
#line 173
  xfree((void *)server_host_key_blob);
#line 174
  BN_free(dh_server_pub);
#line 175
  DH_free(dh);
#line 177
  tmp___11 = key_verify(server_host_key, signature, (int )slen, hash, 20);
#line 177
  if (tmp___11 != 1) {
#line 178
    fatal("key_verify failed for server_host_key");
  }
#line 179
  key_free(server_host_key);
#line 180
  xfree((void *)signature);
#line 183
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 184
    kex->session_id_len = 20;
#line 185
    tmp___12 = xmalloc((unsigned int )kex->session_id_len);
#line 185
    kex->session_id = (u_char *)tmp___12;
#line 186
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 189
  kex_derive_keys(kex, hash, shared_secret);
#line 190
  BN_clear_free(shared_secret);
#line 191
  kex_finish(kex);
#line 192
  return;
}
}
#line 196 "kexdh.c"
static void kexdh_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  int dlen ;
  int slen ;
  int plen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
#line 199
  shared_secret = (BIGNUM *)((void *)0);
#line 199
  dh_client_pub = (BIGNUM *)((void *)0);
#line 202
  signature = (u_char *)((void *)0);
#line 202
  server_host_key_blob = (u_char *)((void *)0);
#line 207
  dh = dh_new_group1();
#line 208
  dh_gen_key(dh, kex->we_need * 8);
#line 210
  debug("expecting SSH2_MSG_KEXDH_INIT");
#line 211
  packet_read_expect(& plen, 30);
#line 213
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 214
    fatal("Cannot load hostkey");
  }
#line 215
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 216
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 217
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 220
  dh_client_pub = BN_new();
#line 221
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 222
    fatal("dh_client_pub == NULL");
  }
#line 223
  packet_get_bignum2(dh_client_pub, & dlen);
#line 238
  tmp = dh_pub_is_valid(dh, dh_client_pub);
#line 238
  if (! tmp) {
#line 239
    packet_disconnect("bad client public DH value");
  }
#line 241
  tmp___0 = DH_size((DH const   *)dh);
#line 241
  klen = (unsigned int )tmp___0;
#line 242
  tmp___1 = xmalloc(klen);
#line 242
  kbuf = (u_char *)tmp___1;
#line 243
  tmp___2 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 243
  kout = (unsigned int )tmp___2;
#line 247
  shared_secret = BN_new();
#line 248
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 249
  memset((void *)kbuf, 0, klen);
#line 250
  xfree((void *)kbuf);
#line 252
  key_to_blob(server_host_key, & server_host_key_blob, & sbloblen);
#line 255
  tmp___3 = buffer_len(& kex->my);
#line 255
  tmp___4 = buffer_ptr(& kex->my);
#line 255
  tmp___5 = buffer_len(& kex->peer);
#line 255
  tmp___6 = buffer_ptr(& kex->peer);
#line 255
  hash = kex_dh_hash(kex->client_version_string, kex->server_version_string, tmp___6,
                     (int )tmp___5, tmp___4, (int )tmp___3, server_host_key_blob,
                     (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret);
#line 265
  BN_free(dh_client_pub);
#line 269
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 270
    kex->session_id_len = 20;
#line 271
    tmp___7 = xmalloc((unsigned int )kex->session_id_len);
#line 271
    kex->session_id = (u_char *)tmp___7;
#line 272
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 277
  key_sign(server_host_key, & signature, & slen, hash, 20);
#line 282
  packet_start((unsigned char)31);
#line 283
  packet_put_string((char const   *)server_host_key_blob, sbloblen);
#line 284
  packet_put_bignum2(dh->pub_key);
#line 285
  packet_put_string((char const   *)signature, (unsigned int )slen);
#line 286
  packet_send();
#line 288
  xfree((void *)signature);
#line 289
  xfree((void *)server_host_key_blob);
#line 291
  DH_free(dh);
#line 293
  kex_derive_keys(kex, hash, shared_secret);
#line 294
  BN_clear_free(shared_secret);
#line 295
  kex_finish(kex);
#line 296
  return;
}
}
#line 298 "kexdh.c"
void kexdh(Kex *kex ) 
{ 

  {
#line 301
  if (kex->server) {
#line 302
    kexdh_server(kex);
  } else {
#line 304
    kexdh_client(kex);
  }
#line 305
  return;
}
}
#line 1 "kexgex.o"
#line 55 "kexgex.c"
static u_char digest___0[64]  ;
#line 42 "kexgex.c"
static u_char *kexgex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                           char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                           u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                           int max , BIGNUM *prime , BIGNUM *gen___0 , BIGNUM *client_dh_pub ,
                           BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  char *tmp___1 ;

  {
#line 56
  tmp = EVP_sha1();
#line 56
  evp_md = (EVP_MD *)tmp;
#line 59
  buffer_init(& b);
#line 60
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 61
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 64
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 65
  buffer_put_char(& b, 20);
#line 66
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 67
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 68
  buffer_put_char(& b, 20);
#line 69
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 71
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 72
  if (min == -1) {
#line 73
    buffer_put_int(& b, (unsigned int )wantbits);
  } else {
#line 72
    if (max == -1) {
#line 73
      buffer_put_int(& b, (unsigned int )wantbits);
    } else {
#line 75
      buffer_put_int(& b, (unsigned int )min);
#line 76
      buffer_put_int(& b, (unsigned int )wantbits);
#line 77
      buffer_put_int(& b, (unsigned int )max);
    }
  }
#line 79
  buffer_put_bignum2(& b, prime);
#line 80
  buffer_put_bignum2(& b, gen___0);
#line 81
  buffer_put_bignum2(& b, client_dh_pub);
#line 82
  buffer_put_bignum2(& b, server_dh_pub);
#line 83
  buffer_put_bignum2(& b, shared_secret);
#line 88
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 89
  tmp___0 = buffer_len(& b);
#line 89
  tmp___1 = buffer_ptr(& b);
#line 89
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 90
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 92
  buffer_free(& b);
#line 97
  return (digest___0);
}
}
#line 102 "kexgex.c"
static void kexgex_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  BIGNUM *p ;
  BIGNUM *g ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int sbloblen ;
  int dlen ;
  int plen ;
  int min ;
  int max ;
  int nbits ;
  DH *dh ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  char *tmp___12 ;
  u_int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 105
  dh_server_pub = (BIGNUM *)((void *)0);
#line 105
  shared_secret = (BIGNUM *)((void *)0);
#line 106
  p = (BIGNUM *)((void *)0);
#line 106
  g = (BIGNUM *)((void *)0);
#line 108
  signature = (u_char *)((void *)0);
#line 108
  server_host_key_blob = (u_char *)((void *)0);
#line 113
  nbits = dh_estimate(kex->we_need * 8);
#line 115
  if (datafellows & 16384) {
#line 116
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD sent");
#line 119
    packet_start((unsigned char)30);
#line 120
    packet_put_int((unsigned int )nbits);
#line 121
    min = 1024;
#line 122
    max = 8192;
  } else {
#line 124
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST sent");
#line 127
    min = 1024;
#line 128
    max = 8192;
#line 129
    packet_start((unsigned char)34);
#line 130
    packet_put_int((unsigned int )min);
#line 131
    packet_put_int((unsigned int )nbits);
#line 132
    packet_put_int((unsigned int )max);
  }
#line 138
  packet_send();
#line 140
  debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
#line 141
  packet_read_expect(& plen, 31);
#line 143
  p = BN_new();
#line 143
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 144
    fatal("BN_new");
  }
#line 145
  packet_get_bignum2(p, & dlen);
#line 146
  g = BN_new();
#line 146
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 147
    fatal("BN_new");
  }
#line 148
  packet_get_bignum2(g, & dlen);
#line 149
  while (1) {
#line 149
    tmp = packet_remaining();
#line 149
    _len = tmp;
#line 149
    if (_len > 0) {
#line 149
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgex.c",
          149);
#line 149
      packet_disconnect("Packet integrity error.");
    }
#line 149
    break;
  }
#line 151
  tmp___1 = BN_num_bits((BIGNUM const   *)p);
#line 151
  if (tmp___1 < min) {
#line 152
    tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 152
    fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
  } else {
#line 151
    tmp___2 = BN_num_bits((BIGNUM const   *)p);
#line 151
    if (tmp___2 > max) {
#line 152
      tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 152
      fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
    }
  }
#line 155
  dh = dh_new_group(g, p);
#line 156
  dh_gen_key(dh, kex->we_need * 8);
#line 165
  debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#line 167
  packet_start((unsigned char)32);
#line 168
  packet_put_bignum2(dh->pub_key);
#line 169
  packet_send();
#line 171
  debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
#line 172
  packet_read_expect(& plen, 33);
#line 175
  tmp___3 = packet_get_string(& sbloblen);
#line 175
  server_host_key_blob = (u_char *)tmp___3;
#line 176
  server_host_key = key_from_blob(server_host_key_blob, (int )sbloblen);
#line 177
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 178
    fatal("cannot decode server_host_key_blob");
  }
#line 180
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 181
    fatal("cannot verify server_host_key");
  }
#line 182
  tmp___4 = (*(kex->verify_host_key))(server_host_key);
#line 182
  if (tmp___4 == -1) {
#line 183
    fatal("server_host_key verification failed");
  }
#line 186
  dh_server_pub = BN_new();
#line 187
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 188
    fatal("dh_server_pub == NULL");
  }
#line 189
  packet_get_bignum2(dh_server_pub, & dlen);
#line 199
  tmp___5 = packet_get_string(& slen);
#line 199
  signature = (u_char *)tmp___5;
#line 200
  while (1) {
#line 200
    tmp___6 = packet_remaining();
#line 200
    _len___0 = tmp___6;
#line 200
    if (_len___0 > 0) {
#line 200
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgex.c",
          200);
#line 200
      packet_disconnect("Packet integrity error.");
    }
#line 200
    break;
  }
#line 202
  tmp___7 = dh_pub_is_valid(dh, dh_server_pub);
#line 202
  if (! tmp___7) {
#line 203
    packet_disconnect("bad server public DH value");
  }
#line 205
  tmp___8 = DH_size((DH const   *)dh);
#line 205
  klen = (unsigned int )tmp___8;
#line 206
  tmp___9 = xmalloc(klen);
#line 206
  kbuf = (u_char *)tmp___9;
#line 207
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 207
  kout = (unsigned int )tmp___10;
#line 211
  shared_secret = BN_new();
#line 212
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 213
  memset((void *)kbuf, 0, klen);
#line 214
  xfree((void *)kbuf);
#line 216
  if (datafellows & 16384) {
#line 217
    max = -1;
#line 217
    min = max;
  }
#line 220
  tmp___11 = buffer_len(& kex->peer);
#line 220
  tmp___12 = buffer_ptr(& kex->peer);
#line 220
  tmp___13 = buffer_len(& kex->my);
#line 220
  tmp___14 = buffer_ptr(& kex->my);
#line 220
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, tmp___14,
                     (int )tmp___13, tmp___12, (int )tmp___11, server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh->pub_key, dh_server_pub,
                     shared_secret);
#line 233
  DH_free(dh);
#line 234
  xfree((void *)server_host_key_blob);
#line 235
  BN_free(dh_server_pub);
#line 237
  tmp___15 = key_verify(server_host_key, signature, (int )slen, hash, 20);
#line 237
  if (tmp___15 != 1) {
#line 238
    fatal("key_verify failed for server_host_key");
  }
#line 239
  key_free(server_host_key);
#line 240
  xfree((void *)signature);
#line 243
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 244
    kex->session_id_len = 20;
#line 245
    tmp___16 = xmalloc((unsigned int )kex->session_id_len);
#line 245
    kex->session_id = (u_char *)tmp___16;
#line 246
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 248
  kex_derive_keys(kex, hash, shared_secret);
#line 249
  BN_clear_free(shared_secret);
#line 251
  kex_finish(kex);
#line 252
  return;
}
}
#line 256 "kexgex.c"
static void kexgex_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  int min ;
  int max ;
  int nbits ;
  int type ;
  int plen ;
  int dlen ;
  int slen ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  u_int tmp___8 ;
  char *tmp___9 ;
  u_int tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;

  {
#line 259
  shared_secret = (BIGNUM *)((void *)0);
#line 259
  dh_client_pub = (BIGNUM *)((void *)0);
#line 261
  dh = dh;
#line 262
  signature = (u_char *)((void *)0);
#line 262
  server_host_key_blob = (u_char *)((void *)0);
#line 264
  min = -1;
#line 264
  max = -1;
#line 264
  nbits = -1;
#line 266
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 267
    fatal("Cannot load hostkey");
  }
#line 268
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 269
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 270
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 272
  type = packet_read(& plen);
#line 273
  switch (type) {
  case 34: 
#line 275
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
#line 276
  tmp = packet_get_int();
#line 276
  min = (int )tmp;
#line 277
  tmp___0 = packet_get_int();
#line 277
  nbits = (int )tmp___0;
#line 278
  tmp___1 = packet_get_int();
#line 278
  max = (int )tmp___1;
#line 279
  if (1024 > min) {
#line 279
    min = 1024;
  } else {
#line 279
    min = min;
  }
#line 280
  if (8192 < max) {
#line 280
    max = 8192;
  } else {
#line 280
    max = max;
  }
#line 281
  break;
  case 30: 
#line 283
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
#line 284
  tmp___2 = packet_get_int();
#line 284
  nbits = (int )tmp___2;
#line 285
  min = 1024;
#line 286
  max = 8192;
#line 288
  break;
  default: 
#line 290
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
#line 292
  while (1) {
#line 292
    tmp___3 = packet_remaining();
#line 292
    _len = tmp___3;
#line 292
    if (_len > 0) {
#line 292
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgex.c",
          292);
#line 292
      packet_disconnect("Packet integrity error.");
    }
#line 292
    break;
  }
#line 294
  if (max < min) {
#line 295
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
  } else {
#line 294
    if (nbits < min) {
#line 295
      fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    } else {
#line 294
      if (max < nbits) {
#line 295
        fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
      }
    }
  }
#line 298
  dh = choose_dh(min, nbits, max);
#line 299
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 300
    packet_disconnect("Protocol error: no matching DH grp found");
  }
#line 302
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
#line 303
  packet_start((unsigned char)31);
#line 304
  packet_put_bignum2(dh->p);
#line 305
  packet_put_bignum2(dh->g);
#line 306
  packet_send();
#line 309
  packet_write_wait();
#line 312
  dh_gen_key(dh, kex->we_need * 8);
#line 314
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
#line 315
  packet_read_expect(& plen, 32);
#line 318
  dh_client_pub = BN_new();
#line 319
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 320
    fatal("dh_client_pub == NULL");
  }
#line 321
  packet_get_bignum2(dh_client_pub, & dlen);
#line 336
  tmp___4 = dh_pub_is_valid(dh, dh_client_pub);
#line 336
  if (! tmp___4) {
#line 337
    packet_disconnect("bad client public DH value");
  }
#line 339
  tmp___5 = DH_size((DH const   *)dh);
#line 339
  klen = (unsigned int )tmp___5;
#line 340
  tmp___6 = xmalloc(klen);
#line 340
  kbuf = (u_char *)tmp___6;
#line 341
  tmp___7 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 341
  kout = (unsigned int )tmp___7;
#line 345
  shared_secret = BN_new();
#line 346
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 347
  memset((void *)kbuf, 0, klen);
#line 348
  xfree((void *)kbuf);
#line 350
  key_to_blob(server_host_key, & server_host_key_blob, & sbloblen);
#line 352
  if (type == 30) {
#line 353
    max = -1;
#line 353
    min = max;
  }
#line 356
  tmp___8 = buffer_len(& kex->my);
#line 356
  tmp___9 = buffer_ptr(& kex->my);
#line 356
  tmp___10 = buffer_len(& kex->peer);
#line 356
  tmp___11 = buffer_ptr(& kex->peer);
#line 356
  hash = kexgex_hash(kex->client_version_string, kex->server_version_string, tmp___11,
                     (int )tmp___10, tmp___9, (int )tmp___8, server_host_key_blob,
                     (int )sbloblen, min, nbits, max, dh->p, dh->g, dh_client_pub,
                     dh->pub_key, shared_secret);
#line 368
  BN_free(dh_client_pub);
#line 372
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 373
    kex->session_id_len = 20;
#line 374
    tmp___12 = xmalloc((unsigned int )kex->session_id_len);
#line 374
    kex->session_id = (u_char *)tmp___12;
#line 375
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           (unsigned int )kex->session_id_len);
  }
#line 380
  key_sign(server_host_key, & signature, & slen, hash, 20);
#line 385
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
#line 386
  packet_start((unsigned char)33);
#line 387
  packet_put_string((char const   *)server_host_key_blob, sbloblen);
#line 388
  packet_put_bignum2(dh->pub_key);
#line 389
  packet_put_string((char const   *)signature, (unsigned int )slen);
#line 390
  packet_send();
#line 391
  xfree((void *)signature);
#line 392
  xfree((void *)server_host_key_blob);
#line 394
  DH_free(dh);
#line 396
  kex_derive_keys(kex, hash, shared_secret);
#line 397
  BN_clear_free(shared_secret);
#line 399
  kex_finish(kex);
#line 400
  return;
}
}
#line 402 "kexgex.c"
void kexgex(Kex *kex ) 
{ 

  {
#line 405
  if (kex->server) {
#line 406
    kexgex_server(kex);
  } else {
#line 408
    kexgex_client(kex);
  }
#line 409
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 49 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 51
SyslogFacility log_facility_number(char *name ) ;
#line 52
LogLevel log_level_number(char *name ) ;
#line 44 "log.c"
static LogLevel log_level  =    3;
#line 45 "log.c"
static int log_on_stderr  =    1;
#line 46 "log.c"
static int log_facility  =    4 << 3;
#line 47 "log.c"
static char *argv0  ;
#line 53 "log.c"
static struct __anonstruct_log_facilities_65 log_facilities[13]  = 
#line 53
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"AUTHPRIV", 3}, 
        {"LOCAL0", 4}, 
        {"LOCAL1", 5}, 
        {"LOCAL2", 6}, 
        {"LOCAL3", 7}, 
        {"LOCAL4", 8}, 
        {"LOCAL5", 9}, 
        {"LOCAL6", 10}, 
        {"LOCAL7", 11}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 74 "log.c"
static struct __anonstruct_log_levels_66 log_levels[10]  = 
#line 74
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 91
static void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 93 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 97
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 98
    i = 0;
#line 98
    while (log_facilities[i].name) {
#line 99
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 99
      if (tmp == 0) {
#line 100
        return (log_facilities[i].val);
      }
#line 98
      i ++;
    }
  }
#line 101
  return ((enum __anonenum_SyslogFacility_63 )-1);
}
}
#line 104 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 108
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 109
    i = 0;
#line 109
    while (log_levels[i].name) {
#line 110
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 110
      if (tmp == 0) {
#line 111
        return (log_levels[i].val);
      }
#line 109
      i ++;
    }
  }
#line 112
  return ((enum __anonenum_LogLevel_64 )-1);
}
}
#line 116 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 120
  __builtin_va_start(args, fmt);
#line 121
  do_log(1, fmt, args);
#line 122
  __builtin_va_end(args);
#line 123
  fatal_cleanup();
#line 124
  return;
}
}
#line 128 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 132
  __builtin_va_start(args, fmt);
#line 133
  do_log(2, fmt, args);
#line 134
  __builtin_va_end(args);
#line 135
  return;
}
}
#line 139 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 143
  __builtin_va_start(args, fmt);
#line 144
  do_log(3, fmt, args);
#line 145
  __builtin_va_end(args);
#line 146
  return;
}
}
#line 150 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 154
  __builtin_va_start(args, fmt);
#line 155
  do_log(4, fmt, args);
#line 156
  __builtin_va_end(args);
#line 157
  return;
}
}
#line 161 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 165
  __builtin_va_start(args, fmt);
#line 166
  do_log(5, fmt, args);
#line 167
  __builtin_va_end(args);
#line 168
  return;
}
}
#line 170 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 174
  __builtin_va_start(args, fmt);
#line 175
  do_log(6, fmt, args);
#line 176
  __builtin_va_end(args);
#line 177
  return;
}
}
#line 179 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 183
  __builtin_va_start(args, fmt);
#line 184
  do_log(7, fmt, args);
#line 185
  __builtin_va_end(args);
#line 186
  return;
}
}
#line 196 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 200 "log.c"
void fatal_add_cleanup(void (*proc)(void * ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 205
  tmp = xmalloc(sizeof(*cu));
#line 205
  cu = (struct fatal_cleanup *)tmp;
#line 206
  cu->proc = proc;
#line 207
  cu->context = context;
#line 208
  cu->next = fatal_cleanups;
#line 209
  fatal_cleanups = cu;
#line 210
  return;
}
}
#line 214 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 219
  cup = & fatal_cleanups;
#line 219
  while (*cup) {
#line 220
    cu = *cup;
#line 221
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 221
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 222
        *cup = cu->next;
#line 223
        xfree((void *)cu);
#line 224
        return;
      }
    }
#line 219
    cup = & cu->next;
  }
#line 227
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx", (unsigned long )proc,
        (unsigned long )context);
#line 229
  return;
}
}
#line 236 "log.c"
static int called  =    0;
#line 232 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 238
  if (called) {
#line 239
    exit(255);
  }
#line 240
  called = 1;
#line 242
  cu = fatal_cleanups;
#line 242
  while (cu) {
#line 243
    next_cu = cu->next;
#line 244
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 246
    (*(cu->proc))(cu->context);
#line 242
    cu = next_cu;
  }
#line 248
  exit(255);
}
}
#line 256 "log.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 259
  argv0 = av0;
#line 261
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 270
  log_level = level;
#line 271
  break;
  default: 
#line 273
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 275
  exit(1);
  }
#line 278
  log_on_stderr = on_stderr;
#line 279
  if (on_stderr) {
#line 280
    return;
  }
#line 282
  switch ((int )facility) {
  case 0: 
#line 284
  log_facility = 3 << 3;
#line 285
  break;
  case 1: 
#line 287
  log_facility = 1 << 3;
#line 288
  break;
  case 2: 
#line 290
  log_facility = 4 << 3;
#line 291
  break;
  case 3: 
#line 294
  log_facility = 10 << 3;
#line 295
  break;
  case 4: 
#line 298
  log_facility = 16 << 3;
#line 299
  break;
  case 5: 
#line 301
  log_facility = 17 << 3;
#line 302
  break;
  case 6: 
#line 304
  log_facility = 18 << 3;
#line 305
  break;
  case 7: 
#line 307
  log_facility = 19 << 3;
#line 308
  break;
  case 8: 
#line 310
  log_facility = 20 << 3;
#line 311
  break;
  case 9: 
#line 313
  log_facility = 21 << 3;
#line 314
  break;
  case 10: 
#line 316
  log_facility = 22 << 3;
#line 317
  break;
  case 11: 
#line 319
  log_facility = 23 << 3;
#line 320
  break;
  default: 
#line 322
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 325
  exit(1);
  }
#line 327
  return;
}
}
#line 331 "log.c"
static void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;
  char *tmp ;

  {
#line 336
  txt = (char *)((void *)0);
#line 337
  pri = 6;
#line 339
  if ((int )level > (int )log_level) {
#line 340
    return;
  }
#line 342
  switch ((int )level) {
  case 1: 
#line 344
  if (! log_on_stderr) {
#line 345
    txt = (char *)"fatal";
  }
#line 346
  pri = 2;
#line 347
  break;
  case 2: 
#line 349
  if (! log_on_stderr) {
#line 350
    txt = (char *)"error";
  }
#line 351
  pri = 3;
#line 352
  break;
  case 3: 
#line 354
  pri = 6;
#line 355
  break;
  case 4: 
#line 357
  pri = 6;
#line 358
  break;
  case 5: 
#line 360
  txt = (char *)"debug1";
#line 361
  pri = 7;
#line 362
  break;
  case 6: 
#line 364
  txt = (char *)"debug2";
#line 365
  pri = 7;
#line 366
  break;
  case 7: 
#line 368
  txt = (char *)"debug3";
#line 369
  pri = 7;
#line 370
  break;
  default: 
#line 372
  txt = (char *)"internal error";
#line 373
  pri = 3;
#line 374
  break;
  }
#line 376
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 377
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 378
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 380
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 382
  if (log_on_stderr) {
#line 383
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\r\n", msgbuf);
  } else {
#line 385
    if (argv0) {
#line 385
      tmp = argv0;
    } else {
#line 385
      tmp = __progname;
    }
#line 385
    openlog((char const   *)tmp, 1, log_facility);
#line 386
    syslog(pri, "%.500s", msgbuf);
#line 387
    closelog();
  }
#line 389
  return;
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 17 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 19
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) ;
#line 20
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) ;
#line 48 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 51
  while (1) {
#line 53
    if (! *pattern) {
#line 54
      return (! *s);
    }
#line 56
    if ((int const   )*pattern == 42) {
#line 58
      pattern ++;
#line 61
      if (! *pattern) {
#line 62
        return (1);
      }
#line 65
      if ((int const   )*pattern != 63) {
#line 65
        if ((int const   )*pattern != 42) {
#line 71
          while (*s) {
#line 72
            if ((int const   )*s == (int const   )*pattern) {
#line 72
              tmp = match_pattern(s + 1, pattern + 1);
#line 72
              if (tmp) {
#line 74
                return (1);
              }
            }
#line 71
            s ++;
          }
#line 76
          return (0);
        }
      }
#line 82
      while (*s) {
#line 83
        tmp___0 = match_pattern(s, pattern);
#line 83
        if (tmp___0) {
#line 84
          return (1);
        }
#line 82
        s ++;
      }
#line 86
      return (0);
    }
#line 92
    if (! *s) {
#line 93
      return (0);
    }
#line 96
    if ((int const   )*pattern != 63) {
#line 96
      if ((int const   )*pattern != (int const   )*s) {
#line 97
        return (0);
      }
    }
#line 100
    s ++;
#line 101
    pattern ++;
  }
}
}
#line 113 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 121
  got_positive = 0;
#line 122
  i = 0U;
#line 122
  while (i < len) {
#line 124
    if ((int const   )*(pattern + i) == 33) {
#line 125
      negated = 1;
#line 126
      i ++;
    } else {
#line 128
      negated = 0;
    }
#line 134
    subi = 0U;
#line 134
    while (1) {
#line 134
      if (i < len) {
#line 134
        if (subi < sizeof(sub) - 1U) {
#line 134
          if (! ((int const   )*(pattern + i) != 44)) {
#line 134
            break;
          }
        } else {
#line 134
          break;
        }
      } else {
#line 134
        break;
      }
#line 137
      tmp___6 = __ctype_b_loc();
#line 137
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 137
        if (sizeof(*(pattern + i)) > 1U) {
#line 137
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 137
          tmp___5 = __ctype_tolower_loc();
#line 137
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 137
        sub[subi] = (char )__res___0;
      } else {
#line 137
        sub[subi] = (char )*(pattern + i);
      }
#line 134
      subi ++;
#line 134
      i ++;
    }
#line 139
    if (subi >= sizeof(sub) - 1U) {
#line 140
      return (0);
    }
#line 143
    if (i < len) {
#line 143
      if ((int const   )*(pattern + i) == 44) {
#line 144
        i ++;
      }
    }
#line 147
    sub[subi] = (char )'\000';
#line 150
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 150
    if (tmp___7) {
#line 151
      if (negated) {
#line 152
        return (-1);
      } else {
#line 154
        got_positive = 1;
      }
    }
  }
#line 162
  return (got_positive);
}
}
#line 169 "match.c"
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) 
{ int mhost ;
  int mip ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 176
  tmp = strlen(patterns);
#line 176
  mip = match_hostname(ipaddr, patterns, tmp);
#line 176
  if (mip == -1) {
#line 177
    return (0);
  }
#line 179
  tmp___0 = strlen(patterns);
#line 179
  mhost = match_hostname(host, patterns, tmp___0);
#line 179
  if (mhost == -1) {
#line 180
    return (0);
  }
#line 182
  if (mhost == 0) {
#line 182
    if (mip == 0) {
#line 183
      return (0);
    }
  }
#line 184
  return (1);
}
}
#line 190 "match.c"
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) 
{ char *p ;
  char *pat ;
  int ret ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 197
  tmp___1 = __builtin_strchr((char *)pattern, '@');
#line 197
  p = tmp___1;
#line 197
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 198
    tmp = match_pattern(user, pattern);
#line 198
    return (tmp);
  }
#line 200
  pat = xstrdup(pattern);
#line 201
  tmp___3 = __builtin_strchr(pat, '@');
#line 201
  p = tmp___3;
#line 202
  tmp___4 = p;
#line 202
  p ++;
#line 202
  *tmp___4 = (char )'\000';
#line 204
  ret = match_pattern(user, (char const   *)pat);
#line 204
  if (ret == 1) {
#line 205
    ret = match_host_and_ip(host, ipaddr, (char const   *)p);
  }
#line 206
  xfree((void *)pat);
#line 208
  return (ret);
}
}
#line 217 "match.c"
char *match_list(char const   *client , char const   *server , u_int *next ) 
{ char *sproposals[20] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;

  {
#line 224
  cp = xstrdup(client);
#line 224
  c = cp;
#line 225
  sp = xstrdup(server);
#line 225
  s = sp;
#line 227
  tmp___14 = __strsep_g(& sp, ",");
#line 227
  p = tmp___14;
#line 227
  i = 0;
#line 227
  while (1) {
#line 227
    if (p) {
#line 227
      if (! ((int )*p != 0)) {
#line 227
        break;
      }
    } else {
#line 227
      break;
    }
#line 229
    if (i < 20) {
#line 230
      sproposals[i] = p;
    } else {
#line 232
      break;
    }
#line 228
    tmp___30 = __strsep_g(& sp, ",");
#line 228
    p = tmp___30;
#line 228
    i ++;
  }
#line 234
  nproposals = i;
#line 236
  tmp___46 = __strsep_g(& cp, ",");
#line 236
  p = tmp___46;
#line 236
  i = 0;
#line 236
  while (1) {
#line 236
    if (p) {
#line 236
      if (! ((int )*p != 0)) {
#line 236
        break;
      }
    } else {
#line 236
      break;
    }
#line 238
    j = 0;
#line 238
    while (j < nproposals) {
#line 239
      if (0) {
#line 239
        __s1_len = strlen((char const   *)p);
#line 239
        __s2_len = strlen((char const   *)sproposals[j]);
#line 239
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 239
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 239
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 239
              tmp___73 = 1;
            } else {
#line 239
              if (__s2_len >= 4U) {
#line 239
                tmp___73 = 1;
              } else {
#line 239
                tmp___73 = 0;
              }
            }
          } else {
#line 239
            tmp___73 = 0;
          }
        }
#line 239
        if (tmp___73) {
#line 239
          tmp___69 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 239
          tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 239
          tmp___69 = tmp___72;
        }
      } else {
#line 239
        tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 239
        tmp___69 = tmp___72;
      }
#line 239
      if (tmp___69 == 0) {
#line 240
        ret = xstrdup((char const   *)p);
#line 241
        if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 242
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 242
            *next = strlen((char const   *)c);
          } else {
#line 242
            *next = (unsigned int )(cp - c);
          }
        }
#line 244
        xfree((void *)c);
#line 245
        xfree((void *)s);
#line 246
        return (ret);
      }
#line 238
      j ++;
    }
#line 237
    tmp___62 = __strsep_g(& cp, ",");
#line 237
    p = tmp___62;
#line 237
    i ++;
  }
#line 250
  if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 251
    *next = strlen((char const   *)c);
  }
#line 252
  xfree((void *)c);
#line 253
  xfree((void *)s);
#line 254
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "misc.o"
#line 260 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 15 "misc.h"
char *chop(char *s ) ;
#line 18
void unset_nonblock(int fd ) ;
#line 19
int a2port(char const   *s ) ;
#line 20
char *cleanhostname(char *host ) ;
#line 21
char *colon(char *cp ) ;
#line 22
long convtime(char const   *s ) ;
#line 24
struct passwd *pwcopy(struct passwd *pw ) ;
#line 32
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) ;
#line 36
mysig_t mysignal(int sig , void (*act)(int  ) ) ;
#line 35 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 38
  t = s;
#line 39
  while (*t) {
#line 40
    if ((int )*t == 10) {
#line 41
      *t = (char )'\000';
#line 42
      return (s);
    } else {
#line 40
      if ((int )*t == 13) {
#line 41
        *t = (char )'\000';
#line 42
        return (s);
      }
    }
#line 44
    t ++;
  }
#line 46
  return (s);
}
}
#line 51 "misc.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 56
  val = fcntl(fd, 3, 0);
#line 57
  if (val < 0) {
#line 58
    tmp = __errno_location();
#line 58
    tmp___0 = strerror(*tmp);
#line 58
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 59
    return;
  }
#line 61
  if (val & 2048) {
#line 62
    debug2("fd %d is O_NONBLOCK", fd);
#line 63
    return;
  }
#line 65
  debug("fd %d setting O_NONBLOCK", fd);
#line 66
  val |= 2048;
#line 67
  tmp___4 = fcntl(fd, 4, val);
#line 67
  if (tmp___4 == -1) {
#line 68
    tmp___3 = __errno_location();
#line 68
    if (*tmp___3 != 19) {
#line 69
      tmp___1 = __errno_location();
#line 69
      tmp___2 = strerror(*tmp___1);
#line 69
      error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
    }
  }
#line 71
  return;
}
}
#line 73 "misc.c"
void unset_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 78
  val = fcntl(fd, 3, 0);
#line 79
  if (val < 0) {
#line 80
    tmp = __errno_location();
#line 80
    tmp___0 = strerror(*tmp);
#line 80
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 81
    return;
  }
#line 83
  if (! (val & 2048)) {
#line 84
    debug2("fd %d is not O_NONBLOCK", fd);
#line 85
    return;
  }
#line 87
  debug("fd %d clearing O_NONBLOCK", fd);
#line 88
  val &= -2049;
#line 89
  tmp___4 = fcntl(fd, 4, val);
#line 89
  if (tmp___4 == -1) {
#line 90
    tmp___3 = __errno_location();
#line 90
    if (*tmp___3 != 19) {
#line 91
      tmp___1 = __errno_location();
#line 91
      tmp___2 = strerror(*tmp___1);
#line 91
      error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
    }
  }
#line 93
  return;
}
}
#line 99 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  unsigned int tmp___62 ;
  unsigned int tmp___94 ;

  {
#line 103
  wspace = 0;
#line 105
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 106
    return ((char *)((void *)0));
  }
#line 108
  old = *s;
#line 110
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n=");
#line 110
  *s = tmp___30;
#line 111
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 112
    return (old);
  }
#line 115
  if ((int )*(*(s + 0)) == 61) {
#line 116
    wspace = 1;
  }
#line 117
  *(*(s + 0)) = (char )'\000';
#line 119
  tmp___62 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 119
  *s += tmp___62 + 1U;
#line 120
  if ((int )*(*(s + 0)) == 61) {
#line 120
    if (! wspace) {
#line 121
      tmp___94 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 121
      *s += tmp___94 + 1U;
    }
  }
#line 123
  return (old);
}
}
#line 126 "misc.c"
struct passwd *pwcopy(struct passwd *pw ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 129
  tmp = xmalloc(sizeof(*copy));
#line 129
  copy = (struct passwd *)tmp;
#line 131
  memset((void *)copy, 0, sizeof(*copy));
#line 132
  copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 133
  copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 134
  copy->pw_gecos = xstrdup((char const   *)pw->pw_gecos);
#line 135
  copy->pw_uid = pw->pw_uid;
#line 136
  copy->pw_gid = pw->pw_gid;
#line 146
  copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 147
  copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 148
  return (copy);
}
}
#line 156 "misc.c"
int a2port(char const   *s ) 
{ long port ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 162
  tmp = __errno_location();
#line 162
  *tmp = 0;
#line 163
  port = strtol((char const   * __restrict  )s, (char ** __restrict  )(& endp), 0);
#line 164
  if ((unsigned int )s == (unsigned int )endp) {
#line 167
    return (0);
  } else {
#line 164
    if ((int )*endp != 0) {
#line 167
      return (0);
    } else {
#line 164
      tmp___0 = __errno_location();
#line 164
      if (*tmp___0 == 34) {
#line 164
        if (port == (-0x7FFFFFFF-1)) {
#line 167
          return (0);
        } else {
#line 164
          if (port == 2147483647L) {
#line 167
            return (0);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 164
        if (port <= 0L) {
#line 167
          return (0);
        } else {
#line 164
          if (port > 65535L) {
#line 167
            return (0);
          }
        }
      }
    }
  }
#line 169
  return ((int )port);
}
}
#line 199 "misc.c"
long convtime(char const   *s ) 
{ long total ;
  long secs ;
  char const   *p ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 206
  tmp = __errno_location();
#line 206
  *tmp = 0;
#line 207
  total = 0L;
#line 208
  p = s;
#line 210
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 211
    return (-1L);
  } else {
#line 210
    if ((int const   )*p == 0) {
#line 211
      return (-1L);
    }
  }
#line 213
  while (*p) {
#line 214
    secs = strtol((char const   * __restrict  )p, (char ** __restrict  )(& endp),
                  10);
#line 215
    if ((unsigned int )p == (unsigned int )endp) {
#line 218
      return (-1L);
    } else {
#line 215
      tmp___0 = __errno_location();
#line 215
      if (*tmp___0 == 34) {
#line 215
        if (secs == (-0x7FFFFFFF-1)) {
#line 218
          return (-1L);
        } else {
#line 215
          if (secs == 2147483647L) {
#line 218
            return (-1L);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 215
        if (secs < 0L) {
#line 218
          return (-1L);
        }
      }
    }
#line 220
    tmp___1 = endp;
#line 220
    endp ++;
#line 220
    switch ((int )*tmp___1) {
    case 0: 
#line 222
    endp --;
    case 115: 
    case 83: 
#line 225
    break;
    case 109: 
    case 77: 
#line 228
    secs *= 60L;
#line 229
    break;
    case 104: 
    case 72: 
#line 232
    secs *= 3600L;
#line 233
    break;
    case 100: 
    case 68: 
#line 236
    secs *= 86400L;
#line 237
    break;
    case 119: 
    case 87: 
#line 240
    secs *= 604800L;
#line 241
    break;
    default: ;
#line 243
    return (-1L);
    }
#line 245
    total += secs;
#line 246
    if (total < 0L) {
#line 247
      return (-1L);
    }
#line 248
    p = (char const   *)endp;
  }
#line 251
  return (total);
}
}
#line 254 "misc.c"
char *cleanhostname(char *host ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 257
  if ((int )*host == 91) {
#line 257
    tmp___0 = strlen((char const   *)host);
#line 257
    if ((int )*(host + (tmp___0 - 1U)) == 93) {
#line 258
      tmp = strlen((char const   *)host);
#line 258
      *(host + (tmp - 1U)) = (char )'\000';
#line 259
      return (host + 1);
    } else {
#line 261
      return (host);
    }
  } else {
#line 261
    return (host);
  }
}
}
#line 264 "misc.c"
char *colon(char *cp ) 
{ int flag ;

  {
#line 267
  flag = 0;
#line 269
  if ((int )*cp == 58) {
#line 270
    return ((char *)0);
  }
#line 271
  if ((int )*cp == 91) {
#line 272
    flag = 1;
  }
#line 274
  while (*cp) {
#line 275
    if ((int )*cp == 64) {
#line 275
      if ((int )*(cp + 1) == 91) {
#line 276
        flag = 1;
      }
    }
#line 277
    if ((int )*cp == 93) {
#line 277
      if ((int )*(cp + 1) == 58) {
#line 277
        if (flag) {
#line 278
          return (cp + 1);
        }
      }
    }
#line 279
    if ((int )*cp == 58) {
#line 279
      if (! flag) {
#line 280
        return (cp);
      }
    }
#line 281
    if ((int )*cp == 47) {
#line 282
      return ((char *)0);
    }
#line 274
    cp ++;
  }
#line 284
  return ((char *)0);
}
}
#line 288 "misc.c"
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) 
{ va_list ap ;
  char buf___2[1024] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 294
  __builtin_va_start(ap, fmt);
#line 295
  vsnprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )fmt,
            ap);
#line 296
  __builtin_va_end(ap);
#line 298
  if ((unsigned int )args->list == (unsigned int )((void *)0)) {
#line 299
    args->nalloc = 32;
#line 300
    args->num = 0;
  } else {
#line 301
    if (args->num + 2 >= args->nalloc) {
#line 302
      args->nalloc *= 2;
    }
  }
#line 304
  tmp = xrealloc((void *)args->list, (unsigned int )args->nalloc * sizeof(char *));
#line 304
  args->list = (char **)tmp;
#line 305
  tmp___0 = args->num;
#line 305
  (args->num) ++;
#line 305
  *(args->list + tmp___0) = xstrdup((char const   *)(buf___2));
#line 306
  *(args->list + args->num) = (char *)((void *)0);
#line 307
  return;
}
}
#line 309 "misc.c"
mysig_t mysignal(int sig , void (*act)(int  ) ) 
{ struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;
  int tmp___0 ;

  {
#line 315
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa));
#line 315
  if (tmp == -1) {
#line 316
    return ((void (*)(int  ))-1);
  }
#line 317
  if ((unsigned int )osa.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 318
    memset((void *)(& sa), 0, sizeof(sa));
#line 319
    sigemptyset(& sa.sa_mask);
#line 320
    sa.sa_flags = 0;
#line 322
    if (sig == 14) {
#line 323
      sa.sa_flags |= 536870912;
    }
#line 325
    sa.__sigaction_handler.sa_handler = act;
#line 326
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 326
    if (tmp___0 == -1) {
#line 327
      return ((void (*)(int  ))-1);
    }
  }
#line 329
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 1 "mpaux.o"
#line 20 "mpaux.h"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) ;
#line 26 "mpaux.c"
void compute_session_id(u_char *session_id___0 , u_char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ u_int host_key_bytes ;
  int tmp ;
  u_int session_key_bytes ;
  int tmp___0 ;
  u_int bytes ;
  u_char *buf___2 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (u_int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (u_int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___2 = (u_char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___2);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___2 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___2, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___2, 0, bytes);
#line 45
  xfree((void *)buf___2);
#line 46
  return;
}
}
#line 1 "nchan.o"
#line 67 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 68 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 69 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 71 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 72 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 73 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 77
static void chan_send_ieof1(Channel *c ) ;
#line 78
static void chan_send_oclose1(Channel *c ) ;
#line 79
static void chan_send_close2(Channel *c ) ;
#line 80
static void chan_send_eof2(Channel *c ) ;
#line 83
static void chan_shutdown_write(Channel *c ) ;
#line 84
static void chan_shutdown_read(Channel *c ) ;
#line 90 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 93
  debug("channel %d: rcvd oclose", c->self);
#line 94
  switch (c->istate) {
  case 4: 
#line 96
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 97
  c->istate = 8;
#line 98
  break;
  case 1: 
#line 100
  debug("channel %d: input open -> closed", c->self);
#line 101
  chan_shutdown_read(c);
#line 102
  chan_send_ieof1(c);
#line 103
  c->istate = 8;
#line 104
  break;
  case 2: 
#line 107
  log("channel %d: input drain -> closed", c->self);
#line 108
  chan_send_ieof1(c);
#line 109
  c->istate = 8;
#line 110
  break;
  default: 
#line 112
  error("channel %d: protocol error: rcvd_oclose for istate %d", c->self, c->istate);
#line 114
  return;
  }
#line 116
  return;
}
}
#line 117 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ 

  {
#line 120
  debug("channel %d: read failed", c->self);
#line 121
  switch (c->istate) {
  case 1: 
#line 123
  debug("channel %d: input open -> drain", c->self);
#line 124
  chan_shutdown_read(c);
#line 125
  c->istate = 2;
#line 132
  break;
  default: 
#line 134
  error("channel %d: chan_read_failed for istate %d", c->self, c->istate);
#line 136
  break;
  }
#line 138
  return;
}
}
#line 139 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ u_int tmp ;

  {
#line 142
  debug("channel %d: ibuf empty", c->self);
#line 143
  tmp = buffer_len(& c->input);
#line 143
  if (tmp) {
#line 144
    error("channel %d: chan_ibuf_empty for non empty buffer", c->self);
#line 146
    return;
  }
#line 148
  switch (c->istate) {
  case 2: 
#line 150
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 151
  chan_send_ieof1(c);
#line 152
  c->istate = 4;
#line 153
  break;
  default: 
#line 155
  error("channel %d: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 157
  break;
  }
#line 159
  return;
}
}
#line 160 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 163
  debug("channel %d: rcvd ieof", c->self);
#line 164
  if (c->type != 4) {
#line 165
    debug("channel %d: non-open", c->self);
#line 166
    if (c->istate == 1) {
#line 167
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 169
      chan_shutdown_read(c);
#line 170
      chan_send_ieof1(c);
#line 171
      c->istate = 4;
    } else {
#line 173
      error("channel %d: non-open: istate %d != open", c->self, c->istate);
    }
#line 176
    if (c->ostate == 16) {
#line 177
      debug("channel %d: non-open: output open -> closed", c->self);
#line 179
      chan_send_oclose1(c);
#line 180
      c->ostate = 128;
    } else {
#line 182
      error("channel %d: non-open: ostate %d != open", c->self, c->ostate);
    }
#line 185
    return;
  }
#line 187
  switch (c->ostate) {
  case 16: 
#line 189
  debug("channel %d: output open -> drain", c->self);
#line 190
  c->ostate = 32;
#line 191
  break;
  case 64: 
#line 193
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 194
  c->ostate = 128;
#line 195
  break;
  default: 
#line 197
  error("channel %d: protocol error: rcvd_ieof for ostate %d", c->self, c->ostate);
#line 199
  break;
  }
#line 201
  return;
}
}
#line 202 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 205
  debug("channel %d: write failed", c->self);
#line 206
  switch (c->ostate) {
  case 16: 
#line 208
  debug("channel %d: output open -> wait_ieof", c->self);
#line 209
  chan_send_oclose1(c);
#line 210
  c->ostate = 64;
#line 211
  break;
  case 32: 
#line 213
  debug("channel %d: output wait_drain -> closed", c->self);
#line 214
  chan_send_oclose1(c);
#line 215
  c->ostate = 128;
#line 216
  break;
  default: 
#line 218
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 220
  break;
  }
#line 222
  return;
}
}
#line 223 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ u_int tmp ;

  {
#line 226
  debug("channel %d: obuf empty", c->self);
#line 227
  tmp = buffer_len(& c->output);
#line 227
  if (tmp) {
#line 228
    error("channel %d: chan_obuf_empty for non empty buffer", c->self);
#line 230
    return;
  }
#line 232
  switch (c->ostate) {
  case 32: 
#line 234
  debug("channel %d: output drain -> closed", c->self);
#line 235
  chan_send_oclose1(c);
#line 236
  c->ostate = 128;
#line 237
  break;
  default: 
#line 239
  error("channel %d: internal error: obuf_empty for ostate %d", c->self, c->ostate);
#line 241
  break;
  }
#line 243
  return;
}
}
#line 244 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 247
  debug("channel %d: send ieof", c->self);
#line 248
  switch (c->istate) {
  case 1: 
  case 2: 
#line 251
  packet_start((unsigned char)24);
#line 252
  packet_put_int((unsigned int )c->remote_id);
#line 253
  packet_send();
#line 254
  break;
  default: 
#line 256
  error("channel %d: cannot send ieof for istate %d", c->self, c->istate);
#line 258
  break;
  }
#line 260
  return;
}
}
#line 261 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ u_int tmp ;

  {
#line 264
  debug("channel %d: send oclose", c->self);
#line 265
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 268
  chan_shutdown_write(c);
#line 269
  tmp = buffer_len(& c->output);
#line 269
  buffer_consume(& c->output, tmp);
#line 270
  packet_start((unsigned char)25);
#line 271
  packet_put_int((unsigned int )c->remote_id);
#line 272
  packet_send();
#line 273
  break;
  default: 
#line 275
  error("channel %d: cannot send oclose for ostate %d", c->self, c->ostate);
#line 277
  break;
  }
#line 279
  return;
}
}
#line 284 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 287
  debug("channel %d: rcvd close", c->self);
#line 288
  if (c->flags & 2) {
#line 289
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 290
  c->flags |= 2;
#line 291
  if (c->type == 10) {
#line 293
    c->ostate = 128;
#line 294
    c->istate = 8;
#line 295
    return;
  }
#line 297
  switch (c->ostate) {
  case 16: 
#line 303
  debug("channel %d: output open -> drain", c->self);
#line 304
  c->ostate = 32;
#line 305
  break;
  }
#line 307
  switch (c->istate) {
  case 1: 
#line 309
  debug("channel %d: input open -> closed", c->self);
#line 310
  chan_shutdown_read(c);
#line 311
  break;
  case 2: 
#line 313
  debug("channel %d: input drain -> closed", c->self);
#line 314
  chan_send_eof2(c);
#line 315
  break;
  }
#line 317
  c->istate = 8;
#line 318
  return;
}
}
#line 319 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ u_int tmp ;

  {
#line 322
  debug("channel %d: ibuf empty", c->self);
#line 323
  tmp = buffer_len(& c->input);
#line 323
  if (tmp) {
#line 324
    error("channel %d: chan_ibuf_empty for non empty buffer", c->self);
#line 326
    return;
  }
#line 328
  switch (c->istate) {
  case 2: 
#line 330
  debug("channel %d: input drain -> closed", c->self);
#line 331
  if (! (c->flags & 1)) {
#line 332
    chan_send_eof2(c);
  }
#line 333
  c->istate = 8;
#line 334
  break;
  default: 
#line 336
  error("channel %d: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 338
  break;
  }
#line 340
  return;
}
}
#line 341 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 344
  debug("channel %d: rcvd eof", c->self);
#line 345
  if (c->ostate == 16) {
#line 346
    debug("channel %d: output open -> drain", c->self);
#line 347
    c->ostate = 32;
  }
#line 349
  return;
}
}
#line 350 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 353
  debug("channel %d: write failed", c->self);
#line 354
  switch (c->ostate) {
  case 16: 
#line 356
  debug("channel %d: output open -> closed", c->self);
#line 357
  chan_shutdown_write(c);
#line 358
  c->ostate = 128;
#line 359
  break;
  case 32: 
#line 361
  debug("channel %d: output drain -> closed", c->self);
#line 362
  chan_shutdown_write(c);
#line 363
  c->ostate = 128;
#line 364
  break;
  default: 
#line 366
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 368
  break;
  }
#line 370
  return;
}
}
#line 371 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ u_int tmp ;

  {
#line 374
  debug("channel %d: obuf empty", c->self);
#line 375
  tmp = buffer_len(& c->output);
#line 375
  if (tmp) {
#line 376
    error("channel %d: chan_obuf_empty for non empty buffer", c->self);
#line 378
    return;
  }
#line 380
  switch (c->ostate) {
  case 32: 
#line 382
  debug("channel %d: output drain -> closed", c->self);
#line 383
  chan_shutdown_write(c);
#line 384
  c->ostate = 128;
#line 385
  break;
  default: 
#line 387
  error("channel %d: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 389
  break;
  }
#line 391
  return;
}
}
#line 392 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 395
  debug("channel %d: send eof", c->self);
#line 396
  switch (c->istate) {
  case 2: 
#line 398
  packet_start((unsigned char)96);
#line 399
  packet_put_int((unsigned int )c->remote_id);
#line 400
  packet_send();
#line 401
  break;
  default: 
#line 403
  error("channel %d: cannot send eof for istate %d", c->self, c->istate);
#line 405
  break;
  }
#line 407
  return;
}
}
#line 408 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 411
  debug("channel %d: send close", c->self);
#line 412
  if (c->ostate != 128) {
#line 414
    error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
          c->ostate);
  } else {
#line 412
    if (c->istate != 8) {
#line 414
      error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
            c->ostate);
    } else {
#line 416
      if (c->flags & 1) {
#line 417
        error("channel %d: already sent close", c->self);
      } else {
#line 419
        packet_start((unsigned char)97);
#line 420
        packet_put_int((unsigned int )c->remote_id);
#line 421
        packet_send();
#line 422
        c->flags |= 1;
      }
    }
  }
#line 424
  return;
}
}
#line 428 "nchan.c"
void chan_mark_dead(Channel *c ) 
{ 

  {
#line 431
  c->type = 14;
#line 432
  return;
}
}
#line 434 "nchan.c"
int chan_is_dead(Channel *c ) 
{ char const   *tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 437
  if (c->type == 14) {
#line 438
    debug("channel %d: zombie", c->self);
#line 439
    return (1);
  }
#line 441
  if (c->istate != 8) {
#line 442
    return (0);
  } else {
#line 441
    if (c->ostate != 128) {
#line 442
      return (0);
    }
  }
#line 443
  if (! compat20) {
#line 444
    debug("channel %d: is dead", c->self);
#line 445
    return (1);
  }
#line 451
  if (c->extended_usage != 0) {
#line 451
    tmp___1 = buffer_len(& c->extended);
#line 451
    if (tmp___1 > 0U) {
#line 458
      if (c->extended_usage == 1) {
#line 458
        tmp = "read";
      } else {
#line 458
        tmp = "write";
      }
#line 458
      tmp___0 = buffer_len(& c->extended);
#line 458
      debug2("channel %d: active efd: %d len %d type %s", c->self, c->efd, tmp___0,
             tmp);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 463
    if (! (c->flags & 1)) {
#line 464
      chan_send_close2(c);
    }
#line 466
    if (c->flags & 1) {
#line 466
      if (c->flags & 2) {
#line 468
        debug("channel %d: is dead", c->self);
#line 469
        return (1);
      }
    }
  }
#line 472
  return (0);
}
}
#line 475 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 478
  c->ostate = 16;
#line 479
  c->istate = 1;
#line 480
  c->flags = 0;
#line 481
  return;
}
}
#line 484 "nchan.c"
void chan_init(void) 
{ 

  {
#line 487
  if (compat20) {
#line 488
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 489
    chan_read_failed = & chan_read_failed_12;
#line 490
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 492
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 493
    chan_write_failed = & chan_write_failed2;
#line 494
    chan_obuf_empty = & chan_obuf_empty2;
  } else {
#line 496
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 497
    chan_read_failed = & chan_read_failed_12;
#line 498
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 500
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 501
    chan_write_failed = & chan_write_failed1;
#line 502
    chan_obuf_empty = & chan_obuf_empty1;
  }
#line 504
  return;
}
}
#line 507 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 510
  tmp = buffer_len(& c->output);
#line 510
  buffer_consume(& c->output, tmp);
#line 511
  if (compat20) {
#line 511
    if (c->type == 10) {
#line 512
      return;
    }
  }
#line 514
  debug("channel %d: close_write", c->self);
#line 515
  if (c->sock != -1) {
#line 516
    tmp___2 = shutdown(c->sock, 1);
#line 516
    if (tmp___2 < 0) {
#line 517
      tmp___0 = __errno_location();
#line 517
      tmp___1 = strerror(*tmp___0);
#line 517
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 521
    tmp___5 = channel_close_fd(& c->wfd);
#line 521
    if (tmp___5 < 0) {
#line 522
      tmp___3 = __errno_location();
#line 522
      tmp___4 = strerror(*tmp___3);
#line 522
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
  }
#line 526
  return;
}
}
#line 527 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 530
  if (compat20) {
#line 530
    if (c->type == 10) {
#line 531
      return;
    }
  }
#line 532
  debug("channel %d: close_read", c->self);
#line 533
  if (c->sock != -1) {
#line 539
    tmp___1 = shutdown(c->sock, 0);
#line 539
    if (tmp___1 < 0) {
#line 539
      tmp___2 = __errno_location();
#line 539
      if (*tmp___2 != 107) {
#line 541
        tmp = __errno_location();
#line 541
        tmp___0 = strerror(*tmp);
#line 541
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      }
    }
  } else {
#line 546
    tmp___5 = channel_close_fd(& c->rfd);
#line 546
    if (tmp___5 < 0) {
#line 547
      tmp___3 = __errno_location();
#line 547
      tmp___4 = strerror(*tmp___3);
#line 547
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___4);
    }
  }
#line 551
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 21 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 22
void packet_set_nonblocking(void) ;
#line 24
int packet_get_connection_out(void) ;
#line 25
void packet_close(void) ;
#line 26
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 27
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 29
void packet_start_compression(int level ) ;
#line 30
void packet_set_interactive(int interactive ) ;
#line 36
void packet_put_bignum(BIGNUM *value ) ;
#line 46
void packet_process_incoming(char const   *buf___2 , u_int len ) ;
#line 50
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 57
void packet_write_poll(void) ;
#line 59
int packet_have_data_to_write(void) ;
#line 60
int packet_not_very_much_data_to_write(void) ;
#line 63
int packet_connection_is_ipv4(void) ;
#line 66
void packet_inject_ignore(int sumlen ) ;
#line 72
int packet_set_maxsize(int s ) ;
#line 75 "packet.c"
static int connection_in  =    -1;
#line 76 "packet.c"
static int connection_out  =    -1;
#line 79 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 82 "packet.c"
static CipherContext receive_context  ;
#line 85 "packet.c"
static CipherContext send_context  ;
#line 88 "packet.c"
static Buffer input  ;
#line 91 "packet.c"
static Buffer output  ;
#line 94 "packet.c"
static Buffer outgoing_packet  ;
#line 97 "packet.c"
static Buffer incoming_packet  ;
#line 100 "packet.c"
static Buffer compression_buffer  ;
#line 101 "packet.c"
static int compression_buffer_ready  =    0;
#line 104 "packet.c"
static int packet_compression  =    0;
#line 107 "packet.c"
int max_packet_size  =    32768;
#line 110 "packet.c"
static int initialized  =    0;
#line 113 "packet.c"
static int interactive_mode  =    0;
#line 116 "packet.c"
Newkeys *newkeys[2]  ;
#line 122 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 125
  tmp = cipher_by_name("none");
#line 125
  none = tmp;
#line 126
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 127
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 128
  connection_in = fd_in;
#line 129
  connection_out = fd_out;
#line 130
  cipher_init(& send_context, none, (u_char const   *)((u_char *)""), 0U, (u_char const   *)((void *)0),
              0U);
#line 131
  cipher_init(& receive_context, none, (u_char const   *)((u_char *)""), 0U, (u_char const   *)((void *)0),
              0U);
#line 132
  newkeys[1] = (Newkeys *)((void *)0);
#line 132
  newkeys[0] = newkeys[1];
#line 133
  if (! initialized) {
#line 134
    initialized = 1;
#line 135
    buffer_init(& input);
#line 136
    buffer_init(& output);
#line 137
    buffer_init(& outgoing_packet);
#line 138
    buffer_init(& incoming_packet);
  }
#line 141
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 142
  return;
}
}
#line 146 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 153
  if (connection_in == connection_out) {
#line 154
    return (1);
  }
#line 155
  fromlen = sizeof(from);
#line 156
  memset((void *)(& from), 0, sizeof(from));
#line 157
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 157
  if (tmp < 0) {
#line 158
    return (0);
  }
#line 159
  tolen = sizeof(to);
#line 160
  memset((void *)(& to), 0, sizeof(to));
#line 161
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 161
  if (tmp___0 < 0) {
#line 162
    return (0);
  }
#line 163
  if (fromlen != tolen) {
#line 164
    return (0);
  } else {
#line 163
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 163
    if (tmp___1 != 0) {
#line 164
      return (0);
    }
  }
#line 165
  if ((int )from.ss_family != 2) {
#line 165
    if ((int )from.ss_family != 10) {
#line 166
      return (0);
    }
  }
#line 167
  return (1);
}
}
#line 172 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 176
  tolen = sizeof(to);
#line 178
  memset((void *)(& to), 0, sizeof(to));
#line 179
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 179
  if (tmp < 0) {
#line 180
    return (0);
  }
#line 181
  if ((int )to.ss_family != 2) {
#line 182
    return (0);
  }
#line 183
  return (1);
}
}
#line 188 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 192
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 192
  if (tmp___1 < 0) {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 195
  if (connection_out != connection_in) {
#line 196
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 196
    if (tmp___4 < 0) {
#line 197
      tmp___2 = __errno_location();
#line 197
      tmp___3 = strerror(*tmp___2);
#line 197
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 199
  return;
}
}
#line 203 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 206
  return (connection_in);
}
}
#line 211 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 214
  return (connection_out);
}
}
#line 219 "packet.c"
void packet_close(void) 
{ 

  {
#line 222
  if (! initialized) {
#line 223
    return;
  }
#line 224
  initialized = 0;
#line 225
  if (connection_in == connection_out) {
#line 226
    shutdown(connection_out, 2);
#line 227
    close(connection_out);
  } else {
#line 229
    close(connection_in);
#line 230
    close(connection_out);
  }
#line 232
  buffer_free(& input);
#line 233
  buffer_free(& output);
#line 234
  buffer_free(& outgoing_packet);
#line 235
  buffer_free(& incoming_packet);
#line 236
  if (compression_buffer_ready) {
#line 237
    buffer_free(& compression_buffer);
#line 238
    buffer_compress_uninit();
  }
#line 240
  return;
}
}
#line 244 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 247
  remote_protocol_flags = protocol_flags;
#line 248
  return;
}
}
#line 252 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 255
  return (remote_protocol_flags);
}
}
#line 263 "packet.c"
static void packet_init_compression(void) 
{ 

  {
#line 266
  if (compression_buffer_ready == 1) {
#line 267
    return;
  }
#line 268
  compression_buffer_ready = 1;
#line 269
  buffer_init(& compression_buffer);
#line 270
  return;
}
}
#line 272 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 275
  if (packet_compression) {
#line 275
    if (! compat20) {
#line 276
      fatal("Compression already enabled.");
    }
  }
#line 277
  packet_compression = 1;
#line 278
  packet_init_compression();
#line 279
  buffer_compress_init_send(level);
#line 280
  buffer_compress_init_recv();
#line 281
  return;
}
}
#line 288 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 292
  tmp = cipher_by_number(number);
#line 292
  cipher = tmp;
#line 293
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 294
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 295
  if (keylen < 20U) {
#line 296
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 297
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 298
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U);
#line 299
  return;
}
}
#line 302 "packet.c"
void packet_start(u_char type ) 
{ u_char buf___2[9] ;
  int len ;

  {
#line 309
  if (compat20) {
#line 309
    len = 6;
  } else {
#line 309
    len = 9;
  }
#line 310
  memset((void *)(buf___2), 0, (unsigned int )(len - 1));
#line 311
  buf___2[len - 1] = type;
#line 312
  buffer_clear(& outgoing_packet);
#line 313
  buffer_append(& outgoing_packet, (char const   *)(buf___2), (unsigned int )len);
#line 314
  return;
}
}
#line 317 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 320
  ch = (char )value;
#line 321
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 322
  return;
}
}
#line 323 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 326
  buffer_put_int(& outgoing_packet, value);
#line 327
  return;
}
}
#line 328 "packet.c"
void packet_put_string(char const   *buf___2 , u_int len ) 
{ 

  {
#line 331
  buffer_put_string(& outgoing_packet, (void const   *)buf___2, len);
#line 332
  return;
}
}
#line 333 "packet.c"
void packet_put_cstring(char const   *str ) 
{ 

  {
#line 336
  buffer_put_cstring(& outgoing_packet, str);
#line 337
  return;
}
}
#line 338 "packet.c"
void packet_put_raw(char const   *buf___2 , u_int len ) 
{ 

  {
#line 341
  buffer_append(& outgoing_packet, buf___2, len);
#line 342
  return;
}
}
#line 343 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 346
  buffer_put_bignum(& outgoing_packet, value);
#line 347
  return;
}
}
#line 348 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 351
  buffer_put_bignum2(& outgoing_packet, value);
#line 352
  return;
}
}
#line 359 "packet.c"
static void packet_send1(void) 
{ char buf___2[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rand___0 ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;

  {
#line 365
  rand___0 = (u_int32_t )0;
#line 371
  if (packet_compression) {
#line 372
    buffer_clear(& compression_buffer);
#line 374
    buffer_consume(& outgoing_packet, 8U);
#line 376
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 377
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 378
    buffer_clear(& outgoing_packet);
#line 379
    tmp = buffer_len(& compression_buffer);
#line 379
    tmp___0 = buffer_ptr(& compression_buffer);
#line 379
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 383
  tmp___1 = buffer_len(& outgoing_packet);
#line 383
  len = (int )((tmp___1 + 4U) - 8U);
#line 386
  padding = 8 - len % 8;
#line 387
  if ((send_context.cipher)->number != 0) {
#line 388
    cp = buffer_ptr(& outgoing_packet);
#line 389
    i = 0;
#line 389
    while (i < padding) {
#line 390
      if (i % 4 == 0) {
#line 391
        rand___0 = arc4random();
      }
#line 392
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 393
      rand___0 >>= 8;
#line 389
      i ++;
    }
  }
#line 396
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 399
  tmp___2 = buffer_len(& outgoing_packet);
#line 399
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 399
  checksum = ssh_crc32((u_char const   *)((u_char *)tmp___3), tmp___2);
#line 401
  while (1) {
#line 401
    buf___2[0] = (char )(checksum >> 24);
#line 401
    buf___2[1] = (char )(checksum >> 16);
#line 401
    buf___2[2] = (char )(checksum >> 8);
#line 401
    buf___2[3] = (char )checksum;
#line 401
    break;
  }
#line 402
  buffer_append(& outgoing_packet, (char const   *)(buf___2), 4U);
#line 410
  while (1) {
#line 410
    buf___2[0] = (char )(len >> 24);
#line 410
    buf___2[1] = (char )(len >> 16);
#line 410
    buf___2[2] = (char )(len >> 8);
#line 410
    buf___2[3] = (char )len;
#line 410
    break;
  }
#line 411
  buffer_append(& output, (char const   *)(buf___2), 4U);
#line 412
  tmp___4 = buffer_len(& outgoing_packet);
#line 412
  buffer_append_space(& output, & cp, tmp___4);
#line 413
  tmp___5 = buffer_len(& outgoing_packet);
#line 413
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 413
  cipher_encrypt(& send_context, (u_char *)cp, (u_char const   *)tmp___6, tmp___5);
#line 421
  buffer_clear(& outgoing_packet);
#line 428
  return;
}
}
#line 430 "packet.c"
static void set_newkeys(int mode ) 
{ Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  CipherContext *cc ;

  {
#line 438
  debug("newkeys: mode %d", mode);
#line 440
  if (mode == 1) {
#line 440
    cc = & send_context;
  } else {
#line 440
    cc = & receive_context;
  }
#line 441
  if ((unsigned int )newkeys[mode] != (unsigned int )((void *)0)) {
#line 442
    debug("newkeys: rekeying");
#line 444
    memset((void *)cc, 0, sizeof(*cc));
#line 445
    enc = & (newkeys[mode])->enc;
#line 446
    mac = & (newkeys[mode])->mac;
#line 447
    comp = & (newkeys[mode])->comp;
#line 448
    memset((void *)mac->key, 0, (unsigned int )mac->key_len);
#line 449
    xfree((void *)enc->name);
#line 450
    xfree((void *)enc->iv);
#line 451
    xfree((void *)enc->key);
#line 452
    xfree((void *)mac->name);
#line 453
    xfree((void *)mac->key);
#line 454
    xfree((void *)comp->name);
#line 455
    xfree((void *)newkeys[mode]);
  }
#line 457
  newkeys[mode] = kex_get_newkeys(mode);
#line 458
  if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
#line 459
    fatal("newkeys: no keys for mode %d", mode);
  }
#line 460
  enc = & (newkeys[mode])->enc;
#line 461
  mac = & (newkeys[mode])->mac;
#line 462
  comp = & (newkeys[mode])->comp;
#line 463
  if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 464
    mac->enabled = 1;
  }
#line 466
  cipher_init(cc, enc->cipher, (u_char const   *)enc->key, (enc->cipher)->key_len,
              (u_char const   *)enc->iv, (enc->cipher)->block_size);
#line 468
  memset((void *)enc->iv, 0, (enc->cipher)->block_size);
#line 469
  memset((void *)enc->key, 0, (enc->cipher)->key_len);
#line 470
  if (comp->type != 0) {
#line 470
    if (comp->enabled == 0) {
#line 471
      packet_init_compression();
#line 472
      if (mode == 1) {
#line 473
        buffer_compress_init_send(6);
      } else {
#line 475
        buffer_compress_init_recv();
      }
#line 476
      comp->enabled = 1;
    }
  }
#line 478
  return;
}
}
#line 486
static void packet_send2(void) ;
#line 486 "packet.c"
static u_int32_t seqnr  =    (u_int32_t )0;
#line 483 "packet.c"
static void packet_send2(void) 
{ u_char type ;
  u_char *ucp ;
  u_char *macbuf ;
  char *cp ;
  u_int packet_length___0 ;
  u_int i ;
  u_int padlen ;
  u_int len ;
  u_int32_t rand___0 ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  char *tmp ;
  u_int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  char *tmp___8 ;

  {
#line 487
  macbuf = (u_char *)((void *)0);
#line 489
  packet_length___0 = (u_int )0;
#line 491
  rand___0 = (u_int32_t )0;
#line 492
  enc = (Enc *)((void *)0);
#line 493
  mac = (Mac *)((void *)0);
#line 494
  comp = (Comp *)((void *)0);
#line 497
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 498
    enc = & (newkeys[1])->enc;
#line 499
    mac = & (newkeys[1])->mac;
#line 500
    comp = & (newkeys[1])->comp;
  }
#line 502
  if (enc) {
#line 502
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 502
    block_size = 8;
  }
#line 504
  tmp = buffer_ptr(& outgoing_packet);
#line 504
  ucp = (u_char *)tmp;
#line 505
  type = *(ucp + 5);
#line 512
  if (comp) {
#line 512
    if (comp->enabled) {
#line 513
      len = buffer_len(& outgoing_packet);
#line 515
      buffer_consume(& outgoing_packet, 5U);
#line 516
      buffer_clear(& compression_buffer);
#line 517
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 518
      buffer_clear(& outgoing_packet);
#line 519
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 520
      tmp___0 = buffer_len(& compression_buffer);
#line 520
      tmp___1 = buffer_ptr(& compression_buffer);
#line 520
      buffer_append(& outgoing_packet, (char const   *)tmp___1, tmp___0);
    }
  }
#line 527
  len = buffer_len(& outgoing_packet);
#line 533
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 534
  if (padlen < 4U) {
#line 535
    padlen += (u_int )block_size;
  }
#line 536
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 537
  if (enc) {
#line 537
    if ((enc->cipher)->number != 0) {
#line 539
      i = 0U;
#line 539
      while (i < padlen) {
#line 540
        if (i % 4U == 0U) {
#line 541
          rand___0 = arc4random();
        }
#line 542
        *(cp + i) = (char )(rand___0 & 255U);
#line 543
        rand___0 >>= 8;
#line 539
        i ++;
      }
    } else {
#line 547
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 547
    memset((void *)cp, 0, padlen);
  }
#line 550
  tmp___2 = buffer_len(& outgoing_packet);
#line 550
  packet_length___0 = tmp___2 - 4U;
#line 551
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 551
  ucp = (u_char *)tmp___3;
#line 552
  while (1) {
#line 552
    *(ucp + 0) = (unsigned char )(packet_length___0 >> 24);
#line 552
    *(ucp + 1) = (unsigned char )(packet_length___0 >> 16);
#line 552
    *(ucp + 2) = (unsigned char )(packet_length___0 >> 8);
#line 552
    *(ucp + 3) = (unsigned char )packet_length___0;
#line 552
    break;
  }
#line 553
  *(ucp + 4) = (unsigned char )padlen;
#line 557
  if (mac) {
#line 557
    if (mac->enabled) {
#line 558
      tmp___4 = buffer_len(& outgoing_packet);
#line 558
      tmp___5 = buffer_ptr(& outgoing_packet);
#line 558
      macbuf = mac_compute(mac, seqnr, (u_char *)tmp___5, (int )tmp___4);
    }
  }
#line 564
  tmp___6 = buffer_len(& outgoing_packet);
#line 564
  buffer_append_space(& output, & cp, tmp___6);
#line 565
  tmp___7 = buffer_len(& outgoing_packet);
#line 565
  tmp___8 = buffer_ptr(& outgoing_packet);
#line 565
  cipher_encrypt(& send_context, (u_char *)cp, (u_char const   *)tmp___8, tmp___7);
#line 568
  if (mac) {
#line 568
    if (mac->enabled) {
#line 569
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 575
  seqnr ++;
#line 575
  if (seqnr == 0U) {
#line 576
    log("outgoing seqnr wraps around");
  }
#line 577
  buffer_clear(& outgoing_packet);
#line 579
  if ((int )type == 21) {
#line 580
    set_newkeys(1);
  }
#line 581
  return;
}
}
#line 583 "packet.c"
void packet_send(void) 
{ 

  {
#line 586
  if (compat20) {
#line 587
    packet_send2();
  } else {
#line 589
    packet_send1();
  }
#line 591
  return;
}
}
#line 599 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set *setp ;
  char buf___2[8192] ;
  void *tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 607
  tmp = xmalloc((((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 607
  setp = (fd_set *)tmp;
#line 611
  packet_write_wait();
#line 614
  while (1) {
#line 616
    type = packet_read_poll(payload_len_ptr);
#line 617
    if (! compat20) {
#line 617
      if (type == 14) {
        goto _L;
      } else {
#line 617
        if (type == 15) {
          goto _L;
        } else {
#line 617
          if (type == 19) {
            goto _L;
          } else {
#line 617
            if (type == 33) {
              _L: /* CIL Label */ 
#line 622
              while (1) {
#line 622
                _p = *payload_len_ptr;
#line 622
                _e = 0;
#line 622
                if (_p != _e) {
#line 622
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      622);
#line 622
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 622
                break;
              }
            }
          }
        }
      }
    }
#line 624
    if (type != 0) {
#line 625
      xfree((void *)setp);
#line 626
      return (type);
    }
#line 632
    memset((void *)setp, 0, (((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 634
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 637
    while (1) {
#line 637
      tmp___0 = select(connection_in + 1, (fd_set * __restrict  )setp, (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 637
      if (tmp___0 == -1) {
#line 637
        tmp___1 = __errno_location();
#line 637
        if (! (*tmp___1 == 11)) {
#line 637
          tmp___2 = __errno_location();
#line 637
          if (! (*tmp___2 == 4)) {
#line 637
            break;
          }
        }
      } else {
#line 637
        break;
      }
    }
#line 642
    len = read(connection_in, (void *)(buf___2), sizeof(buf___2));
#line 643
    if (len == 0) {
#line 644
      tmp___3 = get_remote_ipaddr();
#line 644
      log("Connection closed by %.200s", tmp___3);
#line 645
      fatal_cleanup();
    }
#line 647
    if (len < 0) {
#line 648
      tmp___4 = __errno_location();
#line 648
      tmp___5 = strerror(*tmp___4);
#line 648
      fatal("Read from socket failed: %.100s", tmp___5);
    }
#line 650
    packet_process_incoming((char const   *)(buf___2), (unsigned int )len);
  }
}
}
#line 660 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 665
  type = packet_read(payload_len_ptr);
#line 666
  if (type != expected_type) {
#line 667
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 669
  return;
}
}
#line 686 "packet.c"
static int packet_read_poll1(int *payload_len_ptr ) 
{ u_int len ;
  u_int padded_len ;
  u_char *ucp ;
  u_char type ;
  char *cp ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  char *tmp___9 ;
  u_int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  u_int tmp___13 ;

  {
#line 695
  tmp = buffer_len(& input);
#line 695
  if (tmp < 12U) {
#line 696
    return (0);
  }
#line 698
  tmp___0 = buffer_ptr(& input);
#line 698
  ucp = (u_char *)tmp___0;
#line 699
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 700
  if (len < 5U) {
#line 701
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 700
    if (len > 262144U) {
#line 701
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 702
  padded_len = (len + 8U) & 4294967288U;
#line 705
  tmp___1 = buffer_len(& input);
#line 705
  if (tmp___1 < 4U + padded_len) {
#line 706
    return (0);
  }
#line 711
  buffer_consume(& input, 4U);
#line 718
  if ((receive_context.cipher)->number != 0) {
#line 718
    tmp___2 = buffer_ptr(& input);
#line 718
    tmp___3 = detect_attack((u_char *)tmp___2, padded_len, (u_char *)((void *)0));
#line 718
    if (tmp___3 == 1) {
#line 720
      packet_disconnect("crc32 compensation attack: network attack detected");
    }
  }
#line 723
  buffer_clear(& incoming_packet);
#line 724
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 725
  tmp___4 = buffer_ptr(& input);
#line 725
  cipher_decrypt(& receive_context, (u_char *)cp, (u_char const   *)tmp___4, padded_len);
#line 727
  buffer_consume(& input, padded_len);
#line 735
  tmp___5 = buffer_len(& incoming_packet);
#line 735
  tmp___6 = buffer_ptr(& incoming_packet);
#line 735
  checksum = ssh_crc32((u_char const   *)((u_char *)tmp___6), tmp___5 - 4U);
#line 739
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 742
  tmp___8 = buffer_len(& incoming_packet);
#line 742
  if (len != tmp___8) {
#line 743
    tmp___7 = buffer_len(& incoming_packet);
#line 743
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___7);
  }
#line 746
  tmp___9 = buffer_ptr(& incoming_packet);
#line 746
  ucp = ((u_char *)tmp___9 + len) - 4;
#line 747
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 748
  if (checksum != stored_checksum) {
#line 749
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 750
  buffer_consume_end(& incoming_packet, 4U);
#line 752
  if (packet_compression) {
#line 753
    buffer_clear(& compression_buffer);
#line 754
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 755
    buffer_clear(& incoming_packet);
#line 756
    tmp___10 = buffer_len(& compression_buffer);
#line 756
    tmp___11 = buffer_ptr(& compression_buffer);
#line 756
    buffer_append(& incoming_packet, (char const   *)tmp___11, tmp___10);
  }
#line 759
  tmp___12 = buffer_get_char(& incoming_packet);
#line 759
  type = (unsigned char )tmp___12;
#line 760
  tmp___13 = buffer_len(& incoming_packet);
#line 760
  *payload_len_ptr = (int )tmp___13;
#line 761
  return ((int )type);
}
}
#line 767
static int packet_read_poll2(int *payload_len_ptr ) ;
#line 767 "packet.c"
static u_int32_t seqnr___0  =    (u_int32_t )0;
#line 768 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 764 "packet.c"
static int packet_read_poll2(int *payload_len_ptr ) 
{ u_int padlen ;
  u_int need ;
  u_char *macbuf ;
  u_char *ucp ;
  u_char type ;
  char *cp ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  char *tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  u_int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  u_int tmp___12 ;

  {
#line 773
  enc = (Enc *)((void *)0);
#line 774
  mac = (Mac *)((void *)0);
#line 775
  comp = (Comp *)((void *)0);
#line 777
  if ((unsigned int )newkeys[0] != (unsigned int )((void *)0)) {
#line 778
    enc = & (newkeys[0])->enc;
#line 779
    mac = & (newkeys[0])->mac;
#line 780
    comp = & (newkeys[0])->comp;
  }
#line 782
  if (mac) {
#line 782
    if (mac->enabled) {
#line 782
      maclen = mac->mac_len;
    } else {
#line 782
      maclen = 0;
    }
  } else {
#line 782
    maclen = 0;
  }
#line 783
  if (enc) {
#line 783
    block_size = (int )(enc->cipher)->block_size;
  } else {
#line 783
    block_size = 8;
  }
#line 785
  if (packet_length == 0U) {
#line 790
    tmp = buffer_len(& input);
#line 790
    if (tmp < (u_int )block_size) {
#line 791
      return (0);
    }
#line 792
    buffer_clear(& incoming_packet);
#line 793
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 794
    tmp___0 = buffer_ptr(& input);
#line 794
    cipher_decrypt(& receive_context, (u_char *)cp, (u_char const   *)tmp___0, (unsigned int )block_size);
#line 796
    tmp___1 = buffer_ptr(& incoming_packet);
#line 796
    ucp = (u_char *)tmp___1;
#line 797
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 798
    if (packet_length < 5U) {
#line 799
      buffer_dump(& incoming_packet);
#line 800
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 798
      if (packet_length > 262144U) {
#line 799
        buffer_dump(& incoming_packet);
#line 800
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 803
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 806
  need = (4U + packet_length) - (u_int )block_size;
#line 809
  if (need % (unsigned int )block_size != 0U) {
#line 810
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 816
  tmp___2 = buffer_len(& input);
#line 816
  if (tmp___2 < need + (u_int )maclen) {
#line 817
    return (0);
  }
#line 822
  buffer_append_space(& incoming_packet, & cp, need);
#line 823
  tmp___3 = buffer_ptr(& input);
#line 823
  cipher_decrypt(& receive_context, (u_char *)cp, (u_char const   *)tmp___3, need);
#line 824
  buffer_consume(& input, need);
#line 829
  if (mac) {
#line 829
    if (mac->enabled) {
#line 830
      tmp___4 = buffer_len(& incoming_packet);
#line 830
      tmp___5 = buffer_ptr(& incoming_packet);
#line 830
      macbuf = mac_compute(mac, seqnr___0, (u_char *)tmp___5, (int )tmp___4);
#line 833
      tmp___6 = buffer_ptr(& input);
#line 833
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 833
      if (tmp___7 != 0) {
#line 834
        packet_disconnect("Corrupted MAC on input.");
      }
#line 836
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 838
  seqnr___0 ++;
#line 838
  if (seqnr___0 == 0U) {
#line 839
    log("incoming seqnr wraps around");
  }
#line 842
  tmp___8 = buffer_ptr(& incoming_packet);
#line 842
  cp = tmp___8 + 4;
#line 843
  padlen = (unsigned int )((unsigned char )*cp);
#line 845
  if (padlen < 4U) {
#line 846
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 849
  buffer_consume(& incoming_packet, 5U);
#line 850
  buffer_consume_end(& incoming_packet, padlen);
#line 853
  if (comp) {
#line 853
    if (comp->enabled) {
#line 854
      buffer_clear(& compression_buffer);
#line 855
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 856
      buffer_clear(& incoming_packet);
#line 857
      tmp___9 = buffer_len(& compression_buffer);
#line 857
      tmp___10 = buffer_ptr(& compression_buffer);
#line 857
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 865
  tmp___11 = buffer_get_char(& incoming_packet);
#line 865
  type = (unsigned char )tmp___11;
#line 866
  if ((int )type == 21) {
#line 867
    set_newkeys(0);
  }
#line 868
  tmp___12 = buffer_len(& incoming_packet);
#line 868
  *payload_len_ptr = (int )tmp___12;
#line 874
  packet_length = 0U;
#line 875
  return ((int )type);
}
}
#line 878 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ int reason ;
  u_char type ;
  char *msg ;
  int tmp ;
  u_int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 885
  while (1) {
#line 886
    if (compat20) {
#line 887
      tmp = packet_read_poll2(payload_len_ptr);
#line 887
      type = (unsigned char )tmp;
#line 888
      if (type) {

      }
#line 890
      switch ((int )type) {
      case 2: 
#line 892
      break;
      case 4: 
#line 894
      packet_get_char();
#line 895
      msg = packet_get_string((u_int *)((void *)0));
#line 896
      debug("Remote: %.900s", msg);
#line 897
      xfree((void *)msg);
#line 898
      msg = packet_get_string((u_int *)((void *)0));
#line 899
      xfree((void *)msg);
#line 900
      break;
      case 1: 
#line 902
      tmp___0 = packet_get_int();
#line 902
      reason = (int )tmp___0;
#line 903
      msg = packet_get_string((u_int *)((void *)0));
#line 904
      tmp___1 = get_remote_ipaddr();
#line 904
      log("Received disconnect from %s: %d: %.400s", tmp___1, reason, msg);
#line 906
      xfree((void *)msg);
#line 907
      fatal_cleanup();
#line 908
      break;
      default: ;
#line 910
      return ((int )type);
#line 911
      break;
      }
    } else {
#line 914
      tmp___2 = packet_read_poll1(payload_len_ptr);
#line 914
      type = (unsigned char )tmp___2;
#line 915
      switch ((int )type) {
      case 32: 
#line 917
      break;
      case 36: 
#line 919
      msg = packet_get_string((u_int *)((void *)0));
#line 920
      debug("Remote: %.900s", msg);
#line 921
      xfree((void *)msg);
#line 922
      break;
      case 1: 
#line 924
      msg = packet_get_string((u_int *)((void *)0));
#line 925
      tmp___3 = get_remote_ipaddr();
#line 925
      log("Received disconnect from %s: %.400s", tmp___3, msg);
#line 927
      fatal_cleanup();
#line 928
      xfree((void *)msg);
#line 929
      break;
      default: ;
#line 931
      if (type) {

      }
#line 933
      return ((int )type);
#line 934
      break;
      }
    }
  }
}
}
#line 945 "packet.c"
void packet_process_incoming(char const   *buf___2 , u_int len ) 
{ 

  {
#line 948
  buffer_append(& input, buf___2, len);
#line 949
  return;
}
}
#line 953 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 957
  buffer_get(& incoming_packet, & ch, 1U);
#line 958
  return ((unsigned int )((unsigned char )ch));
}
}
#line 963 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 966
  tmp = buffer_get_int(& incoming_packet);
#line 966
  return (tmp);
}
}
#line 974 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 977
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 978
  return;
}
}
#line 980 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 983
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 984
  return;
}
}
#line 986 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  u_int tmp ;
  char *tmp___0 ;

  {
#line 989
  tmp = buffer_len(& incoming_packet);
#line 989
  bytes = (int )tmp;
#line 990
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 991
    *length_ptr = bytes;
  }
#line 992
  tmp___0 = buffer_ptr(& incoming_packet);
#line 992
  return (tmp___0);
}
}
#line 995 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 998
  tmp = buffer_len(& incoming_packet);
#line 998
  return ((int )tmp);
}
}
#line 1008 "packet.c"
char *packet_get_string(u_int *length_ptr ) 
{ char *tmp ;

  {
#line 1011
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1011
  return (tmp);
}
}
#line 1023 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___2[1024] ;
  va_list args ;

  {
#line 1029
  if (compat20) {
#line 1029
    if (datafellows & 64) {
#line 1030
      return;
    }
  }
#line 1032
  __builtin_va_start(args, fmt);
#line 1033
  vsnprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )fmt,
            args);
#line 1034
  __builtin_va_end(args);
#line 1036
  if (compat20) {
#line 1037
    packet_start((unsigned char)4);
#line 1038
    packet_put_char(0);
#line 1039
    packet_put_cstring((char const   *)(buf___2));
#line 1040
    packet_put_cstring("");
  } else {
#line 1042
    packet_start((unsigned char)36);
#line 1043
    packet_put_cstring((char const   *)(buf___2));
  }
#line 1045
  packet_send();
#line 1046
  packet_write_wait();
#line 1047
  return;
}
}
#line 1061 "packet.c"
static int disconnecting  =    0;
#line 1056 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___2[1024] ;
  va_list args ;

  {
#line 1062
  if (disconnecting) {
#line 1063
    fatal("packet_disconnect called recursively.");
  }
#line 1064
  disconnecting = 1;
#line 1070
  __builtin_va_start(args, fmt);
#line 1071
  vsnprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )fmt,
            args);
#line 1072
  __builtin_va_end(args);
#line 1075
  if (compat20) {
#line 1076
    packet_start((unsigned char)1);
#line 1077
    packet_put_int(2U);
#line 1078
    packet_put_cstring((char const   *)(buf___2));
#line 1079
    packet_put_cstring("");
  } else {
#line 1081
    packet_start((unsigned char)1);
#line 1082
    packet_put_cstring((char const   *)(buf___2));
  }
#line 1084
  packet_send();
#line 1085
  packet_write_wait();
#line 1088
  channel_close_all();
#line 1091
  packet_close();
#line 1094
  log("Disconnecting: %.100s", buf___2);
#line 1095
  fatal_cleanup();
#line 1096
  return;
}
}
#line 1100 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1103
  tmp = buffer_len(& output);
#line 1103
  len = (int )tmp;
#line 1104
  if (len > 0) {
#line 1105
    tmp___0 = buffer_ptr(& output);
#line 1105
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1106
    if (len <= 0) {
#line 1107
      tmp___3 = __errno_location();
#line 1107
      if (*tmp___3 == 11) {
#line 1108
        return;
      } else {
#line 1110
        tmp___1 = __errno_location();
#line 1110
        tmp___2 = strerror(*tmp___1);
#line 1110
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1112
    buffer_consume(& output, (unsigned int )len);
  }
#line 1114
  return;
}
}
#line 1121 "packet.c"
void packet_write_wait(void) 
{ fd_set *setp ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1126
  tmp = xmalloc((((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1126
  setp = (fd_set *)tmp;
#line 1128
  packet_write_poll();
#line 1129
  while (1) {
#line 1129
    tmp___3 = packet_have_data_to_write();
#line 1129
    if (! tmp___3) {
#line 1129
      break;
    }
#line 1130
    memset((void *)setp, 0, (((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1132
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1133
    while (1) {
#line 1133
      tmp___0 = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )setp,
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1133
      if (tmp___0 == -1) {
#line 1133
        tmp___1 = __errno_location();
#line 1133
        if (! (*tmp___1 == 11)) {
#line 1133
          tmp___2 = __errno_location();
#line 1133
          if (! (*tmp___2 == 4)) {
#line 1133
            break;
          }
        }
      } else {
#line 1133
        break;
      }
    }
#line 1136
    packet_write_poll();
  }
#line 1138
  xfree((void *)setp);
#line 1139
  return;
}
}
#line 1143 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1146
  tmp = buffer_len(& output);
#line 1146
  return (tmp != 0U);
}
}
#line 1151 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1154
  if (interactive_mode) {
#line 1155
    tmp = buffer_len(& output);
#line 1155
    return (tmp < 16384U);
  } else {
#line 1157
    tmp___0 = buffer_len(& output);
#line 1157
    return (tmp___0 < 131072U);
  }
}
}
#line 1165 "packet.c"
static int called___0  =    0;
#line 1162 "packet.c"
void packet_set_interactive(int interactive ) 
{ int lowdelay ;
  int throughput ;
  int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1167
  lowdelay = 16;
#line 1168
  throughput = 8;
#line 1170
  on = 1;
#line 1172
  if (called___0) {
#line 1173
    return;
  }
#line 1174
  called___0 = 1;
#line 1177
  interactive_mode = interactive;
#line 1180
  tmp = packet_connection_is_on_socket();
#line 1180
  if (! tmp) {
#line 1181
    return;
  }
#line 1185
  if (interactive) {
#line 1191
    tmp___3 = packet_connection_is_ipv4();
#line 1191
    if (tmp___3) {
#line 1192
      tmp___2 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                           sizeof(lowdelay));
#line 1192
      if (tmp___2 < 0) {
#line 1194
        tmp___0 = __errno_location();
#line 1194
        tmp___1 = strerror(*tmp___0);
#line 1194
        error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___1);
      }
    }
#line 1198
    tmp___6 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1198
    if (tmp___6 < 0) {
#line 1200
      tmp___4 = __errno_location();
#line 1200
      tmp___5 = strerror(*tmp___4);
#line 1200
      error("setsockopt TCP_NODELAY: %.100s", tmp___5);
    }
  } else {
#line 1201
    tmp___10 = packet_connection_is_ipv4();
#line 1201
    if (tmp___10) {
#line 1207
      tmp___9 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                           sizeof(throughput));
#line 1207
      if (tmp___9 < 0) {
#line 1209
        tmp___7 = __errno_location();
#line 1209
        tmp___8 = strerror(*tmp___7);
#line 1209
        error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___8);
      }
    }
  }
#line 1212
  return;
}
}
#line 1216 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1219
  return (interactive_mode);
}
}
#line 1225 "packet.c"
static int called___1  =    0;
#line 1222 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1226
  if (called___1) {
#line 1227
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1229
    return (-1);
  }
#line 1231
  if (s < 4096) {
#line 1232
    log("packet_set_maxsize: bad size %d", s);
#line 1233
    return (-1);
  } else {
#line 1231
    if (s > 1048576) {
#line 1232
      log("packet_set_maxsize: bad size %d", s);
#line 1233
      return (-1);
    }
  }
#line 1235
  debug("packet_set_maxsize: setting to %d", s);
#line 1236
  max_packet_size = s;
#line 1237
  return (s);
}
}
#line 1252 "packet.c"
void packet_inject_ignore(int sumlen ) 
{ int blocksize ;
  int padlen ;
  int have ;
  int need ;
  int nb ;
  int mini ;
  int nbytes ;
  Enc *enc ;
  u_int tmp ;

  {
#line 1256
  enc = (Enc *)((void *)0);
#line 1258
  if (compat20 == 0) {
#line 1259
    return;
  }
#line 1261
  tmp = buffer_len(& outgoing_packet);
#line 1261
  have = (int )tmp;
#line 1262
  debug2("packet_inject_ignore: current %d", have);
#line 1263
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 1264
    enc = & (newkeys[1])->enc;
  }
#line 1265
  if (enc) {
#line 1265
    blocksize = (int )(enc->cipher)->block_size;
  } else {
#line 1265
    blocksize = 8;
  }
#line 1266
  padlen = blocksize - have % blocksize;
#line 1267
  if (padlen < 4) {
#line 1268
    padlen += blocksize;
  }
#line 1269
  have += padlen;
#line 1270
  have /= blocksize;
#line 1272
  nb = (((sumlen + (blocksize - 1)) / blocksize) * blocksize) / blocksize;
#line 1273
  mini = (((14 + (blocksize - 1)) / blocksize) * blocksize) / blocksize;
#line 1274
  need = nb - have % nb;
#line 1275
  if (need <= mini) {
#line 1276
    need += nb;
  }
#line 1277
  nbytes = (need - mini) * blocksize;
#line 1278
  debug2("packet_inject_ignore: block %d have %d nb %d mini %d need %d", blocksize,
         have, nb, mini, need);
#line 1282
  packet_send();
#line 1283
  packet_send_ignore(nbytes);
#line 1284
  return;
}
}
#line 1286 "packet.c"
void packet_send_ignore(int nbytes ) 
{ u_int32_t rand___0 ;
  int i ;
  int tmp ;

  {
#line 1289
  rand___0 = (u_int32_t )0;
#line 1292
  if (compat20) {
#line 1292
    tmp = 2;
  } else {
#line 1292
    tmp = 32;
  }
#line 1292
  packet_start((unsigned char )tmp);
#line 1293
  packet_put_int((unsigned int )nbytes);
#line 1294
  i = 0;
#line 1294
  while (i < nbytes) {
#line 1295
    if (i % 4 == 0) {
#line 1296
      rand___0 = arc4random();
    }
#line 1297
    packet_put_char((int )(rand___0 & 255U));
#line 1298
    rand___0 >>= 8;
#line 1294
    i ++;
  }
#line 1300
  return;
}
}
#line 1 "radix.o"
#line 1 "rijndael.o"
#line 51 "rijndael.c"
static u32 const   Te0[256]  = 
#line 51 "rijndael.c"
  {      (u32 const   )3328402341U,      (u32 const   )4168907908U,      (u32 const   )4000806809U,      (u32 const   )4135287693U, 
        (u32 const   )4294111757U,      (u32 const   )3597364157U,      (u32 const   )3731845041U,      (u32 const   )2445657428U, 
        (u32 const   )1613770832U,      (u32 const   )33620227U,      (u32 const   )3462883241U,      (u32 const   )1445669757U, 
        (u32 const   )3892248089U,      (u32 const   )3050821474U,      (u32 const   )1303096294U,      (u32 const   )3967186586U, 
        (u32 const   )2412431941U,      (u32 const   )528646813U,      (u32 const   )2311702848U,      (u32 const   )4202528135U, 
        (u32 const   )4026202645U,      (u32 const   )2992200171U,      (u32 const   )2387036105U,      (u32 const   )4226871307U, 
        (u32 const   )1101901292U,      (u32 const   )3017069671U,      (u32 const   )1604494077U,      (u32 const   )1169141738U, 
        (u32 const   )597466303U,      (u32 const   )1403299063U,      (u32 const   )3832705686U,      (u32 const   )2613100635U, 
        (u32 const   )1974974402U,      (u32 const   )3791519004U,      (u32 const   )1033081774U,      (u32 const   )1277568618U, 
        (u32 const   )1815492186U,      (u32 const   )2118074177U,      (u32 const   )4126668546U,      (u32 const   )2211236943U, 
        (u32 const   )1748251740U,      (u32 const   )1369810420U,      (u32 const   )3521504564U,      (u32 const   )4193382664U, 
        (u32 const   )3799085459U,      (u32 const   )2883115123U,      (u32 const   )1647391059U,      (u32 const   )706024767U, 
        (u32 const   )134480908U,      (u32 const   )2512897874U,      (u32 const   )1176707941U,      (u32 const   )2646852446U, 
        (u32 const   )806885416U,      (u32 const   )932615841U,      (u32 const   )168101135U,      (u32 const   )798661301U, 
        (u32 const   )235341577U,      (u32 const   )605164086U,      (u32 const   )461406363U,      (u32 const   )3756188221U, 
        (u32 const   )3454790438U,      (u32 const   )1311188841U,      (u32 const   )2142417613U,      (u32 const   )3933566367U, 
        (u32 const   )302582043U,      (u32 const   )495158174U,      (u32 const   )1479289972U,      (u32 const   )874125870U, 
        (u32 const   )907746093U,      (u32 const   )3698224818U,      (u32 const   )3025820398U,      (u32 const   )1537253627U, 
        (u32 const   )2756858614U,      (u32 const   )1983593293U,      (u32 const   )3084310113U,      (u32 const   )2108928974U, 
        (u32 const   )1378429307U,      (u32 const   )3722699582U,      (u32 const   )1580150641U,      (u32 const   )327451799U, 
        (u32 const   )2790478837U,      (u32 const   )3117535592U,      (u32 const   )0U,      (u32 const   )3253595436U, 
        (u32 const   )1075847264U,      (u32 const   )3825007647U,      (u32 const   )2041688520U,      (u32 const   )3059440621U, 
        (u32 const   )3563743934U,      (u32 const   )2378943302U,      (u32 const   )1740553945U,      (u32 const   )1916352843U, 
        (u32 const   )2487896798U,      (u32 const   )2555137236U,      (u32 const   )2958579944U,      (u32 const   )2244988746U, 
        (u32 const   )3151024235U,      (u32 const   )3320835882U,      (u32 const   )1336584933U,      (u32 const   )3992714006U, 
        (u32 const   )2252555205U,      (u32 const   )2588757463U,      (u32 const   )1714631509U,      (u32 const   )293963156U, 
        (u32 const   )2319795663U,      (u32 const   )3925473552U,      (u32 const   )67240454U,      (u32 const   )4269768577U, 
        (u32 const   )2689618160U,      (u32 const   )2017213508U,      (u32 const   )631218106U,      (u32 const   )1269344483U, 
        (u32 const   )2723238387U,      (u32 const   )1571005438U,      (u32 const   )2151694528U,      (u32 const   )93294474U, 
        (u32 const   )1066570413U,      (u32 const   )563977660U,      (u32 const   )1882732616U,      (u32 const   )4059428100U, 
        (u32 const   )1673313503U,      (u32 const   )2008463041U,      (u32 const   )2950355573U,      (u32 const   )1109467491U, 
        (u32 const   )537923632U,      (u32 const   )3858759450U,      (u32 const   )4260623118U,      (u32 const   )3218264685U, 
        (u32 const   )2177748300U,      (u32 const   )403442708U,      (u32 const   )638784309U,      (u32 const   )3287084079U, 
        (u32 const   )3193921505U,      (u32 const   )899127202U,      (u32 const   )2286175436U,      (u32 const   )773265209U, 
        (u32 const   )2479146071U,      (u32 const   )1437050866U,      (u32 const   )4236148354U,      (u32 const   )2050833735U, 
        (u32 const   )3362022572U,      (u32 const   )3126681063U,      (u32 const   )840505643U,      (u32 const   )3866325909U, 
        (u32 const   )3227541664U,      (u32 const   )427917720U,      (u32 const   )2655997905U,      (u32 const   )2749160575U, 
        (u32 const   )1143087718U,      (u32 const   )1412049534U,      (u32 const   )999329963U,      (u32 const   )193497219U, 
        (u32 const   )2353415882U,      (u32 const   )3354324521U,      (u32 const   )1807268051U,      (u32 const   )672404540U, 
        (u32 const   )2816401017U,      (u32 const   )3160301282U,      (u32 const   )369822493U,      (u32 const   )2916866934U, 
        (u32 const   )3688947771U,      (u32 const   )1681011286U,      (u32 const   )1949973070U,      (u32 const   )336202270U, 
        (u32 const   )2454276571U,      (u32 const   )201721354U,      (u32 const   )1210328172U,      (u32 const   )3093060836U, 
        (u32 const   )2680341085U,      (u32 const   )3184776046U,      (u32 const   )1135389935U,      (u32 const   )3294782118U, 
        (u32 const   )965841320U,      (u32 const   )831886756U,      (u32 const   )3554993207U,      (u32 const   )4068047243U, 
        (u32 const   )3588745010U,      (u32 const   )2345191491U,      (u32 const   )1849112409U,      (u32 const   )3664604599U, 
        (u32 const   )26054028U,      (u32 const   )2983581028U,      (u32 const   )2622377682U,      (u32 const   )1235855840U, 
        (u32 const   )3630984372U,      (u32 const   )2891339514U,      (u32 const   )4092916743U,      (u32 const   )3488279077U, 
        (u32 const   )3395642799U,      (u32 const   )4101667470U,      (u32 const   )1202630377U,      (u32 const   )268961816U, 
        (u32 const   )1874508501U,      (u32 const   )4034427016U,      (u32 const   )1243948399U,      (u32 const   )1546530418U, 
        (u32 const   )941366308U,      (u32 const   )1470539505U,      (u32 const   )1941222599U,      (u32 const   )2546386513U, 
        (u32 const   )3421038627U,      (u32 const   )2715671932U,      (u32 const   )3899946140U,      (u32 const   )1042226977U, 
        (u32 const   )2521517021U,      (u32 const   )1639824860U,      (u32 const   )227249030U,      (u32 const   )260737669U, 
        (u32 const   )3765465232U,      (u32 const   )2084453954U,      (u32 const   )1907733956U,      (u32 const   )3429263018U, 
        (u32 const   )2420656344U,      (u32 const   )100860677U,      (u32 const   )4160157185U,      (u32 const   )470683154U, 
        (u32 const   )3261161891U,      (u32 const   )1781871967U,      (u32 const   )2924959737U,      (u32 const   )1773779408U, 
        (u32 const   )394692241U,      (u32 const   )2579611992U,      (u32 const   )974986535U,      (u32 const   )664706745U, 
        (u32 const   )3655459128U,      (u32 const   )3958962195U,      (u32 const   )731420851U,      (u32 const   )571543859U, 
        (u32 const   )3530123707U,      (u32 const   )2849626480U,      (u32 const   )126783113U,      (u32 const   )865375399U, 
        (u32 const   )765172662U,      (u32 const   )1008606754U,      (u32 const   )361203602U,      (u32 const   )3387549984U, 
        (u32 const   )2278477385U,      (u32 const   )2857719295U,      (u32 const   )1344809080U,      (u32 const   )2782912378U, 
        (u32 const   )59542671U,      (u32 const   )1503764984U,      (u32 const   )160008576U,      (u32 const   )437062935U, 
        (u32 const   )1707065306U,      (u32 const   )3622233649U,      (u32 const   )2218934982U,      (u32 const   )3496503480U, 
        (u32 const   )2185314755U,      (u32 const   )697932208U,      (u32 const   )1512910199U,      (u32 const   )504303377U, 
        (u32 const   )2075177163U,      (u32 const   )2824099068U,      (u32 const   )1841019862U,      (u32 const   )739644986U};
#line 117 "rijndael.c"
static u32 const   Te1[256]  = 
#line 117
  {      (u32 const   )2781242211U,      (u32 const   )2230877308U,      (u32 const   )2582542199U,      (u32 const   )2381740923U, 
        (u32 const   )234877682U,      (u32 const   )3184946027U,      (u32 const   )2984144751U,      (u32 const   )1418839493U, 
        (u32 const   )1348481072U,      (u32 const   )50462977U,      (u32 const   )2848876391U,      (u32 const   )2102799147U, 
        (u32 const   )434634494U,      (u32 const   )1656084439U,      (u32 const   )3863849899U,      (u32 const   )2599188086U, 
        (u32 const   )1167051466U,      (u32 const   )2636087938U,      (u32 const   )1082771913U,      (u32 const   )2281340285U, 
        (u32 const   )368048890U,      (u32 const   )3954334041U,      (u32 const   )3381544775U,      (u32 const   )201060592U, 
        (u32 const   )3963727277U,      (u32 const   )1739838676U,      (u32 const   )4250903202U,      (u32 const   )3930435503U, 
        (u32 const   )3206782108U,      (u32 const   )4149453988U,      (u32 const   )2531553906U,      (u32 const   )1536934080U, 
        (u32 const   )3262494647U,      (u32 const   )484572669U,      (u32 const   )2923271059U,      (u32 const   )1783375398U, 
        (u32 const   )1517041206U,      (u32 const   )1098792767U,      (u32 const   )49674231U,      (u32 const   )1334037708U, 
        (u32 const   )1550332980U,      (u32 const   )4098991525U,      (u32 const   )886171109U,      (u32 const   )150598129U, 
        (u32 const   )2481090929U,      (u32 const   )1940642008U,      (u32 const   )1398944049U,      (u32 const   )1059722517U, 
        (u32 const   )201851908U,      (u32 const   )1385547719U,      (u32 const   )1699095331U,      (u32 const   )1587397571U, 
        (u32 const   )674240536U,      (u32 const   )2704774806U,      (u32 const   )252314885U,      (u32 const   )3039795866U, 
        (u32 const   )151914247U,      (u32 const   )908333586U,      (u32 const   )2602270848U,      (u32 const   )1038082786U, 
        (u32 const   )651029483U,      (u32 const   )1766729511U,      (u32 const   )3447698098U,      (u32 const   )2682942837U, 
        (u32 const   )454166793U,      (u32 const   )2652734339U,      (u32 const   )1951935532U,      (u32 const   )775166490U, 
        (u32 const   )758520603U,      (u32 const   )3000790638U,      (u32 const   )4004797018U,      (u32 const   )4217086112U, 
        (u32 const   )4137964114U,      (u32 const   )1299594043U,      (u32 const   )1639438038U,      (u32 const   )3464344499U, 
        (u32 const   )2068982057U,      (u32 const   )1054729187U,      (u32 const   )1901997871U,      (u32 const   )2534638724U, 
        (u32 const   )4121318227U,      (u32 const   )1757008337U,      (u32 const   )0U,      (u32 const   )750906861U, 
        (u32 const   )1614815264U,      (u32 const   )535035132U,      (u32 const   )3363418545U,      (u32 const   )3988151131U, 
        (u32 const   )3201591914U,      (u32 const   )1183697867U,      (u32 const   )3647454910U,      (u32 const   )1265776953U, 
        (u32 const   )3734260298U,      (u32 const   )3566750796U,      (u32 const   )3903871064U,      (u32 const   )1250283471U, 
        (u32 const   )1807470800U,      (u32 const   )717615087U,      (u32 const   )3847203498U,      (u32 const   )384695291U, 
        (u32 const   )3313910595U,      (u32 const   )3617213773U,      (u32 const   )1432761139U,      (u32 const   )2484176261U, 
        (u32 const   )3481945413U,      (u32 const   )283769337U,      (u32 const   )100925954U,      (u32 const   )2180939647U, 
        (u32 const   )4037038160U,      (u32 const   )1148730428U,      (u32 const   )3123027871U,      (u32 const   )3813386408U, 
        (u32 const   )4087501137U,      (u32 const   )4267549603U,      (u32 const   )3229630528U,      (u32 const   )2315620239U, 
        (u32 const   )2906624658U,      (u32 const   )3156319645U,      (u32 const   )1215313976U,      (u32 const   )82966005U, 
        (u32 const   )3747855548U,      (u32 const   )3245848246U,      (u32 const   )1974459098U,      (u32 const   )1665278241U, 
        (u32 const   )807407632U,      (u32 const   )451280895U,      (u32 const   )251524083U,      (u32 const   )1841287890U, 
        (u32 const   )1283575245U,      (u32 const   )337120268U,      (u32 const   )891687699U,      (u32 const   )801369324U, 
        (u32 const   )3787349855U,      (u32 const   )2721421207U,      (u32 const   )3431482436U,      (u32 const   )959321879U, 
        (u32 const   )1469301956U,      (u32 const   )4065699751U,      (u32 const   )2197585534U,      (u32 const   )1199193405U, 
        (u32 const   )2898814052U,      (u32 const   )3887750493U,      (u32 const   )724703513U,      (u32 const   )2514908019U, 
        (u32 const   )2696962144U,      (u32 const   )2551808385U,      (u32 const   )3516813135U,      (u32 const   )2141445340U, 
        (u32 const   )1715741218U,      (u32 const   )2119445034U,      (u32 const   )2872807568U,      (u32 const   )2198571144U, 
        (u32 const   )3398190662U,      (u32 const   )700968686U,      (u32 const   )3547052216U,      (u32 const   )1009259540U, 
        (u32 const   )2041044702U,      (u32 const   )3803995742U,      (u32 const   )487983883U,      (u32 const   )1991105499U, 
        (u32 const   )1004265696U,      (u32 const   )1449407026U,      (u32 const   )1316239930U,      (u32 const   )504629770U, 
        (u32 const   )3683797321U,      (u32 const   )168560134U,      (u32 const   )1816667172U,      (u32 const   )3837287516U, 
        (u32 const   )1570751170U,      (u32 const   )1857934291U,      (u32 const   )4014189740U,      (u32 const   )2797888098U, 
        (u32 const   )2822345105U,      (u32 const   )2754712981U,      (u32 const   )936633572U,      (u32 const   )2347923833U, 
        (u32 const   )852879335U,      (u32 const   )1133234376U,      (u32 const   )1500395319U,      (u32 const   )3084545389U, 
        (u32 const   )2348912013U,      (u32 const   )1689376213U,      (u32 const   )3533459022U,      (u32 const   )3762923945U, 
        (u32 const   )3034082412U,      (u32 const   )4205598294U,      (u32 const   )133428468U,      (u32 const   )634383082U, 
        (u32 const   )2949277029U,      (u32 const   )2398386810U,      (u32 const   )3913789102U,      (u32 const   )403703816U, 
        (u32 const   )3580869306U,      (u32 const   )2297460856U,      (u32 const   )1867130149U,      (u32 const   )1918643758U, 
        (u32 const   )607656988U,      (u32 const   )4049053350U,      (u32 const   )3346248884U,      (u32 const   )1368901318U, 
        (u32 const   )600565992U,      (u32 const   )2090982877U,      (u32 const   )2632479860U,      (u32 const   )557719327U, 
        (u32 const   )3717614411U,      (u32 const   )3697393085U,      (u32 const   )2249034635U,      (u32 const   )2232388234U, 
        (u32 const   )2430627952U,      (u32 const   )1115438654U,      (u32 const   )3295786421U,      (u32 const   )2865522278U, 
        (u32 const   )3633334344U,      (u32 const   )84280067U,      (u32 const   )33027830U,      (u32 const   )303828494U, 
        (u32 const   )2747425121U,      (u32 const   )1600795957U,      (u32 const   )4188952407U,      (u32 const   )3496589753U, 
        (u32 const   )2434238086U,      (u32 const   )1486471617U,      (u32 const   )658119965U,      (u32 const   )3106381470U, 
        (u32 const   )953803233U,      (u32 const   )334231800U,      (u32 const   )3005978776U,      (u32 const   )857870609U, 
        (u32 const   )3151128937U,      (u32 const   )1890179545U,      (u32 const   )2298973838U,      (u32 const   )2805175444U, 
        (u32 const   )3056442267U,      (u32 const   )574365214U,      (u32 const   )2450884487U,      (u32 const   )550103529U, 
        (u32 const   )1233637070U,      (u32 const   )4289353045U,      (u32 const   )2018519080U,      (u32 const   )2057691103U, 
        (u32 const   )2399374476U,      (u32 const   )4166623649U,      (u32 const   )2148108681U,      (u32 const   )387583245U, 
        (u32 const   )3664101311U,      (u32 const   )836232934U,      (u32 const   )3330556482U,      (u32 const   )3100665960U, 
        (u32 const   )3280093505U,      (u32 const   )2955516313U,      (u32 const   )2002398509U,      (u32 const   )287182607U, 
        (u32 const   )3413881008U,      (u32 const   )4238890068U,      (u32 const   )3597515707U,      (u32 const   )975967766U};
#line 183 "rijndael.c"
static u32 const   Te2[256]  = 
#line 183
  {      (u32 const   )1671808611U,      (u32 const   )2089089148U,      (u32 const   )2006576759U,      (u32 const   )2072901243U, 
        (u32 const   )4061003762U,      (u32 const   )1807603307U,      (u32 const   )1873927791U,      (u32 const   )3310653893U, 
        (u32 const   )810573872U,      (u32 const   )16974337U,      (u32 const   )1739181671U,      (u32 const   )729634347U, 
        (u32 const   )4263110654U,      (u32 const   )3613570519U,      (u32 const   )2883997099U,      (u32 const   )1989864566U, 
        (u32 const   )3393556426U,      (u32 const   )2191335298U,      (u32 const   )3376449993U,      (u32 const   )2106063485U, 
        (u32 const   )4195741690U,      (u32 const   )1508618841U,      (u32 const   )1204391495U,      (u32 const   )4027317232U, 
        (u32 const   )2917941677U,      (u32 const   )3563566036U,      (u32 const   )2734514082U,      (u32 const   )2951366063U, 
        (u32 const   )2629772188U,      (u32 const   )2767672228U,      (u32 const   )1922491506U,      (u32 const   )3227229120U, 
        (u32 const   )3082974647U,      (u32 const   )4246528509U,      (u32 const   )2477669779U,      (u32 const   )644500518U, 
        (u32 const   )911895606U,      (u32 const   )1061256767U,      (u32 const   )4144166391U,      (u32 const   )3427763148U, 
        (u32 const   )878471220U,      (u32 const   )2784252325U,      (u32 const   )3845444069U,      (u32 const   )4043897329U, 
        (u32 const   )1905517169U,      (u32 const   )3631459288U,      (u32 const   )827548209U,      (u32 const   )356461077U, 
        (u32 const   )67897348U,      (u32 const   )3344078279U,      (u32 const   )593839651U,      (u32 const   )3277757891U, 
        (u32 const   )405286936U,      (u32 const   )2527147926U,      (u32 const   )84871685U,      (u32 const   )2595565466U, 
        (u32 const   )118033927U,      (u32 const   )305538066U,      (u32 const   )2157648768U,      (u32 const   )3795705826U, 
        (u32 const   )3945188843U,      (u32 const   )661212711U,      (u32 const   )2999812018U,      (u32 const   )1973414517U, 
        (u32 const   )152769033U,      (u32 const   )2208177539U,      (u32 const   )745822252U,      (u32 const   )439235610U, 
        (u32 const   )455947803U,      (u32 const   )1857215598U,      (u32 const   )1525593178U,      (u32 const   )2700827552U, 
        (u32 const   )1391895634U,      (u32 const   )994932283U,      (u32 const   )3596728278U,      (u32 const   )3016654259U, 
        (u32 const   )695947817U,      (u32 const   )3812548067U,      (u32 const   )795958831U,      (u32 const   )2224493444U, 
        (u32 const   )1408607827U,      (u32 const   )3513301457U,      (u32 const   )0U,      (u32 const   )3979133421U, 
        (u32 const   )543178784U,      (u32 const   )4229948412U,      (u32 const   )2982705585U,      (u32 const   )1542305371U, 
        (u32 const   )1790891114U,      (u32 const   )3410398667U,      (u32 const   )3201918910U,      (u32 const   )961245753U, 
        (u32 const   )1256100938U,      (u32 const   )1289001036U,      (u32 const   )1491644504U,      (u32 const   )3477767631U, 
        (u32 const   )3496721360U,      (u32 const   )4012557807U,      (u32 const   )2867154858U,      (u32 const   )4212583931U, 
        (u32 const   )1137018435U,      (u32 const   )1305975373U,      (u32 const   )861234739U,      (u32 const   )2241073541U, 
        (u32 const   )1171229253U,      (u32 const   )4178635257U,      (u32 const   )33948674U,      (u32 const   )2139225727U, 
        (u32 const   )1357946960U,      (u32 const   )1011120188U,      (u32 const   )2679776671U,      (u32 const   )2833468328U, 
        (u32 const   )1374921297U,      (u32 const   )2751356323U,      (u32 const   )1086357568U,      (u32 const   )2408187279U, 
        (u32 const   )2460827538U,      (u32 const   )2646352285U,      (u32 const   )944271416U,      (u32 const   )4110742005U, 
        (u32 const   )3168756668U,      (u32 const   )3066132406U,      (u32 const   )3665145818U,      (u32 const   )560153121U, 
        (u32 const   )271589392U,      (u32 const   )4279952895U,      (u32 const   )4077846003U,      (u32 const   )3530407890U, 
        (u32 const   )3444343245U,      (u32 const   )202643468U,      (u32 const   )322250259U,      (u32 const   )3962553324U, 
        (u32 const   )1608629855U,      (u32 const   )2543990167U,      (u32 const   )1154254916U,      (u32 const   )389623319U, 
        (u32 const   )3294073796U,      (u32 const   )2817676711U,      (u32 const   )2122513534U,      (u32 const   )1028094525U, 
        (u32 const   )1689045092U,      (u32 const   )1575467613U,      (u32 const   )422261273U,      (u32 const   )1939203699U, 
        (u32 const   )1621147744U,      (u32 const   )2174228865U,      (u32 const   )1339137615U,      (u32 const   )3699352540U, 
        (u32 const   )577127458U,      (u32 const   )712922154U,      (u32 const   )2427141008U,      (u32 const   )2290289544U, 
        (u32 const   )1187679302U,      (u32 const   )3995715566U,      (u32 const   )3100863416U,      (u32 const   )339486740U, 
        (u32 const   )3732514782U,      (u32 const   )1591917662U,      (u32 const   )186455563U,      (u32 const   )3681988059U, 
        (u32 const   )3762019296U,      (u32 const   )844522546U,      (u32 const   )978220090U,      (u32 const   )169743370U, 
        (u32 const   )1239126601U,      (u32 const   )101321734U,      (u32 const   )611076132U,      (u32 const   )1558493276U, 
        (u32 const   )3260915650U,      (u32 const   )3547250131U,      (u32 const   )2901361580U,      (u32 const   )1655096418U, 
        (u32 const   )2443721105U,      (u32 const   )2510565781U,      (u32 const   )3828863972U,      (u32 const   )2039214713U, 
        (u32 const   )3878868455U,      (u32 const   )3359869896U,      (u32 const   )928607799U,      (u32 const   )1840765549U, 
        (u32 const   )2374762893U,      (u32 const   )3580146133U,      (u32 const   )1322425422U,      (u32 const   )2850048425U, 
        (u32 const   )1823791212U,      (u32 const   )1459268694U,      (u32 const   )4094161908U,      (u32 const   )3928346602U, 
        (u32 const   )1706019429U,      (u32 const   )2056189050U,      (u32 const   )2934523822U,      (u32 const   )135794696U, 
        (u32 const   )3134549946U,      (u32 const   )2022240376U,      (u32 const   )628050469U,      (u32 const   )779246638U, 
        (u32 const   )472135708U,      (u32 const   )2800834470U,      (u32 const   )3032970164U,      (u32 const   )3327236038U, 
        (u32 const   )3894660072U,      (u32 const   )3715932637U,      (u32 const   )1956440180U,      (u32 const   )522272287U, 
        (u32 const   )1272813131U,      (u32 const   )3185336765U,      (u32 const   )2340818315U,      (u32 const   )2323976074U, 
        (u32 const   )1888542832U,      (u32 const   )1044544574U,      (u32 const   )3049550261U,      (u32 const   )1722469478U, 
        (u32 const   )1222152264U,      (u32 const   )50660867U,      (u32 const   )4127324150U,      (u32 const   )236067854U, 
        (u32 const   )1638122081U,      (u32 const   )895445557U,      (u32 const   )1475980887U,      (u32 const   )3117443513U, 
        (u32 const   )2257655686U,      (u32 const   )3243809217U,      (u32 const   )489110045U,      (u32 const   )2662934430U, 
        (u32 const   )3778599393U,      (u32 const   )4162055160U,      (u32 const   )2561878936U,      (u32 const   )288563729U, 
        (u32 const   )1773916777U,      (u32 const   )3648039385U,      (u32 const   )2391345038U,      (u32 const   )2493985684U, 
        (u32 const   )2612407707U,      (u32 const   )505560094U,      (u32 const   )2274497927U,      (u32 const   )3911240169U, 
        (u32 const   )3460925390U,      (u32 const   )1442818645U,      (u32 const   )678973480U,      (u32 const   )3749357023U, 
        (u32 const   )2358182796U,      (u32 const   )2717407649U,      (u32 const   )2306869641U,      (u32 const   )219617805U, 
        (u32 const   )3218761151U,      (u32 const   )3862026214U,      (u32 const   )1120306242U,      (u32 const   )1756942440U, 
        (u32 const   )1103331905U,      (u32 const   )2578459033U,      (u32 const   )762796589U,      (u32 const   )252780047U, 
        (u32 const   )2966125488U,      (u32 const   )1425844308U,      (u32 const   )3151392187U,      (u32 const   )372911126U};
#line 249 "rijndael.c"
static u32 const   Te3[256]  = 
#line 249
  {      (u32 const   )1667474886U,      (u32 const   )2088535288U,      (u32 const   )2004326894U,      (u32 const   )2071694838U, 
        (u32 const   )4075949567U,      (u32 const   )1802223062U,      (u32 const   )1869591006U,      (u32 const   )3318043793U, 
        (u32 const   )808472672U,      (u32 const   )16843522U,      (u32 const   )1734846926U,      (u32 const   )724270422U, 
        (u32 const   )4278065639U,      (u32 const   )3621216949U,      (u32 const   )2880169549U,      (u32 const   )1987484396U, 
        (u32 const   )3402253711U,      (u32 const   )2189597983U,      (u32 const   )3385409673U,      (u32 const   )2105378810U, 
        (u32 const   )4210693615U,      (u32 const   )1499065266U,      (u32 const   )1195886990U,      (u32 const   )4042263547U, 
        (u32 const   )2913856577U,      (u32 const   )3570689971U,      (u32 const   )2728590687U,      (u32 const   )2947541573U, 
        (u32 const   )2627518243U,      (u32 const   )2762274643U,      (u32 const   )1920112356U,      (u32 const   )3233831835U, 
        (u32 const   )3082273397U,      (u32 const   )4261223649U,      (u32 const   )2475929149U,      (u32 const   )640051788U, 
        (u32 const   )909531756U,      (u32 const   )1061110142U,      (u32 const   )4160160501U,      (u32 const   )3435941763U, 
        (u32 const   )875846760U,      (u32 const   )2779116625U,      (u32 const   )3857003729U,      (u32 const   )4059105529U, 
        (u32 const   )1903268834U,      (u32 const   )3638064043U,      (u32 const   )825316194U,      (u32 const   )353713962U, 
        (u32 const   )67374088U,      (u32 const   )3351728789U,      (u32 const   )589522246U,      (u32 const   )3284360861U, 
        (u32 const   )404236336U,      (u32 const   )2526454071U,      (u32 const   )84217610U,      (u32 const   )2593830191U, 
        (u32 const   )117901582U,      (u32 const   )303183396U,      (u32 const   )2155911963U,      (u32 const   )3806477791U, 
        (u32 const   )3958056653U,      (u32 const   )656894286U,      (u32 const   )2998062463U,      (u32 const   )1970642922U, 
        (u32 const   )151591698U,      (u32 const   )2206440989U,      (u32 const   )741110872U,      (u32 const   )437923380U, 
        (u32 const   )454765878U,      (u32 const   )1852748508U,      (u32 const   )1515908788U,      (u32 const   )2694904667U, 
        (u32 const   )1381168804U,      (u32 const   )993742198U,      (u32 const   )3604373943U,      (u32 const   )3014905469U, 
        (u32 const   )690584402U,      (u32 const   )3823320797U,      (u32 const   )791638366U,      (u32 const   )2223281939U, 
        (u32 const   )1398011302U,      (u32 const   )3520161977U,      (u32 const   )0U,      (u32 const   )3991743681U, 
        (u32 const   )538992704U,      (u32 const   )4244381667U,      (u32 const   )2981218425U,      (u32 const   )1532751286U, 
        (u32 const   )1785380564U,      (u32 const   )3419096717U,      (u32 const   )3200178535U,      (u32 const   )960056178U, 
        (u32 const   )1246420628U,      (u32 const   )1280103576U,      (u32 const   )1482221744U,      (u32 const   )3486468741U, 
        (u32 const   )3503319995U,      (u32 const   )4025428677U,      (u32 const   )2863326543U,      (u32 const   )4227536621U, 
        (u32 const   )1128514950U,      (u32 const   )1296947098U,      (u32 const   )859002214U,      (u32 const   )2240123921U, 
        (u32 const   )1162203018U,      (u32 const   )4193849577U,      (u32 const   )33687044U,      (u32 const   )2139062782U, 
        (u32 const   )1347481760U,      (u32 const   )1010582648U,      (u32 const   )2678045221U,      (u32 const   )2829640523U, 
        (u32 const   )1364325282U,      (u32 const   )2745433693U,      (u32 const   )1077985408U,      (u32 const   )2408548869U, 
        (u32 const   )2459086143U,      (u32 const   )2644360225U,      (u32 const   )943212656U,      (u32 const   )4126475505U, 
        (u32 const   )3166494563U,      (u32 const   )3065430391U,      (u32 const   )3671750063U,      (u32 const   )555836226U, 
        (u32 const   )269496352U,      (u32 const   )4294908645U,      (u32 const   )4092792573U,      (u32 const   )3537006015U, 
        (u32 const   )3452783745U,      (u32 const   )202118168U,      (u32 const   )320025894U,      (u32 const   )3974901699U, 
        (u32 const   )1600119230U,      (u32 const   )2543297077U,      (u32 const   )1145359496U,      (u32 const   )387397934U, 
        (u32 const   )3301201811U,      (u32 const   )2812801621U,      (u32 const   )2122220284U,      (u32 const   )1027426170U, 
        (u32 const   )1684319432U,      (u32 const   )1566435258U,      (u32 const   )421079858U,      (u32 const   )1936954854U, 
        (u32 const   )1616945344U,      (u32 const   )2172753945U,      (u32 const   )1330631070U,      (u32 const   )3705438115U, 
        (u32 const   )572679748U,      (u32 const   )707427924U,      (u32 const   )2425400123U,      (u32 const   )2290647819U, 
        (u32 const   )1179044492U,      (u32 const   )4008585671U,      (u32 const   )3099120491U,      (u32 const   )336870440U, 
        (u32 const   )3739122087U,      (u32 const   )1583276732U,      (u32 const   )185277718U,      (u32 const   )3688593069U, 
        (u32 const   )3772791771U,      (u32 const   )842159716U,      (u32 const   )976899700U,      (u32 const   )168435220U, 
        (u32 const   )1229577106U,      (u32 const   )101059084U,      (u32 const   )606366792U,      (u32 const   )1549591736U, 
        (u32 const   )3267517855U,      (u32 const   )3553849021U,      (u32 const   )2897014595U,      (u32 const   )1650632388U, 
        (u32 const   )2442242105U,      (u32 const   )2509612081U,      (u32 const   )3840161747U,      (u32 const   )2038008818U, 
        (u32 const   )3890688725U,      (u32 const   )3368567691U,      (u32 const   )926374254U,      (u32 const   )1835907034U, 
        (u32 const   )2374863873U,      (u32 const   )3587531953U,      (u32 const   )1313788572U,      (u32 const   )2846482505U, 
        (u32 const   )1819063512U,      (u32 const   )1448540844U,      (u32 const   )4109633523U,      (u32 const   )3941213647U, 
        (u32 const   )1701162954U,      (u32 const   )2054852340U,      (u32 const   )2930698567U,      (u32 const   )134748176U, 
        (u32 const   )3132806511U,      (u32 const   )2021165296U,      (u32 const   )623210314U,      (u32 const   )774795868U, 
        (u32 const   )471606328U,      (u32 const   )2795958615U,      (u32 const   )3031746419U,      (u32 const   )3334885783U, 
        (u32 const   )3907527627U,      (u32 const   )3722280097U,      (u32 const   )1953799400U,      (u32 const   )522133822U, 
        (u32 const   )1263263126U,      (u32 const   )3183336545U,      (u32 const   )2341176845U,      (u32 const   )2324333839U, 
        (u32 const   )1886425312U,      (u32 const   )1044267644U,      (u32 const   )3048588401U,      (u32 const   )1718004428U, 
        (u32 const   )1212733584U,      (u32 const   )50529542U,      (u32 const   )4143317495U,      (u32 const   )235803164U, 
        (u32 const   )1633788866U,      (u32 const   )892690282U,      (u32 const   )1465383342U,      (u32 const   )3115962473U, 
        (u32 const   )2256965911U,      (u32 const   )3250673817U,      (u32 const   )488449850U,      (u32 const   )2661202215U, 
        (u32 const   )3789633753U,      (u32 const   )4177007595U,      (u32 const   )2560144171U,      (u32 const   )286339874U, 
        (u32 const   )1768537042U,      (u32 const   )3654906025U,      (u32 const   )2391705863U,      (u32 const   )2492770099U, 
        (u32 const   )2610673197U,      (u32 const   )505291324U,      (u32 const   )2273808917U,      (u32 const   )3924369609U, 
        (u32 const   )3469625735U,      (u32 const   )1431699370U,      (u32 const   )673740880U,      (u32 const   )3755965093U, 
        (u32 const   )2358021891U,      (u32 const   )2711746649U,      (u32 const   )2307489801U,      (u32 const   )218961690U, 
        (u32 const   )3217021541U,      (u32 const   )3873845719U,      (u32 const   )1111672452U,      (u32 const   )1751693520U, 
        (u32 const   )1094828930U,      (u32 const   )2576986153U,      (u32 const   )757954394U,      (u32 const   )252645662U, 
        (u32 const   )2964376443U,      (u32 const   )1414855848U,      (u32 const   )3149649517U,      (u32 const   )370555436U};
#line 316 "rijndael.c"
static u32 const   Te4[256]  = 
#line 316
  {      (u32 const   )1667457891U,      (u32 const   )2088533116U,      (u32 const   )2004318071U,      (u32 const   )2071690107U, 
        (u32 const   )4076008178U,      (u32 const   )1802201963U,      (u32 const   )1869573999U,      (u32 const   )3318072773U, 
        (u32 const   )808464432U,      (u32 const   )16843009U,      (u32 const   )1734829927U,      (u32 const   )724249387U, 
        (u32 const   )4278124286U,      (u32 const   )3621246935U,      (u32 const   )2880154539U,      (u32 const   )1987475062U, 
        (u32 const   )3402287818U,      (u32 const   )2189591170U,      (u32 const   )3385444809U,      (u32 const   )2105376125U, 
        (u32 const   )4210752250U,      (u32 const   )1499027801U,      (u32 const   )1195853639U,      (u32 const   )4042322160U, 
        (u32 const   )2913840557U,      (u32 const   )3570717908U,      (u32 const   )2728567458U,      (u32 const   )2947526575U, 
        (u32 const   )2627509404U,      (u32 const   )2762253476U,      (u32 const   )1920103026U,      (u32 const   )3233857728U, 
        (u32 const   )3082270647U,      (u32 const   )4261281277U,      (u32 const   )2475922323U,      (u32 const   )640034342U, 
        (u32 const   )909522486U,      (u32 const   )1061109567U,      (u32 const   )4160223223U,      (u32 const   )3435973836U, 
        (u32 const   )875836468U,      (u32 const   )2779096485U,      (u32 const   )3857049061U,      (u32 const   )4059165169U, 
        (u32 const   )1903260017U,      (u32 const   )3638089944U,      (u32 const   )825307441U,      (u32 const   )353703189U, 
        (u32 const   )67372036U,      (u32 const   )3351758791U,      (u32 const   )589505315U,      (u32 const   )3284386755U, 
        (u32 const   )404232216U,      (u32 const   )2526451350U,      (u32 const   )84215045U,      (u32 const   )2593823386U, 
        (u32 const   )117901063U,      (u32 const   )303174162U,      (u32 const   )2155905152U,      (u32 const   )3806520034U, 
        (u32 const   )3958107115U,      (u32 const   )656877351U,      (u32 const   )2998055602U,      (u32 const   )1970632053U, 
        (u32 const   )151587081U,      (u32 const   )2206434179U,      (u32 const   )741092396U,      (u32 const   )437918234U, 
        (u32 const   )454761243U,      (u32 const   )1852730990U,      (u32 const   )1515870810U,      (u32 const   )2694881440U, 
        (u32 const   )1381126738U,      (u32 const   )993737531U,      (u32 const   )3604403926U,      (u32 const   )3014898611U, 
        (u32 const   )690563369U,      (u32 const   )3823363043U,      (u32 const   )791621423U,      (u32 const   )2223277188U, 
        (u32 const   )1397969747U,      (u32 const   )3520188881U,      (u32 const   )0U,      (u32 const   )3991793133U, 
        (u32 const   )538976288U,      (u32 const   )4244438268U,      (u32 const   )2981212593U,      (u32 const   )1532713819U, 
        (u32 const   )1785358954U,      (u32 const   )3419130827U,      (u32 const   )3200171710U,      (u32 const   )960051513U, 
        (u32 const   )1246382666U,      (u32 const   )1280068684U,      (u32 const   )1482184792U,      (u32 const   )3486502863U, 
        (u32 const   )3503345872U,      (u32 const   )4025479151U,      (u32 const   )2863311530U,      (u32 const   )4227595259U, 
        (u32 const   )1128481603U,      (u32 const   )1296911693U,      (u32 const   )858993459U,      (u32 const   )2240120197U, 
        (u32 const   )1162167621U,      (u32 const   )4193909241U,      (u32 const   )33686018U,      (u32 const   )2139062143U, 
        (u32 const   )1347440720U,      (u32 const   )1010580540U,      (u32 const   )2678038431U,      (u32 const   )2829625512U, 
        (u32 const   )1364283729U,      (u32 const   )2745410467U,      (u32 const   )1077952576U,      (u32 const   )2408550287U, 
        (u32 const   )2459079314U,      (u32 const   )2644352413U,      (u32 const   )943208504U,      (u32 const   )4126537205U, 
        (u32 const   )3166485692U,      (u32 const   )3065427638U,      (u32 const   )3671775962U,      (u32 const   )555819297U, 
        (u32 const   )269488144U,      (u32 const   )4294967295U,      (u32 const   )4092851187U,      (u32 const   )3537031890U, 
        (u32 const   )3452816845U,      (u32 const   )202116108U,      (u32 const   )320017171U,      (u32 const   )3974950124U, 
        (u32 const   )1600085855U,      (u32 const   )2543294359U,      (u32 const   )1145324612U,      (u32 const   )387389207U, 
        (u32 const   )3301229764U,      (u32 const   )2812782503U,      (u32 const   )2122219134U,      (u32 const   )1027423549U, 
        (u32 const   )1684300900U,      (u32 const   )1566399837U,      (u32 const   )421075225U,      (u32 const   )1936946035U, 
        (u32 const   )1616928864U,      (u32 const   )2172748161U,      (u32 const   )1330597711U,      (u32 const   )3705461980U, 
        (u32 const   )572662306U,      (u32 const   )707406378U,      (u32 const   )2425393296U,      (u32 const   )2290649224U, 
        (u32 const   )1179010630U,      (u32 const   )4008636142U,      (u32 const   )3099113656U,      (u32 const   )336860180U, 
        (u32 const   )3739147998U,      (u32 const   )1583242846U,      (u32 const   )185273099U,      (u32 const   )3688618971U, 
        (u32 const   )3772834016U,      (u32 const   )842150450U,      (u32 const   )976894522U,      (u32 const   )168430090U, 
        (u32 const   )1229539657U,      (u32 const   )101058054U,      (u32 const   )606348324U,      (u32 const   )1549556828U, 
        (u32 const   )3267543746U,      (u32 const   )3553874899U,      (u32 const   )2896997548U,      (u32 const   )1650614882U, 
        (u32 const   )2442236305U,      (u32 const   )2509608341U,      (u32 const   )3840206052U,      (u32 const   )2038004089U, 
        (u32 const   )3890735079U,      (u32 const   )3368601800U,      (u32 const   )926365495U,      (u32 const   )1835887981U, 
        (u32 const   )2374864269U,      (u32 const   )3587560917U,      (u32 const   )1313754702U,      (u32 const   )2846468521U, 
        (u32 const   )1819044972U,      (u32 const   )1448498774U,      (u32 const   )4109694196U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )2054847098U,      (u32 const   )2930683566U,      (u32 const   )134744072U, 
        (u32 const   )3132799674U,      (u32 const   )2021161080U,      (u32 const   )623191333U,      (u32 const   )774778414U, 
        (u32 const   )471604252U,      (u32 const   )2795939494U,      (u32 const   )3031741620U,      (u32 const   )3334915782U, 
        (u32 const   )3907578088U,      (u32 const   )3722304989U,      (u32 const   )1953789044U,      (u32 const   )522133279U, 
        (u32 const   )1263225675U,      (u32 const   )3183328701U,      (u32 const   )2341178251U,      (u32 const   )2324335242U, 
        (u32 const   )1886417008U,      (u32 const   )1044266558U,      (u32 const   )3048584629U,      (u32 const   )1717986918U, 
        (u32 const   )1212696648U,      (u32 const   )50529027U,      (u32 const   )4143380214U,      (u32 const   )235802126U, 
        (u32 const   )1633771873U,      (u32 const   )892679477U,      (u32 const   )1465341783U,      (u32 const   )3115956665U, 
        (u32 const   )2256963206U,      (u32 const   )3250700737U,      (u32 const   )488447261U,      (u32 const   )2661195422U, 
        (u32 const   )3789677025U,      (u32 const   )4177066232U,      (u32 const   )2560137368U,      (u32 const   )286331153U, 
        (u32 const   )1768515945U,      (u32 const   )3654932953U,      (u32 const   )2391707278U,      (u32 const   )2492765332U, 
        (u32 const   )2610666395U,      (u32 const   )505290270U,      (u32 const   )2273806215U,      (u32 const   )3924421097U, 
        (u32 const   )3469659854U,      (u32 const   )1431655765U,      (u32 const   )673720360U,      (u32 const   )3755991007U, 
        (u32 const   )2358021260U,      (u32 const   )2711724449U,      (u32 const   )2307492233U,      (u32 const   )218959117U, 
        (u32 const   )3217014719U,      (u32 const   )3873892070U,      (u32 const   )1111638594U,      (u32 const   )1751672936U, 
        (u32 const   )1094795585U,      (u32 const   )2576980377U,      (u32 const   )757935405U,      (u32 const   )252645135U, 
        (u32 const   )2964369584U,      (u32 const   )1414812756U,      (u32 const   )3149642683U,      (u32 const   )370546198U};
#line 382 "rijndael.c"
static u32 const   Td0[256]  = 
#line 382
  {      (u32 const   )1374988112U,      (u32 const   )2118214995U,      (u32 const   )437757123U,      (u32 const   )975658646U, 
        (u32 const   )1001089995U,      (u32 const   )530400753U,      (u32 const   )2902087851U,      (u32 const   )1273168787U, 
        (u32 const   )540080725U,      (u32 const   )2910219766U,      (u32 const   )2295101073U,      (u32 const   )4110568485U, 
        (u32 const   )1340463100U,      (u32 const   )3307916247U,      (u32 const   )641025152U,      (u32 const   )3043140495U, 
        (u32 const   )3736164937U,      (u32 const   )632953703U,      (u32 const   )1172967064U,      (u32 const   )1576976609U, 
        (u32 const   )3274667266U,      (u32 const   )2169303058U,      (u32 const   )2370213795U,      (u32 const   )1809054150U, 
        (u32 const   )59727847U,      (u32 const   )361929877U,      (u32 const   )3211623147U,      (u32 const   )2505202138U, 
        (u32 const   )3569255213U,      (u32 const   )1484005843U,      (u32 const   )1239443753U,      (u32 const   )2395588676U, 
        (u32 const   )1975683434U,      (u32 const   )4102977912U,      (u32 const   )2572697195U,      (u32 const   )666464733U, 
        (u32 const   )3202437046U,      (u32 const   )4035489047U,      (u32 const   )3374361702U,      (u32 const   )2110667444U, 
        (u32 const   )1675577880U,      (u32 const   )3843699074U,      (u32 const   )2538681184U,      (u32 const   )1649639237U, 
        (u32 const   )2976151520U,      (u32 const   )3144396420U,      (u32 const   )4269907996U,      (u32 const   )4178062228U, 
        (u32 const   )1883793496U,      (u32 const   )2403728665U,      (u32 const   )2497604743U,      (u32 const   )1383856311U, 
        (u32 const   )2876494627U,      (u32 const   )1917518562U,      (u32 const   )3810496343U,      (u32 const   )1716890410U, 
        (u32 const   )3001755655U,      (u32 const   )800440835U,      (u32 const   )2261089178U,      (u32 const   )3543599269U, 
        (u32 const   )807962610U,      (u32 const   )599762354U,      (u32 const   )33778362U,      (u32 const   )3977675356U, 
        (u32 const   )2328828971U,      (u32 const   )2809771154U,      (u32 const   )4077384432U,      (u32 const   )1315562145U, 
        (u32 const   )1708848333U,      (u32 const   )101039829U,      (u32 const   )3509871135U,      (u32 const   )3299278474U, 
        (u32 const   )875451293U,      (u32 const   )2733856160U,      (u32 const   )92987698U,      (u32 const   )2767645557U, 
        (u32 const   )193195065U,      (u32 const   )1080094634U,      (u32 const   )1584504582U,      (u32 const   )3178106961U, 
        (u32 const   )1042385657U,      (u32 const   )2531067453U,      (u32 const   )3711829422U,      (u32 const   )1306967366U, 
        (u32 const   )2438237621U,      (u32 const   )1908694277U,      (u32 const   )67556463U,      (u32 const   )1615861247U, 
        (u32 const   )429456164U,      (u32 const   )3602770327U,      (u32 const   )2302690252U,      (u32 const   )1742315127U, 
        (u32 const   )2968011453U,      (u32 const   )126454664U,      (u32 const   )3877198648U,      (u32 const   )2043211483U, 
        (u32 const   )2709260871U,      (u32 const   )2084704233U,      (u32 const   )4169408201U,      (u32 const   )0U, 
        (u32 const   )159417987U,      (u32 const   )841739592U,      (u32 const   )504459436U,      (u32 const   )1817866830U, 
        (u32 const   )4245618683U,      (u32 const   )260388950U,      (u32 const   )1034867998U,      (u32 const   )908933415U, 
        (u32 const   )168810852U,      (u32 const   )1750902305U,      (u32 const   )2606453969U,      (u32 const   )607530554U, 
        (u32 const   )202008497U,      (u32 const   )2472011535U,      (u32 const   )3035535058U,      (u32 const   )463180190U, 
        (u32 const   )2160117071U,      (u32 const   )1641816226U,      (u32 const   )1517767529U,      (u32 const   )470948374U, 
        (u32 const   )3801332234U,      (u32 const   )3231722213U,      (u32 const   )1008918595U,      (u32 const   )303765277U, 
        (u32 const   )235474187U,      (u32 const   )4069246893U,      (u32 const   )766945465U,      (u32 const   )337553864U, 
        (u32 const   )1475418501U,      (u32 const   )2943682380U,      (u32 const   )4003061179U,      (u32 const   )2743034109U, 
        (u32 const   )4144047775U,      (u32 const   )1551037884U,      (u32 const   )1147550661U,      (u32 const   )1543208500U, 
        (u32 const   )2336434550U,      (u32 const   )3408119516U,      (u32 const   )3069049960U,      (u32 const   )3102011747U, 
        (u32 const   )3610369226U,      (u32 const   )1113818384U,      (u32 const   )328671808U,      (u32 const   )2227573024U, 
        (u32 const   )2236228733U,      (u32 const   )3535486456U,      (u32 const   )2935566865U,      (u32 const   )3341394285U, 
        (u32 const   )496906059U,      (u32 const   )3702665459U,      (u32 const   )226906860U,      (u32 const   )2009195472U, 
        (u32 const   )733156972U,      (u32 const   )2842737049U,      (u32 const   )294930682U,      (u32 const   )1206477858U, 
        (u32 const   )2835123396U,      (u32 const   )2700099354U,      (u32 const   )1451044056U,      (u32 const   )573804783U, 
        (u32 const   )2269728455U,      (u32 const   )3644379585U,      (u32 const   )2362090238U,      (u32 const   )2564033334U, 
        (u32 const   )2801107407U,      (u32 const   )2776292904U,      (u32 const   )3669462566U,      (u32 const   )1068351396U, 
        (u32 const   )742039012U,      (u32 const   )1350078989U,      (u32 const   )1784663195U,      (u32 const   )1417561698U, 
        (u32 const   )4136440770U,      (u32 const   )2430122216U,      (u32 const   )775550814U,      (u32 const   )2193862645U, 
        (u32 const   )2673705150U,      (u32 const   )1775276924U,      (u32 const   )1876241833U,      (u32 const   )3475313331U, 
        (u32 const   )3366754619U,      (u32 const   )270040487U,      (u32 const   )3902563182U,      (u32 const   )3678124923U, 
        (u32 const   )3441850377U,      (u32 const   )1851332852U,      (u32 const   )3969562369U,      (u32 const   )2203032232U, 
        (u32 const   )3868552805U,      (u32 const   )2868897406U,      (u32 const   )566021896U,      (u32 const   )4011190502U, 
        (u32 const   )3135740889U,      (u32 const   )1248802510U,      (u32 const   )3936291284U,      (u32 const   )699432150U, 
        (u32 const   )832877231U,      (u32 const   )708780849U,      (u32 const   )3332740144U,      (u32 const   )899835584U, 
        (u32 const   )1951317047U,      (u32 const   )4236429990U,      (u32 const   )3767586992U,      (u32 const   )866637845U, 
        (u32 const   )4043610186U,      (u32 const   )1106041591U,      (u32 const   )2144161806U,      (u32 const   )395441711U, 
        (u32 const   )1984812685U,      (u32 const   )1139781709U,      (u32 const   )3433712980U,      (u32 const   )3835036895U, 
        (u32 const   )2664543715U,      (u32 const   )1282050075U,      (u32 const   )3240894392U,      (u32 const   )1181045119U, 
        (u32 const   )2640243204U,      (u32 const   )25965917U,      (u32 const   )4203181171U,      (u32 const   )4211818798U, 
        (u32 const   )3009879386U,      (u32 const   )2463879762U,      (u32 const   )3910161971U,      (u32 const   )1842759443U, 
        (u32 const   )2597806476U,      (u32 const   )933301370U,      (u32 const   )1509430414U,      (u32 const   )3943906441U, 
        (u32 const   )3467192302U,      (u32 const   )3076639029U,      (u32 const   )3776767469U,      (u32 const   )2051518780U, 
        (u32 const   )2631065433U,      (u32 const   )1441952575U,      (u32 const   )404016761U,      (u32 const   )1942435775U, 
        (u32 const   )1408749034U,      (u32 const   )1610459739U,      (u32 const   )3745345300U,      (u32 const   )2017778566U, 
        (u32 const   )3400528769U,      (u32 const   )3110650942U,      (u32 const   )941896748U,      (u32 const   )3265478751U, 
        (u32 const   )371049330U,      (u32 const   )3168937228U,      (u32 const   )675039627U,      (u32 const   )4279080257U, 
        (u32 const   )967311729U,      (u32 const   )135050206U,      (u32 const   )3635733660U,      (u32 const   )1683407248U, 
        (u32 const   )2076935265U,      (u32 const   )3576870512U,      (u32 const   )1215061108U,      (u32 const   )3501741890U};
#line 448 "rijndael.c"
static u32 const   Td1[256]  = 
#line 448
  {      (u32 const   )1347548327U,      (u32 const   )1400783205U,      (u32 const   )3273267108U,      (u32 const   )2520393566U, 
        (u32 const   )3409685355U,      (u32 const   )4045380933U,      (u32 const   )2880240216U,      (u32 const   )2471224067U, 
        (u32 const   )1428173050U,      (u32 const   )4138563181U,      (u32 const   )2441661558U,      (u32 const   )636813900U, 
        (u32 const   )4233094615U,      (u32 const   )3620022987U,      (u32 const   )2149987652U,      (u32 const   )2411029155U, 
        (u32 const   )1239331162U,      (u32 const   )1730525723U,      (u32 const   )2554718734U,      (u32 const   )3781033664U, 
        (u32 const   )46346101U,      (u32 const   )310463728U,      (u32 const   )2743944855U,      (u32 const   )3328955385U, 
        (u32 const   )3875770207U,      (u32 const   )2501218972U,      (u32 const   )3955191162U,      (u32 const   )3667219033U, 
        (u32 const   )768917123U,      (u32 const   )3545789473U,      (u32 const   )692707433U,      (u32 const   )1150208456U, 
        (u32 const   )1786102409U,      (u32 const   )2029293177U,      (u32 const   )1805211710U,      (u32 const   )3710368113U, 
        (u32 const   )3065962831U,      (u32 const   )401639597U,      (u32 const   )1724457132U,      (u32 const   )3028143674U, 
        (u32 const   )409198410U,      (u32 const   )2196052529U,      (u32 const   )1620529459U,      (u32 const   )1164071807U, 
        (u32 const   )3769721975U,      (u32 const   )2226875310U,      (u32 const   )486441376U,      (u32 const   )2499348523U, 
        (u32 const   )1483753576U,      (u32 const   )428819965U,      (u32 const   )2274680428U,      (u32 const   )3075636216U, 
        (u32 const   )598438867U,      (u32 const   )3799141122U,      (u32 const   )1474502543U,      (u32 const   )711349675U, 
        (u32 const   )129166120U,      (u32 const   )53458370U,      (u32 const   )2592523643U,      (u32 const   )2782082824U, 
        (u32 const   )4063242375U,      (u32 const   )2988687269U,      (u32 const   )3120694122U,      (u32 const   )1559041666U, 
        (u32 const   )730517276U,      (u32 const   )2460449204U,      (u32 const   )4042459122U,      (u32 const   )2706270690U, 
        (u32 const   )3446004468U,      (u32 const   )3573941694U,      (u32 const   )533804130U,      (u32 const   )2328143614U, 
        (u32 const   )2637442643U,      (u32 const   )2695033685U,      (u32 const   )839224033U,      (u32 const   )1973745387U, 
        (u32 const   )957055980U,      (u32 const   )2856345839U,      (u32 const   )106852767U,      (u32 const   )1371368976U, 
        (u32 const   )4181598602U,      (u32 const   )1033297158U,      (u32 const   )2933734917U,      (u32 const   )1179510461U, 
        (u32 const   )3046200461U,      (u32 const   )91341917U,      (u32 const   )1862534868U,      (u32 const   )4284502037U, 
        (u32 const   )605657339U,      (u32 const   )2547432937U,      (u32 const   )3431546947U,      (u32 const   )2003294622U, 
        (u32 const   )3182487618U,      (u32 const   )2282195339U,      (u32 const   )954669403U,      (u32 const   )3682191598U, 
        (u32 const   )1201765386U,      (u32 const   )3917234703U,      (u32 const   )3388507166U,      (u32 const   )0U, 
        (u32 const   )2198438022U,      (u32 const   )1211247597U,      (u32 const   )2887651696U,      (u32 const   )1315723890U, 
        (u32 const   )4227665663U,      (u32 const   )1443857720U,      (u32 const   )507358933U,      (u32 const   )657861945U, 
        (u32 const   )1678381017U,      (u32 const   )560487590U,      (u32 const   )3516619604U,      (u32 const   )975451694U, 
        (u32 const   )2970356327U,      (u32 const   )261314535U,      (u32 const   )3535072918U,      (u32 const   )2652609425U, 
        (u32 const   )1333838021U,      (u32 const   )2724322336U,      (u32 const   )1767536459U,      (u32 const   )370938394U, 
        (u32 const   )182621114U,      (u32 const   )3854606378U,      (u32 const   )1128014560U,      (u32 const   )487725847U, 
        (u32 const   )185469197U,      (u32 const   )2918353863U,      (u32 const   )3106780840U,      (u32 const   )3356761769U, 
        (u32 const   )2237133081U,      (u32 const   )1286567175U,      (u32 const   )3152976349U,      (u32 const   )4255350624U, 
        (u32 const   )2683765030U,      (u32 const   )3160175349U,      (u32 const   )3309594171U,      (u32 const   )878443390U, 
        (u32 const   )1988838185U,      (u32 const   )3704300486U,      (u32 const   )1756818940U,      (u32 const   )1673061617U, 
        (u32 const   )3403100636U,      (u32 const   )272786309U,      (u32 const   )1075025698U,      (u32 const   )545572369U, 
        (u32 const   )2105887268U,      (u32 const   )4174560061U,      (u32 const   )296679730U,      (u32 const   )1841768865U, 
        (u32 const   )1260232239U,      (u32 const   )4091327024U,      (u32 const   )3960309330U,      (u32 const   )3497509347U, 
        (u32 const   )1814803222U,      (u32 const   )2578018489U,      (u32 const   )4195456072U,      (u32 const   )575138148U, 
        (u32 const   )3299409036U,      (u32 const   )446754879U,      (u32 const   )3629546796U,      (u32 const   )4011996048U, 
        (u32 const   )3347532110U,      (u32 const   )3252238545U,      (u32 const   )4270639778U,      (u32 const   )915985419U, 
        (u32 const   )3483825537U,      (u32 const   )681933534U,      (u32 const   )651868046U,      (u32 const   )2755636671U, 
        (u32 const   )3828103837U,      (u32 const   )223377554U,      (u32 const   )2607439820U,      (u32 const   )1649704518U, 
        (u32 const   )3270937875U,      (u32 const   )3901806776U,      (u32 const   )1580087799U,      (u32 const   )4118987695U, 
        (u32 const   )3198115200U,      (u32 const   )2087309459U,      (u32 const   )2842678573U,      (u32 const   )3016697106U, 
        (u32 const   )1003007129U,      (u32 const   )2802849917U,      (u32 const   )1860738147U,      (u32 const   )2077965243U, 
        (u32 const   )164439672U,      (u32 const   )4100872472U,      (u32 const   )32283319U,      (u32 const   )2827177882U, 
        (u32 const   )1709610350U,      (u32 const   )2125135846U,      (u32 const   )136428751U,      (u32 const   )3874428392U, 
        (u32 const   )3652904859U,      (u32 const   )3460984630U,      (u32 const   )3572145929U,      (u32 const   )3593056380U, 
        (u32 const   )2939266226U,      (u32 const   )824852259U,      (u32 const   )818324884U,      (u32 const   )3224740454U, 
        (u32 const   )930369212U,      (u32 const   )2801566410U,      (u32 const   )2967507152U,      (u32 const   )355706840U, 
        (u32 const   )1257309336U,      (u32 const   )4148292826U,      (u32 const   )243256656U,      (u32 const   )790073846U, 
        (u32 const   )2373340630U,      (u32 const   )1296297904U,      (u32 const   )1422699085U,      (u32 const   )3756299780U, 
        (u32 const   )3818836405U,      (u32 const   )457992840U,      (u32 const   )3099667487U,      (u32 const   )2135319889U, 
        (u32 const   )77422314U,      (u32 const   )1560382517U,      (u32 const   )1945798516U,      (u32 const   )788204353U, 
        (u32 const   )1521706781U,      (u32 const   )1385356242U,      (u32 const   )870912086U,      (u32 const   )325965383U, 
        (u32 const   )2358957921U,      (u32 const   )2050466060U,      (u32 const   )2388260884U,      (u32 const   )2313884476U, 
        (u32 const   )4006521127U,      (u32 const   )901210569U,      (u32 const   )3990953189U,      (u32 const   )1014646705U, 
        (u32 const   )1503449823U,      (u32 const   )1062597235U,      (u32 const   )2031621326U,      (u32 const   )3212035895U, 
        (u32 const   )3931371469U,      (u32 const   )1533017514U,      (u32 const   )350174575U,      (u32 const   )2256028891U, 
        (u32 const   )2177544179U,      (u32 const   )1052338372U,      (u32 const   )741876788U,      (u32 const   )1606591296U, 
        (u32 const   )1914052035U,      (u32 const   )213705253U,      (u32 const   )2334669897U,      (u32 const   )1107234197U, 
        (u32 const   )1899603969U,      (u32 const   )3725069491U,      (u32 const   )2631447780U,      (u32 const   )2422494913U, 
        (u32 const   )1635502980U,      (u32 const   )1893020342U,      (u32 const   )1950903388U,      (u32 const   )1120974935U};
#line 514 "rijndael.c"
static u32 const   Td2[256]  = 
#line 514
  {      (u32 const   )2807058932U,      (u32 const   )1699970625U,      (u32 const   )2764249623U,      (u32 const   )1586903591U, 
        (u32 const   )1808481195U,      (u32 const   )1173430173U,      (u32 const   )1487645946U,      (u32 const   )59984867U, 
        (u32 const   )4199882800U,      (u32 const   )1844882806U,      (u32 const   )1989249228U,      (u32 const   )1277555970U, 
        (u32 const   )3623636965U,      (u32 const   )3419915562U,      (u32 const   )1149249077U,      (u32 const   )2744104290U, 
        (u32 const   )1514790577U,      (u32 const   )459744698U,      (u32 const   )244860394U,      (u32 const   )3235995134U, 
        (u32 const   )1963115311U,      (u32 const   )4027744588U,      (u32 const   )2544078150U,      (u32 const   )4190530515U, 
        (u32 const   )1608975247U,      (u32 const   )2627016082U,      (u32 const   )2062270317U,      (u32 const   )1507497298U, 
        (u32 const   )2200818878U,      (u32 const   )567498868U,      (u32 const   )1764313568U,      (u32 const   )3359936201U, 
        (u32 const   )2305455554U,      (u32 const   )2037970062U,      (u32 const   )1047239000U,      (u32 const   )1910319033U, 
        (u32 const   )1337376481U,      (u32 const   )2904027272U,      (u32 const   )2892417312U,      (u32 const   )984907214U, 
        (u32 const   )1243112415U,      (u32 const   )830661914U,      (u32 const   )861968209U,      (u32 const   )2135253587U, 
        (u32 const   )2011214180U,      (u32 const   )2927934315U,      (u32 const   )2686254721U,      (u32 const   )731183368U, 
        (u32 const   )1750626376U,      (u32 const   )4246310725U,      (u32 const   )1820824798U,      (u32 const   )4172763771U, 
        (u32 const   )3542330227U,      (u32 const   )48394827U,      (u32 const   )2404901663U,      (u32 const   )2871682645U, 
        (u32 const   )671593195U,      (u32 const   )3254988725U,      (u32 const   )2073724613U,      (u32 const   )145085239U, 
        (u32 const   )2280796200U,      (u32 const   )2779915199U,      (u32 const   )1790575107U,      (u32 const   )2187128086U, 
        (u32 const   )472615631U,      (u32 const   )3029510009U,      (u32 const   )4075877127U,      (u32 const   )3802222185U, 
        (u32 const   )4107101658U,      (u32 const   )3201631749U,      (u32 const   )1646252340U,      (u32 const   )4270507174U, 
        (u32 const   )1402811438U,      (u32 const   )1436590835U,      (u32 const   )3778151818U,      (u32 const   )3950355702U, 
        (u32 const   )3963161475U,      (u32 const   )4020912224U,      (u32 const   )2667994737U,      (u32 const   )273792366U, 
        (u32 const   )2331590177U,      (u32 const   )104699613U,      (u32 const   )95345982U,      (u32 const   )3175501286U, 
        (u32 const   )2377486676U,      (u32 const   )1560637892U,      (u32 const   )3564045318U,      (u32 const   )369057872U, 
        (u32 const   )4213447064U,      (u32 const   )3919042237U,      (u32 const   )1137477952U,      (u32 const   )2658625497U, 
        (u32 const   )1119727848U,      (u32 const   )2340947849U,      (u32 const   )1530455833U,      (u32 const   )4007360968U, 
        (u32 const   )172466556U,      (u32 const   )266959938U,      (u32 const   )516552836U,      (u32 const   )0U, 
        (u32 const   )2256734592U,      (u32 const   )3980931627U,      (u32 const   )1890328081U,      (u32 const   )1917742170U, 
        (u32 const   )4294704398U,      (u32 const   )945164165U,      (u32 const   )3575528878U,      (u32 const   )958871085U, 
        (u32 const   )3647212047U,      (u32 const   )2787207260U,      (u32 const   )1423022939U,      (u32 const   )775562294U, 
        (u32 const   )1739656202U,      (u32 const   )3876557655U,      (u32 const   )2530391278U,      (u32 const   )2443058075U, 
        (u32 const   )3310321856U,      (u32 const   )547512796U,      (u32 const   )1265195639U,      (u32 const   )437656594U, 
        (u32 const   )3121275539U,      (u32 const   )719700128U,      (u32 const   )3762502690U,      (u32 const   )387781147U, 
        (u32 const   )218828297U,      (u32 const   )3350065803U,      (u32 const   )2830708150U,      (u32 const   )2848461854U, 
        (u32 const   )428169201U,      (u32 const   )122466165U,      (u32 const   )3720081049U,      (u32 const   )1627235199U, 
        (u32 const   )648017665U,      (u32 const   )4122762354U,      (u32 const   )1002783846U,      (u32 const   )2117360635U, 
        (u32 const   )695634755U,      (u32 const   )3336358691U,      (u32 const   )4234721005U,      (u32 const   )4049844452U, 
        (u32 const   )3704280881U,      (u32 const   )2232435299U,      (u32 const   )574624663U,      (u32 const   )287343814U, 
        (u32 const   )612205898U,      (u32 const   )1039717051U,      (u32 const   )840019705U,      (u32 const   )2708326185U, 
        (u32 const   )793451934U,      (u32 const   )821288114U,      (u32 const   )1391201670U,      (u32 const   )3822090177U, 
        (u32 const   )376187827U,      (u32 const   )3113855344U,      (u32 const   )1224348052U,      (u32 const   )1679968233U, 
        (u32 const   )2361698556U,      (u32 const   )1058709744U,      (u32 const   )752375421U,      (u32 const   )2431590963U, 
        (u32 const   )1321699145U,      (u32 const   )3519142200U,      (u32 const   )2734591178U,      (u32 const   )188127444U, 
        (u32 const   )2177869557U,      (u32 const   )3727205754U,      (u32 const   )2384911031U,      (u32 const   )3215212461U, 
        (u32 const   )2648976442U,      (u32 const   )2450346104U,      (u32 const   )3432737375U,      (u32 const   )1180849278U, 
        (u32 const   )331544205U,      (u32 const   )3102249176U,      (u32 const   )4150144569U,      (u32 const   )2952102595U, 
        (u32 const   )2159976285U,      (u32 const   )2474404304U,      (u32 const   )766078933U,      (u32 const   )313773861U, 
        (u32 const   )2570832044U,      (u32 const   )2108100632U,      (u32 const   )1668212892U,      (u32 const   )3145456443U, 
        (u32 const   )2013908262U,      (u32 const   )418672217U,      (u32 const   )3070356634U,      (u32 const   )2594734927U, 
        (u32 const   )1852171925U,      (u32 const   )3867060991U,      (u32 const   )3473416636U,      (u32 const   )3907448597U, 
        (u32 const   )2614737639U,      (u32 const   )919489135U,      (u32 const   )164948639U,      (u32 const   )2094410160U, 
        (u32 const   )2997825956U,      (u32 const   )590424639U,      (u32 const   )2486224549U,      (u32 const   )1723872674U, 
        (u32 const   )3157750862U,      (u32 const   )3399941250U,      (u32 const   )3501252752U,      (u32 const   )3625268135U, 
        (u32 const   )2555048196U,      (u32 const   )3673637356U,      (u32 const   )1343127501U,      (u32 const   )4130281361U, 
        (u32 const   )3599595085U,      (u32 const   )2957853679U,      (u32 const   )1297403050U,      (u32 const   )81781910U, 
        (u32 const   )3051593425U,      (u32 const   )2283490410U,      (u32 const   )532201772U,      (u32 const   )1367295589U, 
        (u32 const   )3926170974U,      (u32 const   )895287692U,      (u32 const   )1953757831U,      (u32 const   )1093597963U, 
        (u32 const   )492483431U,      (u32 const   )3528626907U,      (u32 const   )1446242576U,      (u32 const   )1192455638U, 
        (u32 const   )1636604631U,      (u32 const   )209336225U,      (u32 const   )344873464U,      (u32 const   )1015671571U, 
        (u32 const   )669961897U,      (u32 const   )3375740769U,      (u32 const   )3857572124U,      (u32 const   )2973530695U, 
        (u32 const   )3747192018U,      (u32 const   )1933530610U,      (u32 const   )3464042516U,      (u32 const   )935293895U, 
        (u32 const   )3454686199U,      (u32 const   )2858115069U,      (u32 const   )1863638845U,      (u32 const   )3683022916U, 
        (u32 const   )4085369519U,      (u32 const   )3292445032U,      (u32 const   )875313188U,      (u32 const   )1080017571U, 
        (u32 const   )3279033885U,      (u32 const   )621591778U,      (u32 const   )1233856572U,      (u32 const   )2504130317U, 
        (u32 const   )24197544U,      (u32 const   )3017672716U,      (u32 const   )3835484340U,      (u32 const   )3247465558U, 
        (u32 const   )2220981195U,      (u32 const   )3060847922U,      (u32 const   )1551124588U,      (u32 const   )1463996600U};
#line 581 "rijndael.c"
static u32 const   Td3[256]  = 
#line 581
  {      (u32 const   )4104605777U,      (u32 const   )1097159550U,      (u32 const   )396673818U,      (u32 const   )660510266U, 
        (u32 const   )2875968315U,      (u32 const   )2638606623U,      (u32 const   )4200115116U,      (u32 const   )3808662347U, 
        (u32 const   )821712160U,      (u32 const   )1986918061U,      (u32 const   )3430322568U,      (u32 const   )38544885U, 
        (u32 const   )3856137295U,      (u32 const   )718002117U,      (u32 const   )893681702U,      (u32 const   )1654886325U, 
        (u32 const   )2975484382U,      (u32 const   )3122358053U,      (u32 const   )3926825029U,      (u32 const   )4274053469U, 
        (u32 const   )796197571U,      (u32 const   )1290801793U,      (u32 const   )1184342925U,      (u32 const   )3556361835U, 
        (u32 const   )2405426947U,      (u32 const   )2459735317U,      (u32 const   )1836772287U,      (u32 const   )1381620373U, 
        (u32 const   )3196267988U,      (u32 const   )1948373848U,      (u32 const   )3764988233U,      (u32 const   )3385345166U, 
        (u32 const   )3263785589U,      (u32 const   )2390325492U,      (u32 const   )1480485785U,      (u32 const   )3111247143U, 
        (u32 const   )3780097726U,      (u32 const   )2293045232U,      (u32 const   )548169417U,      (u32 const   )3459953789U, 
        (u32 const   )3746175075U,      (u32 const   )439452389U,      (u32 const   )1362321559U,      (u32 const   )1400849762U, 
        (u32 const   )1685577905U,      (u32 const   )1806599355U,      (u32 const   )2174754046U,      (u32 const   )137073913U, 
        (u32 const   )1214797936U,      (u32 const   )1174215055U,      (u32 const   )3731654548U,      (u32 const   )2079897426U, 
        (u32 const   )1943217067U,      (u32 const   )1258480242U,      (u32 const   )529487843U,      (u32 const   )1437280870U, 
        (u32 const   )3945269170U,      (u32 const   )3049390895U,      (u32 const   )3313212038U,      (u32 const   )923313619U, 
        (u32 const   )679998000U,      (u32 const   )3215307299U,      (u32 const   )57326082U,      (u32 const   )377642221U, 
        (u32 const   )3474729866U,      (u32 const   )2041877159U,      (u32 const   )133361907U,      (u32 const   )1776460110U, 
        (u32 const   )3673476453U,      (u32 const   )96392454U,      (u32 const   )878845905U,      (u32 const   )2801699524U, 
        (u32 const   )777231668U,      (u32 const   )4082475170U,      (u32 const   )2330014213U,      (u32 const   )4142626212U, 
        (u32 const   )2213296395U,      (u32 const   )1626319424U,      (u32 const   )1906247262U,      (u32 const   )1846563261U, 
        (u32 const   )562755902U,      (u32 const   )3708173718U,      (u32 const   )1040559837U,      (u32 const   )3871163981U, 
        (u32 const   )1418573201U,      (u32 const   )3294430577U,      (u32 const   )114585348U,      (u32 const   )1343618912U, 
        (u32 const   )2566595609U,      (u32 const   )3186202582U,      (u32 const   )1078185097U,      (u32 const   )3651041127U, 
        (u32 const   )3896688048U,      (u32 const   )2307622919U,      (u32 const   )425408743U,      (u32 const   )3371096953U, 
        (u32 const   )2081048481U,      (u32 const   )1108339068U,      (u32 const   )2216610296U,      (u32 const   )0U, 
        (u32 const   )2156299017U,      (u32 const   )736970802U,      (u32 const   )292596766U,      (u32 const   )1517440620U, 
        (u32 const   )251657213U,      (u32 const   )2235061775U,      (u32 const   )2933202493U,      (u32 const   )758720310U, 
        (u32 const   )265905162U,      (u32 const   )1554391400U,      (u32 const   )1532285339U,      (u32 const   )908999204U, 
        (u32 const   )174567692U,      (u32 const   )1474760595U,      (u32 const   )4002861748U,      (u32 const   )2610011675U, 
        (u32 const   )3234156416U,      (u32 const   )3693126241U,      (u32 const   )2001430874U,      (u32 const   )303699484U, 
        (u32 const   )2478443234U,      (u32 const   )2687165888U,      (u32 const   )585122620U,      (u32 const   )454499602U, 
        (u32 const   )151849742U,      (u32 const   )2345119218U,      (u32 const   )3064510765U,      (u32 const   )514443284U, 
        (u32 const   )4044981591U,      (u32 const   )1963412655U,      (u32 const   )2581445614U,      (u32 const   )2137062819U, 
        (u32 const   )19308535U,      (u32 const   )1928707164U,      (u32 const   )1715193156U,      (u32 const   )4219352155U, 
        (u32 const   )1126790795U,      (u32 const   )600235211U,      (u32 const   )3992742070U,      (u32 const   )3841024952U, 
        (u32 const   )836553431U,      (u32 const   )1669664834U,      (u32 const   )2535604243U,      (u32 const   )3323011204U, 
        (u32 const   )1243905413U,      (u32 const   )3141400786U,      (u32 const   )4180808110U,      (u32 const   )698445255U, 
        (u32 const   )2653899549U,      (u32 const   )2989552604U,      (u32 const   )2253581325U,      (u32 const   )3252932727U, 
        (u32 const   )3004591147U,      (u32 const   )1891211689U,      (u32 const   )2487810577U,      (u32 const   )3915653703U, 
        (u32 const   )4237083816U,      (u32 const   )4030667424U,      (u32 const   )2100090966U,      (u32 const   )865136418U, 
        (u32 const   )1229899655U,      (u32 const   )953270745U,      (u32 const   )3399679628U,      (u32 const   )3557504664U, 
        (u32 const   )4118925222U,      (u32 const   )2061379749U,      (u32 const   )3079546586U,      (u32 const   )2915017791U, 
        (u32 const   )983426092U,      (u32 const   )2022837584U,      (u32 const   )1607244650U,      (u32 const   )2118541908U, 
        (u32 const   )2366882550U,      (u32 const   )3635996816U,      (u32 const   )972512814U,      (u32 const   )3283088770U, 
        (u32 const   )1568718495U,      (u32 const   )3499326569U,      (u32 const   )3576539503U,      (u32 const   )621982671U, 
        (u32 const   )2895723464U,      (u32 const   )410887952U,      (u32 const   )2623762152U,      (u32 const   )1002142683U, 
        (u32 const   )645401037U,      (u32 const   )1494807662U,      (u32 const   )2595684844U,      (u32 const   )1335535747U, 
        (u32 const   )2507040230U,      (u32 const   )4293295786U,      (u32 const   )3167684641U,      (u32 const   )367585007U, 
        (u32 const   )3885750714U,      (u32 const   )1865862730U,      (u32 const   )2668221674U,      (u32 const   )2960971305U, 
        (u32 const   )2763173681U,      (u32 const   )1059270954U,      (u32 const   )2777952454U,      (u32 const   )2724642869U, 
        (u32 const   )1320957812U,      (u32 const   )2194319100U,      (u32 const   )2429595872U,      (u32 const   )2815956275U, 
        (u32 const   )77089521U,      (u32 const   )3973773121U,      (u32 const   )3444575871U,      (u32 const   )2448830231U, 
        (u32 const   )1305906550U,      (u32 const   )4021308739U,      (u32 const   )2857194700U,      (u32 const   )2516901860U, 
        (u32 const   )3518358430U,      (u32 const   )1787304780U,      (u32 const   )740276417U,      (u32 const   )1699839814U, 
        (u32 const   )1592394909U,      (u32 const   )2352307457U,      (u32 const   )2272556026U,      (u32 const   )188821243U, 
        (u32 const   )1729977011U,      (u32 const   )3687994002U,      (u32 const   )274084841U,      (u32 const   )3594982253U, 
        (u32 const   )3613494426U,      (u32 const   )2701949495U,      (u32 const   )4162096729U,      (u32 const   )322734571U, 
        (u32 const   )2837966542U,      (u32 const   )1640576439U,      (u32 const   )484830689U,      (u32 const   )1202797690U, 
        (u32 const   )3537852828U,      (u32 const   )4067639125U,      (u32 const   )349075736U,      (u32 const   )3342319475U, 
        (u32 const   )4157467219U,      (u32 const   )4255800159U,      (u32 const   )1030690015U,      (u32 const   )1155237496U, 
        (u32 const   )2951971274U,      (u32 const   )1757691577U,      (u32 const   )607398968U,      (u32 const   )2738905026U, 
        (u32 const   )499347990U,      (u32 const   )3794078908U,      (u32 const   )1011452712U,      (u32 const   )227885567U, 
        (u32 const   )2818666809U,      (u32 const   )213114376U,      (u32 const   )3034881240U,      (u32 const   )1455525988U, 
        (u32 const   )3414450555U,      (u32 const   )850817237U,      (u32 const   )1817998408U,      (u32 const   )3092726480U};
#line 647 "rijndael.c"
static u32 const   Td4[256]  = 
#line 647
  {      (u32 const   )1381126738U,      (u32 const   )151587081U,      (u32 const   )1785358954U,      (u32 const   )3587560917U, 
        (u32 const   )808464432U,      (u32 const   )909522486U,      (u32 const   )2779096485U,      (u32 const   )943208504U, 
        (u32 const   )3217014719U,      (u32 const   )1077952576U,      (u32 const   )2745410467U,      (u32 const   )2661195422U, 
        (u32 const   )2172748161U,      (u32 const   )4092851187U,      (u32 const   )3621246935U,      (u32 const   )4227595259U, 
        (u32 const   )2088533116U,      (u32 const   )3823363043U,      (u32 const   )960051513U,      (u32 const   )2189591170U, 
        (u32 const   )2610666395U,      (u32 const   )791621423U,      (u32 const   )4294967295U,      (u32 const   )2273806215U, 
        (u32 const   )875836468U,      (u32 const   )2391707278U,      (u32 const   )1128481603U,      (u32 const   )1145324612U, 
        (u32 const   )3301229764U,      (u32 const   )3739147998U,      (u32 const   )3924421097U,      (u32 const   )3419130827U, 
        (u32 const   )1414812756U,      (u32 const   )2071690107U,      (u32 const   )2492765332U,      (u32 const   )842150450U, 
        (u32 const   )2795939494U,      (u32 const   )3267543746U,      (u32 const   )589505315U,      (u32 const   )1027423549U, 
        (u32 const   )4008636142U,      (u32 const   )1280068684U,      (u32 const   )2509608341U,      (u32 const   )185273099U, 
        (u32 const   )1111638594U,      (u32 const   )4210752250U,      (u32 const   )3284386755U,      (u32 const   )1313754702U, 
        (u32 const   )134744072U,      (u32 const   )774778414U,      (u32 const   )2711724449U,      (u32 const   )1717986918U, 
        (u32 const   )673720360U,      (u32 const   )3654932953U,      (u32 const   )606348324U,      (u32 const   )2998055602U, 
        (u32 const   )1987475062U,      (u32 const   )1532713819U,      (u32 const   )2728567458U,      (u32 const   )1229539657U, 
        (u32 const   )1835887981U,      (u32 const   )2341178251U,      (u32 const   )3520188881U,      (u32 const   )623191333U, 
        (u32 const   )1920103026U,      (u32 const   )4177066232U,      (u32 const   )4143380214U,      (u32 const   )1684300900U, 
        (u32 const   )2256963206U,      (u32 const   )1751672936U,      (u32 const   )2560137368U,      (u32 const   )370546198U, 
        (u32 const   )3570717908U,      (u32 const   )2762253476U,      (u32 const   )1549556828U,      (u32 const   )3435973836U, 
        (u32 const   )1566399837U,      (u32 const   )1701143909U,      (u32 const   )3065427638U,      (u32 const   )2459079314U, 
        (u32 const   )1819044972U,      (u32 const   )1886417008U,      (u32 const   )1212696648U,      (u32 const   )1347440720U, 
        (u32 const   )4261281277U,      (u32 const   )3991793133U,      (u32 const   )3115956665U,      (u32 const   )3671775962U, 
        (u32 const   )1583242846U,      (u32 const   )353703189U,      (u32 const   )1179010630U,      (u32 const   )1465341783U, 
        (u32 const   )2812782503U,      (u32 const   )2374864269U,      (u32 const   )2644352413U,      (u32 const   )2223277188U, 
        (u32 const   )2425393296U,      (u32 const   )3638089944U,      (u32 const   )2880154539U,      (u32 const   )0U, 
        (u32 const   )2358021260U,      (u32 const   )3166485692U,      (u32 const   )3553874899U,      (u32 const   )168430090U, 
        (u32 const   )4160223223U,      (u32 const   )3840206052U,      (u32 const   )1482184792U,      (u32 const   )84215045U, 
        (u32 const   )3099113656U,      (u32 const   )3014898611U,      (u32 const   )1162167621U,      (u32 const   )101058054U, 
        (u32 const   )3503345872U,      (u32 const   )741092396U,      (u32 const   )505290270U,      (u32 const   )2408550287U, 
        (u32 const   )3402287818U,      (u32 const   )1061109567U,      (u32 const   )252645135U,      (u32 const   )33686018U, 
        (u32 const   )3250700737U,      (u32 const   )2947526575U,      (u32 const   )3183328701U,      (u32 const   )50529027U, 
        (u32 const   )16843009U,      (u32 const   )320017171U,      (u32 const   )2324335242U,      (u32 const   )1802201963U, 
        (u32 const   )976894522U,      (u32 const   )2442236305U,      (u32 const   )286331153U,      (u32 const   )1094795585U, 
        (u32 const   )1330597711U,      (u32 const   )1734829927U,      (u32 const   )3705461980U,      (u32 const   )3941264106U, 
        (u32 const   )2543294359U,      (u32 const   )4076008178U,      (u32 const   )3486502863U,      (u32 const   )3469659854U, 
        (u32 const   )4042322160U,      (u32 const   )3031741620U,      (u32 const   )3873892070U,      (u32 const   )1936946035U, 
        (u32 const   )2526451350U,      (u32 const   )2896997548U,      (u32 const   )1953789044U,      (u32 const   )572662306U, 
        (u32 const   )3890735079U,      (u32 const   )2913840557U,      (u32 const   )892679477U,      (u32 const   )2240120197U, 
        (u32 const   )3806520034U,      (u32 const   )4193909241U,      (u32 const   )926365495U,      (u32 const   )3907578088U, 
        (u32 const   )471604252U,      (u32 const   )1970632053U,      (u32 const   )3755991007U,      (u32 const   )1852730990U, 
        (u32 const   )1195853639U,      (u32 const   )4059165169U,      (u32 const   )437918234U,      (u32 const   )1903260017U, 
        (u32 const   )488447261U,      (u32 const   )690563369U,      (u32 const   )3318072773U,      (u32 const   )2307492233U, 
        (u32 const   )1869573999U,      (u32 const   )3082270647U,      (u32 const   )1650614882U,      (u32 const   )235802126U, 
        (u32 const   )2863311530U,      (u32 const   )404232216U,      (u32 const   )3200171710U,      (u32 const   )454761243U, 
        (u32 const   )4244438268U,      (u32 const   )1448498774U,      (u32 const   )1044266558U,      (u32 const   )1263225675U, 
        (u32 const   )3334915782U,      (u32 const   )3537031890U,      (u32 const   )2038004089U,      (u32 const   )538976288U, 
        (u32 const   )2593823386U,      (u32 const   )3688618971U,      (u32 const   )3233857728U,      (u32 const   )4278124286U, 
        (u32 const   )2021161080U,      (u32 const   )3452816845U,      (u32 const   )1515870810U,      (u32 const   )4109694196U, 
        (u32 const   )522133279U,      (u32 const   )3722304989U,      (u32 const   )2829625512U,      (u32 const   )858993459U, 
        (u32 const   )2290649224U,      (u32 const   )117901063U,      (u32 const   )3351758791U,      (u32 const   )825307441U, 
        (u32 const   )2981212593U,      (u32 const   )303174162U,      (u32 const   )269488144U,      (u32 const   )1499027801U, 
        (u32 const   )656877351U,      (u32 const   )2155905152U,      (u32 const   )3974950124U,      (u32 const   )1600085855U, 
        (u32 const   )1616928864U,      (u32 const   )1364283729U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )421075225U,      (u32 const   )3048584629U,      (u32 const   )1246382666U,      (u32 const   )218959117U, 
        (u32 const   )757935405U,      (u32 const   )3857049061U,      (u32 const   )2054847098U,      (u32 const   )2678038431U, 
        (u32 const   )2475922323U,      (u32 const   )3385444809U,      (u32 const   )2627509404U,      (u32 const   )4025479151U, 
        (u32 const   )2694881440U,      (u32 const   )3772834016U,      (u32 const   )993737531U,      (u32 const   )1296911693U, 
        (u32 const   )2930683566U,      (u32 const   )707406378U,      (u32 const   )4126537205U,      (u32 const   )2964369584U, 
        (u32 const   )3368601800U,      (u32 const   )3958107115U,      (u32 const   )3149642683U,      (u32 const   )1010580540U, 
        (u32 const   )2206434179U,      (u32 const   )1397969747U,      (u32 const   )2576980377U,      (u32 const   )1633771873U, 
        (u32 const   )387389207U,      (u32 const   )724249387U,      (u32 const   )67372036U,      (u32 const   )2122219134U, 
        (u32 const   )3132799674U,      (u32 const   )2004318071U,      (u32 const   )3604403926U,      (u32 const   )640034342U, 
        (u32 const   )3789677025U,      (u32 const   )1768515945U,      (u32 const   )336860180U,      (u32 const   )1667457891U, 
        (u32 const   )1431655765U,      (u32 const   )555819297U,      (u32 const   )202116108U,      (u32 const   )2105376125U};
#line 713 "rijndael.c"
static u32 const   rcon[10]  = 
#line 713
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )2147483648U, 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 727 "rijndael.c"
static int rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  u32 temp ;

  {
#line 728
  i = 0;
#line 731
  *(rk + 0) = ((((unsigned int )*(cipherKey + 0) << 24) ^ ((unsigned int )*(cipherKey + 1) << 16)) ^ ((unsigned int )*(cipherKey + 2) << 8)) ^ (unsigned int )*(cipherKey + 3);
#line 732
  *(rk + 1) = ((((unsigned int )*((cipherKey + 4) + 0) << 24) ^ ((unsigned int )*((cipherKey + 4) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 4) + 2) << 8)) ^ (unsigned int )*((cipherKey + 4) + 3);
#line 733
  *(rk + 2) = ((((unsigned int )*((cipherKey + 8) + 0) << 24) ^ ((unsigned int )*((cipherKey + 8) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 8) + 2) << 8)) ^ (unsigned int )*((cipherKey + 8) + 3);
#line 734
  *(rk + 3) = ((((unsigned int )*((cipherKey + 12) + 0) << 24) ^ ((unsigned int )*((cipherKey + 12) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 12) + 2) << 8)) ^ (unsigned int )*((cipherKey + 12) + 3);
#line 735
  if (keyBits == 128) {
#line 736
    while (1) {
#line 737
      temp = *(rk + 3);
#line 738
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 744
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 745
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 746
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 747
      i ++;
#line 747
      if (i == 10) {
#line 748
        return (10);
      }
#line 750
      rk += 4;
    }
  }
#line 753
  *(rk + 4) = ((((unsigned int )*((cipherKey + 16) + 0) << 24) ^ ((unsigned int )*((cipherKey + 16) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 16) + 2) << 8)) ^ (unsigned int )*((cipherKey + 16) + 3);
#line 754
  *(rk + 5) = ((((unsigned int )*((cipherKey + 20) + 0) << 24) ^ ((unsigned int )*((cipherKey + 20) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 20) + 2) << 8)) ^ (unsigned int )*((cipherKey + 20) + 3);
#line 755
  if (keyBits == 192) {
#line 756
    while (1) {
#line 757
      temp = *(rk + 5);
#line 758
      *(rk + 6) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 764
      *(rk + 7) = *(rk + 1) ^ *(rk + 6);
#line 765
      *(rk + 8) = *(rk + 2) ^ *(rk + 7);
#line 766
      *(rk + 9) = *(rk + 3) ^ *(rk + 8);
#line 767
      i ++;
#line 767
      if (i == 8) {
#line 768
        return (12);
      }
#line 770
      *(rk + 10) = *(rk + 4) ^ *(rk + 9);
#line 771
      *(rk + 11) = *(rk + 5) ^ *(rk + 10);
#line 772
      rk += 6;
    }
  }
#line 775
  *(rk + 6) = ((((unsigned int )*((cipherKey + 24) + 0) << 24) ^ ((unsigned int )*((cipherKey + 24) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 24) + 2) << 8)) ^ (unsigned int )*((cipherKey + 24) + 3);
#line 776
  *(rk + 7) = ((((unsigned int )*((cipherKey + 28) + 0) << 24) ^ ((unsigned int )*((cipherKey + 28) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 28) + 2) << 8)) ^ (unsigned int )*((cipherKey + 28) + 3);
#line 777
  if (keyBits == 256) {
#line 778
    while (1) {
#line 779
      temp = *(rk + 7);
#line 780
      *(rk + 8) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 786
      *(rk + 9) = *(rk + 1) ^ *(rk + 8);
#line 787
      *(rk + 10) = *(rk + 2) ^ *(rk + 9);
#line 788
      *(rk + 11) = *(rk + 3) ^ *(rk + 10);
#line 789
      i ++;
#line 789
      if (i == 7) {
#line 790
        return (14);
      }
#line 792
      temp = *(rk + 11);
#line 793
      *(rk + 12) = (((*(rk + 4) ^ (unsigned int )(Te4[temp >> 24] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 16711680U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 65280U)) ^ (unsigned int )(Te4[temp & 255U] & 255U);
#line 798
      *(rk + 13) = *(rk + 5) ^ *(rk + 12);
#line 799
      *(rk + 14) = *(rk + 6) ^ *(rk + 13);
#line 800
      *(rk + 15) = *(rk + 7) ^ *(rk + 14);
#line 802
      rk += 8;
    }
  }
#line 805
  return (0);
}
}
#line 813 "rijndael.c"
static int rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits , int have_encrypt ) 
{ int Nr ;
  int i ;
  int j ;
  u32 temp ;

  {
#line 819
  if (have_encrypt) {
#line 820
    Nr = have_encrypt;
  } else {
#line 823
    Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
  }
#line 826
  i = 0;
#line 826
  j = 4 * Nr;
#line 826
  while (i < j) {
#line 827
    temp = *(rk + i);
#line 827
    *(rk + i) = *(rk + j);
#line 827
    *(rk + j) = temp;
#line 828
    temp = *(rk + (i + 1));
#line 828
    *(rk + (i + 1)) = *(rk + (j + 1));
#line 828
    *(rk + (j + 1)) = temp;
#line 829
    temp = *(rk + (i + 2));
#line 829
    *(rk + (i + 2)) = *(rk + (j + 2));
#line 829
    *(rk + (j + 2)) = temp;
#line 830
    temp = *(rk + (i + 3));
#line 830
    *(rk + (i + 3)) = *(rk + (j + 3));
#line 830
    *(rk + (j + 3)) = temp;
#line 826
    i += 4;
#line 826
    j -= 4;
  }
#line 833
  i = 1;
#line 833
  while (i < Nr) {
#line 834
    rk += 4;
#line 835
    *(rk + 0) = (unsigned int )(((Td0[Te4[*(rk + 0) >> 24] & 255U] ^ Td1[Te4[(*(rk + 0) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 0) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 0) & 255U] & 255U]);
#line 840
    *(rk + 1) = (unsigned int )(((Td0[Te4[*(rk + 1) >> 24] & 255U] ^ Td1[Te4[(*(rk + 1) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 1) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 1) & 255U] & 255U]);
#line 845
    *(rk + 2) = (unsigned int )(((Td0[Te4[*(rk + 2) >> 24] & 255U] ^ Td1[Te4[(*(rk + 2) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 2) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 2) & 255U] & 255U]);
#line 850
    *(rk + 3) = (unsigned int )(((Td0[Te4[*(rk + 3) >> 24] & 255U] ^ Td1[Te4[(*(rk + 3) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 3) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 3) & 255U] & 255U]);
#line 833
    i ++;
  }
#line 856
  return (Nr);
}
}
#line 859 "rijndael.c"
static void rijndaelEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 869
  s0 = (((((unsigned int )*(pt + 0) << 24) ^ ((unsigned int )*(pt + 1) << 16)) ^ ((unsigned int )*(pt + 2) << 8)) ^ (unsigned int )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 870
  s1 = (((((unsigned int )*((pt + 4) + 0) << 24) ^ ((unsigned int )*((pt + 4) + 1) << 16)) ^ ((unsigned int )*((pt + 4) + 2) << 8)) ^ (unsigned int )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 871
  s2 = (((((unsigned int )*((pt + 8) + 0) << 24) ^ ((unsigned int )*((pt + 8) + 1) << 16)) ^ ((unsigned int )*((pt + 8) + 2) << 8)) ^ (unsigned int )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 872
  s3 = (((((unsigned int )*((pt + 12) + 0) << 24) ^ ((unsigned int )*((pt + 12) + 1) << 16)) ^ ((unsigned int )*((pt + 12) + 2) << 8)) ^ (unsigned int )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 875
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 4));
#line 876
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 5));
#line 877
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 6));
#line 878
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 7));
#line 880
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 8));
#line 881
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 9));
#line 882
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 10));
#line 883
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 11));
#line 885
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 12));
#line 886
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 13));
#line 887
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 14));
#line 888
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 15));
#line 890
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 16));
#line 891
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 17));
#line 892
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 18));
#line 893
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 19));
#line 895
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 20));
#line 896
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 21));
#line 897
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 22));
#line 898
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 23));
#line 900
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 24));
#line 901
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 25));
#line 902
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 26));
#line 903
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 27));
#line 905
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 28));
#line 906
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 29));
#line 907
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 30));
#line 908
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 31));
#line 910
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 32));
#line 911
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 33));
#line 912
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 34));
#line 913
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 35));
#line 915
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 36));
#line 916
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 37));
#line 917
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 38));
#line 918
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 39));
#line 919
  if (Nr > 10) {
#line 921
    s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 40));
#line 922
    s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 41));
#line 923
    s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 42));
#line 924
    s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 43));
#line 926
    t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 44));
#line 927
    t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 45));
#line 928
    t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 46));
#line 929
    t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 47));
#line 930
    if (Nr > 12) {
#line 932
      s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 48));
#line 933
      s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 49));
#line 934
      s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 50));
#line 935
      s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 51));
#line 937
      t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 52));
#line 938
      t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 53));
#line 939
      t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 54));
#line 940
      t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 55));
    }
  }
#line 943
  rk += Nr << 2;
#line 1010
  s0 = (unsigned int )(((((Te4[t0 >> 24] & 4278190080U) ^ (Te4[(t1 >> 16) & 255U] & 16711680U)) ^ (Te4[(t2 >> 8) & 255U] & 65280U)) ^ (Te4[t3 & 255U] & 255U)) ^ *(rk + 0));
#line 1016
  *(ct + 0) = (unsigned char )(s0 >> 24);
#line 1016
  *(ct + 1) = (unsigned char )(s0 >> 16);
#line 1016
  *(ct + 2) = (unsigned char )(s0 >> 8);
#line 1016
  *(ct + 3) = (unsigned char )s0;
#line 1017
  s1 = (unsigned int )(((((Te4[t1 >> 24] & 4278190080U) ^ (Te4[(t2 >> 16) & 255U] & 16711680U)) ^ (Te4[(t3 >> 8) & 255U] & 65280U)) ^ (Te4[t0 & 255U] & 255U)) ^ *(rk + 1));
#line 1023
  *((ct + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1023
  *((ct + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1023
  *((ct + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1023
  *((ct + 4) + 3) = (unsigned char )s1;
#line 1024
  s2 = (unsigned int )(((((Te4[t2 >> 24] & 4278190080U) ^ (Te4[(t3 >> 16) & 255U] & 16711680U)) ^ (Te4[(t0 >> 8) & 255U] & 65280U)) ^ (Te4[t1 & 255U] & 255U)) ^ *(rk + 2));
#line 1030
  *((ct + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1030
  *((ct + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1030
  *((ct + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1030
  *((ct + 8) + 3) = (unsigned char )s2;
#line 1031
  s3 = (unsigned int )(((((Te4[t3 >> 24] & 4278190080U) ^ (Te4[(t0 >> 16) & 255U] & 16711680U)) ^ (Te4[(t1 >> 8) & 255U] & 65280U)) ^ (Te4[t2 & 255U] & 255U)) ^ *(rk + 3));
#line 1037
  *((ct + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1037
  *((ct + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1037
  *((ct + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1037
  *((ct + 12) + 3) = (unsigned char )s3;
#line 1038
  return;
}
}
#line 1040 "rijndael.c"
static void rijndaelDecrypt(u32 const   *rk , int Nr , u8 const   *ct , u8 *pt ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 1050
  s0 = (((((unsigned int )*(ct + 0) << 24) ^ ((unsigned int )*(ct + 1) << 16)) ^ ((unsigned int )*(ct + 2) << 8)) ^ (unsigned int )*(ct + 3)) ^ (unsigned int )*(rk + 0);
#line 1051
  s1 = (((((unsigned int )*((ct + 4) + 0) << 24) ^ ((unsigned int )*((ct + 4) + 1) << 16)) ^ ((unsigned int )*((ct + 4) + 2) << 8)) ^ (unsigned int )*((ct + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 1052
  s2 = (((((unsigned int )*((ct + 8) + 0) << 24) ^ ((unsigned int )*((ct + 8) + 1) << 16)) ^ ((unsigned int )*((ct + 8) + 2) << 8)) ^ (unsigned int )*((ct + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 1053
  s3 = (((((unsigned int )*((ct + 12) + 0) << 24) ^ ((unsigned int )*((ct + 12) + 1) << 16)) ^ ((unsigned int )*((ct + 12) + 2) << 8)) ^ (unsigned int )*((ct + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 1056
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 4));
#line 1057
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 5));
#line 1058
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 6));
#line 1059
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 7));
#line 1061
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 8));
#line 1062
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 9));
#line 1063
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 10));
#line 1064
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 11));
#line 1066
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 12));
#line 1067
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 13));
#line 1068
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 14));
#line 1069
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 15));
#line 1071
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 16));
#line 1072
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 17));
#line 1073
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 18));
#line 1074
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 19));
#line 1076
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 20));
#line 1077
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 21));
#line 1078
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 22));
#line 1079
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 23));
#line 1081
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 24));
#line 1082
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 25));
#line 1083
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 26));
#line 1084
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 27));
#line 1086
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 28));
#line 1087
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 29));
#line 1088
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 30));
#line 1089
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 31));
#line 1091
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 32));
#line 1092
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 33));
#line 1093
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 34));
#line 1094
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 35));
#line 1096
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 36));
#line 1097
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 37));
#line 1098
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 38));
#line 1099
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 39));
#line 1100
  if (Nr > 10) {
#line 1102
    s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 40));
#line 1103
    s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 41));
#line 1104
    s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 42));
#line 1105
    s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 43));
#line 1107
    t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 44));
#line 1108
    t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 45));
#line 1109
    t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 46));
#line 1110
    t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 47));
#line 1111
    if (Nr > 12) {
#line 1113
      s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 48));
#line 1114
      s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 49));
#line 1115
      s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 50));
#line 1116
      s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 51));
#line 1118
      t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 52));
#line 1119
      t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 53));
#line 1120
      t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 54));
#line 1121
      t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 55));
    }
  }
#line 1124
  rk += Nr << 2;
#line 1191
  s0 = (unsigned int )(((((Td4[t0 >> 24] & 4278190080U) ^ (Td4[(t3 >> 16) & 255U] & 16711680U)) ^ (Td4[(t2 >> 8) & 255U] & 65280U)) ^ (Td4[t1 & 255U] & 255U)) ^ *(rk + 0));
#line 1197
  *(pt + 0) = (unsigned char )(s0 >> 24);
#line 1197
  *(pt + 1) = (unsigned char )(s0 >> 16);
#line 1197
  *(pt + 2) = (unsigned char )(s0 >> 8);
#line 1197
  *(pt + 3) = (unsigned char )s0;
#line 1198
  s1 = (unsigned int )(((((Td4[t1 >> 24] & 4278190080U) ^ (Td4[(t0 >> 16) & 255U] & 16711680U)) ^ (Td4[(t3 >> 8) & 255U] & 65280U)) ^ (Td4[t2 & 255U] & 255U)) ^ *(rk + 1));
#line 1204
  *((pt + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1204
  *((pt + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1204
  *((pt + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1204
  *((pt + 4) + 3) = (unsigned char )s1;
#line 1205
  s2 = (unsigned int )(((((Td4[t2 >> 24] & 4278190080U) ^ (Td4[(t1 >> 16) & 255U] & 16711680U)) ^ (Td4[(t0 >> 8) & 255U] & 65280U)) ^ (Td4[t3 & 255U] & 255U)) ^ *(rk + 2));
#line 1211
  *((pt + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1211
  *((pt + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1211
  *((pt + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1211
  *((pt + 8) + 3) = (unsigned char )s2;
#line 1212
  s3 = (unsigned int )(((((Td4[t3 >> 24] & 4278190080U) ^ (Td4[(t2 >> 16) & 255U] & 16711680U)) ^ (Td4[(t1 >> 8) & 255U] & 65280U)) ^ (Td4[t0 & 255U] & 255U)) ^ *(rk + 3));
#line 1218
  *((pt + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1218
  *((pt + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1218
  *((pt + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1218
  *((pt + 12) + 3) = (unsigned char )s3;
#line 1219
  return;
}
}
#line 1221 "rijndael.c"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int encrypt ) 
{ 

  {
#line 1224
  ctx->Nr = rijndaelKeySetupEnc(ctx->ek, (u8 const   *)key, bits);
#line 1225
  if (encrypt) {
#line 1226
    ctx->decrypt = 0;
#line 1227
    memset((void *)(ctx->dk), 0, sizeof(ctx->dk));
  } else {
#line 1229
    ctx->decrypt = 1;
#line 1230
    memcpy((void * __restrict  )(ctx->dk), (void const   * __restrict  )(ctx->ek),
           sizeof(ctx->ek));
#line 1231
    rijndaelKeySetupDec(ctx->dk, (u8 const   *)key, bits, ctx->Nr);
  }
#line 1233
  return;
}
}
#line 1235 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1238
  rijndaelDecrypt((u32 const   *)(ctx->dk), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1239
  return;
}
}
#line 1241 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1244
  rijndaelEncrypt((u32 const   *)(ctx->ek), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1245
  return;
}
}
#line 1 "entropy.o"
#line 31 "entropy.h"
void init_rng(void) ;
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 109
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 71 "entropy.c"
static void check_openssl_version(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 74
  tmp___0 = SSLeay();
#line 74
  if (tmp___0 != 9469999UL) {
#line 75
    tmp = SSLeay();
#line 75
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 77
  return;
}
}
#line 185 "entropy.c"
static int get_random_bytes(unsigned char *buf___2 , int len ) 
{ int random_pool ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 190
  random_pool = open("/dev/urandom", 0);
#line 191
  if (random_pool == -1) {
#line 192
    tmp = __errno_location();
#line 192
    tmp___0 = strerror(*tmp);
#line 192
    error("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
#line 194
    return (0);
  }
#line 197
  tmp___3 = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___2, (unsigned int )len);
#line 197
  if (tmp___3 != len) {
#line 198
    tmp___1 = __errno_location();
#line 198
    tmp___2 = strerror(*tmp___1);
#line 198
    error("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
#line 200
    close(random_pool);
#line 201
    return (0);
  }
#line 204
  close(random_pool);
#line 206
  return (1);
}
}
#line 215 "entropy.c"
void seed_rng(void) 
{ unsigned char buf___2[32] ;
  int tmp ;
  int tmp___0 ;

  {
#line 220
  debug("Seeding random number generator");
#line 222
  tmp___0 = get_random_bytes(buf___2, (int )sizeof(buf___2));
#line 222
  if (tmp___0) {
#line 226
    RAND_add((void const   *)(buf___2), (int )sizeof(buf___2), (double )sizeof(buf___2));
  } else {
#line 223
    tmp = RAND_status();
#line 223
    if (! tmp) {
#line 224
      fatal("Entropy collection failed and entropy exhausted");
    }
  }
#line 229
  memset((void *)(buf___2), '\000', sizeof(buf___2));
#line 230
  return;
}
}
#line 232 "entropy.c"
void init_rng(void) 
{ 

  {
#line 235
  check_openssl_version();
#line 236
  return;
}
}
#line 1 "readpass.o"
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 18 "readpass.h"
char *read_passphrase(char const   *prompt , int flags ) ;
#line 43 "readpass.c"
static char *ssh_askpass(char *askpass , char const   *msg ) 
{ pid_t pid ;
  size_t len ;
  char *nl ;
  char *pass ;
  int p[2] ;
  int status ;
  char buf___2[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  __uid_t tmp___9 ;
  __uid_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  ssize_t tmp___16 ;
  int *tmp___17 ;
  __pid_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___21 ;

  {
#line 52
  tmp___1 = fflush(stdout);
#line 52
  if (tmp___1 != 0) {
#line 53
    tmp = __errno_location();
#line 53
    tmp___0 = strerror(*tmp);
#line 53
    error("ssh_askpass: fflush: %s", tmp___0);
  }
#line 54
  if ((unsigned int )askpass == (unsigned int )((void *)0)) {
#line 55
    fatal("internal error: askpass undefined");
  }
#line 56
  tmp___5 = pipe((int *)(p));
#line 56
  if (tmp___5 < 0) {
#line 57
    tmp___2 = __errno_location();
#line 57
    tmp___3 = strerror(*tmp___2);
#line 57
    error("ssh_askpass: pipe: %s", tmp___3);
#line 58
    tmp___4 = xstrdup("");
#line 58
    return (tmp___4);
  }
#line 60
  pid = fork();
#line 60
  if (pid < 0) {
#line 61
    tmp___6 = __errno_location();
#line 61
    tmp___7 = strerror(*tmp___6);
#line 61
    error("ssh_askpass: fork: %s", tmp___7);
#line 62
    tmp___8 = xstrdup("");
#line 62
    return (tmp___8);
  }
#line 64
  if (pid == 0) {
#line 65
    tmp___9 = getuid();
#line 65
    seteuid(tmp___9);
#line 66
    tmp___10 = getuid();
#line 66
    setuid(tmp___10);
#line 67
    close(p[0]);
#line 68
    tmp___13 = dup2(p[1], 1);
#line 68
    if (tmp___13 < 0) {
#line 69
      tmp___11 = __errno_location();
#line 69
      tmp___12 = strerror(*tmp___11);
#line 69
      fatal("ssh_askpass: dup2: %s", tmp___12);
    }
#line 70
    execlp((char const   *)askpass, (char const   *)askpass, msg, (char *)0);
#line 71
    tmp___14 = __errno_location();
#line 71
    tmp___15 = strerror(*tmp___14);
#line 71
    fatal("ssh_askpass: exec(%s): %s", askpass, tmp___15);
  }
#line 73
  close(p[1]);
#line 74
  tmp___16 = read(p[0], (void *)(buf___2), sizeof(buf___2));
#line 74
  len = (unsigned int )tmp___16;
#line 75
  close(p[0]);
#line 76
  while (1) {
#line 76
    tmp___18 = waitpid(pid, & status, 0);
#line 76
    if (! (tmp___18 < 0)) {
#line 76
      break;
    }
#line 77
    tmp___17 = __errno_location();
#line 77
    if (*tmp___17 != 4) {
#line 78
      break;
    }
  }
#line 79
  if (len <= 1U) {
#line 80
    tmp___19 = xstrdup("");
#line 80
    return (tmp___19);
  }
#line 81
  tmp___21 = __builtin_strchr(buf___2, '\n');
#line 81
  nl = tmp___21;
#line 82
  if (nl) {
#line 83
    *nl = (char )'\000';
  }
#line 84
  pass = xstrdup((char const   *)(buf___2));
#line 85
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 86
  return (pass);
}
}
#line 95 "readpass.c"
char *read_passphrase(char const   *prompt , int flags ) 
{ char *askpass ;
  char *ret ;
  char buf___2[1024] ;
  int rppflags ;
  int use_askpass ;
  int ttyfd ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 98
  askpass = (char *)((void *)0);
#line 99
  use_askpass = 0;
#line 101
  if (flags & 1) {
#line 101
    rppflags = 1;
  } else {
#line 101
    rppflags = 0;
  }
#line 102
  if (flags & 2) {
#line 103
    tmp = isatty(0);
#line 103
    if (! tmp) {
#line 104
      use_askpass = 1;
    }
  } else {
#line 106
    rppflags |= 2;
#line 107
    ttyfd = open("/dev/tty", 2);
#line 108
    if (ttyfd >= 0) {
#line 109
      close(ttyfd);
    } else {
#line 111
      use_askpass = 1;
    }
  }
#line 114
  if (use_askpass) {
#line 114
    tmp___2 = getenv("DISPLAY");
#line 114
    if (tmp___2) {
#line 115
      tmp___0 = getenv("SSH_ASKPASS");
#line 115
      if (tmp___0) {
#line 116
        askpass = getenv("SSH_ASKPASS");
      } else {
#line 118
        askpass = (char *)"/usr/local/libexec/ssh-askpass";
      }
#line 119
      tmp___1 = ssh_askpass(askpass, prompt);
#line 119
      return (tmp___1);
    }
  }
#line 122
  tmp___4 = readpassphrase(prompt, buf___2, sizeof(buf___2), rppflags);
#line 122
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 123
    tmp___3 = xstrdup("");
#line 123
    return (tmp___3);
  }
#line 125
  ret = xstrdup((char const   *)(buf___2));
#line 126
  memset((void *)(buf___2), 'x', sizeof(buf___2));
#line 127
  return (ret);
}
}
#line 1 "rsa.o"
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 24
void rsa_generate_additional_parameters(RSA *rsa ) ;
#line 69 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 75
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 75
  if (tmp < 2) {
#line 76
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 75
    if ((key->e)->top > 0) {
#line 75
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 76
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 76
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 78
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 78
  olen = (tmp___0 + 7) / 8;
#line 79
  tmp___1 = xmalloc((unsigned int )olen);
#line 79
  outbuf = (u_char *)tmp___1;
#line 81
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 81
  ilen = (tmp___2 + 7) / 8;
#line 82
  tmp___3 = xmalloc((unsigned int )ilen);
#line 82
  inbuf = (u_char *)tmp___3;
#line 83
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 85
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 85
  if (len <= 0) {
#line 87
    fatal("rsa_public_encrypt() failed");
  }
#line 89
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 91
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 92
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 93
  xfree((void *)outbuf);
#line 94
  xfree((void *)inbuf);
#line 95
  return;
}
}
#line 97 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 103
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 103
  olen = (tmp + 7) / 8;
#line 104
  tmp___0 = xmalloc((unsigned int )olen);
#line 104
  outbuf = (u_char *)tmp___0;
#line 106
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 106
  ilen = (tmp___1 + 7) / 8;
#line 107
  tmp___2 = xmalloc((unsigned int )ilen);
#line 107
  inbuf = (u_char *)tmp___2;
#line 108
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 110
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 110
  if (len <= 0) {
#line 112
    error("rsa_private_decrypt() failed");
  } else {
#line 114
    BN_bin2bn((unsigned char const   *)outbuf, len, out);
  }
#line 116
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 117
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 118
  xfree((void *)outbuf);
#line 119
  xfree((void *)inbuf);
#line 120
  return (len);
}
}
#line 123 "rsa.c"
void rsa_generate_additional_parameters(RSA *rsa ) 
{ BIGNUM *aux ;
  BN_CTX *ctx ;
  BIGNUM const   *tmp ;
  BIGNUM const   *tmp___0 ;

  {
#line 129
  aux = BN_new();
#line 130
  ctx = BN_CTX_new();
#line 132
  tmp = BN_value_one();
#line 132
  BN_sub(aux, (BIGNUM const   *)rsa->q, tmp);
#line 133
  BN_div((BIGNUM *)((void *)0), rsa->dmq1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 135
  tmp___0 = BN_value_one();
#line 135
  BN_sub(aux, (BIGNUM const   *)rsa->p, tmp___0);
#line 136
  BN_div((BIGNUM *)((void *)0), rsa->dmp1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
         ctx);
#line 138
  BN_clear_free(aux);
#line 139
  BN_CTX_free(ctx);
#line 140
  return;
}
}
#line 1 "scard.o"
#line 1 "ssh-dss.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 42 "ssh-dss.c"
int ssh_dss_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char *digest___1 ;
  u_char *ret ;
  u_char sigblob[40] ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 49
  tmp = EVP_sha1();
#line 49
  evp_md = (EVP_MD *)tmp;
#line 55
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 56
    error("ssh_dss_sign: no DSA key");
#line 57
    return (-1);
  } else {
#line 55
    if (key->type != 2) {
#line 56
      error("ssh_dss_sign: no DSA key");
#line 57
      return (-1);
    } else {
#line 55
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 56
        error("ssh_dss_sign: no DSA key");
#line 57
        return (-1);
      }
    }
  }
#line 59
  dlen = (unsigned int )evp_md->md_size;
#line 60
  tmp___0 = xmalloc(dlen);
#line 60
  digest___1 = (u_char *)tmp___0;
#line 61
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 62
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 63
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 65
  sig = DSA_do_sign((unsigned char const   *)digest___1, (int )dlen, key->dsa);
#line 67
  memset((void *)digest___1, 0, dlen);
#line 68
  xfree((void *)digest___1);
#line 69
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 70
    error("ssh_dss_sign: sign failed");
#line 71
    return (-1);
  }
#line 74
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 74
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 75
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 75
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 76
  if (rlen > 20U) {
#line 77
    error("bad sig size %d %d", rlen, slen);
#line 78
    DSA_SIG_free(sig);
#line 79
    return (-1);
  } else {
#line 76
    if (slen > 20U) {
#line 77
      error("bad sig size %d %d", rlen, slen);
#line 78
      DSA_SIG_free(sig);
#line 79
      return (-1);
    }
  }
#line 81
  memset((void *)(sigblob), 0, 40U);
#line 82
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 83
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 84
  DSA_SIG_free(sig);
#line 86
  if (datafellows & 1) {
#line 87
    tmp___3 = xmalloc(40U);
#line 87
    ret = (u_char *)tmp___3;
#line 88
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 89
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 90
      *lenp = 40;
    }
#line 91
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 92
      *sigp = ret;
    }
  } else {
#line 95
    buffer_init(& b);
#line 96
    buffer_put_cstring(& b, "ssh-dss");
#line 97
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 98
    len = buffer_len(& b);
#line 99
    tmp___4 = xmalloc(len);
#line 99
    ret = (u_char *)tmp___4;
#line 100
    tmp___5 = buffer_ptr(& b);
#line 100
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 101
    buffer_free(& b);
#line 102
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 103
      *lenp = (int )len;
    }
#line 104
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 105
      *sigp = ret;
    }
  }
#line 107
  return (0);
}
}
#line 109 "ssh-dss.c"
int ssh_dss_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char *digest___1 ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  Buffer b ;
  char *ktype ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  char const   *tmp___14 ;

  {
#line 116
  tmp = EVP_sha1();
#line 116
  evp_md = (EVP_MD *)tmp;
#line 123
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 124
    error("ssh_dss_verify: no DSA key");
#line 125
    return (-1);
  } else {
#line 123
    if (key->type != 2) {
#line 124
      error("ssh_dss_verify: no DSA key");
#line 125
      return (-1);
    } else {
#line 123
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 124
        error("ssh_dss_verify: no DSA key");
#line 125
        return (-1);
      }
    }
  }
#line 129
  if (datafellows & 1) {
#line 130
    sigblob = signature;
#line 131
    len = (unsigned int )signaturelen;
  } else {
#line 135
    buffer_init(& b);
#line 136
    buffer_append(& b, (char const   *)signature, (unsigned int )signaturelen);
#line 137
    ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 138
    if (0) {
#line 138
      __s1_len = strlen("ssh-dss");
#line 138
      __s2_len = strlen((char const   *)ktype);
#line 138
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___0;
      } else {
#line 138
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 138
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 138
            tmp___9 = 1;
          } else {
#line 138
            if (__s2_len >= 4U) {
#line 138
              tmp___9 = 1;
            } else {
#line 138
              tmp___9 = 0;
            }
          }
        } else {
#line 138
          tmp___9 = 0;
        }
      }
#line 138
      if (tmp___9) {
#line 138
        tmp___5 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 138
        tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 138
        tmp___5 = tmp___8;
      }
    } else {
#line 138
      tmp___8 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 138
      tmp___5 = tmp___8;
    }
#line 138
    if (tmp___5 != 0) {
#line 139
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 140
      buffer_free(& b);
#line 141
      return (-1);
    }
#line 143
    tmp___10 = buffer_get_string(& b, & len);
#line 143
    sigblob = (u_char *)tmp___10;
#line 144
    tmp___11 = buffer_len(& b);
#line 144
    rlen = (int )tmp___11;
#line 145
    if (rlen != 0) {
#line 146
      error("remaining bytes in signature %d", rlen);
#line 147
      buffer_free(& b);
#line 148
      return (-1);
    }
#line 150
    buffer_free(& b);
#line 151
    xfree((void *)ktype);
  }
#line 154
  if (len != 40U) {
#line 155
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 159
  sig = DSA_SIG_new();
#line 160
  sig->r = BN_new();
#line 161
  sig->s = BN_new();
#line 162
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 163
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 165
  if (! (datafellows & 1)) {
#line 166
    memset((void *)sigblob, 0, len);
#line 167
    xfree((void *)sigblob);
  }
#line 171
  dlen = (unsigned int )evp_md->md_size;
#line 172
  tmp___12 = xmalloc(dlen);
#line 172
  digest___1 = (u_char *)tmp___12;
#line 173
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 174
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 175
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 177
  ret = DSA_do_verify((unsigned char const   *)digest___1, (int )dlen, sig, key->dsa);
#line 179
  memset((void *)digest___1, 0, dlen);
#line 180
  xfree((void *)digest___1);
#line 181
  DSA_SIG_free(sig);
#line 183
  if (ret == 1) {
#line 183
    tmp___14 = "correct";
  } else {
#line 183
    if (ret == 0) {
#line 183
      tmp___14 = "incorrect";
    } else {
#line 183
      tmp___14 = "error";
    }
  }
#line 183
  debug("ssh_dss_verify: signature %s", tmp___14);
#line 185
  return (ret);
}
}
#line 1 "ssh-rsa.o"
#line 1006 "/usr/include/openssl/objects.h"
extern char const   *OBJ_nid2sn(int n ) ;
#line 732 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_get_digestbyname(char const   *name ) ;
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 286
extern int RSA_verify(int type , unsigned char const   *m , unsigned int m_length ,
                      unsigned char *sigbuf , unsigned int siglen , RSA *rsa ) ;
#line 40 "ssh-rsa.c"
int ssh_rsa_sign(Key *key , u_char **sigp , int *lenp , u_char *data , int datalen ) 
{ EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  u_char *digest___1 ;
  u_char *sig ;
  u_char *ret ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  int nid ;
  Buffer b ;
  char const   *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int ecode ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  int diff ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
#line 53
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 54
    error("ssh_rsa_sign: no RSA key");
#line 55
    return (-1);
  } else {
#line 53
    if (key->type != 1) {
#line 54
      error("ssh_rsa_sign: no RSA key");
#line 55
      return (-1);
    } else {
#line 53
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 54
        error("ssh_rsa_sign: no RSA key");
#line 55
        return (-1);
      }
    }
  }
#line 57
  if (datafellows & 8192) {
#line 57
    nid = 4;
  } else {
#line 57
    nid = 64;
  }
#line 58
  tmp = OBJ_nid2sn(nid);
#line 58
  evp_md = EVP_get_digestbyname(tmp);
#line 58
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 59
    error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
#line 60
    return (-1);
  }
#line 62
  dlen = (unsigned int )evp_md->md_size;
#line 63
  tmp___0 = xmalloc(dlen);
#line 63
  digest___1 = (u_char *)tmp___0;
#line 64
  EVP_DigestInit(& md, evp_md);
#line 65
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 66
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 68
  tmp___1 = RSA_size((RSA const   *)key->rsa);
#line 68
  slen = (unsigned int )tmp___1;
#line 69
  tmp___2 = xmalloc(slen);
#line 69
  sig = (u_char *)tmp___2;
#line 71
  ok = RSA_sign(nid, (unsigned char const   *)digest___1, dlen, sig, & len, key->rsa);
#line 72
  memset((void *)digest___1, 'd', dlen);
#line 73
  xfree((void *)digest___1);
#line 75
  if (ok != 1) {
#line 76
    tmp___3 = ERR_get_error();
#line 76
    ecode = (int )tmp___3;
#line 77
    tmp___4 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 77
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___4);
#line 78
    xfree((void *)sig);
#line 79
    return (-1);
  }
#line 81
  if (len < slen) {
#line 82
    diff = (int )(slen - len);
#line 83
    debug("slen %d > len %d", slen, len);
#line 84
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 85
    memset((void *)sig, 0, (unsigned int )diff);
  } else {
#line 86
    if (len > slen) {
#line 87
      error("ssh_rsa_sign: slen %d slen2 %d", slen, len);
#line 88
      xfree((void *)sig);
#line 89
      return (-1);
    }
  }
#line 92
  buffer_init(& b);
#line 93
  buffer_put_cstring(& b, "ssh-rsa");
#line 94
  buffer_put_string(& b, (void const   *)sig, slen);
#line 95
  len = buffer_len(& b);
#line 96
  tmp___5 = xmalloc(len);
#line 96
  ret = (u_char *)tmp___5;
#line 97
  tmp___6 = buffer_ptr(& b);
#line 97
  memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___6, len);
#line 98
  buffer_free(& b);
#line 99
  memset((void *)sig, 's', slen);
#line 100
  xfree((void *)sig);
#line 102
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 103
    *lenp = (int )len;
  }
#line 104
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 105
    *sigp = ret;
  }
#line 106
  return (0);
}
}
#line 109 "ssh-rsa.c"
int ssh_rsa_verify(Key *key , u_char *signature , int signaturelen , u_char *data ,
                   int datalen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char *sigblob ;
  u_char *digest___1 ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret ;
  int nid ;
  int tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  u_int tmp___12 ;
  char const   *tmp___13 ;
  void *tmp___14 ;
  int ecode ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 123
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 124
    error("ssh_rsa_verify: no RSA key");
#line 125
    return (-1);
  } else {
#line 123
    if (key->type != 1) {
#line 124
      error("ssh_rsa_verify: no RSA key");
#line 125
      return (-1);
    } else {
#line 123
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 124
        error("ssh_rsa_verify: no RSA key");
#line 125
        return (-1);
      }
    }
  }
#line 127
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 127
  if (tmp___0 < 768) {
#line 128
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 128
    error("ssh_rsa_verify: n too small: %d bits", tmp);
#line 130
    return (-1);
  }
#line 132
  buffer_init(& b);
#line 133
  buffer_append(& b, (char const   *)signature, (unsigned int )signaturelen);
#line 134
  ktype = buffer_get_string(& b, (u_int *)((void *)0));
#line 135
  if (0) {
#line 135
    __s1_len = strlen("ssh-rsa");
#line 135
    __s2_len = strlen((char const   *)ktype);
#line 135
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 135
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 135
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 135
          tmp___10 = 1;
        } else {
#line 135
          if (__s2_len >= 4U) {
#line 135
            tmp___10 = 1;
          } else {
#line 135
            tmp___10 = 0;
          }
        }
      } else {
#line 135
        tmp___10 = 0;
      }
    }
#line 135
    if (tmp___10) {
#line 135
      tmp___6 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 135
      tmp___9 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 135
      tmp___6 = tmp___9;
    }
  } else {
#line 135
    tmp___9 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 135
    tmp___6 = tmp___9;
  }
#line 135
  if (tmp___6 != 0) {
#line 136
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 137
    buffer_free(& b);
#line 138
    xfree((void *)ktype);
#line 139
    return (-1);
  }
#line 141
  xfree((void *)ktype);
#line 142
  tmp___11 = buffer_get_string(& b, & len);
#line 142
  sigblob = (u_char *)tmp___11;
#line 143
  tmp___12 = buffer_len(& b);
#line 143
  rlen = (int )tmp___12;
#line 144
  buffer_free(& b);
#line 145
  if (rlen != 0) {
#line 146
    xfree((void *)sigblob);
#line 147
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 148
    return (-1);
  }
#line 150
  if (datafellows & 8192) {
#line 150
    nid = 4;
  } else {
#line 150
    nid = 64;
  }
#line 151
  tmp___13 = OBJ_nid2sn(nid);
#line 151
  evp_md = EVP_get_digestbyname(tmp___13);
#line 151
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 152
    xfree((void *)sigblob);
#line 153
    error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
#line 154
    return (-1);
  }
#line 156
  dlen = (unsigned int )evp_md->md_size;
#line 157
  tmp___14 = xmalloc(dlen);
#line 157
  digest___1 = (u_char *)tmp___14;
#line 158
  EVP_DigestInit(& md, evp_md);
#line 159
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 160
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 162
  ret = RSA_verify(nid, (unsigned char const   *)digest___1, dlen, sigblob, len, key->rsa);
#line 163
  memset((void *)digest___1, 'd', dlen);
#line 164
  xfree((void *)digest___1);
#line 165
  memset((void *)sigblob, 's', len);
#line 166
  xfree((void *)sigblob);
#line 167
  if (ret == 0) {
#line 168
    tmp___15 = ERR_get_error();
#line 168
    ecode = (int )tmp___15;
#line 169
    tmp___16 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 169
    error("ssh_rsa_verify: RSA_verify failed: %s", tmp___16);
  }
#line 171
  if (ret == 0) {
#line 171
    tmp___17 = "in";
  } else {
#line 171
    tmp___17 = "";
  }
#line 171
  debug("ssh_rsa_verify: signature %scorrect", tmp___17);
#line 172
  return (ret);
}
}
#line 1 "tildexpand.o"
#line 15 "tildexpand.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 24 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  u_int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;

  {
#line 35
  if ((int const   )*(filename + 0) != 126) {
#line 36
    tmp = xstrdup(filename);
#line 36
    return (tmp);
  }
#line 39
  filename ++;
#line 42
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 42
  cp = (char const   *)tmp___1;
#line 43
  if (cp) {
#line 44
    userlen = (unsigned int )(cp - filename);
  } else {
#line 46
    userlen = strlen(filename);
  }
#line 47
  if (userlen == 0U) {
#line 48
    pw = getpwuid(my_uid);
  } else {
#line 51
    if (userlen > sizeof(user) - 1U) {
#line 52
      fatal("User name after tilde too long.");
    }
#line 53
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 54
    user[userlen] = (char)0;
#line 55
    pw = getpwnam((char const   *)(user));
  }
#line 57
  if (! pw) {
#line 58
    fatal("Unknown user %100s.", user);
  }
#line 61
  if (! cp) {
#line 63
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 63
    return (tmp___2);
  }
#line 66
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 66
  tmp___4 = strlen(cp + 1);
#line 66
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 67
  if (len > 4096) {
#line 68
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 69
  tmp___5 = xmalloc((unsigned int )len);
#line 69
  expanded = (char *)tmp___5;
#line 70
  if (0) {
#line 70
    __s1_len___0 = strlen((char const   *)pw->pw_dir);
#line 70
    __s2_len___0 = strlen("/");
#line 70
    if (! ((unsigned int )((void const   *)(pw->pw_dir + 1)) - (unsigned int )((void const   *)pw->pw_dir) == 1U)) {
      goto _L___2;
    } else {
#line 70
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 70
        if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 70
          tmp___26 = 1;
        } else {
#line 70
          if (__s2_len___0 >= 4U) {
#line 70
            tmp___26 = 1;
          } else {
#line 70
            tmp___26 = 0;
          }
        }
      } else {
#line 70
        tmp___26 = 0;
      }
    }
#line 70
    if (tmp___26) {
#line 70
      tmp___22 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
    } else {
#line 70
      tmp___25 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 70
      tmp___22 = tmp___25;
    }
  } else {
#line 70
    tmp___25 = __builtin_strcmp((char const   *)pw->pw_dir, "/");
#line 70
    tmp___22 = tmp___25;
  }
#line 70
  if (tmp___22) {
#line 70
    tmp___16 = "/";
  } else {
#line 70
    tmp___16 = "";
  }
#line 70
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s%s%s",
           pw->pw_dir, tmp___16, cp + 1);
#line 71
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 68 "packet.h"
void tty_make_modes(int fd , struct termios *tiop ) ;
#line 69
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 68 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 71
  switch ((int )speed) {
  case 0: 
#line 73
  return (0);
  case 1: 
#line 75
  return (50);
  case 2: 
#line 77
  return (75);
  case 3: 
#line 79
  return (110);
  case 4: 
#line 81
  return (134);
  case 5: 
#line 83
  return (150);
  case 6: 
#line 85
  return (200);
  case 7: 
#line 87
  return (300);
  case 8: 
#line 89
  return (600);
  case 9: 
#line 91
  return (1200);
  case 10: 
#line 93
  return (1800);
  case 11: 
#line 95
  return (2400);
  case 12: 
#line 97
  return (4800);
  case 13: 
#line 99
  return (9600);
  case 14: 
#line 103
  return (19200);
  case 15: 
#line 113
  return (38400);
  case 4097: 
#line 135
  return (57600);
  case 4098: 
#line 143
  return (115200);
  case 4099: 
#line 147
  return (230400);
  default: ;
#line 150
  return (9600);
  }
}
}
#line 157 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 160
  switch (baud) {
  case 0: 
#line 162
  return (0U);
  case 50: 
#line 164
  return (1U);
  case 75: 
#line 166
  return (2U);
  case 110: 
#line 168
  return (3U);
  case 134: 
#line 170
  return (4U);
  case 150: 
#line 172
  return (5U);
  case 200: 
#line 174
  return (6U);
  case 300: 
#line 176
  return (7U);
  case 600: 
#line 178
  return (8U);
  case 1200: 
#line 180
  return (9U);
  case 1800: 
#line 182
  return (10U);
  case 2400: 
#line 184
  return (11U);
  case 4800: 
#line 186
  return (12U);
  case 9600: 
#line 188
  return (13U);
  case 19200: 
#line 192
  return (14U);
  case 38400: 
#line 202
  return (15U);
  case 57600: 
#line 224
  return (4097U);
  case 115200: 
#line 232
  return (4098U);
  case 230400: 
#line 236
  return (4099U);
  default: ;
#line 239
  return (13U);
  }
}
}
#line 248 "ttymodes.c"
void tty_make_modes(int fd , struct termios *tiop ) 
{ struct termios tio ;
  int baud ;
  Buffer buf___2 ;
  int tty_op_ospeed ;
  int tty_op_ispeed ;
  void (*put_arg)(Buffer * , u_int  ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;
  u_int tmp___4 ;
  char *tmp___5 ;
  u_int tmp___6 ;
  char *tmp___7 ;

  {
#line 257
  buffer_init(& buf___2);
#line 258
  if (compat20) {
#line 259
    tty_op_ospeed = 129;
#line 260
    tty_op_ispeed = 128;
#line 261
    put_arg = & buffer_put_int;
  } else {
#line 263
    tty_op_ospeed = 193;
#line 264
    tty_op_ispeed = 192;
#line 265
    put_arg = (void (*)(Buffer * , u_int  ))(& buffer_put_char);
  }
#line 268
  if ((unsigned int )tiop == (unsigned int )((void *)0)) {
#line 269
    tmp___1 = tcgetattr(fd, & tio);
#line 269
    if (tmp___1 == -1) {
#line 270
      tmp = __errno_location();
#line 270
      tmp___0 = strerror(*tmp);
#line 270
      log("tcgetattr: %.100s", tmp___0);
      goto end;
    }
  } else {
#line 274
    tio = *tiop;
  }
#line 277
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 277
  baud = speed_to_baud(tmp___2);
#line 278
  debug3("tty_make_modes: ospeed %d", baud);
#line 279
  buffer_put_char(& buf___2, tty_op_ospeed);
#line 280
  buffer_put_int(& buf___2, (unsigned int )baud);
#line 281
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 281
  baud = speed_to_baud(tmp___3);
#line 282
  debug3("tty_make_modes: ispeed %d", baud);
#line 283
  buffer_put_char(& buf___2, tty_op_ispeed);
#line 284
  buffer_put_int(& buf___2, (unsigned int )baud);
#line 69 "ttymodes.h"
  debug3("tty_make_modes: %d %d", 1, tio.c_cc[0]);
#line 69
  buffer_put_char(& buf___2, 1);
#line 69
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[0]);
#line 70
  debug3("tty_make_modes: %d %d", 2, tio.c_cc[1]);
#line 70
  buffer_put_char(& buf___2, 2);
#line 70
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[1]);
#line 71
  debug3("tty_make_modes: %d %d", 3, tio.c_cc[2]);
#line 71
  buffer_put_char(& buf___2, 3);
#line 71
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[2]);
#line 73
  debug3("tty_make_modes: %d %d", 4, tio.c_cc[3]);
#line 73
  buffer_put_char(& buf___2, 4);
#line 73
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[3]);
#line 75
  debug3("tty_make_modes: %d %d", 5, tio.c_cc[4]);
#line 75
  buffer_put_char(& buf___2, 5);
#line 75
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[4]);
#line 77
  debug3("tty_make_modes: %d %d", 6, tio.c_cc[11]);
#line 77
  buffer_put_char(& buf___2, 6);
#line 77
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[11]);
#line 80
  debug3("tty_make_modes: %d %d", 7, tio.c_cc[16]);
#line 80
  buffer_put_char(& buf___2, 7);
#line 80
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[16]);
#line 82
  debug3("tty_make_modes: %d %d", 8, tio.c_cc[8]);
#line 82
  buffer_put_char(& buf___2, 8);
#line 82
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[8]);
#line 83
  debug3("tty_make_modes: %d %d", 9, tio.c_cc[9]);
#line 83
  buffer_put_char(& buf___2, 9);
#line 83
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[9]);
#line 85
  debug3("tty_make_modes: %d %d", 10, tio.c_cc[10]);
#line 85
  buffer_put_char(& buf___2, 10);
#line 85
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[10]);
#line 91
  debug3("tty_make_modes: %d %d", 12, tio.c_cc[12]);
#line 91
  buffer_put_char(& buf___2, 12);
#line 91
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[12]);
#line 94
  debug3("tty_make_modes: %d %d", 13, tio.c_cc[14]);
#line 94
  buffer_put_char(& buf___2, 13);
#line 94
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[14]);
#line 97
  debug3("tty_make_modes: %d %d", 14, tio.c_cc[15]);
#line 97
  buffer_put_char(& buf___2, 14);
#line 97
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[15]);
#line 109
  debug3("tty_make_modes: %d %d", 18, tio.c_cc[13]);
#line 109
  buffer_put_char(& buf___2, 18);
#line 109
  (*put_arg)(& buf___2, (unsigned int )tio.c_cc[13]);
#line 113
  debug3("tty_make_modes: %d %d", 30, (tio.c_iflag & 4U) != 0U);
#line 113
  buffer_put_char(& buf___2, 30);
#line 113
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 4U) != 0U));
#line 114
  debug3("tty_make_modes: %d %d", 31, (tio.c_iflag & 8U) != 0U);
#line 114
  buffer_put_char(& buf___2, 31);
#line 114
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 8U) != 0U));
#line 115
  debug3("tty_make_modes: %d %d", 32, (tio.c_iflag & 16U) != 0U);
#line 115
  buffer_put_char(& buf___2, 32);
#line 115
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 16U) != 0U));
#line 116
  debug3("tty_make_modes: %d %d", 33, (tio.c_iflag & 32U) != 0U);
#line 116
  buffer_put_char(& buf___2, 33);
#line 116
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 32U) != 0U));
#line 117
  debug3("tty_make_modes: %d %d", 34, (tio.c_iflag & 64U) != 0U);
#line 117
  buffer_put_char(& buf___2, 34);
#line 117
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 64U) != 0U));
#line 118
  debug3("tty_make_modes: %d %d", 35, (tio.c_iflag & 128U) != 0U);
#line 118
  buffer_put_char(& buf___2, 35);
#line 118
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 128U) != 0U));
#line 119
  debug3("tty_make_modes: %d %d", 36, (tio.c_iflag & 256U) != 0U);
#line 119
  buffer_put_char(& buf___2, 36);
#line 119
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 256U) != 0U));
#line 121
  debug3("tty_make_modes: %d %d", 37, (tio.c_iflag & 512U) != 0U);
#line 121
  buffer_put_char(& buf___2, 37);
#line 121
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 512U) != 0U));
#line 123
  debug3("tty_make_modes: %d %d", 38, (tio.c_iflag & 1024U) != 0U);
#line 123
  buffer_put_char(& buf___2, 38);
#line 123
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 1024U) != 0U));
#line 124
  debug3("tty_make_modes: %d %d", 39, (tio.c_iflag & 2048U) != 0U);
#line 124
  buffer_put_char(& buf___2, 39);
#line 124
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 2048U) != 0U));
#line 125
  debug3("tty_make_modes: %d %d", 40, (tio.c_iflag & 4096U) != 0U);
#line 125
  buffer_put_char(& buf___2, 40);
#line 125
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 4096U) != 0U));
#line 127
  debug3("tty_make_modes: %d %d", 41, (tio.c_iflag & 8192U) != 0U);
#line 127
  buffer_put_char(& buf___2, 41);
#line 127
  (*put_arg)(& buf___2, (unsigned int )((tio.c_iflag & 8192U) != 0U));
#line 130
  debug3("tty_make_modes: %d %d", 50, (tio.c_lflag & 1U) != 0U);
#line 130
  buffer_put_char(& buf___2, 50);
#line 130
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 1U) != 0U));
#line 131
  debug3("tty_make_modes: %d %d", 51, (tio.c_lflag & 2U) != 0U);
#line 131
  buffer_put_char(& buf___2, 51);
#line 131
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 2U) != 0U));
#line 133
  debug3("tty_make_modes: %d %d", 52, (tio.c_lflag & 4U) != 0U);
#line 133
  buffer_put_char(& buf___2, 52);
#line 133
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 4U) != 0U));
#line 135
  debug3("tty_make_modes: %d %d", 53, (tio.c_lflag & 8U) != 0U);
#line 135
  buffer_put_char(& buf___2, 53);
#line 135
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 8U) != 0U));
#line 136
  debug3("tty_make_modes: %d %d", 54, (tio.c_lflag & 16U) != 0U);
#line 136
  buffer_put_char(& buf___2, 54);
#line 136
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 16U) != 0U));
#line 137
  debug3("tty_make_modes: %d %d", 55, (tio.c_lflag & 32U) != 0U);
#line 137
  buffer_put_char(& buf___2, 55);
#line 137
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 32U) != 0U));
#line 138
  debug3("tty_make_modes: %d %d", 56, (tio.c_lflag & 64U) != 0U);
#line 138
  buffer_put_char(& buf___2, 56);
#line 138
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 64U) != 0U));
#line 139
  debug3("tty_make_modes: %d %d", 57, (tio.c_lflag & 128U) != 0U);
#line 139
  buffer_put_char(& buf___2, 57);
#line 139
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 128U) != 0U));
#line 140
  debug3("tty_make_modes: %d %d", 58, (tio.c_lflag & 256U) != 0U);
#line 140
  buffer_put_char(& buf___2, 58);
#line 140
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 256U) != 0U));
#line 142
  debug3("tty_make_modes: %d %d", 59, (tio.c_lflag & 32768U) != 0U);
#line 142
  buffer_put_char(& buf___2, 59);
#line 142
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 32768U) != 0U));
#line 145
  debug3("tty_make_modes: %d %d", 60, (tio.c_lflag & 512U) != 0U);
#line 145
  buffer_put_char(& buf___2, 60);
#line 145
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 512U) != 0U));
#line 148
  debug3("tty_make_modes: %d %d", 61, (tio.c_lflag & 2048U) != 0U);
#line 148
  buffer_put_char(& buf___2, 61);
#line 148
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 2048U) != 0U));
#line 151
  debug3("tty_make_modes: %d %d", 62, (tio.c_lflag & 16384U) != 0U);
#line 151
  buffer_put_char(& buf___2, 62);
#line 151
  (*put_arg)(& buf___2, (unsigned int )((tio.c_lflag & 16384U) != 0U));
#line 154
  debug3("tty_make_modes: %d %d", 70, (tio.c_oflag & 1U) != 0U);
#line 154
  buffer_put_char(& buf___2, 70);
#line 154
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 1U) != 0U));
#line 156
  debug3("tty_make_modes: %d %d", 71, (tio.c_oflag & 2U) != 0U);
#line 156
  buffer_put_char(& buf___2, 71);
#line 156
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 2U) != 0U));
#line 158
  debug3("tty_make_modes: %d %d", 72, (tio.c_oflag & 4U) != 0U);
#line 158
  buffer_put_char(& buf___2, 72);
#line 158
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 4U) != 0U));
#line 160
  debug3("tty_make_modes: %d %d", 73, (tio.c_oflag & 8U) != 0U);
#line 160
  buffer_put_char(& buf___2, 73);
#line 160
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 8U) != 0U));
#line 163
  debug3("tty_make_modes: %d %d", 74, (tio.c_oflag & 16U) != 0U);
#line 163
  buffer_put_char(& buf___2, 74);
#line 163
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 16U) != 0U));
#line 166
  debug3("tty_make_modes: %d %d", 75, (tio.c_oflag & 32U) != 0U);
#line 166
  buffer_put_char(& buf___2, 75);
#line 166
  (*put_arg)(& buf___2, (unsigned int )((tio.c_oflag & 32U) != 0U));
#line 169
  debug3("tty_make_modes: %d %d", 90, (tio.c_cflag & 32U) != 0U);
#line 169
  buffer_put_char(& buf___2, 90);
#line 169
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 32U) != 0U));
#line 170
  debug3("tty_make_modes: %d %d", 91, (tio.c_cflag & 48U) != 0U);
#line 170
  buffer_put_char(& buf___2, 91);
#line 170
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 48U) != 0U));
#line 171
  debug3("tty_make_modes: %d %d", 92, (tio.c_cflag & 256U) != 0U);
#line 171
  buffer_put_char(& buf___2, 92);
#line 171
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 256U) != 0U));
#line 172
  debug3("tty_make_modes: %d %d", 93, (tio.c_cflag & 512U) != 0U);
#line 172
  buffer_put_char(& buf___2, 93);
#line 172
  (*put_arg)(& buf___2, (unsigned int )((tio.c_cflag & 512U) != 0U));
  end: 
#line 304 "ttymodes.c"
  buffer_put_char(& buf___2, 0);
#line 305
  if (compat20) {
#line 306
    tmp___4 = buffer_len(& buf___2);
#line 306
    tmp___5 = buffer_ptr(& buf___2);
#line 306
    packet_put_string((char const   *)tmp___5, tmp___4);
  } else {
#line 308
    tmp___6 = buffer_len(& buf___2);
#line 308
    tmp___7 = buffer_ptr(& buf___2);
#line 308
    packet_put_raw((char const   *)tmp___7, tmp___6);
  }
#line 309
  buffer_free(& buf___2);
#line 310
  return;
}
}
#line 317 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  u_int (*get_arg)(void) ;
  int arg ;
  int arg_size ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  speed_t tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  u_int tmp___56 ;
  u_int tmp___57 ;
  u_int tmp___58 ;
  int _p ;
  int _e ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
#line 322
  n_bytes = 0;
#line 323
  failure = 0;
#line 327
  if (compat20) {
#line 328
    tmp = packet_get_int();
#line 328
    *n_bytes_ptr = (int )tmp;
#line 329
    debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
#line 330
    if (*n_bytes_ptr == 0) {
#line 331
      return;
    }
#line 332
    get_arg = & packet_get_int;
#line 333
    arg_size = 4;
  } else {
#line 335
    get_arg = & packet_get_char;
#line 336
    arg_size = 1;
  }
#line 344
  tmp___2 = tcgetattr(fd, & tio);
#line 344
  if (tmp___2 == -1) {
#line 345
    tmp___0 = __errno_location();
#line 345
    tmp___1 = strerror(*tmp___0);
#line 345
    log("tcgetattr: %.100s", tmp___1);
#line 346
    failure = -1;
  }
#line 349
  while (1) {
#line 350
    n_bytes ++;
#line 351
    tmp___3 = packet_get_char();
#line 351
    opcode = (int )tmp___3;
#line 352
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
    case 128: 
#line 359
    n_bytes += 4;
#line 360
    tmp___4 = packet_get_int();
#line 360
    baud = (int )tmp___4;
#line 361
    debug3("tty_parse_modes: ispeed %d", baud);
#line 362
    if (failure != -1) {
#line 362
      tmp___5 = baud_to_speed(baud);
#line 362
      tmp___6 = cfsetispeed(& tio, tmp___5);
#line 362
      if (tmp___6 == -1) {
#line 363
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 364
    break;
    case 193: 
    case 129: 
#line 369
    n_bytes += 4;
#line 370
    tmp___7 = packet_get_int();
#line 370
    baud = (int )tmp___7;
#line 371
    debug3("tty_parse_modes: ospeed %d", baud);
#line 372
    if (failure != -1) {
#line 372
      tmp___8 = baud_to_speed(baud);
#line 372
      tmp___9 = cfsetospeed(& tio, tmp___8);
#line 372
      if (tmp___9 == -1) {
#line 373
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 374
    break;
    case 1: 
#line 69 "ttymodes.h"
    n_bytes += arg_size;
#line 69
    tmp___10 = (*get_arg)();
#line 69
    tio.c_cc[0] = (unsigned char )tmp___10;
#line 69
    debug3("tty_parse_modes: %d %d", 1, tio.c_cc[0]);
#line 69
    break;
    case 2: 
#line 70
    n_bytes += arg_size;
#line 70
    tmp___11 = (*get_arg)();
#line 70
    tio.c_cc[1] = (unsigned char )tmp___11;
#line 70
    debug3("tty_parse_modes: %d %d", 2, tio.c_cc[1]);
#line 70
    break;
    case 3: 
#line 71
    n_bytes += arg_size;
#line 71
    tmp___12 = (*get_arg)();
#line 71
    tio.c_cc[2] = (unsigned char )tmp___12;
#line 71
    debug3("tty_parse_modes: %d %d", 3, tio.c_cc[2]);
#line 71
    break;
    case 4: 
#line 73
    n_bytes += arg_size;
#line 73
    tmp___13 = (*get_arg)();
#line 73
    tio.c_cc[3] = (unsigned char )tmp___13;
#line 73
    debug3("tty_parse_modes: %d %d", 4, tio.c_cc[3]);
#line 73
    break;
    case 5: 
#line 75
    n_bytes += arg_size;
#line 75
    tmp___14 = (*get_arg)();
#line 75
    tio.c_cc[4] = (unsigned char )tmp___14;
#line 75
    debug3("tty_parse_modes: %d %d", 5, tio.c_cc[4]);
#line 75
    break;
    case 6: 
#line 77
    n_bytes += arg_size;
#line 77
    tmp___15 = (*get_arg)();
#line 77
    tio.c_cc[11] = (unsigned char )tmp___15;
#line 77
    debug3("tty_parse_modes: %d %d", 6, tio.c_cc[11]);
#line 77
    break;
    case 7: 
#line 80
    n_bytes += arg_size;
#line 80
    tmp___16 = (*get_arg)();
#line 80
    tio.c_cc[16] = (unsigned char )tmp___16;
#line 80
    debug3("tty_parse_modes: %d %d", 7, tio.c_cc[16]);
#line 80
    break;
    case 8: 
#line 82
    n_bytes += arg_size;
#line 82
    tmp___17 = (*get_arg)();
#line 82
    tio.c_cc[8] = (unsigned char )tmp___17;
#line 82
    debug3("tty_parse_modes: %d %d", 8, tio.c_cc[8]);
#line 82
    break;
    case 9: 
#line 83
    n_bytes += arg_size;
#line 83
    tmp___18 = (*get_arg)();
#line 83
    tio.c_cc[9] = (unsigned char )tmp___18;
#line 83
    debug3("tty_parse_modes: %d %d", 9, tio.c_cc[9]);
#line 83
    break;
    case 10: 
#line 85
    n_bytes += arg_size;
#line 85
    tmp___19 = (*get_arg)();
#line 85
    tio.c_cc[10] = (unsigned char )tmp___19;
#line 85
    debug3("tty_parse_modes: %d %d", 10, tio.c_cc[10]);
#line 85
    break;
    case 12: 
#line 91
    n_bytes += arg_size;
#line 91
    tmp___20 = (*get_arg)();
#line 91
    tio.c_cc[12] = (unsigned char )tmp___20;
#line 91
    debug3("tty_parse_modes: %d %d", 12, tio.c_cc[12]);
#line 91
    break;
    case 13: 
#line 94
    n_bytes += arg_size;
#line 94
    tmp___21 = (*get_arg)();
#line 94
    tio.c_cc[14] = (unsigned char )tmp___21;
#line 94
    debug3("tty_parse_modes: %d %d", 13, tio.c_cc[14]);
#line 94
    break;
    case 14: 
#line 97
    n_bytes += arg_size;
#line 97
    tmp___22 = (*get_arg)();
#line 97
    tio.c_cc[15] = (unsigned char )tmp___22;
#line 97
    debug3("tty_parse_modes: %d %d", 14, tio.c_cc[15]);
#line 97
    break;
    case 18: 
#line 109
    n_bytes += arg_size;
#line 109
    tmp___23 = (*get_arg)();
#line 109
    tio.c_cc[13] = (unsigned char )tmp___23;
#line 109
    debug3("tty_parse_modes: %d %d", 18, tio.c_cc[13]);
#line 109
    break;
    case 30: 
#line 113
    n_bytes += arg_size;
#line 113
    tmp___24 = (*get_arg)();
#line 113
    arg = (int )tmp___24;
#line 113
    if (arg) {
#line 113
      tio.c_iflag |= 4U;
    } else {
#line 113
      tio.c_iflag &= 4294967291U;
    }
#line 113
    debug3("tty_parse_modes: %d %d", 30, arg);
#line 113
    break;
    case 31: 
#line 114
    n_bytes += arg_size;
#line 114
    tmp___25 = (*get_arg)();
#line 114
    arg = (int )tmp___25;
#line 114
    if (arg) {
#line 114
      tio.c_iflag |= 8U;
    } else {
#line 114
      tio.c_iflag &= 4294967287U;
    }
#line 114
    debug3("tty_parse_modes: %d %d", 31, arg);
#line 114
    break;
    case 32: 
#line 115
    n_bytes += arg_size;
#line 115
    tmp___26 = (*get_arg)();
#line 115
    arg = (int )tmp___26;
#line 115
    if (arg) {
#line 115
      tio.c_iflag |= 16U;
    } else {
#line 115
      tio.c_iflag &= 4294967279U;
    }
#line 115
    debug3("tty_parse_modes: %d %d", 32, arg);
#line 115
    break;
    case 33: 
#line 116
    n_bytes += arg_size;
#line 116
    tmp___27 = (*get_arg)();
#line 116
    arg = (int )tmp___27;
#line 116
    if (arg) {
#line 116
      tio.c_iflag |= 32U;
    } else {
#line 116
      tio.c_iflag &= 4294967263U;
    }
#line 116
    debug3("tty_parse_modes: %d %d", 33, arg);
#line 116
    break;
    case 34: 
#line 117
    n_bytes += arg_size;
#line 117
    tmp___28 = (*get_arg)();
#line 117
    arg = (int )tmp___28;
#line 117
    if (arg) {
#line 117
      tio.c_iflag |= 64U;
    } else {
#line 117
      tio.c_iflag &= 4294967231U;
    }
#line 117
    debug3("tty_parse_modes: %d %d", 34, arg);
#line 117
    break;
    case 35: 
#line 118
    n_bytes += arg_size;
#line 118
    tmp___29 = (*get_arg)();
#line 118
    arg = (int )tmp___29;
#line 118
    if (arg) {
#line 118
      tio.c_iflag |= 128U;
    } else {
#line 118
      tio.c_iflag &= 4294967167U;
    }
#line 118
    debug3("tty_parse_modes: %d %d", 35, arg);
#line 118
    break;
    case 36: 
#line 119
    n_bytes += arg_size;
#line 119
    tmp___30 = (*get_arg)();
#line 119
    arg = (int )tmp___30;
#line 119
    if (arg) {
#line 119
      tio.c_iflag |= 256U;
    } else {
#line 119
      tio.c_iflag &= 4294967039U;
    }
#line 119
    debug3("tty_parse_modes: %d %d", 36, arg);
#line 119
    break;
    case 37: 
#line 121
    n_bytes += arg_size;
#line 121
    tmp___31 = (*get_arg)();
#line 121
    arg = (int )tmp___31;
#line 121
    if (arg) {
#line 121
      tio.c_iflag |= 512U;
    } else {
#line 121
      tio.c_iflag &= 4294966783U;
    }
#line 121
    debug3("tty_parse_modes: %d %d", 37, arg);
#line 121
    break;
    case 38: 
#line 123
    n_bytes += arg_size;
#line 123
    tmp___32 = (*get_arg)();
#line 123
    arg = (int )tmp___32;
#line 123
    if (arg) {
#line 123
      tio.c_iflag |= 1024U;
    } else {
#line 123
      tio.c_iflag &= 4294966271U;
    }
#line 123
    debug3("tty_parse_modes: %d %d", 38, arg);
#line 123
    break;
    case 39: 
#line 124
    n_bytes += arg_size;
#line 124
    tmp___33 = (*get_arg)();
#line 124
    arg = (int )tmp___33;
#line 124
    if (arg) {
#line 124
      tio.c_iflag |= 2048U;
    } else {
#line 124
      tio.c_iflag &= 4294965247U;
    }
#line 124
    debug3("tty_parse_modes: %d %d", 39, arg);
#line 124
    break;
    case 40: 
#line 125
    n_bytes += arg_size;
#line 125
    tmp___34 = (*get_arg)();
#line 125
    arg = (int )tmp___34;
#line 125
    if (arg) {
#line 125
      tio.c_iflag |= 4096U;
    } else {
#line 125
      tio.c_iflag &= 4294963199U;
    }
#line 125
    debug3("tty_parse_modes: %d %d", 40, arg);
#line 125
    break;
    case 41: 
#line 127
    n_bytes += arg_size;
#line 127
    tmp___35 = (*get_arg)();
#line 127
    arg = (int )tmp___35;
#line 127
    if (arg) {
#line 127
      tio.c_iflag |= 8192U;
    } else {
#line 127
      tio.c_iflag &= 4294959103U;
    }
#line 127
    debug3("tty_parse_modes: %d %d", 41, arg);
#line 127
    break;
    case 50: 
#line 130
    n_bytes += arg_size;
#line 130
    tmp___36 = (*get_arg)();
#line 130
    arg = (int )tmp___36;
#line 130
    if (arg) {
#line 130
      tio.c_lflag |= 1U;
    } else {
#line 130
      tio.c_lflag &= 4294967294U;
    }
#line 130
    debug3("tty_parse_modes: %d %d", 50, arg);
#line 130
    break;
    case 51: 
#line 131
    n_bytes += arg_size;
#line 131
    tmp___37 = (*get_arg)();
#line 131
    arg = (int )tmp___37;
#line 131
    if (arg) {
#line 131
      tio.c_lflag |= 2U;
    } else {
#line 131
      tio.c_lflag &= 4294967293U;
    }
#line 131
    debug3("tty_parse_modes: %d %d", 51, arg);
#line 131
    break;
    case 52: 
#line 133
    n_bytes += arg_size;
#line 133
    tmp___38 = (*get_arg)();
#line 133
    arg = (int )tmp___38;
#line 133
    if (arg) {
#line 133
      tio.c_lflag |= 4U;
    } else {
#line 133
      tio.c_lflag &= 4294967291U;
    }
#line 133
    debug3("tty_parse_modes: %d %d", 52, arg);
#line 133
    break;
    case 53: 
#line 135
    n_bytes += arg_size;
#line 135
    tmp___39 = (*get_arg)();
#line 135
    arg = (int )tmp___39;
#line 135
    if (arg) {
#line 135
      tio.c_lflag |= 8U;
    } else {
#line 135
      tio.c_lflag &= 4294967287U;
    }
#line 135
    debug3("tty_parse_modes: %d %d", 53, arg);
#line 135
    break;
    case 54: 
#line 136
    n_bytes += arg_size;
#line 136
    tmp___40 = (*get_arg)();
#line 136
    arg = (int )tmp___40;
#line 136
    if (arg) {
#line 136
      tio.c_lflag |= 16U;
    } else {
#line 136
      tio.c_lflag &= 4294967279U;
    }
#line 136
    debug3("tty_parse_modes: %d %d", 54, arg);
#line 136
    break;
    case 55: 
#line 137
    n_bytes += arg_size;
#line 137
    tmp___41 = (*get_arg)();
#line 137
    arg = (int )tmp___41;
#line 137
    if (arg) {
#line 137
      tio.c_lflag |= 32U;
    } else {
#line 137
      tio.c_lflag &= 4294967263U;
    }
#line 137
    debug3("tty_parse_modes: %d %d", 55, arg);
#line 137
    break;
    case 56: 
#line 138
    n_bytes += arg_size;
#line 138
    tmp___42 = (*get_arg)();
#line 138
    arg = (int )tmp___42;
#line 138
    if (arg) {
#line 138
      tio.c_lflag |= 64U;
    } else {
#line 138
      tio.c_lflag &= 4294967231U;
    }
#line 138
    debug3("tty_parse_modes: %d %d", 56, arg);
#line 138
    break;
    case 57: 
#line 139
    n_bytes += arg_size;
#line 139
    tmp___43 = (*get_arg)();
#line 139
    arg = (int )tmp___43;
#line 139
    if (arg) {
#line 139
      tio.c_lflag |= 128U;
    } else {
#line 139
      tio.c_lflag &= 4294967167U;
    }
#line 139
    debug3("tty_parse_modes: %d %d", 57, arg);
#line 139
    break;
    case 58: 
#line 140
    n_bytes += arg_size;
#line 140
    tmp___44 = (*get_arg)();
#line 140
    arg = (int )tmp___44;
#line 140
    if (arg) {
#line 140
      tio.c_lflag |= 256U;
    } else {
#line 140
      tio.c_lflag &= 4294967039U;
    }
#line 140
    debug3("tty_parse_modes: %d %d", 58, arg);
#line 140
    break;
    case 59: 
#line 142
    n_bytes += arg_size;
#line 142
    tmp___45 = (*get_arg)();
#line 142
    arg = (int )tmp___45;
#line 142
    if (arg) {
#line 142
      tio.c_lflag |= 32768U;
    } else {
#line 142
      tio.c_lflag &= 4294934527U;
    }
#line 142
    debug3("tty_parse_modes: %d %d", 59, arg);
#line 142
    break;
    case 60: 
#line 145
    n_bytes += arg_size;
#line 145
    tmp___46 = (*get_arg)();
#line 145
    arg = (int )tmp___46;
#line 145
    if (arg) {
#line 145
      tio.c_lflag |= 512U;
    } else {
#line 145
      tio.c_lflag &= 4294966783U;
    }
#line 145
    debug3("tty_parse_modes: %d %d", 60, arg);
#line 145
    break;
    case 61: 
#line 148
    n_bytes += arg_size;
#line 148
    tmp___47 = (*get_arg)();
#line 148
    arg = (int )tmp___47;
#line 148
    if (arg) {
#line 148
      tio.c_lflag |= 2048U;
    } else {
#line 148
      tio.c_lflag &= 4294965247U;
    }
#line 148
    debug3("tty_parse_modes: %d %d", 61, arg);
#line 148
    break;
    case 62: 
#line 151
    n_bytes += arg_size;
#line 151
    tmp___48 = (*get_arg)();
#line 151
    arg = (int )tmp___48;
#line 151
    if (arg) {
#line 151
      tio.c_lflag |= 16384U;
    } else {
#line 151
      tio.c_lflag &= 4294950911U;
    }
#line 151
    debug3("tty_parse_modes: %d %d", 62, arg);
#line 151
    break;
    case 70: 
#line 154
    n_bytes += arg_size;
#line 154
    tmp___49 = (*get_arg)();
#line 154
    arg = (int )tmp___49;
#line 154
    if (arg) {
#line 154
      tio.c_oflag |= 1U;
    } else {
#line 154
      tio.c_oflag &= 4294967294U;
    }
#line 154
    debug3("tty_parse_modes: %d %d", 70, arg);
#line 154
    break;
    case 71: 
#line 156
    n_bytes += arg_size;
#line 156
    tmp___50 = (*get_arg)();
#line 156
    arg = (int )tmp___50;
#line 156
    if (arg) {
#line 156
      tio.c_oflag |= 2U;
    } else {
#line 156
      tio.c_oflag &= 4294967293U;
    }
#line 156
    debug3("tty_parse_modes: %d %d", 71, arg);
#line 156
    break;
    case 72: 
#line 158
    n_bytes += arg_size;
#line 158
    tmp___51 = (*get_arg)();
#line 158
    arg = (int )tmp___51;
#line 158
    if (arg) {
#line 158
      tio.c_oflag |= 4U;
    } else {
#line 158
      tio.c_oflag &= 4294967291U;
    }
#line 158
    debug3("tty_parse_modes: %d %d", 72, arg);
#line 158
    break;
    case 73: 
#line 160
    n_bytes += arg_size;
#line 160
    tmp___52 = (*get_arg)();
#line 160
    arg = (int )tmp___52;
#line 160
    if (arg) {
#line 160
      tio.c_oflag |= 8U;
    } else {
#line 160
      tio.c_oflag &= 4294967287U;
    }
#line 160
    debug3("tty_parse_modes: %d %d", 73, arg);
#line 160
    break;
    case 74: 
#line 163
    n_bytes += arg_size;
#line 163
    tmp___53 = (*get_arg)();
#line 163
    arg = (int )tmp___53;
#line 163
    if (arg) {
#line 163
      tio.c_oflag |= 16U;
    } else {
#line 163
      tio.c_oflag &= 4294967279U;
    }
#line 163
    debug3("tty_parse_modes: %d %d", 74, arg);
#line 163
    break;
    case 75: 
#line 166
    n_bytes += arg_size;
#line 166
    tmp___54 = (*get_arg)();
#line 166
    arg = (int )tmp___54;
#line 166
    if (arg) {
#line 166
      tio.c_oflag |= 32U;
    } else {
#line 166
      tio.c_oflag &= 4294967263U;
    }
#line 166
    debug3("tty_parse_modes: %d %d", 75, arg);
#line 166
    break;
    case 90: 
#line 169
    n_bytes += arg_size;
#line 169
    tmp___55 = (*get_arg)();
#line 169
    arg = (int )tmp___55;
#line 169
    if (arg) {
#line 169
      tio.c_cflag |= 32U;
    } else {
#line 169
      tio.c_cflag &= 4294967263U;
    }
#line 169
    debug3("tty_parse_modes: %d %d", 90, arg);
#line 169
    break;
    case 91: 
#line 170
    n_bytes += arg_size;
#line 170
    tmp___56 = (*get_arg)();
#line 170
    arg = (int )tmp___56;
#line 170
    if (arg) {
#line 170
      tio.c_cflag |= 48U;
    } else {
#line 170
      tio.c_cflag &= 4294967247U;
    }
#line 170
    debug3("tty_parse_modes: %d %d", 91, arg);
#line 170
    break;
    case 92: 
#line 171
    n_bytes += arg_size;
#line 171
    tmp___57 = (*get_arg)();
#line 171
    arg = (int )tmp___57;
#line 171
    if (arg) {
#line 171
      tio.c_cflag |= 256U;
    } else {
#line 171
      tio.c_cflag &= 4294967039U;
    }
#line 171
    debug3("tty_parse_modes: %d %d", 92, arg);
#line 171
    break;
    case 93: 
#line 172
    n_bytes += arg_size;
#line 172
    tmp___58 = (*get_arg)();
#line 172
    arg = (int )tmp___58;
#line 172
    if (arg) {
#line 172
      tio.c_cflag |= 512U;
    } else {
#line 172
      tio.c_cflag &= 4294966783U;
    }
#line 172
    debug3("tty_parse_modes: %d %d", 93, arg);
#line 172
    break;
    default: 
#line 398 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 400
    if (! compat20) {
#line 408
      if (opcode > 0) {
#line 408
        if (opcode < 128) {
#line 409
          n_bytes ++;
#line 410
          packet_get_char();
#line 411
          break;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 412
        if (opcode >= 128) {
#line 412
          if (opcode < 160) {
#line 413
            n_bytes += 4;
#line 414
            packet_get_int();
#line 415
            break;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 424
          log("parse_tty_modes: unknown opcode %d", opcode);
#line 425
          while (1) {
#line 425
            _p = 0;
#line 425
            _e = 1;
#line 425
            if (_p != _e) {
#line 425
              log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c",
                  425);
#line 425
              packet_disconnect("Packet integrity error. (%d)", 10);
            }
#line 425
            break;
          }
          goto set;
        }
      }
    } else {
#line 436
      if (opcode > 0) {
#line 436
        if (opcode < 160) {
#line 437
          n_bytes += 4;
#line 438
          packet_get_int();
#line 439
          break;
        } else {
#line 441
          log("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      } else {
#line 441
        log("parse_tty_modes: unknown opcode %d", opcode);
        goto set;
      }
    }
    }
  }
  set: 
#line 449
  if (*n_bytes_ptr != n_bytes) {
#line 450
    *n_bytes_ptr = n_bytes;
#line 451
    log("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d", *n_bytes_ptr, n_bytes);
#line 453
    return;
  }
#line 455
  if (failure == -1) {
#line 456
    return;
  }
#line 459
  tmp___61 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 459
  if (tmp___61 == -1) {
#line 460
    tmp___59 = __errno_location();
#line 460
    tmp___60 = strerror(*tmp___59);
#line 460
    log("Setting tty modes failed: %.100s", tmp___60);
  }
#line 461
  return;
}
}
#line 1 "uidswap.o"
#line 651 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 20 "uidswap.h"
void permanently_set_uid(struct passwd *pw ) ;
#line 34 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 35 "uidswap.c"
static gid_t saved_egid  =    (gid_t )0;
#line 39 "uidswap.c"
static int privileged  =    0;
#line 40 "uidswap.c"
static int temporarily_use_uid_effective  =    0;
#line 41 "uidswap.c"
static gid_t saved_egroups[65536]  ;
#line 41 "uidswap.c"
static gid_t user_groups[65536]  ;
#line 42 "uidswap.c"
static int saved_egroupslen  =    -1;
#line 42 "uidswap.c"
static int user_groupslen  =    -1;
#line 48 "uidswap.c"
void temporarily_use_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 53
  saved_euid = geteuid();
#line 54
  saved_egid = getegid();
#line 55
  debug("temporarily_use_uid: %d/%d (e=%d)", pw->pw_uid, pw->pw_gid, saved_euid);
#line 57
  if (saved_euid != 0U) {
#line 58
    privileged = 0;
#line 59
    return;
  }
#line 68
  privileged = 1;
#line 69
  temporarily_use_uid_effective = 1;
#line 70
  saved_egroupslen = getgroups(65536, saved_egroups);
#line 71
  if (saved_egroupslen < 0) {
#line 72
    tmp = __errno_location();
#line 72
    tmp___0 = strerror(*tmp);
#line 72
    fatal("getgroups: %.100s", tmp___0);
  }
#line 75
  if (user_groupslen == -1) {
#line 76
    tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 76
    if (tmp___3 < 0) {
#line 77
      tmp___1 = __errno_location();
#line 77
      tmp___2 = strerror(*tmp___1);
#line 77
      fatal("initgroups: %s: %.100s", pw->pw_name, tmp___2);
    }
#line 79
    user_groupslen = getgroups(65536, user_groups);
#line 80
    if (user_groupslen < 0) {
#line 81
      tmp___4 = __errno_location();
#line 81
      tmp___5 = strerror(*tmp___4);
#line 81
      fatal("getgroups: %.100s", tmp___5);
    }
  }
#line 85
  tmp___8 = setgroups((unsigned int )user_groupslen, (__gid_t const   *)(user_groups));
#line 85
  if (tmp___8 < 0) {
#line 86
    tmp___6 = __errno_location();
#line 86
    tmp___7 = strerror(*tmp___6);
#line 86
    fatal("setgroups: %.100s", tmp___7);
  }
#line 96
  tmp___11 = setegid(pw->pw_gid);
#line 96
  if (tmp___11 < 0) {
#line 97
    tmp___9 = __errno_location();
#line 97
    tmp___10 = strerror(*tmp___9);
#line 97
    fatal("setegid %u: %.100s", pw->pw_gid, tmp___10);
  }
#line 99
  tmp___14 = seteuid(pw->pw_uid);
#line 99
  if (tmp___14 == -1) {
#line 100
    tmp___12 = __errno_location();
#line 100
    tmp___13 = strerror(*tmp___12);
#line 100
    fatal("seteuid %u: %.100s", pw->pw_uid, tmp___13);
  }
#line 102
  return;
}
}
#line 107 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 110
  debug("restore_uid");
#line 112
  if (! privileged) {
#line 113
    return;
  }
#line 114
  if (! temporarily_use_uid_effective) {
#line 115
    fatal("restore_uid: temporarily_use_uid not effective");
  }
#line 119
  tmp___1 = seteuid(saved_euid);
#line 119
  if (tmp___1 < 0) {
#line 120
    tmp = __errno_location();
#line 120
    tmp___0 = strerror(*tmp);
#line 120
    fatal("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 121
  tmp___4 = setegid(saved_egid);
#line 121
  if (tmp___4 < 0) {
#line 122
    tmp___2 = __errno_location();
#line 122
    tmp___3 = strerror(*tmp___2);
#line 122
    fatal("setegid %u: %.100s", saved_egid, tmp___3);
  }
#line 135
  tmp___7 = setgroups((unsigned int )saved_egroupslen, (__gid_t const   *)(saved_egroups));
#line 135
  if (tmp___7 < 0) {
#line 136
    tmp___5 = __errno_location();
#line 136
    tmp___6 = strerror(*tmp___5);
#line 136
    fatal("setgroups: %.100s", tmp___6);
  }
#line 138
  temporarily_use_uid_effective = 0;
#line 139
  return;
}
}
#line 145 "uidswap.c"
void permanently_set_uid(struct passwd *pw ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 148
  if (temporarily_use_uid_effective) {
#line 149
    fatal("restore_uid: temporarily_use_uid effective");
  }
#line 150
  tmp___1 = setgid(pw->pw_gid);
#line 150
  if (tmp___1 < 0) {
#line 151
    tmp = __errno_location();
#line 151
    tmp___0 = strerror(*tmp);
#line 151
    fatal("setgid %u: %.100s", pw->pw_gid, tmp___0);
  }
#line 152
  tmp___4 = setuid(pw->pw_uid);
#line 152
  if (tmp___4 < 0) {
#line 153
    tmp___2 = __errno_location();
#line 153
    tmp___3 = strerror(*tmp___2);
#line 153
    fatal("setuid %u: %.100s", pw->pw_uid, tmp___3);
  }
#line 154
  return;
}
}
#line 1 "uuencode.o"
#line 31 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , int len ) ;
#line 33 "uuencode.c"
int uuencode(u_char *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 37
  tmp = b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 37
  return (tmp);
}
}
#line 40 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 47
  encoded = xstrdup(src);
#line 49
  p = encoded;
#line 49
  while (1) {
#line 49
    if (! ((int )*p == 32)) {
#line 49
      if (! ((int )*p == 9)) {
#line 49
        break;
      }
    }
#line 49
    p ++;
  }
#line 51
  while (1) {
#line 51
    if ((int )*p != 0) {
#line 51
      if ((int )*p != 32) {
#line 51
        if (! ((int )*p != 9)) {
#line 51
          break;
        }
      } else {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 51
    p ++;
  }
#line 54
  *p = (char )'\000';
#line 55
  len = b64_pton((char const   *)encoded, target, targsize);
#line 56
  xfree((void *)encoded);
#line 57
  return (len);
}
}
#line 60 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , int len ) 
{ u_char *buf___2 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 63
  tmp = xmalloc((unsigned int )(2 * len));
#line 63
  buf___2 = (u_char *)tmp;
#line 66
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___2, (unsigned int )(2 * len));
#line 67
  i = 0;
#line 67
  while (i < n___0) {
#line 68
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___2 + i));
#line 69
    if (i % 70 == 69) {
#line 70
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 67
    i ++;
  }
#line 72
  if (i % 70 != 69) {
#line 73
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 74
  xfree((void *)buf___2);
#line 75
  return;
}
}
#line 1 "xmalloc.o"
#line 21 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 26
  if (size == 0U) {
#line 27
    fatal("xmalloc: zero size");
  }
#line 28
  ptr = malloc(size);
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 31
  return (ptr);
}
}
#line 34 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 39
  if (new_size == 0U) {
#line 40
    fatal("xrealloc: zero size");
  }
#line 41
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 42
    new_ptr = malloc(new_size);
  } else {
#line 44
    new_ptr = realloc(ptr, new_size);
  }
#line 45
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 46
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 47
  return (new_ptr);
}
}
#line 50 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 53
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 54
    fatal("xfree: NULL pointer given as argument");
  }
#line 55
  free(ptr);
#line 56
  return;
}
}
#line 58 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 64
  tmp = strlen(str);
#line 64
  len = tmp + 1U;
#line 65
  tmp___0 = xmalloc(len);
#line 65
  cp = (char *)tmp___0;
#line 66
  strlcpy(cp, str, len);
#line 67
  return (cp);
}
}
#line 1 "sshd.o"
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 135 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 136
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 137
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 711 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 47 "myproposal.h"
static char *myproposal[10]  = 
#line 47 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se", 
        (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib",      (char *)"none,zlib", 
        (char *)"",      (char *)""};
#line 124 "auth.h"
void do_authentication(void) ;
#line 125
void do_authentication2(void) ;
#line 93 "sshd.c"
ServerOptions options  ;
#line 96 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 105 "sshd.c"
int IPv4or6  =    0;
#line 114 "sshd.c"
int debug_flag  =    0;
#line 117 "sshd.c"
int test_flag  =    0;
#line 120 "sshd.c"
int inetd_flag  =    0;
#line 123 "sshd.c"
int no_daemon_flag  =    0;
#line 126 "sshd.c"
int log_stderr  =    0;
#line 129 "sshd.c"
char **saved_argv  ;
#line 130 "sshd.c"
int saved_argc  ;
#line 137 "sshd.c"
int listen_socks[16]  ;
#line 138 "sshd.c"
int num_listen_socks  =    0;
#line 144 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 145 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 148 "sshd.c"
Kex *xxx_kex  ;
#line 158 "sshd.c"
struct __anonstruct_sensitive_data_82 sensitive_data  ;
#line 171 "sshd.c"
int key_do_regen  =    0;
#line 174 "sshd.c"
int received_sighup  =    0;
#line 175 "sshd.c"
int received_sigterm  =    0;
#line 178 "sshd.c"
u_char session_id[16]  ;
#line 181 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 182 "sshd.c"
int session_id2_len  =    0;
#line 185 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 188
void destroy_sensitive_data(void) ;
#line 190
static void do_ssh1_kex(void) ;
#line 191
static void do_ssh2_kex(void) ;
#line 196 "sshd.c"
static void close_listen_socks(void) 
{ int i ;

  {
#line 200
  i = 0;
#line 200
  while (i < num_listen_socks) {
#line 201
    close(listen_socks[i]);
#line 200
    i ++;
  }
#line 202
  num_listen_socks = -1;
#line 203
  return;
}
}
#line 210 "sshd.c"
static void sighup_handler(int sig ) 
{ 

  {
#line 213
  received_sighup = 1;
#line 214
  signal(1, & sighup_handler);
#line 215
  return;
}
}
#line 221 "sshd.c"
static void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 224
  log("Received SIGHUP; restarting.");
#line 225
  close_listen_socks();
#line 226
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 227
  tmp = __errno_location();
#line 227
  tmp___0 = strerror(*tmp);
#line 227
  log("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 228
  exit(1);
}
}
#line 234 "sshd.c"
static void sigterm_handler(int sig ) 
{ 

  {
#line 237
  received_sigterm = sig;
#line 238
  return;
}
}
#line 244 "sshd.c"
static void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 247
  tmp = __errno_location();
#line 247
  save_errno = *tmp;
#line 250
  while (1) {
#line 250
    tmp___0 = waitpid(-1, & status, 1);
#line 250
    if (! (tmp___0 > 0)) {
#line 250
      break;
    }
  }
#line 253
  signal(17, & main_sigchld_handler);
#line 254
  tmp___1 = __errno_location();
#line 254
  *tmp___1 = save_errno;
#line 255
  return;
}
}
#line 260 "sshd.c"
static void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 266
  packet_close();
#line 269
  tmp = get_remote_ipaddr();
#line 269
  fatal("Timeout before authentication for %s.", tmp);
#line 270
  return;
}
}
#line 279 "sshd.c"
static void generate_ephemeral_server_key(void) 
{ u_int32_t rand___0 ;
  int i ;
  char const   *tmp ;

  {
#line 282
  rand___0 = (u_int32_t )0;
#line 285
  if (sensitive_data.server_key) {
#line 285
    tmp = "new ";
  } else {
#line 285
    tmp = "";
  }
#line 285
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 287
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 288
    key_free(sensitive_data.server_key);
  }
#line 289
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 291
  verbose("RSA key generation complete.");
#line 293
  i = 0;
#line 293
  while (i < 32) {
#line 294
    if (i % 4 == 0) {
#line 295
      rand___0 = arc4random();
    }
#line 296
    sensitive_data.ssh1_cookie[i] = (unsigned char )(rand___0 & 255U);
#line 297
    rand___0 >>= 8;
#line 293
    i ++;
  }
#line 299
  arc4random_stir();
#line 300
  return;
}
}
#line 302 "sshd.c"
static void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 305
  tmp = __errno_location();
#line 305
  save_errno = *tmp;
#line 306
  signal(14, (void (*)(int  ))0);
#line 307
  tmp___0 = __errno_location();
#line 307
  *tmp___0 = save_errno;
#line 308
  key_do_regen = 1;
#line 309
  return;
}
}
#line 311 "sshd.c"
static void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___2[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  size_t tmp___35 ;
  char const   *tmp___36 ;

  {
#line 321
  if (options.protocol & 1) {
#line 321
    if (options.protocol & 4) {
#line 323
      major = 1;
#line 324
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 325
    if (options.protocol & 4) {
#line 326
      major = 2;
#line 327
      minor = 0;
    } else {
#line 329
      major = 1;
#line 330
      minor = 5;
    }
  }
#line 332
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_2.9.9p2");
#line 333
  server_version_string = xstrdup((char const   *)(buf___2));
#line 335
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 337
    tmp___0 = strlen((char const   *)server_version_string);
#line 337
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 337
    tmp___2 = strlen((char const   *)server_version_string);
#line 337
    if ((size_t )tmp___1 != tmp___2) {
#line 339
      tmp = get_remote_ipaddr();
#line 339
      log("Could not write ident string to %s.", tmp);
#line 340
      fatal_cleanup();
    }
#line 344
    memset((void *)(buf___2), 0, sizeof(buf___2));
#line 345
    i = 0;
#line 345
    while ((unsigned int )i < sizeof(buf___2) - 1U) {
#line 346
      tmp___4 = atomicio((ssize_t (*)())(& read), sock_in, (void *)(& buf___2[i]),
                         1U);
#line 346
      if (tmp___4 != 1) {
#line 347
        tmp___3 = get_remote_ipaddr();
#line 347
        log("Did not receive identification string from %s.", tmp___3);
#line 349
        fatal_cleanup();
      }
#line 351
      if ((int )buf___2[i] == 13) {
#line 352
        buf___2[i] = (char)0;
#line 355
        if (i == 12) {
#line 355
          if (0) {
#line 355
            if (0) {
#line 355
              __s1_len___0 = strlen((char const   *)(buf___2));
#line 355
              __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 355
              if (! ((unsigned int )((void const   *)(buf___2 + 1)) - (unsigned int )((void const   *)(buf___2)) == 1U)) {
                goto _L___3;
              } else {
#line 355
                if (__s1_len___0 >= 4U) {
                  _L___3: /* CIL Label */ 
#line 355
                  if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 355
                    tmp___28 = 1;
                  } else {
#line 355
                    if (__s2_len___0 >= 4U) {
#line 355
                      tmp___28 = 1;
                    } else {
#line 355
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 355
                  tmp___28 = 0;
                }
              }
#line 355
              if (tmp___28) {
#line 355
                tmp___24 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
              } else {
#line 355
                tmp___27 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
#line 355
                tmp___24 = tmp___27;
              }
            } else {
#line 355
              tmp___27 = __builtin_strcmp((char const   *)(buf___2), "SSH-1.5-W1.0");
#line 355
              tmp___24 = tmp___27;
            }
#line 355
            tmp___18 = tmp___24;
          } else {
#line 355
            tmp___18 = strncmp((char const   *)(buf___2), "SSH-1.5-W1.0", 12U);
          }
#line 355
          if (tmp___18 == 0) {
#line 356
            break;
          }
        }
        goto __Cont;
      }
#line 359
      if ((int )buf___2[i] == 10) {
#line 360
        buf___2[i] = (char)0;
#line 361
        break;
      }
      __Cont: /* CIL Label */ 
#line 345
      i ++;
    }
#line 364
    buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 365
    client_version_string = xstrdup((char const   *)(buf___2));
  }
#line 372
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 372
  if (tmp___33 != 3) {
#line 374
    s = (char *)"Protocol mismatch.\n";
#line 375
    tmp___31 = strlen((char const   *)s);
#line 375
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___31);
#line 376
    close(sock_in);
#line 377
    close(sock_out);
#line 378
    tmp___32 = get_remote_ipaddr();
#line 378
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___32);
#line 380
    fatal_cleanup();
  }
#line 382
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 385
  compat_datafellows((char const   *)(remote_version));
#line 387
  if (datafellows & 2048) {
#line 388
    tmp___34 = get_remote_ipaddr();
#line 388
    log("scanned from %s with %s.  Don\'t panic.", tmp___34, client_version_string);
#line 390
    fatal_cleanup();
  }
#line 393
  mismatch = 0;
#line 394
  switch (remote_major) {
  case 1: 
#line 396
  if (remote_minor == 99) {
#line 397
    if (options.protocol & 4) {
#line 398
      enable_compat20();
    } else {
#line 400
      mismatch = 1;
    }
#line 401
    break;
  }
#line 403
  if (! (options.protocol & 1)) {
#line 404
    mismatch = 1;
#line 405
    break;
  }
#line 407
  if (remote_minor < 3) {
#line 408
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 410
    if (remote_minor == 3) {
#line 412
      enable_compat13();
    }
  }
#line 414
  break;
  case 2: 
#line 416
  if (options.protocol & 4) {
#line 417
    enable_compat20();
#line 418
    break;
  }
  default: 
#line 422
  mismatch = 1;
#line 423
  break;
  }
#line 425
  chop(server_version_string);
#line 426
  debug("Local version string %.200s", server_version_string);
#line 428
  if (mismatch) {
#line 429
    s = (char *)"Protocol major versions differ.\n";
#line 430
    tmp___35 = strlen((char const   *)s);
#line 430
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___35);
#line 431
    close(sock_in);
#line 432
    close(sock_out);
#line 433
    tmp___36 = get_remote_ipaddr();
#line 433
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___36, server_version_string,
        client_version_string);
#line 436
    fatal_cleanup();
  }
#line 438
  return;
}
}
#line 442 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 447
  if (sensitive_data.server_key) {
#line 448
    key_free(sensitive_data.server_key);
#line 449
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 451
  i = 0;
#line 451
  while (i < options.num_host_key_files) {
#line 452
    if (*(sensitive_data.host_keys + i)) {
#line 453
      key_free(*(sensitive_data.host_keys + i));
#line 454
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 451
    i ++;
  }
#line 457
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 458
  memset((void *)(sensitive_data.ssh1_cookie), 0, 32U);
#line 459
  return;
}
}
#line 464 "sshd.c"
static char buf[1024]  ;
#line 461 "sshd.c"
static char *list_hostkey_types(void) 
{ int i ;
  Key *key ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 466
  buf[0] = (char )'\000';
#line 467
  i = 0;
#line 467
  while (i < options.num_host_key_files) {
#line 468
    key = *(sensitive_data.host_keys + i);
#line 469
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 471
    switch (key->type) {
    case 1: 
    case 2: 
#line 474
    tmp = key_ssh_name(key);
#line 474
    strlcat(buf, (char const   *)tmp, sizeof(buf));
#line 475
    strlcat(buf, ",", sizeof(buf));
#line 476
    break;
    }
    __Cont: /* CIL Label */ 
#line 467
    i ++;
  }
#line 479
  tmp___0 = strlen((char const   *)(buf));
#line 479
  i = (int )tmp___0;
#line 480
  if (i > 0) {
#line 480
    if ((int )buf[i - 1] == 44) {
#line 481
      buf[i - 1] = (char )'\000';
    }
  }
#line 482
  debug("list_hostkey_types: %s", buf);
#line 483
  return (buf);
}
}
#line 486 "sshd.c"
static Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 490
  i = 0;
#line 490
  while (i < options.num_host_key_files) {
#line 491
    key = *(sensitive_data.host_keys + i);
#line 492
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 492
      if (key->type == type) {
#line 493
        return (key);
      }
    }
#line 490
    i ++;
  }
#line 495
  return ((Key *)((void *)0));
}
}
#line 504 "sshd.c"
static int drop_connection(int startups ) 
{ double p ;
  double r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 509
  if (startups < options.max_startups_begin) {
#line 510
    return (0);
  }
#line 511
  if (startups >= options.max_startups) {
#line 512
    return (1);
  }
#line 513
  if (options.max_startups_rate == 100) {
#line 514
    return (1);
  }
#line 516
  p = (double )(100 - options.max_startups_rate);
#line 517
  p *= (double )(startups - options.max_startups_begin);
#line 518
  p /= (double )(options.max_startups - options.max_startups_begin);
#line 519
  p += (double )options.max_startups_rate;
#line 520
  p /= 100.0;
#line 521
  tmp = arc4random();
#line 521
  r = (double )tmp / (double )4294967295U;
#line 523
  debug("drop_connection: p %g, r %g", p, r);
#line 524
  if (r < p) {
#line 524
    tmp___0 = 1;
  } else {
#line 524
    tmp___0 = 0;
  }
#line 524
  return (tmp___0);
}
}
#line 527 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 528 "sshd.c"
int startup_pipe  ;
#line 533 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int startups ;
  Key *key ;
  int ret ;
  int key_used ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int fd ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int s1 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  __pid_t tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int *tmp___32 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;

  {
#line 538
  sock_in = 0;
#line 538
  sock_out = 0;
#line 538
  on = 1;
#line 551
  startups = 0;
#line 553
  key_used = 0;
#line 555
  __progname = get_progname(*(av + 0));
#line 556
  init_rng();
#line 559
  saved_argc = ac;
#line 560
  saved_argv = av;
#line 563
  initialize_server_options(& options);
#line 566
  while (1) {
#line 566
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:u:dDeiqtQ46");
#line 566
    if (! (opt != -1)) {
#line 566
      break;
    }
#line 567
    switch (opt) {
    case 52: 
#line 569
    IPv4or6 = 2;
#line 570
    break;
    case 54: 
#line 572
    IPv4or6 = 10;
#line 573
    break;
    case 102: 
#line 575
    config_file_name = optarg;
#line 576
    break;
    case 100: 
#line 578
    if (0 == debug_flag) {
#line 579
      debug_flag = 1;
#line 580
      options.log_level = 5;
    } else {
#line 581
      if ((int )options.log_level < 7) {
#line 582
        options.log_level = (LogLevel )((int )options.log_level + 1);
      } else {
#line 584
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too high debugging level.\n");
#line 585
        exit(1);
      }
    }
#line 587
    break;
    case 68: 
#line 589
    no_daemon_flag = 1;
#line 590
    break;
    case 101: 
#line 592
    log_stderr = 1;
#line 593
    break;
    case 105: 
#line 595
    inetd_flag = 1;
#line 596
    break;
    case 81: 
#line 599
    break;
    case 113: 
#line 601
    options.log_level = 0;
#line 602
    break;
    case 98: 
#line 604
    options.server_key_bits = atoi((char const   *)optarg);
#line 605
    break;
    case 112: 
#line 607
    options.ports_from_cmdline = 1U;
#line 608
    if (options.num_ports >= 256U) {
#line 609
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 610
      exit(1);
    }
#line 612
    tmp = options.num_ports;
#line 612
    (options.num_ports) ++;
#line 612
    tmp___0 = a2port((char const   *)optarg);
#line 612
    options.ports[tmp] = (unsigned short )tmp___0;
#line 613
    if ((int )options.ports[options.num_ports - 1U] == 0) {
#line 614
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 615
      exit(1);
    }
#line 617
    break;
    case 103: 
#line 619
    tmp___1 = convtime((char const   *)optarg);
#line 619
    options.login_grace_time = (int )tmp___1;
#line 619
    if (options.login_grace_time == -1) {
#line 620
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid login grace time.\n");
#line 621
      exit(1);
    }
#line 623
    break;
    case 107: 
#line 625
    tmp___2 = convtime((char const   *)optarg);
#line 625
    options.key_regeneration_time = (int )tmp___2;
#line 625
    if (options.key_regeneration_time == -1) {
#line 626
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid key regeneration interval.\n");
#line 627
      exit(1);
    }
#line 629
    break;
    case 104: 
#line 631
    if (options.num_host_key_files >= 256) {
#line 632
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 633
      exit(1);
    }
#line 635
    tmp___3 = options.num_host_key_files;
#line 635
    (options.num_host_key_files) ++;
#line 635
    options.host_key_files[tmp___3] = optarg;
#line 636
    break;
    case 86: 
#line 638
    client_version_string = optarg;
#line 640
    inetd_flag = 1;
#line 641
    break;
    case 116: 
#line 643
    test_flag = 1;
#line 644
    break;
    case 117: 
#line 646
    tmp___4 = atoi((char const   *)optarg);
#line 646
    utmp_len = (unsigned int )tmp___4;
#line 647
    break;
    case 63: 
    default: 
#line 650
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH_2.9.9p2");
#line 651
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            __progname);
#line 652
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 653
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 654
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode (multiple -d means more debugging)\n");
#line 655
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 656
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -D         Do not fork into daemon mode\n");
#line 657
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -t         Only test configuration file and keys\n");
#line 658
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 659
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 660
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 661
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 600)\n");
#line 662
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 663
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 665
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -u len     Maximum hostname length for utmp recording\n");
#line 666
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 667
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 668
    exit(1);
    }
  }
#line 671
  OPENSSL_add_all_algorithms_noconf();
#line 677
  if ((int )options.log_facility == -1) {
#line 677
    tmp___5 = 2;
  } else {
#line 677
    tmp___5 = (int )options.log_facility;
  }
#line 677
  if ((int )options.log_level == -1) {
#line 677
    tmp___6 = 3;
  } else {
#line 677
    tmp___6 = (int )options.log_level;
  }
#line 677
  log_init(__progname, (enum __anonenum_LogLevel_64 )tmp___6, (enum __anonenum_SyslogFacility_63 )tmp___5,
           ! inetd_flag);
#line 689
  seed_rng();
#line 692
  read_server_config(& options, (char const   *)config_file_name);
#line 695
  fill_default_server_options(& options);
#line 698
  if (optind < ac) {
#line 699
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 700
    exit(1);
  }
#line 703
  debug("sshd version %.100s", "OpenSSH_2.9.9p2");
#line 706
  tmp___7 = xmalloc((unsigned int )options.num_host_key_files * sizeof(Key *));
#line 706
  sensitive_data.host_keys = (Key **)tmp___7;
#line 707
  i = 0;
#line 707
  while (i < options.num_host_key_files) {
#line 708
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 707
    i ++;
  }
#line 709
  sensitive_data.server_key = (Key *)((void *)0);
#line 710
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 711
  sensitive_data.have_ssh1_key = 0;
#line 712
  sensitive_data.have_ssh2_key = 0;
#line 714
  i = 0;
#line 714
  while (i < options.num_host_key_files) {
#line 715
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
#line 716
    *(sensitive_data.host_keys + i) = key;
#line 717
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 718
      error("Could not load host key: %s", options.host_key_files[i]);
#line 720
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      goto __Cont;
    }
#line 723
    switch (key->type) {
    case 0: 
#line 725
    sensitive_data.ssh1_host_key = key;
#line 726
    sensitive_data.have_ssh1_key = 1;
#line 727
    break;
    case 1: 
    case 2: 
#line 730
    sensitive_data.have_ssh2_key = 1;
#line 731
    break;
    }
#line 733
    tmp___8 = key_type(key);
#line 733
    debug("private host key: #%d type %d %s", i, key->type, tmp___8);
    __Cont: /* CIL Label */ 
#line 714
    i ++;
  }
#line 736
  if (options.protocol & 1) {
#line 736
    if (! sensitive_data.have_ssh1_key) {
#line 737
      log("Disabling protocol version 1. Could not load host key");
#line 738
      options.protocol &= -2;
    }
  }
#line 740
  if (options.protocol & 4) {
#line 740
    if (! sensitive_data.have_ssh2_key) {
#line 741
      log("Disabling protocol version 2. Could not load host key");
#line 742
      options.protocol &= -5;
    }
  }
#line 744
  if (! (options.protocol & 5)) {
#line 745
    log("sshd: no hostkeys available -- exiting.");
#line 746
    exit(1);
  }
#line 750
  if (options.protocol & 1) {
#line 751
    if (options.server_key_bits < 512) {
#line 753
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 754
      exit(1);
    } else {
#line 751
      if (options.server_key_bits > 32768) {
#line 753
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 754
        exit(1);
      }
    }
#line 761
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 761
    if (options.server_key_bits > tmp___10 - 128) {
#line 761
      tmp___11 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 761
      if (options.server_key_bits < tmp___11 + 128) {
#line 765
        tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 765
        options.server_key_bits = tmp___9 + 128;
#line 767
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 773
  if (test_flag) {
#line 774
    exit(0);
  }
#line 781
  if (debug_flag) {
#line 781
    if (! inetd_flag) {
#line 782
      log_stderr = 1;
    }
  }
#line 783
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 790
  if (! debug_flag) {
#line 790
    if (! inetd_flag) {
#line 790
      if (! no_daemon_flag) {
#line 794
        tmp___14 = daemon(0, 0);
#line 794
        if (tmp___14 < 0) {
#line 795
          tmp___12 = __errno_location();
#line 795
          tmp___13 = strerror(*tmp___12);
#line 795
          fatal("daemon() failed: %.200s", tmp___13);
        }
#line 799
        fd = open("/dev/tty", 258);
#line 800
        if (fd >= 0) {
#line 801
          ioctl(fd, 21538UL, (void *)0);
#line 802
          close(fd);
        }
      }
    }
  }
#line 807
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 810
  arc4random_stir();
#line 814
  chdir("/");
#line 817
  signal(13, (void (*)(int  ))1);
#line 820
  if (inetd_flag) {
#line 822
    s1 = dup(0);
#line 823
    dup(s1);
#line 824
    sock_in = dup(0);
#line 825
    sock_out = dup(1);
#line 826
    startup_pipe = -1;
#line 832
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 833
    if (options.protocol & 1) {
#line 834
      generate_ephemeral_server_key();
    }
  } else {
#line 836
    ai = options.listen_addrs;
#line 836
    while (ai) {
#line 837
      if (ai->ai_family != 2) {
#line 837
        if (ai->ai_family != 10) {
          goto __Cont___0;
        }
      }
#line 839
      if (num_listen_socks >= 16) {
#line 840
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 842
      tmp___15 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 842
      if (tmp___15 != 0) {
#line 845
        error("getnameinfo failed");
        goto __Cont___0;
      }
#line 849
      listen_sock = socket(ai->ai_family, 1, 0);
#line 850
      if (listen_sock < 0) {
#line 852
        tmp___16 = __errno_location();
#line 852
        tmp___17 = strerror(*tmp___16);
#line 852
        verbose("socket: %.100s", tmp___17);
        goto __Cont___0;
      }
#line 855
      tmp___20 = fcntl(listen_sock, 4, 2048);
#line 855
      if (tmp___20 < 0) {
#line 856
        tmp___18 = __errno_location();
#line 856
        tmp___19 = strerror(*tmp___18);
#line 856
        error("listen_sock O_NONBLOCK: %s", tmp___19);
#line 857
        close(listen_sock);
        goto __Cont___0;
      }
#line 866
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 868
      linger.l_onoff = 1;
#line 869
      linger.l_linger = 5;
#line 870
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 873
      debug("Bind to port %s on %s.", strport, ntop);
#line 876
      tmp___23 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 876
      if (tmp___23 < 0) {
#line 877
        if (! ai->ai_next) {
#line 878
          tmp___21 = __errno_location();
#line 878
          tmp___22 = strerror(*tmp___21);
#line 878
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___22);
        }
#line 880
        close(listen_sock);
        goto __Cont___0;
      }
#line 883
      listen_socks[num_listen_socks] = listen_sock;
#line 884
      num_listen_socks ++;
#line 887
      log("Server listening on %s port %s.", ntop, strport);
#line 888
      tmp___26 = listen(listen_sock, 5);
#line 888
      if (tmp___26 < 0) {
#line 889
        tmp___24 = __errno_location();
#line 889
        tmp___25 = strerror(*tmp___24);
#line 889
        fatal("listen: %.100s", tmp___25);
      }
      __Cont___0: /* CIL Label */ 
#line 836
      ai = ai->ai_next;
    }
#line 892
    freeaddrinfo(options.listen_addrs);
#line 894
    if (! num_listen_socks) {
#line 895
      fatal("Cannot bind any address.");
    }
#line 897
    if (options.protocol & 1) {
#line 898
      generate_ephemeral_server_key();
    }
#line 904
    signal(1, & sighup_handler);
#line 906
    signal(15, & sigterm_handler);
#line 907
    signal(3, & sigterm_handler);
#line 910
    signal(17, & main_sigchld_handler);
#line 913
    if (! debug_flag) {
#line 921
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"wb");
#line 922
      if (f) {
#line 923
        tmp___27 = getpid();
#line 923
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___27);
#line 924
        fclose(f);
      }
    }
#line 929
    fdset = (fd_set *)((void *)0);
#line 930
    maxfd = 0;
#line 931
    i = 0;
#line 931
    while (i < num_listen_socks) {
#line 932
      if (listen_socks[i] > maxfd) {
#line 933
        maxfd = listen_socks[i];
      }
#line 931
      i ++;
    }
#line 935
    tmp___28 = xmalloc((unsigned int )options.max_startups * sizeof(int ));
#line 935
    startup_pipes = (int *)tmp___28;
#line 936
    i = 0;
#line 936
    while (i < options.max_startups) {
#line 937
      *(startup_pipes + i) = -1;
#line 936
      i ++;
    }
#line 943
    while (1) {
#line 944
      if (received_sighup) {
#line 945
        sighup_restart();
      }
#line 946
      if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 947
        xfree((void *)fdset);
      }
#line 948
      fdsetsz = (int )((((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 949
      tmp___29 = xmalloc((unsigned int )fdsetsz);
#line 949
      fdset = (fd_set *)tmp___29;
#line 950
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 952
      i = 0;
#line 952
      while (i < num_listen_socks) {
#line 953
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 952
        i ++;
      }
#line 954
      i = 0;
#line 954
      while (i < options.max_startups) {
#line 955
        if (*(startup_pipes + i) != -1) {
#line 956
          __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
#line 954
        i ++;
      }
#line 959
      ret = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 960
      if (ret < 0) {
#line 960
        tmp___32 = __errno_location();
#line 960
        if (*tmp___32 != 4) {
#line 961
          tmp___30 = __errno_location();
#line 961
          tmp___31 = strerror(*tmp___30);
#line 961
          error("select: %.100s", tmp___31);
        }
      }
#line 962
      if (received_sigterm) {
#line 963
        log("Received signal %d; terminating.", received_sigterm);
#line 965
        close_listen_socks();
#line 966
        unlink((char const   *)options.pid_file);
#line 967
        exit(255);
      }
#line 969
      if (key_used) {
#line 969
        if (key_do_regen) {
#line 970
          generate_ephemeral_server_key();
#line 971
          key_used = 0;
#line 972
          key_do_regen = 0;
        }
      }
#line 974
      if (ret < 0) {
        goto __Cont___1;
      }
#line 977
      i = 0;
#line 977
      while (i < options.max_startups) {
#line 979
        if (*(startup_pipes + i) != -1) {
#line 979
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                               "m" (fdset->__fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 979
          if (__result) {
#line 986
            close(*(startup_pipes + i));
#line 987
            *(startup_pipes + i) = -1;
#line 988
            startups --;
          }
        }
#line 977
        i ++;
      }
#line 990
      i = 0;
#line 990
      while (i < num_listen_socks) {
#line 991
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 991
        if (! __result___0) {
          goto __Cont___2;
        }
#line 993
        fromlen = sizeof(from);
#line 994
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 996
        if (newsock < 0) {
#line 997
          tmp___35 = __errno_location();
#line 997
          if (*tmp___35 != 4) {
#line 997
            tmp___36 = __errno_location();
#line 997
            if (*tmp___36 != 11) {
#line 998
              tmp___33 = __errno_location();
#line 998
              tmp___34 = strerror(*tmp___33);
#line 998
              error("accept: %.100s", tmp___34);
            }
          }
          goto __Cont___2;
        }
#line 1001
        tmp___39 = fcntl(newsock, 4, 0);
#line 1001
        if (tmp___39 < 0) {
#line 1002
          tmp___37 = __errno_location();
#line 1002
          tmp___38 = strerror(*tmp___37);
#line 1002
          error("newsock del O_NONBLOCK: %s", tmp___38);
          goto __Cont___2;
        }
#line 1005
        tmp___40 = drop_connection(startups);
#line 1005
        if (tmp___40 == 1) {
#line 1006
          debug("drop connection #%d", startups);
#line 1007
          close(newsock);
          goto __Cont___2;
        }
#line 1010
        tmp___41 = pipe((int *)(startup_p));
#line 1010
        if (tmp___41 == -1) {
#line 1011
          close(newsock);
          goto __Cont___2;
        }
#line 1015
        j = 0;
#line 1015
        while (j < options.max_startups) {
#line 1016
          if (*(startup_pipes + j) == -1) {
#line 1017
            *(startup_pipes + j) = startup_p[0];
#line 1018
            if (maxfd < startup_p[0]) {
#line 1019
              maxfd = startup_p[0];
            }
#line 1020
            startups ++;
#line 1021
            break;
          }
#line 1015
          j ++;
        }
#line 1028
        if (debug_flag) {
#line 1034
          debug("Server will not fork when running in debugging mode.");
#line 1035
          close_listen_socks();
#line 1036
          sock_in = newsock;
#line 1037
          sock_out = newsock;
#line 1038
          startup_pipe = -1;
#line 1039
          pid = getpid();
#line 1040
          break;
        } else {
#line 1047
          pid = fork();
#line 1047
          if (pid == 0) {
#line 1055
            startup_pipe = startup_p[1];
#line 1056
            j = 0;
#line 1056
            while (j < options.max_startups) {
#line 1057
              if (*(startup_pipes + j) != -1) {
#line 1058
                close(*(startup_pipes + j));
              }
#line 1056
              j ++;
            }
#line 1059
            close_listen_socks();
#line 1060
            sock_in = newsock;
#line 1061
            sock_out = newsock;
#line 1062
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1063
            break;
          }
        }
#line 1068
        if (pid < 0) {
#line 1069
          tmp___42 = __errno_location();
#line 1069
          tmp___43 = strerror(*tmp___42);
#line 1069
          error("fork: %.100s", tmp___43);
        } else {
#line 1071
          debug("Forked child %d.", pid);
        }
#line 1073
        close(startup_p[1]);
#line 1076
        if (options.protocol & 1) {
#line 1076
          if (key_used == 0) {
#line 1079
            signal(14, & key_regeneration_alarm);
#line 1080
            alarm((unsigned int )options.key_regeneration_time);
#line 1081
            key_used = 1;
          }
        }
#line 1084
        arc4random_stir();
#line 1087
        close(newsock);
        __Cont___2: /* CIL Label */ 
#line 990
        i ++;
      }
#line 1090
      if (num_listen_socks < 0) {
#line 1091
        break;
      }
      __Cont___1: /* CIL Label */ ;
    }
  }
#line 1102
  alarm(0U);
#line 1103
  signal(14, (void (*)(int  ))0);
#line 1104
  signal(1, (void (*)(int  ))0);
#line 1105
  signal(15, (void (*)(int  ))0);
#line 1106
  signal(3, (void (*)(int  ))0);
#line 1107
  signal(17, (void (*)(int  ))0);
#line 1108
  signal(2, (void (*)(int  ))0);
#line 1116
  linger.l_onoff = 1;
#line 1117
  linger.l_linger = 5;
#line 1118
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1121
  if (options.keepalives) {
#line 1121
    tmp___46 = setsockopt(sock_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1121
    if (tmp___46 < 0) {
#line 1124
      tmp___44 = __errno_location();
#line 1124
      tmp___45 = strerror(*tmp___44);
#line 1124
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___45);
    }
  }
#line 1130
  packet_set_connection(sock_in, sock_out);
#line 1132
  remote_port = get_remote_port();
#line 1133
  remote_ip = get_remote_ipaddr();
#line 1153
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 1163
  signal(14, & grace_alarm_handler);
#line 1164
  if (! debug_flag) {
#line 1165
    alarm((unsigned int )options.login_grace_time);
  }
#line 1167
  sshd_exchange_identification(sock_in, sock_out);
#line 1175
  if (remote_port >= 1024) {
#line 1177
    debug("Rhosts Authentication disabled, originating port not trusted.");
#line 1179
    options.rhosts_authentication = 0;
  } else {
#line 1175
    if (remote_port < 512) {
#line 1177
      debug("Rhosts Authentication disabled, originating port not trusted.");
#line 1179
      options.rhosts_authentication = 0;
    }
  }
#line 1196
  packet_set_nonblocking();
#line 1200
  if (compat20) {
#line 1201
    do_ssh2_kex();
#line 1202
    do_authentication2();
  } else {
#line 1204
    do_ssh1_kex();
#line 1205
    do_authentication();
  }
#line 1208
  verbose("Closing connection to %.100s", remote_ip);
#line 1214
  packet_close();
#line 1215
  exit(0);
}
}
#line 1221 "sshd.c"
static void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int bytes ;
  int tmp___24 ;
  char *buf___2 ;
  void *tmp___25 ;
  MD5_CTX md ;

  {
#line 1226
  rsafail = 0;
#line 1231
  rand___0 = (u_int32_t )0;
#line 1242
  i = 0;
#line 1242
  while (i < 8) {
#line 1243
    if (i % 4 == 0) {
#line 1244
      rand___0 = arc4random();
    }
#line 1245
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1246
    rand___0 >>= 8;
#line 1242
    i ++;
  }
#line 1254
  packet_start((unsigned char)2);
#line 1255
  i = 0;
#line 1255
  while (i < 8) {
#line 1256
    packet_put_char((int )cookie[i]);
#line 1255
    i ++;
  }
#line 1259
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1259
  packet_put_int((unsigned int )tmp);
#line 1260
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 1261
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 1264
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1264
  packet_put_int((unsigned int )tmp___0);
#line 1265
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 1266
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1269
  packet_put_int(2U);
#line 1272
  tmp___1 = cipher_mask_ssh1(0);
#line 1272
  packet_put_int(tmp___1);
#line 1275
  auth_mask = 0U;
#line 1276
  if (options.rhosts_authentication) {
#line 1277
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1278
  if (options.rhosts_rsa_authentication) {
#line 1279
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1280
  if (options.rsa_authentication) {
#line 1281
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1294
  if (options.challenge_response_authentication == 1) {
#line 1295
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 1296
  if (options.password_authentication) {
#line 1297
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1298
  packet_put_int(auth_mask);
#line 1301
  packet_send();
#line 1302
  packet_write_wait();
#line 1304
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1304
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1304
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 1309
  packet_read_expect(& plen, 3);
#line 1312
  cipher_type = packet_get_char();
#line 1314
  tmp___4 = cipher_mask_ssh1(0);
#line 1314
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
#line 1315
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1319
  i = 0;
#line 1319
  while (i < 8) {
#line 1320
    tmp___5 = packet_get_char();
#line 1320
    if ((u_int )cookie[i] != tmp___5) {
#line 1321
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1319
    i ++;
  }
#line 1323
  tmp___6 = cipher_name((int )cipher_type);
#line 1323
  debug("Encryption type: %.200s", tmp___6);
#line 1326
  session_key_int = BN_new();
#line 1327
  packet_get_bignum(session_key_int, & slen);
#line 1329
  protocol_flags = packet_get_int();
#line 1330
  packet_set_protocol_flags(protocol_flags);
#line 1332
  while (1) {
#line 1332
    _p = plen;
#line 1332
    _e = (9 + slen) + 4;
#line 1332
    if (_p != _e) {
#line 1332
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1332);
#line 1332
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1332
    break;
  }
#line 1338
  tmp___21 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1338
  if (tmp___21 > 0) {
#line 1340
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1340
    tmp___11 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1340
    if (tmp___10 < tmp___11 + 128) {
#line 1342
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1342
      tmp___8 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1342
      tmp___9 = get_remote_ipaddr();
#line 1342
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1348
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1348
    if (tmp___12 <= 0) {
#line 1350
      rsafail ++;
    }
#line 1351
    tmp___13 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1351
    if (tmp___13 <= 0) {
#line 1353
      rsafail ++;
    }
  } else {
#line 1356
    tmp___17 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1356
    tmp___18 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1356
    if (tmp___17 < tmp___18 + 128) {
#line 1358
      tmp___14 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1358
      tmp___15 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1358
      tmp___16 = get_remote_ipaddr();
#line 1358
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___16, tmp___15, tmp___14, 128);
    }
#line 1364
    tmp___19 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1364
    if (tmp___19 < 0) {
#line 1366
      rsafail ++;
    }
#line 1367
    tmp___20 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1367
    if (tmp___20 < 0) {
#line 1369
      rsafail ++;
    }
  }
#line 1376
  if (! rsafail) {
#line 1377
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1378
    tmp___22 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1378
    len = (tmp___22 + 7) / 8;
#line 1379
    if (len < 0) {
#line 1380
      tmp___23 = get_remote_ipaddr();
#line 1380
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___23, len, (unsigned long )sizeof(session_key));
#line 1383
      rsafail ++;
    } else {
#line 1379
      if ((unsigned int )len > sizeof(session_key)) {
#line 1380
        tmp___23 = get_remote_ipaddr();
#line 1380
        error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___23, len, (unsigned long )sizeof(session_key));
#line 1383
        rsafail ++;
      } else {
#line 1385
        memset((void *)(session_key), 0, sizeof(session_key));
#line 1386
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1389
        compute_session_id((u_char *)(session_id), (u_char *)(cookie), ((sensitive_data.ssh1_host_key)->rsa)->n,
                           ((sensitive_data.server_key)->rsa)->n);
#line 1396
        i = 0;
#line 1396
        while (i < 16) {
#line 1397
          session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1396
          i ++;
        }
      }
    }
  }
#line 1400
  if (rsafail) {
#line 1401
    tmp___24 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1401
    bytes = (tmp___24 + 7) / 8;
#line 1402
    tmp___25 = xmalloc((unsigned int )bytes);
#line 1402
    buf___2 = (char *)tmp___25;
#line 1405
    log("do_connection: generating a fake encryption key");
#line 1406
    BN_bn2bin((BIGNUM const   *)session_key_int, (unsigned char *)buf___2);
#line 1407
    MD5_Init(& md);
#line 1408
    MD5_Update(& md, (void const   *)buf___2, (unsigned int )bytes);
#line 1409
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1410
    MD5_Final(session_key, & md);
#line 1411
    MD5_Init(& md);
#line 1412
    MD5_Update(& md, (void const   *)(session_key), 16U);
#line 1413
    MD5_Update(& md, (void const   *)buf___2, (unsigned int )bytes);
#line 1414
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 1415
    MD5_Final(session_key + 16, & md);
#line 1416
    memset((void *)buf___2, 0, (unsigned int )bytes);
#line 1417
    xfree((void *)buf___2);
#line 1418
    i = 0;
#line 1418
    while (i < 16) {
#line 1419
      session_id[i] = (unsigned char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 1418
      i ++;
    }
  }
#line 1422
  destroy_sensitive_data();
#line 1425
  BN_clear_free(session_key_int);
#line 1428
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type);
#line 1431
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1433
  debug("Received session key; encryption turned on.");
#line 1436
  packet_start((unsigned char)14);
#line 1437
  packet_send();
#line 1438
  packet_write_wait();
#line 1439
  return;
}
}
#line 1444 "sshd.c"
static void do_ssh2_kex(void) 
{ Kex *kex ;

  {
#line 1449
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1450
    myproposal[3] = options.ciphers;
#line 1450
    myproposal[2] = myproposal[3];
  }
#line 1453
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
#line 1455
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
#line 1458
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 1459
    myproposal[5] = options.macs;
#line 1459
    myproposal[4] = myproposal[5];
  }
#line 1462
  myproposal[1] = list_hostkey_types();
#line 1465
  kex = kex_setup((char **)(myproposal));
#line 1466
  kex->server = 1;
#line 1467
  kex->client_version_string = client_version_string;
#line 1468
  kex->server_version_string = server_version_string;
#line 1469
  kex->load_host_key = & get_hostkey_by_type;
#line 1471
  xxx_kex = kex;
#line 1473
  dispatch_run(0, & kex->done, (void *)kex);
#line 1475
  session_id2 = kex->session_id;
#line 1476
  session_id2_len = kex->session_id_len;
#line 1485
  debug("KEX done");
#line 1486
  return;
}
}
#line 1 "auth.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 756 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 32 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 33
int ga_match(char * const  *groups , int n___0 ) ;
#line 34
void ga_free(void) ;
#line 127 "auth.h"
Authctxt *authctxt_new(void) ;
#line 128
void auth_log(Authctxt *authctxt , int authenticated , char *method , char *info ) ;
#line 130
int auth_root_allowed(char *method ) ;
#line 134
int allowed_user(struct passwd *pw ) ;
#line 141
char *expand_filename(char const   *filename , struct passwd *pw ) ;
#line 142
char *authorized_keys_file(struct passwd *pw ) ;
#line 143
char *authorized_keys_file2(struct passwd *pw ) ;
#line 145
int secure_filename(FILE *f , char const   *file , struct passwd *pw , char *err ,
                    size_t errlen ) ;
#line 148
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) ;
#line 30 "auth-options.h"
char *forced_command ;
#line 64 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  char const   *hostname ;
  char const   *ipaddr ;
  char *shell ;
  int i ;
  struct spwd *spw ;
  int days ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 68
  hostname = (char const   *)((void *)0);
#line 68
  ipaddr = (char const   *)((void *)0);
#line 79
  if (! pw) {
#line 80
    return (0);
  } else {
#line 79
    if (! pw->pw_name) {
#line 80
      return (0);
    }
  }
#line 82
  spw = getspnam((char const   *)pw->pw_name);
#line 83
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 84
    tmp = time((time_t *)((void *)0));
#line 84
    days = (int )(tmp / 86400L);
#line 87
    if (spw->sp_expire >= 0L) {
#line 87
      if ((long )days > spw->sp_expire) {
#line 88
        return (0);
      }
    }
#line 91
    if (spw->sp_lstchg >= 0L) {
#line 91
      if (spw->sp_max >= 0L) {
#line 91
        if ((long )days > spw->sp_lstchg + spw->sp_max) {
#line 93
          return (0);
        }
      }
    }
  }
#line 105
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 105
    shell = (char *)"/bin/sh";
  } else {
#line 105
    shell = pw->pw_shell;
  }
#line 108
  tmp___0 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 108
  if (tmp___0 != 0) {
#line 109
    return (0);
  }
#line 110
  if (st.st_mode & 32768U) {
#line 110
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 111
      return (0);
    }
  } else {
#line 111
    return (0);
  }
#line 113
  if (options.num_deny_users > 0U) {
#line 114
    hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 115
    ipaddr = get_remote_ipaddr();
  } else {
#line 113
    if (options.num_allow_users > 0U) {
#line 114
      hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 115
      ipaddr = get_remote_ipaddr();
    }
  }
#line 119
  if (options.num_deny_users > 0U) {
#line 120
    i = 0;
#line 120
    while ((u_int )i < options.num_deny_users) {
#line 121
      tmp___1 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.deny_users[i]);
#line 121
      if (tmp___1) {
#line 123
        return (0);
      }
#line 120
      i ++;
    }
  }
#line 126
  if (options.num_allow_users > 0U) {
#line 127
    i = 0;
#line 127
    while ((u_int )i < options.num_allow_users) {
#line 128
      tmp___2 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.allow_users[i]);
#line 128
      if (tmp___2) {
#line 130
        break;
      }
#line 127
      i ++;
    }
#line 132
    if ((u_int )i >= options.num_allow_users) {
#line 133
      return (0);
    }
  }
#line 135
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 135
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 137
      tmp___3 = ga_init((char const   *)pw->pw_name, pw->pw_gid);
#line 137
      if (tmp___3 == 0) {
#line 138
        return (0);
      }
#line 141
      if (options.num_deny_groups > 0U) {
#line 142
        tmp___4 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 142
        if (tmp___4) {
#line 144
          ga_free();
#line 145
          return (0);
        }
      }
#line 151
      if (options.num_allow_groups > 0U) {
#line 152
        tmp___5 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 152
        if (! tmp___5) {
#line 154
          ga_free();
#line 155
          return (0);
        }
      }
#line 157
      ga_free();
    }
  }
#line 178
  return (1);
}
}
#line 181 "auth.c"
Authctxt *authctxt_new(void) 
{ Authctxt *authctxt ;
  void *tmp ;

  {
#line 184
  tmp = xmalloc(sizeof(*authctxt));
#line 184
  authctxt = (Authctxt *)tmp;
#line 185
  memset((void *)authctxt, 0, sizeof(*authctxt));
#line 186
  return (authctxt);
}
}
#line 189 "auth.c"
void auth_log(Authctxt *authctxt , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 192
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 199
  if (authenticated == 1) {
#line 200
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 199
    if (! authctxt->valid) {
#line 200
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 199
      if (authctxt->failures >= 3) {
#line 200
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 199
        if (0) {
#line 199
          __s1_len = strlen((char const   *)method);
#line 199
          __s2_len = strlen("password");
#line 199
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 199
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 199
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 199
                tmp___8 = 1;
              } else {
#line 199
                if (__s2_len >= 4U) {
#line 199
                  tmp___8 = 1;
                } else {
#line 199
                  tmp___8 = 0;
                }
              }
            } else {
#line 199
              tmp___8 = 0;
            }
          }
#line 199
          if (tmp___8) {
#line 199
            tmp___4 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 199
            tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 199
            tmp___4 = tmp___7;
          }
        } else {
#line 199
          tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 199
          tmp___4 = tmp___7;
        }
#line 199
        if (tmp___4 == 0) {
#line 200
          authlog = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
  }
#line 202
  if (authctxt->postponed) {
#line 203
    authmsg = (char *)"Postponed";
  } else {
#line 205
    if (authenticated) {
#line 205
      authmsg = (char *)"Accepted";
    } else {
#line 205
      authmsg = (char *)"Failed";
    }
  }
#line 207
  tmp___9 = get_remote_port();
#line 207
  tmp___10 = get_remote_ipaddr();
#line 207
  if (authctxt->valid) {
#line 207
    if ((authctxt->pw)->pw_uid == 0U) {
#line 207
      tmp___11 = "ROOT";
    } else {
#line 207
      tmp___11 = (char const   *)authctxt->user;
    }
  } else {
#line 207
    tmp___11 = (char const   *)authctxt->user;
  }
#line 207
  if (authctxt->valid) {
#line 207
    tmp___12 = "";
  } else {
#line 207
    tmp___12 = "illegal user ";
  }
#line 207
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___12,
             tmp___11, tmp___10, tmp___9, info);
#line 215
  return;
}
}
#line 220 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 223
  switch (options.permit_root_login) {
  case 3: 
#line 225
  return (1);
#line 226
  break;
  case 2: 
#line 228
  if (0) {
#line 228
    __s1_len = strlen((char const   *)method);
#line 228
    __s2_len = strlen("password");
#line 228
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 228
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 228
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 228
          tmp___8 = 1;
        } else {
#line 228
          if (__s2_len >= 4U) {
#line 228
            tmp___8 = 1;
          } else {
#line 228
            tmp___8 = 0;
          }
        }
      } else {
#line 228
        tmp___8 = 0;
      }
    }
#line 228
    if (tmp___8) {
#line 228
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 228
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 228
      tmp___4 = tmp___7;
    }
  } else {
#line 228
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 228
    tmp___4 = tmp___7;
  }
#line 228
  if (tmp___4 != 0) {
#line 229
    return (1);
  }
#line 230
  break;
  case 1: 
#line 232
  if (forced_command) {
#line 233
    log("Root login accepted for forced command.");
#line 234
    return (1);
  }
#line 236
  break;
  }
#line 238
  tmp___9 = get_remote_ipaddr();
#line 238
  log("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 239
  return (0);
}
}
#line 250 "auth.c"
char *expand_filename(char const   *filename , struct passwd *pw ) 
{ Buffer buffer ;
  char *file ;
  char const   *cp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 261
  buffer_init(& buffer);
#line 262
  cp = filename;
#line 262
  while (*cp) {
#line 263
    if ((int const   )*(cp + 0) == 37) {
#line 263
      if ((int const   )*(cp + 1) == 37) {
#line 264
        buffer_append(& buffer, "%", 1U);
#line 265
        cp ++;
        goto __Cont;
      }
    }
#line 268
    if ((int const   )*(cp + 0) == 37) {
#line 268
      if ((int const   )*(cp + 1) == 104) {
#line 269
        tmp = strlen((char const   *)pw->pw_dir);
#line 269
        buffer_append(& buffer, (char const   *)pw->pw_dir, tmp);
#line 270
        cp ++;
        goto __Cont;
      }
    }
#line 273
    if ((int const   )*(cp + 0) == 37) {
#line 273
      if ((int const   )*(cp + 1) == 117) {
#line 274
        tmp___0 = strlen((char const   *)pw->pw_name);
#line 274
        buffer_append(& buffer, (char const   *)pw->pw_name, tmp___0);
#line 276
        cp ++;
        goto __Cont;
      }
    }
#line 279
    buffer_append(& buffer, cp, 1U);
    __Cont: /* CIL Label */ 
#line 262
    cp ++;
  }
#line 281
  buffer_append(& buffer, "\000", 1U);
#line 287
  tmp___1 = xmalloc(4096U);
#line 287
  file = (char *)tmp___1;
#line 288
  tmp___2 = buffer_ptr(& buffer);
#line 288
  cp = (char const   *)tmp___2;
#line 289
  if ((int const   )*cp != 47) {
#line 290
    snprintf((char * __restrict  )file, 4096U, (char const   * __restrict  )"%s/%s",
             pw->pw_dir, cp);
  } else {
#line 292
    strlcpy(file, cp, 4096U);
  }
#line 294
  buffer_free(& buffer);
#line 295
  return (file);
}
}
#line 298 "auth.c"
char *authorized_keys_file(struct passwd *pw ) 
{ char *tmp ;

  {
#line 301
  tmp = expand_filename((char const   *)options.authorized_keys_file, pw);
#line 301
  return (tmp);
}
}
#line 304 "auth.c"
char *authorized_keys_file2(struct passwd *pw ) 
{ char *tmp ;

  {
#line 307
  tmp = expand_filename((char const   *)options.authorized_keys_file2, pw);
#line 307
  return (tmp);
}
}
#line 311 "auth.c"
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) 
{ Key *found ;
  char *user_hostfile ;
  struct stat st ;
  int host_status ;
  HostStatus tmp ;
  HostStatus tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 321
  found = key_new(key->type);
#line 322
  tmp = check_host_in_hostfile(sysfile, host, key, found, (int *)((void *)0));
#line 322
  host_status = (int )tmp;
#line 324
  if (host_status != 0) {
#line 324
    if ((unsigned int )userfile != (unsigned int )((void *)0)) {
#line 325
      user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
#line 326
      if (options.strict_modes) {
#line 326
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 326
        if (tmp___1 == 0) {
#line 326
          if (st.st_uid != 0U) {
#line 326
            if (st.st_uid != pw->pw_uid) {
#line 330
              log("Authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 326
            if ((st.st_mode & 18U) != 0U) {
#line 330
              log("Authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 334
              temporarily_use_uid(pw);
#line 335
              tmp___0 = check_host_in_hostfile((char const   *)user_hostfile, host,
                                               key, found, (int *)((void *)0));
#line 335
              host_status = (int )tmp___0;
#line 337
              restore_uid();
            }
          }
        } else {
#line 334
          temporarily_use_uid(pw);
#line 335
          tmp___0 = check_host_in_hostfile((char const   *)user_hostfile, host, key,
                                           found, (int *)((void *)0));
#line 335
          host_status = (int )tmp___0;
#line 337
          restore_uid();
        }
      } else {
#line 334
        temporarily_use_uid(pw);
#line 335
        tmp___0 = check_host_in_hostfile((char const   *)user_hostfile, host, key,
                                         found, (int *)((void *)0));
#line 335
        host_status = (int )tmp___0;
#line 337
        restore_uid();
      }
#line 339
      xfree((void *)user_hostfile);
    }
  }
#line 341
  key_free(found);
#line 343
  if (host_status == 0) {
#line 343
    tmp___2 = "ok";
  } else {
#line 343
    tmp___2 = "not found";
  }
#line 343
  debug2("check_key_in_hostfiles: key %s for %s", tmp___2, host);
#line 345
  return ((enum __anonenum_HostStatus_66 )host_status);
}
}
#line 361 "auth.c"
int secure_filename(FILE *f , char const   *file , struct passwd *pw , char *err ,
                    size_t errlen ) 
{ uid_t uid ;
  char buf___2[4096] ;
  char *cp ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 365
  uid = pw->pw_uid;
#line 370
  tmp___1 = realpath((char const   * __restrict  )file, (char * __restrict  )(buf___2));
#line 370
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 371
    tmp = __errno_location();
#line 371
    tmp___0 = strerror(*tmp);
#line 371
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"realpath %s failed: %s",
             file, tmp___0);
#line 373
    return (-1);
  }
#line 377
  tmp___2 = fileno(f);
#line 377
  tmp___3 = fstat(tmp___2, & st);
#line 377
  if (tmp___3 < 0) {
#line 380
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
             buf___2);
#line 382
    return (-1);
  } else {
#line 377
    if (st.st_uid != 0U) {
#line 377
      if (st.st_uid != uid) {
#line 380
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___2);
#line 382
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      if ((st.st_mode & 18U) != 0U) {
#line 380
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___2);
#line 382
        return (-1);
      }
    }
  }
#line 386
  while (1) {
#line 387
    cp = dirname(buf___2);
#line 387
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 388
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"dirname() failed");
#line 389
      return (-1);
    }
#line 391
    strlcpy(buf___2, (char const   *)cp, sizeof(buf___2));
#line 393
    debug3("secure_filename: checking \'%s\'", buf___2);
#line 394
    tmp___4 = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 394
    if (tmp___4 < 0) {
#line 397
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
               buf___2);
#line 399
      return (-1);
    } else {
#line 394
      if (st.st_uid != 0U) {
#line 394
        if (st.st_uid != uid) {
#line 397
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___2);
#line 399
          return (-1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 394
        if ((st.st_mode & 18U) != 0U) {
#line 397
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___2);
#line 399
          return (-1);
        }
      }
    }
#line 403
    if (0) {
#line 403
      __s1_len = strlen((char const   *)pw->pw_dir);
#line 403
      __s2_len = strlen((char const   *)(buf___2));
#line 403
      if (! ((unsigned int )((void const   *)(pw->pw_dir + 1)) - (unsigned int )((void const   *)pw->pw_dir) == 1U)) {
        goto _L___2;
      } else {
#line 403
        if (__s1_len >= 4U) {
          _L___2: /* CIL Label */ 
#line 403
          if (! ((unsigned int )((void const   *)(buf___2 + 1)) - (unsigned int )((void const   *)(buf___2)) == 1U)) {
#line 403
            tmp___14 = 1;
          } else {
#line 403
            if (__s2_len >= 4U) {
#line 403
              tmp___14 = 1;
            } else {
#line 403
              tmp___14 = 0;
            }
          }
        } else {
#line 403
          tmp___14 = 0;
        }
      }
#line 403
      if (tmp___14) {
#line 403
        tmp___10 = __builtin_strcmp((char const   *)pw->pw_dir, (char const   *)(buf___2));
      } else {
#line 403
        tmp___13 = __builtin_strcmp((char const   *)pw->pw_dir, (char const   *)(buf___2));
#line 403
        tmp___10 = tmp___13;
      }
    } else {
#line 403
      tmp___13 = __builtin_strcmp((char const   *)pw->pw_dir, (char const   *)(buf___2));
#line 403
      tmp___10 = tmp___13;
    }
#line 403
    if (tmp___10 == 0) {
#line 404
      debug3("secure_filename: terminating check at \'%s\'", buf___2);
#line 406
      break;
    }
#line 412
    if (0) {
#line 412
      __s1_len___0 = strlen("/");
#line 412
      __s2_len___0 = strlen((char const   *)(buf___2));
#line 412
      if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
        goto _L___4;
      } else {
#line 412
        if (__s1_len___0 >= 4U) {
          _L___4: /* CIL Label */ 
#line 412
          if (! ((unsigned int )((void const   *)(buf___2 + 1)) - (unsigned int )((void const   *)(buf___2)) == 1U)) {
#line 412
            tmp___24 = 1;
          } else {
#line 412
            if (__s2_len___0 >= 4U) {
#line 412
              tmp___24 = 1;
            } else {
#line 412
              tmp___24 = 0;
            }
          }
        } else {
#line 412
          tmp___24 = 0;
        }
      }
#line 412
      if (tmp___24) {
#line 412
        tmp___20 = __builtin_strcmp("/", (char const   *)(buf___2));
      } else {
#line 412
        tmp___23 = __builtin_strcmp("/", (char const   *)(buf___2));
#line 412
        tmp___20 = tmp___23;
      }
    } else {
#line 412
      tmp___23 = __builtin_strcmp("/", (char const   *)(buf___2));
#line 412
      tmp___20 = tmp___23;
    }
#line 412
    if (tmp___20 == 0) {
#line 413
      break;
    } else {
#line 412
      if (0) {
#line 412
        __s1_len___1 = strlen(".");
#line 412
        __s2_len___1 = strlen((char const   *)(buf___2));
#line 412
        if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
          goto _L___6;
        } else {
#line 412
          if (__s1_len___1 >= 4U) {
            _L___6: /* CIL Label */ 
#line 412
            if (! ((unsigned int )((void const   *)(buf___2 + 1)) - (unsigned int )((void const   *)(buf___2)) == 1U)) {
#line 412
              tmp___34 = 1;
            } else {
#line 412
              if (__s2_len___1 >= 4U) {
#line 412
                tmp___34 = 1;
              } else {
#line 412
                tmp___34 = 0;
              }
            }
          } else {
#line 412
            tmp___34 = 0;
          }
        }
#line 412
        if (tmp___34) {
#line 412
          tmp___30 = __builtin_strcmp(".", (char const   *)(buf___2));
        } else {
#line 412
          tmp___33 = __builtin_strcmp(".", (char const   *)(buf___2));
#line 412
          tmp___30 = tmp___33;
        }
      } else {
#line 412
        tmp___33 = __builtin_strcmp(".", (char const   *)(buf___2));
#line 412
        tmp___30 = tmp___33;
      }
#line 412
      if (tmp___30 == 0) {
#line 413
        break;
      }
    }
  }
#line 415
  return (0);
}
}
#line 1 "auth1.o"
#line 90 "auth.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 94
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 95
int auth_password(Authctxt *authctxt , char const   *password ) ;
#line 96
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 136
char *get_challenge(Authctxt *authctxt ) ;
#line 137
int verify_response(Authctxt *authctxt , char const   *response ) ;
#line 29 "session.h"
void do_authenticated(Authctxt *authctxt ) ;
#line 42 "auth1.c"
static char buf___0[1024]  ;
#line 39 "auth1.c"
static char *get_authname(int type ) 
{ 

  {
#line 43
  switch (type) {
  case 9: 
#line 45
  return ((char *)"password");
  case 6: 
#line 47
  return ((char *)"rsa");
  case 35: 
#line 49
  return ((char *)"rhosts-rsa");
  case 5: 
#line 51
  return ((char *)"rhosts");
  case 39: 
  case 41: 
#line 54
  return ((char *)"challenge-response");
  }
#line 60
  snprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 61
  return (buf___0);
}
}
#line 68 "auth1.c"
static void do_authloop(Authctxt *authctxt ) 
{ int authenticated ;
  u_int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char info[1024] ;
  u_int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  u_int ulen ;
  int type ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___0 ;
  int _p ;
  int _e ;
  int tmp___1 ;
  int tmp___2 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___3 ;
  char *challenge ;
  char *tmp___4 ;
  char *response ;
  char *tmp___5 ;
  int _p___3 ;
  int _e___3 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 71
  authenticated = 0;
#line 80
  type = 0;
#line 81
  pw = authctxt->pw;
#line 83
  if (authctxt->valid) {
#line 83
    tmp = "";
  } else {
#line 83
    tmp = "illegal user ";
  }
#line 83
  debug("Attempting authentication for %s%.100s.", tmp, authctxt->user);
#line 87
  if (options.password_authentication) {
#line 87
    tmp___0 = auth_password(authctxt, "");
#line 87
    if (tmp___0) {
#line 98
      auth_log(authctxt, 1, (char *)"without authentication", (char *)"");
#line 99
      return;
    }
  }
#line 103
  packet_start((unsigned char)15);
#line 104
  packet_send();
#line 105
  packet_write_wait();
#line 107
  client_user = (char *)((void *)0);
#line 109
  while (1) {
#line 111
    authenticated = 0;
#line 113
    info[0] = (char )'\000';
#line 116
    type = packet_read(& plen);
#line 119
    switch (type) {
    case 5: 
#line 179
    if (! options.rhosts_authentication) {
#line 180
      verbose("Rhosts authentication disabled.");
#line 181
      break;
    }
#line 189
    client_user = packet_get_string(& ulen);
#line 190
    while (1) {
#line 190
      _p = plen;
#line 190
      _e = (int )(4U + ulen);
#line 190
      if (_p != _e) {
#line 190
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 190);
#line 190
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 190
      break;
    }
#line 193
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 195
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 196
    break;
    case 35: 
#line 199
    if (! options.rhosts_rsa_authentication) {
#line 200
      verbose("Rhosts with RSA authentication disabled.");
#line 201
      break;
    }
#line 208
    client_user = packet_get_string(& ulen);
#line 211
    client_host_key = RSA_new();
#line 212
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 213
      fatal("RSA_new failed");
    }
#line 214
    client_host_key->e = BN_new();
#line 215
    client_host_key->n = BN_new();
#line 216
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 217
      fatal("BN_new failed");
    } else {
#line 216
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 217
        fatal("BN_new failed");
      }
    }
#line 218
    bits = packet_get_int();
#line 219
    packet_get_bignum(client_host_key->e, & elen);
#line 220
    packet_get_bignum(client_host_key->n, & nlen);
#line 222
    tmp___2 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 222
    if (bits != (u_int )tmp___2) {
#line 223
      tmp___1 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 223
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___1, bits);
    }
#line 225
    while (1) {
#line 225
      _p___0 = plen;
#line 225
      _e___0 = (int )((((4U + ulen) + 4U) + (u_int )elen) + (u_int )nlen);
#line 225
      if (_p___0 != _e___0) {
#line 225
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            225);
#line 225
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 225
      break;
    }
#line 227
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 228
    RSA_free(client_host_key);
#line 230
    snprintf((char * __restrict  )(info), sizeof(info), (char const   * __restrict  )" ruser %.100s",
             client_user);
#line 231
    break;
    case 6: 
#line 234
    if (! options.rsa_authentication) {
#line 235
      verbose("RSA authentication disabled.");
#line 236
      break;
    }
#line 239
    n___0 = BN_new();
#line 240
    packet_get_bignum(n___0, & nlen);
#line 241
    while (1) {
#line 241
      _p___1 = plen;
#line 241
      _e___1 = nlen;
#line 241
      if (_p___1 != _e___1) {
#line 241
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            241);
#line 241
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 241
      break;
    }
#line 242
    authenticated = auth_rsa(pw, n___0);
#line 243
    BN_clear_free(n___0);
#line 244
    break;
    case 9: 
#line 247
    if (! options.password_authentication) {
#line 248
      verbose("Password authentication disabled.");
#line 249
      break;
    }
#line 256
    password = packet_get_string(& dlen);
#line 257
    while (1) {
#line 257
      _p___2 = plen;
#line 257
      _e___2 = (int )(4U + dlen);
#line 257
      if (_p___2 != _e___2) {
#line 257
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            257);
#line 257
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 257
      break;
    }
#line 268
    authenticated = auth_password(authctxt, (char const   *)password);
#line 271
    tmp___3 = strlen((char const   *)password);
#line 271
    memset((void *)password, 0, tmp___3);
#line 272
    xfree((void *)password);
#line 273
    break;
    case 39: 
#line 276
    debug("rcvd SSH_CMSG_AUTH_TIS");
#line 277
    if (options.challenge_response_authentication == 1) {
#line 278
      tmp___4 = get_challenge(authctxt);
#line 278
      challenge = tmp___4;
#line 279
      if ((unsigned int )challenge != (unsigned int )((void *)0)) {
#line 280
        debug("sending challenge \'%s\'", challenge);
#line 281
        packet_start((unsigned char)40);
#line 282
        packet_put_cstring((char const   *)challenge);
#line 283
        xfree((void *)challenge);
#line 284
        packet_send();
#line 285
        packet_write_wait();
        goto __Cont;
      }
    }
#line 289
    break;
    case 41: 
#line 291
    debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
#line 292
    if (options.challenge_response_authentication == 1) {
#line 293
      tmp___5 = packet_get_string(& dlen);
#line 293
      response = tmp___5;
#line 294
      debug("got response \'%s\'", response);
#line 295
      while (1) {
#line 295
        _p___3 = plen;
#line 295
        _e___3 = (int )(4U + dlen);
#line 295
        if (_p___3 != _e___3) {
#line 295
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "auth1.c",
              295);
#line 295
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 295
        break;
      }
#line 296
      authenticated = verify_response(authctxt, (char const   *)response);
#line 297
      memset((void *)response, 'r', dlen);
#line 298
      xfree((void *)response);
    }
#line 300
    break;
    default: 
#line 307
    log("Unknown message during authentication: type %d", type);
#line 308
    break;
    }
#line 316
    if (! authctxt->valid) {
#line 316
      if (authenticated) {
#line 317
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt->user);
      }
    }
#line 329
    if (authenticated) {
#line 329
      if ((authctxt->pw)->pw_uid == 0U) {
#line 329
        tmp___6 = get_authname(type);
#line 329
        tmp___7 = auth_root_allowed(tmp___6);
#line 329
        if (! tmp___7) {
#line 331
          authenticated = 0;
        }
      }
    }
#line 339
    tmp___8 = get_authname(type);
#line 339
    auth_log(authctxt, authenticated, tmp___8, info);
#line 341
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 342
      xfree((void *)client_user);
#line 343
      client_user = (char *)((void *)0);
    }
#line 346
    if (authenticated) {
#line 347
      return;
    }
#line 349
    tmp___9 = authctxt->failures;
#line 349
    (authctxt->failures) ++;
#line 349
    if (tmp___9 > 6) {
#line 355
      packet_disconnect("Too many authentication failures for %.100s", authctxt->user);
    }
#line 358
    packet_start((unsigned char)15);
#line 359
    packet_send();
#line 360
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 368 "auth1.c"
void do_authentication(void) 
{ Authctxt *authctxt ;
  struct passwd *pw ;
  int plen ;
  u_int ulen ;
  char *p ;
  char *user ;
  char *style ;
  int _p ;
  int _e ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;

  {
#line 375
  style = (char *)((void *)0);
#line 378
  packet_read_expect(& plen, 4);
#line 381
  user = packet_get_string(& ulen);
#line 382
  while (1) {
#line 382
    _p = plen;
#line 382
    _e = (int )(4U + ulen);
#line 382
    if (_p != _e) {
#line 382
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 382);
#line 382
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 382
    break;
  }
#line 384
  tmp___1 = __builtin_strchr(user, ':');
#line 384
  style = tmp___1;
#line 384
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 385
    tmp = style;
#line 385
    style ++;
#line 385
    *tmp = (char )'\000';
  }
#line 388
  tmp___3 = __builtin_strchr(user, '@');
#line 388
  p = tmp___3;
#line 388
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 389
    *p = (char )'\000';
  }
#line 391
  authctxt = authctxt_new();
#line 392
  authctxt->user = user;
#line 393
  authctxt->style = style;
#line 396
  pw = getpwnam((char const   *)user);
#line 397
  if (pw) {
#line 397
    tmp___4 = allowed_user(pw);
#line 397
    if (tmp___4) {
#line 398
      authctxt->valid = 1;
#line 399
      pw = pwcopy(pw);
    } else {
#line 401
      debug("do_authentication: illegal user %s", user);
#line 402
      pw = (struct passwd *)((void *)0);
    }
  } else {
#line 401
    debug("do_authentication: illegal user %s", user);
#line 402
    pw = (struct passwd *)((void *)0);
  }
#line 404
  authctxt->pw = pw;
#line 406
  if (pw) {
#line 406
    tmp___5 = (char const   *)user;
  } else {
#line 406
    tmp___5 = "unknown";
  }
#line 406
  setproctitle("%s", tmp___5);
#line 418
  tmp___6 = getuid();
#line 418
  if (tmp___6 != 0U) {
#line 418
    if (pw) {
#line 418
      tmp___7 = getuid();
#line 418
      if (pw->pw_uid != tmp___7) {
#line 419
        packet_disconnect("Cannot change user when server not running as root.");
      }
    }
  }
#line 426
  do_authloop(authctxt);
#line 429
  packet_start((unsigned char)14);
#line 430
  packet_send();
#line 431
  packet_write_wait();
#line 442
  do_authenticated(authctxt);
#line 443
  return;
}
}
#line 1 "auth2.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 91 "auth.h"
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 129
void userauth_finish(Authctxt *authctxt , int authenticated , char *method ) ;
#line 132
int auth2_challenge(Authctxt *authctxt , char *devs ) ;
#line 139
struct passwd *auth_get_user(void) ;
#line 33 "auth-options.h"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) ;
#line 34
void auth_clear_options(void) ;
#line 65 "auth2.c"
static Authctxt *x_authctxt  =    (Authctxt *)((void *)0);
#line 66 "auth2.c"
static int one  =    1;
#line 77
static void input_service_request(int type , int plen , void *ctxt ) ;
#line 78
static void input_userauth_request(int type , int plen , void *ctxt ) ;
#line 79
static void protocol_error(int type , int plen , void *ctxt ) ;
#line 82
static Authmethod *authmethod_lookup(char const   *name ) ;
#line 83
static char *authmethods_get(void) ;
#line 84
static int user_key_allowed(struct passwd *pw , Key *key ) ;
#line 85
static int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                                 Key *key ) ;
#line 88
static void userauth_banner(void) ;
#line 89
static int userauth_none(Authctxt *authctxt ) ;
#line 90
static int userauth_passwd(Authctxt *authctxt ) ;
#line 91
static int userauth_pubkey(Authctxt *authctxt ) ;
#line 92
static int userauth_hostbased(Authctxt *authctxt ) ;
#line 93
static int userauth_kbdint(Authctxt *authctxt ) ;
#line 95 "auth2.c"
Authmethod authmethods[6]  = {      {(char *)"none", & userauth_none, & one}, 
        {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication}, 
        {(char *)"password", & userauth_passwd, & options.password_authentication}, 
        {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication}, 
        {(char *)"hostbased",
      & userauth_hostbased, & options.hostbased_authentication}, 
        {(char *)((void *)0), (int (*)(Authctxt *authctxt ))((void *)0), (int *)((void *)0)}};
#line 118 "auth2.c"
void do_authentication2(void) 
{ Authctxt *authctxt ;
  Authctxt *tmp ;

  {
#line 121
  tmp = authctxt_new();
#line 121
  authctxt = tmp;
#line 123
  x_authctxt = authctxt;
#line 126
  if (options.challenge_response_authentication) {
#line 127
    options.kbd_interactive_authentication = 1;
  }
#line 128
  if (options.pam_authentication_via_kbd_int) {
#line 129
    options.kbd_interactive_authentication = 1;
  }
#line 131
  dispatch_init(& protocol_error);
#line 132
  dispatch_set(5, & input_service_request);
#line 133
  dispatch_run(0, & authctxt->success, (void *)authctxt);
#line 134
  do_authenticated(authctxt);
#line 135
  return;
}
}
#line 137 "auth2.c"
static void protocol_error(int type , int plen , void *ctxt ) 
{ 

  {
#line 140
  log("auth: protocol error: type %d plen %d", type, plen);
#line 141
  packet_start((unsigned char)3);
#line 142
  packet_put_int(0U);
#line 143
  packet_send();
#line 144
  packet_write_wait();
#line 145
  return;
}
}
#line 147 "auth2.c"
static void input_service_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  u_int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 150
  authctxt = (Authctxt *)ctxt;
#line 152
  accept___0 = 0;
#line 153
  tmp = packet_get_string(& len);
#line 153
  service = tmp;
#line 154
  while (1) {
#line 154
    tmp___0 = packet_remaining();
#line 154
    _len = tmp___0;
#line 154
    if (_len > 0) {
#line 154
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          154);
#line 154
      packet_disconnect("Packet integrity error.");
    }
#line 154
    break;
  }
#line 156
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 157
    fatal("input_service_request: no authctxt");
  }
#line 159
  if (0) {
#line 159
    __s1_len = strlen((char const   *)service);
#line 159
    __s2_len = strlen("ssh-userauth");
#line 159
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 159
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 159
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 159
          tmp___10 = 1;
        } else {
#line 159
          if (__s2_len >= 4U) {
#line 159
            tmp___10 = 1;
          } else {
#line 159
            tmp___10 = 0;
          }
        }
      } else {
#line 159
        tmp___10 = 0;
      }
    }
#line 159
    if (tmp___10) {
#line 159
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 159
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 159
      tmp___6 = tmp___9;
    }
  } else {
#line 159
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 159
    tmp___6 = tmp___9;
  }
#line 159
  if (tmp___6 == 0) {
#line 160
    if (! authctxt->success) {
#line 161
      accept___0 = 1;
#line 163
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 168
  if (accept___0) {
#line 169
    packet_start((unsigned char)6);
#line 170
    packet_put_cstring((char const   *)service);
#line 171
    packet_send();
#line 172
    packet_write_wait();
  } else {
#line 174
    debug("bad service request %s", service);
#line 175
    packet_disconnect("bad service request %s", service);
  }
#line 177
  xfree((void *)service);
#line 178
  return;
}
}
#line 180 "auth2.c"
static void input_userauth_request(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  char *tmp ;
  char *tmp___1 ;
  struct passwd *pw ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 183
  authctxt = (Authctxt *)ctxt;
#line 184
  m___0 = (Authmethod *)((void *)0);
#line 185
  style = (char *)((void *)0);
#line 186
  authenticated = 0;
#line 188
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 189
    fatal("input_userauth_request: no authctxt");
  }
#line 191
  user = packet_get_string((u_int *)((void *)0));
#line 192
  service = packet_get_string((u_int *)((void *)0));
#line 193
  method = packet_get_string((u_int *)((void *)0));
#line 194
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 195
  debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);
#line 197
  tmp___1 = __builtin_strchr(user, ':');
#line 197
  style = tmp___1;
#line 197
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 198
    tmp = style;
#line 198
    style ++;
#line 198
    *tmp = (char)0;
  }
#line 200
  tmp___35 = authctxt->attempt;
#line 200
  (authctxt->attempt) ++;
#line 200
  if (tmp___35 == 0) {
#line 202
    pw = (struct passwd *)((void *)0);
#line 203
    pw = getpwnam((char const   *)user);
#line 204
    if (pw) {
#line 204
      tmp___2 = allowed_user(pw);
#line 204
      if (tmp___2) {
#line 204
        if (0) {
#line 204
          __s1_len = strlen((char const   *)service);
#line 204
          __s2_len = strlen("ssh-connection");
#line 204
          if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
            goto _L___0;
          } else {
#line 204
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 204
              if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 204
                tmp___12 = 1;
              } else {
#line 204
                if (__s2_len >= 4U) {
#line 204
                  tmp___12 = 1;
                } else {
#line 204
                  tmp___12 = 0;
                }
              }
            } else {
#line 204
              tmp___12 = 0;
            }
          }
#line 204
          if (tmp___12) {
#line 204
            tmp___8 = __builtin_strcmp((char const   *)service, "ssh-connection");
          } else {
#line 204
            tmp___11 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 204
            tmp___8 = tmp___11;
          }
        } else {
#line 204
          tmp___11 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 204
          tmp___8 = tmp___11;
        }
#line 204
        if (tmp___8 == 0) {
#line 205
          authctxt->pw = pwcopy(pw);
#line 206
          authctxt->valid = 1;
#line 207
          debug2("input_userauth_request: setting up authctxt for %s", user);
        } else {
#line 212
          log("input_userauth_request: illegal user %s", user);
        }
      } else {
#line 212
        log("input_userauth_request: illegal user %s", user);
      }
    } else {
#line 212
      log("input_userauth_request: illegal user %s", user);
    }
#line 217
    if (pw) {
#line 217
      tmp___13 = (char const   *)user;
    } else {
#line 217
      tmp___13 = "unknown";
    }
#line 217
    setproctitle("%s", tmp___13);
#line 218
    authctxt->user = xstrdup((char const   *)user);
#line 219
    authctxt->service = xstrdup((char const   *)service);
#line 220
    if (style) {
#line 220
      authctxt->style = xstrdup((char const   *)style);
    } else {
#line 220
      authctxt->style = (char *)((void *)0);
    }
  } else {
#line 221
    if (0) {
#line 221
      __s1_len___0 = strlen((char const   *)user);
#line 221
      __s2_len___0 = strlen((char const   *)authctxt->user);
#line 221
      if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
        goto _L___2;
      } else {
#line 221
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 221
          if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 221
            tmp___24 = 1;
          } else {
#line 221
            if (__s2_len___0 >= 4U) {
#line 221
              tmp___24 = 1;
            } else {
#line 221
              tmp___24 = 0;
            }
          }
        } else {
#line 221
          tmp___24 = 0;
        }
      }
#line 221
      if (tmp___24) {
#line 221
        tmp___20 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
      } else {
#line 221
        tmp___23 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 221
        tmp___20 = tmp___23;
      }
    } else {
#line 221
      tmp___23 = __builtin_strcmp((char const   *)user, (char const   *)authctxt->user);
#line 221
      tmp___20 = tmp___23;
    }
#line 222
    if (tmp___20 != 0) {
#line 223
      packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                        authctxt->user, authctxt->service, user, service);
    } else {
#line 222
      if (0) {
#line 222
        __s1_len___1 = strlen((char const   *)service);
#line 222
        __s2_len___1 = strlen((char const   *)authctxt->service);
#line 222
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___4;
        } else {
#line 222
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 222
            if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 222
              tmp___34 = 1;
            } else {
#line 222
              if (__s2_len___1 >= 4U) {
#line 222
                tmp___34 = 1;
              } else {
#line 222
                tmp___34 = 0;
              }
            }
          } else {
#line 222
            tmp___34 = 0;
          }
        }
#line 222
        if (tmp___34) {
#line 222
          tmp___30 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
        } else {
#line 222
          tmp___33 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 222
          tmp___30 = tmp___33;
        }
      } else {
#line 222
        tmp___33 = __builtin_strcmp((char const   *)service, (char const   *)authctxt->service);
#line 222
        tmp___30 = tmp___33;
      }
#line 222
      if (tmp___30 != 0) {
#line 223
        packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                          authctxt->user, authctxt->service, user, service);
      }
    }
  }
#line 228
  dispatch_set(61, & protocol_error);
#line 229
  authctxt->postponed = 0;
#line 238
  m___0 = authmethod_lookup((char const   *)method);
#line 239
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 240
    debug2("input_userauth_request: try method %s", method);
#line 241
    authenticated = (*(m___0->userauth))(authctxt);
  }
#line 243
  userauth_finish(authctxt, authenticated, method);
#line 245
  xfree((void *)service);
#line 246
  xfree((void *)user);
#line 247
  xfree((void *)method);
#line 248
  return;
}
}
#line 250 "auth2.c"
void userauth_finish(Authctxt *authctxt , int authenticated , char *method ) 
{ char *methods ;
  int tmp ;
  int tmp___0 ;

  {
#line 255
  if (! authctxt->valid) {
#line 255
    if (authenticated) {
#line 256
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt->user);
    }
  }
#line 260
  if (authenticated) {
#line 260
    if ((authctxt->pw)->pw_uid == 0U) {
#line 260
      tmp = auth_root_allowed(method);
#line 260
      if (! tmp) {
#line 262
        authenticated = 0;
      }
    }
  }
#line 271
  auth_log(authctxt, authenticated, method, (char *)" ssh2");
#line 273
  if (authctxt->postponed) {
#line 274
    return;
  }
#line 277
  if (authenticated == 1) {
#line 279
    dispatch_set(50, & protocol_error);
#line 280
    packet_start((unsigned char)52);
#line 281
    packet_send();
#line 282
    packet_write_wait();
#line 284
    authctxt->success = 1;
  } else {
#line 286
    tmp___0 = authctxt->failures;
#line 286
    (authctxt->failures) ++;
#line 286
    if (tmp___0 > 6) {
#line 287
      packet_disconnect("Too many authentication failures for %.100s", authctxt->user);
    }
#line 288
    methods = authmethods_get();
#line 289
    packet_start((unsigned char)51);
#line 290
    packet_put_cstring((char const   *)methods);
#line 291
    packet_put_char(0);
#line 292
    packet_send();
#line 293
    packet_write_wait();
#line 294
    xfree((void *)methods);
  }
#line 296
  return;
}
}
#line 298 "auth2.c"
static void userauth_banner(void) 
{ struct stat st ;
  char *banner ;
  off_t len ;
  off_t n___0 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 302
  banner = (char *)((void *)0);
#line 306
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 307
    return;
  } else {
#line 306
    if (datafellows & 128) {
#line 307
      return;
    }
  }
#line 308
  fd = open((char const   *)options.banner, 0);
#line 308
  if (fd < 0) {
#line 309
    return;
  }
#line 310
  tmp = fstat(fd, & st);
#line 310
  if (tmp < 0) {
    goto done;
  }
#line 312
  len = st.st_size;
#line 313
  tmp___0 = xmalloc((unsigned int )(len + 1L));
#line 313
  banner = (char *)tmp___0;
#line 314
  tmp___1 = read(fd, (void *)banner, (unsigned int )len);
#line 314
  n___0 = (long )tmp___1;
#line 314
  if (n___0 < 0L) {
    goto done;
  }
#line 316
  *(banner + n___0) = (char )'\000';
#line 317
  packet_start((unsigned char)53);
#line 318
  packet_put_cstring((char const   *)banner);
#line 319
  packet_put_cstring("");
#line 320
  packet_send();
#line 321
  debug("userauth_banner: sent");
  done: 
#line 323
  if (banner) {
#line 324
    xfree((void *)banner);
  }
#line 325
  close(fd);
#line 326
  return;
}
}
#line 329 "auth2.c"
static int userauth_none(Authctxt *authctxt ) 
{ Authmethod *m___0 ;
  Authmethod *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 333
  tmp = authmethod_lookup("none");
#line 333
  m___0 = tmp;
#line 334
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 335
    m___0->enabled = (int *)((void *)0);
  }
#line 336
  while (1) {
#line 336
    tmp___0 = packet_remaining();
#line 336
    _len = tmp___0;
#line 336
    if (_len > 0) {
#line 336
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          336);
#line 336
      packet_disconnect("Packet integrity error.");
    }
#line 336
    break;
  }
#line 337
  userauth_banner();
#line 339
  if (authctxt->valid == 0) {
#line 340
    return (0);
  }
#line 351
  tmp___1 = auth_password(authctxt, "");
#line 351
  return (tmp___1);
}
}
#line 355 "auth2.c"
static int userauth_passwd(Authctxt *authctxt ) 
{ char *password ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 359
  authenticated = 0;
#line 362
  tmp = packet_get_char();
#line 362
  change = (int )tmp;
#line 363
  if (change) {
#line 364
    log("password change not supported");
  }
#line 365
  password = packet_get_string(& len);
#line 366
  while (1) {
#line 366
    tmp___0 = packet_remaining();
#line 366
    _len = tmp___0;
#line 366
    if (_len > 0) {
#line 366
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          366);
#line 366
      packet_disconnect("Packet integrity error.");
    }
#line 366
    break;
  }
#line 367
  if (authctxt->valid) {
#line 367
    tmp___1 = auth_password(authctxt, (char const   *)password);
#line 367
    if (tmp___1 == 1) {
#line 378
      authenticated = 1;
    }
  }
#line 379
  memset((void *)password, 0, len);
#line 380
  xfree((void *)password);
#line 381
  return (authenticated);
}
}
#line 384 "auth2.c"
static int userauth_kbdint(Authctxt *authctxt ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  int _len ;
  int tmp ;

  {
#line 387
  authenticated = 0;
#line 390
  lang = packet_get_string((u_int *)((void *)0));
#line 391
  devs = packet_get_string((u_int *)((void *)0));
#line 392
  while (1) {
#line 392
    tmp = packet_remaining();
#line 392
    _len = tmp;
#line 392
    if (_len > 0) {
#line 392
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          392);
#line 392
      packet_disconnect("Packet integrity error.");
    }
#line 392
    break;
  }
#line 394
  debug("keyboard-interactive devs %s", devs);
#line 396
  if (options.challenge_response_authentication) {
#line 397
    authenticated = auth2_challenge(authctxt, devs);
  }
#line 403
  xfree((void *)devs);
#line 404
  xfree((void *)lang);
#line 409
  return (authenticated);
}
}
#line 412 "auth2.c"
static int userauth_pubkey(Authctxt *authctxt ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 420
  authenticated = 0;
#line 422
  if (! authctxt->valid) {
#line 423
    debug2("userauth_pubkey: disabled because of invalid user");
#line 424
    return (0);
  }
#line 426
  tmp = packet_get_char();
#line 426
  have_sig = (int )tmp;
#line 427
  if (datafellows & 32) {
#line 428
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 430
    pkblob = packet_get_string(& blen);
#line 431
    buffer_init(& b);
#line 432
    buffer_append(& b, (char const   *)pkblob, blen);
#line 434
    pkalg = buffer_get_string(& b, & alen);
#line 435
    buffer_free(& b);
  } else {
#line 437
    pkalg = packet_get_string(& alen);
#line 438
    pkblob = packet_get_string(& blen);
  }
#line 440
  pktype = key_type_from_name(pkalg);
#line 441
  if (pktype == 3) {
#line 443
    log("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
#line 444
    xfree((void *)pkalg);
#line 445
    xfree((void *)pkblob);
#line 446
    return (0);
  }
#line 448
  key = key_from_blob((u_char *)pkblob, (int )blen);
#line 449
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 450
    if (have_sig) {
#line 451
      sig = packet_get_string(& slen);
#line 452
      while (1) {
#line 452
        tmp___0 = packet_remaining();
#line 452
        _len = tmp___0;
#line 452
        if (_len > 0) {
#line 452
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              452);
#line 452
          packet_disconnect("Packet integrity error.");
        }
#line 452
        break;
      }
#line 453
      buffer_init(& b);
#line 454
      if (datafellows & 16) {
#line 455
        buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
      } else {
#line 457
        buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
      }
#line 460
      buffer_put_char(& b, 50);
#line 461
      buffer_put_cstring(& b, (char const   *)authctxt->user);
#line 462
      if (datafellows & 2) {
#line 462
        tmp___1 = "ssh-userauth";
      } else {
#line 462
        tmp___1 = (char const   *)authctxt->service;
      }
#line 462
      buffer_put_cstring(& b, tmp___1);
#line 466
      if (datafellows & 32) {
#line 467
        buffer_put_char(& b, have_sig);
      } else {
#line 469
        buffer_put_cstring(& b, "publickey");
#line 470
        buffer_put_char(& b, have_sig);
#line 471
        buffer_put_cstring(& b, (char const   *)pkalg);
      }
#line 473
      buffer_put_string(& b, (void const   *)pkblob, blen);
#line 478
      tmp___2 = user_key_allowed(authctxt->pw, key);
#line 478
      if (tmp___2) {
#line 478
        tmp___3 = buffer_len(& b);
#line 478
        tmp___4 = buffer_ptr(& b);
#line 478
        tmp___5 = key_verify(key, (u_char *)sig, (int )slen, (u_char *)tmp___4, (int )tmp___3);
#line 478
        if (tmp___5 == 1) {
#line 480
          authenticated = 1;
        }
      }
#line 481
      buffer_clear(& b);
#line 482
      xfree((void *)sig);
    } else {
#line 484
      debug("test whether pkalg/pkblob are acceptable");
#line 485
      while (1) {
#line 485
        tmp___6 = packet_remaining();
#line 485
        _len___0 = tmp___6;
#line 485
        if (_len___0 > 0) {
#line 485
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              485);
#line 485
          packet_disconnect("Packet integrity error.");
        }
#line 485
        break;
      }
#line 495
      tmp___7 = user_key_allowed(authctxt->pw, key);
#line 495
      if (tmp___7) {
#line 496
        packet_start((unsigned char)60);
#line 497
        packet_put_string((char const   *)pkalg, alen);
#line 498
        packet_put_string((char const   *)pkblob, blen);
#line 499
        packet_send();
#line 500
        packet_write_wait();
#line 501
        authctxt->postponed = 1;
      }
    }
#line 504
    if (authenticated != 1) {
#line 505
      auth_clear_options();
    }
#line 506
    key_free(key);
  }
#line 508
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 509
  xfree((void *)pkalg);
#line 510
  xfree((void *)pkblob);
#line 515
  return (authenticated);
}
}
#line 518 "auth2.c"
static int userauth_hostbased(Authctxt *authctxt ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  int tmp ;
  u_int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 526
  authenticated = 0;
#line 528
  if (! authctxt->valid) {
#line 529
    debug2("userauth_hostbased: disabled because of invalid user");
#line 530
    return (0);
  }
#line 532
  pkalg = packet_get_string(& alen);
#line 533
  pkblob = packet_get_string(& blen);
#line 534
  chost = packet_get_string((u_int *)((void *)0));
#line 535
  cuser = packet_get_string((u_int *)((void *)0));
#line 536
  sig = packet_get_string(& slen);
#line 538
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
#line 547
  pktype = key_type_from_name(pkalg);
#line 548
  if (pktype == 3) {
#line 550
    log("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 554
  key = key_from_blob((u_char *)pkblob, (int )blen);
#line 555
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 556
    debug("userauth_hostbased: cannot decode key: %s", pkalg);
    goto done;
  }
#line 559
  if (datafellows & 65536) {
#line 559
    service = (char *)"ssh-userauth";
  } else {
#line 559
    service = authctxt->service;
  }
#line 561
  buffer_init(& b);
#line 562
  buffer_put_string(& b, (void const   *)session_id2, (unsigned int )session_id2_len);
#line 564
  buffer_put_char(& b, 50);
#line 565
  buffer_put_cstring(& b, (char const   *)authctxt->user);
#line 566
  buffer_put_cstring(& b, (char const   *)service);
#line 567
  buffer_put_cstring(& b, "hostbased");
#line 568
  buffer_put_string(& b, (void const   *)pkalg, alen);
#line 569
  buffer_put_string(& b, (void const   *)pkblob, blen);
#line 570
  buffer_put_cstring(& b, (char const   *)chost);
#line 571
  buffer_put_cstring(& b, (char const   *)cuser);
#line 576
  tmp = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, chost, key);
#line 576
  if (tmp) {
#line 576
    tmp___0 = buffer_len(& b);
#line 576
    tmp___1 = buffer_ptr(& b);
#line 576
    tmp___2 = key_verify(key, (u_char *)sig, (int )slen, (u_char *)tmp___1, (int )tmp___0);
#line 576
    if (tmp___2 == 1) {
#line 578
      authenticated = 1;
    }
  }
#line 580
  buffer_clear(& b);
#line 581
  key_free(key);
  done: 
#line 584
  debug2("userauth_hostbased: authenticated %d", authenticated);
#line 585
  xfree((void *)pkalg);
#line 586
  xfree((void *)pkblob);
#line 587
  xfree((void *)cuser);
#line 588
  xfree((void *)chost);
#line 589
  xfree((void *)sig);
#line 590
  return (authenticated);
}
}
#line 595 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 598
  if ((unsigned int )x_authctxt != (unsigned int )((void *)0)) {
#line 598
    if (x_authctxt->valid) {
#line 598
      tmp = x_authctxt->pw;
    } else {
#line 598
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 598
    tmp = (struct passwd *)((void *)0);
  }
#line 598
  return (tmp);
}
}
#line 603 "auth2.c"
static char *authmethods_get(void) 
{ Authmethod *method ;
  u_int size ;
  char *list ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 606
  method = (Authmethod *)((void *)0);
#line 607
  size = (u_int )0;
#line 610
  method = authmethods;
#line 610
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 611
    if (0) {
#line 611
      __s1_len = strlen((char const   *)method->name);
#line 611
      __s2_len = strlen("none");
#line 611
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___0;
      } else {
#line 611
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 611
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 611
            tmp___8 = 1;
          } else {
#line 611
            if (__s2_len >= 4U) {
#line 611
              tmp___8 = 1;
            } else {
#line 611
              tmp___8 = 0;
            }
          }
        } else {
#line 611
          tmp___8 = 0;
        }
      }
#line 611
      if (tmp___8) {
#line 611
        tmp___4 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 611
        tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 611
        tmp___4 = tmp___7;
      }
    } else {
#line 611
      tmp___7 = __builtin_strcmp((char const   *)method->name, "none");
#line 611
      tmp___4 = tmp___7;
    }
#line 611
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 613
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 613
      if (*(method->enabled) != 0) {
#line 614
        if (size != 0U) {
#line 615
          tmp___9 = strlen(",");
#line 615
          size += tmp___9;
        }
#line 616
        tmp___10 = strlen((char const   *)method->name);
#line 616
        size += tmp___10;
      }
    }
    __Cont: /* CIL Label */ 
#line 610
    method ++;
  }
#line 619
  size ++;
#line 620
  tmp___11 = xmalloc(size);
#line 620
  list = (char *)tmp___11;
#line 621
  *(list + 0) = (char )'\000';
#line 623
  method = authmethods;
#line 623
  while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 624
    if (0) {
#line 624
      __s1_len___0 = strlen((char const   *)method->name);
#line 624
      __s2_len___0 = strlen("none");
#line 624
      if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
        goto _L___2;
      } else {
#line 624
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 624
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 624
            tmp___21 = 1;
          } else {
#line 624
            if (__s2_len___0 >= 4U) {
#line 624
              tmp___21 = 1;
            } else {
#line 624
              tmp___21 = 0;
            }
          }
        } else {
#line 624
          tmp___21 = 0;
        }
      }
#line 624
      if (tmp___21) {
#line 624
        tmp___17 = __builtin_strcmp((char const   *)method->name, "none");
      } else {
#line 624
        tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 624
        tmp___17 = tmp___20;
      }
    } else {
#line 624
      tmp___20 = __builtin_strcmp((char const   *)method->name, "none");
#line 624
      tmp___17 = tmp___20;
    }
#line 624
    if (tmp___17 == 0) {
      goto __Cont___0;
    }
#line 626
    if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 626
      if (*(method->enabled) != 0) {
#line 627
        if ((int )*(list + 0) != 0) {
#line 628
          strlcat(list, ",", size);
        }
#line 629
        strlcat(list, (char const   *)method->name, size);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 623
    method ++;
  }
#line 632
  return (list);
}
}
#line 635 "auth2.c"
static Authmethod *authmethod_lookup(char const   *name ) 
{ Authmethod *method ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 638
  method = (Authmethod *)((void *)0);
#line 639
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 640
    method = authmethods;
#line 640
    while ((unsigned int )method->name != (unsigned int )((void *)0)) {
#line 643
      if ((unsigned int )method->enabled != (unsigned int )((void *)0)) {
#line 643
        if (*(method->enabled) != 0) {
#line 643
          if (0) {
#line 643
            __s1_len = strlen(name);
#line 643
            __s2_len = strlen((char const   *)method->name);
#line 643
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 643
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 643
                if (! ((unsigned int )((void const   *)(method->name + 1)) - (unsigned int )((void const   *)method->name) == 1U)) {
#line 643
                  tmp___8 = 1;
                } else {
#line 643
                  if (__s2_len >= 4U) {
#line 643
                    tmp___8 = 1;
                  } else {
#line 643
                    tmp___8 = 0;
                  }
                }
              } else {
#line 643
                tmp___8 = 0;
              }
            }
#line 643
            if (tmp___8) {
#line 643
              tmp___4 = __builtin_strcmp(name, (char const   *)method->name);
            } else {
#line 643
              tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 643
              tmp___4 = tmp___7;
            }
          } else {
#line 643
            tmp___7 = __builtin_strcmp(name, (char const   *)method->name);
#line 643
            tmp___4 = tmp___7;
          }
#line 643
          if (tmp___4 == 0) {
#line 644
            return (method);
          }
        }
      }
#line 640
      method ++;
    }
  }
#line 645
  if (name) {
#line 645
    tmp___9 = name;
  } else {
#line 645
    tmp___9 = "NULL";
  }
#line 645
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 646
  return ((Authmethod *)((void *)0));
}
}
#line 650 "auth2.c"
static int user_key_allowed2(struct passwd *pw , Key *key , char *file ) 
{ char line[8192] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 654
  found_key = 0;
#line 656
  linenum = (u_long )0;
#line 660
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 661
    return (0);
  }
#line 664
  temporarily_use_uid(pw);
#line 666
  debug("trying public key file %s", file);
#line 669
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 669
  if (tmp < 0) {
#line 671
    restore_uid();
#line 672
    return (0);
  }
#line 675
  f = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 676
  if (! f) {
#line 678
    restore_uid();
#line 679
    return (0);
  }
#line 681
  if (options.strict_modes) {
#line 681
    tmp___0 = secure_filename(f, (char const   *)file, pw, line, sizeof(line));
#line 681
    if (tmp___0 != 0) {
#line 683
      fclose(f);
#line 684
      log("Authentication refused: %s", line);
#line 685
      restore_uid();
#line 686
      return (0);
    }
  }
#line 689
  found_key = 0;
#line 690
  found = key_new(key->type);
#line 692
  while (1) {
#line 692
    tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 692
    if (! tmp___5) {
#line 692
      break;
    }
#line 693
    options___0 = (char *)((void *)0);
#line 694
    linenum ++;
#line 696
    cp = line;
#line 696
    while (1) {
#line 696
      if (! ((int )*cp == 32)) {
#line 696
        if (! ((int )*cp == 9)) {
#line 696
          break;
        }
      }
#line 696
      cp ++;
    }
#line 698
    if (! *cp) {
#line 699
      continue;
    } else {
#line 698
      if ((int )*cp == 10) {
#line 699
        continue;
      } else {
#line 698
        if ((int )*cp == 35) {
#line 699
          continue;
        }
      }
    }
#line 701
    tmp___2 = key_read(found, & cp);
#line 701
    if (tmp___2 != 1) {
#line 703
      quoted = 0;
#line 704
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 705
      options___0 = cp;
#line 706
      while (1) {
#line 706
        if (*cp) {
#line 706
          if (! quoted) {
#line 706
            if ((int )*cp != 32) {
#line 706
              if (! ((int )*cp != 9)) {
#line 706
                break;
              }
            } else {
#line 706
              break;
            }
          }
        } else {
#line 706
          break;
        }
#line 707
        if ((int )*cp == 92) {
#line 707
          if ((int )*(cp + 1) == 34) {
#line 708
            cp ++;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 709
          if ((int )*cp == 34) {
#line 710
            quoted = ! quoted;
          }
        }
#line 706
        cp ++;
      }
#line 713
      while (1) {
#line 713
        if (! ((int )*cp == 32)) {
#line 713
          if (! ((int )*cp == 9)) {
#line 713
            break;
          }
        }
#line 713
        cp ++;
      }
#line 715
      tmp___1 = key_read(found, & cp);
#line 715
      if (tmp___1 != 1) {
#line 716
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 718
        continue;
      }
    }
#line 721
    tmp___3 = key_equal(found, key);
#line 721
    if (tmp___3) {
#line 721
      tmp___4 = auth_parse_options(pw, options___0, file, linenum);
#line 721
      if (tmp___4 == 1) {
#line 723
        found_key = 1;
#line 724
        debug("matching key found: file %s, line %lu", file, linenum);
#line 726
        break;
      }
    }
  }
#line 729
  restore_uid();
#line 730
  fclose(f);
#line 731
  key_free(found);
#line 732
  if (! found_key) {
#line 733
    debug2("key not found");
  }
#line 734
  return (found_key);
}
}
#line 738 "auth2.c"
static int user_key_allowed(struct passwd *pw , Key *key ) 
{ int success ;
  char *file ;

  {
#line 744
  file = authorized_keys_file(pw);
#line 745
  success = user_key_allowed2(pw, key, file);
#line 746
  xfree((void *)file);
#line 747
  if (success) {
#line 748
    return (success);
  }
#line 751
  file = authorized_keys_file2(pw);
#line 752
  success = user_key_allowed2(pw, key, file);
#line 753
  xfree((void *)file);
#line 754
  return (success);
}
}
#line 758 "auth2.c"
static int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                                 Key *key ) 
{ char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  int host_status ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  HostStatus tmp___4 ;
  char const   *tmp___5 ;
  HostStatus tmp___6 ;

  {
#line 765
  resolvedname = get_canonical_hostname(options.reverse_mapping_check);
#line 766
  ipaddr = get_remote_ipaddr();
#line 768
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
#line 771
  if (options.hostbased_uses_name_from_packet_only) {
#line 772
    tmp = auth_rhosts2(pw, cuser, (char const   *)chost, (char const   *)chost);
#line 772
    if (tmp == 0) {
#line 773
      return (0);
    }
#line 774
    lookup = (char const   *)chost;
  } else {
#line 776
    tmp___0 = strlen((char const   *)chost);
#line 776
    len = (int )tmp___0;
#line 776
    if (len > 0) {
#line 776
      if ((int )*(chost + (len - 1)) == 46) {
#line 777
        debug2("stripping trailing dot from chost %s", chost);
#line 778
        *(chost + (len - 1)) = (char )'\000';
      }
    }
#line 780
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
#line 780
    if (tmp___1 != 0) {
#line 781
      log("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
          chost, ipaddr, resolvedname);
    }
#line 784
    tmp___2 = auth_rhosts2(pw, cuser, resolvedname, ipaddr);
#line 784
    if (tmp___2 == 0) {
#line 785
      return (0);
    }
#line 786
    lookup = resolvedname;
  }
#line 788
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
#line 790
  if (options.ignore_user_known_hosts) {
#line 790
    tmp___3 = (char const   *)((void *)0);
  } else {
#line 790
    tmp___3 = "~/.ssh/known_hosts";
  }
#line 790
  tmp___4 = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts",
                                   tmp___3);
#line 790
  host_status = (int )tmp___4;
#line 795
  if (host_status == 1) {
#line 796
    if (options.ignore_user_known_hosts) {
#line 796
      tmp___5 = (char const   *)((void *)0);
    } else {
#line 796
      tmp___5 = "~/.ssh/known_hosts2";
    }
#line 796
    tmp___6 = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts2",
                                     tmp___5);
#line 796
    host_status = (int )tmp___6;
  }
#line 801
  return (host_status == 0);
}
}
#line 1 "auth-chall.o"
#line 34 "auth-chall.c"
KbdintDevice *devices[1] ;
#line 35 "auth-chall.c"
static KbdintDevice *device  ;
#line 37 "auth-chall.c"
char *get_challenge(Authctxt *authctxt ) 
{ char *challenge ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int tmp ;

  {
#line 44
  device = devices[0];
#line 45
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 46
    return ((char *)((void *)0));
  }
#line 47
  authctxt->kbdintctxt = (*(device->init_ctx))(authctxt);
#line 47
  if ((unsigned int )authctxt->kbdintctxt == (unsigned int )((void *)0)) {
#line 48
    return ((char *)((void *)0));
  }
#line 49
  tmp = (*(device->query))(authctxt->kbdintctxt, & name, & info, & numprompts, & prompts,
                           & echo_on);
#line 49
  if (tmp) {
#line 51
    (*(device->free_ctx))(authctxt->kbdintctxt);
#line 52
    authctxt->kbdintctxt = (void *)0;
#line 53
    return ((char *)((void *)0));
  }
#line 55
  if (numprompts < 1U) {
#line 56
    fatal("get_challenge: numprompts < 1");
  }
#line 57
  challenge = xstrdup((char const   *)*(prompts + 0));
#line 58
  i = 0U;
#line 58
  while (i < numprompts) {
#line 59
    xfree((void *)*(prompts + i));
#line 58
    i ++;
  }
#line 60
  xfree((void *)prompts);
#line 61
  xfree((void *)name);
#line 62
  xfree((void *)echo_on);
#line 63
  xfree((void *)info);
#line 65
  return (challenge);
}
}
#line 67 "auth-chall.c"
int verify_response(Authctxt *authctxt , char const   *response ) 
{ char *resp[1] ;
  int res ;
  int tmp ;

  {
#line 73
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 74
    return (0);
  }
#line 75
  if ((unsigned int )authctxt->kbdintctxt == (unsigned int )((void *)0)) {
#line 76
    return (0);
  }
#line 77
  resp[0] = (char *)response;
#line 78
  res = (*(device->respond))(authctxt->kbdintctxt, 1U, resp);
#line 79
  (*(device->free_ctx))(authctxt->kbdintctxt);
#line 80
  authctxt->kbdintctxt = (void *)0;
#line 81
  if (res) {
#line 81
    tmp = 0;
  } else {
#line 81
    tmp = 1;
  }
#line 81
  return (tmp);
}
}
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
#line 1 "auth2-chall.o"
#line 36 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt ) ;
#line 37
static int send_userauth_info_request(Authctxt *authctxt ) ;
#line 38
static void input_userauth_info_response(int type , int plen , void *ctxt ) ;
#line 48 "auth2-chall.c"
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
#line 67 "auth2-chall.c"
static KbdintAuthctxt *kbdint_alloc(char const   *devs ) 
{ KbdintAuthctxt *kbdintctxt ;
  int i ;
  char buf___2[1024] ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 74
  tmp = xmalloc(sizeof(KbdintAuthctxt ));
#line 74
  kbdintctxt = (KbdintAuthctxt *)tmp;
#line 75
  if (0) {
#line 75
    __s1_len = strlen(devs);
#line 75
    __s2_len = strlen("");
#line 75
    if (! ((unsigned int )((void const   *)(devs + 1)) - (unsigned int )((void const   *)devs) == 1U)) {
      goto _L___0;
    } else {
#line 75
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 75
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 75
          tmp___9 = 1;
        } else {
#line 75
          if (__s2_len >= 4U) {
#line 75
            tmp___9 = 1;
          } else {
#line 75
            tmp___9 = 0;
          }
        }
      } else {
#line 75
        tmp___9 = 0;
      }
    }
#line 75
    if (tmp___9) {
#line 75
      tmp___5 = __builtin_strcmp(devs, "");
    } else {
#line 75
      tmp___8 = __builtin_strcmp(devs, "");
#line 75
      tmp___5 = tmp___8;
    }
  } else {
#line 75
    tmp___8 = __builtin_strcmp(devs, "");
#line 75
    tmp___5 = tmp___8;
  }
#line 75
  if (tmp___5 == 0) {
#line 76
    buf___2[0] = (char )'\000';
#line 77
    i = 0;
#line 77
    while (devices[i]) {
#line 78
      if (i != 0) {
#line 79
        strlcat(buf___2, ",", sizeof(buf___2));
      }
#line 80
      strlcat(buf___2, (devices[i])->name, sizeof(buf___2));
#line 77
      i ++;
    }
#line 82
    debug("kbdint_alloc: devices \'%s\'", buf___2);
#line 83
    kbdintctxt->devices = xstrdup((char const   *)(buf___2));
  } else {
#line 85
    kbdintctxt->devices = xstrdup(devs);
  }
#line 87
  kbdintctxt->ctxt = (void *)0;
#line 88
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 90
  return (kbdintctxt);
}
}
#line 92 "auth2-chall.c"
static void kbdint_reset_device(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 95
  if (kbdintctxt->ctxt) {
#line 96
    (*((kbdintctxt->device)->free_ctx))(kbdintctxt->ctxt);
#line 97
    kbdintctxt->ctxt = (void *)0;
  }
#line 99
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 100
  return;
}
}
#line 101 "auth2-chall.c"
static void kbdint_free(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 104
  if (kbdintctxt->device) {
#line 105
    kbdint_reset_device(kbdintctxt);
  }
#line 106
  if (kbdintctxt->devices) {
#line 107
    xfree((void *)kbdintctxt->devices);
#line 108
    kbdintctxt->devices = (char *)((void *)0);
  }
#line 110
  xfree((void *)kbdintctxt);
#line 111
  return;
}
}
#line 113 "auth2-chall.c"
static int kbdint_next_device(KbdintAuthctxt *kbdintctxt ) 
{ size_t len ;
  char *t ;
  int i ;
  unsigned int tmp___64 ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  char const   *tmp___92 ;
  int tmp___93 ;

  {
#line 120
  if (kbdintctxt->device) {
#line 121
    kbdint_reset_device(kbdintctxt);
  }
#line 122
  while (1) {
#line 124
    if (kbdintctxt->devices) {
#line 124
      tmp___64 = __builtin_strcspn((char const   *)kbdintctxt->devices, ",");
#line 124
      len = tmp___64;
    } else {
#line 124
      len = 0U;
    }
#line 126
    if (len == 0U) {
#line 127
      break;
    }
#line 128
    i = 0;
#line 128
    while (devices[i]) {
#line 129
      if (0) {
#line 129
        if (0) {
#line 129
          __s1_len___0 = strlen((char const   *)kbdintctxt->devices);
#line 129
          __s2_len___0 = strlen((devices[i])->name);
#line 129
          if (! ((unsigned int )((void const   *)(kbdintctxt->devices + 1)) - (unsigned int )((void const   *)kbdintctxt->devices) == 1U)) {
            goto _L___2;
          } else {
#line 129
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 129
              if (! ((unsigned int )((void const   *)((devices[i])->name + 1)) - (unsigned int )((void const   *)(devices[i])->name) == 1U)) {
#line 129
                tmp___88 = 1;
              } else {
#line 129
                if (__s2_len___0 >= 4U) {
#line 129
                  tmp___88 = 1;
                } else {
#line 129
                  tmp___88 = 0;
                }
              }
            } else {
#line 129
              tmp___88 = 0;
            }
          }
#line 129
          if (tmp___88) {
#line 129
            tmp___84 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
          } else {
#line 129
            tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 129
            tmp___84 = tmp___87;
          }
        } else {
#line 129
          tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 129
          tmp___84 = tmp___87;
        }
#line 129
        tmp___78 = tmp___84;
      } else {
#line 129
        tmp___78 = strncmp((char const   *)kbdintctxt->devices, (devices[i])->name,
                           len);
      }
#line 129
      if (tmp___78 == 0) {
#line 130
        kbdintctxt->device = devices[i];
      }
#line 128
      i ++;
    }
#line 131
    t = kbdintctxt->devices;
#line 132
    if (*(t + len)) {
#line 132
      kbdintctxt->devices = xstrdup((char const   *)((t + len) + 1));
    } else {
#line 132
      kbdintctxt->devices = (char *)((void *)0);
    }
#line 133
    xfree((void *)t);
#line 134
    if (kbdintctxt->devices) {
#line 134
      tmp___92 = (char const   *)kbdintctxt->devices;
    } else {
#line 134
      tmp___92 = "<empty>";
    }
#line 134
    debug2("kbdint_next_device: devices %s", tmp___92);
#line 122
    if (kbdintctxt->devices) {
#line 122
      if (! (! kbdintctxt->device)) {
#line 122
        break;
      }
    } else {
#line 122
      break;
    }
  }
#line 138
  if (kbdintctxt->device) {
#line 138
    tmp___93 = 1;
  } else {
#line 138
    tmp___93 = 0;
  }
#line 138
  return (tmp___93);
}
}
#line 145 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt , char *devs ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  KbdintAuthctxt *tmp___1 ;
  int tmp___2 ;

  {
#line 148
  if (devs) {
#line 148
    tmp = (char const   *)devs;
  } else {
#line 148
    tmp = "<no devs>";
  }
#line 148
  if (authctxt->user) {
#line 148
    tmp___0 = (char const   *)authctxt->user;
  } else {
#line 148
    tmp___0 = "<nouser>";
  }
#line 148
  debug("auth2_challenge: user=%s devs=%s", tmp___0, tmp);
#line 152
  if ((unsigned int )authctxt->user == (unsigned int )((void *)0)) {
#line 153
    return (0);
  } else {
#line 152
    if (! devs) {
#line 153
      return (0);
    }
  }
#line 154
  if ((unsigned int )authctxt->kbdintctxt == (unsigned int )((void *)0)) {
#line 155
    tmp___1 = kbdint_alloc((char const   *)devs);
#line 155
    authctxt->kbdintctxt = (void *)tmp___1;
  }
#line 156
  tmp___2 = auth2_challenge_start(authctxt);
#line 156
  return (tmp___2);
}
}
#line 160 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt ) 
{ KbdintAuthctxt *kbdintctxt ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 163
  kbdintctxt = (KbdintAuthctxt *)authctxt->kbdintctxt;
#line 165
  if (kbdintctxt->devices) {
#line 165
    tmp = (char const   *)kbdintctxt->devices;
  } else {
#line 165
    tmp = "<empty>";
  }
#line 165
  debug2("auth2_challenge_start: devices %s", tmp);
#line 168
  tmp___0 = kbdint_next_device(kbdintctxt);
#line 168
  if (tmp___0 == 0) {
#line 169
    kbdint_free(kbdintctxt);
#line 170
    authctxt->kbdintctxt = (void *)0;
#line 171
    return (0);
  }
#line 173
  debug("auth2_challenge_start: trying authentication method \'%s\'", (kbdintctxt->device)->name);
#line 176
  kbdintctxt->ctxt = (*((kbdintctxt->device)->init_ctx))(authctxt);
#line 176
  if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 177
    kbdint_free(kbdintctxt);
#line 178
    authctxt->kbdintctxt = (void *)0;
#line 179
    return (0);
  }
#line 181
  tmp___1 = send_userauth_info_request(authctxt);
#line 181
  if (tmp___1 == 0) {
#line 182
    kbdint_free(kbdintctxt);
#line 183
    authctxt->kbdintctxt = (void *)0;
#line 184
    return (0);
  }
#line 186
  dispatch_set(61, & input_userauth_info_response);
#line 189
  authctxt->postponed = 1;
#line 190
  return (0);
}
}
#line 193 "auth2-chall.c"
static int send_userauth_info_request(Authctxt *authctxt ) 
{ KbdintAuthctxt *kbdintctxt ;
  char *name ;
  char *instr ;
  char **prompts ;
  int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int tmp ;

  {
#line 201
  kbdintctxt = (KbdintAuthctxt *)authctxt->kbdintctxt;
#line 202
  tmp = (*((kbdintctxt->device)->query))(kbdintctxt->ctxt, & name, & instr, & numprompts,
                                         & prompts, & echo_on);
#line 202
  if (tmp) {
#line 204
    return (0);
  }
#line 206
  packet_start((unsigned char)60);
#line 207
  packet_put_cstring((char const   *)name);
#line 208
  packet_put_cstring((char const   *)instr);
#line 209
  packet_put_cstring("");
#line 210
  packet_put_int(numprompts);
#line 211
  i = 0;
#line 211
  while ((u_int )i < numprompts) {
#line 212
    packet_put_cstring((char const   *)*(prompts + i));
#line 213
    packet_put_char((int )*(echo_on + i));
#line 211
    i ++;
  }
#line 215
  packet_send();
#line 216
  packet_write_wait();
#line 218
  i = 0;
#line 218
  while ((u_int )i < numprompts) {
#line 219
    xfree((void *)*(prompts + i));
#line 218
    i ++;
  }
#line 220
  xfree((void *)prompts);
#line 221
  xfree((void *)echo_on);
#line 222
  xfree((void *)name);
#line 223
  xfree((void *)instr);
#line 224
  return (1);
}
}
#line 227 "auth2-chall.c"
static void input_userauth_info_response(int type , int plen , void *ctxt ) 
{ Authctxt *authctxt ;
  KbdintAuthctxt *kbdintctxt ;
  int i ;
  int authenticated ;
  int res ;
  int len ;
  u_int nresp ;
  char **response ;
  char *method ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 230
  authctxt = (Authctxt *)ctxt;
#line 232
  authenticated = 0;
#line 234
  response = (char **)((void *)0);
#line 236
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 237
    fatal("input_userauth_info_response: no authctxt");
  }
#line 238
  kbdintctxt = (KbdintAuthctxt *)authctxt->kbdintctxt;
#line 239
  if ((unsigned int )kbdintctxt == (unsigned int )((void *)0)) {
#line 240
    fatal("input_userauth_info_response: no kbdintctxt");
  } else {
#line 239
    if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 240
      fatal("input_userauth_info_response: no kbdintctxt");
    }
  }
#line 241
  if ((unsigned int )kbdintctxt->device == (unsigned int )((void *)0)) {
#line 242
    fatal("input_userauth_info_response: no device");
  }
#line 244
  authctxt->postponed = 0;
#line 245
  nresp = packet_get_int();
#line 246
  if (nresp > 0U) {
#line 247
    tmp = xmalloc(nresp * sizeof(char *));
#line 247
    response = (char **)tmp;
#line 248
    i = 0;
#line 248
    while ((u_int )i < nresp) {
#line 249
      *(response + i) = packet_get_string((u_int *)((void *)0));
#line 248
      i ++;
    }
  }
#line 251
  while (1) {
#line 251
    tmp___0 = packet_remaining();
#line 251
    _len = tmp___0;
#line 251
    if (_len > 0) {
#line 251
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
          251);
#line 251
      packet_disconnect("Packet integrity error.");
    }
#line 251
    break;
  }
#line 253
  if (authctxt->valid) {
#line 254
    res = (*((kbdintctxt->device)->respond))(kbdintctxt->ctxt, nresp, response);
  } else {
#line 257
    res = -1;
  }
#line 260
  i = 0;
#line 260
  while ((u_int )i < nresp) {
#line 261
    tmp___1 = strlen((char const   *)*(response + i));
#line 261
    memset((void *)*(response + i), 'r', tmp___1);
#line 262
    xfree((void *)*(response + i));
#line 260
    i ++;
  }
#line 264
  if (response) {
#line 265
    xfree((void *)response);
  }
#line 267
  switch (res) {
  case 0: 
#line 270
  authenticated = 1;
#line 271
  break;
  case 1: 
#line 274
  authctxt->postponed = 1;
#line 275
  tmp___2 = send_userauth_info_request(authctxt);
#line 275
  if (tmp___2 == 0) {
#line 276
    authctxt->postponed = 0;
  }
#line 278
  break;
  default: ;
#line 281
  break;
  }
#line 284
  tmp___3 = strlen("keyboard-interactive");
#line 284
  tmp___4 = strlen((kbdintctxt->device)->name);
#line 284
  len = (int )((tmp___3 + 2U) + tmp___4);
#line 286
  tmp___5 = xmalloc((unsigned int )len);
#line 286
  method = (char *)tmp___5;
#line 287
  *(method + 0) = (char )'\000';
#line 288
  strlcat(method, "keyboard-interactive", (unsigned int )len);
#line 289
  strlcat(method, "/", (unsigned int )len);
#line 290
  strlcat(method, (kbdintctxt->device)->name, (unsigned int )len);
#line 292
  if (! authctxt->postponed) {
#line 294
    dispatch_set(61, (dispatch_fn *)((void *)0));
#line 296
    if (authenticated) {
#line 297
      kbdint_free(kbdintctxt);
#line 298
      authctxt->kbdintctxt = (void *)0;
    } else {
#line 302
      auth2_challenge_start(authctxt);
    }
  }
#line 305
  userauth_finish(authctxt, authenticated, method);
#line 306
  xfree((void *)method);
#line 307
  return;
}
}
#line 1 "auth-rhosts.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 37 "auth-rhosts.c"
static int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                             char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___2[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 46
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 47
  if (! f) {
#line 48
    return (0);
  }
#line 50
  while (1) {
#line 50
    tmp___50 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 50
    if (! tmp___50) {
#line 50
      break;
    }
#line 55
    cp = buf___2;
#line 55
    while (1) {
#line 55
      if (! ((int )*cp == 32)) {
#line 55
        if (! ((int )*cp == 9)) {
#line 55
          break;
        }
      }
#line 55
      cp ++;
    }
#line 57
    if ((int )*cp == 35) {
#line 58
      continue;
    } else {
#line 57
      if ((int )*cp == 10) {
#line 58
        continue;
      } else {
#line 57
        if (! *cp) {
#line 58
          continue;
        }
      }
    }
#line 64
    if (0) {
#line 64
      if (0) {
#line 64
        __s1_len___0 = strlen((char const   *)cp);
#line 64
        __s2_len___0 = strlen("NO_PLUS");
#line 64
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 64
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 64
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 64
              tmp___22 = 1;
            } else {
#line 64
              if (__s2_len___0 >= 4U) {
#line 64
                tmp___22 = 1;
              } else {
#line 64
                tmp___22 = 0;
              }
            }
          } else {
#line 64
            tmp___22 = 0;
          }
        }
#line 64
        if (tmp___22) {
#line 64
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 64
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
          tmp___18 = tmp___21;
        }
      } else {
#line 64
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 64
        tmp___18 = tmp___21;
      }
#line 64
      tmp___12 = tmp___18;
    } else {
#line 64
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 64
    if (tmp___12 == 0) {
#line 65
      continue;
    }
#line 71
    tmp___25 = sscanf((char const   * __restrict  )(buf___2), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 71
    switch (tmp___25) {
    case 0: 
#line 73
    packet_send_debug("Found empty line in %.100s.", filename);
#line 74
    continue;
    case 1: 
#line 77
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 78
    break;
    case 2: 
#line 81
    break;
    case 3: 
#line 83
    packet_send_debug("Found garbage in %.100s.", filename);
#line 84
    continue;
    default: ;
#line 87
    continue;
    }
#line 90
    host = hostbuf;
#line 91
    user = userbuf;
#line 92
    negated = 0;
#line 95
    if ((int )*(host + 0) == 45) {
#line 96
      negated = 1;
#line 97
      host ++;
    } else {
#line 98
      if ((int )*(host + 0) == 43) {
#line 99
        host ++;
      }
    }
#line 101
    if ((int )*(user + 0) == 45) {
#line 102
      negated = 1;
#line 103
      user ++;
    } else {
#line 104
      if ((int )*(user + 0) == 43) {
#line 105
        user ++;
      }
    }
#line 108
    if (! *(host + 0)) {
#line 110
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 112
      continue;
    } else {
#line 108
      if (! *(user + 0)) {
#line 110
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 112
        continue;
      }
    }
#line 115
    if ((int )*(host + 0) == 64) {
#line 116
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 116
      if (! tmp___26) {
#line 116
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 116
        if (! tmp___27) {
#line 118
          continue;
        }
      }
    } else {
#line 119
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 119
      if (tmp___28) {
#line 119
        if (0) {
#line 119
          __s1_len___1 = strlen((char const   *)host);
#line 119
          __s2_len___1 = strlen(ipaddr);
#line 119
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 119
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 119
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 119
                tmp___38 = 1;
              } else {
#line 119
                if (__s2_len___1 >= 4U) {
#line 119
                  tmp___38 = 1;
                } else {
#line 119
                  tmp___38 = 0;
                }
              }
            } else {
#line 119
              tmp___38 = 0;
            }
          }
#line 119
          if (tmp___38) {
#line 119
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 119
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 119
            tmp___34 = tmp___37;
          }
        } else {
#line 119
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 119
          tmp___34 = tmp___37;
        }
#line 119
        if (tmp___34 != 0) {
#line 120
          continue;
        }
      }
    }
#line 123
    if ((int )*(user + 0) == 64) {
#line 124
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 124
      if (! tmp___39) {
#line 125
        continue;
      }
    } else {
#line 126
      if (0) {
#line 126
        __s1_len___2 = strlen((char const   *)user);
#line 126
        __s2_len___2 = strlen(client_user);
#line 126
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 126
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 126
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 126
              tmp___49 = 1;
            } else {
#line 126
              if (__s2_len___2 >= 4U) {
#line 126
                tmp___49 = 1;
              } else {
#line 126
                tmp___49 = 0;
              }
            }
          } else {
#line 126
            tmp___49 = 0;
          }
        }
#line 126
        if (tmp___49) {
#line 126
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 126
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 126
          tmp___45 = tmp___48;
        }
      } else {
#line 126
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 126
        tmp___45 = tmp___48;
      }
#line 126
      if (tmp___45 != 0) {
#line 127
        continue;
      }
    }
#line 130
    fclose(f);
#line 133
    if (negated) {
#line 134
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 136
      return (0);
    }
#line 139
    return (1);
  }
#line 143
  fclose(f);
#line 144
  return (0);
}
}
#line 153 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char const   *hostname ;
  char const   *ipaddr ;
  int ret ;

  {
#line 159
  hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 160
  ipaddr = get_remote_ipaddr();
#line 161
  ret = auth_rhosts2(pw, client_user, hostname, ipaddr);
#line 162
  return (ret);
}
}
#line 171 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 165 "auth-rhosts.c"
int auth_rhosts2(struct passwd *pw , char const   *client_user , char const   *hostname ,
                 char const   *ipaddr ) 
{ char buf___2[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 174
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user, hostname,
         ipaddr);
#line 178
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 179
    return (0);
  }
#line 182
  temporarily_use_uid(pw);
#line 188
  rhosts_file_index = 0U;
#line 188
  while (rhosts_files[rhosts_file_index]) {
#line 191
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 193
    tmp = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 193
    if (tmp >= 0) {
#line 194
      break;
    }
#line 188
    rhosts_file_index ++;
  }
#line 197
  restore_uid();
#line 200
  if (! rhosts_files[rhosts_file_index]) {
#line 200
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 200
    if (tmp___0 < 0) {
#line 200
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 200
      if (tmp___1 < 0) {
#line 203
        return (0);
      }
    }
  }
#line 206
  if (pw->pw_uid != 0U) {
#line 207
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 207
    if (tmp___2) {
#line 209
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 211
      return (1);
    }
#line 213
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 213
    if (tmp___3) {
#line 215
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 217
      return (1);
    }
  }
#line 224
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 224
  if (tmp___4 < 0) {
#line 225
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 227
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 229
    return (0);
  }
#line 231
  if (options.strict_modes) {
#line 231
    if (st.st_uid != 0U) {
#line 231
      if (st.st_uid != pw->pw_uid) {
#line 234
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 236
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 238
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 231
      if ((st.st_mode & 18U) != 0U) {
#line 234
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 236
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 238
        return (0);
      }
    }
  }
#line 241
  temporarily_use_uid(pw);
#line 244
  rhosts_file_index = 0U;
#line 244
  while (rhosts_files[rhosts_file_index]) {
#line 247
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 249
    tmp___5 = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 249
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 258
    if (options.strict_modes) {
#line 258
      if (st.st_uid != 0U) {
#line 258
        if (st.st_uid != pw->pw_uid) {
#line 261
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___2);
#line 263
          packet_send_debug("Bad file modes for %.200s", buf___2);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 258
        if ((st.st_mode & 18U) != 0U) {
#line 261
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___2);
#line 263
          packet_send_debug("Bad file modes for %.200s", buf___2);
          goto __Cont;
        }
      }
    }
#line 267
    if (options.ignore_rhosts) {
#line 268
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 273
    tmp___6 = check_rhosts_file((char const   *)(buf___2), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 273
    if (tmp___6) {
#line 274
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 277
      restore_uid();
#line 278
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 244
    rhosts_file_index ++;
  }
#line 283
  restore_uid();
#line 284
  return (0);
}
}
#line 1 "auth-options.o"
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 26 "auth-options.h"
int no_port_forwarding_flag ;
#line 27
int no_agent_forwarding_flag ;
#line 28
int no_x11_forwarding_flag ;
#line 29
int no_pty_flag ;
#line 31
struct envstring *custom_environment ;
#line 26 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 27 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 28 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 29 "auth-options.c"
int no_pty_flag  =    0;
#line 32 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 35 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 39 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 42
  no_agent_forwarding_flag = 0;
#line 43
  no_port_forwarding_flag = 0;
#line 44
  no_pty_flag = 0;
#line 45
  no_x11_forwarding_flag = 0;
#line 46
  while (custom_environment) {
#line 47
    ce = custom_environment;
#line 48
    custom_environment = ce->next;
#line 49
    xfree((void *)ce->s);
#line 50
    xfree((void *)ce);
  }
#line 52
  if (forced_command) {
#line 53
    xfree((void *)forced_command);
#line 54
    forced_command = (char *)((void *)0);
  }
#line 56
  channel_clear_permitted_opens();
#line 57
  return;
}
}
#line 63 "auth-options.c"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) 
{ char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  char const   *remote_ip ;
  char const   *tmp___28 ;
  char const   *remote_host ;
  char const   *tmp___29 ;
  char *patterns ;
  size_t tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  char host[256] ;
  char sport[6] ;
  u_short port ;
  char *patterns___0 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;

  {
#line 70
  auth_clear_options();
#line 72
  if (! opts) {
#line 73
    return (1);
  }
#line 75
  while (1) {
#line 75
    if (*opts) {
#line 75
      if ((int )*opts != 32) {
#line 75
        if (! ((int )*opts != 9)) {
#line 75
          break;
        }
      } else {
#line 75
        break;
      }
    } else {
#line 75
      break;
    }
#line 76
    cp = "no-port-forwarding";
#line 77
    tmp___0 = strlen(cp);
#line 77
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 77
    if (tmp___1 == 0) {
#line 78
      packet_send_debug("Port forwarding disabled.");
#line 79
      no_port_forwarding_flag = 1;
#line 80
      tmp = strlen(cp);
#line 80
      opts += tmp;
      goto next_option;
    }
#line 83
    cp = "no-agent-forwarding";
#line 84
    tmp___3 = strlen(cp);
#line 84
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 84
    if (tmp___4 == 0) {
#line 85
      packet_send_debug("Agent forwarding disabled.");
#line 86
      no_agent_forwarding_flag = 1;
#line 87
      tmp___2 = strlen(cp);
#line 87
      opts += tmp___2;
      goto next_option;
    }
#line 90
    cp = "no-X11-forwarding";
#line 91
    tmp___6 = strlen(cp);
#line 91
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 91
    if (tmp___7 == 0) {
#line 92
      packet_send_debug("X11 forwarding disabled.");
#line 93
      no_x11_forwarding_flag = 1;
#line 94
      tmp___5 = strlen(cp);
#line 94
      opts += tmp___5;
      goto next_option;
    }
#line 97
    cp = "no-pty";
#line 98
    tmp___9 = strlen(cp);
#line 98
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 98
    if (tmp___10 == 0) {
#line 99
      packet_send_debug("Pty allocation disabled.");
#line 100
      no_pty_flag = 1;
#line 101
      tmp___8 = strlen(cp);
#line 101
      opts += tmp___8;
      goto next_option;
    }
#line 104
    cp = "command=\"";
#line 105
    tmp___17 = strlen(cp);
#line 105
    tmp___18 = strncasecmp((char const   *)opts, cp, tmp___17);
#line 105
    if (tmp___18 == 0) {
#line 106
      tmp___11 = strlen(cp);
#line 106
      opts += tmp___11;
#line 107
      tmp___12 = strlen((char const   *)opts);
#line 107
      tmp___13 = xmalloc(tmp___12 + 1U);
#line 107
      forced_command = (char *)tmp___13;
#line 108
      i = 0;
#line 109
      while (*opts) {
#line 110
        if ((int )*opts == 34) {
#line 111
          break;
        }
#line 112
        if ((int )*opts == 92) {
#line 112
          if ((int )*(opts + 1) == 34) {
#line 113
            opts += 2;
#line 114
            tmp___14 = i;
#line 114
            i ++;
#line 114
            *(forced_command + tmp___14) = (char )'\"';
#line 115
            continue;
          }
        }
#line 117
        tmp___15 = i;
#line 117
        i ++;
#line 117
        tmp___16 = opts;
#line 117
        opts ++;
#line 117
        *(forced_command + tmp___15) = *tmp___16;
      }
#line 119
      if (! *opts) {
#line 120
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 122
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 124
        xfree((void *)forced_command);
#line 125
        forced_command = (char *)((void *)0);
        goto bad_option;
      }
#line 128
      *(forced_command + i) = (char)0;
#line 129
      packet_send_debug("Forced command: %.900s", forced_command);
#line 130
      opts ++;
      goto next_option;
    }
#line 133
    cp = "environment=\"";
#line 134
    tmp___26 = strlen(cp);
#line 134
    tmp___27 = strncasecmp((char const   *)opts, cp, tmp___26);
#line 134
    if (tmp___27 == 0) {
#line 138
      tmp___19 = strlen(cp);
#line 138
      opts += tmp___19;
#line 139
      tmp___20 = strlen((char const   *)opts);
#line 139
      tmp___21 = xmalloc(tmp___20 + 1U);
#line 139
      s = (char *)tmp___21;
#line 140
      i = 0;
#line 141
      while (*opts) {
#line 142
        if ((int )*opts == 34) {
#line 143
          break;
        }
#line 144
        if ((int )*opts == 92) {
#line 144
          if ((int )*(opts + 1) == 34) {
#line 145
            opts += 2;
#line 146
            tmp___22 = i;
#line 146
            i ++;
#line 146
            *(s + tmp___22) = (char )'\"';
#line 147
            continue;
          }
        }
#line 149
        tmp___23 = i;
#line 149
        i ++;
#line 149
        tmp___24 = opts;
#line 149
        opts ++;
#line 149
        *(s + tmp___23) = *tmp___24;
      }
#line 151
      if (! *opts) {
#line 152
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 154
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 156
        xfree((void *)s);
        goto bad_option;
      }
#line 159
      *(s + i) = (char)0;
#line 160
      packet_send_debug("Adding to environment: %.900s", s);
#line 161
      debug("Adding to environment: %.900s", s);
#line 162
      opts ++;
#line 163
      tmp___25 = xmalloc(sizeof(struct envstring ));
#line 163
      new_envstring = (struct envstring *)tmp___25;
#line 164
      new_envstring->s = s;
#line 165
      new_envstring->next = custom_environment;
#line 166
      custom_environment = new_envstring;
      goto next_option;
    }
#line 169
    cp = "from=\"";
#line 170
    tmp___37 = strlen(cp);
#line 170
    tmp___38 = strncasecmp((char const   *)opts, cp, tmp___37);
#line 170
    if (tmp___38 == 0) {
#line 171
      tmp___28 = get_remote_ipaddr();
#line 171
      remote_ip = tmp___28;
#line 172
      tmp___29 = get_canonical_hostname(options.reverse_mapping_check);
#line 172
      remote_host = tmp___29;
#line 174
      tmp___30 = strlen((char const   *)opts);
#line 174
      tmp___31 = xmalloc(tmp___30 + 1U);
#line 174
      patterns = (char *)tmp___31;
#line 176
      tmp___32 = strlen(cp);
#line 176
      opts += tmp___32;
#line 177
      i = 0;
#line 178
      while (*opts) {
#line 179
        if ((int )*opts == 34) {
#line 180
          break;
        }
#line 181
        if ((int )*opts == 92) {
#line 181
          if ((int )*(opts + 1) == 34) {
#line 182
            opts += 2;
#line 183
            tmp___33 = i;
#line 183
            i ++;
#line 183
            *(patterns + tmp___33) = (char )'\"';
#line 184
            continue;
          }
        }
#line 186
        tmp___34 = i;
#line 186
        i ++;
#line 186
        tmp___35 = opts;
#line 186
        opts ++;
#line 186
        *(patterns + tmp___34) = *tmp___35;
      }
#line 188
      if (! *opts) {
#line 189
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 191
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 193
        xfree((void *)patterns);
        goto bad_option;
      }
#line 196
      *(patterns + i) = (char)0;
#line 197
      opts ++;
#line 198
      tmp___36 = match_host_and_ip(remote_host, remote_ip, (char const   *)patterns);
#line 198
      if (tmp___36 != 1) {
#line 200
        xfree((void *)patterns);
#line 201
        log("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
            pw->pw_name, remote_host, remote_ip);
#line 205
        packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                          remote_host);
#line 209
        return (0);
      }
#line 211
      xfree((void *)patterns);
      goto next_option;
    }
#line 215
    cp = "permitopen=\"";
#line 216
    tmp___48 = strlen(cp);
#line 216
    tmp___49 = strncasecmp((char const   *)opts, cp, tmp___48);
#line 216
    if (tmp___49 == 0) {
#line 219
      tmp___39 = strlen((char const   *)opts);
#line 219
      tmp___40 = xmalloc(tmp___39 + 1U);
#line 219
      patterns___0 = (char *)tmp___40;
#line 221
      tmp___41 = strlen(cp);
#line 221
      opts += tmp___41;
#line 222
      i = 0;
#line 223
      while (*opts) {
#line 224
        if ((int )*opts == 34) {
#line 225
          break;
        }
#line 226
        if ((int )*opts == 92) {
#line 226
          if ((int )*(opts + 1) == 34) {
#line 227
            opts += 2;
#line 228
            tmp___42 = i;
#line 228
            i ++;
#line 228
            *(patterns___0 + tmp___42) = (char )'\"';
#line 229
            continue;
          }
        }
#line 231
        tmp___43 = i;
#line 231
        i ++;
#line 231
        tmp___44 = opts;
#line 231
        opts ++;
#line 231
        *(patterns___0 + tmp___43) = *tmp___44;
      }
#line 233
      if (! *opts) {
#line 234
        debug("%.100s, line %lu: missing end quote", file, linenum);
#line 236
        packet_send_debug("%.100s, line %lu: missing end quote", file, linenum);
#line 238
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 241
      *(patterns___0 + i) = (char)0;
#line 242
      opts ++;
#line 243
      tmp___45 = sscanf((char const   * __restrict  )patterns___0, (char const   * __restrict  )"%255[^:]:%5[0-9]",
                        host, sport);
#line 243
      if (tmp___45 != 2) {
#line 243
        tmp___46 = sscanf((char const   * __restrict  )patterns___0, (char const   * __restrict  )"%255[^/]/%5[0-9]",
                          host, sport);
#line 243
        if (tmp___46 != 2) {
#line 245
          debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file, linenum,
                patterns___0);
#line 247
          packet_send_debug("%.100s, line %lu: Bad permitopen specification", file,
                            linenum);
#line 249
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 252
      tmp___47 = a2port((char const   *)(sport));
#line 252
      port = (unsigned short )tmp___47;
#line 252
      if ((int )port == 0) {
#line 253
        debug("%.100s, line %lu: Bad permitopen port <%.100s>", file, linenum, sport);
#line 255
        packet_send_debug("%.100s, line %lu: Bad permitopen port", file, linenum);
#line 257
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 260
      if (options.allow_tcp_forwarding) {
#line 261
        channel_add_permitted_opens(host, (int )port);
      }
#line 262
      xfree((void *)patterns___0);
      goto next_option;
    }
    next_option: 
#line 270
    if (! *opts) {
#line 271
      fatal("Bugs in auth-options.c option processing.");
    }
#line 272
    if ((int )*opts == 32) {
#line 273
      break;
    } else {
#line 272
      if ((int )*opts == 9) {
#line 273
        break;
      }
    }
#line 274
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 276
    opts ++;
  }
#line 280
  return (1);
  bad_option: 
#line 283
  log("Bad options in %.100s file, line %lu: %.50s", file, linenum, opts);
#line 285
  packet_send_debug("Bad options in %.100s file, line %lu: %.50s", file, linenum,
                    opts);
#line 288
  return (0);
}
}
#line 1 "auth-krb4.o"
#line 1 "auth-pam.o"
#line 1 "auth2-pam.o"
#line 1 "auth-passwd.o"
#line 33 "/usr/include/crypt.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 90 "auth-passwd.c"
int auth_password(Authctxt *authctxt , char const   *password ) 
{ struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *salt ;
  struct spwd *spw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  pw = authctxt->pw;
#line 116
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 117
    return (0);
  }
#line 119
  if (pw->pw_uid == 0U) {
#line 119
    if (options.permit_root_login != 3) {
#line 120
      return (0);
    }
  }
#line 129
  if ((int const   )*password == 0) {
#line 129
    if (options.permit_empty_passwd == 0) {
#line 130
      return (0);
    }
  }
#line 167
  pw_password = pw->pw_passwd;
#line 173
  spw = getspnam((char const   *)pw->pw_name);
#line 174
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 175
    pw_password = spw->sp_pwdp;
  }
#line 195
  if ((int const   )*(password + 0) == 0) {
#line 195
    if ((int )*(pw_password + 0) == 0) {
#line 196
      return (1);
    }
  }
#line 198
  if ((int )*(pw_password + 0) != 0) {
#line 199
    salt = pw_password;
  } else {
#line 201
    salt = (char *)"xx";
  }
#line 215
  encrypted_password = crypt(password, (char const   *)salt);
#line 220
  if (0) {
#line 220
    __s1_len = strlen((char const   *)encrypted_password);
#line 220
    __s2_len = strlen((char const   *)pw_password);
#line 220
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___0;
    } else {
#line 220
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 220
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 220
          tmp___8 = 1;
        } else {
#line 220
          if (__s2_len >= 4U) {
#line 220
            tmp___8 = 1;
          } else {
#line 220
            tmp___8 = 0;
          }
        }
      } else {
#line 220
        tmp___8 = 0;
      }
    }
#line 220
    if (tmp___8) {
#line 220
      tmp___4 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 220
      tmp___7 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 220
      tmp___4 = tmp___7;
    }
  } else {
#line 220
    tmp___7 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 220
    tmp___4 = tmp___7;
  }
#line 220
  return (tmp___4 == 0);
}
}
#line 1 "auth-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 98 "auth.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 60 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  u_char buf___2[32] ;
  u_char mdbuf[16] ;
  u_char response[16] ;
  MD5_CTX md ;
  u_int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  encrypted_challenge = BN_new();
#line 71
  challenge = BN_new();
#line 74
  BN_rand(challenge, 256, 0, 0);
#line 75
  ctx = BN_CTX_new();
#line 76
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 77
  BN_CTX_free(ctx);
#line 80
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 83
  packet_start((unsigned char)7);
#line 84
  packet_put_bignum(encrypted_challenge);
#line 85
  packet_send();
#line 86
  BN_clear_free(encrypted_challenge);
#line 87
  packet_write_wait();
#line 90
  packet_read_expect(& plen, 8);
#line 91
  while (1) {
#line 91
    _p = plen;
#line 91
    _e = 16;
#line 91
    if (_p != _e) {
#line 91
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 91);
#line 91
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 91
    break;
  }
#line 92
  i = 0U;
#line 92
  while (i < 16U) {
#line 93
    tmp = packet_get_char();
#line 93
    response[i] = (unsigned char )tmp;
#line 92
    i ++;
  }
#line 96
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 96
  len = (tmp___0 + 7) / 8;
#line 97
  if (len <= 0) {
#line 98
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 97
    if (len > 32) {
#line 98
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 99
  memset((void *)(buf___2), 0, 32U);
#line 100
  BN_bn2bin((BIGNUM const   *)challenge, (buf___2 + 32) - len);
#line 101
  MD5_Init(& md);
#line 102
  MD5_Update(& md, (void const   *)(buf___2), 32U);
#line 103
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 104
  MD5_Final(mdbuf, & md);
#line 105
  BN_clear_free(challenge);
#line 108
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 108
  if (tmp___1 != 0) {
#line 110
    return (0);
  }
#line 113
  return (1);
}
}
#line 122 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char *file ;
  int authenticated ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 129
  linenum = (u_long )0;
#line 134
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 135
    return (0);
  }
#line 138
  temporarily_use_uid(pw);
#line 141
  file = authorized_keys_file(pw);
#line 142
  debug("trying public RSA key file %s", file);
#line 145
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 145
  if (tmp < 0) {
#line 147
    restore_uid();
#line 148
    xfree((void *)file);
#line 149
    return (0);
  }
#line 152
  f = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 153
  if (! f) {
#line 155
    restore_uid();
#line 156
    packet_send_debug("Could not open %.900s for reading.", file);
#line 157
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 158
    xfree((void *)file);
#line 159
    return (0);
  }
#line 161
  if (options.strict_modes) {
#line 161
    tmp___0 = secure_filename(f, (char const   *)file, pw, line, sizeof(line));
#line 161
    if (tmp___0 != 0) {
#line 163
      xfree((void *)file);
#line 164
      fclose(f);
#line 165
      log("Authentication refused: %s", line);
#line 166
      packet_send_debug("Authentication refused: %s", line);
#line 167
      restore_uid();
#line 168
      return (0);
    }
  }
#line 171
  authenticated = 0;
#line 173
  pk = RSA_new();
#line 174
  pk->e = BN_new();
#line 175
  pk->n = BN_new();
#line 182
  while (1) {
#line 182
    tmp___7 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 182
    if (! tmp___7) {
#line 182
      break;
    }
#line 186
    linenum ++;
#line 189
    cp = line;
#line 189
    while (1) {
#line 189
      if (! ((int )*cp == 32)) {
#line 189
        if (! ((int )*cp == 9)) {
#line 189
          break;
        }
      }
#line 189
      cp ++;
    }
#line 191
    if (! *cp) {
#line 192
      continue;
    } else {
#line 191
      if ((int )*cp == 10) {
#line 192
        continue;
      } else {
#line 191
        if ((int )*cp == 35) {
#line 192
          continue;
        }
      }
    }
#line 200
    if ((int )*cp < 48) {
      goto _L___0;
    } else {
#line 200
      if ((int )*cp > 57) {
        _L___0: /* CIL Label */ 
#line 201
        quoted = 0;
#line 202
        options___0 = cp;
#line 203
        while (1) {
#line 203
          if (*cp) {
#line 203
            if (! quoted) {
#line 203
              if ((int )*cp != 32) {
#line 203
                if (! ((int )*cp != 9)) {
#line 203
                  break;
                }
              } else {
#line 203
                break;
              }
            }
          } else {
#line 203
            break;
          }
#line 204
          if ((int )*cp == 92) {
#line 204
            if ((int )*(cp + 1) == 34) {
#line 205
              cp ++;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 206
            if ((int )*cp == 34) {
#line 207
              quoted = ! quoted;
            }
          }
#line 203
          cp ++;
        }
      } else {
#line 210
        options___0 = (char *)((void *)0);
      }
    }
#line 213
    tmp___1 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 213
    if (! tmp___1) {
#line 214
      debug("%.100s, line %lu: non ssh1 key syntax", file, linenum);
#line 216
      continue;
    }
#line 221
    tmp___2 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 221
    if (tmp___2 != 0) {
#line 222
      continue;
    }
#line 225
    tmp___4 = BN_num_bits((BIGNUM const   *)pk->n);
#line 225
    if (bits != (u_int )tmp___4) {
#line 226
      tmp___3 = BN_num_bits((BIGNUM const   *)pk->n);
#line 226
      log("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___3, bits);
    }
#line 235
    tmp___5 = auth_parse_options(pw, options___0, file, linenum);
#line 235
    if (! tmp___5) {
#line 236
      continue;
    }
#line 239
    tmp___6 = auth_rsa_challenge_dialog(pk);
#line 239
    if (! tmp___6) {
#line 241
      verbose("Wrong response to RSA authentication challenge.");
#line 242
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 243
      continue;
    }
#line 253
    authenticated = 1;
#line 254
    break;
  }
#line 258
  restore_uid();
#line 261
  xfree((void *)file);
#line 262
  fclose(f);
#line 264
  RSA_free(pk);
#line 266
  if (authenticated) {
#line 267
    packet_send_debug("RSA authentication accepted.");
  } else {
#line 269
    auth_clear_options();
  }
#line 272
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#line 35 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 43
  debug("Trying rhosts with RSA host authentication for client user %.100s", client_user);
#line 45
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 46
    return (0);
  } else {
#line 45
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 46
      return (0);
    }
  }
#line 49
  tmp = auth_rhosts(pw, client_user);
#line 49
  if (! tmp) {
#line 50
    return (0);
  }
#line 52
  canonical_hostname = get_canonical_hostname(options.reverse_mapping_check);
#line 55
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 58
  client_key = key_new(0);
#line 59
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 60
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 62
  if (options.ignore_user_known_hosts) {
#line 62
    tmp___0 = (char const   *)((void *)0);
  } else {
#line 62
    tmp___0 = "~/.ssh/known_hosts";
  }
#line 62
  host_status = check_key_in_hostfiles(pw, client_key, canonical_hostname, "/usr/local/etc/ssh_known_hosts",
                                       tmp___0);
#line 66
  key_free(client_key);
#line 68
  if ((int )host_status != 0) {
#line 69
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 70
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 71
    return (0);
  }
#line 76
  tmp___1 = auth_rsa_challenge_dialog(client_host_key);
#line 76
  if (! tmp___1) {
#line 77
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 79
    return (0);
  }
#line 86
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 88
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 89
  return (1);
}
}
#line 1 "auth-sia.o"
#line 1 "sshpty.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 20 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 21
void pty_release(char const   *ttyname___0 ) ;
#line 22
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 23
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 24
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 48 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 56
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 57
  if (i < 0) {
#line 58
    tmp = __errno_location();
#line 58
    tmp___0 = strerror(*tmp);
#line 58
    error("openpty: %.100s", tmp___0);
#line 59
    return (0);
  }
#line 61
  name = ttyname(*ttyfd);
#line 62
  if (! name) {
#line 63
    fatal("openpty returns device for which ttyname fails.");
  }
#line 65
  strlcpy(namebuf, (char const   *)name, (unsigned int )namebuflen);
#line 66
  return (1);
}
}
#line 238 "sshpty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 241
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 241
  if (tmp___1 < 0) {
#line 242
    tmp = __errno_location();
#line 242
    tmp___0 = strerror(*tmp);
#line 242
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 243
  tmp___4 = chmod(ttyname___0, 438U);
#line 243
  if (tmp___4 < 0) {
#line 244
    tmp___2 = __errno_location();
#line 244
    tmp___3 = strerror(*tmp___2);
#line 244
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 245
  return;
}
}
#line 249 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  __sighandler_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 284
  fd = open("/dev/tty", 258);
#line 285
  if (fd >= 0) {
#line 286
    ioctl(fd, 21538UL, (void *)0);
#line 287
    close(fd);
  }
#line 290
  tmp___1 = setsid();
#line 290
  if (tmp___1 < 0) {
#line 291
    tmp = __errno_location();
#line 291
    tmp___0 = strerror(*tmp);
#line 291
    error("setsid: %.100s", tmp___0);
  }
#line 297
  fd = open("/dev/tty", 258);
#line 298
  if (fd >= 0) {
#line 299
    error("Failed to disconnect from controlling tty.");
#line 300
    close(fd);
  }
#line 304
  debug("Setting controlling tty using TIOCSCTTY.");
#line 305
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 305
  if (tmp___4 < 0) {
#line 306
    tmp___2 = __errno_location();
#line 306
    tmp___3 = strerror(*tmp___2);
#line 306
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 313
  tmp___5 = signal(1, (void (*)(int  ))1);
#line 313
  old = (void *)tmp___5;
#line 314
  vhangup();
#line 315
  signal(1, (void (*)(int  ))old);
#line 317
  fd = open(ttyname___0, 2);
#line 318
  if (fd < 0) {
#line 319
    tmp___6 = __errno_location();
#line 319
    tmp___7 = strerror(*tmp___6);
#line 319
    error("%.100s: %.100s", ttyname___0, tmp___7);
  } else {
#line 322
    close(*ttyfd);
#line 323
    *ttyfd = fd;
  }
#line 329
  fd = open("/dev/tty", 1);
#line 330
  if (fd < 0) {
#line 331
    tmp___8 = __errno_location();
#line 331
    tmp___9 = strerror(*tmp___8);
#line 331
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 334
    close(fd);
  }
#line 337
  return;
}
}
#line 341 "sshpty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 346
  w.ws_row = (unsigned short )row;
#line 347
  w.ws_col = (unsigned short )col;
#line 348
  w.ws_xpixel = (unsigned short )xpixel;
#line 349
  w.ws_ypixel = (unsigned short )ypixel;
#line 350
  ioctl(ptyfd, 21524UL, & w);
#line 351
  return;
}
}
#line 353 "sshpty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 362
  grp = getgrnam("tty");
#line 363
  if (grp) {
#line 364
    gid = grp->gr_gid;
#line 365
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 367
    gid = pw->pw_gid;
#line 368
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 376
  tmp___1 = stat((char const   * __restrict  )ttyname___0, (struct stat * __restrict  )(& st));
#line 376
  if (tmp___1) {
#line 377
    tmp = __errno_location();
#line 377
    tmp___0 = strerror(*tmp);
#line 377
    fatal("stat(%.100s) failed: %.100s", ttyname___0, tmp___0);
  }
#line 380
  if (st.st_uid != pw->pw_uid) {
    goto _L;
  } else {
#line 380
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 381
      tmp___7 = chown(ttyname___0, pw->pw_uid, gid);
#line 381
      if (tmp___7 < 0) {
#line 382
        tmp___6 = __errno_location();
#line 382
        if (*tmp___6 == 30) {
#line 382
          if (st.st_uid == pw->pw_uid) {
#line 384
            tmp___2 = __errno_location();
#line 384
            tmp___3 = strerror(*tmp___2);
#line 384
            error("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid,
                  gid, tmp___3);
          } else {
#line 382
            if (st.st_uid == 0U) {
#line 384
              tmp___2 = __errno_location();
#line 384
              tmp___3 = strerror(*tmp___2);
#line 384
              error("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid,
                    gid, tmp___3);
            } else {
#line 388
              tmp___4 = __errno_location();
#line 388
              tmp___5 = strerror(*tmp___4);
#line 388
              fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid,
                    gid, tmp___5);
            }
          }
        } else {
#line 388
          tmp___4 = __errno_location();
#line 388
          tmp___5 = strerror(*tmp___4);
#line 388
          fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid,
                tmp___5);
        }
      }
    }
  }
#line 394
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 395
    tmp___13 = chmod(ttyname___0, mode);
#line 395
    if (tmp___13 < 0) {
#line 396
      tmp___12 = __errno_location();
#line 396
      if (*tmp___12 == 30) {
#line 396
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 398
          tmp___8 = __errno_location();
#line 398
          tmp___9 = strerror(*tmp___8);
#line 398
          error("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___9);
        } else {
#line 401
          tmp___10 = __errno_location();
#line 401
          tmp___11 = strerror(*tmp___10);
#line 401
          fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
        }
      } else {
#line 401
        tmp___10 = __errno_location();
#line 401
        tmp___11 = strerror(*tmp___10);
#line 401
        fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___11);
      }
    }
  }
#line 405
  return;
}
}
#line 1 "sshlogin.o"
#line 100 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 103
void login_free_entry(struct logininfo *li ) ;
#line 111
int login_login(struct logininfo *li ) ;
#line 112
int login_logout(struct logininfo *li ) ;
#line 124
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 131
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 52 "sshlogin.c"
u_long get_last_login_time(uid_t uid , char const   *logname , char *buf___2 , u_int bufsize ) 
{ struct logininfo li ;

  {
#line 58
  login_get_lastlog(& li, (int )uid);
#line 59
  strlcpy(buf___2, (char const   *)(li.hostname), bufsize);
#line 60
  return ((unsigned long )li.tv_sec);
}
}
#line 68 "sshlogin.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct logininfo *li ;

  {
#line 74
  li = login_alloc_entry(pid, user, host, ttyname___0);
#line 75
  login_set_addr(li, (struct sockaddr  const  *)addr, sizeof(struct sockaddr ));
#line 76
  login_login(li);
#line 77
  login_free_entry(li);
#line 78
  return;
}
}
#line 96 "sshlogin.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ struct logininfo *li ;

  {
#line 101
  li = login_alloc_entry(pid, (char const   *)((void *)0), (char const   *)((void *)0),
                         ttyname___0);
#line 102
  login_logout(li);
#line 103
  login_free_entry(li);
#line 104
  return;
}
}
#line 1 "loginrec.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 105 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 108
void login_set_current_time(struct logininfo *li ) ;
#line 120
int login_write(struct logininfo *li ) ;
#line 133
unsigned int login_get_lastlog_time(int uid ) ;
#line 136
char *line_fullname(char *dst , char const   *src , int dstsize ) ;
#line 137
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 138
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 181 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 182
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 194
int lastlog_write_entry(struct logininfo *li ) ;
#line 195
int syslogin_write_entry(struct logininfo *li ) ;
#line 197
int getlast_entry(struct logininfo *li ) ;
#line 198
int lastlog_get_entry(struct logininfo *li ) ;
#line 218 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 221
  li->type = (short)7;
#line 222
  tmp = login_write(li);
#line 222
  return (tmp);
}
}
#line 234 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 237
  li->type = (short)8;
#line 238
  tmp = login_write(li);
#line 238
  return (tmp);
}
}
#line 258 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 263
  tmp = login_get_lastlog(& li, uid);
#line 263
  if (tmp) {
#line 264
    return (li.tv_sec);
  } else {
#line 266
    return (0U);
  }
}
}
#line 282 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw ;
  int tmp ;

  {
#line 287
  memset((void *)li, '\000', sizeof(*li));
#line 288
  li->uid = uid;
#line 295
  pw = getpwuid((unsigned int )uid);
#line 296
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 297
    fatal("login_get_lastlog: Cannot find account for uid %i", uid);
  }
#line 301
  strlcpy(li->username, (char const   *)pw->pw_name, sizeof(li->username));
#line 303
  tmp = getlast_entry(li);
#line 303
  if (tmp) {
#line 304
    return (li);
  } else {
#line 306
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 319 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 325
  tmp = xmalloc(sizeof(*newli));
#line 325
  newli = (struct logininfo *)tmp;
#line 326
  login_init_entry(newli, pid, username, hostname, line);
#line 327
  return (newli);
}
}
#line 332 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 335
  xfree((void *)li);
#line 336
  return;
}
}
#line 347 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw ;

  {
#line 353
  memset((void *)li, 0, sizeof(*li));
#line 355
  li->pid = pid;
#line 358
  if (line) {
#line 359
    line_fullname(li->line, line, (int )sizeof(li->line));
  }
#line 361
  if (username) {
#line 362
    strlcpy(li->username, username, sizeof(li->username));
#line 363
    pw = getpwnam((char const   *)(li->username));
#line 364
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 365
      fatal("login_init_entry: Cannot find user \"%s\"", li->username);
    }
#line 366
    li->uid = (int )pw->pw_uid;
  }
#line 369
  if (hostname) {
#line 370
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 372
  return (1);
}
}
#line 381 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv ;

  {
#line 386
  gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 388
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 389
  li->tv_usec = (unsigned int )tv.tv_usec;
#line 390
  return;
}
}
#line 393 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 397
  bufsize = sa_size;
#line 400
  if (sizeof(li->hostaddr) < sa_size) {
#line 401
    bufsize = sizeof(li->hostaddr);
  }
#line 403
  memcpy((void * __restrict  )((void *)(& li->hostaddr.sa)), (void const   * __restrict  )((void const   *)sa),
         bufsize);
#line 404
  return;
}
}
#line 411 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 415
  tmp = geteuid();
#line 415
  if ((int )tmp != 0) {
#line 416
    log("Attempt to write login records by non-root user (aborting)");
#line 417
    return (1);
  }
#line 422
  login_set_current_time(li);
#line 424
  syslogin_write_entry(li);
#line 427
  if ((int )li->type == 7) {
#line 428
    lastlog_write_entry(li);
  }
#line 443
  return (0);
}
}
#line 473 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 477
  tmp = lastlog_get_entry(li);
#line 477
  return (tmp);
}
}
#line 524 "loginrec.c"
char *line_fullname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 527
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 528
  if (0) {
#line 528
    if (0) {
#line 528
      __s1_len___0 = strlen(src);
#line 528
      __s2_len___0 = strlen("/dev/");
#line 528
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 528
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 528
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 528
            tmp___22 = 1;
          } else {
#line 528
            if (__s2_len___0 >= 4U) {
#line 528
              tmp___22 = 1;
            } else {
#line 528
              tmp___22 = 0;
            }
          }
        } else {
#line 528
          tmp___22 = 0;
        }
      }
#line 528
      if (tmp___22) {
#line 528
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 528
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 528
        tmp___18 = tmp___21;
      }
    } else {
#line 528
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 528
      tmp___18 = tmp___21;
    }
#line 528
    tmp___12 = tmp___18;
  } else {
#line 528
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 528
  if (tmp___12 == 0) {
#line 529
    strlcpy(dst, src, (unsigned int )dstsize);
  } else {
#line 528
    tmp___25 = strlen(src);
#line 528
    if ((size_t )dstsize < tmp___25 + 5U) {
#line 529
      strlcpy(dst, src, (unsigned int )dstsize);
    } else {
#line 531
      strlcpy(dst, "/dev/", (unsigned int )dstsize);
#line 532
      strlcat(dst, src, (unsigned int )dstsize);
    }
  }
#line 534
  return (dst);
}
}
#line 538 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 541
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 542
  if (0) {
#line 542
    if (0) {
#line 542
      __s1_len___0 = strlen(src);
#line 542
      __s2_len___0 = strlen("/dev/");
#line 542
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 542
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 542
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 542
            tmp___22 = 1;
          } else {
#line 542
            if (__s2_len___0 >= 4U) {
#line 542
              tmp___22 = 1;
            } else {
#line 542
              tmp___22 = 0;
            }
          }
        } else {
#line 542
          tmp___22 = 0;
        }
      }
#line 542
      if (tmp___22) {
#line 542
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 542
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 542
        tmp___18 = tmp___21;
      }
    } else {
#line 542
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 542
      tmp___18 = tmp___21;
    }
#line 542
    tmp___12 = tmp___18;
  } else {
#line 542
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 542
  if (tmp___12 == 0) {
#line 543
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 545
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 546
  return (dst);
}
}
#line 555 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 560
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 563
  if (0) {
#line 563
    if (0) {
#line 563
      __s1_len___0 = strlen(src);
#line 563
      __s2_len___0 = strlen("/dev/");
#line 563
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 563
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 563
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 563
            tmp___22 = 1;
          } else {
#line 563
            if (__s2_len___0 >= 4U) {
#line 563
              tmp___22 = 1;
            } else {
#line 563
              tmp___22 = 0;
            }
          }
        } else {
#line 563
          tmp___22 = 0;
        }
      }
#line 563
      if (tmp___22) {
#line 563
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 563
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 563
        tmp___18 = tmp___21;
      }
    } else {
#line 563
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 563
      tmp___18 = tmp___21;
    }
#line 563
    tmp___12 = tmp___18;
  } else {
#line 563
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 563
  if (tmp___12 == 0) {
#line 564
    src += 5;
  }
#line 566
  len = strlen(src);
#line 568
  if (len > 0U) {
#line 569
    if ((int )len - dstsize > 0) {
#line 570
      src += (int )len - dstsize;
    }
#line 573
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 576
  return (dst);
}
}
#line 589 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 593
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 594
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 600
  return;
}
}
#line 602 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 606
  memset((void *)ut, '\000', sizeof(*ut));
#line 611
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 616
  switch ((int )li->type) {
  case 7: 
#line 618
  ut->ut_type = (short)7;
#line 622
  break;
  case 8: 
#line 624
  ut->ut_type = (short)8;
#line 628
  break;
  }
#line 631
  set_utmp_time(li, ut);
#line 633
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 636
  ut->ut_pid = li->pid;
#line 640
  if ((int )li->type == 8) {
#line 641
    return;
  }
#line 649
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 649
    tmp = sizeof(ut->ut_user);
  } else {
#line 649
    tmp = sizeof(li->username);
  }
#line 649
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 651
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 651
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 651
    tmp___0 = sizeof(li->hostname);
  }
#line 651
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 655
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 656
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 658
  return;
}
}
#line 1300 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1305
  tmp = malloc(sizeof(*ut));
#line 1305
  ut = (struct utmp *)tmp;
#line 1305
  if (! ut) {
#line 1306
    log("syslogin_perform_login: couldn\'t malloc()");
#line 1307
    return (0);
  }
#line 1309
  construct_utmp(li, ut);
#line 1310
  login((struct utmp  const  *)ut);
#line 1312
  return (1);
}
}
#line 1315 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[8] ;
  int tmp ;

  {
#line 1321
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1323
  tmp = logout((char const   *)(line));
#line 1323
  if (tmp) {
#line 1327
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1324
    log("syslogin_perform_logout: logout() returned an error");
  }
#line 1335
  return (1);
}
}
#line 1338 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1341
  switch ((int )li->type) {
  case 7: 
#line 1343
  tmp = syslogin_perform_login(li);
#line 1343
  return (tmp);
  case 8: 
#line 1345
  tmp___0 = syslogin_perform_logout(li);
#line 1345
  return (tmp___0);
  default: 
#line 1347
  log("syslogin_write_entry: Invalid type field");
#line 1348
  return (0);
  }
}
}
#line 1364 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1368
  memset((void *)last, '\000', sizeof(*last));
#line 1370
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1371
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1371
    tmp = sizeof(last->ll_host);
  } else {
#line 1371
    tmp = sizeof(li->hostname);
  }
#line 1371
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1373
  last->ll_time = (long )li->tv_sec;
#line 1374
  return;
}
}
#line 1376 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1381
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1381
  if (tmp___1 != 0) {
#line 1382
    tmp = __errno_location();
#line 1382
    tmp___0 = strerror(*tmp);
#line 1382
    log("lastlog_perform_login: Couldn\'t stat %s: %s", "/var/log/lastlog", tmp___0);
#line 1384
    return (0);
  }
#line 1386
  if ((st.st_mode & 61440U) == 16384U) {
#line 1387
    return (2);
  } else {
#line 1388
    if ((st.st_mode & 61440U) == 32768U) {
#line 1389
      return (1);
    } else {
#line 1391
      return (3);
    }
  }
}
}
#line 1396 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off_t tmp___3 ;

  {
#line 1403
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1404
  switch (type) {
  case 1: 
#line 1406
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1407
  break;
  case 2: 
#line 1409
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1411
  break;
  default: 
#line 1413
  log("lastlog_openseek: %.100s is not a file or directory!", "/var/log/lastlog");
#line 1415
  return (0);
  }
#line 1418
  *fd = open((char const   *)(lastlog_file), filemode);
#line 1419
  if (*fd < 0) {
#line 1420
    tmp = __errno_location();
#line 1420
    tmp___0 = strerror(*tmp);
#line 1420
    debug("lastlog_openseek: Couldn\'t open %s: %s", lastlog_file, tmp___0);
#line 1422
    return (0);
  }
#line 1425
  if (type == 1) {
#line 1427
    offset = (long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1429
    tmp___3 = lseek(*fd, offset, 0);
#line 1429
    if (tmp___3 != offset) {
#line 1430
      tmp___1 = __errno_location();
#line 1430
      tmp___2 = strerror(*tmp___1);
#line 1430
      log("lastlog_openseek: %s->lseek(): %s", lastlog_file, tmp___2);
#line 1432
      return (0);
    }
  }
#line 1436
  return (1);
}
}
#line 1439 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 1446
  lastlog_construct(li, & last);
#line 1448
  tmp = lastlog_openseek(li, & fd, 66);
#line 1448
  if (! tmp) {
#line 1449
    return (0);
  }
#line 1452
  tmp___2 = atomicio((ssize_t (*)())(& write), fd, (void *)(& last), sizeof(last));
#line 1452
  if ((unsigned int )tmp___2 != sizeof(last)) {
#line 1453
    close(fd);
#line 1454
    tmp___0 = __errno_location();
#line 1454
    tmp___1 = strerror(*tmp___0);
#line 1454
    log("lastlog_write_filemode: Error writing to %s: %s", "/var/log/lastlog", tmp___1);
#line 1456
    return (0);
  }
#line 1459
  close(fd);
#line 1460
  return (1);
}
}
#line 1463 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1466
  switch ((int )li->type) {
  case 7: 
#line 1468
  tmp = lastlog_perform_login(li);
#line 1468
  return (tmp);
  default: 
#line 1470
  log("lastlog_write_entry: Invalid type field");
#line 1471
  return (0);
  }
}
}
#line 1475 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1478
  line_fullname(li->line, (char const   *)(last->ll_line), (int )sizeof(li->line));
#line 1479
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1479
    tmp = sizeof(li->hostname);
  } else {
#line 1479
    tmp = sizeof(last->ll_host);
  }
#line 1479
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1481
  li->tv_sec = (unsigned int )last->ll_time;
#line 1482
  return;
}
}
#line 1484 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1490
  tmp___2 = lastlog_openseek(li, & fd, 0);
#line 1490
  if (tmp___2) {
#line 1491
    tmp___1 = atomicio((ssize_t (*)())(& read), fd, (void *)(& last), sizeof(last));
#line 1491
    if ((unsigned int )tmp___1 != sizeof(last)) {
#line 1492
      tmp = __errno_location();
#line 1492
      tmp___0 = strerror(*tmp);
#line 1492
      log("lastlog_get_entry: Error reading from %s: %s", "/var/log/lastlog", tmp___0);
#line 1494
      return (0);
    } else {
#line 1496
      lastlog_populate_entry(li, & last);
#line 1497
      return (1);
    }
  } else {
#line 1500
    return (0);
  }
}
}
#line 1 "servconf.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 34 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 35
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 42 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 45
  memset((void *)options___0, 0, sizeof(*options___0));
#line 46
  options___0->num_ports = 0U;
#line 47
  options___0->ports_from_cmdline = 0U;
#line 48
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 49
  options___0->num_host_key_files = 0;
#line 50
  options___0->pid_file = (char *)((void *)0);
#line 51
  options___0->server_key_bits = -1;
#line 52
  options___0->login_grace_time = -1;
#line 53
  options___0->key_regeneration_time = -1;
#line 54
  options___0->permit_root_login = -1;
#line 55
  options___0->ignore_rhosts = -1;
#line 56
  options___0->ignore_user_known_hosts = -1;
#line 57
  options___0->print_motd = -1;
#line 58
  options___0->print_lastlog = -1;
#line 59
  options___0->x11_forwarding = -1;
#line 60
  options___0->x11_display_offset = -1;
#line 61
  options___0->xauth_location = (char *)((void *)0);
#line 62
  options___0->strict_modes = -1;
#line 63
  options___0->keepalives = -1;
#line 64
  options___0->log_facility = (enum __anonenum_SyslogFacility_63 )-1;
#line 65
  options___0->log_level = (enum __anonenum_LogLevel_64 )-1;
#line 66
  options___0->rhosts_authentication = -1;
#line 67
  options___0->rhosts_rsa_authentication = -1;
#line 68
  options___0->hostbased_authentication = -1;
#line 69
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 70
  options___0->rsa_authentication = -1;
#line 71
  options___0->pubkey_authentication = -1;
#line 83
  options___0->password_authentication = -1;
#line 84
  options___0->kbd_interactive_authentication = -1;
#line 85
  options___0->challenge_response_authentication = -1;
#line 86
  options___0->permit_empty_passwd = -1;
#line 87
  options___0->use_login = -1;
#line 88
  options___0->allow_tcp_forwarding = -1;
#line 89
  options___0->num_allow_users = 0U;
#line 90
  options___0->num_deny_users = 0U;
#line 91
  options___0->num_allow_groups = 0U;
#line 92
  options___0->num_deny_groups = 0U;
#line 93
  options___0->ciphers = (char *)((void *)0);
#line 94
  options___0->macs = (char *)((void *)0);
#line 95
  options___0->protocol = 0;
#line 96
  options___0->gateway_ports = -1;
#line 97
  options___0->num_subsystems = 0U;
#line 98
  options___0->max_startups_begin = -1;
#line 99
  options___0->max_startups_rate = -1;
#line 100
  options___0->max_startups = -1;
#line 101
  options___0->banner = (char *)((void *)0);
#line 102
  options___0->reverse_mapping_check = -1;
#line 103
  options___0->client_alive_interval = -1;
#line 104
  options___0->client_alive_count_max = -1;
#line 105
  options___0->authorized_keys_file = (char *)((void *)0);
#line 106
  options___0->authorized_keys_file2 = (char *)((void *)0);
#line 107
  options___0->pam_authentication_via_kbd_int = -1;
#line 108
  return;
}
}
#line 110 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 113
  if (options___0->protocol == 0) {
#line 114
    options___0->protocol = 5;
  }
#line 115
  if (options___0->num_host_key_files == 0) {
#line 117
    if (options___0->protocol & 1) {
#line 118
      tmp = options___0->num_host_key_files;
#line 118
      (options___0->num_host_key_files) ++;
#line 118
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 119
    if (options___0->protocol & 4) {
#line 120
      tmp___0 = options___0->num_host_key_files;
#line 120
      (options___0->num_host_key_files) ++;
#line 120
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 122
  if (options___0->num_ports == 0U) {
#line 123
    tmp___1 = options___0->num_ports;
#line 123
    (options___0->num_ports) ++;
#line 123
    options___0->ports[tmp___1] = (unsigned short)22;
  }
#line 124
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 125
    add_listen_addr(options___0, (char *)((void *)0), (unsigned short)0);
  }
#line 126
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 127
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 128
  if (options___0->server_key_bits == -1) {
#line 129
    options___0->server_key_bits = 768;
  }
#line 130
  if (options___0->login_grace_time == -1) {
#line 131
    options___0->login_grace_time = 600;
  }
#line 132
  if (options___0->key_regeneration_time == -1) {
#line 133
    options___0->key_regeneration_time = 3600;
  }
#line 134
  if (options___0->permit_root_login == -1) {
#line 135
    options___0->permit_root_login = 3;
  }
#line 136
  if (options___0->ignore_rhosts == -1) {
#line 137
    options___0->ignore_rhosts = 1;
  }
#line 138
  if (options___0->ignore_user_known_hosts == -1) {
#line 139
    options___0->ignore_user_known_hosts = 0;
  }
#line 140
  if (options___0->print_motd == -1) {
#line 141
    options___0->print_motd = 1;
  }
#line 142
  if (options___0->print_lastlog == -1) {
#line 143
    options___0->print_lastlog = 1;
  }
#line 144
  if (options___0->x11_forwarding == -1) {
#line 145
    options___0->x11_forwarding = 0;
  }
#line 146
  if (options___0->x11_display_offset == -1) {
#line 147
    options___0->x11_display_offset = 10;
  }
#line 149
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 150
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 152
  if (options___0->strict_modes == -1) {
#line 153
    options___0->strict_modes = 1;
  }
#line 154
  if (options___0->keepalives == -1) {
#line 155
    options___0->keepalives = 1;
  }
#line 156
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_63 )-1)) {
#line 157
    options___0->log_facility = 2;
  }
#line 158
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_64 )-1)) {
#line 159
    options___0->log_level = 3;
  }
#line 160
  if (options___0->rhosts_authentication == -1) {
#line 161
    options___0->rhosts_authentication = 0;
  }
#line 162
  if (options___0->rhosts_rsa_authentication == -1) {
#line 163
    options___0->rhosts_rsa_authentication = 0;
  }
#line 164
  if (options___0->hostbased_authentication == -1) {
#line 165
    options___0->hostbased_authentication = 0;
  }
#line 166
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 167
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 168
  if (options___0->rsa_authentication == -1) {
#line 169
    options___0->rsa_authentication = 1;
  }
#line 170
  if (options___0->pubkey_authentication == -1) {
#line 171
    options___0->pubkey_authentication = 1;
  }
#line 188
  if (options___0->password_authentication == -1) {
#line 189
    options___0->password_authentication = 1;
  }
#line 190
  if (options___0->kbd_interactive_authentication == -1) {
#line 191
    options___0->kbd_interactive_authentication = 0;
  }
#line 192
  if (options___0->challenge_response_authentication == -1) {
#line 193
    options___0->challenge_response_authentication = 1;
  }
#line 194
  if (options___0->permit_empty_passwd == -1) {
#line 195
    options___0->permit_empty_passwd = 0;
  }
#line 196
  if (options___0->use_login == -1) {
#line 197
    options___0->use_login = 0;
  }
#line 198
  if (options___0->allow_tcp_forwarding == -1) {
#line 199
    options___0->allow_tcp_forwarding = 1;
  }
#line 200
  if (options___0->gateway_ports == -1) {
#line 201
    options___0->gateway_ports = 0;
  }
#line 202
  if (options___0->max_startups == -1) {
#line 203
    options___0->max_startups = 10;
  }
#line 204
  if (options___0->max_startups_rate == -1) {
#line 205
    options___0->max_startups_rate = 100;
  }
#line 206
  if (options___0->max_startups_begin == -1) {
#line 207
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 208
  if (options___0->reverse_mapping_check == -1) {
#line 209
    options___0->reverse_mapping_check = 0;
  }
#line 210
  if (options___0->client_alive_interval == -1) {
#line 211
    options___0->client_alive_interval = 0;
  }
#line 212
  if (options___0->client_alive_count_max == -1) {
#line 213
    options___0->client_alive_count_max = 3;
  }
#line 214
  if ((unsigned int )options___0->authorized_keys_file == (unsigned int )((void *)0)) {
#line 215
    options___0->authorized_keys_file = (char *)".ssh/authorized_keys";
  }
#line 216
  if ((unsigned int )options___0->authorized_keys_file2 == (unsigned int )((void *)0)) {
#line 217
    options___0->authorized_keys_file2 = (char *)".ssh/authorized_keys2";
  }
#line 218
  if (options___0->pam_authentication_via_kbd_int == -1) {
#line 219
    options___0->pam_authentication_via_kbd_int = 0;
  }
#line 220
  return;
}
}
#line 253 "servconf.c"
static struct __anonstruct_keywords_81 keywords[53]  = 
#line 253
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 2}, 
        {"pidfile", 34}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"hostbasedauthentication", 42}, 
        {"hostbasedusesnamefrompacketonly", 43}, 
        {"rsaauthentication", 11}, 
        {"pubkeyauthentication", 36}, 
        {"dsaauthentication", 36}, 
        {"passwordauthentication", 13}, 
        {"kbdinteractiveauthentication", 14}, 
        {"challengeresponseauthentication", 12}, 
        {"skeyauthentication", 12}, 
        {"checkmail", 48}, 
        {"listenaddress", 15}, 
        {"printmotd", 16}, 
        {"printlastlog", 17}, 
        {"ignorerhosts", 18}, 
        {"ignoreuserknownhosts", 30}, 
        {"x11forwarding", 19}, 
        {"x11displayoffset", 20}, 
        {"xauthlocation", 37}, 
        {"strictmodes", 21}, 
        {"permitemptypasswords", 22}, 
        {"uselogin", 24}, 
        {"keepalive", 23}, 
        {"allowtcpforwarding", 25}, 
        {"allowusers", 26}, 
        {"denyusers", 27}, 
        {"allowgroups", 28}, 
        {"denygroups", 29}, 
        {"ciphers", 31}, 
        {"macs", 32}, 
        {"protocol", 33}, 
        {"gatewayports", 35}, 
        {"subsystem", 38}, 
        {"maxstartups", 39}, 
        {"banner", 40}, 
        {"reversemappingcheck", 41}, 
        {"clientaliveinterval", 44}, 
        {"clientalivecountmax", 45}, 
        {"authorizedkeysfile", 46}, 
        {"authorizedkeysfile2", 47}, 
        {"PAMAuthenticationViaKbdInt", 49}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 327 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ u_int i ;
  int tmp ;

  {
#line 333
  i = 0U;
#line 333
  while (keywords[i].name) {
#line 334
    tmp = strcasecmp(cp, keywords[i].name);
#line 334
    if (tmp == 0) {
#line 335
      return (keywords[i].opcode);
    }
#line 333
    i ++;
  }
#line 337
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
#line 339
  return (0);
}
}
#line 342 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ int i ;
  u_int tmp ;

  {
#line 347
  if (options___0->num_ports == 0U) {
#line 348
    tmp = options___0->num_ports;
#line 348
    (options___0->num_ports) ++;
#line 348
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 349
  if ((int )port == 0) {
#line 350
    i = 0;
#line 350
    while ((u_int )i < options___0->num_ports) {
#line 351
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
#line 350
      i ++;
    }
  } else {
#line 353
    add_one_listen_addr(options___0, addr, port);
  }
#line 354
  return;
}
}
#line 356 "servconf.c"
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 363
  memset((void *)(& hints), 0, sizeof(hints));
#line 364
  hints.ai_family = IPv4or6;
#line 365
  hints.ai_socktype = 1;
#line 366
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 366
    hints.ai_flags = 1;
  } else {
#line 366
    hints.ai_flags = 0;
  }
#line 367
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 368
  gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 368
  if (gaierr != 0) {
#line 369
    tmp = gai_strerror(gaierr);
#line 369
    if (addr) {
#line 369
      tmp___0 = (char const   *)addr;
    } else {
#line 369
      tmp___0 = "<NULL>";
    }
#line 369
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
  }
#line 372
  ai = aitop;
#line 372
  while (ai->ai_next) {
#line 372
    ai = ai->ai_next;
  }
#line 374
  ai->ai_next = options___0->listen_addrs;
#line 375
  options___0->listen_addrs = aitop;
#line 376
  return;
}
}
#line 380 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  int i ;
  int n___0 ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  char *tmp___32 ;
  char *tmp___34 ;
  u_short port ;
  int tmp___35 ;
  __uid_t tmp___36 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___52 ;
  int tmp___55 ;
  int tmp___56 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___62 ;
  int tmp___65 ;
  int tmp___66 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___72 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___82 ;
  int tmp___85 ;
  int tmp___86 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___92 ;
  int tmp___95 ;
  int tmp___96 ;
  SyslogFacility tmp___97 ;
  char const   *tmp___98 ;
  LogLevel tmp___99 ;
  char const   *tmp___100 ;
  u_int tmp___101 ;
  u_int tmp___102 ;
  u_int tmp___103 ;
  u_int tmp___104 ;
  char const   *tmp___105 ;
  int tmp___106 ;
  char const   *tmp___107 ;
  int tmp___108 ;
  char const   *tmp___109 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___115 ;
  int tmp___118 ;
  int tmp___119 ;
  char *tmp___120 ;

  {
#line 387
  bad_options = 0;
#line 391
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 392
  if (! f) {
#line 393
    perror(filename);
#line 394
    exit(1);
  }
#line 396
  linenum = 0;
#line 397
  while (1) {
#line 397
    tmp___120 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 397
    if (! tmp___120) {
#line 397
      break;
    }
#line 398
    linenum ++;
#line 399
    cp = line;
#line 400
    arg = strdelim(& cp);
#line 402
    if ((int )*arg == 0) {
#line 403
      arg = strdelim(& cp);
    }
#line 404
    if (! arg) {
#line 405
      continue;
    } else {
#line 404
      if (! *arg) {
#line 405
        continue;
      } else {
#line 404
        if ((int )*arg == 35) {
#line 405
          continue;
        }
      }
    }
#line 406
    intptr = (int *)((void *)0);
#line 407
    charptr = (char **)((void *)0);
#line 408
    opcode = parse_token((char const   *)arg, filename, linenum);
#line 409
    switch ((int )opcode) {
    case 0: 
#line 411
    bad_options ++;
#line 412
    continue;
    case 1: 
#line 415
    if (options___0->ports_from_cmdline) {
#line 416
      continue;
    }
#line 417
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 418
      fatal("%s line %d: ports must be specified before ListenAdress.", filename,
            linenum);
    }
#line 420
    if (options___0->num_ports >= 256U) {
#line 421
      fatal("%s line %d: too many ports.", filename, linenum);
    }
#line 423
    arg = strdelim(& cp);
#line 424
    if (! arg) {
#line 425
      fatal("%s line %d: missing port number.", filename, linenum);
    } else {
#line 424
      if ((int )*arg == 0) {
#line 425
        fatal("%s line %d: missing port number.", filename, linenum);
      }
    }
#line 427
    tmp = options___0->num_ports;
#line 427
    (options___0->num_ports) ++;
#line 427
    tmp___0 = a2port((char const   *)arg);
#line 427
    options___0->ports[tmp] = (unsigned short )tmp___0;
#line 428
    if ((int )options___0->ports[options___0->num_ports - 1U] == 0) {
#line 429
      fatal("%s line %d: Badly formatted port number.", filename, linenum);
    }
#line 431
    break;
    case 3: 
#line 434
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 436
    arg = strdelim(& cp);
#line 437
    if (! arg) {
#line 438
      fatal("%s line %d: missing integer value.", filename, linenum);
    } else {
#line 437
      if ((int )*arg == 0) {
#line 438
        fatal("%s line %d: missing integer value.", filename, linenum);
      }
    }
#line 440
    value = atoi((char const   *)arg);
#line 441
    if (*intptr == -1) {
#line 442
      *intptr = value;
    }
#line 443
    break;
    case 4: 
#line 446
    intptr = & options___0->login_grace_time;
    parse_time: 
#line 448
    arg = strdelim(& cp);
#line 449
    if (! arg) {
#line 450
      fatal("%s line %d: missing time value.", filename, linenum);
    } else {
#line 449
      if ((int )*arg == 0) {
#line 450
        fatal("%s line %d: missing time value.", filename, linenum);
      }
    }
#line 452
    tmp___1 = convtime((char const   *)arg);
#line 452
    value = (int )tmp___1;
#line 452
    if (value == -1) {
#line 453
      fatal("%s line %d: invalid time value.", filename, linenum);
    }
#line 455
    if (*intptr == -1) {
#line 456
      *intptr = value;
    }
#line 457
    break;
    case 5: 
#line 460
    intptr = & options___0->key_regeneration_time;
    goto parse_time;
    case 15: 
#line 464
    arg = strdelim(& cp);
#line 465
    if (! arg) {
#line 466
      fatal("%s line %d: missing inet addr.", filename, linenum);
    } else {
#line 465
      if ((int )*arg == 0) {
#line 466
        fatal("%s line %d: missing inet addr.", filename, linenum);
      } else {
#line 465
        if (0) {
#line 465
          if (0) {
#line 465
            __s1_len___0 = strlen((char const   *)arg);
#line 465
            __s2_len___0 = strlen("[]");
#line 465
            if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
              goto _L___2;
            } else {
#line 465
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 465
                if (! ((unsigned int )((void const   *)("[]" + 1)) - (unsigned int )((void const   *)"[]") == 1U)) {
#line 465
                  tmp___25 = 1;
                } else {
#line 465
                  if (__s2_len___0 >= 4U) {
#line 465
                    tmp___25 = 1;
                  } else {
#line 465
                    tmp___25 = 0;
                  }
                }
              } else {
#line 465
                tmp___25 = 0;
              }
            }
#line 465
            if (tmp___25) {
#line 465
              tmp___21 = __builtin_strcmp((char const   *)arg, "[]");
            } else {
#line 465
              tmp___24 = __builtin_strcmp((char const   *)arg, "[]");
#line 465
              tmp___21 = tmp___24;
            }
          } else {
#line 465
            tmp___24 = __builtin_strcmp((char const   *)arg, "[]");
#line 465
            tmp___21 = tmp___24;
          }
#line 465
          tmp___15 = tmp___21;
        } else {
#line 465
          tmp___15 = strncmp((char const   *)arg, "[]", 2U);
        }
#line 465
        if (tmp___15 == 0) {
#line 466
          fatal("%s line %d: missing inet addr.", filename, linenum);
        }
      }
    }
#line 468
    if ((int )*arg == 91) {
#line 469
      tmp___29 = __builtin_strchr(arg, ']');
#line 469
      p = tmp___29;
#line 469
      if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 470
        fatal("%s line %d: bad ipv6 inet addr usage.", filename, linenum);
      }
#line 472
      arg ++;
#line 473
      tmp___30 = strlen((char const   *)(p + 1));
#line 473
      memmove((void *)p, (void const   *)(p + 1), tmp___30 + 1U);
    } else {
#line 474
      tmp___32 = __builtin_strchr(arg, ':');
#line 474
      p = tmp___32;
#line 474
      if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 476
        add_listen_addr(options___0, arg, (unsigned short)0);
#line 477
        break;
      } else {
#line 474
        tmp___34 = __builtin_strchr(p + 1, ':');
#line 474
        if ((unsigned int )tmp___34 != (unsigned int )((void *)0)) {
#line 476
          add_listen_addr(options___0, arg, (unsigned short)0);
#line 477
          break;
        }
      }
    }
#line 479
    if ((int )*p == 58) {
#line 482
      p ++;
#line 483
      if ((int )*p == 0) {
#line 484
        fatal("%s line %d: bad inet addr:port usage.", filename, linenum);
      } else {
#line 487
        *(p - 1) = (char )'\000';
#line 488
        tmp___35 = a2port((char const   *)p);
#line 488
        port = (unsigned short )tmp___35;
#line 488
        if ((int )port == 0) {
#line 489
          fatal("%s line %d: bad port number.", filename, linenum);
        }
#line 491
        add_listen_addr(options___0, arg, port);
      }
    } else {
#line 493
      if ((int )*p == 0) {
#line 494
        add_listen_addr(options___0, arg, (unsigned short)0);
      } else {
#line 496
        fatal("%s line %d: bad inet addr usage.", filename, linenum);
      }
    }
#line 498
    break;
    case 2: 
#line 501
    intptr = & options___0->num_host_key_files;
#line 502
    if (*intptr >= 256) {
#line 503
      fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
            256);
    }
#line 505
    charptr = & options___0->host_key_files[*intptr];
    parse_filename: 
#line 507
    arg = strdelim(& cp);
#line 508
    if (! arg) {
#line 509
      fatal("%s line %d: missing file name.", filename, linenum);
    } else {
#line 508
      if ((int )*arg == 0) {
#line 509
        fatal("%s line %d: missing file name.", filename, linenum);
      }
    }
#line 511
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 512
      tmp___36 = getuid();
#line 512
      *charptr = tilde_expand_filename((char const   *)arg, tmp___36);
#line 514
      if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 515
        (*intptr) ++;
      }
    }
#line 517
    break;
    case 34: 
#line 520
    charptr = & options___0->pid_file;
    goto parse_filename;
    case 6: 
#line 524
    intptr = & options___0->permit_root_login;
#line 525
    arg = strdelim(& cp);
#line 526
    if (! arg) {
#line 527
      fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
            filename, linenum);
    } else {
#line 526
      if ((int )*arg == 0) {
#line 527
        fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
              filename, linenum);
      }
    }
#line 530
    value = 0;
#line 531
    if (0) {
#line 531
      __s1_len___4 = strlen((char const   *)arg);
#line 531
      __s2_len___4 = strlen("without-password");
#line 531
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___10;
      } else {
#line 531
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 531
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 531
            tmp___76 = 1;
          } else {
#line 531
            if (__s2_len___4 >= 4U) {
#line 531
              tmp___76 = 1;
            } else {
#line 531
              tmp___76 = 0;
            }
          }
        } else {
#line 531
          tmp___76 = 0;
        }
      }
#line 531
      if (tmp___76) {
#line 531
        tmp___72 = __builtin_strcmp((char const   *)arg, "without-password");
      } else {
#line 531
        tmp___75 = __builtin_strcmp((char const   *)arg, "without-password");
#line 531
        tmp___72 = tmp___75;
      }
    } else {
#line 531
      tmp___75 = __builtin_strcmp((char const   *)arg, "without-password");
#line 531
      tmp___72 = tmp___75;
    }
#line 531
    if (tmp___72 == 0) {
#line 532
      value = 2;
    } else {
#line 533
      if (0) {
#line 533
        __s1_len___3 = strlen((char const   *)arg);
#line 533
        __s2_len___3 = strlen("forced-commands-only");
#line 533
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___8;
        } else {
#line 533
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 533
            if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 533
              tmp___66 = 1;
            } else {
#line 533
              if (__s2_len___3 >= 4U) {
#line 533
                tmp___66 = 1;
              } else {
#line 533
                tmp___66 = 0;
              }
            }
          } else {
#line 533
            tmp___66 = 0;
          }
        }
#line 533
        if (tmp___66) {
#line 533
          tmp___62 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
        } else {
#line 533
          tmp___65 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 533
          tmp___62 = tmp___65;
        }
      } else {
#line 533
        tmp___65 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 533
        tmp___62 = tmp___65;
      }
#line 533
      if (tmp___62 == 0) {
#line 534
        value = 1;
      } else {
#line 535
        if (0) {
#line 535
          __s1_len___2 = strlen((char const   *)arg);
#line 535
          __s2_len___2 = strlen("yes");
#line 535
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___6;
          } else {
#line 535
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 535
              if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 535
                tmp___56 = 1;
              } else {
#line 535
                if (__s2_len___2 >= 4U) {
#line 535
                  tmp___56 = 1;
                } else {
#line 535
                  tmp___56 = 0;
                }
              }
            } else {
#line 535
              tmp___56 = 0;
            }
          }
#line 535
          if (tmp___56) {
#line 535
            tmp___52 = __builtin_strcmp((char const   *)arg, "yes");
          } else {
#line 535
            tmp___55 = __builtin_strcmp((char const   *)arg, "yes");
#line 535
            tmp___52 = tmp___55;
          }
        } else {
#line 535
          tmp___55 = __builtin_strcmp((char const   *)arg, "yes");
#line 535
          tmp___52 = tmp___55;
        }
#line 535
        if (tmp___52 == 0) {
#line 536
          value = 3;
        } else {
#line 537
          if (0) {
#line 537
            __s1_len___1 = strlen((char const   *)arg);
#line 537
            __s2_len___1 = strlen("no");
#line 537
            if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
              goto _L___4;
            } else {
#line 537
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 537
                if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 537
                  tmp___46 = 1;
                } else {
#line 537
                  if (__s2_len___1 >= 4U) {
#line 537
                    tmp___46 = 1;
                  } else {
#line 537
                    tmp___46 = 0;
                  }
                }
              } else {
#line 537
                tmp___46 = 0;
              }
            }
#line 537
            if (tmp___46) {
#line 537
              tmp___42 = __builtin_strcmp((char const   *)arg, "no");
            } else {
#line 537
              tmp___45 = __builtin_strcmp((char const   *)arg, "no");
#line 537
              tmp___42 = tmp___45;
            }
          } else {
#line 537
            tmp___45 = __builtin_strcmp((char const   *)arg, "no");
#line 537
            tmp___42 = tmp___45;
          }
#line 537
          if (tmp___42 == 0) {
#line 538
            value = 0;
          } else {
#line 540
            fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                  filename, linenum, arg);
          }
        }
      }
    }
#line 543
    if (*intptr == -1) {
#line 544
      *intptr = value;
    }
#line 545
    break;
    case 18: 
#line 548
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 550
    arg = strdelim(& cp);
#line 551
    if (! arg) {
#line 552
      fatal("%s line %d: missing yes/no argument.", filename, linenum);
    } else {
#line 551
      if ((int )*arg == 0) {
#line 552
        fatal("%s line %d: missing yes/no argument.", filename, linenum);
      }
    }
#line 554
    value = 0;
#line 555
    if (0) {
#line 555
      __s1_len___6 = strlen((char const   *)arg);
#line 555
      __s2_len___6 = strlen("yes");
#line 555
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___14;
      } else {
#line 555
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 555
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 555
            tmp___96 = 1;
          } else {
#line 555
            if (__s2_len___6 >= 4U) {
#line 555
              tmp___96 = 1;
            } else {
#line 555
              tmp___96 = 0;
            }
          }
        } else {
#line 555
          tmp___96 = 0;
        }
      }
#line 555
      if (tmp___96) {
#line 555
        tmp___92 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 555
        tmp___95 = __builtin_strcmp((char const   *)arg, "yes");
#line 555
        tmp___92 = tmp___95;
      }
    } else {
#line 555
      tmp___95 = __builtin_strcmp((char const   *)arg, "yes");
#line 555
      tmp___92 = tmp___95;
    }
#line 555
    if (tmp___92 == 0) {
#line 556
      value = 1;
    } else {
#line 557
      if (0) {
#line 557
        __s1_len___5 = strlen((char const   *)arg);
#line 557
        __s2_len___5 = strlen("no");
#line 557
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___12;
        } else {
#line 557
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 557
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 557
              tmp___86 = 1;
            } else {
#line 557
              if (__s2_len___5 >= 4U) {
#line 557
                tmp___86 = 1;
              } else {
#line 557
                tmp___86 = 0;
              }
            }
          } else {
#line 557
            tmp___86 = 0;
          }
        }
#line 557
        if (tmp___86) {
#line 557
          tmp___82 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 557
          tmp___85 = __builtin_strcmp((char const   *)arg, "no");
#line 557
          tmp___82 = tmp___85;
        }
      } else {
#line 557
        tmp___85 = __builtin_strcmp((char const   *)arg, "no");
#line 557
        tmp___82 = tmp___85;
      }
#line 557
      if (tmp___82 == 0) {
#line 558
        value = 0;
      } else {
#line 560
        fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
      }
    }
#line 562
    if (*intptr == -1) {
#line 563
      *intptr = value;
    }
#line 564
    break;
    case 30: 
#line 567
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 571
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 575
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 42: 
#line 579
    intptr = & options___0->hostbased_authentication;
    goto parse_flag;
    case 43: 
#line 583
    intptr = & options___0->hostbased_uses_name_from_packet_only;
    goto parse_flag;
    case 11: 
#line 587
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 36: 
#line 591
    intptr = & options___0->pubkey_authentication;
    goto parse_flag;
    case 13: 
#line 618
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 14: 
#line 622
    intptr = & options___0->kbd_interactive_authentication;
    goto parse_flag;
    case 12: 
#line 626
    intptr = & options___0->challenge_response_authentication;
    goto parse_flag;
    case 16: 
#line 630
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 17: 
#line 634
    intptr = & options___0->print_lastlog;
    goto parse_flag;
    case 19: 
#line 638
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 20: 
#line 642
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 37: 
#line 646
    charptr = & options___0->xauth_location;
    goto parse_filename;
    case 21: 
#line 650
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 23: 
#line 654
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 22: 
#line 658
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 24: 
#line 662
    intptr = & options___0->use_login;
    goto parse_flag;
    case 35: 
#line 666
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 41: 
#line 670
    intptr = & options___0->reverse_mapping_check;
    goto parse_flag;
    case 7: 
#line 674
    intptr = (int *)(& options___0->log_facility);
#line 675
    arg = strdelim(& cp);
#line 676
    tmp___97 = log_facility_number(arg);
#line 676
    value = (int )tmp___97;
#line 677
    if (value == (int )((enum __anonenum_SyslogFacility_63 )-1)) {
#line 678
      if (arg) {
#line 678
        tmp___98 = (char const   *)arg;
      } else {
#line 678
        tmp___98 = "<NONE>";
      }
#line 678
      fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum,
            tmp___98);
    }
#line 680
    if (*intptr == -1) {
#line 681
      *intptr = (int )((enum __anonenum_SyslogFacility_63 )value);
    }
#line 682
    break;
    case 8: 
#line 685
    intptr = (int *)(& options___0->log_level);
#line 686
    arg = strdelim(& cp);
#line 687
    tmp___99 = log_level_number(arg);
#line 687
    value = (int )tmp___99;
#line 688
    if (value == (int )((enum __anonenum_LogLevel_64 )-1)) {
#line 689
      if (arg) {
#line 689
        tmp___100 = (char const   *)arg;
      } else {
#line 689
        tmp___100 = "<NONE>";
      }
#line 689
      fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___100);
    }
#line 691
    if (*intptr == -1) {
#line 692
      *intptr = (int )((enum __anonenum_LogLevel_64 )value);
    }
#line 693
    break;
    case 25: 
#line 696
    intptr = & options___0->allow_tcp_forwarding;
    goto parse_flag;
    case 26: 
#line 700
    while (1) {
#line 700
      arg = strdelim(& cp);
#line 700
      if (arg) {
#line 700
        if (! ((int )*arg != 0)) {
#line 700
          break;
        }
      } else {
#line 700
        break;
      }
#line 701
      if (options___0->num_allow_users >= 256U) {
#line 702
        fatal("%s line %d: too many allow users.", filename, linenum);
      }
#line 704
      tmp___101 = options___0->num_allow_users;
#line 704
      (options___0->num_allow_users) ++;
#line 704
      options___0->allow_users[tmp___101] = xstrdup((char const   *)arg);
    }
#line 706
    break;
    case 27: 
#line 709
    while (1) {
#line 709
      arg = strdelim(& cp);
#line 709
      if (arg) {
#line 709
        if (! ((int )*arg != 0)) {
#line 709
          break;
        }
      } else {
#line 709
        break;
      }
#line 710
      if (options___0->num_deny_users >= 256U) {
#line 711
        fatal("%s line %d: too many deny users.", filename, linenum);
      }
#line 713
      tmp___102 = options___0->num_deny_users;
#line 713
      (options___0->num_deny_users) ++;
#line 713
      options___0->deny_users[tmp___102] = xstrdup((char const   *)arg);
    }
#line 715
    break;
    case 28: 
#line 718
    while (1) {
#line 718
      arg = strdelim(& cp);
#line 718
      if (arg) {
#line 718
        if (! ((int )*arg != 0)) {
#line 718
          break;
        }
      } else {
#line 718
        break;
      }
#line 719
      if (options___0->num_allow_groups >= 256U) {
#line 720
        fatal("%s line %d: too many allow groups.", filename, linenum);
      }
#line 722
      tmp___103 = options___0->num_allow_groups;
#line 722
      (options___0->num_allow_groups) ++;
#line 722
      options___0->allow_groups[tmp___103] = xstrdup((char const   *)arg);
    }
#line 724
    break;
    case 29: 
#line 727
    while (1) {
#line 727
      arg = strdelim(& cp);
#line 727
      if (arg) {
#line 727
        if (! ((int )*arg != 0)) {
#line 727
          break;
        }
      } else {
#line 727
        break;
      }
#line 728
      if (options___0->num_deny_groups >= 256U) {
#line 729
        fatal("%s line %d: too many deny groups.", filename, linenum);
      }
#line 731
      tmp___104 = options___0->num_deny_groups;
#line 731
      (options___0->num_deny_groups) ++;
#line 731
      options___0->deny_groups[tmp___104] = xstrdup((char const   *)arg);
    }
#line 733
    break;
    case 31: 
#line 736
    arg = strdelim(& cp);
#line 737
    if (! arg) {
#line 738
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 737
      if ((int )*arg == 0) {
#line 738
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 739
    tmp___106 = ciphers_valid((char const   *)arg);
#line 739
    if (! tmp___106) {
#line 740
      if (arg) {
#line 740
        tmp___105 = (char const   *)arg;
      } else {
#line 740
        tmp___105 = "<NONE>";
      }
#line 740
      fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___105);
    }
#line 742
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 743
      options___0->ciphers = xstrdup((char const   *)arg);
    }
#line 744
    break;
    case 32: 
#line 747
    arg = strdelim(& cp);
#line 748
    if (! arg) {
#line 749
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 748
      if ((int )*arg == 0) {
#line 749
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 750
    tmp___108 = mac_valid((char const   *)arg);
#line 750
    if (! tmp___108) {
#line 751
      if (arg) {
#line 751
        tmp___107 = (char const   *)arg;
      } else {
#line 751
        tmp___107 = "<NONE>";
      }
#line 751
      fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___107);
    }
#line 753
    if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 754
      options___0->macs = xstrdup((char const   *)arg);
    }
#line 755
    break;
    case 33: 
#line 758
    intptr = & options___0->protocol;
#line 759
    arg = strdelim(& cp);
#line 760
    if (! arg) {
#line 761
      fatal("%s line %d: Missing argument.", filename, linenum);
    } else {
#line 760
      if ((int )*arg == 0) {
#line 761
        fatal("%s line %d: Missing argument.", filename, linenum);
      }
    }
#line 762
    value = proto_spec((char const   *)arg);
#line 763
    if (value == 0) {
#line 764
      if (arg) {
#line 764
        tmp___109 = (char const   *)arg;
      } else {
#line 764
        tmp___109 = "<NONE>";
      }
#line 764
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___109);
    }
#line 766
    if (*intptr == 0) {
#line 767
      *intptr = value;
    }
#line 768
    break;
    case 38: 
#line 771
    if (options___0->num_subsystems >= 256U) {
#line 772
      fatal("%s line %d: too many subsystems defined.", filename, linenum);
    }
#line 775
    arg = strdelim(& cp);
#line 776
    if (! arg) {
#line 777
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    } else {
#line 776
      if ((int )*arg == 0) {
#line 777
        fatal("%s line %d: Missing subsystem name.", filename, linenum);
      }
    }
#line 779
    i = 0;
#line 779
    while ((u_int )i < options___0->num_subsystems) {
#line 780
      if (0) {
#line 780
        __s1_len___7 = strlen((char const   *)arg);
#line 780
        __s2_len___7 = strlen((char const   *)options___0->subsystem_name[i]);
#line 780
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___16;
        } else {
#line 780
          if (__s1_len___7 >= 4U) {
            _L___16: /* CIL Label */ 
#line 780
            if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 780
              tmp___119 = 1;
            } else {
#line 780
              if (__s2_len___7 >= 4U) {
#line 780
                tmp___119 = 1;
              } else {
#line 780
                tmp___119 = 0;
              }
            }
          } else {
#line 780
            tmp___119 = 0;
          }
        }
#line 780
        if (tmp___119) {
#line 780
          tmp___115 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
        } else {
#line 780
          tmp___118 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 780
          tmp___115 = tmp___118;
        }
      } else {
#line 780
        tmp___118 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 780
        tmp___115 = tmp___118;
      }
#line 780
      if (tmp___115 == 0) {
#line 781
        fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum,
              arg);
      }
#line 779
      i ++;
    }
#line 783
    options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 784
    arg = strdelim(& cp);
#line 785
    if (! arg) {
#line 786
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    } else {
#line 785
      if ((int )*arg == 0) {
#line 786
        fatal("%s line %d: Missing subsystem command.", filename, linenum);
      }
    }
#line 788
    options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 789
    (options___0->num_subsystems) ++;
#line 790
    break;
    case 39: 
#line 793
    arg = strdelim(& cp);
#line 794
    if (! arg) {
#line 795
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    } else {
#line 794
      if ((int )*arg == 0) {
#line 795
        fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
      }
    }
#line 797
    n___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                   & options___0->max_startups_begin, & options___0->max_startups_rate,
                   & options___0->max_startups);
#line 797
    if (n___0 == 3) {
#line 801
      if (options___0->max_startups_begin > options___0->max_startups) {
#line 805
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 801
        if (options___0->max_startups_rate > 100) {
#line 805
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        } else {
#line 801
          if (options___0->max_startups_rate < 1) {
#line 805
            fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
          }
        }
      }
    } else {
#line 807
      if (n___0 != 1) {
#line 808
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 811
        options___0->max_startups = options___0->max_startups_begin;
      }
    }
#line 812
    break;
    case 40: 
#line 815
    charptr = & options___0->banner;
    goto parse_filename;
    case 46: 
    case 47: 
#line 825
    if ((int )opcode == 46) {
#line 825
      charptr = & options___0->authorized_keys_file;
    } else {
#line 825
      charptr = & options___0->authorized_keys_file2;
    }
    goto parse_filename;
    case 44: 
#line 831
    intptr = & options___0->client_alive_interval;
    goto parse_time;
    case 45: 
#line 835
    intptr = & options___0->client_alive_count_max;
    goto parse_int;
    case 48: 
#line 839
    log("%s line %d: Deprecated option %s", filename, linenum, arg);
#line 841
    while (arg) {
#line 842
      arg = strdelim(& cp);
    }
#line 843
    break;
    case 49: 
#line 846
    intptr = & options___0->pam_authentication_via_kbd_int;
    goto parse_flag;
    default: 
#line 850
    fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
          opcode);
    }
#line 853
    arg = strdelim(& cp);
#line 853
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 853
      if ((int )*arg != 0) {
#line 854
        fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
              arg);
      }
    }
  }
#line 857
  fclose(f);
#line 858
  if (bad_options > 0) {
#line 859
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
  }
#line 861
  return;
}
}
#line 1 "serverloop.o"
#line 31 "session.h"
int session_open(Authctxt *authctxt , int chanid ) ;
#line 32
void session_input_channel_req(int id , void *arg ) ;
#line 33
void session_close_by_pid(pid_t pid , int status ) ;
#line 34
void session_close_by_channel(int id , void *arg ) ;
#line 35
int session_have_children(void) ;
#line 24 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 25
void server_loop2(Authctxt *authctxt ) ;
#line 62 "serverloop.c"
static Authctxt *xxx_authctxt  ;
#line 64 "serverloop.c"
static Buffer stdin_buffer  ;
#line 65 "serverloop.c"
static Buffer stdout_buffer  ;
#line 66 "serverloop.c"
static Buffer stderr_buffer  ;
#line 67 "serverloop.c"
static int fdin  ;
#line 68 "serverloop.c"
static int fdout  ;
#line 70 "serverloop.c"
static int fderr  ;
#line 71 "serverloop.c"
static long stdin_bytes  =    0L;
#line 72 "serverloop.c"
static long stdout_bytes  =    0L;
#line 73 "serverloop.c"
static long stderr_bytes  =    0L;
#line 74 "serverloop.c"
static long fdout_bytes  =    0L;
#line 75 "serverloop.c"
static int stdin_eof  =    0;
#line 76 "serverloop.c"
static int fdout_eof  =    0;
#line 77 "serverloop.c"
static int fderr_eof  =    0;
#line 78 "serverloop.c"
static int fdin_is_tty  =    0;
#line 79 "serverloop.c"
static int connection_in___0  ;
#line 80 "serverloop.c"
static int connection_out___0  ;
#line 81 "serverloop.c"
static int connection_closed  =    0;
#line 82 "serverloop.c"
static u_int buffer_high  ;
#line 89 "serverloop.c"
static int volatile   child_terminated  ;
#line 92
static void server_init_dispatch(void) ;
#line 94 "serverloop.c"
int client_alive_timeouts  =    0;
#line 96 "serverloop.c"
static void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 99
  tmp = __errno_location();
#line 99
  save_errno = *tmp;
#line 100
  debug("Received SIGCHLD.");
#line 101
  child_terminated = (int volatile   )1;
#line 102
  mysignal(17, & sigchld_handler);
#line 103
  tmp___0 = __errno_location();
#line 103
  *tmp___0 = save_errno;
#line 104
  return;
}
}
#line 110 "serverloop.c"
static void make_packets_from_stderr_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 116
  while (1) {
#line 116
    tmp___2 = buffer_len(& stderr_buffer);
#line 116
    if (tmp___2 > 0U) {
#line 116
      tmp___3 = packet_not_very_much_data_to_write();
#line 116
      if (! tmp___3) {
#line 116
        break;
      }
    } else {
#line 116
      break;
    }
#line 118
    tmp = buffer_len(& stderr_buffer);
#line 118
    len = (int )tmp;
#line 119
    tmp___0 = packet_is_interactive();
#line 119
    if (tmp___0) {
#line 120
      if (len > 512) {
#line 121
        len = 512;
      }
    } else {
#line 124
      if (len > max_packet_size) {
#line 125
        len = max_packet_size;
      }
    }
#line 127
    packet_start((unsigned char)18);
#line 128
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 128
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 129
    packet_send();
#line 130
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 131
    stderr_bytes += (long )len;
  }
#line 133
  return;
}
}
#line 139 "serverloop.c"
static void make_packets_from_stdout_data(void) 
{ int len ;
  u_int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;

  {
#line 145
  while (1) {
#line 145
    tmp___2 = buffer_len(& stdout_buffer);
#line 145
    if (tmp___2 > 0U) {
#line 145
      tmp___3 = packet_not_very_much_data_to_write();
#line 145
      if (! tmp___3) {
#line 145
        break;
      }
    } else {
#line 145
      break;
    }
#line 147
    tmp = buffer_len(& stdout_buffer);
#line 147
    len = (int )tmp;
#line 148
    tmp___0 = packet_is_interactive();
#line 148
    if (tmp___0) {
#line 149
      if (len > 512) {
#line 150
        len = 512;
      }
    } else {
#line 153
      if (len > max_packet_size) {
#line 154
        len = max_packet_size;
      }
    }
#line 156
    packet_start((unsigned char)17);
#line 157
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 157
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 158
    packet_send();
#line 159
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 160
    stdout_bytes += (long )len;
  }
#line 162
  return;
}
}
#line 170 "serverloop.c"
static void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                        int *nallocp , u_int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int client_alive_scheduled ;
  int tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int id ;

  {
#line 176
  client_alive_scheduled = 0;
#line 186
  if (compat20) {
#line 186
    if (max_time_milliseconds == 0U) {
#line 186
      if (options.client_alive_interval) {
#line 188
        client_alive_scheduled = 1;
#line 189
        max_time_milliseconds = (unsigned int )(options.client_alive_interval * 1000);
      }
    }
  }
  retry_select: 
#line 196
  channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
#line 198
  if (compat20) {
#line 200
    tmp = channel_not_very_much_buffered_data();
#line 200
    if (tmp) {
#line 201
      __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 207
    tmp___0 = buffer_len(& stdin_buffer);
#line 207
    if (tmp___0 < buffer_high) {
#line 207
      tmp___1 = channel_not_very_much_buffered_data();
#line 207
      if (tmp___1) {
#line 209
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 214
    tmp___2 = packet_not_very_much_data_to_write();
#line 214
    if (tmp___2) {
#line 215
      if (! fdout_eof) {
#line 216
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 217
      if (! fderr_eof) {
#line 218
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 224
    if (fdin != -1) {
#line 224
      tmp___3 = buffer_len(& stdin_buffer);
#line 224
      if (tmp___3 > 0U) {
#line 225
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 232
  tmp___4 = packet_have_data_to_write();
#line 232
  if (tmp___4) {
#line 233
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 239
  if (child_terminated) {
#line 239
    tmp___5 = packet_not_very_much_data_to_write();
#line 239
    if (tmp___5) {
#line 240
      if (max_time_milliseconds == 0U) {
#line 241
        max_time_milliseconds = 100U;
      } else {
#line 240
        if (client_alive_scheduled) {
#line 241
          max_time_milliseconds = 100U;
        }
      }
    }
  }
#line 243
  if (max_time_milliseconds == 0U) {
#line 244
    tvp = (struct timeval *)((void *)0);
  } else {
#line 246
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 247
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 248
    tvp = & tv;
  }
#line 250
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 251
    debug3("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 254
  ret = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 256
  if (ret == -1) {
#line 257
    tmp___8 = __errno_location();
#line 257
    if (*tmp___8 != 4) {
#line 258
      tmp___6 = __errno_location();
#line 258
      tmp___7 = strerror(*tmp___6);
#line 258
      error("select: %.100s", tmp___7);
    } else {
      goto retry_select;
    }
  }
#line 262
  if (ret == 0) {
#line 262
    if (client_alive_scheduled) {
#line 264
      client_alive_timeouts ++;
#line 266
      if (client_alive_timeouts > options.client_alive_count_max) {
#line 267
        packet_disconnect("Timeout, your session not responding.");
      } else {
#line 276
        id = channel_find_open();
#line 277
        if (id != -1) {
#line 278
          channel_request_start(id, (char *)"keepalive@openssh.com", 1);
#line 280
          packet_send();
        } else {
#line 282
          packet_disconnect("No open channels after timeout!");
        }
      }
    }
  }
#line 286
  return;
}
}
#line 292 "serverloop.c"
static void process_input(fd_set *readset ) 
{ int len ;
  char buf___2[16384] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result___0 ;
  int *tmp___5 ;
  int *tmp___6 ;
  register char __result___1 ;

  {
#line 299
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 299
  if (__result) {
#line 300
    len = read(connection_in___0, (void *)(buf___2), sizeof(buf___2));
#line 301
    if (len == 0) {
#line 302
      verbose("Connection closed by remote host.");
#line 303
      connection_closed = 1;
#line 304
      if (compat20) {
#line 305
        return;
      }
#line 306
      fatal_cleanup();
    } else {
#line 307
      if (len < 0) {
#line 308
        tmp___1 = __errno_location();
#line 308
        if (*tmp___1 != 4) {
#line 308
          tmp___2 = __errno_location();
#line 308
          if (*tmp___2 != 11) {
#line 309
            tmp = __errno_location();
#line 309
            tmp___0 = strerror(*tmp);
#line 309
            verbose("Read error from remote host: %.100s", tmp___0);
#line 310
            fatal_cleanup();
          }
        }
      } else {
#line 314
        packet_process_incoming((char const   *)(buf___2), (unsigned int )len);
      }
    }
  }
#line 317
  if (compat20) {
#line 318
    return;
  }
#line 321
  if (! fdout_eof) {
#line 321
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 321
    if (__result___0) {
#line 322
      len = read(fdout, (void *)(buf___2), sizeof(buf___2));
#line 323
      if (len < 0) {
#line 323
        tmp___3 = __errno_location();
#line 323
        if (! (*tmp___3 == 4)) {
#line 323
          tmp___4 = __errno_location();
#line 323
          if (! (*tmp___4 == 11)) {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 325
        if (len <= 0) {
#line 326
          fdout_eof = 1;
        } else {
#line 328
          buffer_append(& stdout_buffer, (char const   *)(buf___2), (unsigned int )len);
#line 329
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 333
  if (! fderr_eof) {
#line 333
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 333
    if (__result___1) {
#line 334
      len = read(fderr, (void *)(buf___2), sizeof(buf___2));
#line 335
      if (len < 0) {
#line 335
        tmp___5 = __errno_location();
#line 335
        if (! (*tmp___5 == 4)) {
#line 335
          tmp___6 = __errno_location();
#line 335
          if (! (*tmp___6 == 11)) {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 337
        if (len <= 0) {
#line 338
          fderr_eof = 1;
        } else {
#line 340
          buffer_append(& stderr_buffer, (char const   *)(buf___2), (unsigned int )len);
        }
      }
    }
  }
#line 343
  return;
}
}
#line 348 "serverloop.c"
static void process_output(fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 357
  if (! compat20) {
#line 357
    if (fdin != -1) {
#line 357
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 357
      if (__result) {
#line 358
        tmp = buffer_ptr(& stdin_buffer);
#line 358
        data = (u_char *)tmp;
#line 359
        dlen = buffer_len(& stdin_buffer);
#line 360
        len = write(fdin, (void const   *)data, dlen);
#line 361
        if (len < 0) {
#line 361
          tmp___1 = __errno_location();
#line 361
          if (! (*tmp___1 == 4)) {
#line 361
            tmp___2 = __errno_location();
#line 361
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 363
          if (len <= 0) {
#line 367
            if (fdin != fdout) {
#line 368
              close(fdin);
            } else {
#line 370
              shutdown(fdin, 1);
            }
#line 372
            fdin = -1;
          } else {
#line 375
            if (fdin_is_tty) {
#line 375
              if (dlen >= 1U) {
#line 375
                if ((int )*(data + 0) != 13) {
#line 375
                  tmp___0 = tcgetattr(fdin, & tio);
#line 375
                  if (tmp___0 == 0) {
#line 375
                    if (! (tio.c_lflag & 8U)) {
#line 375
                      if (tio.c_lflag & 2U) {
#line 382
                        packet_send_ignore(len);
#line 383
                        packet_send();
                      }
                    }
                  }
                }
              }
            }
#line 386
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 388
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 392
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 392
  if (__result___0) {
#line 393
    packet_write_poll();
  }
#line 394
  return;
}
}
#line 400 "serverloop.c"
static void drain_output(void) 
{ u_int tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 404
  tmp___2 = buffer_len(& stdout_buffer);
#line 404
  if (tmp___2 > 0U) {
#line 405
    packet_start((unsigned char)17);
#line 406
    tmp = buffer_len(& stdout_buffer);
#line 406
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 406
    packet_put_string((char const   *)tmp___0, tmp);
#line 408
    packet_send();
#line 410
    tmp___1 = buffer_len(& stdout_buffer);
#line 410
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 413
  tmp___6 = buffer_len(& stderr_buffer);
#line 413
  if (tmp___6 > 0U) {
#line 414
    packet_start((unsigned char)18);
#line 415
    tmp___3 = buffer_len(& stderr_buffer);
#line 415
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 415
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 417
    packet_send();
#line 419
    tmp___5 = buffer_len(& stderr_buffer);
#line 419
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 422
  packet_write_wait();
#line 423
  return;
}
}
#line 425 "serverloop.c"
static void process_buffered_input_packets(void) 
{ Kex *tmp ;

  {
#line 428
  if (compat20) {
#line 428
    tmp = xxx_kex;
  } else {
#line 428
    tmp = (Kex *)((void *)0);
  }
#line 428
  dispatch_run(1, (int *)((void *)0), (void *)tmp);
#line 429
  return;
}
}
#line 438 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  int nalloc ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  union __anonunion_82 __constr_expr_0 ;
  union __anonunion_83 __constr_expr_1 ;
  int plen ;
  union __anonunion_84 __constr_expr_2 ;
  union __anonunion_85 __constr_expr_3 ;
  union __anonunion_86 __constr_expr_4 ;

  {
#line 441
  readset = (fd_set *)((void *)0);
#line 441
  writeset = (fd_set *)((void *)0);
#line 442
  max_fd = 0;
#line 442
  nalloc = 0;
#line 445
  waiting_termination = 0;
#line 451
  debug("Entering interactive session.");
#line 454
  child_terminated = (int volatile   )0;
#line 455
  mysignal(17, & sigchld_handler);
#line 458
  fdin = fdin_arg;
#line 459
  fdout = fdout_arg;
#line 460
  fderr = fderr_arg;
#line 463
  set_nonblock(fdin);
#line 464
  set_nonblock(fdout);
#line 466
  if (fderr != -1) {
#line 467
    set_nonblock(fderr);
  }
#line 469
  if (! (datafellows & 256)) {
#line 469
    tmp = isatty(fdin);
#line 469
    if (tmp) {
#line 470
      fdin_is_tty = 1;
    }
  }
#line 472
  connection_in___0 = packet_get_connection_in();
#line 473
  connection_out___0 = packet_get_connection_out();
#line 475
  previous_stdout_buffer_bytes = 0U;
#line 478
  tmp___0 = packet_is_interactive();
#line 478
  if (tmp___0) {
#line 479
    buffer_high = 4096U;
  } else {
#line 481
    buffer_high = 65536U;
  }
#line 493
  buffer_init(& stdin_buffer);
#line 494
  buffer_init(& stdout_buffer);
#line 495
  buffer_init(& stderr_buffer);
#line 503
  if (fderr == -1) {
#line 504
    fderr_eof = 1;
  }
#line 506
  server_init_dispatch();
#line 509
  while (1) {
#line 512
    process_buffered_input_packets();
#line 518
    if (stdin_eof) {
#line 518
      if (fdin != -1) {
#line 518
        tmp___1 = buffer_len(& stdin_buffer);
#line 518
        if (tmp___1 == 0U) {
#line 522
          if (fdin != fdout) {
#line 523
            close(fdin);
          } else {
#line 525
            shutdown(fdin, 1);
          }
#line 527
          fdin = -1;
        }
      }
    }
#line 530
    make_packets_from_stderr_data();
#line 539
    max_time_milliseconds = 0U;
#line 540
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 541
    if (stdout_buffer_bytes != 0U) {
#line 541
      if (stdout_buffer_bytes < 256U) {
#line 541
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 544
          max_time_milliseconds = 10U;
        } else {
#line 547
          make_packets_from_stdout_data();
        }
      } else {
#line 547
        make_packets_from_stdout_data();
      }
    } else {
#line 547
      make_packets_from_stdout_data();
    }
#line 549
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 552
    tmp___2 = packet_not_very_much_data_to_write();
#line 552
    if (tmp___2) {
#line 553
      channel_output_poll();
    }
#line 560
    if (fdout_eof) {
#line 560
      if (fderr_eof) {
#line 560
        tmp___6 = packet_have_data_to_write();
#line 560
        if (! tmp___6) {
#line 560
          tmp___7 = buffer_len(& stdout_buffer);
#line 560
          if (tmp___7 == 0U) {
#line 560
            tmp___8 = buffer_len(& stderr_buffer);
#line 560
            if (tmp___8 == 0U) {
#line 562
              tmp___3 = channel_still_open();
#line 562
              if (! tmp___3) {
#line 563
                break;
              }
#line 564
              if (! waiting_termination) {
#line 565
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 567
                waiting_termination = 1;
#line 568
                tmp___4 = strlen(s);
#line 568
                buffer_append(& stderr_buffer, s, tmp___4);
#line 571
                cp = channel_open_message();
#line 572
                tmp___5 = strlen((char const   *)cp);
#line 572
                buffer_append(& stderr_buffer, (char const   *)cp, tmp___5);
#line 573
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 576
    if (connection_in___0 > connection_out___0) {
#line 576
      max_fd = connection_in___0;
    } else {
#line 576
      max_fd = connection_out___0;
    }
#line 577
    if (max_fd > fdin) {
#line 577
      max_fd = max_fd;
    } else {
#line 577
      max_fd = fdin;
    }
#line 578
    if (max_fd > fdout) {
#line 578
      max_fd = max_fd;
    } else {
#line 578
      max_fd = fdout;
    }
#line 579
    if (max_fd > fderr) {
#line 579
      max_fd = max_fd;
    } else {
#line 579
      max_fd = fderr;
    }
#line 582
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, max_time_milliseconds);
#line 586
    channel_after_select(readset, writeset);
#line 589
    process_input(readset);
#line 592
    process_output(writeset);
  }
#line 594
  if (readset) {
#line 595
    xfree((void *)readset);
  }
#line 596
  if (writeset) {
#line 597
    xfree((void *)writeset);
  }
#line 602
  drain_output();
#line 604
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 608
  buffer_free(& stdin_buffer);
#line 609
  buffer_free(& stdout_buffer);
#line 610
  buffer_free(& stderr_buffer);
#line 613
  if (fdout != -1) {
#line 614
    close(fdout);
  }
#line 615
  fdout = -1;
#line 616
  fdout_eof = 1;
#line 617
  if (fderr != -1) {
#line 618
    close(fderr);
  }
#line 619
  fderr = -1;
#line 620
  fderr_eof = 1;
#line 621
  if (fdin != -1) {
#line 622
    close(fdin);
  }
#line 623
  fdin = -1;
#line 625
  channel_free_all();
#line 628
  mysignal(17, (void (*)(int  ))0);
#line 630
  if (child_terminated) {
#line 630
    tmp___9 = 1;
  } else {
#line 630
    tmp___9 = 0;
  }
#line 630
  wait_pid = waitpid(-1, & wait_status, tmp___9);
#line 631
  if (wait_pid == -1) {
#line 632
    tmp___10 = __errno_location();
#line 632
    tmp___11 = strerror(*tmp___10);
#line 632
    packet_disconnect("wait: %.100s", tmp___11);
  } else {
#line 633
    if (wait_pid != pid) {
#line 634
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 638
  __constr_expr_2.__in = wait_status;
#line 638
  if ((__constr_expr_2.__i & 127) == 0) {
#line 640
    __constr_expr_0.__in = wait_status;
#line 640
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 641
    packet_start((unsigned char)20);
#line 642
    __constr_expr_1.__in = wait_status;
#line 642
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 643
    packet_send();
#line 644
    packet_write_wait();
#line 653
    while (1) {
#line 655
      type = packet_read(& plen);
#line 653
      if (! (type != 33)) {
#line 653
        break;
      }
    }
#line 659
    debug("Received exit confirmation.");
#line 660
    return;
  }
#line 663
  __constr_expr_4.__in = wait_status;
#line 663
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 664
    __constr_expr_3.__in = wait_status;
#line 664
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 668
  packet_disconnect("wait returned status %04x.", wait_status);
#line 670
  return;
}
}
#line 672 "serverloop.c"
void server_loop2(Authctxt *authctxt ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int rekeying ;
  int max_fd ;
  int status ;
  int nalloc ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 675
  readset = (fd_set *)((void *)0);
#line 675
  writeset = (fd_set *)((void *)0);
#line 676
  rekeying = 0;
#line 676
  nalloc = 0;
#line 679
  debug("Entering interactive session for SSH2.");
#line 681
  mysignal(17, & sigchld_handler);
#line 682
  child_terminated = (int volatile   )0;
#line 683
  connection_in___0 = packet_get_connection_in();
#line 684
  connection_out___0 = packet_get_connection_out();
#line 686
  if (connection_in___0 > connection_out___0) {
#line 686
    max_fd = connection_in___0;
  } else {
#line 686
    max_fd = connection_out___0;
  }
#line 687
  xxx_authctxt = authctxt;
#line 689
  server_init_dispatch();
#line 691
  while (1) {
#line 692
    process_buffered_input_packets();
#line 694
    if ((unsigned int )xxx_kex != (unsigned int )((void *)0)) {
#line 694
      if (! xxx_kex->done) {
#line 694
        tmp = 1;
      } else {
#line 694
        tmp = 0;
      }
    } else {
#line 694
      tmp = 0;
    }
#line 694
    rekeying = tmp;
#line 696
    if (! rekeying) {
#line 696
      tmp___0 = packet_not_very_much_data_to_write();
#line 696
      if (tmp___0) {
#line 697
        channel_output_poll();
      }
    }
#line 698
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, 0U);
#line 700
    if (child_terminated) {
#line 701
      while (1) {
#line 701
        pid = waitpid(-1, & status, 1);
#line 701
        if (! (pid > 0)) {
#line 701
          break;
        }
#line 702
        session_close_by_pid(pid, status);
      }
#line 703
      child_terminated = (int volatile   )0;
    }
#line 705
    if (! rekeying) {
#line 706
      channel_after_select(readset, writeset);
    }
#line 707
    process_input(readset);
#line 708
    if (connection_closed) {
#line 709
      break;
    }
#line 710
    process_output(writeset);
  }
#line 712
  if (readset) {
#line 713
    xfree((void *)readset);
  }
#line 714
  if (writeset) {
#line 715
    xfree((void *)writeset);
  }
#line 717
  mysignal(17, (void (*)(int  ))0);
#line 719
  while (1) {
#line 719
    pid = waitpid(-1, & status, 1);
#line 719
    if (! (pid > 0)) {
#line 719
      break;
    }
#line 720
    session_close_by_pid(pid, status);
  }
#line 725
  channel_detach_all();
#line 726
  channel_stop_listening();
#line 728
  while (1) {
#line 728
    tmp___3 = session_have_children();
#line 728
    if (! tmp___3) {
#line 728
      break;
    }
#line 729
    pid = waitpid(-1, & status, 0);
#line 730
    if (pid > 0) {
#line 731
      session_close_by_pid(pid, status);
    } else {
#line 733
      tmp___1 = __errno_location();
#line 733
      tmp___2 = strerror(*tmp___1);
#line 733
      error("waitpid returned %d: %s", pid, tmp___2);
#line 734
      break;
    }
  }
#line 737
  channel_free_all();
#line 738
  return;
}
}
#line 740 "serverloop.c"
static void server_input_channel_failure(int type , int plen , void *ctxt ) 
{ 

  {
#line 743
  debug("Got CHANNEL_FAILURE for keepalive");
#line 749
  client_alive_timeouts = 0;
#line 750
  return;
}
}
#line 753 "serverloop.c"
static void server_input_stdin_data(int type , int plen , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  int _p ;
  int _e ;

  {
#line 761
  if (fdin == -1) {
#line 762
    return;
  }
#line 763
  data = packet_get_string(& data_len);
#line 764
  while (1) {
#line 764
    _p = plen;
#line 764
    _e = (int )(4U + data_len);
#line 764
    if (_p != _e) {
#line 764
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 764);
#line 764
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 764
    break;
  }
#line 765
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 766
  memset((void *)data, 0, data_len);
#line 767
  xfree((void *)data);
#line 768
  return;
}
}
#line 770 "serverloop.c"
static void server_input_eof(int type , int plen , void *ctxt ) 
{ int _p ;
  int _e ;

  {
#line 778
  debug("EOF received for stdin.");
#line 779
  while (1) {
#line 779
    _p = plen;
#line 779
    _e = 0;
#line 779
    if (_p != _e) {
#line 779
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 779);
#line 779
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 779
    break;
  }
#line 780
  stdin_eof = 1;
#line 781
  return;
}
}
#line 783 "serverloop.c"
static void server_input_window_size(int type , int plen , void *ctxt ) 
{ int row ;
  u_int tmp ;
  int col ;
  u_int tmp___0 ;
  int xpixel ;
  u_int tmp___1 ;
  int ypixel ;
  u_int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 786
  tmp = packet_get_int();
#line 786
  row = (int )tmp;
#line 787
  tmp___0 = packet_get_int();
#line 787
  col = (int )tmp___0;
#line 788
  tmp___1 = packet_get_int();
#line 788
  xpixel = (int )tmp___1;
#line 789
  tmp___2 = packet_get_int();
#line 789
  ypixel = (int )tmp___2;
#line 791
  debug("Window change received.");
#line 792
  while (1) {
#line 792
    _p = plen;
#line 792
    _e = 16;
#line 792
    if (_p != _e) {
#line 792
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 792);
#line 792
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 792
    break;
  }
#line 793
  if (fdin != -1) {
#line 794
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 795
  return;
}
}
#line 797 "serverloop.c"
static Channel *server_request_direct_tcpip(char *ctype ) 
{ Channel *c ;
  int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 805
  target = packet_get_string((u_int *)((void *)0));
#line 806
  tmp = packet_get_int();
#line 806
  target_port = (int )tmp;
#line 807
  originator = packet_get_string((u_int *)((void *)0));
#line 808
  tmp___0 = packet_get_int();
#line 808
  originator_port = (int )tmp___0;
#line 809
  while (1) {
#line 809
    tmp___1 = packet_remaining();
#line 809
    _len = tmp___1;
#line 809
    if (_len > 0) {
#line 809
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          809);
#line 809
      packet_disconnect("Packet integrity error.");
    }
#line 809
    break;
  }
#line 811
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 815
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 816
  xfree((void *)target);
#line 817
  xfree((void *)originator);
#line 818
  if (sock < 0) {
#line 819
    return ((Channel *)((void *)0));
  }
#line 820
  tmp___2 = xstrdup("direct-tcpip");
#line 820
  c = channel_new(ctype, 12, sock, sock, -1, 32768, 16384, 0, tmp___2, 1);
#line 823
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 824
    error("server_request_direct_tcpip: channel_new failed");
#line 825
    close(sock);
  }
#line 827
  return (c);
}
}
#line 830 "serverloop.c"
static Channel *server_request_session(char *ctype ) 
{ Channel *c ;
  int _len ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 835
  debug("input_session_request");
#line 836
  while (1) {
#line 836
    tmp = packet_remaining();
#line 836
    _len = tmp;
#line 836
    if (_len > 0) {
#line 836
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          836);
#line 836
      packet_disconnect("Packet integrity error.");
    }
#line 836
    break;
  }
#line 843
  tmp___0 = xstrdup("server-session");
#line 843
  c = channel_new(ctype, 10, -1, -1, -1, 0, 16384, 0, tmp___0, 1);
#line 846
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 847
    error("server_request_session: channel_new failed");
#line 848
    return ((Channel *)((void *)0));
  }
#line 850
  tmp___1 = session_open(xxx_authctxt, c->self);
#line 850
  if (tmp___1 != 1) {
#line 851
    debug("session open failed, free channel %d", c->self);
#line 852
    channel_free(c);
#line 853
    return ((Channel *)((void *)0));
  }
#line 855
  channel_register_callback(c->self, 98, & session_input_channel_req, (void *)0);
#line 857
  channel_register_cleanup(c->self, & session_close_by_channel);
#line 858
  return (c);
}
}
#line 861 "serverloop.c"
static void server_input_channel_open(int type , int plen , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  u_int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 864
  c = (Channel *)((void *)0);
#line 871
  ctype = packet_get_string(& len);
#line 872
  tmp = packet_get_int();
#line 872
  rchan = (int )tmp;
#line 873
  tmp___0 = packet_get_int();
#line 873
  rwindow = (int )tmp___0;
#line 874
  tmp___1 = packet_get_int();
#line 874
  rmaxpack = (int )tmp___1;
#line 876
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 879
  if (0) {
#line 879
    __s1_len___0 = strlen((char const   *)ctype);
#line 879
    __s2_len___0 = strlen("session");
#line 879
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 879
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 879
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 879
          tmp___21 = 1;
        } else {
#line 879
          if (__s2_len___0 >= 4U) {
#line 879
            tmp___21 = 1;
          } else {
#line 879
            tmp___21 = 0;
          }
        }
      } else {
#line 879
        tmp___21 = 0;
      }
    }
#line 879
    if (tmp___21) {
#line 879
      tmp___17 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 879
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
#line 879
      tmp___17 = tmp___20;
    }
  } else {
#line 879
    tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
#line 879
    tmp___17 = tmp___20;
  }
#line 879
  if (tmp___17 == 0) {
#line 880
    c = server_request_session(ctype);
  } else {
#line 881
    if (0) {
#line 881
      __s1_len = strlen((char const   *)ctype);
#line 881
      __s2_len = strlen("direct-tcpip");
#line 881
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 881
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 881
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 881
            tmp___11 = 1;
          } else {
#line 881
            if (__s2_len >= 4U) {
#line 881
              tmp___11 = 1;
            } else {
#line 881
              tmp___11 = 0;
            }
          }
        } else {
#line 881
          tmp___11 = 0;
        }
      }
#line 881
      if (tmp___11) {
#line 881
        tmp___7 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 881
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 881
        tmp___7 = tmp___10;
      }
    } else {
#line 881
      tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 881
      tmp___7 = tmp___10;
    }
#line 881
    if (tmp___7 == 0) {
#line 882
      c = server_request_direct_tcpip(ctype);
    }
  }
#line 884
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 885
    debug("server_input_channel_open: confirm %s", ctype);
#line 886
    c->remote_id = rchan;
#line 887
    c->remote_window = rwindow;
#line 888
    c->remote_maxpacket = rmaxpack;
#line 889
    if (c->type != 12) {
#line 890
      packet_start((unsigned char)91);
#line 891
      packet_put_int((unsigned int )c->remote_id);
#line 892
      packet_put_int((unsigned int )c->self);
#line 893
      packet_put_int((unsigned int )c->local_window);
#line 894
      packet_put_int((unsigned int )c->local_maxpacket);
#line 895
      packet_send();
    }
  } else {
#line 898
    debug("server_input_channel_open: failure %s", ctype);
#line 899
    packet_start((unsigned char)92);
#line 900
    packet_put_int((unsigned int )rchan);
#line 901
    packet_put_int(1U);
#line 902
    if (! (datafellows & 131072)) {
#line 903
      packet_put_cstring("open failed");
#line 904
      packet_put_cstring("");
    }
#line 906
    packet_send();
  }
#line 908
  xfree((void *)ctype);
#line 909
  return;
}
}
#line 911 "serverloop.c"
static void server_input_global_request(int type , int plen , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  u_int tmp ;
  struct passwd *pw ;
  char *listen_address ;
  u_short listen_port ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 916
  success = 0;
#line 918
  rtype = packet_get_string((u_int *)((void *)0));
#line 919
  tmp = packet_get_char();
#line 919
  want_reply = (int )tmp;
#line 920
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 923
  if (0) {
#line 923
    __s1_len = strlen((char const   *)rtype);
#line 923
    __s2_len = strlen("tcpip-forward");
#line 923
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 923
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 923
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 923
          tmp___10 = 1;
        } else {
#line 923
          if (__s2_len >= 4U) {
#line 923
            tmp___10 = 1;
          } else {
#line 923
            tmp___10 = 0;
          }
        }
      } else {
#line 923
        tmp___10 = 0;
      }
    }
#line 923
    if (tmp___10) {
#line 923
      tmp___6 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 923
      tmp___9 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 923
      tmp___6 = tmp___9;
    }
  } else {
#line 923
    tmp___9 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 923
    tmp___6 = tmp___9;
  }
#line 923
  if (tmp___6 == 0) {
#line 928
    pw = auth_get_user();
#line 929
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 930
      fatal("server_input_global_request: no user");
    }
#line 931
    listen_address = packet_get_string((u_int *)((void *)0));
#line 932
    tmp___0 = packet_get_int();
#line 932
    listen_port = (unsigned short )tmp___0;
#line 933
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 937
    if (! options.allow_tcp_forwarding) {
#line 940
      success = 0;
#line 941
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 937
      if (no_port_forwarding_flag) {
#line 940
        success = 0;
#line 941
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 937
        if ((int )listen_port < 1024) {
#line 937
          if (pw->pw_uid != 0U) {
#line 940
            success = 0;
#line 941
            packet_send_debug("Server has disabled port forwarding.");
          } else {
#line 944
            success = channel_request_forwarding((char const   *)listen_address, listen_port,
                                                 "<unspec host>", (unsigned short)0,
                                                 options.gateway_ports, 1);
          }
        } else {
#line 944
          success = channel_request_forwarding((char const   *)listen_address, listen_port,
                                               "<unspec host>", (unsigned short)0,
                                               options.gateway_ports, 1);
        }
      }
    }
#line 950
    xfree((void *)listen_address);
  }
#line 952
  if (want_reply) {
#line 953
    if (success) {
#line 953
      tmp___11 = 81;
    } else {
#line 953
      tmp___11 = 82;
    }
#line 953
    packet_start((unsigned char )tmp___11);
#line 955
    packet_send();
#line 956
    packet_write_wait();
  }
#line 958
  xfree((void *)rtype);
#line 959
  return;
}
}
#line 961 "serverloop.c"
static void server_init_dispatch_20(void) 
{ 

  {
#line 964
  debug("server_init_dispatch_20");
#line 965
  dispatch_init(& dispatch_protocol_error);
#line 966
  dispatch_set(97, & channel_input_oclose);
#line 967
  dispatch_set(94, & channel_input_data);
#line 968
  dispatch_set(96, & channel_input_ieof);
#line 969
  dispatch_set(95, & channel_input_extended_data);
#line 970
  dispatch_set(90, & server_input_channel_open);
#line 971
  dispatch_set(91, & channel_input_open_confirmation);
#line 972
  dispatch_set(92, & channel_input_open_failure);
#line 973
  dispatch_set(98, & channel_input_channel_request);
#line 974
  dispatch_set(93, & channel_input_window_adjust);
#line 975
  dispatch_set(80, & server_input_global_request);
#line 977
  dispatch_set(100, & server_input_channel_failure);
#line 979
  dispatch_set(20, & kex_input_kexinit);
#line 980
  return;
}
}
#line 981 "serverloop.c"
static void server_init_dispatch_13(void) 
{ 

  {
#line 984
  debug("server_init_dispatch_13");
#line 985
  dispatch_init((dispatch_fn *)((void *)0));
#line 986
  dispatch_set(19, & server_input_eof);
#line 987
  dispatch_set(16, & server_input_stdin_data);
#line 988
  dispatch_set(11, & server_input_window_size);
#line 989
  dispatch_set(24, & channel_input_close);
#line 990
  dispatch_set(25, & channel_input_close_confirmation);
#line 991
  dispatch_set(23, & channel_input_data);
#line 992
  dispatch_set(21, & channel_input_open_confirmation);
#line 993
  dispatch_set(22, & channel_input_open_failure);
#line 994
  dispatch_set(29, & channel_input_port_open);
#line 995
  return;
}
}
#line 996 "serverloop.c"
static void server_init_dispatch_15(void) 
{ 

  {
#line 999
  server_init_dispatch_13();
#line 1000
  debug("server_init_dispatch_15");
#line 1001
  dispatch_set(24, & channel_input_ieof);
#line 1002
  dispatch_set(25, & channel_input_oclose);
#line 1003
  return;
}
}
#line 1004 "serverloop.c"
static void server_init_dispatch(void) 
{ 

  {
#line 1007
  if (compat20) {
#line 1008
    server_init_dispatch_20();
  } else {
#line 1009
    if (compat13) {
#line 1010
      server_init_dispatch_13();
    } else {
#line 1012
      server_init_dispatch_15();
    }
  }
#line 1013
  return;
}
}
#line 1 "md5crypt.o"
#line 1 "session.o"
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 333
extern int printf(char const   * __restrict  __format  , ...) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 123 "session.c"
Session *session_new(void) ;
#line 124
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 125
static void session_pty_cleanup(void *session ) ;
#line 126
void session_proctitle(Session *s ) ;
#line 127
int session_setup_x11fwd(Session *s ) ;
#line 128
void do_exec_pty(Session *s , char const   *command ) ;
#line 129
void do_exec_no_pty(Session *s , char const   *command ) ;
#line 130
void do_exec(Session *s , char const   *command ) ;
#line 131
void do_login(Session *s , char const   *command ) ;
#line 132
void do_child(Session *s , char const   *command ) ;
#line 133
void do_motd(void) ;
#line 134
int check_quietlogin(Session *s , char const   *command ) ;
#line 136
static void do_authenticated1(Authctxt *authctxt ) ;
#line 137
static void do_authenticated2(Authctxt *authctxt ) ;
#line 139
static void session_close(Session *s ) ;
#line 140
static int session_pty_req(Session *s ) ;
#line 152 "session.c"
char const   *original_command  =    (char const   *)((void *)0);
#line 156 "session.c"
Session sessions[10]  ;
#line 167 "session.c"
void do_authenticated(Authctxt *authctxt ) 
{ char *tmp ;

  {
#line 174
  alarm(0U);
#line 175
  if (startup_pipe != -1) {
#line 176
    close(startup_pipe);
#line 177
    startup_pipe = -1;
  }
#line 192
  if (! no_port_forwarding_flag) {
#line 192
    if (options.allow_tcp_forwarding) {
#line 193
      channel_permit_all_opens();
    }
  }
#line 195
  if (compat20) {
#line 196
    do_authenticated2(authctxt);
  } else {
#line 198
    do_authenticated1(authctxt);
  }
#line 201
  tmp = auth_get_socket_name();
#line 201
  if (tmp) {
#line 202
    auth_sock_cleanup_proc((void *)authctxt->pw);
  }
#line 211
  return;
}
}
#line 219 "session.c"
static void do_authenticated1(Authctxt *authctxt ) 
{ Session *s ;
  char *command ;
  int success ;
  int type ;
  int plen ;
  int screen_flag ;
  int compression_level ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  int _p ;
  int _e ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int _len ;
  int tmp___3 ;
  u_int tmp___4 ;
  int tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 225
  compression_level = 0;
#line 225
  enable_compression_after_reply = 0;
#line 228
  s = session_new();
#line 229
  s->authctxt = authctxt;
#line 230
  s->pw = authctxt->pw;
#line 236
  while (1) {
#line 237
    success = 0;
#line 240
    type = packet_read(& plen);
#line 243
    switch (type) {
    case 37: 
#line 245
    while (1) {
#line 245
      _p = plen;
#line 245
      _e = 4;
#line 245
      if (_p != _e) {
#line 245
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 245);
#line 245
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 245
      break;
    }
#line 246
    tmp = packet_get_int();
#line 246
    compression_level = (int )tmp;
#line 247
    if (compression_level < 1) {
#line 248
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 250
      break;
    } else {
#line 247
      if (compression_level > 9) {
#line 248
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 250
        break;
      }
    }
#line 253
    enable_compression_after_reply = 1;
#line 254
    success = 1;
#line 255
    break;
    case 10: 
#line 258
    success = session_pty_req(s);
#line 259
    break;
    case 34: 
#line 262
    s->auth_proto = packet_get_string(& proto_len);
#line 263
    s->auth_data = packet_get_string(& data_len);
#line 265
    tmp___0 = packet_get_protocol_flags();
#line 265
    screen_flag = (int )(tmp___0 & 1U);
#line 267
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 269
    tmp___2 = packet_remaining();
#line 269
    if (tmp___2 == 4) {
#line 270
      if (! screen_flag) {
#line 271
        debug2("Buggy client: X11 screen flag missing");
      }
#line 273
      tmp___1 = packet_get_int();
#line 273
      s->screen = (int )tmp___1;
    } else {
#line 275
      s->screen = 0;
    }
#line 277
    while (1) {
#line 277
      tmp___3 = packet_remaining();
#line 277
      _len = tmp___3;
#line 277
      if (_len > 0) {
#line 277
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            277);
#line 277
        packet_disconnect("Packet integrity error.");
      }
#line 277
      break;
    }
#line 278
    success = session_setup_x11fwd(s);
#line 279
    if (! success) {
#line 280
      xfree((void *)s->auth_proto);
#line 281
      xfree((void *)s->auth_data);
#line 282
      s->auth_proto = (char *)((void *)0);
#line 283
      s->auth_data = (char *)((void *)0);
    }
#line 285
    break;
    case 30: 
#line 288
    if (no_agent_forwarding_flag) {
#line 289
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 290
      break;
    } else {
#line 288
      if (compat13) {
#line 289
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 290
        break;
      }
    }
#line 292
    debug("Received authentication agent forwarding request.");
#line 293
    success = auth_input_request_forwarding(s->pw);
#line 294
    break;
    case 28: 
#line 297
    if (no_port_forwarding_flag) {
#line 298
      debug("Port forwarding not permitted for this authentication.");
#line 299
      break;
    }
#line 301
    if (! options.allow_tcp_forwarding) {
#line 302
      debug("Port forwarding not permitted.");
#line 303
      break;
    }
#line 305
    debug("Received TCP/IP port forwarding request.");
#line 306
    channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
#line 307
    success = 1;
#line 308
    break;
    case 38: 
#line 311
    tmp___4 = packet_get_int();
#line 311
    tmp___5 = packet_set_maxsize((int )tmp___4);
#line 311
    if (tmp___5 > 0) {
#line 312
      success = 1;
    }
#line 313
    break;
    case 12: 
    case 13: 
#line 369
    if (type == 13) {
#line 370
      command = packet_get_string(& dlen);
#line 371
      debug("Exec command \'%.500s\'", command);
#line 372
      do_exec(s, (char const   *)command);
#line 373
      xfree((void *)command);
    } else {
#line 375
      do_exec(s, (char const   *)((void *)0));
    }
#line 377
    while (1) {
#line 377
      tmp___6 = packet_remaining();
#line 377
      _len___0 = tmp___6;
#line 377
      if (_len___0 > 0) {
#line 377
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "session.c",
            377);
#line 377
        packet_disconnect("Packet integrity error.");
      }
#line 377
      break;
    }
#line 378
    session_close(s);
#line 379
    return;
    default: 
#line 386
    log("Unknown packet type received after authentication: %d", type);
    }
#line 388
    if (success) {
#line 388
      tmp___7 = 14;
    } else {
#line 388
      tmp___7 = 15;
    }
#line 388
    packet_start((unsigned char )tmp___7);
#line 389
    packet_send();
#line 390
    packet_write_wait();
#line 393
    if (enable_compression_after_reply) {
#line 394
      enable_compression_after_reply = 0;
#line 395
      packet_start_compression(compression_level);
    }
  }
}
}
#line 405 "session.c"
void do_exec_no_pty(Session *s , char const   *command ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 419
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 419
  if (tmp___1 < 0) {
#line 421
    tmp = __errno_location();
#line 421
    tmp___0 = strerror(*tmp);
#line 421
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 419
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 419
    if (tmp___2 < 0) {
#line 421
      tmp = __errno_location();
#line 421
      tmp___0 = strerror(*tmp);
#line 421
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 424
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 425
    fatal("do_exec_no_pty: no session");
  }
#line 427
  session_proctitle(s);
#line 435
  pid = fork();
#line 435
  if (pid == 0) {
#line 437
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 443
    tmp___5 = setsid();
#line 443
    if (tmp___5 < 0) {
#line 444
      tmp___3 = __errno_location();
#line 444
      tmp___4 = strerror(*tmp___3);
#line 444
      error("setsid failed: %.100s", tmp___4);
    }
#line 473
    close(inout[1]);
#line 474
    close(err[1]);
#line 475
    tmp___6 = dup2(inout[0], 0);
#line 475
    if (tmp___6 < 0) {
#line 476
      perror("dup2 stdin");
    }
#line 477
    tmp___7 = dup2(inout[0], 1);
#line 477
    if (tmp___7 < 0) {
#line 478
      perror("dup2 stdout");
    }
#line 479
    tmp___8 = dup2(err[0], 2);
#line 479
    if (tmp___8 < 0) {
#line 480
      perror("dup2 stderr");
    }
#line 484
    do_child(s, command);
  }
#line 491
  if (pid < 0) {
#line 492
    tmp___9 = __errno_location();
#line 492
    tmp___10 = strerror(*tmp___9);
#line 492
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 493
  s->pid = pid;
#line 495
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 511
  close(inout[0]);
#line 512
  close(err[0]);
#line 518
  if (compat20) {
#line 519
    if (s->is_subsystem) {
#line 519
      tmp___11 = -1;
    } else {
#line 519
      tmp___11 = err[1];
    }
#line 519
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 521
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 525
  return;
}
}
#line 533 "session.c"
void do_exec_pty(Session *s , char const   *command ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;

  {
#line 539
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 540
    fatal("do_exec_pty: no session");
  }
#line 541
  ptyfd = s->ptyfd;
#line 542
  ttyfd = s->ttyfd;
#line 550
  pid = fork();
#line 550
  if (pid == 0) {
#line 553
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 555
    close(ptyfd);
#line 558
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 561
    tmp___1 = fileno(stdin);
#line 561
    tmp___2 = dup2(ttyfd, tmp___1);
#line 561
    if (tmp___2 < 0) {
#line 562
      tmp = __errno_location();
#line 562
      tmp___0 = strerror(*tmp);
#line 562
      error("dup2 stdin failed: %.100s", tmp___0);
    }
#line 565
    tmp___5 = fileno(stdout);
#line 565
    tmp___6 = dup2(ttyfd, tmp___5);
#line 565
    if (tmp___6 < 0) {
#line 566
      tmp___3 = __errno_location();
#line 566
      tmp___4 = strerror(*tmp___3);
#line 566
      error("dup2 stdin failed: %.100s", tmp___4);
    }
#line 569
    tmp___9 = fileno(stderr);
#line 569
    tmp___10 = dup2(ttyfd, tmp___9);
#line 569
    if (tmp___10 < 0) {
#line 570
      tmp___7 = __errno_location();
#line 570
      tmp___8 = strerror(*tmp___7);
#line 570
      error("dup2 stdin failed: %.100s", tmp___8);
    }
#line 573
    close(ttyfd);
#line 577
    if (options.use_login) {
#line 577
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 578
        do_login(s, command);
      }
    } else {
#line 578
      do_login(s, command);
    }
#line 586
    do_child(s, command);
  }
#line 593
  if (pid < 0) {
#line 594
    tmp___11 = __errno_location();
#line 594
    tmp___12 = strerror(*tmp___11);
#line 594
    packet_disconnect("fork failed: %.100s", tmp___12);
  }
#line 595
  s->pid = pid;
#line 598
  close(ttyfd);
#line 605
  fdout___0 = dup(ptyfd);
#line 606
  if (fdout___0 < 0) {
#line 607
    tmp___13 = __errno_location();
#line 607
    tmp___14 = strerror(*tmp___13);
#line 607
    packet_disconnect("dup #1 failed: %.100s", tmp___14);
  }
#line 610
  ptymaster = dup(ptyfd);
#line 611
  if (ptymaster < 0) {
#line 612
    tmp___15 = __errno_location();
#line 612
    tmp___16 = strerror(*tmp___15);
#line 612
    packet_disconnect("dup #2 failed: %.100s", tmp___16);
  }
#line 613
  s->ptymaster = ptymaster;
#line 616
  packet_set_interactive(1);
#line 617
  if (compat20) {
#line 618
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 620
    server_loop(pid, ptyfd, fdout___0, -1);
  }
#line 623
  return;
}
}
#line 657 "session.c"
void do_exec(Session *s , char const   *command ) 
{ 

  {
#line 660
  if (forced_command) {
#line 661
    original_command = command;
#line 662
    command = (char const   *)forced_command;
#line 663
    debug("Forced command \'%.900s\'", command);
  }
#line 666
  if (s->ttyfd != -1) {
#line 667
    do_exec_pty(s, command);
  } else {
#line 669
    do_exec_no_pty(s, command);
  }
#line 671
  original_command = (char const   *)((void *)0);
#line 672
  return;
}
}
#line 675 "session.c"
void do_login(Session *s , char const   *command ) 
{ char *time_string ;
  char hostname[64] ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  time_t last_login_time ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u_long tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char *tmp___9 ;
  char *tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 683
  pw = s->pw;
#line 684
  tmp = getpid();
#line 684
  pid = tmp;
#line 690
  memset((void *)(& from), 0, sizeof(from));
#line 691
  tmp___4 = packet_connection_is_on_socket();
#line 691
  if (tmp___4) {
#line 692
    fromlen = sizeof(from);
#line 693
    tmp___2 = packet_get_connection_in();
#line 693
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 693
    if (tmp___3 < 0) {
#line 695
      tmp___0 = __errno_location();
#line 695
      tmp___1 = strerror(*tmp___0);
#line 695
      debug("getpeername: %.100s", tmp___1);
#line 696
      fatal_cleanup();
    }
  }
#line 701
  if (options.print_lastlog) {
#line 702
    hostname[0] = (char )'\000';
#line 703
    tmp___5 = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, hostname,
                                  sizeof(hostname));
#line 703
    last_login_time = (long )tmp___5;
  }
#line 708
  tmp___6 = get_remote_name_or_ip(utmp_len, options.reverse_mapping_check);
#line 708
  record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___6, (struct sockaddr *)(& from));
#line 723
  tmp___7 = check_quietlogin(s, command);
#line 723
  if (tmp___7) {
#line 724
    return;
  }
#line 735
  if (options.print_lastlog) {
#line 735
    if (last_login_time != 0L) {
#line 736
      time_string = ctime((time_t const   *)(& last_login_time));
#line 737
      tmp___11 = __builtin_strchr(time_string, '\n');
#line 737
      if (tmp___11) {
#line 738
        tmp___9 = __builtin_strchr(time_string, '\n');
#line 738
        *tmp___9 = (char)0;
      }
#line 739
      if (0) {
#line 739
        __s1_len = strlen((char const   *)(hostname));
#line 739
        __s2_len = strlen("");
#line 739
        if (! ((unsigned int )((void const   *)(hostname + 1)) - (unsigned int )((void const   *)(hostname)) == 1U)) {
          goto _L___0;
        } else {
#line 739
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 739
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 739
              tmp___21 = 1;
            } else {
#line 739
              if (__s2_len >= 4U) {
#line 739
                tmp___21 = 1;
              } else {
#line 739
                tmp___21 = 0;
              }
            }
          } else {
#line 739
            tmp___21 = 0;
          }
        }
#line 739
        if (tmp___21) {
#line 739
          tmp___17 = __builtin_strcmp((char const   *)(hostname), "");
        } else {
#line 739
          tmp___20 = __builtin_strcmp((char const   *)(hostname), "");
#line 739
          tmp___17 = tmp___20;
        }
      } else {
#line 739
        tmp___20 = __builtin_strcmp((char const   *)(hostname), "");
#line 739
        tmp___17 = tmp___20;
      }
#line 739
      if (tmp___17 == 0) {
#line 740
        printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
      } else {
#line 742
        printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
               hostname);
      }
    }
  }
#line 745
  do_motd();
#line 746
  return;
}
}
#line 751 "session.c"
void do_motd(void) 
{ FILE *f ;
  char buf___2[256] ;
  char *tmp ;

  {
#line 757
  if (options.print_motd) {
#line 762
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 764
    if (f) {
#line 765
      while (1) {
#line 765
        tmp = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 765
        if (! tmp) {
#line 765
          break;
        }
#line 766
        fputs((char const   * __restrict  )(buf___2), (FILE * __restrict  )stdout);
      }
#line 767
      fclose(f);
    }
  }
#line 770
  return;
}
}
#line 776 "session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ char buf___2[256] ;
  struct passwd *pw ;
  struct stat st ;
  int tmp ;

  {
#line 780
  pw = s->pw;
#line 784
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 785
    return (1);
  }
#line 786
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/.hushlogin",
           pw->pw_dir);
#line 791
  tmp = stat((char const   * __restrict  )(buf___2), (struct stat * __restrict  )(& st));
#line 791
  if (tmp >= 0) {
#line 792
    return (1);
  }
#line 794
  return (0);
}
}
#line 801 "session.c"
static void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ u_int i ;
  u_int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 813
  env = *envp;
#line 814
  namelen = strlen(name);
#line 815
  i = 0U;
#line 815
  while (*(env + i)) {
#line 816
    if (0) {
#line 816
      if (0) {
#line 816
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 816
        __s2_len___0 = strlen(name);
#line 816
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 816
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 816
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 816
              tmp___22 = 1;
            } else {
#line 816
              if (__s2_len___0 >= 4U) {
#line 816
                tmp___22 = 1;
              } else {
#line 816
                tmp___22 = 0;
              }
            }
          } else {
#line 816
            tmp___22 = 0;
          }
        }
#line 816
        if (tmp___22) {
#line 816
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 816
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 816
          tmp___18 = tmp___21;
        }
      } else {
#line 816
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 816
        tmp___18 = tmp___21;
      }
#line 816
      tmp___12 = tmp___18;
    } else {
#line 816
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 816
    if (tmp___12 == 0) {
#line 816
      if ((int )*(*(env + i) + namelen) == 61) {
#line 817
        break;
      }
    }
#line 815
    i ++;
  }
#line 818
  if (*(env + i)) {
#line 820
    xfree((void *)*(env + i));
  } else {
#line 823
    if (i >= *envsizep - 1U) {
#line 824
      *envsizep += 50U;
#line 825
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 825
      *envp = (char **)tmp___25;
#line 825
      env = *envp;
    }
#line 828
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 832
  tmp___26 = strlen(name);
#line 832
  tmp___27 = strlen(value);
#line 832
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 832
  *(env + i) = (char *)tmp___28;
#line 833
  tmp___29 = strlen(name);
#line 833
  tmp___30 = strlen(value);
#line 833
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 834
  return;
}
}
#line 842 "session.c"
static void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___2[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 850
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 851
  if (! f) {
#line 852
    return;
  }
#line 854
  while (1) {
#line 854
    tmp___5 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 854
    if (! tmp___5) {
#line 854
      break;
    }
#line 855
    cp = buf___2;
#line 855
    while (1) {
#line 855
      if (! ((int )*cp == 32)) {
#line 855
        if (! ((int )*cp == 9)) {
#line 855
          break;
        }
      }
#line 855
      cp ++;
    }
#line 857
    if (! *cp) {
#line 858
      continue;
    } else {
#line 857
      if ((int )*cp == 35) {
#line 858
        continue;
      } else {
#line 857
        if ((int )*cp == 10) {
#line 858
          continue;
        }
      }
    }
#line 859
    tmp___2 = __builtin_strchr(cp, '\n');
#line 859
    if (tmp___2) {
#line 860
      tmp___0 = __builtin_strchr(cp, '\n');
#line 860
      *tmp___0 = (char )'\000';
    }
#line 861
    tmp___4 = __builtin_strchr(cp, '=');
#line 861
    value = tmp___4;
#line 862
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 863
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___2);
#line 864
      continue;
    }
#line 870
    *value = (char )'\000';
#line 871
    value ++;
#line 872
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 874
  fclose(f);
#line 875
  return;
}
}
#line 1028
extern char **environ ;
#line 1018 "session.c"
void do_child(Session *s , char const   *command ) 
{ char const   *shell ;
  char const   *hostname ;
  char const   *cp ;
  struct passwd *pw ;
  char buf___2[256] ;
  char cmd[1024] ;
  FILE *f ;
  u_int envsize ;
  u_int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int do_xauth ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  struct envstring *ce ;
  char *s___0 ;
  int i___0 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *screen ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char buf___3[256] ;

  {
#line 1021
  hostname = (char const   *)((void *)0);
#line 1021
  cp = (char const   *)((void *)0);
#line 1022
  pw = s->pw;
#line 1025
  f = (FILE *)((void *)0);
#line 1043
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1043
    if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1043
      if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1043
        tmp = 1;
      } else {
#line 1043
        tmp = 0;
      }
    } else {
#line 1043
      tmp = 0;
    }
  } else {
#line 1043
    tmp = 0;
  }
#line 1043
  do_xauth = tmp;
#line 1047
  destroy_sensitive_data();
#line 1050
  if (options.use_login) {
#line 1050
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1051
      options.use_login = 0;
    }
  }
#line 1054
  if (! options.use_login) {
#line 1060
    if (pw->pw_uid) {
#line 1061
      f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
    }
#line 1063
    if (f) {
#line 1065
      while (1) {
#line 1065
        tmp___0 = fgets((char * __restrict  )(buf___2), (int )sizeof(buf___2), (FILE * __restrict  )f);
#line 1065
        if (! tmp___0) {
#line 1065
          break;
        }
#line 1066
        fputs((char const   * __restrict  )(buf___2), (FILE * __restrict  )stderr);
      }
#line 1067
      fclose(f);
#line 1068
      exit(254);
    }
  }
#line 1076
  if (! options.use_login) {
#line 1085
    tmp___6 = getuid();
#line 1085
    if (tmp___6 == 0U) {
      goto _L;
    } else {
#line 1085
      tmp___7 = geteuid();
#line 1085
      if (tmp___7 == 0U) {
        _L: /* CIL Label */ 
#line 1103
        tmp___3 = setlogin((char const   *)pw->pw_name);
#line 1103
        if (tmp___3 < 0) {
#line 1104
          tmp___1 = __errno_location();
#line 1104
          tmp___2 = strerror(*tmp___1);
#line 1104
          error("setlogin failed: %s", tmp___2);
        }
#line 1105
        tmp___4 = setgid(pw->pw_gid);
#line 1105
        if (tmp___4 < 0) {
#line 1106
          perror("setgid");
#line 1107
          exit(1);
        }
#line 1110
        tmp___5 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 1110
        if (tmp___5 < 0) {
#line 1111
          perror("initgroups");
#line 1112
          exit(1);
        }
#line 1114
        endgrent();
#line 1177
        permanently_set_uid(pw);
      }
    }
#line 1185
    tmp___8 = getuid();
#line 1185
    if (tmp___8 != pw->pw_uid) {
#line 1186
      fatal("Failed to set uids to %u.", pw->pw_uid);
    } else {
#line 1185
      tmp___9 = geteuid();
#line 1185
      if (tmp___9 != pw->pw_uid) {
#line 1186
        fatal("Failed to set uids to %u.", pw->pw_uid);
      }
    }
  }
#line 1192
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1192
    shell = "/bin/sh";
  } else {
#line 1192
    shell = (char const   *)pw->pw_shell;
  }
#line 1198
  envsize = 100U;
#line 1199
  tmp___10 = xmalloc(envsize * sizeof(char *));
#line 1199
  env = (char **)tmp___10;
#line 1200
  *(env + 0) = (char *)((void *)0);
#line 1210
  if (! options.use_login) {
#line 1212
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 1213
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 1214
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 1226
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin");
#line 1230
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 1232
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___2));
#line 1235
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1237
  tmp___12 = getenv("TZ");
#line 1237
  if (tmp___12) {
#line 1238
    tmp___11 = getenv("TZ");
#line 1238
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___11);
  }
#line 1241
  while (custom_environment) {
#line 1242
    ce = custom_environment;
#line 1243
    s___0 = ce->s;
#line 1245
    i___0 = 0;
#line 1245
    while (1) {
#line 1245
      if ((int )*(s___0 + i___0) != 61) {
#line 1245
        if (! *(s___0 + i___0)) {
#line 1245
          break;
        }
      } else {
#line 1245
        break;
      }
#line 1245
      i___0 ++;
    }
#line 1246
    if ((int )*(s___0 + i___0) == 61) {
#line 1247
      *(s___0 + i___0) = (char)0;
#line 1248
      child_set_env(& env, & envsize, (char const   *)s___0, (char const   *)((s___0 + i___0) + 1));
    }
#line 1250
    custom_environment = ce->next;
#line 1251
    xfree((void *)ce->s);
#line 1252
    xfree((void *)ce);
  }
#line 1255
  tmp___13 = get_local_port();
#line 1255
  tmp___14 = get_remote_port();
#line 1255
  tmp___15 = get_remote_ipaddr();
#line 1255
  snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.50s %d %d",
           tmp___15, tmp___14, tmp___13);
#line 1257
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___2));
#line 1259
  if (s->ttyfd != -1) {
#line 1260
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
  }
#line 1261
  if (s->term) {
#line 1262
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
  }
#line 1263
  if (s->display) {
#line 1264
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
  }
#line 1265
  if (original_command) {
#line 1266
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", original_command);
  }
#line 1291
  tmp___17 = auth_get_socket_name();
#line 1291
  if ((unsigned int )tmp___17 != (unsigned int )((void *)0)) {
#line 1292
    tmp___16 = auth_get_socket_name();
#line 1292
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___16);
  }
#line 1296
  if (! options.use_login) {
#line 1297
    snprintf((char * __restrict  )(buf___2), sizeof(buf___2), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 1299
    read_environment_file(& env, & envsize, (char const   *)(buf___2));
  }
#line 1301
  if (debug_flag) {
#line 1303
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1304
    i = 0U;
#line 1304
    while (*(env + i)) {
#line 1305
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1304
      i ++;
    }
  }
#line 1308
  if (options.use_login) {
#line 1309
    hostname = get_remote_name_or_ip(utmp_len, options.reverse_mapping_check);
  }
#line 1318
  tmp___21 = packet_get_connection_in();
#line 1318
  tmp___22 = packet_get_connection_out();
#line 1318
  if (tmp___21 == tmp___22) {
#line 1319
    tmp___18 = packet_get_connection_in();
#line 1319
    close(tmp___18);
  } else {
#line 1321
    tmp___19 = packet_get_connection_in();
#line 1321
    close(tmp___19);
#line 1322
    tmp___20 = packet_get_connection_out();
#line 1322
    close(tmp___20);
  }
#line 1329
  channel_close_all();
#line 1335
  endpwent();
#line 1343
  i = 3U;
#line 1343
  while (i < 64U) {
#line 1344
    close((int )i);
#line 1343
    i ++;
  }
#line 1347
  tmp___25 = chdir((char const   *)pw->pw_dir);
#line 1347
  if (tmp___25 < 0) {
#line 1348
    tmp___23 = __errno_location();
#line 1348
    tmp___24 = strerror(*tmp___23);
#line 1348
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___24);
  }
#line 1360
  environ = env;
#line 1378
  if (! options.use_login) {
#line 1380
    if (! s->is_subsystem) {
#line 1380
      tmp___29 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1380
      if (tmp___29 >= 0) {
#line 1381
        snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -c \'%s %s\'",
                 shell, "/bin/sh", ".ssh/rc");
#line 1383
        if (debug_flag) {
#line 1384
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s\n",
                  cmd);
        }
#line 1385
        f = popen((char const   *)(cmd), "w");
#line 1386
        if (f) {
#line 1387
          if (do_xauth) {
#line 1388
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    s->auth_proto, s->auth_data);
          }
#line 1390
          pclose(f);
        } else {
#line 1392
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  ".ssh/rc");
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1394
      tmp___28 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1394
      if (tmp___28 >= 0) {
#line 1395
        if (debug_flag) {
#line 1396
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                  "/bin/sh", "/usr/local/etc/sshrc");
        }
#line 1398
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1399
        if (f) {
#line 1400
          if (do_xauth) {
#line 1401
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    s->auth_proto, s->auth_data);
          }
#line 1403
          pclose(f);
        } else {
#line 1405
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1407
        if (do_xauth) {
#line 1407
          if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1409
            tmp___27 = __builtin_strchr(s->display, ':');
#line 1409
            screen = tmp___27;
#line 1411
            if (debug_flag) {
#line 1412
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      options.xauth_location, s->display, s->auth_proto, s->auth_data);
#line 1417
              if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1418
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Adding %.*s/unix%s %s %s\n",
                        screen - s->display, s->display, screen, s->auth_proto, s->auth_data);
              }
            }
#line 1424
            snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                     options.xauth_location);
#line 1426
            f = popen((char const   *)(cmd), "w");
#line 1427
            if (f) {
#line 1428
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      s->display, s->auth_proto, s->auth_data);
#line 1430
              if ((unsigned int )screen != (unsigned int )((void *)0)) {
#line 1431
                fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %.*s/unix%s %s %s\n",
                        screen - s->display, s->display, screen, s->auth_proto, s->auth_data);
              }
#line 1436
              pclose(f);
            } else {
#line 1438
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                      cmd);
            }
          }
        }
      }
    }
#line 1443
    tmp___30 = strrchr(shell, '/');
#line 1443
    cp = (char const   *)tmp___30;
#line 1444
    if (cp) {
#line 1445
      cp ++;
    } else {
#line 1447
      cp = shell;
    }
  }
#line 1451
  signal(13, (void (*)(int  ))0);
#line 1458
  if (! command) {
#line 1459
    if (! options.use_login) {
#line 1463
      buf___3[0] = (char )'-';
#line 1464
      __builtin_strncpy(buf___3 + 1, cp, sizeof(buf___3) - 1U);
#line 1465
      buf___3[sizeof(buf___3) - 1U] = (char)0;
#line 1468
      argv[0] = buf___3;
#line 1469
      argv[1] = (char *)((void *)0);
#line 1470
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1473
      perror(shell);
#line 1474
      exit(1);
    } else {
#line 1479
      execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name,
            (char *)((void *)0));
#line 1487
      perror("login");
#line 1488
      exit(1);
    }
  }
#line 1495
  argv[0] = (char *)cp;
#line 1496
  argv[1] = (char *)"-c";
#line 1497
  argv[2] = (char *)command;
#line 1498
  argv[3] = (char *)((void *)0);
#line 1499
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1500
  perror(shell);
#line 1501
  exit(1);
}
}
#line 1508 "session.c"
static int did_init___0  =    0;
#line 1504 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1509
  if (! did_init___0) {
#line 1510
    debug("session_new: init");
#line 1511
    i = 0;
#line 1511
    while (i < 10) {
#line 1512
      sessions[i].used = 0;
#line 1511
      i ++;
    }
#line 1514
    did_init___0 = 1;
  }
#line 1516
  i = 0;
#line 1516
  while (i < 10) {
#line 1517
    s = & sessions[i];
#line 1518
    if (! s->used) {
#line 1519
      memset((void *)s, 0, sizeof(*s));
#line 1520
      s->chanid = -1;
#line 1521
      s->ptyfd = -1;
#line 1522
      s->ttyfd = -1;
#line 1523
      s->used = 1;
#line 1524
      s->self = i;
#line 1525
      debug("session_new: session %d", i);
#line 1526
      return (s);
    }
#line 1516
    i ++;
  }
#line 1529
  return ((Session *)((void *)0));
}
}
#line 1532 "session.c"
static void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1536
  i = 0;
#line 1536
  while (i < 10) {
#line 1537
    s = & sessions[i];
#line 1538
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1536
    i ++;
  }
#line 1545
  return;
}
}
#line 1547 "session.c"
int session_open(Authctxt *authctxt , int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1550
  tmp = session_new();
#line 1550
  s = tmp;
#line 1551
  debug("session_open: channel %d", chanid);
#line 1552
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1553
    error("no more sessions");
#line 1554
    return (0);
  }
#line 1556
  s->authctxt = authctxt;
#line 1557
  s->pw = authctxt->pw;
#line 1558
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1559
    fatal("no user for session %d", s->self);
  }
#line 1560
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1561
  s->chanid = chanid;
#line 1562
  return (1);
}
}
#line 1565 "session.c"
static Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1569
  i = 0;
#line 1569
  while (i < 10) {
#line 1570
    s = & sessions[i];
#line 1571
    if (s->used) {
#line 1571
      if (s->chanid == id) {
#line 1572
        debug("session_by_channel: session %d channel %d", i, id);
#line 1573
        return (s);
      }
    }
#line 1569
    i ++;
  }
#line 1576
  debug("session_by_channel: unknown channel %d", id);
#line 1577
  session_dump();
#line 1578
  return ((Session *)((void *)0));
}
}
#line 1581 "session.c"
static Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1585
  debug("session_by_pid: pid %d", pid);
#line 1586
  i = 0;
#line 1586
  while (i < 10) {
#line 1587
    s = & sessions[i];
#line 1588
    if (s->used) {
#line 1588
      if (s->pid == pid) {
#line 1589
        return (s);
      }
    }
#line 1586
    i ++;
  }
#line 1591
  error("session_by_pid: unknown pid %d", pid);
#line 1592
  session_dump();
#line 1593
  return ((Session *)((void *)0));
}
}
#line 1596 "session.c"
static int session_window_change_req(Session *s ) 
{ u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1599
  tmp = packet_get_int();
#line 1599
  s->col = (int )tmp;
#line 1600
  tmp___0 = packet_get_int();
#line 1600
  s->row = (int )tmp___0;
#line 1601
  tmp___1 = packet_get_int();
#line 1601
  s->xpixel = (int )tmp___1;
#line 1602
  tmp___2 = packet_get_int();
#line 1602
  s->ypixel = (int )tmp___2;
#line 1603
  while (1) {
#line 1603
    tmp___3 = packet_remaining();
#line 1603
    _len = tmp___3;
#line 1603
    if (_len > 0) {
#line 1603
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1603);
#line 1603
      packet_disconnect("Packet integrity error.");
    }
#line 1603
    break;
  }
#line 1604
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1605
  return (1);
}
}
#line 1608 "session.c"
static int session_pty_req(Session *s ) 
{ u_int len ;
  int n_bytes ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int _len ;
  int tmp___16 ;

  {
#line 1614
  if (no_pty_flag) {
#line 1615
    debug("Allocating a pty not permitted for this authentication.");
#line 1616
    return (0);
  }
#line 1618
  if (s->ttyfd != -1) {
#line 1619
    packet_disconnect("Protocol error: you already have a pty.");
#line 1620
    return (0);
  }
#line 1623
  s->term = packet_get_string(& len);
#line 1625
  if (compat20) {
#line 1626
    tmp = packet_get_int();
#line 1626
    s->col = (int )tmp;
#line 1627
    tmp___0 = packet_get_int();
#line 1627
    s->row = (int )tmp___0;
  } else {
#line 1629
    tmp___1 = packet_get_int();
#line 1629
    s->row = (int )tmp___1;
#line 1630
    tmp___2 = packet_get_int();
#line 1630
    s->col = (int )tmp___2;
  }
#line 1632
  tmp___3 = packet_get_int();
#line 1632
  s->xpixel = (int )tmp___3;
#line 1633
  tmp___4 = packet_get_int();
#line 1633
  s->ypixel = (int )tmp___4;
#line 1635
  if (0) {
#line 1635
    __s1_len = strlen((char const   *)s->term);
#line 1635
    __s2_len = strlen("");
#line 1635
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1635
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1635
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1635
          tmp___14 = 1;
        } else {
#line 1635
          if (__s2_len >= 4U) {
#line 1635
            tmp___14 = 1;
          } else {
#line 1635
            tmp___14 = 0;
          }
        }
      } else {
#line 1635
        tmp___14 = 0;
      }
    }
#line 1635
    if (tmp___14) {
#line 1635
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1635
      tmp___13 = __builtin_strcmp((char const   *)s->term, "");
#line 1635
      tmp___10 = tmp___13;
    }
  } else {
#line 1635
    tmp___13 = __builtin_strcmp((char const   *)s->term, "");
#line 1635
    tmp___10 = tmp___13;
  }
#line 1635
  if (tmp___10 == 0) {
#line 1636
    xfree((void *)s->term);
#line 1637
    s->term = (char *)((void *)0);
  }
#line 1641
  debug("Allocating pty.");
#line 1642
  tmp___15 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1642
  if (! tmp___15) {
#line 1643
    if (s->term) {
#line 1644
      xfree((void *)s->term);
    }
#line 1645
    s->term = (char *)((void *)0);
#line 1646
    s->ptyfd = -1;
#line 1647
    s->ttyfd = -1;
#line 1648
    error("session_pty_req: session %d alloc failed", s->self);
#line 1649
    return (0);
  }
#line 1651
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1654
  if (! compat20) {
#line 1655
    n_bytes = packet_remaining();
  }
#line 1656
  tty_parse_modes(s->ttyfd, & n_bytes);
#line 1662
  fatal_add_cleanup(& session_pty_cleanup, (void *)s);
#line 1663
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1666
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1668
  while (1) {
#line 1668
    tmp___16 = packet_remaining();
#line 1668
    _len = tmp___16;
#line 1668
    if (_len > 0) {
#line 1668
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1668);
#line 1668
      packet_disconnect("Packet integrity error.");
    }
#line 1668
    break;
  }
#line 1669
  session_proctitle(s);
#line 1670
  return (1);
}
}
#line 1673 "session.c"
static int session_subsystem_req(Session *s ) 
{ u_int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int i ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1677
  success = 0;
#line 1678
  tmp = packet_get_string(& len);
#line 1678
  subsys = tmp;
#line 1681
  while (1) {
#line 1681
    tmp___0 = packet_remaining();
#line 1681
    _len = tmp___0;
#line 1681
    if (_len > 0) {
#line 1681
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1681);
#line 1681
      packet_disconnect("Packet integrity error.");
    }
#line 1681
    break;
  }
#line 1682
  log("subsystem request for %s", subsys);
#line 1684
  i = 0;
#line 1684
  while ((u_int )i < options.num_subsystems) {
#line 1685
    if (0) {
#line 1685
      __s1_len = strlen((char const   *)subsys);
#line 1685
      __s2_len = strlen((char const   *)options.subsystem_name[i]);
#line 1685
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___0;
      } else {
#line 1685
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1685
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1685
            tmp___10 = 1;
          } else {
#line 1685
            if (__s2_len >= 4U) {
#line 1685
              tmp___10 = 1;
            } else {
#line 1685
              tmp___10 = 0;
            }
          }
        } else {
#line 1685
          tmp___10 = 0;
        }
      }
#line 1685
      if (tmp___10) {
#line 1685
        tmp___6 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1685
        tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1685
        tmp___6 = tmp___9;
      }
    } else {
#line 1685
      tmp___9 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1685
      tmp___6 = tmp___9;
    }
#line 1685
    if (tmp___6 == 0) {
#line 1686
      debug("subsystem: exec() %s", options.subsystem_command[i]);
#line 1687
      s->is_subsystem = 1;
#line 1688
      do_exec(s, (char const   *)options.subsystem_command[i]);
#line 1689
      success = 1;
    }
#line 1684
    i ++;
  }
#line 1693
  if (! success) {
#line 1694
    log("subsystem request for %s failed, subsystem not found", subsys);
  }
#line 1696
  xfree((void *)subsys);
#line 1697
  return (success);
}
}
#line 1700 "session.c"
static int session_x11_req(Session *s ) 
{ int success ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1705
  tmp = packet_get_char();
#line 1705
  s->single_connection = (int )tmp;
#line 1706
  s->auth_proto = packet_get_string((u_int *)((void *)0));
#line 1707
  s->auth_data = packet_get_string((u_int *)((void *)0));
#line 1708
  tmp___0 = packet_get_int();
#line 1708
  s->screen = (int )tmp___0;
#line 1709
  while (1) {
#line 1709
    tmp___1 = packet_remaining();
#line 1709
    _len = tmp___1;
#line 1709
    if (_len > 0) {
#line 1709
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1709);
#line 1709
      packet_disconnect("Packet integrity error.");
    }
#line 1709
    break;
  }
#line 1711
  success = session_setup_x11fwd(s);
#line 1712
  if (! success) {
#line 1713
    xfree((void *)s->auth_proto);
#line 1714
    xfree((void *)s->auth_data);
#line 1715
    s->auth_proto = (char *)((void *)0);
#line 1716
    s->auth_data = (char *)((void *)0);
  }
#line 1718
  return (success);
}
}
#line 1721 "session.c"
static int session_shell_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1724
  while (1) {
#line 1724
    tmp = packet_remaining();
#line 1724
    _len = tmp;
#line 1724
    if (_len > 0) {
#line 1724
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1724);
#line 1724
      packet_disconnect("Packet integrity error.");
    }
#line 1724
    break;
  }
#line 1725
  do_exec(s, (char const   *)((void *)0));
#line 1726
  return (1);
}
}
#line 1729 "session.c"
static int session_exec_req(Session *s ) 
{ u_int len ;
  char *command ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1733
  tmp = packet_get_string(& len);
#line 1733
  command = tmp;
#line 1734
  while (1) {
#line 1734
    tmp___0 = packet_remaining();
#line 1734
    _len = tmp___0;
#line 1734
    if (_len > 0) {
#line 1734
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1734);
#line 1734
      packet_disconnect("Packet integrity error.");
    }
#line 1734
    break;
  }
#line 1735
  do_exec(s, (char const   *)command);
#line 1736
  xfree((void *)command);
#line 1737
  return (1);
}
}
#line 1743
static int session_auth_agent_req(Session *s ) ;
#line 1743 "session.c"
static int called___2  =    0;
#line 1740 "session.c"
static int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1744
  while (1) {
#line 1744
    tmp = packet_remaining();
#line 1744
    _len = tmp;
#line 1744
    if (_len > 0) {
#line 1744
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1744);
#line 1744
      packet_disconnect("Packet integrity error.");
    }
#line 1744
    break;
  }
#line 1745
  if (no_agent_forwarding_flag) {
#line 1746
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 1747
    return (0);
  }
#line 1749
  if (called___2) {
#line 1750
    return (0);
  } else {
#line 1752
    called___2 = 1;
#line 1753
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 1753
    return (tmp___0);
  }
}
}
#line 1757 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ u_int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  u_int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___65 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
#line 1762
  success = 0;
#line 1767
  rtype = packet_get_string(& len);
#line 1768
  tmp = packet_get_char();
#line 1768
  reply = (int )tmp;
#line 1770
  s = session_by_channel(id);
#line 1771
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1772
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1773
  c = channel_lookup(id);
#line 1774
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1775
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1777
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1784
  if (c->type == 10) {
#line 1785
    if (0) {
#line 1785
      __s1_len___4 = strlen((char const   *)rtype);
#line 1785
      __s2_len___4 = strlen("shell");
#line 1785
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___10;
      } else {
#line 1785
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 1785
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1785
            tmp___59 = 1;
          } else {
#line 1785
            if (__s2_len___4 >= 4U) {
#line 1785
              tmp___59 = 1;
            } else {
#line 1785
              tmp___59 = 0;
            }
          }
        } else {
#line 1785
          tmp___59 = 0;
        }
      }
#line 1785
      if (tmp___59) {
#line 1785
        tmp___55 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1785
        tmp___58 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1785
        tmp___55 = tmp___58;
      }
    } else {
#line 1785
      tmp___58 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1785
      tmp___55 = tmp___58;
    }
#line 1785
    if (tmp___55 == 0) {
#line 1786
      success = session_shell_req(s);
    } else {
#line 1787
      if (0) {
#line 1787
        __s1_len___3 = strlen((char const   *)rtype);
#line 1787
        __s2_len___3 = strlen("exec");
#line 1787
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___8;
        } else {
#line 1787
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 1787
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1787
              tmp___49 = 1;
            } else {
#line 1787
              if (__s2_len___3 >= 4U) {
#line 1787
                tmp___49 = 1;
              } else {
#line 1787
                tmp___49 = 0;
              }
            }
          } else {
#line 1787
            tmp___49 = 0;
          }
        }
#line 1787
        if (tmp___49) {
#line 1787
          tmp___45 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1787
          tmp___48 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1787
          tmp___45 = tmp___48;
        }
      } else {
#line 1787
        tmp___48 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1787
        tmp___45 = tmp___48;
      }
#line 1787
      if (tmp___45 == 0) {
#line 1788
        success = session_exec_req(s);
      } else {
#line 1789
        if (0) {
#line 1789
          __s1_len___2 = strlen((char const   *)rtype);
#line 1789
          __s2_len___2 = strlen("pty-req");
#line 1789
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___6;
          } else {
#line 1789
            if (__s1_len___2 >= 4U) {
              _L___6: /* CIL Label */ 
#line 1789
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1789
                tmp___39 = 1;
              } else {
#line 1789
                if (__s2_len___2 >= 4U) {
#line 1789
                  tmp___39 = 1;
                } else {
#line 1789
                  tmp___39 = 0;
                }
              }
            } else {
#line 1789
              tmp___39 = 0;
            }
          }
#line 1789
          if (tmp___39) {
#line 1789
            tmp___35 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1789
            tmp___38 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1789
            tmp___35 = tmp___38;
          }
        } else {
#line 1789
          tmp___38 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1789
          tmp___35 = tmp___38;
        }
#line 1789
        if (tmp___35 == 0) {
#line 1790
          success = session_pty_req(s);
        } else {
#line 1791
          if (0) {
#line 1791
            __s1_len___1 = strlen((char const   *)rtype);
#line 1791
            __s2_len___1 = strlen("x11-req");
#line 1791
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___4;
            } else {
#line 1791
              if (__s1_len___1 >= 4U) {
                _L___4: /* CIL Label */ 
#line 1791
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1791
                  tmp___29 = 1;
                } else {
#line 1791
                  if (__s2_len___1 >= 4U) {
#line 1791
                    tmp___29 = 1;
                  } else {
#line 1791
                    tmp___29 = 0;
                  }
                }
              } else {
#line 1791
                tmp___29 = 0;
              }
            }
#line 1791
            if (tmp___29) {
#line 1791
              tmp___25 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1791
              tmp___28 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1791
              tmp___25 = tmp___28;
            }
          } else {
#line 1791
            tmp___28 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1791
            tmp___25 = tmp___28;
          }
#line 1791
          if (tmp___25 == 0) {
#line 1792
            success = session_x11_req(s);
          } else {
#line 1793
            if (0) {
#line 1793
              __s1_len___0 = strlen((char const   *)rtype);
#line 1793
              __s2_len___0 = strlen("auth-agent-req@openssh.com");
#line 1793
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___2;
              } else {
#line 1793
                if (__s1_len___0 >= 4U) {
                  _L___2: /* CIL Label */ 
#line 1793
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 1793
                    tmp___19 = 1;
                  } else {
#line 1793
                    if (__s2_len___0 >= 4U) {
#line 1793
                      tmp___19 = 1;
                    } else {
#line 1793
                      tmp___19 = 0;
                    }
                  }
                } else {
#line 1793
                  tmp___19 = 0;
                }
              }
#line 1793
              if (tmp___19) {
#line 1793
                tmp___15 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
              } else {
#line 1793
                tmp___18 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
#line 1793
                tmp___15 = tmp___18;
              }
            } else {
#line 1793
              tmp___18 = __builtin_strcmp((char const   *)rtype, "auth-agent-req@openssh.com");
#line 1793
              tmp___15 = tmp___18;
            }
#line 1793
            if (tmp___15 == 0) {
#line 1794
              success = session_auth_agent_req(s);
            } else {
#line 1795
              if (0) {
#line 1795
                __s1_len = strlen((char const   *)rtype);
#line 1795
                __s2_len = strlen("subsystem");
#line 1795
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___0;
                } else {
#line 1795
                  if (__s1_len >= 4U) {
                    _L___0: /* CIL Label */ 
#line 1795
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1795
                      tmp___9 = 1;
                    } else {
#line 1795
                      if (__s2_len >= 4U) {
#line 1795
                        tmp___9 = 1;
                      } else {
#line 1795
                        tmp___9 = 0;
                      }
                    }
                  } else {
#line 1795
                    tmp___9 = 0;
                  }
                }
#line 1795
                if (tmp___9) {
#line 1795
                  tmp___5 = __builtin_strcmp((char const   *)rtype, "subsystem");
                } else {
#line 1795
                  tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1795
                  tmp___5 = tmp___8;
                }
              } else {
#line 1795
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1795
                tmp___5 = tmp___8;
              }
#line 1795
              if (tmp___5 == 0) {
#line 1796
                success = session_subsystem_req(s);
              }
            }
          }
        }
      }
    }
  }
#line 1799
  if (0) {
#line 1799
    __s1_len___5 = strlen((char const   *)rtype);
#line 1799
    __s2_len___5 = strlen("window-change");
#line 1799
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___12;
    } else {
#line 1799
      if (__s1_len___5 >= 4U) {
        _L___12: /* CIL Label */ 
#line 1799
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1799
          tmp___69 = 1;
        } else {
#line 1799
          if (__s2_len___5 >= 4U) {
#line 1799
            tmp___69 = 1;
          } else {
#line 1799
            tmp___69 = 0;
          }
        }
      } else {
#line 1799
        tmp___69 = 0;
      }
    }
#line 1799
    if (tmp___69) {
#line 1799
      tmp___65 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1799
      tmp___68 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1799
      tmp___65 = tmp___68;
    }
  } else {
#line 1799
    tmp___68 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1799
    tmp___65 = tmp___68;
  }
#line 1799
  if (tmp___65 == 0) {
#line 1800
    success = session_window_change_req(s);
  }
#line 1803
  if (reply) {
#line 1804
    if (success) {
#line 1804
      tmp___70 = 99;
    } else {
#line 1804
      tmp___70 = 100;
    }
#line 1804
    packet_start((unsigned char )tmp___70);
#line 1806
    packet_put_int((unsigned int )c->remote_id);
#line 1807
    packet_send();
  }
#line 1809
  xfree((void *)rtype);
#line 1810
  return;
}
}
#line 1812 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1815
  if (! compat20) {
#line 1816
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1821
  if (s->chanid == -1) {
#line 1822
    fatal("no channel for session %d", s->self);
  }
#line 1823
  if (fderr___0 == -1) {
#line 1823
    tmp = 0;
  } else {
#line 1823
    tmp = 1;
  }
#line 1823
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1);
#line 1827
  return;
}
}
#line 1833 "session.c"
static void session_pty_cleanup(void *session ) 
{ Session *s ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1836
  s = (Session *)session;
#line 1838
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1839
    error("session_pty_cleanup: no session");
#line 1840
    return;
  }
#line 1842
  if (s->ttyfd == -1) {
#line 1843
    return;
  }
#line 1845
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 1848
  if (s->pid != 0) {
#line 1849
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 1852
  pty_release((char const   *)(s->tty));
#line 1859
  tmp___1 = close(s->ptymaster);
#line 1859
  if (tmp___1 < 0) {
#line 1860
    tmp = __errno_location();
#line 1860
    tmp___0 = strerror(*tmp);
#line 1860
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1861
  return;
}
}
#line 1863 "session.c"
static void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_71 __constr_expr_0 ;
  union __anonunion_72 __constr_expr_1 ;
  union __anonunion_73 __constr_expr_2 ;
  union __anonunion_74 __constr_expr_3 ;
  union __anonunion_75 __constr_expr_4 ;

  {
#line 1867
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1868
    fatal("session_close: no session");
  }
#line 1869
  c = channel_lookup(s->chanid);
#line 1870
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1871
    fatal("session_exit_message: session %d: no channel %d", s->self, s->chanid);
  }
#line 1873
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1876
  __constr_expr_4.__in = status;
#line 1876
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1877
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1879
    __constr_expr_0.__in = status;
#line 1879
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1880
    packet_send();
  } else {
#line 1881
    __constr_expr_3.__in = status;
#line 1881
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1882
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1884
      __constr_expr_1.__in = status;
#line 1884
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1886
      __constr_expr_2.__in = status;
#line 1886
      packet_put_char(__constr_expr_2.__i & 128);
#line 1890
      packet_put_cstring("");
#line 1891
      packet_put_cstring("");
#line 1892
      packet_send();
    } else {
#line 1895
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1899
  debug("session_exit_message: release channel %d", s->chanid);
#line 1900
  channel_cancel_cleanup(s->chanid);
#line 1907
  if (c->ostate != 128) {
#line 1908
    (*chan_write_failed)(c);
  }
#line 1909
  s->chanid = -1;
#line 1910
  return;
}
}
#line 1912 "session.c"
static void session_close(Session *s ) 
{ 

  {
#line 1915
  debug("session_close: session %d pid %d", s->self, s->pid);
#line 1916
  if (s->ttyfd != -1) {
#line 1917
    fatal_remove_cleanup(& session_pty_cleanup, (void *)s);
#line 1918
    session_pty_cleanup((void *)s);
  }
#line 1920
  if (s->term) {
#line 1921
    xfree((void *)s->term);
  }
#line 1922
  if (s->display) {
#line 1923
    xfree((void *)s->display);
  }
#line 1924
  if (s->auth_data) {
#line 1925
    xfree((void *)s->auth_data);
  }
#line 1926
  if (s->auth_proto) {
#line 1927
    xfree((void *)s->auth_proto);
  }
#line 1928
  s->used = 0;
#line 1929
  session_proctitle(s);
#line 1930
  return;
}
}
#line 1932 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1935
  tmp = session_by_pid(pid);
#line 1935
  s = tmp;
#line 1936
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1937
    debug("session_close_by_pid: no session for pid %d", pid);
#line 1938
    return;
  }
#line 1940
  if (s->chanid != -1) {
#line 1941
    session_exit_message(s, status);
  }
#line 1942
  session_close(s);
#line 1943
  return;
}
}
#line 1945 "session.c"
int session_have_children(void) 
{ int i ;
  Session *s ;

  {
#line 1950
  i = 0;
#line 1950
  while (i < 10) {
#line 1951
    s = & sessions[i];
#line 1952
    if (s->used) {
#line 1952
      if (s->pid != -1) {
#line 1953
        debug("session_have_children: id %d pid %d", i, s->pid);
#line 1954
        return (1);
      }
    }
#line 1950
    i ++;
  }
#line 1957
  debug("session_have_children: no more children");
#line 1958
  return (0);
}
}
#line 1965 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1968
  tmp = session_by_channel(id);
#line 1968
  s = tmp;
#line 1969
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1970
    debug("session_close_by_channel: no session for channel %d", id);
#line 1971
    return;
  }
#line 1974
  channel_cancel_cleanup(s->chanid);
#line 1975
  s->chanid = -1;
#line 1977
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 1978
  if (s->pid == 0) {
#line 1980
    session_close(s);
  } else {
#line 1983
    if (s->ttyfd == -1) {
#line 1983
      tmp___2 = 15;
    } else {
#line 1983
      tmp___2 = 1;
    }
#line 1983
    tmp___3 = kill(s->pid, tmp___2);
#line 1983
    if (tmp___3 < 0) {
#line 1984
      tmp___0 = __errno_location();
#line 1984
      tmp___1 = strerror(*tmp___0);
#line 1984
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 1987
  return;
}
}
#line 1992 "session.c"
static char buf___1[1024]  ;
#line 1989 "session.c"
static char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1994
  buf___1[0] = (char )'\000';
#line 1995
  i = 0;
#line 1995
  while (i < 10) {
#line 1996
    s = & sessions[i];
#line 1997
    if (s->used) {
#line 1997
      if (s->ttyfd != -1) {
#line 1998
        if ((int )buf___1[0] != 0) {
#line 1999
          strlcat(buf___1, ",", sizeof(buf___1));
        }
#line 2000
        tmp = strrchr((char const   *)(s->tty), '/');
#line 2000
        strlcat(buf___1, (char const   *)(tmp + 1), sizeof(buf___1));
      }
    }
#line 1995
    i ++;
  }
#line 2003
  if ((int )buf___1[0] == 0) {
#line 2004
    strlcpy(buf___1, "notty", sizeof(buf___1));
  }
#line 2005
  return (buf___1);
}
}
#line 2008 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 2011
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 2012
    error("no user for session %d", s->self);
  } else {
#line 2014
    tmp = session_tty_list();
#line 2014
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 2015
  return;
}
}
#line 2017 "session.c"
int session_setup_x11fwd(Session *s ) 
{ struct stat st ;
  int tmp ;

  {
#line 2022
  if (no_x11_forwarding_flag) {
#line 2023
    packet_send_debug("X11 forwarding disabled in user configuration file.");
#line 2024
    return (0);
  }
#line 2026
  if (! options.x11_forwarding) {
#line 2027
    debug("X11 forwarding disabled in server configuration file.");
#line 2028
    return (0);
  }
#line 2030
  if (! options.xauth_location) {
#line 2032
    packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2033
    return (0);
  } else {
#line 2030
    tmp = stat((char const   * __restrict  )options.xauth_location, (struct stat * __restrict  )(& st));
#line 2030
    if (tmp == -1) {
#line 2032
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2033
      return (0);
    }
  }
#line 2035
  if (options.use_login) {
#line 2036
    packet_send_debug("X11 forwarding disabled; not compatible with UseLogin=yes.");
#line 2038
    return (0);
  }
#line 2040
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 2041
    debug("X11 display already set.");
#line 2042
    return (0);
  }
#line 2044
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 2045
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 2046
    debug("x11_create_display_inet failed.");
#line 2047
    return (0);
  }
#line 2049
  return (1);
}
}
#line 2052 "session.c"
static void do_authenticated2(Authctxt *authctxt ) 
{ 

  {
#line 2055
  server_loop2(authctxt);
#line 2056
  return;
}
}
#line 1 "groupaccess.o"
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 34 "groupaccess.c"
static int ngroups  ;
#line 35 "groupaccess.c"
static char *groups_byname[65537]  ;
#line 41 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t groups_bygid[65537] ;
  int i ;
  int j ;
  struct group *gr ;
  int tmp ;
  int tmp___0 ;

  {
#line 48
  if (ngroups > 0) {
#line 49
    ga_free();
  }
#line 51
  ngroups = (int )(sizeof(groups_bygid) / sizeof(gid_t ));
#line 52
  tmp = getgrouplist(user, base, groups_bygid, & ngroups);
#line 52
  if (tmp == -1) {
#line 53
    log("getgrouplist: groups list too small");
  }
#line 54
  i = 0;
#line 54
  j = 0;
#line 54
  while (i < ngroups) {
#line 55
    gr = getgrgid(groups_bygid[i]);
#line 55
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 56
      tmp___0 = j;
#line 56
      j ++;
#line 56
      groups_byname[tmp___0] = xstrdup((char const   *)gr->gr_name);
    }
#line 54
    i ++;
  }
#line 57
  ngroups = j;
#line 57
  return (ngroups);
}
}
#line 64 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 69
  i = 0;
#line 69
  while (i < ngroups) {
#line 70
    j = 0;
#line 70
    while (j < n___0) {
#line 71
      tmp = match_pattern((char const   *)groups_byname[i], (char const   *)*(groups + j));
#line 71
      if (tmp) {
#line 72
        return (1);
      }
#line 70
      j ++;
    }
#line 69
    i ++;
  }
#line 73
  return (0);
}
}
#line 79 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 84
  if (ngroups > 0) {
#line 85
    i = 0;
#line 85
    while (i < ngroups) {
#line 86
      xfree((void *)groups_byname[i]);
#line 85
      i ++;
    }
#line 87
    ngroups = 0;
  }
#line 89
  return;
}
}
#line 1 "auth-skey.o"
#line 1 "auth-bsdauth.o"
