/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_62 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_62 cb ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 21 "buffer.h"
struct __anonstruct_Buffer_74 {
   char *buf ;
   unsigned int alloc ;
   unsigned int offset ;
   unsigned int end ;
};
#line 21 "buffer.h"
typedef struct __anonstruct_Buffer_74 Buffer;
#line 34 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer packet ;
   Buffer identities ;
   int howmany ;
};
#line 34 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 281 "/usr/include/openssl/crypto.h"
struct bio_st;
#line 256 "/usr/include/openssl/bio.h"
typedef struct bio_st BIO;
#line 258 "/usr/include/openssl/bio.h"
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
#line 261 "/usr/include/openssl/bio.h"
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
#line 261 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 290 "/usr/include/openssl/bio.h"
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_64 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_64 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 78 "/usr/include/openssl/des.h"
typedef unsigned char DES_cblock[8];
#line 83 "/usr/include/openssl/des.h"
union __anonunion_ks_73 {
   DES_cblock cblock ;
   unsigned long deslong[2] ;
};
#line 83 "/usr/include/openssl/des.h"
struct DES_ks {
   union __anonunion_ks_73 ks[16] ;
};
#line 83 "/usr/include/openssl/des.h"
typedef struct DES_ks DES_key_schedule;
#line 101 "/usr/include/openssl/blowfish.h"
struct bf_key_st {
   unsigned int P[18] ;
   unsigned int S[1024] ;
};
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 80 "/usr/include/openssl/cast.h"
struct cast_key_st {
   unsigned long data[32] ;
   int short_key ;
};
#line 80 "/usr/include/openssl/cast.h"
typedef struct cast_key_st CAST_KEY;
#line 42 "cipher.h"
struct __anonstruct_des3_77 {
   DES_key_schedule key1 ;
   DES_key_schedule key2 ;
   DES_cblock iv2 ;
   DES_key_schedule key3 ;
   DES_cblock iv3 ;
};
#line 42 "cipher.h"
struct __anonstruct_bf_78 {
   struct bf_key_st key ;
   unsigned char iv[8] ;
};
#line 42 "cipher.h"
struct __anonstruct_cast_79 {
   CAST_KEY key ;
   unsigned char iv[8] ;
};
#line 42 "cipher.h"
union __anonunion_u_76 {
   struct __anonstruct_des3_77 des3 ;
   struct __anonstruct_bf_78 bf ;
   struct __anonstruct_cast_79 cast ;
   RC4_KEY rc4 ;
};
#line 42 "cipher.h"
struct __anonstruct_CipherContext_75 {
   unsigned int type ;
   union __anonunion_u_76 u ;
};
#line 42 "cipher.h"
typedef struct __anonstruct_CipherContext_75 CipherContext;
#line 4 "key.h"
struct Key;
#line 4 "key.h"
typedef struct Key Key;
#line 10 "key.h"
struct Key {
   int type ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_21 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_21 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 54 "bsd-misc.c"
struct __anonstruct_rc4_t_74 {
   unsigned int s[256] ;
   int i ;
   int j ;
};
#line 54 "bsd-misc.c"
typedef struct __anonstruct_rc4_t_74 rc4_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 314 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 24 "channels.h"
typedef void channel_callback_fn(int id , void *arg );
#line 26 "channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   int istate ;
   int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[200] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   int remote_window ;
   int remote_maxpacket ;
   int local_window ;
   int local_window_max ;
   int local_consumed ;
   int local_maxpacket ;
   int extended_usage ;
   char *ctype ;
   channel_callback_fn *cb_fn ;
   void *cb_arg ;
   int cb_event ;
   channel_callback_fn *dettach_user ;
};
#line 26 "channels.h"
typedef struct Channel Channel;
#line 80 "nchan.h"
typedef void chan_event_fn(Channel *c );
#line 92 "channels.c"
struct __anonstruct_ForwardPermission_79 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 92 "channels.c"
typedef struct __anonstruct_ForwardPermission_79 ForwardPermission;
#line 328 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 79 "/usr/include/openssl/des.h"
typedef unsigned char const_DES_cblock[8];
#line 101 "/usr/include/openssl/blowfish.h"
typedef struct bf_key_st BF_KEY;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 89 "cipher.c"
union __anonunion_t_74 {
   u_int32_t i ;
   char c[4] ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 6 "dispatch.h"
typedef void dispatch_fn(int type , int plen );
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 10 "hostfile.h"
enum __anonenum_HostStatus_74 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2
} ;
#line 10 "hostfile.h"
typedef enum __anonenum_HostStatus_74 HostStatus;
#line 122 "/usr/include/openssl/ossl_typ.h"
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 55 "kex.h"
struct Kex;
#line 55 "kex.h"
typedef struct Kex Kex;
#line 56
struct Mac;
#line 56 "kex.h"
typedef struct Mac Mac;
#line 57
struct Comp;
#line 57 "kex.h"
typedef struct Comp Comp;
#line 58
struct Enc;
#line 58 "kex.h"
typedef struct Enc Enc;
#line 60 "kex.h"
struct Enc {
   int type ;
   int enabled ;
   int block_size ;
   unsigned char *key ;
   unsigned char *iv ;
   int key_len ;
   int iv_len ;
   char *name ;
};
#line 70 "kex.h"
struct Mac {
   EVP_MD *md ;
   int enabled ;
   int mac_len ;
   unsigned char *key ;
   int key_len ;
   char *name ;
};
#line 78 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 83 "kex.h"
struct Kex {
   Enc enc[2] ;
   Mac mac[2] ;
   Comp comp[2] ;
   int we_need ;
   int server ;
   char *name ;
   char *hostkeyalg ;
};
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 428 "ssh.h"
enum __anonenum_SyslogFacility_72 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_LOCAL0 = 3,
    SYSLOG_FACILITY_LOCAL1 = 4,
    SYSLOG_FACILITY_LOCAL2 = 5,
    SYSLOG_FACILITY_LOCAL3 = 6,
    SYSLOG_FACILITY_LOCAL4 = 7,
    SYSLOG_FACILITY_LOCAL5 = 8,
    SYSLOG_FACILITY_LOCAL6 = 9,
    SYSLOG_FACILITY_LOCAL7 = 10
} ;
#line 428 "ssh.h"
typedef enum __anonenum_SyslogFacility_72 SyslogFacility;
#line 442
enum __anonenum_LogLevel_73 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG = 5
} ;
#line 442 "ssh.h"
typedef enum __anonenum_LogLevel_73 LogLevel;
#line 69 "log.c"
struct fatal_cleanup {
   struct fatal_cleanup *next ;
   void (*proc)(void * ) ;
   void *context ;
};
#line 132 "log.c"
struct __anonstruct_log_facilities_74 {
   char const   *name ;
   SyslogFacility val ;
};
#line 150 "log.c"
struct __anonstruct_log_levels_75 {
   char const   *name ;
   LogLevel val ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_24 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_27 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_28 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_22 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_23 _kill ;
   struct __anonstruct__timer_24 _timer ;
   struct __anonstruct__rt_25 _rt ;
   struct __anonstruct__sigchld_26 _sigchld ;
   struct __anonstruct__sigfault_27 _sigfault ;
   struct __anonstruct__sigpoll_28 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_22 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_40 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_40 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 28 "servconf.h"
struct __anonstruct_ServerOptions_74 {
   unsigned int num_ports ;
   unsigned int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   char *host_key_file ;
   char *host_dsa_key_file ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int check_mail ;
   int x11_forwarding ;
   int x11_display_offset ;
   int strict_modes ;
   int keepalives ;
   char *ciphers ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_authentication ;
   int rhosts_rsa_authentication ;
   int rsa_authentication ;
   int dsa_authentication ;
   int password_authentication ;
   int permit_empty_passwd ;
   int use_login ;
   unsigned int num_allow_users ;
   char *allow_users[256] ;
   unsigned int num_deny_users ;
   char *deny_users[256] ;
   unsigned int num_allow_groups ;
   char *allow_groups[256] ;
   unsigned int num_deny_groups ;
   char *deny_groups[256] ;
};
#line 28 "servconf.h"
typedef struct __anonstruct_ServerOptions_74 ServerOptions;
#line 115 "sshd.c"
struct __anonstruct_sensitive_data_76 {
   RSA *private_key ;
   RSA *host_key ;
   Key *dsa_host_key ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 78 "auth2.c"
struct Authctxt;
#line 78 "auth2.c"
typedef struct Authctxt Authctxt;
#line 79 "auth2.c"
struct Authctxt {
   char *user ;
   char *service ;
   struct passwd pw ;
   int valid ;
};
#line 18 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 18 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 244 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 276 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 28 "auth-pam.c"
struct pam_handle_t;
#line 502 "ssh.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 161 "servconf.c"
enum __anonenum_ServerOpCodes_75 {
    sBadOption = 0,
    sPort = 1,
    sHostKeyFile = 2,
    sServerKeyBits = 3,
    sLoginGraceTime = 4,
    sKeyRegenerationTime = 5,
    sPermitRootLogin = 6,
    sLogFacility = 7,
    sLogLevel = 8,
    sRhostsAuthentication = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sPasswordAuthentication = 12,
    sListenAddress = 13,
    sPrintMotd = 14,
    sIgnoreRhosts = 15,
    sX11Forwarding = 16,
    sX11DisplayOffset = 17,
    sStrictModes = 18,
    sEmptyPasswd = 19,
    sRandomSeedFile = 20,
    sKeepAlives = 21,
    sCheckMail = 22,
    sUseLogin = 23,
    sAllowUsers = 24,
    sDenyUsers = 25,
    sAllowGroups = 26,
    sDenyGroups = 27,
    sIgnoreUserKnownHosts = 28,
    sHostDSAKeyFile = 29,
    sCiphers = 30,
    sProtocol = 31,
    sPidFile = 32,
    sGatewayPorts = 33,
    sDSAAuthentication = 34
} ;
#line 161 "servconf.c"
typedef enum __anonenum_ServerOpCodes_75 ServerOpCodes;
#line 184 "servconf.c"
struct __anonstruct_keywords_76 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_43 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_44 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_43 __wait_terminated ;
   struct __anonstruct___wait_stopped_44 __wait_stopped ;
};
#line 74 "serverloop.c"
union __anonunion_77 {
   int volatile   __in ;
   int __i ;
};
#line 74 "serverloop.c"
union __anonunion_78 {
   int volatile   __in ;
   int __i ;
};
#line 577 "serverloop.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 579 "serverloop.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 575 "serverloop.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 601 "serverloop.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 600 "serverloop.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 33 "session.c"
struct Session;
#line 33 "session.c"
typedef struct Session Session;
#line 34 "session.c"
struct Session {
   int used ;
   int self ;
   int extended ;
   struct passwd *pw ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   int row ;
   int col ;
   int xpixel ;
   int ypixel ;
   char tty[64] ;
   char *display ;
   int screen ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
};
#line 1457 "session.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 1462 "session.c"
union __anonunion_77___0 {
   int __in ;
   int __i ;
};
#line 1463 "session.c"
union __anonunion_78___0 {
   int __in ;
   int __i ;
};
#line 1459 "session.c"
union __anonunion_79___0 {
   int __in ;
   int __i ;
};
#line 1454 "session.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 1 "atomicio.o"
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 510 "ssh.h"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) ;
#line 35 "atomicio.c"
ssize_t atomicio(ssize_t (*f)() , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  ssize_t res ;
  ssize_t pos ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 42
  s = (char *)_s;
#line 43
  pos = 0;
#line 45
  while (n___0 > (size_t )pos) {
#line 46
    res = (*f)(fd, s + pos, n___0 - (size_t )pos);
#line 47
    switch (res) {
    case -1: 
#line 49
    tmp = __errno_location();
#line 49
    if (*tmp == 4) {
#line 50
      continue;
    } else {
#line 49
      tmp___0 = __errno_location();
#line 49
      if (*tmp___0 == 11) {
#line 50
        continue;
      }
    }
    case 0: 
#line 52
    return (res);
    default: 
#line 54
    pos += res;
    }
  }
#line 57
  return (pos);
}
}
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 660 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 7 "bsd-strlcpy.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 461 "ssh.h"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) ;
#line 462
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 463
void ( /* format attribute */  log)(char const   *fmt  , ...) ;
#line 28 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 31
void buffer_free(Buffer *buffer ) ;
#line 35
void buffer_clear(Buffer *buffer ) ;
#line 38
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) ;
#line 48
unsigned int buffer_len(Buffer *buffer ) ;
#line 51
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) ;
#line 60
char *buffer_ptr(Buffer *buffer ) ;
#line 41 "authfd.h"
int ssh_get_authentication_socket(void) ;
#line 48
void ssh_close_authentication_socket(int sock ) ;
#line 56
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 62
void ssh_close_authentication_connection(AuthenticationConnection *ac ) ;
#line 70
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) ;
#line 80
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) ;
#line 86
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) ;
#line 98
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) ;
#line 107
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) ;
#line 114
int ssh_remove_all_identities(AuthenticationConnection *auth ) ;
#line 25 "bufaux.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 29
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 33
unsigned int buffer_get_int(Buffer *buffer ) ;
#line 36
void buffer_put_int(Buffer *buffer , unsigned int value ) ;
#line 39
int buffer_get_char(Buffer *buffer ) ;
#line 42
void buffer_put_char(Buffer *buffer , int value ) ;
#line 52
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) ;
#line 55
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) ;
#line 23 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 29
void xfree(void *ptr ) ;
#line 31 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 38
  tmp = getenv("SSH_AUTH_SOCK");
#line 38
  authsocket = (char const   *)tmp;
#line 39
  if (! authsocket) {
#line 40
    return (-1);
  }
#line 42
  sunaddr.sun_family = (unsigned short)1;
#line 43
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 45
  sock = socket(1, 1, 0);
#line 46
  if (sock < 0) {
#line 47
    return (-1);
  }
#line 50
  tmp___0 = fcntl(sock, 2, 1);
#line 50
  if (tmp___0 == -1) {
#line 51
    close(sock);
#line 52
    return (-1);
  }
#line 54
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 54
  if (tmp___1 < 0) {
#line 55
    close(sock);
#line 56
    return (-1);
  }
#line 58
  return (sock);
}
}
#line 67 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 70
  tmp = getenv("SSH_AUTH_SOCK");
#line 70
  if (tmp) {
#line 71
    close(sock);
  }
#line 72
  return;
}
}
#line 82 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 88
  sock = ssh_get_authentication_socket();
#line 94
  if (sock < 0) {
#line 95
    return ((AuthenticationConnection *)((void *)0));
  }
#line 97
  tmp = xmalloc(sizeof(*auth));
#line 97
  auth = (AuthenticationConnection *)tmp;
#line 98
  auth->fd = sock;
#line 99
  buffer_init(& auth->packet);
#line 100
  buffer_init(& auth->identities);
#line 101
  auth->howmany = 0;
#line 103
  return (auth);
}
}
#line 111 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *ac ) 
{ 

  {
#line 114
  buffer_free(& ac->packet);
#line 115
  buffer_free(& ac->identities);
#line 116
  close(ac->fd);
#line 117
  xfree((void *)ac);
#line 118
  return;
}
}
#line 127 "authfd.c"
int ssh_get_first_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                           char **comment ) 
{ unsigned char msg[8192] ;
  int len ;
  int l ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 138
  msg[0] = (unsigned char)0;
#line 139
  msg[1] = (unsigned char)0;
#line 140
  msg[2] = (unsigned char)0;
#line 141
  msg[3] = (unsigned char)1;
#line 142
  msg[4] = (unsigned char)1;
#line 143
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(msg), 5U);
#line 143
  if (tmp___1 != 5) {
#line 144
    tmp = __errno_location();
#line 144
    tmp___0 = strerror(*tmp);
#line 144
    error("write auth->fd: %.100s", tmp___0);
#line 145
    return (0);
  }
#line 148
  len = 4;
#line 149
  while (len > 0) {
#line 150
    l = read(auth->fd, (void *)((msg + 4) - len), (unsigned int )len);
#line 151
    if (l <= 0) {
#line 152
      tmp___2 = __errno_location();
#line 152
      tmp___3 = strerror(*tmp___2);
#line 152
      error("read auth->fd: %.100s", tmp___3);
#line 153
      return (0);
    }
#line 155
    len -= l;
  }
#line 162
  len = (int )(((((unsigned long )msg[0] << 24) | ((unsigned long )msg[1] << 16)) | ((unsigned long )msg[2] << 8)) | (unsigned long )msg[3]);
#line 163
  if (len < 1) {
#line 164
    fatal("Authentication reply message too long: %d\n", len);
  } else {
#line 163
    if (len > 262144) {
#line 164
      fatal("Authentication reply message too long: %d\n", len);
    }
  }
#line 167
  buffer_clear(& auth->identities);
#line 168
  while (len > 0) {
#line 169
    l = len;
#line 170
    if ((unsigned int )l > sizeof(msg)) {
#line 171
      l = (int )sizeof(msg);
    }
#line 172
    l = read(auth->fd, (void *)(msg), (unsigned int )l);
#line 173
    if (l <= 0) {
#line 174
      fatal("Incomplete authentication reply.");
    }
#line 175
    buffer_append(& auth->identities, (char const   *)((char *)(msg)), (unsigned int )l);
#line 176
    len -= l;
  }
#line 180
  buffer_get(& auth->identities, (char *)(msg), 1U);
#line 181
  if ((int )msg[0] != 2) {
#line 182
    fatal("Bad authentication reply message type: %d", msg[0]);
  }
#line 185
  tmp___4 = buffer_get_int(& auth->identities);
#line 185
  auth->howmany = (int )tmp___4;
#line 186
  if (auth->howmany > 1024) {
#line 187
    fatal("Too many identities in authentication reply: %d\n", auth->howmany);
  }
#line 190
  tmp___5 = ssh_get_next_identity(auth, e, n___0, comment);
#line 190
  return (tmp___5);
}
}
#line 200 "authfd.c"
int ssh_get_next_identity(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          char **comment ) 
{ unsigned int bits ;
  int tmp ;
  int tmp___0 ;

  {
#line 207
  if (auth->howmany <= 0) {
#line 208
    return (0);
  }
#line 214
  bits = buffer_get_int(& auth->identities);
#line 215
  buffer_get_bignum(& auth->identities, e);
#line 216
  buffer_get_bignum(& auth->identities, n___0);
#line 217
  *comment = buffer_get_string(& auth->identities, (unsigned int *)((void *)0));
#line 219
  tmp___0 = BN_num_bits((BIGNUM const   *)n___0);
#line 219
  if (bits != (unsigned int )tmp___0) {
#line 220
    tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 220
    log("Warning: identity keysize mismatch: actual %d, announced %u", tmp, bits);
  }
#line 224
  (auth->howmany) --;
#line 226
  return (1);
}
}
#line 237 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , BIGNUM *e , BIGNUM *n___0 ,
                          BIGNUM *challenge , unsigned char *session_id___0 , unsigned int response_type ,
                          unsigned char *response ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 249
  if (response_type == 0U) {
#line 250
    fatal("Compatibility with ssh protocol version 1.0 no longer supported.");
  }
#line 253
  buf___1[0] = (unsigned char)3;
#line 254
  buffer_init(& buffer);
#line 255
  buffer_append(& buffer, (char const   *)((char *)(buf___1)), 1U);
#line 256
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 256
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 257
  buffer_put_bignum(& buffer, e);
#line 258
  buffer_put_bignum(& buffer, n___0);
#line 259
  buffer_put_bignum(& buffer, challenge);
#line 260
  buffer_append(& buffer, (char const   *)((char *)session_id___0), 16U);
#line 261
  buffer_put_int(& buffer, response_type);
#line 264
  tmp___0 = buffer_len(& buffer);
#line 264
  len = (int )tmp___0;
#line 265
  while (1) {
#line 265
    buf___1[0] = (unsigned char )(len >> 24);
#line 265
    buf___1[1] = (unsigned char )(len >> 16);
#line 265
    buf___1[2] = (unsigned char )(len >> 8);
#line 265
    buf___1[3] = (unsigned char )len;
#line 265
    break;
  }
#line 268
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 268
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 268
    tmp___2 = buffer_len(& buffer);
#line 268
    tmp___3 = buffer_ptr(& buffer);
#line 268
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 268
    tmp___5 = buffer_len(& buffer);
#line 268
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 271
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 273
      buffer_free(& buffer);
#line 274
      return (0);
    }
  }
#line 280
  len = 4;
#line 281
  while (len > 0) {
#line 282
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 283
    if (l <= 0) {
#line 284
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 287
    len -= l;
  }
#line 291
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 292
  if (len > 262144) {
#line 293
    fatal("Authentication response too long: %d", len);
  }
#line 296
  buffer_clear(& buffer);
#line 297
  while (len > 0) {
#line 298
    l = len;
#line 299
    if ((unsigned int )l > sizeof(buf___1)) {
#line 300
      l = (int )sizeof(buf___1);
    }
#line 301
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 302
    if (l <= 0) {
#line 303
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 306
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 307
    len -= l;
  }
#line 311
  buffer_get(& buffer, (char *)(buf___1), 1U);
#line 314
  if ((int )buf___1[0] == 5) {
#line 315
    log("Agent admitted failure to authenticate using the key.");
    goto error_cleanup;
  }
#line 319
  if ((int )buf___1[0] != 4) {
#line 320
    fatal("Bad authentication response: %d", buf___1[0]);
  }
#line 326
  i = 0;
#line 326
  while (i < 16) {
#line 327
    tmp___6 = buffer_get_char(& buffer);
#line 327
    *(response + i) = (unsigned char )tmp___6;
#line 326
    i ++;
  }
#line 330
  buffer_free(& buffer);
#line 333
  return (1);
}
}
#line 341 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , RSA *key , char const   *comment ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 350
  buffer_init(& buffer);
#line 351
  buffer_put_char(& buffer, 7);
#line 352
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 352
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 353
  buffer_put_bignum(& buffer, key->n);
#line 354
  buffer_put_bignum(& buffer, key->e);
#line 355
  buffer_put_bignum(& buffer, key->d);
#line 357
  buffer_put_bignum(& buffer, key->iqmp);
#line 358
  buffer_put_bignum(& buffer, key->q);
#line 359
  buffer_put_bignum(& buffer, key->p);
#line 360
  tmp___0 = strlen(comment);
#line 360
  buffer_put_string(& buffer, (void const   *)comment, tmp___0);
#line 363
  tmp___1 = buffer_len(& buffer);
#line 363
  len = (int )tmp___1;
#line 364
  while (1) {
#line 364
    buf___1[0] = (unsigned char )(len >> 24);
#line 364
    buf___1[1] = (unsigned char )(len >> 16);
#line 364
    buf___1[2] = (unsigned char )(len >> 8);
#line 364
    buf___1[3] = (unsigned char )len;
#line 364
    break;
  }
#line 367
  tmp___2 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 367
  if (tmp___2 != 4) {
    goto _L;
  } else {
#line 367
    tmp___3 = buffer_len(& buffer);
#line 367
    tmp___4 = buffer_ptr(& buffer);
#line 367
    tmp___5 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___4, tmp___3);
#line 367
    tmp___6 = buffer_len(& buffer);
#line 367
    if ((unsigned int )tmp___5 != tmp___6) {
      _L: /* CIL Label */ 
#line 370
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 372
      buffer_free(& buffer);
#line 373
      return (0);
    }
  }
#line 377
  len = 4;
#line 378
  while (len > 0) {
#line 379
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 380
    if (l <= 0) {
#line 381
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 384
    len -= l;
  }
#line 388
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 389
  if (len > 262144) {
#line 390
    fatal("Add identity response too long: %d", len);
  }
#line 393
  buffer_clear(& buffer);
#line 394
  while (len > 0) {
#line 395
    l = len;
#line 396
    if ((unsigned int )l > sizeof(buf___1)) {
#line 397
      l = (int )sizeof(buf___1);
    }
#line 398
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 399
    if (l <= 0) {
#line 400
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 403
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 404
    len -= l;
  }
#line 408
  type = buffer_get_char(& buffer);
#line 409
  switch (type) {
  case 5: 
#line 411
  buffer_free(& buffer);
#line 412
  return (0);
  case 6: 
#line 414
  buffer_free(& buffer);
#line 415
  return (1);
  default: 
#line 417
  fatal("Bad response to add identity from authentication agent: %d", type);
  }
#line 421
  return (0);
}
}
#line 429 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , RSA *key ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int type ;
  int tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 437
  buffer_init(& buffer);
#line 438
  buffer_put_char(& buffer, 8);
#line 439
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 439
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 440
  buffer_put_bignum(& buffer, key->e);
#line 441
  buffer_put_bignum(& buffer, key->n);
#line 444
  tmp___0 = buffer_len(& buffer);
#line 444
  len = (int )tmp___0;
#line 445
  while (1) {
#line 445
    buf___1[0] = (unsigned char )(len >> 24);
#line 445
    buf___1[1] = (unsigned char )(len >> 16);
#line 445
    buf___1[2] = (unsigned char )(len >> 8);
#line 445
    buf___1[3] = (unsigned char )len;
#line 445
    break;
  }
#line 448
  tmp___1 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 4U);
#line 448
  if (tmp___1 != 4) {
    goto _L;
  } else {
#line 448
    tmp___2 = buffer_len(& buffer);
#line 448
    tmp___3 = buffer_ptr(& buffer);
#line 448
    tmp___4 = atomicio((ssize_t (*)())(& write), auth->fd, (void *)tmp___3, tmp___2);
#line 448
    tmp___5 = buffer_len(& buffer);
#line 448
    if ((unsigned int )tmp___4 != tmp___5) {
      _L: /* CIL Label */ 
#line 451
      error("Error writing to authentication socket.");
      error_cleanup: 
#line 453
      buffer_free(& buffer);
#line 454
      return (0);
    }
  }
#line 460
  len = 4;
#line 461
  while (len > 0) {
#line 462
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 463
    if (l <= 0) {
#line 464
      error("Error reading response length from authentication socket.");
      goto error_cleanup;
    }
#line 467
    len -= l;
  }
#line 471
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 472
  if (len > 262144) {
#line 473
    fatal("Remove identity response too long: %d", len);
  }
#line 476
  buffer_clear(& buffer);
#line 477
  while (len > 0) {
#line 478
    l = len;
#line 479
    if ((unsigned int )l > sizeof(buf___1)) {
#line 480
      l = (int )sizeof(buf___1);
    }
#line 481
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 482
    if (l <= 0) {
#line 483
      error("Error reading response from authentication socket.");
      goto error_cleanup;
    }
#line 486
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 487
    len -= l;
  }
#line 491
  type = buffer_get_char(& buffer);
#line 492
  switch (type) {
  case 5: 
#line 494
  buffer_free(& buffer);
#line 495
  return (0);
  case 6: 
#line 497
  buffer_free(& buffer);
#line 498
  return (1);
  default: 
#line 500
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 504
  return (0);
}
}
#line 512 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth ) 
{ Buffer buffer ;
  unsigned char buf___1[8192] ;
  int len ;
  int l ;
  int type ;
  ssize_t tmp ;

  {
#line 520
  while (1) {
#line 520
    buf___1[0] = (unsigned char )(1 >> 24);
#line 520
    buf___1[1] = (unsigned char )(1 >> 16);
#line 520
    buf___1[2] = (unsigned char )(1 >> 8);
#line 520
    buf___1[3] = (unsigned char)1;
#line 520
    break;
  }
#line 521
  buf___1[4] = (unsigned char)9;
#line 524
  tmp = atomicio((ssize_t (*)())(& write), auth->fd, (void *)(buf___1), 5U);
#line 524
  if (tmp != 5) {
#line 525
    error("Error writing to authentication socket.");
#line 526
    return (0);
  }
#line 532
  len = 4;
#line 533
  while (len > 0) {
#line 534
    l = read(auth->fd, (void *)((buf___1 + 4) - len), (unsigned int )len);
#line 535
    if (l <= 0) {
#line 536
      error("Error reading response length from authentication socket.");
#line 537
      return (0);
    }
#line 539
    len -= l;
  }
#line 543
  len = (int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]);
#line 544
  if (len > 262144) {
#line 545
    fatal("Remove identity response too long: %d", len);
  }
#line 548
  buffer_init(& buffer);
#line 549
  while (len > 0) {
#line 550
    l = len;
#line 551
    if ((unsigned int )l > sizeof(buf___1)) {
#line 552
      l = (int )sizeof(buf___1);
    }
#line 553
    l = read(auth->fd, (void *)(buf___1), (unsigned int )l);
#line 554
    if (l <= 0) {
#line 555
      error("Error reading response from authentication socket.");
#line 556
      buffer_free(& buffer);
#line 557
      return (0);
    }
#line 559
    buffer_append(& buffer, (char const   *)((char *)(buf___1)), (unsigned int )l);
#line 560
    len -= l;
  }
#line 564
  type = buffer_get_char(& buffer);
#line 565
  switch (type) {
  case 5: 
#line 567
  buffer_free(& buffer);
#line 568
  return (0);
  case 6: 
#line 570
  buffer_free(& buffer);
#line 571
  return (1);
  default: 
#line 573
  fatal("Bad response to remove identity from authentication agent: %d", type);
  }
#line 577
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "authfile.o"
#line 212 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 380
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 154 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 36 "bsd-misc.h"
unsigned int arc4random(void) ;
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 393
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 560 "/usr/include/openssl/bio.h"
extern BIO_METHOD *BIO_s_file(void) ;
#line 568
extern BIO *BIO_new(BIO_METHOD *type ) ;
#line 570
extern int BIO_free(BIO *a ) ;
#line 577
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
#line 192 "/usr/include/openssl/dsa.h"
extern void DSA_free(DSA *r ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 625 "/usr/include/openssl/pem.h"
extern DSA *PEM_read_bio_DSAPrivateKey(BIO *bp , DSA **x , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 32 "xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 45 "buffer.h"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) ;
#line 69 "cipher.h"
unsigned int cipher_mask1(void) ;
#line 73
char const   *cipher_name(int cipher ) ;
#line 100
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) ;
#line 105
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 110
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) ;
#line 465 "ssh.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 43 "authfile.c"
int save_private_key_rsa(char const   *filename , char const   *passphrase , RSA *key ,
                         char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  char buf___1[100] ;
  char *cp ;
  int fd ;
  int i ;
  CipherContext cipher ;
  int cipher_type___0 ;
  u_int32_t rand___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  unsigned int tmp___17 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  unsigned int tmp___20 ;

  {
#line 58
  if (0) {
#line 58
    __s1_len = strlen(passphrase);
#line 58
    __s2_len = strlen("");
#line 58
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___0;
    } else {
#line 58
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 58
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 58
          tmp___8 = 1;
        } else {
#line 58
          if (__s2_len >= 4U) {
#line 58
            tmp___8 = 1;
          } else {
#line 58
            tmp___8 = 0;
          }
        }
      } else {
#line 58
        tmp___8 = 0;
      }
    }
#line 58
    if (tmp___8) {
#line 58
      tmp___4 = __builtin_strcmp(passphrase, "");
    } else {
#line 58
      tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
      tmp___4 = tmp___7;
    }
  } else {
#line 58
    tmp___7 = __builtin_strcmp(passphrase, "");
#line 58
    tmp___4 = tmp___7;
  }
#line 58
  if (tmp___4 == 0) {
#line 59
    cipher_type___0 = 0;
  } else {
#line 61
    cipher_type___0 = 3;
  }
#line 64
  buffer_init(& buffer);
#line 67
  rand___0 = arc4random();
#line 68
  buf___1[0] = (char )(rand___0 & 255U);
#line 69
  buf___1[1] = (char )((rand___0 >> 8) & 255U);
#line 70
  buf___1[2] = buf___1[0];
#line 71
  buf___1[3] = buf___1[1];
#line 72
  buffer_append(& buffer, (char const   *)(buf___1), 4U);
#line 79
  buffer_put_bignum(& buffer, key->d);
#line 80
  buffer_put_bignum(& buffer, key->iqmp);
#line 81
  buffer_put_bignum(& buffer, key->q);
#line 82
  buffer_put_bignum(& buffer, key->p);
#line 85
  while (1) {
#line 85
    tmp___9 = buffer_len(& buffer);
#line 85
    if (! (tmp___9 % 8U != 0U)) {
#line 85
      break;
    }
#line 86
    buffer_put_char(& buffer, 0);
  }
#line 89
  buffer_init(& encrypted);
#line 92
  cp = (char *)"SSH PRIVATE KEY FILE FORMAT 1.1\n";
#line 93
  i = 0;
#line 93
  while (*(cp + i)) {
#line 94
    buffer_put_char(& encrypted, (int )*(cp + i));
#line 93
    i ++;
  }
#line 95
  buffer_put_char(& encrypted, 0);
#line 98
  buffer_put_char(& encrypted, cipher_type___0);
#line 99
  buffer_put_int(& encrypted, 0U);
#line 102
  tmp___10 = BN_num_bits((BIGNUM const   *)key->n);
#line 102
  buffer_put_int(& encrypted, (unsigned int )tmp___10);
#line 103
  buffer_put_bignum(& encrypted, key->n);
#line 104
  buffer_put_bignum(& encrypted, key->e);
#line 105
  tmp___11 = strlen(comment);
#line 105
  buffer_put_string(& encrypted, (void const   *)comment, tmp___11);
#line 108
  tmp___12 = buffer_len(& buffer);
#line 108
  buffer_append_space(& encrypted, & cp, tmp___12);
#line 110
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 111
  tmp___13 = buffer_len(& buffer);
#line 111
  tmp___14 = buffer_ptr(& buffer);
#line 111
  cipher_encrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___14),
                 tmp___13);
#line 114
  memset((void *)(& cipher), 0, sizeof(cipher));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  buffer_free(& buffer);
#line 120
  fd = open(filename, 577, 384);
#line 121
  if (fd < 0) {
#line 122
    return (0);
  }
#line 123
  tmp___17 = buffer_len(& encrypted);
#line 123
  tmp___18 = buffer_ptr(& encrypted);
#line 123
  tmp___19 = write(fd, (void const   *)tmp___18, tmp___17);
#line 123
  tmp___20 = buffer_len(& encrypted);
#line 123
  if ((unsigned int )tmp___19 != tmp___20) {
#line 125
    tmp___15 = __errno_location();
#line 125
    tmp___16 = strerror(*tmp___15);
#line 125
    debug("Write to key file %.200s failed: %.100s", filename, tmp___16);
#line 127
    buffer_free(& encrypted);
#line 128
    close(fd);
#line 129
    remove(filename);
#line 130
    return (0);
  }
#line 132
  close(fd);
#line 133
  buffer_free(& encrypted);
#line 134
  return (1);
}
}
#line 139 "authfile.c"
int save_private_key_dsa(char const   *filename , char const   *passphrase , DSA *dsa ,
                         char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 145
  success = 1;
#line 146
  tmp = strlen(passphrase);
#line 146
  len = (int )tmp;
#line 148
  if (len > 0) {
#line 148
    if (len <= 4) {
#line 149
      error("passphrase too short: %d bytes", len);
#line 150
      tmp___0 = __errno_location();
#line 150
      *tmp___0 = 0;
#line 151
      return (0);
    }
  }
#line 153
  fd = open(filename, 577, 384);
#line 154
  if (fd < 0) {
#line 155
    debug("open %s failed", filename);
#line 156
    return (0);
  }
#line 158
  fp = fdopen(fd, "w");
#line 159
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 160
    debug("fdopen %s failed", filename);
#line 161
    close(fd);
#line 162
    return (0);
  }
#line 164
  if (len > 0) {
#line 165
    tmp___1 = strlen(passphrase);
#line 165
    tmp___2 = EVP_des_ede3_cbc();
#line 165
    tmp___3 = PEM_write_DSAPrivateKey(fp, dsa, tmp___2, (unsigned char *)((char *)passphrase),
                                      (int )tmp___1, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 165
    if (! tmp___3) {
#line 167
      success = 0;
    }
  } else {
#line 169
    tmp___4 = PEM_write_DSAPrivateKey(fp, dsa, (EVP_CIPHER const   *)((void *)0),
                                      (unsigned char *)((void *)0), 0, (pem_password_cb *)((void *)0),
                                      (void *)0);
#line 169
    if (! tmp___4) {
#line 171
      success = 0;
    }
  }
#line 173
  fclose(fp);
#line 174
  return (success);
}
}
#line 177 "authfile.c"
int save_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 181
  switch (key->type) {
  case 0: 
#line 183
  tmp = save_private_key_rsa(filename, passphrase, key->rsa, comment);
#line 183
  return (tmp);
#line 184
  break;
  case 1: 
#line 186
  tmp___0 = save_private_key_dsa(filename, passphrase, key->dsa, comment);
#line 186
  return (tmp___0);
#line 187
  break;
  default: ;
#line 189
  break;
  }
#line 191
  return (0);
}
}
#line 200 "authfile.c"
int load_public_key_rsa(char const   *filename , RSA *pub , char **comment_return ) 
{ int fd ;
  int i ;
  off_t len ;
  Buffer buffer ;
  char *cp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 208
  fd = open(filename, 0);
#line 209
  if (fd < 0) {
#line 210
    return (0);
  }
#line 211
  len = lseek(fd, 0L, 2);
#line 212
  lseek(fd, 0L, 0);
#line 214
  buffer_init(& buffer);
#line 215
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 217
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 217
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 218
    tmp = __errno_location();
#line 218
    tmp___0 = strerror(*tmp);
#line 218
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 220
    buffer_free(& buffer);
#line 221
    close(fd);
#line 222
    return (0);
  }
#line 224
  close(fd);
#line 227
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 227
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 228
    debug("Bad key file %.200s.", filename);
#line 229
    buffer_free(& buffer);
#line 230
    return (0);
  }
#line 236
  i = 0;
#line 236
  while (1) {
#line 236
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 236
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 236
      break;
    }
#line 237
    tmp___3 = buffer_get_char(& buffer);
#line 237
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 238
      debug("Bad key file %.200s.", filename);
#line 239
      buffer_free(& buffer);
#line 240
      return (0);
    }
#line 236
    i ++;
  }
#line 243
  buffer_get_char(& buffer);
#line 244
  buffer_get_int(& buffer);
#line 247
  buffer_get_int(& buffer);
#line 249
  if ((unsigned int )pub->n == (unsigned int )((void *)0)) {
#line 250
    pub->n = BN_new();
  }
#line 251
  buffer_get_bignum(& buffer, pub->n);
#line 253
  if ((unsigned int )pub->e == (unsigned int )((void *)0)) {
#line 254
    pub->e = BN_new();
  }
#line 255
  buffer_get_bignum(& buffer, pub->e);
#line 256
  if (comment_return) {
#line 257
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  }
#line 260
  buffer_free(& buffer);
#line 262
  return (1);
}
}
#line 265 "authfile.c"
int load_public_key(char const   *filename , Key *key , char **comment_return ) 
{ int tmp ;

  {
#line 268
  switch (key->type) {
  case 0: 
#line 270
  tmp = load_public_key_rsa(filename, key->rsa, comment_return);
#line 270
  return (tmp);
#line 271
  break;
  case 1: 
  default: ;
#line 274
  break;
  }
#line 276
  return (0);
}
}
#line 286 "authfile.c"
int load_private_key_rsa(int fd , char const   *filename , char const   *passphrase ,
                         RSA *prv , char **comment_return ) 
{ int i ;
  int check1 ;
  int check2 ;
  int cipher_type___0 ;
  off_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  char *cp ;
  CipherContext cipher ;
  BN_CTX *ctx ;
  BIGNUM *aux ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  BIGNUM const   *tmp___23 ;
  BIGNUM const   *tmp___24 ;

  {
#line 298
  len = lseek(fd, 0L, 2);
#line 299
  lseek(fd, 0L, 0);
#line 301
  buffer_init(& buffer);
#line 302
  buffer_append_space(& buffer, & cp, (unsigned int )len);
#line 304
  tmp___1 = read(fd, (void *)cp, (unsigned int )len);
#line 304
  if ((unsigned int )tmp___1 != (unsigned int )len) {
#line 305
    tmp = __errno_location();
#line 305
    tmp___0 = strerror(*tmp);
#line 305
    debug("Read from key file %.200s failed: %.100s", filename, tmp___0);
#line 307
    buffer_free(& buffer);
#line 308
    close(fd);
#line 309
    return (0);
  }
#line 311
  close(fd);
#line 314
  tmp___2 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 314
  if ((unsigned long )len < (unsigned long )(tmp___2 + 1U)) {
#line 315
    debug("Bad key file %.200s.", filename);
#line 316
    buffer_free(& buffer);
#line 317
    return (0);
  }
#line 323
  i = 0;
#line 323
  while (1) {
#line 323
    tmp___4 = strlen("SSH PRIVATE KEY FILE FORMAT 1.1\n");
#line 323
    if (! ((unsigned int )i < tmp___4 + 1U)) {
#line 323
      break;
    }
#line 324
    tmp___3 = buffer_get_char(& buffer);
#line 324
    if (tmp___3 != (int )((unsigned char )*("SSH PRIVATE KEY FILE FORMAT 1.1\n" + i))) {
#line 325
      debug("Bad key file %.200s.", filename);
#line 326
      buffer_free(& buffer);
#line 327
      return (0);
    }
#line 323
    i ++;
  }
#line 330
  cipher_type___0 = buffer_get_char(& buffer);
#line 331
  buffer_get_int(& buffer);
#line 334
  buffer_get_int(& buffer);
#line 335
  prv->n = BN_new();
#line 336
  buffer_get_bignum(& buffer, prv->n);
#line 337
  prv->e = BN_new();
#line 338
  buffer_get_bignum(& buffer, prv->e);
#line 339
  if (comment_return) {
#line 340
    *comment_return = buffer_get_string(& buffer, (unsigned int *)((void *)0));
  } else {
#line 342
    tmp___5 = buffer_get_string(& buffer, (unsigned int *)((void *)0));
#line 342
    xfree((void *)tmp___5);
  }
#line 345
  tmp___7 = cipher_mask1();
#line 345
  if (((tmp___7 | 3U) & (unsigned int )(1 << cipher_type___0)) == 0U) {
#line 347
    tmp___6 = cipher_name(cipher_type___0);
#line 347
    debug("Unsupported cipher %.100s used in key file %.200s.", tmp___6, filename);
#line 349
    buffer_free(& buffer);
    goto fail;
  }
#line 353
  buffer_init(& decrypted);
#line 354
  tmp___8 = buffer_len(& buffer);
#line 354
  buffer_append_space(& decrypted, & cp, tmp___8);
#line 357
  cipher_set_key_string(& cipher, cipher_type___0, passphrase);
#line 358
  tmp___9 = buffer_len(& buffer);
#line 358
  tmp___10 = buffer_ptr(& buffer);
#line 358
  cipher_decrypt(& cipher, (unsigned char *)cp, (unsigned char const   *)((unsigned char *)tmp___10),
                 tmp___9);
#line 362
  buffer_free(& buffer);
#line 364
  check1 = buffer_get_char(& decrypted);
#line 365
  check2 = buffer_get_char(& decrypted);
#line 366
  tmp___21 = buffer_get_char(& decrypted);
#line 366
  if (check1 != tmp___21) {
    goto _L___1;
  } else {
#line 366
    tmp___22 = buffer_get_char(& decrypted);
#line 366
    if (check2 != tmp___22) {
      _L___1: /* CIL Label */ 
#line 368
      if (0) {
#line 368
        __s1_len = strlen(passphrase);
#line 368
        __s2_len = strlen("");
#line 368
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 368
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 368
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 368
              tmp___20 = 1;
            } else {
#line 368
              if (__s2_len >= 4U) {
#line 368
                tmp___20 = 1;
              } else {
#line 368
                tmp___20 = 0;
              }
            }
          } else {
#line 368
            tmp___20 = 0;
          }
        }
#line 368
        if (tmp___20) {
#line 368
          tmp___16 = __builtin_strcmp(passphrase, "");
        } else {
#line 368
          tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
          tmp___16 = tmp___19;
        }
      } else {
#line 368
        tmp___19 = __builtin_strcmp(passphrase, "");
#line 368
        tmp___16 = tmp___19;
      }
#line 368
      if (tmp___16 != 0) {
#line 369
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 371
      buffer_free(& decrypted);
      fail: 
#line 373
      BN_clear_free(prv->n);
#line 374
      prv->n = (BIGNUM *)((void *)0);
#line 375
      BN_clear_free(prv->e);
#line 376
      prv->e = (BIGNUM *)((void *)0);
#line 377
      if (comment_return) {
#line 378
        xfree((void *)*comment_return);
      }
#line 379
      return (0);
    }
  }
#line 382
  prv->d = BN_new();
#line 383
  buffer_get_bignum(& decrypted, prv->d);
#line 384
  prv->iqmp = BN_new();
#line 385
  buffer_get_bignum(& decrypted, prv->iqmp);
#line 387
  prv->q = BN_new();
#line 388
  buffer_get_bignum(& decrypted, prv->q);
#line 389
  prv->p = BN_new();
#line 390
  buffer_get_bignum(& decrypted, prv->p);
#line 392
  ctx = BN_CTX_new();
#line 393
  aux = BN_new();
#line 395
  tmp___23 = BN_value_one();
#line 395
  BN_sub(aux, (BIGNUM const   *)prv->q, tmp___23);
#line 396
  prv->dmq1 = BN_new();
#line 397
  BN_div((BIGNUM *)((void *)0), prv->dmq1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 399
  tmp___24 = BN_value_one();
#line 399
  BN_sub(aux, (BIGNUM const   *)prv->p, tmp___24);
#line 400
  prv->dmp1 = BN_new();
#line 401
  BN_div((BIGNUM *)((void *)0), prv->dmp1, (BIGNUM const   *)prv->d, (BIGNUM const   *)aux,
         ctx);
#line 403
  BN_clear_free(aux);
#line 404
  BN_CTX_free(ctx);
#line 406
  buffer_free(& decrypted);
#line 408
  return (1);
}
}
#line 411 "authfile.c"
int load_private_key_dsa(int fd , char const   *passphrase , Key *k , char **comment_return ) 
{ DSA *dsa ;
  BIO *in ;
  FILE *fp ;
  BIO_METHOD *tmp ;
  int tmp___0 ;

  {
#line 418
  tmp = BIO_s_file();
#line 418
  in = BIO_new(tmp);
#line 419
  if ((unsigned int )in == (unsigned int )((void *)0)) {
#line 420
    error("BIO_new failed");
#line 421
    return (0);
  }
#line 423
  fp = fdopen(fd, "r");
#line 424
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 425
    error("fdopen failed");
#line 426
    return (0);
  }
#line 428
  BIO_ctrl(in, 106, 0L, (void *)((char *)fp));
#line 429
  dsa = PEM_read_bio_DSAPrivateKey(in, (DSA **)((void *)0), (pem_password_cb *)((void *)0),
                                   (void *)((char *)passphrase));
#line 430
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 431
    debug("PEM_read_bio_DSAPrivateKey failed");
  } else {
#line 434
    DSA_free(k->dsa);
#line 435
    k->dsa = dsa;
  }
#line 437
  BIO_free(in);
#line 438
  fclose(fp);
#line 439
  if (comment_return) {
#line 440
    *comment_return = xstrdup("dsa w/o comment");
  }
#line 441
  debug("read DSA private key done");
#line 445
  if ((unsigned int )dsa != (unsigned int )((void *)0)) {
#line 445
    tmp___0 = 1;
  } else {
#line 445
    tmp___0 = 0;
  }
#line 445
  return (tmp___0);
}
}
#line 448 "authfile.c"
int load_private_key(char const   *filename , char const   *passphrase , Key *key ,
                     char **comment_return ) 
{ int fd ;
  int ret ;
  struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 453
  ret = 0;
#line 456
  fd = open(filename, 0);
#line 457
  if (fd < 0) {
#line 458
    return (0);
  }
#line 461
  tmp = fstat(fd, & st);
#line 461
  if (tmp < 0) {
    goto _L;
  } else {
#line 461
    if (st.st_uid != 0U) {
#line 461
      tmp___0 = getuid();
#line 461
      if (st.st_uid != tmp___0) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 461
      if ((st.st_mode & 63U) != 0U) {
        _L: /* CIL Label */ 
#line 464
        close(fd);
#line 465
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 466
        error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 467
        error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 468
        error("Bad ownership or mode(0%3.3o) for \'%s\'.", st.st_mode & 511U, filename);
#line 470
        error("It is recommended that your private key files are NOT accessible by others.");
#line 471
        return (0);
      }
    }
  }
#line 473
  switch (key->type) {
  case 0: 
#line 475
  if ((unsigned int )(key->rsa)->e != (unsigned int )((void *)0)) {
#line 476
    BN_clear_free((key->rsa)->e);
#line 477
    (key->rsa)->e = (BIGNUM *)((void *)0);
  }
#line 479
  if ((unsigned int )(key->rsa)->n != (unsigned int )((void *)0)) {
#line 480
    BN_clear_free((key->rsa)->n);
#line 481
    (key->rsa)->n = (BIGNUM *)((void *)0);
  }
#line 483
  ret = load_private_key_rsa(fd, filename, passphrase, key->rsa, comment_return);
#line 485
  break;
  case 1: 
#line 487
  ret = load_private_key_dsa(fd, passphrase, key, comment_return);
  default: ;
#line 489
  break;
  }
#line 491
  close(fd);
#line 492
  return (ret);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "bsd-base64.o"
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 323 "/usr/include/resolv.h"
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 324
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 628 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 64 "bsd-base64.c"
static char const   Base64[65]  = 
#line 64 "bsd-base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 66 "bsd-base64.c"
static char const   Pad64  =    (char const   )'=';
#line 131
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 131 "bsd-base64.c"
int __b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 134
  datalength = (size_t )0;
#line 139
  while (2U < srclength) {
#line 140
    tmp = src;
#line 140
    src ++;
#line 140
    input___0[0] = (unsigned char )*tmp;
#line 141
    tmp___0 = src;
#line 141
    src ++;
#line 141
    input___0[1] = (unsigned char )*tmp___0;
#line 142
    tmp___1 = src;
#line 142
    src ++;
#line 142
    input___0[2] = (unsigned char )*tmp___1;
#line 143
    srclength -= 3U;
#line 145
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 146
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 147
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 148
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 149
    if (! ((int )output___0[0] < 64)) {
#line 149
      abort();
    }
#line 150
    if (! ((int )output___0[1] < 64)) {
#line 150
      abort();
    }
#line 151
    if (! ((int )output___0[2] < 64)) {
#line 151
      abort();
    }
#line 152
    if (! ((int )output___0[3] < 64)) {
#line 152
      abort();
    }
#line 154
    if (datalength + 4U > targsize) {
#line 155
      return (-1);
    }
#line 156
    tmp___2 = datalength;
#line 156
    datalength ++;
#line 156
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 157
    tmp___3 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 158
    tmp___4 = datalength;
#line 158
    datalength ++;
#line 158
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 159
    tmp___5 = datalength;
#line 159
    datalength ++;
#line 159
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 163
  if (0U != srclength) {
#line 165
    input___0[2] = (unsigned char )'\000';
#line 165
    input___0[1] = input___0[2];
#line 165
    input___0[0] = input___0[1];
#line 166
    i = 0;
#line 166
    while ((size_t )i < srclength) {
#line 167
      tmp___6 = src;
#line 167
      src ++;
#line 167
      input___0[i] = (unsigned char )*tmp___6;
#line 166
      i ++;
    }
#line 169
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 170
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 171
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 172
    if (! ((int )output___0[0] < 64)) {
#line 172
      abort();
    }
#line 173
    if (! ((int )output___0[1] < 64)) {
#line 173
      abort();
    }
#line 174
    if (! ((int )output___0[2] < 64)) {
#line 174
      abort();
    }
#line 176
    if (datalength + 4U > targsize) {
#line 177
      return (-1);
    }
#line 178
    tmp___7 = datalength;
#line 178
    datalength ++;
#line 178
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 179
    tmp___8 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 180
    if (srclength == 1U) {
#line 181
      tmp___9 = datalength;
#line 181
      datalength ++;
#line 181
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 183
      tmp___10 = datalength;
#line 183
      datalength ++;
#line 183
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 184
    tmp___11 = datalength;
#line 184
    datalength ++;
#line 184
    *(target + tmp___11) = (char )Pad64;
  }
#line 186
  if (datalength >= targsize) {
#line 187
    return (-1);
  }
#line 188
  *(target + datalength) = (char )'\000';
#line 189
  return ((int )datalength);
}
}
#line 198
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 198 "bsd-base64.c"
int __b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ int tarindex ;
  int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 204
  state = 0;
#line 205
  tarindex = 0;
#line 207
  while (1) {
#line 207
    tmp___2 = src;
#line 207
    src ++;
#line 207
    ch = (int )*tmp___2;
#line 207
    if (! (ch != 0)) {
#line 207
      break;
    }
#line 208
    tmp = __ctype_b_loc();
#line 208
    if ((int const   )*(*tmp + ch) & 8192) {
#line 209
      continue;
    }
#line 211
    if (ch == (int )Pad64) {
#line 212
      break;
    }
#line 214
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 214
    pos = tmp___1;
#line 215
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 216
      return (-1);
    }
#line 218
    switch (state) {
    case 0: 
#line 220
    if (target) {
#line 221
      if ((size_t )tarindex >= targsize) {
#line 222
        return (-1);
      }
#line 223
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 225
    state = 1;
#line 226
    break;
    case 1: 
#line 228
    if (target) {
#line 229
      if ((size_t )(tarindex + 1) >= targsize) {
#line 230
        return (-1);
      }
#line 231
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 232
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 235
    tarindex ++;
#line 236
    state = 2;
#line 237
    break;
    case 2: 
#line 239
    if (target) {
#line 240
      if ((size_t )(tarindex + 1) >= targsize) {
#line 241
        return (-1);
      }
#line 242
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 243
      *(target + (tarindex + 1)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 246
    tarindex ++;
#line 247
    state = 3;
#line 248
    break;
    case 3: 
#line 250
    if (target) {
#line 251
      if ((size_t )tarindex >= targsize) {
#line 252
        return (-1);
      }
#line 253
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 255
    tarindex ++;
#line 256
    state = 0;
#line 257
    break;
    }
  }
#line 266
  if (ch == (int )Pad64) {
#line 267
    tmp___3 = src;
#line 267
    src ++;
#line 267
    ch = (int )*tmp___3;
#line 268
    switch (state) {
    case 0: 
    case 1: 
#line 271
    return (-1);
    case 2: 
#line 275
    while (ch != 0) {
#line 276
      tmp___5 = __ctype_b_loc();
#line 276
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 277
        break;
      }
#line 275
      tmp___4 = src;
#line 275
      src ++;
#line 275
      ch = (int )*tmp___4;
    }
#line 279
    if (ch != (int )Pad64) {
#line 280
      return (-1);
    }
#line 281
    tmp___6 = src;
#line 281
    src ++;
#line 281
    ch = (int )*tmp___6;
    case 3: 
#line 290
    while (ch != 0) {
#line 291
      tmp___8 = __ctype_b_loc();
#line 291
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 292
        return (-1);
      }
#line 290
      tmp___7 = src;
#line 290
      src ++;
#line 290
      ch = (int )*tmp___7;
    }
#line 300
    if (target) {
#line 300
      if ((int )*(target + tarindex) != 0) {
#line 301
        return (-1);
      }
    }
    }
  } else {
#line 308
    if (state != 0) {
#line 309
      return (-1);
    }
  }
#line 312
  return (tarindex);
}
}
#line 1 "bsd-bindresvport.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 7 "bsd-bindresvport.h"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) ;
#line 53 "bsd-bindresvport.c"
int bindresvport_af(int sd , struct sockaddr *sa , int af ) 
{ int error___0 ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port ;
  int salen ;
  int i ;
  int *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 68
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 69
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 70
    sa = (struct sockaddr *)(& myaddr);
  }
#line 73
  if (af == 2) {
#line 74
    sin = (struct sockaddr_in *)sa;
#line 75
    salen = (int )sizeof(struct sockaddr_in );
#line 76
    portp = & sin->sin_port;
  } else {
#line 77
    if (af == 10) {
#line 78
      sin6 = (struct sockaddr_in6 *)sa;
#line 79
      salen = (int )sizeof(struct sockaddr_in6 );
#line 80
      portp = & sin6->sin6_port;
    } else {
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 96;
#line 83
      return (-1);
    }
  }
#line 85
  sa->sa_family = (unsigned short )af;
#line 87
  __x = *portp;
#line 87
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 87
  port = __v;
#line 88
  if ((int )port == 0) {
#line 89
    tmp___0 = arc4random();
#line 89
    port = (unsigned short )(tmp___0 % 424U + 600U);
  }
#line 91
  i = 0;
#line 91
  while (i < 424) {
#line 92
    __x___0 = port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 92
    *portp = __v___0;
#line 94
    error___0 = bind(sd, (struct sockaddr  const  *)sa, (unsigned int )salen);
#line 97
    if (error___0 == 0) {
#line 98
      break;
    }
#line 101
    if (error___0 < 0) {
#line 101
      tmp___1 = __errno_location();
#line 101
      if (! (*tmp___1 == 98)) {
#line 101
        tmp___2 = __errno_location();
#line 101
        if (! (*tmp___2 == 22)) {
#line 102
          break;
        }
      }
    }
#line 104
    port = (u_int16_t )((int )port + 1);
#line 105
    if ((int )port > 1023) {
#line 106
      port = (unsigned short)600;
    }
#line 91
    i ++;
  }
#line 109
  return (error___0);
}
}
#line 1 "bsd-daemon.o"
#line 1 "bsd-misc.o"
#line 828 "/usr/include/unistd.h"
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 37 "bsd-misc.h"
void arc4random_stir(void) ;
#line 41
void setproctitle(char const   *fmt  , ...) ;
#line 33 "entropy.h"
void seed_rng(void) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 61 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) ;
#line 62
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) ;
#line 64 "bsd-misc.c"
static rc4_t *rc4  =    (rc4_t *)((void *)0);
#line 66 "bsd-misc.c"
void rc4_key(rc4_t *r , unsigned char *key , int len ) 
{ int t ;

  {
#line 70
  r->i = 0;
#line 70
  while (r->i < 256) {
#line 71
    r->s[r->i] = (unsigned int )r->i;
#line 70
    (r->i) ++;
  }
#line 73
  r->j = 0;
#line 74
  r->i = 0;
#line 74
  while (r->i < 256) {
#line 76
    r->j = (int )((((unsigned int )r->j + r->s[r->i]) + (unsigned int )*(key + r->i % len)) % 256U);
#line 77
    t = (int )r->s[r->i];
#line 78
    r->s[r->i] = r->s[r->j];
#line 79
    r->s[r->j] = (unsigned int )t;
#line 74
    (r->i) ++;
  }
#line 81
  r->j = 0;
#line 81
  r->i = r->j;
#line 82
  return;
}
}
#line 84 "bsd-misc.c"
void rc4_getbytes(rc4_t *r , unsigned char *buffer , int len ) 
{ int t ;
  int c ;

  {
#line 89
  c = 0;
#line 90
  while (c < len) {
#line 92
    r->i = (r->i + 1) % 256;
#line 93
    r->j = (int )(((unsigned int )r->j + r->s[r->i]) % 256U);
#line 94
    t = (int )r->s[r->i];
#line 95
    r->s[r->i] = r->s[r->j];
#line 96
    r->s[r->j] = (unsigned int )t;
#line 98
    t = (int )((r->s[r->i] + r->s[r->j]) % 256U);
#line 100
    *(buffer + c) = (unsigned char )r->s[t];
#line 101
    c ++;
  }
#line 103
  return;
}
}
#line 105 "bsd-misc.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 109
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 110
    arc4random_stir();
  }
#line 112
  rc4_getbytes(rc4, (unsigned char *)(& r), (int )sizeof(r));
#line 114
  return (r);
}
}
#line 117 "bsd-misc.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[32] ;
  void *tmp ;

  {
#line 121
  if ((unsigned int )rc4 == (unsigned int )((void *)0)) {
#line 122
    tmp = xmalloc(sizeof(*rc4));
#line 122
    rc4 = (rc4_t *)tmp;
  }
#line 124
  seed_rng();
#line 125
  RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 127
  rc4_key(rc4, rand_buf, (int )sizeof(rand_buf));
#line 128
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 129
  return;
}
}
#line 133 "bsd-misc.c"
void setproctitle(char const   *fmt  , ...) 
{ 

  {
#line 136
  return;
}
}
#line 140
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 140 "bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 142
  return (0);
}
}
#line 1 "bsd-mktemp.o"
#line 1 "bsd-rresvport.o"
#line 1 "bsd-setenv.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-strlcat.o"
#line 46 "bsd-strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 51
  d = dst;
#line 52
  s = src;
#line 53
  n___0 = siz;
#line 57
  while (1) {
#line 57
    if ((int )*d != 0) {
#line 57
      tmp = n___0;
#line 57
      n___0 --;
#line 57
      if (! (tmp != 0U)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
#line 58
    d ++;
  }
#line 59
  dlen = (unsigned int )(d - dst);
#line 60
  n___0 = siz - dlen;
#line 62
  if (n___0 == 0U) {
#line 63
    tmp___0 = strlen(s);
#line 63
    return (dlen + tmp___0);
  }
#line 64
  while ((int const   )*s != 0) {
#line 65
    if (n___0 != 1U) {
#line 66
      tmp___1 = d;
#line 66
      d ++;
#line 66
      *tmp___1 = (char )*s;
#line 67
      n___0 --;
    }
#line 69
    s ++;
  }
#line 71
  *d = (char )'\000';
#line 73
  return (dlen + (size_t )(s - src));
}
}
#line 1 "bsd-strlcpy.o"
#line 45 "bsd-strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ register char *d ;
  register char const   *s ;
  register size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  d = dst;
#line 51
  s = src;
#line 52
  n___0 = siz;
#line 55
  if (n___0 != 0U) {
#line 55
    n___0 --;
#line 55
    if (n___0 != 0U) {
#line 56
      while (1) {
#line 57
        tmp = d;
#line 57
        d ++;
#line 57
        tmp___0 = s;
#line 57
        s ++;
#line 57
        *tmp = (char )*tmp___0;
#line 57
        if ((int )*tmp == 0) {
#line 58
          break;
        }
#line 56
        n___0 --;
#line 56
        if (! (n___0 != 0U)) {
#line 56
          break;
        }
      }
    }
  }
#line 63
  if (n___0 == 0U) {
#line 64
    if (siz != 0U) {
#line 65
      *d = (char )'\000';
    }
#line 66
    while (1) {
#line 66
      tmp___1 = s;
#line 66
      s ++;
#line 66
      if (! *tmp___1) {
#line 66
        break;
      }
    }
  }
#line 70
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "bufaux.o"
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 54 "buffer.h"
void buffer_consume(Buffer *buffer , unsigned int bytes ) ;
#line 26 "bufaux.h"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 30
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 56
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 32 "bufaux.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 35
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 35
  bits = tmp;
#line 36
  bin_size = (bits + 7) / 8;
#line 37
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 37
  buf___1 = (unsigned char *)tmp___0;
#line 42
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1);
#line 43
  if (oi != bin_size) {
#line 44
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
  }
#line 48
  while (1) {
#line 48
    msg[0] = (char )(bits >> 8);
#line 48
    msg[1] = (char )bits;
#line 48
    break;
  }
#line 49
  buffer_append(buffer, (char const   *)(msg), 2U);
#line 51
  buffer_append(buffer, (char const   *)((char *)buf___1), (unsigned int )oi);
#line 53
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 54
  xfree((void *)buf___1);
#line 55
  return;
}
}
#line 60 "bufaux.c"
int buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int bits ;
  int bytes ;
  unsigned char buf___1[2] ;
  unsigned char *bin ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 67
  buffer_get(buffer, (char *)(buf___1), 2U);
#line 68
  bits = (int )(((unsigned long )buf___1[0] << 8) | (unsigned long )buf___1[1]);
#line 70
  bytes = (bits + 7) / 8;
#line 71
  tmp = buffer_len(buffer);
#line 71
  if (tmp < (unsigned int )bytes) {
#line 72
    fatal("buffer_get_bignum: input buffer too small");
  }
#line 73
  tmp___0 = buffer_ptr(buffer);
#line 73
  bin = (unsigned char *)tmp___0;
#line 74
  BN_bin2bn((unsigned char const   *)bin, bytes, value);
#line 75
  buffer_consume(buffer, (unsigned int )bytes);
#line 77
  return (2 + bytes);
}
}
#line 83 "bufaux.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int bytes ;
  int tmp ;
  unsigned char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  int hasnohigh ;
  int i ;
  int carry ;
  unsigned char *uc ;
  int tmp___1 ;

  {
#line 86
  tmp = BN_num_bits((BIGNUM const   *)value);
#line 86
  bytes = (tmp + 7) / 8 + 1;
#line 87
  tmp___0 = xmalloc((unsigned int )bytes);
#line 87
  buf___1 = (unsigned char *)tmp___0;
#line 89
  hasnohigh = 0;
#line 90
  *(buf___1 + 0) = (unsigned char )'\000';
#line 92
  oi = BN_bn2bin((BIGNUM const   *)value, buf___1 + 1);
#line 93
  if (oi != bytes - 1) {
#line 94
    fatal("buffer_put_bignum: BN_bn2bin() failed: oi %d != bin_size %d", oi, bytes);
  }
#line 96
  if ((int )*(buf___1 + 1) & 128) {
#line 96
    hasnohigh = 0;
  } else {
#line 96
    hasnohigh = 1;
  }
#line 97
  if (value->neg) {
#line 100
    uc = buf___1;
#line 101
    log("negativ!");
#line 102
    i = bytes - 1;
#line 102
    carry = 1;
#line 102
    while (i >= 0) {
#line 103
      *(uc + i) = (unsigned char )((int )*(uc + i) ^ 255);
#line 104
      if (carry) {
#line 105
        *(uc + i) = (unsigned char )((int )*(uc + i) + 1);
#line 105
        if (*(uc + i)) {
#line 105
          tmp___1 = 0;
        } else {
#line 105
          tmp___1 = 1;
        }
#line 105
        carry = tmp___1;
      }
#line 102
      i --;
    }
  }
#line 108
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), (unsigned int )(bytes - hasnohigh));
#line 109
  memset((void *)buf___1, 0, (unsigned int )bytes);
#line 110
  xfree((void *)buf___1);
#line 111
  return;
}
}
#line 113 "bufaux.c"
int buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int len ;
  unsigned char *bin ;
  char *tmp ;

  {
#line 118
  tmp = buffer_get_string(buffer, (unsigned int *)(& len));
#line 118
  bin = (unsigned char *)tmp;
#line 119
  BN_bin2bn((unsigned char const   *)bin, len, value);
#line 120
  xfree((void *)bin);
#line 121
  return (len);
}
}
#line 127 "bufaux.c"
unsigned int buffer_get_int(Buffer *buffer ) 
{ unsigned char buf___1[4] ;

  {
#line 131
  buffer_get(buffer, (char *)(buf___1), 4U);
#line 132
  return ((unsigned int )(((((unsigned long )buf___1[0] << 24) | ((unsigned long )buf___1[1] << 16)) | ((unsigned long )buf___1[2] << 8)) | (unsigned long )buf___1[3]));
}
}
#line 138 "bufaux.c"
void buffer_put_int(Buffer *buffer , unsigned int value ) 
{ char buf___1[4] ;

  {
#line 142
  while (1) {
#line 142
    buf___1[0] = (char )(value >> 24);
#line 142
    buf___1[1] = (char )(value >> 16);
#line 142
    buf___1[2] = (char )(value >> 8);
#line 142
    buf___1[3] = (char )value;
#line 142
    break;
  }
#line 143
  buffer_append(buffer, (char const   *)(buf___1), 4U);
#line 144
  return;
}
}
#line 154 "bufaux.c"
char *buffer_get_string(Buffer *buffer , unsigned int *length_ptr ) 
{ unsigned int len ;
  char *value ;
  void *tmp ;

  {
#line 160
  len = buffer_get_int(buffer);
#line 161
  if (len > 262144U) {
#line 162
    fatal("Received packet with bad string length %d", len);
  }
#line 164
  tmp = xmalloc(len + 1U);
#line 164
  value = (char *)tmp;
#line 166
  buffer_get(buffer, value, len);
#line 168
  *(value + len) = (char)0;
#line 170
  if (length_ptr) {
#line 171
    *length_ptr = len;
  }
#line 172
  return (value);
}
}
#line 178 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , unsigned int len ) 
{ 

  {
#line 181
  buffer_put_int(buffer, len);
#line 182
  buffer_append(buffer, (char const   *)buf___1, len);
#line 183
  return;
}
}
#line 184 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 187
  tmp = strlen(s);
#line 187
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 188
  return;
}
}
#line 193 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;

  {
#line 197
  buffer_get(buffer, & ch, 1U);
#line 198
  return ((int )((unsigned char )ch));
}
}
#line 204 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 207
  ch = (char )value;
#line 208
  buffer_append(buffer, (char const   *)(& ch), 1U);
#line 209
  return;
}
}
#line 1 "buffer.o"
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 26 "xmalloc.h"
void *xrealloc(void *ptr , size_t new_size ) ;
#line 57 "buffer.h"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) ;
#line 66
void buffer_dump(Buffer *buffer ) ;
#line 25 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ void *tmp ;

  {
#line 28
  buffer->alloc = 4096U;
#line 29
  tmp = xmalloc(buffer->alloc);
#line 29
  buffer->buf = (char *)tmp;
#line 30
  buffer->offset = 0U;
#line 31
  buffer->end = 0U;
#line 32
  return;
}
}
#line 36 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 39
  memset((void *)buffer->buf, 0, buffer->alloc);
#line 40
  xfree((void *)buffer->buf);
#line 41
  return;
}
}
#line 48 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 51
  buffer->offset = 0U;
#line 52
  buffer->end = 0U;
#line 53
  return;
}
}
#line 57 "buffer.c"
void buffer_append(Buffer *buffer , char const   *data , unsigned int len ) 
{ char *cp ;

  {
#line 61
  buffer_append_space(buffer, & cp, len);
#line 62
  memcpy((void * __restrict  )cp, (void const   * __restrict  )data, len);
#line 63
  return;
}
}
#line 71 "buffer.c"
void buffer_append_space(Buffer *buffer , char **datap , unsigned int len ) 
{ void *tmp ;

  {
#line 75
  if (buffer->offset == buffer->end) {
#line 76
    buffer->offset = 0U;
#line 77
    buffer->end = 0U;
  }
  restart: 
#line 81
  if (buffer->end + len < buffer->alloc) {
#line 82
    *datap = buffer->buf + buffer->end;
#line 83
    buffer->end += len;
#line 84
    return;
  }
#line 90
  if (buffer->offset > buffer->alloc / 2U) {
#line 91
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 93
    buffer->end -= buffer->offset;
#line 94
    buffer->offset = 0U;
    goto restart;
  }
#line 98
  buffer->alloc += len + 32768U;
#line 99
  tmp = xrealloc((void *)buffer->buf, buffer->alloc);
#line 99
  buffer->buf = (char *)tmp;
  goto restart;
}
}
#line 105 "buffer.c"
unsigned int buffer_len(Buffer *buffer ) 
{ 

  {
#line 108
  return (buffer->end - buffer->offset);
}
}
#line 113 "buffer.c"
void buffer_get(Buffer *buffer , char *buf___1 , unsigned int len ) 
{ 

  {
#line 116
  if (len > buffer->end - buffer->offset) {
#line 117
    fatal("buffer_get: trying to get more bytes than in buffer");
  }
#line 118
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 119
  buffer->offset += len;
#line 120
  return;
}
}
#line 124 "buffer.c"
void buffer_consume(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 127
  if (bytes > buffer->end - buffer->offset) {
#line 128
    fatal("buffer_consume: trying to get more bytes than in buffer");
  }
#line 129
  buffer->offset += bytes;
#line 130
  return;
}
}
#line 134 "buffer.c"
void buffer_consume_end(Buffer *buffer , unsigned int bytes ) 
{ 

  {
#line 137
  if (bytes > buffer->end - buffer->offset) {
#line 138
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 139
  buffer->end -= bytes;
#line 140
  return;
}
}
#line 144 "buffer.c"
char *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 147
  return (buffer->buf + buffer->offset);
}
}
#line 152 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ int i ;
  unsigned char *ucp ;

  {
#line 156
  ucp = (unsigned char *)buffer->buf;
#line 158
  i = (int )buffer->offset;
#line 158
  while ((unsigned int )i < buffer->end) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %02x", *(ucp + i));
#line 158
    i ++;
  }
#line 160
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 161
  return;
}
}
#line 1 "canohost.o"
#line 114 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 185
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 335 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 34 "packet.h"
int packet_get_connection_in(void) ;
#line 152
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 210
int packet_connection_is_on_socket(void) ;
#line 387 "ssh.h"
char *get_remote_hostname(int socket___0 ) ;
#line 394
char const   *get_canonical_hostname(void) ;
#line 400
char const   *get_remote_ipaddr(void) ;
#line 403
int get_peer_port(int sock ) ;
#line 406
int get_remote_port(void) ;
#line 407
int get_local_port(void) ;
#line 468
void fatal_cleanup(void) ;
#line 28 "canohost.c"
char *get_remote_hostname(int socket___0 ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[64] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *from6 ;
  struct sockaddr_in *from4 ;
  struct in_addr addr ;
  u_int16_t port ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned char options___0[200] ;
  unsigned char *ucp ;
  char text[1024] ;
  char *cp ;
  socklen_t option_size ;
  int ipproto ;
  struct protoent *ip ;
  int tmp___20 ;
  char *tmp___21 ;

  {
#line 39
  fromlen = sizeof(from);
#line 40
  memset((void *)(& from), 0, sizeof(from));
#line 41
  tmp___1 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 41
  if (tmp___1 < 0) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    debug("getpeername failed: %.100s", tmp___0);
#line 43
    fatal_cleanup();
  }
#line 47
  if ((int )from.ss_family == 10) {
#line 48
    from6 = (struct sockaddr_in6 *)(& from);
#line 52
    if (*((uint32_t const   *)(& from6->sin6_addr) + 0) == 0U) {
#line 52
      if (*((uint32_t const   *)(& from6->sin6_addr) + 1) == 0U) {
#line 52
        __x = 65535U;
#line 52
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 52
        if (*((uint32_t const   *)(& from6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 53
          from4 = (struct sockaddr_in *)(& from);
#line 57
          memcpy((void * __restrict  )(& addr), (void const   * __restrict  )((char *)(& from6->sin6_addr) + 12),
                 sizeof(addr));
#line 58
          port = from6->sin6_port;
#line 60
          memset((void *)(& from), 0, sizeof(from));
#line 62
          from4->sin_family = (unsigned short)2;
#line 63
          memcpy((void * __restrict  )(& from4->sin_addr), (void const   * __restrict  )(& addr),
                 sizeof(addr));
#line 64
          from4->sin_port = port;
        }
      }
    }
  }
#line 69
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 69
  if (tmp___2 != 0) {
#line 71
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 74
  tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                         fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                         0U, 8U);
#line 74
  if (tmp___19 == 0) {
#line 77
    name[sizeof(name) - 1U] = (char )'\000';
#line 82
    i = 0;
#line 82
    while (name[i]) {
#line 83
      tmp___6 = __ctype_b_loc();
#line 83
      if ((int const   )*(*tmp___6 + (int )name[i]) & 256) {
#line 84
        if (sizeof(name[i]) > 1U) {
#line 84
          __res = tolower((int )name[i]);
        } else {
#line 84
          tmp___5 = __ctype_tolower_loc();
#line 84
          __res = (int )*(*tmp___5 + (int )name[i]);
        }
#line 84
        name[i] = (char )__res;
      }
#line 82
      i ++;
    }
#line 95
    memset((void *)(& hints), 0, sizeof(hints));
#line 96
    hints.ai_family = (int )from.ss_family;
#line 97
    hints.ai_socktype = 1;
#line 98
    tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                          (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 98
    if (tmp___7 != 0) {
#line 99
      log("reverse mapping checking getaddrinfo for %.700s failed - POSSIBLE BREAKIN ATTEMPT!",
          name);
#line 100
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
#line 104
    ai = aitop;
#line 104
    while (ai) {
#line 105
      tmp___8 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                            (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                            0U, 1U);
#line 107
      if (tmp___8 == 0) {
#line 107
        if (0) {
#line 107
          __s1_len = strlen((char const   *)(ntop));
#line 107
          __s2_len = strlen((char const   *)(ntop2));
#line 107
          if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
            goto _L___0;
          } else {
#line 107
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 107
              if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 107
                tmp___18 = 1;
              } else {
#line 107
                if (__s2_len >= 4U) {
#line 107
                  tmp___18 = 1;
                } else {
#line 107
                  tmp___18 = 0;
                }
              }
            } else {
#line 107
              tmp___18 = 0;
            }
          }
#line 107
          if (tmp___18) {
#line 107
            tmp___14 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
          } else {
#line 107
            tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
            tmp___14 = tmp___17;
          }
        } else {
#line 107
          tmp___17 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 107
          tmp___14 = tmp___17;
        }
#line 107
        if (tmp___14 == 0) {
#line 108
          break;
        }
      }
#line 104
      ai = ai->ai_next;
    }
#line 110
    freeaddrinfo(aitop);
#line 112
    if (! ai) {
#line 114
      log("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAKIN ATTEMPT!",
          ntop, name);
#line 116
      strlcpy(name, (char const   *)(ntop), sizeof(name));
      goto check_ip_options;
    }
  } else {
#line 122
    strlcpy(name, (char const   *)(ntop), sizeof(name));
#line 123
    log("Could not reverse map address %.100s.", name);
  }
  check_ip_options: 
#line 140
  if ((int )from.ss_family == 2) {
#line 147
    ip = getprotobyname("ip");
#line 147
    if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 148
      ipproto = ip->p_proto;
    } else {
#line 150
      ipproto = 0;
    }
#line 151
    option_size = sizeof(options___0);
#line 152
    tmp___20 = getsockopt(0, ipproto, 4, (void * __restrict  )((char *)(options___0)),
                          (socklen_t * __restrict  )(& option_size));
#line 152
    if (tmp___20 >= 0) {
#line 152
      if (option_size != 0U) {
#line 154
        cp = text;
#line 156
        ucp = options___0;
#line 156
        while (option_size > 0U) {
#line 157
          sprintf((char * __restrict  )cp, (char const   * __restrict  )" %2.2x",
                  *ucp);
#line 156
          ucp ++;
#line 156
          option_size --;
#line 156
          cp += 3;
        }
#line 158
        log("Connection from %.100s with IP options:%.800s", ntop, text);
#line 160
        packet_disconnect("Connection from %.100s with IP options:%.800s", ntop, text);
      }
    }
  }
#line 165
  tmp___21 = xstrdup((char const   *)(name));
#line 165
  return (tmp___21);
}
}
#line 177 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 174 "canohost.c"
char const   *get_canonical_hostname(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 180
  if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 181
    return ((char const   *)canonical_host_name);
  }
#line 184
  tmp___0 = packet_connection_is_on_socket();
#line 184
  if (tmp___0) {
#line 185
    tmp = packet_get_connection_in();
#line 185
    canonical_host_name = get_remote_hostname(tmp);
  } else {
#line 187
    canonical_host_name = xstrdup("UNKNOWN");
  }
#line 189
  return ((char const   *)canonical_host_name);
}
}
#line 200 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 197 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  int socket___0 ;
  char ntop[1025] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 207
  if ((unsigned int )canonical_host_ip != (unsigned int )((void *)0)) {
#line 208
    return ((char const   *)canonical_host_ip);
  }
#line 211
  tmp = packet_connection_is_on_socket();
#line 211
  if (! tmp) {
#line 212
    canonical_host_ip = xstrdup("UNKNOWN");
#line 213
    return ((char const   *)canonical_host_ip);
  }
#line 216
  socket___0 = packet_get_connection_in();
#line 219
  fromlen = sizeof(from);
#line 220
  memset((void *)(& from), 0, sizeof(from));
#line 221
  tmp___2 = getpeername(socket___0, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 221
  if (tmp___2 < 0) {
#line 222
    tmp___0 = __errno_location();
#line 222
    tmp___1 = strerror(*tmp___0);
#line 222
    debug("getpeername failed: %.100s", tmp___1);
#line 223
    fatal_cleanup();
  }
#line 226
  tmp___3 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 226
  if (tmp___3 != 0) {
#line 228
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 230
  canonical_host_ip = xstrdup((char const   *)(ntop));
#line 233
  return ((char const   *)canonical_host_ip);
}
}
#line 238 "canohost.c"
int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 246
  fromlen = sizeof(from);
#line 247
  memset((void *)(& from), 0, sizeof(from));
#line 248
  if (local) {
#line 249
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 249
    if (tmp___1 < 0) {
#line 250
      tmp = __errno_location();
#line 250
      tmp___0 = strerror(*tmp);
#line 250
      error("getsockname failed: %.100s", tmp___0);
#line 251
      return (0);
    }
  } else {
#line 254
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 254
    if (tmp___4 < 0) {
#line 255
      tmp___2 = __errno_location();
#line 255
      tmp___3 = strerror(*tmp___2);
#line 255
      debug("getpeername failed: %.100s", tmp___3);
#line 256
      fatal_cleanup();
    }
  }
#line 260
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                        sizeof(strport), 2U);
#line 260
  if (tmp___5 != 0) {
#line 262
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed");
  }
#line 263
  tmp___6 = atoi((char const   *)(strport));
#line 263
  return (tmp___6);
}
}
#line 268 "canohost.c"
int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 275
  tmp = packet_connection_is_on_socket();
#line 275
  if (! tmp) {
#line 276
    return (65535);
  }
#line 279
  tmp___0 = packet_get_connection_in();
#line 279
  tmp___1 = get_sock_port(tmp___0, local);
#line 279
  return (tmp___1);
}
}
#line 282 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 285
  tmp = get_sock_port(sock, 0);
#line 285
  return (tmp);
}
}
#line 288 "canohost.c"
int get_remote_port(void) 
{ int tmp ;

  {
#line 291
  tmp = get_port(0);
#line 291
  return (tmp);
}
}
#line 294 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 297
  tmp = get_port(1);
#line 297
  return (tmp);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "channels.o"
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 464 "ssh.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 475
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 544
int IPv4or6 ;
#line 73 "packet.h"
int packet_is_interactive(void) ;
#line 76
void packet_start(int type ) ;
#line 79
void packet_put_char(int value ) ;
#line 82
void packet_put_int(unsigned int value ) ;
#line 89
void packet_put_string(char const   *buf___1 , unsigned int len ) ;
#line 90
void packet_put_cstring(char const   *str ) ;
#line 97
void packet_send(void) ;
#line 106
void packet_read_expect(int *payload_len_ptr , int expected_type ) ;
#line 128
unsigned int packet_get_int(void) ;
#line 144
char *packet_get_string(unsigned int *length_ptr ) ;
#line 170
void packet_write_wait(void) ;
#line 179
int max_packet_size ;
#line 217
int packet_remaining(void) ;
#line 22 "uidswap.h"
void temporarily_use_uid(uid_t uid ) ;
#line 28
void restore_uid(void) ;
#line 70 "channels.h"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) ;
#line 71
void channel_open(int id ) ;
#line 72
void channel_request(int id , char *service , int wantconfirm ) ;
#line 73
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 74
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) ;
#line 75
void channel_register_cleanup(int id , channel_callback_fn *fn ) ;
#line 76
void channel_cancel_cleanup(int id ) ;
#line 77
Channel *channel_lookup(int id ) ;
#line 79
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) ;
#line 83
void channel_input_channel_request(int type , int plen ) ;
#line 84
void channel_input_close(int type , int plen ) ;
#line 85
void channel_input_close_confirmation(int type , int plen ) ;
#line 86
void channel_input_data(int type , int plen ) ;
#line 87
void channel_input_extended_data(int type , int plen ) ;
#line 88
void channel_input_ieof(int type , int plen ) ;
#line 89
void channel_input_oclose(int type , int plen ) ;
#line 90
void channel_input_open_confirmation(int type , int plen ) ;
#line 91
void channel_input_open_failure(int type , int plen ) ;
#line 92
void channel_input_port_open(int type , int plen ) ;
#line 93
void channel_input_window_adjust(int type , int plen ) ;
#line 97
void channel_set_options(int hostname_in_open ) ;
#line 104
int channel_allocate(int type , int sock , char *remote_name ) ;
#line 107
void channel_free(int id ) ;
#line 110
void channel_prepare_select(fd_set *readset , fd_set *writeset ) ;
#line 116
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 119
void channel_output_poll(void) ;
#line 122
int channel_not_very_much_buffered_data(void) ;
#line 126
void channel_stop_listening(void) ;
#line 132
void channel_close_all(void) ;
#line 135
int channel_max_fd(void) ;
#line 138
int channel_still_open(void) ;
#line 145
char *channel_open_message(void) ;
#line 152
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) ;
#line 162
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) ;
#line 171
void channel_permit_all_opens(void) ;
#line 178
void channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 191
char *x11_create_display_inet(int screen_number , int x11_display_offset ) ;
#line 198
void x11_input_open(int type , int plen ) ;
#line 210
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) ;
#line 215
void auth_request_forwarding(void) ;
#line 222
char *auth_get_socket_name(void) ;
#line 228
void auth_input_request_forwarding(struct passwd *pw ) ;
#line 231
void auth_input_open_request(int type , int plen ) ;
#line 234
int channel_connect_to(char const   *host , u_short host_port ) ;
#line 235
int x11_connect_display(void) ;
#line 83 "nchan.h"
chan_event_fn *chan_rcvd_oclose ;
#line 84
chan_event_fn *chan_read_failed ;
#line 85
chan_event_fn *chan_ibuf_empty ;
#line 88
chan_event_fn *chan_rcvd_ieof ;
#line 89
chan_event_fn *chan_write_failed ;
#line 90
chan_event_fn *chan_obuf_empty ;
#line 92
chan_event_fn *chan_delete_if_full_closed ;
#line 94
void chan_init_iostates(Channel *c ) ;
#line 95
void chan_init(void) ;
#line 43 "compat.h"
int compat13 ;
#line 44
int compat20 ;
#line 53 "channels.c"
static Channel *channels  =    (Channel *)((void *)0);
#line 60 "channels.c"
static int channels_alloc  =    0;
#line 66 "channels.c"
static int channel_max_fd_value  =    0;
#line 69 "channels.c"
static char *channel_forwarded_auth_socket_name  =    (char *)((void *)0);
#line 70 "channels.c"
static char *channel_forwarded_auth_socket_dir  =    (char *)((void *)0);
#line 73 "channels.c"
char *x11_saved_proto  =    (char *)((void *)0);
#line 76 "channels.c"
char *x11_saved_data  =    (char *)((void *)0);
#line 77 "channels.c"
unsigned int x11_saved_data_len  =    0U;
#line 83 "channels.c"
char *x11_fake_data  =    (char *)((void *)0);
#line 84 "channels.c"
unsigned int x11_fake_data_len  ;
#line 99 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 101 "channels.c"
static int num_permitted_opens  =    0;
#line 107 "channels.c"
static int all_opens_permitted  =    0;
#line 110 "channels.c"
static int have_hostname_in_open  =    0;
#line 114 "channels.c"
void channel_set_options(int hostname_in_open ) 
{ 

  {
#line 117
  have_hostname_in_open = hostname_in_open;
#line 118
  return;
}
}
#line 126 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 129
  all_opens_permitted = 1;
#line 130
  return;
}
}
#line 134 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 138
  if (id < 0) {
#line 138
    if (id > channels_alloc) {
#line 139
      log("channel_lookup: %d: bad id", id);
#line 140
      return ((Channel *)((void *)0));
    }
  }
#line 142
  c = channels + id;
#line 143
  if (c->type == 0) {
#line 144
    log("channel_lookup: %d: bad id: channel free", id);
#line 145
    return ((Channel *)((void *)0));
  }
#line 147
  return (c);
}
}
#line 150 "channels.c"
void set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 154
  val = fcntl(fd, 3, 0);
#line 155
  if (val < 0) {
#line 156
    tmp = __errno_location();
#line 156
    tmp___0 = strerror(*tmp);
#line 156
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 157
    return;
  }
#line 159
  if (val & 2048) {
#line 160
    return;
  }
#line 161
  debug("fd %d setting O_NONBLOCK", fd);
#line 162
  val |= 2048;
#line 163
  tmp___3 = fcntl(fd, 4, val);
#line 163
  if (tmp___3 == -1) {
#line 164
    tmp___1 = __errno_location();
#line 164
    tmp___2 = strerror(*tmp___1);
#line 164
    error("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
  }
#line 165
  return;
}
}
#line 172 "channels.c"
void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ) 
{ 

  {
#line 176
  if (rfd > channel_max_fd_value) {
#line 177
    channel_max_fd_value = rfd;
  }
#line 178
  if (wfd > channel_max_fd_value) {
#line 179
    channel_max_fd_value = wfd;
  }
#line 180
  if (efd > channel_max_fd_value) {
#line 181
    channel_max_fd_value = efd;
  }
#line 184
  c->rfd = rfd;
#line 185
  c->wfd = wfd;
#line 186
  if (rfd == wfd) {
#line 186
    c->sock = rfd;
  } else {
#line 186
    c->sock = -1;
  }
#line 187
  c->efd = efd;
#line 188
  c->extended_usage = extusage;
#line 189
  if (rfd != -1) {
#line 190
    set_nonblock(rfd);
  }
#line 191
  if (wfd != -1) {
#line 192
    set_nonblock(wfd);
  }
#line 193
  if (efd != -1) {
#line 194
    set_nonblock(efd);
  }
#line 195
  return;
}
}
#line 202 "channels.c"
int channel_new(char *ctype , int type , int rfd , int wfd , int efd , int window ,
                int maxpack , int extusage , char *remote_name ) 
{ int i ;
  int found ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 210
  if (channels_alloc == 0) {
#line 211
    chan_init();
#line 212
    channels_alloc = 10;
#line 213
    tmp = xmalloc((unsigned int )channels_alloc * sizeof(Channel ));
#line 213
    channels = (Channel *)tmp;
#line 214
    i = 0;
#line 214
    while (i < channels_alloc) {
#line 215
      (channels + i)->type = 0;
#line 214
      i ++;
    }
#line 220
    fatal_add_cleanup((void (*)(void * ))(& channel_stop_listening), (void *)0);
  }
#line 223
  found = -1;
#line 223
  i = 0;
#line 223
  while (i < channels_alloc) {
#line 224
    if ((channels + i)->type == 0) {
#line 226
      found = i;
#line 227
      break;
    }
#line 223
    i ++;
  }
#line 229
  if (found == -1) {
#line 231
    found = channels_alloc;
#line 232
    channels_alloc += 10;
#line 233
    debug("channel: expanding %d", channels_alloc);
#line 234
    tmp___0 = xrealloc((void *)channels, (unsigned int )channels_alloc * sizeof(Channel ));
#line 234
    channels = (Channel *)tmp___0;
#line 235
    i = found;
#line 235
    while (i < channels_alloc) {
#line 236
      (channels + i)->type = 0;
#line 235
      i ++;
    }
  }
#line 239
  c = channels + found;
#line 240
  buffer_init(& c->input);
#line 241
  buffer_init(& c->output);
#line 242
  buffer_init(& c->extended);
#line 243
  chan_init_iostates(c);
#line 244
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 245
  c->self = found;
#line 246
  c->type = type;
#line 247
  c->ctype = ctype;
#line 248
  c->local_window = window;
#line 249
  c->local_window_max = window;
#line 250
  c->local_consumed = 0;
#line 251
  c->local_maxpacket = maxpack;
#line 252
  c->remote_id = -1;
#line 253
  c->remote_name = remote_name;
#line 254
  c->remote_window = 0;
#line 255
  c->remote_maxpacket = 0;
#line 256
  c->cb_fn = (channel_callback_fn *)((void *)0);
#line 257
  c->cb_arg = (void *)0;
#line 258
  c->cb_event = 0;
#line 259
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 260
  debug("channel %d: new [%s]", found, remote_name);
#line 261
  return (found);
}
}
#line 264 "channels.c"
int channel_allocate(int type , int sock , char *remote_name ) 
{ int tmp ;

  {
#line 267
  tmp = channel_new((char *)"", type, sock, sock, -1, 0, 0, 0, remote_name);
#line 267
  return (tmp);
}
}
#line 273 "channels.c"
void channel_close_fds(Channel *c ) 
{ 

  {
#line 276
  if (c->sock != -1) {
#line 277
    close(c->sock);
#line 278
    c->sock = -1;
  }
#line 280
  if (c->rfd != -1) {
#line 281
    close(c->rfd);
#line 282
    c->rfd = -1;
  }
#line 284
  if (c->wfd != -1) {
#line 285
    close(c->wfd);
#line 286
    c->wfd = -1;
  }
#line 288
  if (c->efd != -1) {
#line 289
    close(c->efd);
#line 290
    c->efd = -1;
  }
#line 292
  return;
}
}
#line 296 "channels.c"
void channel_free(int id ) 
{ Channel *c ;
  Channel *tmp ;
  char *tmp___0 ;

  {
#line 299
  tmp = channel_lookup(id);
#line 299
  c = tmp;
#line 300
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 301
    packet_disconnect("channel free: bad local channel %d", id);
  }
#line 302
  tmp___0 = channel_open_message();
#line 302
  debug("channel_free: channel %d: status: %s", id, tmp___0);
#line 303
  if ((unsigned int )c->dettach_user != (unsigned int )((void *)0)) {
#line 304
    debug("channel_free: channel %d: dettaching channel user", id);
#line 305
    (*(c->dettach_user))(c->self, (void *)0);
  }
#line 307
  if (c->sock != -1) {
#line 308
    shutdown(c->sock, 2);
  }
#line 309
  channel_close_fds(c);
#line 310
  buffer_free(& c->input);
#line 311
  buffer_free(& c->output);
#line 312
  buffer_free(& c->extended);
#line 313
  c->type = 0;
#line 314
  if (c->remote_name) {
#line 315
    xfree((void *)c->remote_name);
#line 316
    c->remote_name = (char *)((void *)0);
  }
#line 318
  return;
}
}
#line 329 "channels.c"
chan_fn *channel_pre[11]  ;
#line 330 "channels.c"
chan_fn *channel_post[11]  ;
#line 332 "channels.c"
void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 335
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 336
  return;
}
}
#line 338 "channels.c"
void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 341
  tmp = buffer_len(& c->input);
#line 341
  if (tmp < (unsigned int )max_packet_size) {
#line 342
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 343
  tmp___0 = buffer_len(& c->output);
#line 343
  if (tmp___0 > 0U) {
#line 344
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 345
  return;
}
}
#line 347 "channels.c"
void channel_pre_open_15(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 351
  if (c->istate == 1) {
#line 352
    tmp = buffer_len(& c->input);
#line 352
    if (tmp < (unsigned int )max_packet_size) {
#line 353
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  }
#line 354
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 354
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 356
      tmp___0 = buffer_len(& c->output);
#line 356
      if (tmp___0 > 0U) {
#line 357
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 358
        if (c->ostate == 32) {
#line 359
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 362
  return;
}
}
#line 364 "channels.c"
void channel_pre_open_20(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 367
  if (c->istate == 1) {
#line 367
    if (c->remote_window > 0) {
#line 367
      tmp = buffer_len(& c->input);
#line 367
      if (tmp < (unsigned int )c->remote_window) {
#line 370
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 371
  if (c->ostate == 16) {
    goto _L;
  } else {
#line 371
    if (c->ostate == 32) {
      _L: /* CIL Label */ 
#line 373
      tmp___0 = buffer_len(& c->output);
#line 373
      if (tmp___0 > 0U) {
#line 374
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 375
        if (c->ostate == 32) {
#line 376
          (*chan_obuf_empty)(c);
        }
      }
    }
  }
#line 380
  if (c->efd != -1) {
#line 381
    if (c->extended_usage == 2) {
#line 381
      tmp___2 = buffer_len(& c->extended);
#line 381
      if (tmp___2 > 0U) {
#line 383
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 384
      if (c->extended_usage == 1) {
#line 384
        tmp___1 = buffer_len(& c->extended);
#line 384
        if (tmp___1 < (unsigned int )c->remote_window) {
#line 386
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 388
  return;
}
}
#line 390 "channels.c"
void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 393
  tmp = buffer_len(& c->input);
#line 393
  if (tmp == 0U) {
#line 394
    packet_start(24);
#line 395
    packet_put_int((unsigned int )c->remote_id);
#line 396
    packet_send();
#line 397
    c->type = 5;
#line 398
    debug("Closing channel %d after input drain.", c->self);
  }
#line 400
  return;
}
}
#line 402 "channels.c"
void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ unsigned int tmp ;

  {
#line 405
  tmp = buffer_len(& c->output);
#line 405
  if (tmp == 0U) {
#line 406
    channel_free(c->self);
  } else {
#line 408
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 409
  return;
}
}
#line 419 "channels.c"
int x11_open_helper(Channel *c ) 
{ unsigned char *ucp ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 426
  tmp = buffer_len(& c->output);
#line 426
  if (tmp < 12U) {
#line 427
    return (0);
  }
#line 430
  tmp___0 = buffer_ptr(& c->output);
#line 430
  ucp = (unsigned char *)tmp___0;
#line 431
  if ((int )*(ucp + 0) == 66) {
#line 432
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 433
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 434
    if ((int )*(ucp + 0) == 108) {
#line 435
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 436
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 438
      debug("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 440
      return (-1);
    }
  }
#line 444
  tmp___1 = buffer_len(& c->output);
#line 444
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 446
    return (0);
  }
#line 449
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 449
  if (proto_len != tmp___2) {
#line 451
    debug("X11 connection uses different authentication protocol.");
#line 452
    return (-1);
  } else {
#line 449
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 449
    if (tmp___3 != 0) {
#line 451
      debug("X11 connection uses different authentication protocol.");
#line 452
      return (-1);
    }
  }
#line 455
  if (data_len != x11_fake_data_len) {
#line 458
    debug("X11 auth data does not match fake data.");
#line 459
    return (-1);
  } else {
#line 455
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 455
    if (tmp___4 != 0) {
#line 458
      debug("X11 auth data does not match fake data.");
#line 459
      return (-1);
    }
  }
#line 462
  if (x11_fake_data_len != x11_saved_data_len) {
#line 463
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 465
    return (-1);
  }
#line 472
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 474
  return (1);
}
}
#line 477 "channels.c"
void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 480
  tmp = x11_open_helper(c);
#line 480
  ret = tmp;
#line 481
  if (ret == 1) {
#line 483
    c->type = 4;
#line 484
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 485
    if (ret == -1) {
#line 490
      log("X11 connection rejected because of wrong authentication.\r\n");
#line 491
      buffer_clear(& c->input);
#line 492
      buffer_clear(& c->output);
#line 493
      close(c->sock);
#line 494
      c->sock = -1;
#line 495
      c->type = 5;
#line 496
      packet_start(24);
#line 497
      packet_put_int((unsigned int )c->remote_id);
#line 498
      packet_send();
    }
  }
#line 500
  return;
}
}
#line 502 "channels.c"
void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret ;
  int tmp ;

  {
#line 505
  tmp = x11_open_helper(c);
#line 505
  ret = tmp;
#line 506
  if (ret == 1) {
#line 507
    c->type = 4;
#line 508
    channel_pre_open_15(c, readset, writeset);
  } else {
#line 509
    if (ret == -1) {
#line 510
      debug("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 511
      (*chan_read_failed)(c);
#line 512
      (*chan_write_failed)(c);
#line 513
      debug("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 515
  return;
}
}
#line 518 "channels.c"
void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  register char __result ;

  {
#line 527
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 527
  if (__result) {
#line 528
    debug("X11 connection requested.");
#line 529
    addrlen = sizeof(addr);
#line 530
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 531
    if (newsock < 0) {
#line 532
      tmp = __errno_location();
#line 532
      tmp___0 = strerror(*tmp);
#line 532
      error("accept: %.100s", tmp___0);
#line 533
      return;
    }
#line 535
    remote_hostname = get_remote_hostname(newsock);
#line 536
    remote_port = get_peer_port(newsock);
#line 537
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_hostname, remote_port);
#line 540
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 540
    newch = channel_new((char *)"x11", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 544
    if (compat20) {
#line 545
      packet_start(90);
#line 546
      packet_put_cstring("x11");
#line 547
      packet_put_int((unsigned int )newch);
#line 548
      packet_put_int((unsigned int )c->local_window_max);
#line 549
      packet_put_int((unsigned int )c->local_maxpacket);
#line 551
      packet_put_cstring((char const   *)remote_hostname);
#line 552
      packet_put_int((unsigned int )remote_port);
#line 553
      packet_send();
    } else {
#line 555
      packet_start(27);
#line 556
      packet_put_int((unsigned int )newch);
#line 557
      if (have_hostname_in_open) {
#line 558
        tmp___2 = strlen((char const   *)(buf___1));
#line 558
        packet_put_string((char const   *)(buf___1), tmp___2);
      }
#line 559
      packet_send();
    }
#line 561
    xfree((void *)remote_hostname);
  }
#line 563
  return;
}
}
#line 568 "channels.c"
void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  char buf___1[1024] ;
  char *remote_hostname ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  register char __result ;

  {
#line 577
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 577
  if (__result) {
#line 578
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 581
    addrlen = sizeof(addr);
#line 582
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 583
    if (newsock < 0) {
#line 584
      tmp = __errno_location();
#line 584
      tmp___0 = strerror(*tmp);
#line 584
      error("accept: %.100s", tmp___0);
#line 585
      return;
    }
#line 587
    remote_hostname = get_remote_hostname(newsock);
#line 588
    remote_port = get_peer_port(newsock);
#line 589
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"listen port %d for %.100s port %d, connect from %.200s port %d",
             c->listening_port, c->path, c->host_port, remote_hostname, remote_port);
#line 594
    tmp___1 = xstrdup((char const   *)(buf___1));
#line 594
    newch = channel_new((char *)"direct-tcpip", 3, newsock, newsock, -1, c->local_window_max,
                        c->local_maxpacket, 0, tmp___1);
#line 598
    if (compat20) {
#line 599
      packet_start(90);
#line 600
      packet_put_cstring("direct-tcpip");
#line 601
      packet_put_int((unsigned int )newch);
#line 602
      packet_put_int((unsigned int )c->local_window_max);
#line 603
      packet_put_int((unsigned int )c->local_maxpacket);
#line 605
      tmp___2 = strlen((char const   *)(c->path));
#line 605
      packet_put_string((char const   *)(c->path), tmp___2);
#line 606
      packet_put_int((unsigned int )c->host_port);
#line 608
      packet_put_cstring((char const   *)remote_hostname);
#line 609
      packet_put_int((unsigned int )remote_port);
#line 610
      packet_send();
    } else {
#line 612
      packet_start(29);
#line 613
      packet_put_int((unsigned int )newch);
#line 614
      tmp___3 = strlen((char const   *)(c->path));
#line 614
      packet_put_string((char const   *)(c->path), tmp___3);
#line 615
      packet_put_int((unsigned int )c->host_port);
#line 616
      if (have_hostname_in_open) {
#line 617
        tmp___4 = strlen((char const   *)(buf___1));
#line 617
        packet_put_string((char const   *)(buf___1), tmp___4);
      }
#line 619
      packet_send();
    }
#line 621
    xfree((void *)remote_hostname);
  }
#line 623
  return;
}
}
#line 629 "channels.c"
void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct sockaddr addr ;
  int newsock ;
  int newch ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  register char __result ;

  {
#line 636
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 636
  if (__result) {
#line 637
    addrlen = sizeof(addr);
#line 638
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 639
    if (newsock < 0) {
#line 640
      tmp = __errno_location();
#line 640
      tmp___0 = strerror(*tmp);
#line 640
      error("accept from auth socket: %.100s", tmp___0);
#line 641
      return;
    }
#line 643
    tmp___1 = xstrdup("accepted auth socket");
#line 643
    newch = channel_allocate(3, newsock, tmp___1);
#line 645
    packet_start(31);
#line 646
    packet_put_int((unsigned int )newch);
#line 647
    packet_send();
  }
#line 649
  return;
}
}
#line 651 "channels.c"
int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;

  {
#line 658
  if (c->rfd != -1) {
#line 658
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 658
    if (__result) {
#line 659
      len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 660
      if (len < 0) {
#line 660
        tmp = __errno_location();
#line 660
        if (*tmp == 4) {
#line 661
          return (1);
        } else {
#line 660
          tmp___0 = __errno_location();
#line 660
          if (*tmp___0 == 11) {
#line 661
            return (1);
          }
        }
      }
#line 662
      if (len <= 0) {
#line 663
        debug("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 665
        if (compat13) {
#line 666
          tmp___1 = buffer_len(& c->output);
#line 666
          buffer_consume(& c->output, tmp___1);
#line 667
          c->type = 8;
#line 668
          debug("Channel %d status set to input draining.", c->self);
        } else {
#line 670
          (*chan_read_failed)(c);
        }
#line 672
        return (-1);
      }
#line 674
      buffer_append(& c->input, (char const   *)(buf___1), (unsigned int )len);
    }
  }
#line 676
  return (1);
}
}
#line 678 "channels.c"
int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  register char __result ;
  unsigned int tmp___4 ;

  {
#line 685
  if (c->wfd != -1) {
#line 685
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->__fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 685
    if (__result) {
#line 685
      tmp___4 = buffer_len(& c->output);
#line 685
      if (tmp___4 > 0U) {
#line 687
        tmp = buffer_len(& c->output);
#line 687
        tmp___0 = buffer_ptr(& c->output);
#line 687
        len = write(c->wfd, (void const   *)tmp___0, tmp);
#line 689
        if (len < 0) {
#line 689
          tmp___1 = __errno_location();
#line 689
          if (*tmp___1 == 4) {
#line 690
            return (1);
          } else {
#line 689
            tmp___2 = __errno_location();
#line 689
            if (*tmp___2 == 11) {
#line 690
              return (1);
            }
          }
        }
#line 691
        if (len <= 0) {
#line 692
          if (compat13) {
#line 693
            tmp___3 = buffer_len(& c->output);
#line 693
            buffer_consume(& c->output, tmp___3);
#line 694
            debug("Channel %d status set to input draining.", c->self);
#line 695
            c->type = 8;
          } else {
#line 697
            (*chan_write_failed)(c);
          }
#line 699
          return (-1);
        }
#line 701
        buffer_consume(& c->output, (unsigned int )len);
#line 702
        if (compat20) {
#line 702
          if (len > 0) {
#line 703
            c->local_consumed += len;
          }
        }
      }
    }
  }
#line 706
  return (1);
}
}
#line 708 "channels.c"
int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;
  unsigned int tmp___1 ;

  {
#line 715
  if (c->efd != -1) {
#line 717
    if (c->extended_usage == 2) {
#line 717
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 717
      if (__result___0) {
#line 717
        tmp___1 = buffer_len(& c->extended);
#line 717
        if (tmp___1 > 0U) {
#line 719
          tmp = buffer_len(& c->extended);
#line 719
          tmp___0 = buffer_ptr(& c->extended);
#line 719
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 721
          debug("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 723
          if (len > 0) {
#line 724
            buffer_consume(& c->extended, (unsigned int )len);
#line 725
            c->local_consumed += len;
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 728
      if (c->extended_usage == 1) {
#line 728
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                             "m" (readset->__fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 728
        if (__result) {
#line 729
          len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 730
          debug("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 732
          if (len == 0) {
#line 733
            debug("channel %d: closing efd %d", c->self, c->efd);
#line 735
            close(c->efd);
#line 736
            c->efd = -1;
          } else {
#line 737
            if (len > 0) {
#line 738
              buffer_append(& c->extended, (char const   *)(buf___1), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 741
  return (1);
}
}
#line 743 "channels.c"
int channel_check_window(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 746
  if (! (c->flags & 3)) {
#line 746
    if (c->local_window < c->local_window_max / 2) {
#line 746
      if (c->local_consumed > 0) {
#line 749
        packet_start(93);
#line 750
        packet_put_int((unsigned int )c->remote_id);
#line 751
        packet_put_int((unsigned int )c->local_consumed);
#line 752
        packet_send();
#line 753
        debug("channel %d: window %d sent adjust %d", c->self, c->local_window, c->local_consumed);
#line 756
        c->local_window += c->local_consumed;
#line 757
        c->local_consumed = 0;
      }
    }
  }
#line 759
  return (1);
}
}
#line 762 "channels.c"
void channel_post_open_1(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 765
  channel_handle_rfd(c, readset, writeset);
#line 766
  channel_handle_wfd(c, readset, writeset);
#line 767
  return;
}
}
#line 769 "channels.c"
void channel_post_open_2(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 772
  channel_handle_rfd(c, readset, writeset);
#line 773
  channel_handle_wfd(c, readset, writeset);
#line 774
  channel_handle_efd(c, readset, writeset);
#line 775
  channel_check_window(c, readset, writeset);
#line 776
  return;
}
}
#line 778 "channels.c"
void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  register char __result ;
  unsigned int tmp___2 ;

  {
#line 783
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 783
  if (__result) {
#line 783
    tmp___2 = buffer_len(& c->output);
#line 783
    if (tmp___2 > 0U) {
#line 784
      tmp = buffer_len(& c->output);
#line 784
      tmp___0 = buffer_ptr(& c->output);
#line 784
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 786
      if (len <= 0) {
#line 787
        tmp___1 = buffer_len(& c->output);
#line 787
        buffer_consume(& c->output, tmp___1);
      } else {
#line 789
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 791
  return;
}
}
#line 793 "channels.c"
void channel_handler_init_20(void) 
{ 

  {
#line 796
  channel_pre[4] = & channel_pre_open_20;
#line 797
  channel_pre[7] = & channel_pre_x11_open;
#line 798
  channel_pre[2] = & channel_pre_listener;
#line 799
  channel_pre[1] = & channel_pre_listener;
#line 801
  channel_post[4] = & channel_post_open_2;
#line 802
  channel_post[2] = & channel_post_port_listener;
#line 803
  channel_post[1] = & channel_post_x11_listener;
#line 804
  return;
}
}
#line 806 "channels.c"
void channel_handler_init_13(void) 
{ 

  {
#line 809
  channel_pre[4] = & channel_pre_open_13;
#line 810
  channel_pre[7] = & channel_pre_x11_open_13;
#line 811
  channel_pre[1] = & channel_pre_listener;
#line 812
  channel_pre[2] = & channel_pre_listener;
#line 813
  channel_pre[6] = & channel_pre_listener;
#line 814
  channel_pre[8] = & channel_pre_input_draining;
#line 815
  channel_pre[9] = & channel_pre_output_draining;
#line 817
  channel_post[4] = & channel_post_open_1;
#line 818
  channel_post[1] = & channel_post_x11_listener;
#line 819
  channel_post[2] = & channel_post_port_listener;
#line 820
  channel_post[6] = & channel_post_auth_listener;
#line 821
  channel_post[9] = & channel_post_output_drain_13;
#line 822
  return;
}
}
#line 824 "channels.c"
void channel_handler_init_15(void) 
{ 

  {
#line 827
  channel_pre[4] = & channel_pre_open_15;
#line 828
  channel_pre[7] = & channel_pre_x11_open;
#line 829
  channel_pre[1] = & channel_pre_listener;
#line 830
  channel_pre[2] = & channel_pre_listener;
#line 831
  channel_pre[6] = & channel_pre_listener;
#line 833
  channel_post[1] = & channel_post_x11_listener;
#line 834
  channel_post[2] = & channel_post_port_listener;
#line 835
  channel_post[6] = & channel_post_auth_listener;
#line 836
  channel_post[4] = & channel_post_open_1;
#line 837
  return;
}
}
#line 839 "channels.c"
void channel_handler_init(void) 
{ int i ;

  {
#line 843
  i = 0;
#line 843
  while (i < 11) {
#line 844
    channel_pre[i] = (chan_fn *)((void *)0);
#line 845
    channel_post[i] = (chan_fn *)((void *)0);
#line 843
    i ++;
  }
#line 847
  if (compat20) {
#line 848
    channel_handler_init_20();
  } else {
#line 849
    if (compat13) {
#line 850
      channel_handler_init_13();
    } else {
#line 852
      channel_handler_init_15();
    }
  }
#line 853
  return;
}
}
#line 858
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 858 "channels.c"
static int did_init  =    0;
#line 855 "channels.c"
void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ int i ;
  Channel *c ;

  {
#line 862
  if (! did_init) {
#line 863
    channel_handler_init();
#line 864
    did_init = 1;
  }
#line 866
  i = 0;
#line 866
  while (i < channels_alloc) {
#line 867
    c = channels + i;
#line 868
    if (c->type == 0) {
      goto __Cont;
    }
#line 870
    if ((unsigned int )*(ftab + c->type) == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 872
    (*(*(ftab + c->type)))(c, readset, writeset);
#line 873
    (*chan_delete_if_full_closed)(c);
    __Cont: /* CIL Label */ 
#line 866
    i ++;
  }
#line 875
  return;
}
}
#line 877 "channels.c"
void channel_prepare_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 880
  channel_handler(channel_pre, readset, writeset);
#line 881
  return;
}
}
#line 883 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 886
  channel_handler(channel_post, readset, writeset);
#line 887
  return;
}
}
#line 891 "channels.c"
void channel_output_poll(void) 
{ int len ;
  int i ;
  Channel *c ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 897
  i = 0;
#line 897
  while (i < channels_alloc) {
#line 898
    c = channels + i;
#line 901
    if (compat13) {
#line 902
      if (c->type != 4) {
#line 902
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 906
      if (c->type != 4) {
        goto __Cont;
      }
#line 908
      if (c->istate != 1) {
#line 908
        if (c->istate != 2) {
          goto __Cont;
        }
      }
    }
#line 912
    if (compat20) {
#line 912
      if (c->flags & 3) {
#line 914
        debug("channel: %d: no data after CLOSE", c->self);
        goto __Cont;
      }
    }
#line 919
    tmp = buffer_len(& c->input);
#line 919
    len = (int )tmp;
#line 920
    if (len > 0) {
#line 922
      if (compat20) {
#line 923
        if (len > c->remote_window) {
#line 924
          len = c->remote_window;
        }
#line 925
        if (len > c->remote_maxpacket) {
#line 926
          len = c->remote_maxpacket;
        }
      } else {
#line 928
        tmp___0 = packet_is_interactive();
#line 928
        if (tmp___0) {
#line 929
          if (len > 1024) {
#line 930
            len = 512;
          }
        } else {
#line 933
          if (len > max_packet_size / 2) {
#line 934
            len = max_packet_size / 2;
          }
        }
      }
#line 937
      if (len > 0) {
#line 938
        if (compat20) {
#line 938
          tmp___1 = 94;
        } else {
#line 938
          tmp___1 = 23;
        }
#line 938
        packet_start(tmp___1);
#line 940
        packet_put_int((unsigned int )c->remote_id);
#line 941
        tmp___2 = buffer_ptr(& c->input);
#line 941
        packet_put_string((char const   *)tmp___2, (unsigned int )len);
#line 942
        packet_send();
#line 943
        buffer_consume(& c->input, (unsigned int )len);
#line 944
        c->remote_window -= len;
#line 945
        debug("channel %d: send data len %d", c->self, len);
      }
    } else {
#line 947
      if (c->istate == 2) {
#line 948
        if (compat13) {
#line 949
          fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
        }
#line 954
        (*chan_ibuf_empty)(c);
      }
    }
#line 957
    if (compat20) {
#line 957
      if (c->remote_window > 0) {
#line 957
        tmp___4 = buffer_len(& c->extended);
#line 957
        len = (int )tmp___4;
#line 957
        if (len > 0) {
#line 957
          if (c->extended_usage == 1) {
#line 961
            if (len > c->remote_window) {
#line 962
              len = c->remote_window;
            }
#line 963
            if (len > c->remote_maxpacket) {
#line 964
              len = c->remote_maxpacket;
            }
#line 965
            packet_start(95);
#line 966
            packet_put_int((unsigned int )c->remote_id);
#line 967
            packet_put_int(1U);
#line 968
            tmp___3 = buffer_ptr(& c->extended);
#line 968
            packet_put_string((char const   *)tmp___3, (unsigned int )len);
#line 969
            packet_send();
#line 970
            buffer_consume(& c->extended, (unsigned int )len);
#line 971
            c->remote_window -= len;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 897
    i ++;
  }
#line 974
  return;
}
}
#line 982 "channels.c"
void channel_input_data(int type , int plen ) 
{ int id ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int _p ;
  int _e ;

  {
#line 991
  tmp = packet_get_int();
#line 991
  id = (int )tmp;
#line 992
  c = channel_lookup(id);
#line 993
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 994
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 997
  if (c->type != 4) {
#line 997
    if (c->type != 7) {
#line 999
      return;
    }
  }
#line 1002
  if (! compat13) {
#line 1002
    if (c->ostate != 16) {
#line 1003
      return;
    }
  }
#line 1006
  data = packet_get_string(& data_len);
#line 1007
  while (1) {
#line 1007
    tmp___0 = packet_remaining();
#line 1007
    _len = tmp___0;
#line 1007
    if (_len > 0) {
#line 1007
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1007);
#line 1007
      packet_disconnect("Packet integrity error.");
    }
#line 1007
    break;
  }
#line 1009
  if (compat20) {
#line 1010
    if (data_len > (unsigned int )c->local_maxpacket) {
#line 1011
      log("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 1014
    if (data_len > (unsigned int )c->local_window) {
#line 1015
      log("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 1017
      xfree((void *)data);
#line 1018
      return;
    }
#line 1020
    c->local_window = (int )((unsigned int )c->local_window - data_len);
  } else {
#line 1022
    while (1) {
#line 1022
      _p = plen;
#line 1022
      _e = (int )(8U + data_len);
#line 1022
      if (_p != _e) {
#line 1022
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1022);
#line 1022
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1022
      break;
    }
  }
#line 1024
  buffer_append(& c->output, (char const   *)data, data_len);
#line 1025
  xfree((void *)data);
#line 1026
  return;
}
}
#line 1027 "channels.c"
void channel_input_extended_data(int type , int plen ) 
{ int id ;
  int tcode ;
  char *data ;
  unsigned int data_len ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1037
  tmp = packet_get_int();
#line 1037
  id = (int )tmp;
#line 1038
  c = channel_lookup(id);
#line 1040
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1041
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 1042
  if (c->type != 4) {
#line 1043
    log("channel %d: ext data for non open", id);
#line 1044
    return;
  }
#line 1046
  tmp___0 = packet_get_int();
#line 1046
  tcode = (int )tmp___0;
#line 1047
  if (c->efd == -1) {
#line 1050
    log("channel %d: bad ext data", c->self);
#line 1051
    return;
  } else {
#line 1047
    if (c->extended_usage != 2) {
#line 1050
      log("channel %d: bad ext data", c->self);
#line 1051
      return;
    } else {
#line 1047
      if (tcode != 1) {
#line 1050
        log("channel %d: bad ext data", c->self);
#line 1051
        return;
      }
    }
  }
#line 1053
  data = packet_get_string(& data_len);
#line 1054
  while (1) {
#line 1054
    tmp___1 = packet_remaining();
#line 1054
    _len = tmp___1;
#line 1054
    if (_len > 0) {
#line 1054
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1054);
#line 1054
      packet_disconnect("Packet integrity error.");
    }
#line 1054
    break;
  }
#line 1055
  if (data_len > (unsigned int )c->local_window) {
#line 1056
    log("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len, c->local_window);
#line 1058
    xfree((void *)data);
#line 1059
    return;
  }
#line 1061
  debug("channel %d: rcvd ext data %d", c->self, data_len);
#line 1062
  c->local_window = (int )((unsigned int )c->local_window - data_len);
#line 1063
  buffer_append(& c->extended, (char const   *)data, data_len);
#line 1064
  xfree((void *)data);
#line 1065
  return;
}
}
#line 1073 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ unsigned int i ;
  Channel *c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1079
  i = 0U;
#line 1079
  while (i < (unsigned int )channels_alloc) {
#line 1080
    c = channels + i;
#line 1081
    if (c->type == 4) {
#line 1082
      if (! compat20) {
#line 1082
        tmp___0 = buffer_len(& c->input);
#line 1082
        if (tmp___0 > (unsigned int )max_packet_size) {
#line 1083
          tmp = buffer_len(& c->input);
#line 1083
          debug("channel %d: big input buffer %d", c->self, tmp);
#line 1085
          return (0);
        }
      }
#line 1087
      tmp___2 = buffer_len(& c->output);
#line 1087
      if (tmp___2 > (unsigned int )max_packet_size) {
#line 1088
        tmp___1 = buffer_len(& c->output);
#line 1088
        debug("channel %d: big output buffer %d", c->self, tmp___1);
#line 1090
        return (0);
      }
    }
#line 1079
    i ++;
  }
#line 1094
  return (1);
}
}
#line 1097 "channels.c"
void channel_input_ieof(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 1103
  while (1) {
#line 1103
    _p = plen;
#line 1103
    _e = 4;
#line 1103
    if (_p != _e) {
#line 1103
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1103);
#line 1103
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1103
    break;
  }
#line 1105
  tmp = packet_get_int();
#line 1105
  id = (int )tmp;
#line 1106
  c = channel_lookup(id);
#line 1107
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1108
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 1109
  (*chan_rcvd_ieof)(c);
#line 1110
  return;
}
}
#line 1112 "channels.c"
void channel_input_close(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1118
  while (1) {
#line 1118
    _p = plen;
#line 1118
    _e = 4;
#line 1118
    if (_p != _e) {
#line 1118
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1118);
#line 1118
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1118
    break;
  }
#line 1120
  tmp = packet_get_int();
#line 1120
  id = (int )tmp;
#line 1121
  c = channel_lookup(id);
#line 1122
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1123
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 1129
  packet_start(25);
#line 1130
  packet_put_int((unsigned int )c->remote_id);
#line 1131
  packet_send();
#line 1140
  if (c->type != 5) {
#line 1145
    tmp___0 = buffer_len(& c->input);
#line 1145
    buffer_consume(& c->input, tmp___0);
#line 1146
    c->type = 9;
  }
#line 1148
  return;
}
}
#line 1151 "channels.c"
void channel_input_oclose(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _p ;
  int _e ;

  {
#line 1154
  tmp = packet_get_int();
#line 1154
  id = (int )tmp;
#line 1155
  tmp___0 = channel_lookup(id);
#line 1155
  c = tmp___0;
#line 1156
  while (1) {
#line 1156
    _p = plen;
#line 1156
    _e = 4;
#line 1156
    if (_p != _e) {
#line 1156
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1156);
#line 1156
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 1156
    break;
  }
#line 1157
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1158
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 1159
  (*chan_rcvd_oclose)(c);
#line 1160
  return;
}
}
#line 1162 "channels.c"
void channel_input_close_confirmation(int type , int plen ) 
{ int id ;
  unsigned int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1165
  tmp = packet_get_int();
#line 1165
  id = (int )tmp;
#line 1166
  tmp___0 = channel_lookup(id);
#line 1166
  c = tmp___0;
#line 1168
  while (1) {
#line 1168
    tmp___1 = packet_remaining();
#line 1168
    _len = tmp___1;
#line 1168
    if (_len > 0) {
#line 1168
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1168);
#line 1168
      packet_disconnect("Packet integrity error.");
    }
#line 1168
    break;
  }
#line 1169
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1170
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 1172
  if (c->type != 5) {
#line 1173
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 1175
  channel_free(c->self);
#line 1176
  return;
}
}
#line 1178 "channels.c"
void channel_input_open_confirmation(int type , int plen ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1184
  if (! compat20) {
#line 1185
    while (1) {
#line 1185
      _p = plen;
#line 1185
      _e = 8;
#line 1185
      if (_p != _e) {
#line 1185
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1185);
#line 1185
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1185
      break;
    }
  }
#line 1187
  tmp = packet_get_int();
#line 1187
  id = (int )tmp;
#line 1188
  c = channel_lookup(id);
#line 1190
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1191
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 1190
    if (c->type != 3) {
#line 1191
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 1193
  tmp___0 = packet_get_int();
#line 1193
  remote_id = (int )tmp___0;
#line 1195
  c->remote_id = remote_id;
#line 1196
  c->type = 4;
#line 1198
  if (compat20) {
#line 1199
    tmp___1 = packet_get_int();
#line 1199
    c->remote_window = (int )tmp___1;
#line 1200
    tmp___2 = packet_get_int();
#line 1200
    c->remote_maxpacket = (int )tmp___2;
#line 1201
    while (1) {
#line 1201
      tmp___3 = packet_remaining();
#line 1201
      _len = tmp___3;
#line 1201
      if (_len > 0) {
#line 1201
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1201);
#line 1201
        packet_disconnect("Packet integrity error.");
      }
#line 1201
      break;
    }
#line 1202
    if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1202
      if (c->cb_event == type) {
#line 1203
        debug("callback start");
#line 1204
        (*(c->cb_fn))(c->self, c->cb_arg);
#line 1205
        debug("callback done");
      }
    }
#line 1207
    debug("channel %d: open confirm rwindow %d rmax %d", c->self, c->remote_window,
          c->remote_maxpacket);
  }
#line 1210
  return;
}
}
#line 1212 "channels.c"
void channel_input_open_failure(int type , int plen ) 
{ int id ;
  Channel *c ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int reason ;
  unsigned int tmp___0 ;
  char *msg ;
  char *tmp___1 ;
  char *lang ;
  char *tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1218
  if (! compat20) {
#line 1219
    while (1) {
#line 1219
      _p = plen;
#line 1219
      _e = 4;
#line 1219
      if (_p != _e) {
#line 1219
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1219);
#line 1219
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 1219
      break;
    }
  }
#line 1221
  tmp = packet_get_int();
#line 1221
  id = (int )tmp;
#line 1222
  c = channel_lookup(id);
#line 1224
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1225
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 1224
    if (c->type != 3) {
#line 1225
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 1227
  if (compat20) {
#line 1228
    tmp___0 = packet_get_int();
#line 1228
    reason = (int )tmp___0;
#line 1229
    tmp___1 = packet_get_string((unsigned int *)((void *)0));
#line 1229
    msg = tmp___1;
#line 1230
    tmp___2 = packet_get_string((unsigned int *)((void *)0));
#line 1230
    lang = tmp___2;
#line 1231
    log("channel_open_failure: %d: reason %d: %s", id, reason, msg);
#line 1232
    while (1) {
#line 1232
      tmp___3 = packet_remaining();
#line 1232
      _len = tmp___3;
#line 1232
      if (_len > 0) {
#line 1232
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            1232);
#line 1232
        packet_disconnect("Packet integrity error.");
      }
#line 1232
      break;
    }
#line 1233
    xfree((void *)msg);
#line 1234
    xfree((void *)lang);
  }
#line 1237
  channel_free(id);
#line 1238
  return;
}
}
#line 1240 "channels.c"
void channel_input_channel_request(int type , int plen ) 
{ int id ;
  Channel *c ;
  unsigned int tmp ;
  char *service ;
  char *tmp___0 ;

  {
#line 1246
  tmp = packet_get_int();
#line 1246
  id = (int )tmp;
#line 1247
  c = channel_lookup(id);
#line 1249
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1251
    packet_disconnect("Received request for non-open channel %d.", id);
  } else {
#line 1249
    if (c->type != 4) {
#line 1249
      if (c->type != 10) {
#line 1251
        packet_disconnect("Received request for non-open channel %d.", id);
      }
    }
  }
#line 1253
  if ((unsigned int )c->cb_fn != (unsigned int )((void *)0)) {
#line 1253
    if (c->cb_event == type) {
#line 1254
      debug("callback start");
#line 1255
      (*(c->cb_fn))(c->self, c->cb_arg);
#line 1256
      debug("callback done");
    } else {
#line 1258
      tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1258
      service = tmp___0;
#line 1259
      debug("channel: %d rcvd request for %s", c->self, service);
#line 1260
      debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1261
      xfree((void *)service);
    }
  } else {
#line 1258
    tmp___0 = packet_get_string((unsigned int *)((void *)0));
#line 1258
    service = tmp___0;
#line 1259
    debug("channel: %d rcvd request for %s", c->self, service);
#line 1260
    debug("cb_fn %p cb_event %d", c->cb_fn, c->cb_event);
#line 1261
    xfree((void *)service);
  }
#line 1263
  return;
}
}
#line 1265 "channels.c"
void channel_input_window_adjust(int type , int plen ) 
{ Channel *c ;
  int id ;
  int adjust ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 1271
  if (! compat20) {
#line 1272
    return;
  }
#line 1275
  tmp = packet_get_int();
#line 1275
  id = (int )tmp;
#line 1276
  c = channel_lookup(id);
#line 1278
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1279
    log("Received window adjust for non-open channel %d.", id);
#line 1281
    return;
  } else {
#line 1278
    if (c->type != 4) {
#line 1279
      log("Received window adjust for non-open channel %d.", id);
#line 1281
      return;
    }
  }
#line 1283
  tmp___0 = packet_get_int();
#line 1283
  adjust = (int )tmp___0;
#line 1284
  while (1) {
#line 1284
    tmp___1 = packet_remaining();
#line 1284
    _len = tmp___1;
#line 1284
    if (_len > 0) {
#line 1284
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
          1284);
#line 1284
      packet_disconnect("Packet integrity error.");
    }
#line 1284
    break;
  }
#line 1285
  debug("channel %d: rcvd adjust %d", id, adjust);
#line 1286
  c->remote_window += adjust;
#line 1287
  return;
}
}
#line 1294 "channels.c"
void channel_stop_listening(void) 
{ int i ;

  {
#line 1298
  i = 0;
#line 1298
  while (i < channels_alloc) {
#line 1299
    switch ((channels + i)->type) {
    case 6: 
#line 1301
    close((channels + i)->sock);
#line 1302
    remove((char const   *)((channels + i)->path));
#line 1303
    channel_free(i);
#line 1304
    break;
    case 2: 
    case 1: 
#line 1307
    close((channels + i)->sock);
#line 1308
    channel_free(i);
#line 1309
    break;
    default: ;
#line 1311
    break;
    }
#line 1298
    i ++;
  }
#line 1314
  return;
}
}
#line 1321 "channels.c"
void channel_close_all(void) 
{ int i ;

  {
#line 1325
  i = 0;
#line 1325
  while (i < channels_alloc) {
#line 1326
    if ((channels + i)->type != 0) {
#line 1327
      channel_close_fds(channels + i);
    }
#line 1325
    i ++;
  }
#line 1328
  return;
}
}
#line 1332 "channels.c"
int channel_max_fd(void) 
{ 

  {
#line 1335
  return (channel_max_fd_value);
}
}
#line 1340 "channels.c"
int channel_still_open(void) 
{ unsigned int i ;

  {
#line 1344
  i = 0U;
#line 1344
  while (i < (unsigned int )channels_alloc) {
#line 1345
    switch ((channels + i)->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
#line 1353
    if (! compat20) {
#line 1354
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 1359
    return (1);
    case 8: 
    case 9: 
#line 1362
    if (! compat13) {
#line 1363
      fatal("cannot happen: OUT_DRAIN");
    }
#line 1364
    return (1);
    default: 
#line 1366
    fatal("channel_still_open: bad channel type %d", (channels + i)->type);
    }
    __Cont: /* CIL Label */ 
#line 1344
    i ++;
  }
#line 1369
  return (0);
}
}
#line 1378 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  int i ;
  char buf___1[512] ;
  char *cp ;
  size_t tmp ;
  Channel *c ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 1385
  buffer_init(& buffer);
#line 1386
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 1387
  tmp = strlen((char const   *)(buf___1));
#line 1387
  buffer_append(& buffer, (char const   *)(buf___1), tmp);
#line 1388
  i = 0;
#line 1388
  while (i < channels_alloc) {
#line 1389
    c = channels + i;
#line 1390
    switch (c->type) {
    case 0: 
    case 1: 
    case 2: 
    case 5: 
    case 6: 
    goto __Cont;
    case 10: 
    case 3: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 1403
    tmp___0 = buffer_len(& c->output);
#line 1403
    tmp___1 = buffer_len(& c->input);
#line 1403
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd);
#line 1409
    tmp___2 = strlen((char const   *)(buf___1));
#line 1409
    buffer_append(& buffer, (char const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 1412
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 1388
    i ++;
  }
#line 1416
  buffer_append(& buffer, "\000", 1U);
#line 1417
  tmp___3 = buffer_ptr(& buffer);
#line 1417
  cp = xstrdup((char const   *)tmp___3);
#line 1418
  buffer_free(& buffer);
#line 1419
  return (cp);
}
}
#line 1427 "channels.c"
void channel_request_local_forwarding(u_short port , char const   *host , u_short host_port ,
                                      int gateway_ports ) 
{ int success ;
  int ch ;
  int sock ;
  int on ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  struct linger linger ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1431
  on = 1;
#line 1436
  tmp = strlen(host);
#line 1436
  if (tmp > sizeof((channels + 0)->path) - 1U) {
#line 1437
    packet_disconnect("Forward host name too long.");
  }
#line 1443
  memset((void *)(& hints), 0, sizeof(hints));
#line 1444
  hints.ai_family = IPv4or6;
#line 1445
  if (gateway_ports) {
#line 1445
    hints.ai_flags = 1;
  } else {
#line 1445
    hints.ai_flags = 0;
  }
#line 1446
  hints.ai_socktype = 1;
#line 1447
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port);
#line 1448
  tmp___0 = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1448
  if (tmp___0 != 0) {
#line 1449
    packet_disconnect("getaddrinfo: fatal error");
  }
#line 1451
  success = 0;
#line 1452
  ai = aitop;
#line 1452
  while (ai) {
#line 1453
    if (ai->ai_family != 2) {
#line 1453
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1455
    tmp___1 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1455
    if (tmp___1 != 0) {
#line 1457
      error("channel_request_local_forwarding: getnameinfo failed");
      goto __Cont;
    }
#line 1461
    sock = socket(ai->ai_family, 1, 0);
#line 1462
    if (sock < 0) {
#line 1464
      tmp___2 = __errno_location();
#line 1464
      tmp___3 = strerror(*tmp___2);
#line 1464
      verbose("socket: %.100s", tmp___3);
      goto __Cont;
    }
#line 1471
    setsockopt(sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 1472
    linger.l_onoff = 1;
#line 1473
    linger.l_linger = 5;
#line 1474
    setsockopt(sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 1475
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 1478
    tmp___8 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1478
    if (tmp___8 < 0) {
#line 1480
      if (! ai->ai_next) {
#line 1481
        tmp___4 = __errno_location();
#line 1481
        tmp___5 = strerror(*tmp___4);
#line 1481
        error("bind: %.100s", tmp___5);
      } else {
#line 1483
        tmp___6 = __errno_location();
#line 1483
        tmp___7 = strerror(*tmp___6);
#line 1483
        verbose("bind: %.100s", tmp___7);
      }
#line 1485
      close(sock);
      goto __Cont;
    }
#line 1489
    tmp___11 = listen(sock, 5);
#line 1489
    if (tmp___11 < 0) {
#line 1490
      tmp___9 = __errno_location();
#line 1490
      tmp___10 = strerror(*tmp___9);
#line 1490
      error("listen: %.100s", tmp___10);
#line 1491
      close(sock);
      goto __Cont;
    }
#line 1495
    tmp___12 = xstrdup("port listener");
#line 1495
    ch = channel_new((char *)"port listener", 2, sock, sock, -1, 8192, 4096, 0, tmp___12);
#line 1500
    strlcpy((channels + ch)->path, host, sizeof((channels + ch)->path));
#line 1501
    (channels + ch)->host_port = (int )host_port;
#line 1502
    (channels + ch)->listening_port = (int )port;
#line 1503
    success = 1;
    __Cont: /* CIL Label */ 
#line 1452
    ai = ai->ai_next;
  }
#line 1505
  if (success == 0) {
#line 1506
    packet_disconnect("cannot listen port: %d", port);
  }
#line 1507
  freeaddrinfo(aitop);
#line 1508
  return;
}
}
#line 1515 "channels.c"
void channel_request_remote_forwarding(u_short listen_port , char const   *host_to_connect ,
                                       u_short port_to_connect ) 
{ int payload_len ;
  char const   *address_to_bind ;

  {
#line 1521
  if (num_permitted_opens >= 100) {
#line 1522
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 1524
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 1525
  permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 1526
  permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 1527
  num_permitted_opens ++;
#line 1530
  if (compat20) {
#line 1531
    address_to_bind = "0.0.0.0";
#line 1532
    packet_start(80);
#line 1533
    packet_put_cstring("tcpip-forward");
#line 1534
    packet_put_char(0);
#line 1535
    packet_put_cstring(address_to_bind);
#line 1536
    packet_put_int((unsigned int )listen_port);
  } else {
#line 1538
    packet_start(28);
#line 1539
    packet_put_int((unsigned int )listen_port);
#line 1540
    packet_put_cstring(host_to_connect);
#line 1541
    packet_put_int((unsigned int )port_to_connect);
#line 1542
    packet_send();
#line 1543
    packet_write_wait();
#line 1548
    packet_read_expect(& payload_len, 14);
  }
#line 1550
  return;
}
}
#line 1558 "channels.c"
void channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port ;
  u_short host_port ;
  char *hostname ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1565
  tmp = packet_get_int();
#line 1565
  port = (unsigned short )tmp;
#line 1566
  hostname = packet_get_string((unsigned int *)((void *)0));
#line 1567
  tmp___0 = packet_get_int();
#line 1567
  host_port = (unsigned short )tmp___0;
#line 1573
  if ((int )port < 1024) {
#line 1573
    if (! is_root) {
#line 1574
      packet_disconnect("Requested forwarding of port %d but user is not root.", port);
    }
  }
#line 1579
  channel_request_local_forwarding(port, (char const   *)hostname, host_port, gateway_ports);
#line 1582
  xfree((void *)hostname);
#line 1583
  return;
}
}
#line 1586 "channels.c"
int channel_connect_to(char const   *host , u_short host_port ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 1592
  sock = -1;
#line 1594
  memset((void *)(& hints), 0, sizeof(hints));
#line 1595
  hints.ai_family = IPv4or6;
#line 1596
  hints.ai_socktype = 1;
#line 1597
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           host_port);
#line 1598
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1598
  if (gaierr != 0) {
#line 1599
    tmp = gai_strerror(gaierr);
#line 1599
    error("%.100s: unknown host (%s)", host, tmp);
#line 1600
    return (-1);
  }
#line 1602
  ai = aitop;
#line 1602
  while (ai) {
#line 1603
    if (ai->ai_family != 2) {
#line 1603
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 1605
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 1605
    if (tmp___0 != 0) {
#line 1607
      error("channel_connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 1611
    sock = socket(ai->ai_family, 1, 0);
#line 1612
    if (sock < 0) {
#line 1613
      tmp___1 = __errno_location();
#line 1613
      tmp___2 = strerror(*tmp___1);
#line 1613
      error("socket: %.100s", tmp___2);
      goto __Cont;
    }
#line 1617
    tmp___5 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1617
    if (tmp___5 < 0) {
#line 1618
      tmp___3 = __errno_location();
#line 1618
      tmp___4 = strerror(*tmp___3);
#line 1618
      error("connect %.100s port %s: %.100s", ntop, strport, tmp___4);
#line 1620
      close(sock);
      goto __Cont;
    }
#line 1623
    break;
    __Cont: /* CIL Label */ 
#line 1602
    ai = ai->ai_next;
  }
#line 1626
  freeaddrinfo(aitop);
#line 1627
  if (! ai) {
#line 1628
    error("connect %.100s port %d: failed.", host, host_port);
#line 1629
    return (-1);
  }
#line 1632
  return (sock);
}
}
#line 1641 "channels.c"
void channel_input_port_open(int type , int plen ) 
{ u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_channel ;
  int sock ;
  int newch ;
  int i ;
  int denied ;
  unsigned int host_len ;
  unsigned int originator_len ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _p ;
  int _e ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1646
  sock = -1;
#line 1650
  tmp = packet_get_int();
#line 1650
  remote_channel = (int )tmp;
#line 1653
  host = packet_get_string(& host_len);
#line 1656
  tmp___0 = packet_get_int();
#line 1656
  host_port = (unsigned short )tmp___0;
#line 1659
  if (have_hostname_in_open) {
#line 1660
    originator_string = packet_get_string(& originator_len);
#line 1661
    originator_len += 4U;
  } else {
#line 1663
    originator_string = xstrdup("unknown (remote did not supply name)");
#line 1664
    originator_len = 0U;
  }
#line 1667
  while (1) {
#line 1667
    _p = plen;
#line 1667
    _e = (int )(((8U + host_len) + 4U) + originator_len);
#line 1667
    if (_p != _e) {
#line 1667
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 1668);
#line 1667
      packet_disconnect("Packet integrity error. (%d)", 29);
    }
#line 1667
    break;
  }
#line 1671
  denied = 0;
#line 1672
  if (! all_opens_permitted) {
#line 1674
    i = 0;
#line 1674
    while (i < num_permitted_opens) {
#line 1676
      if ((int )permitted_opens[i].port_to_connect == (int )host_port) {
#line 1676
        if (0) {
#line 1676
          __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 1676
          __s2_len = strlen((char const   *)host);
#line 1676
          if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
            goto _L___0;
          } else {
#line 1676
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1676
              if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 1676
                tmp___10 = 1;
              } else {
#line 1676
                if (__s2_len >= 4U) {
#line 1676
                  tmp___10 = 1;
                } else {
#line 1676
                  tmp___10 = 0;
                }
              }
            } else {
#line 1676
              tmp___10 = 0;
            }
          }
#line 1676
          if (tmp___10) {
#line 1676
            tmp___6 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
          } else {
#line 1676
            tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       (char const   *)host);
#line 1676
            tmp___6 = tmp___9;
          }
        } else {
#line 1676
          tmp___9 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                     (char const   *)host);
#line 1676
          tmp___6 = tmp___9;
        }
#line 1676
        if (tmp___6 == 0) {
#line 1677
          break;
        }
      }
#line 1674
      i ++;
    }
#line 1680
    if (i >= num_permitted_opens) {
#line 1682
      log("Received request to connect to %.100s:%d, but the request was denied.",
          host, host_port);
#line 1684
      denied = 1;
    }
  }
#line 1687
  if (denied) {
#line 1687
    sock = -1;
  } else {
#line 1687
    sock = channel_connect_to((char const   *)host, host_port);
  }
#line 1688
  if (sock > 0) {
#line 1690
    newch = channel_allocate(4, sock, originator_string);
#line 1691
    (channels + newch)->remote_id = remote_channel;
#line 1693
    packet_start(21);
#line 1694
    packet_put_int((unsigned int )remote_channel);
#line 1695
    packet_put_int((unsigned int )newch);
#line 1696
    packet_send();
  } else {
#line 1698
    packet_start(22);
#line 1699
    packet_put_int((unsigned int )remote_channel);
#line 1700
    packet_send();
  }
#line 1702
  xfree((void *)host);
#line 1703
  return;
}
}
#line 1713 "channels.c"
char *x11_create_display_inet(int screen_number , int x11_display_offset ) 
{ int display_number ;
  int sock ;
  u_short port ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char display[512] ;
  char hostname[64] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
#line 1720
  num_socks = 0;
#line 1724
  display_number = x11_display_offset;
#line 1724
  while (display_number < 1000) {
#line 1727
    port = (unsigned short )(6000 + display_number);
#line 1728
    memset((void *)(& hints), 0, sizeof(hints));
#line 1729
    hints.ai_family = IPv4or6;
#line 1730
    hints.ai_flags = 1;
#line 1731
    hints.ai_socktype = 1;
#line 1732
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port);
#line 1733
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1733
    if (gaierr != 0) {
#line 1734
      tmp = gai_strerror(gaierr);
#line 1734
      error("getaddrinfo: %.100s", tmp);
#line 1735
      return ((char *)((void *)0));
    }
#line 1737
    ai = aitop;
#line 1737
    while (ai) {
#line 1738
      if (ai->ai_family != 2) {
#line 1738
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 1740
      sock = socket(ai->ai_family, 1, 0);
#line 1741
      if (sock < 0) {
#line 1742
        tmp___2 = __errno_location();
#line 1742
        if (*tmp___2 != 22) {
#line 1743
          tmp___0 = __errno_location();
#line 1743
          tmp___1 = strerror(*tmp___0);
#line 1743
          error("socket: %.100s", tmp___1);
#line 1744
          return ((char *)((void *)0));
        } else {
#line 1746
          debug("Socket family %d not supported [X11 disp create]", ai->ai_family);
          goto __Cont;
        }
      }
#line 1750
      tmp___5 = bind(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1750
      if (tmp___5 < 0) {
#line 1751
        tmp___3 = __errno_location();
#line 1751
        tmp___4 = strerror(*tmp___3);
#line 1751
        debug("bind port %d: %.100s", port, tmp___4);
#line 1752
        shutdown(sock, 2);
#line 1753
        close(sock);
#line 1755
        if (ai->ai_next) {
          goto __Cont;
        }
#line 1758
        n___0 = 0;
#line 1758
        while (n___0 < num_socks) {
#line 1759
          shutdown(socks[n___0], 2);
#line 1760
          close(socks[n___0]);
#line 1758
          n___0 ++;
        }
#line 1762
        num_socks = 0;
#line 1763
        break;
      }
#line 1765
      tmp___6 = num_socks;
#line 1765
      num_socks ++;
#line 1765
      socks[tmp___6] = sock;
#line 1770
      break;
      __Cont: /* CIL Label */ 
#line 1737
      ai = ai->ai_next;
    }
#line 1773
    if (num_socks > 0) {
#line 1774
      break;
    }
#line 1724
    display_number ++;
  }
#line 1776
  if (display_number >= 1000) {
#line 1777
    error("Failed to allocate internet-domain X11 display socket.");
#line 1778
    return ((char *)((void *)0));
  }
#line 1781
  n___0 = 0;
#line 1781
  while (n___0 < num_socks) {
#line 1782
    sock = socks[n___0];
#line 1783
    tmp___9 = listen(sock, 5);
#line 1783
    if (tmp___9 < 0) {
#line 1784
      tmp___7 = __errno_location();
#line 1784
      tmp___8 = strerror(*tmp___7);
#line 1784
      error("listen: %.100s", tmp___8);
#line 1785
      shutdown(sock, 2);
#line 1786
      close(sock);
#line 1787
      return ((char *)((void *)0));
    }
#line 1781
    n___0 ++;
  }
#line 1793
  tmp___12 = gethostname(hostname, sizeof(hostname));
#line 1793
  if (tmp___12 < 0) {
#line 1794
    tmp___10 = __errno_location();
#line 1794
    tmp___11 = strerror(*tmp___10);
#line 1794
    fatal("gethostname: %.100s", tmp___11);
  }
#line 1831
  snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%d.%d",
           hostname, display_number, screen_number);
#line 1836
  n___0 = 0;
#line 1836
  while (n___0 < num_socks) {
#line 1837
    sock = socks[n___0];
#line 1838
    tmp___13 = xstrdup("X11 inet listener");
#line 1838
    channel_new((char *)"x11 listener", 1, sock, sock, -1, 4096, 2048, 0, tmp___13);
#line 1836
    n___0 ++;
  }
#line 1845
  tmp___14 = xstrdup((char const   *)(display));
#line 1845
  return (tmp___14);
}
}
#line 1856
static int connect_local_xsocket(unsigned int dnr ) ;
#line 1856 "channels.c"
static char const   * const  x_sockets[4]  = {      (char const   * const  )"/tmp/.X11-unix/X%u",      (char const   * const  )"/var/X/.X11-unix/X%u",      (char const   * const  )"/usr/spool/sockets/X11/%u",      (char const   * const  )((void *)0)};
#line 1852 "channels.c"
static int connect_local_xsocket(unsigned int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  char const   * const  *path ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1866
  path = x_sockets;
#line 1866
  while (*path) {
#line 1867
    sock = socket(1, 1, 0);
#line 1868
    if (sock < 0) {
#line 1869
      tmp = __errno_location();
#line 1869
      tmp___0 = strerror(*tmp);
#line 1869
      error("socket: %.100s", tmp___0);
    }
#line 1870
    memset((void *)(& addr), 0, sizeof(addr));
#line 1871
    addr.sun_family = (unsigned short)1;
#line 1872
    snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )*path,
             dnr);
#line 1873
    tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                      sizeof(addr));
#line 1873
    if (tmp___1 == 0) {
#line 1874
      return (sock);
    }
#line 1875
    close(sock);
#line 1866
    path ++;
  }
#line 1877
  tmp___2 = __errno_location();
#line 1877
  tmp___3 = strerror(*tmp___2);
#line 1877
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 1878
  return (-1);
}
}
#line 1881 "channels.c"
int x11_connect_display(void) 
{ int display_number ;
  int sock ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 1884
  sock = 0;
#line 1892
  tmp = getenv("DISPLAY");
#line 1892
  display = (char const   *)tmp;
#line 1893
  if (! display) {
#line 1894
    error("DISPLAY not set.");
#line 1895
    return (-1);
  }
#line 1906
  if (0) {
#line 1906
    if (0) {
#line 1906
      __s1_len___0 = strlen(display);
#line 1906
      __s2_len___0 = strlen("unix:");
#line 1906
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 1906
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1906
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 1906
            tmp___25 = 1;
          } else {
#line 1906
            if (__s2_len___0 >= 4U) {
#line 1906
              tmp___25 = 1;
            } else {
#line 1906
              tmp___25 = 0;
            }
          }
        } else {
#line 1906
          tmp___25 = 0;
        }
      }
#line 1906
      if (tmp___25) {
#line 1906
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 1906
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 1906
        tmp___21 = tmp___24;
      }
    } else {
#line 1906
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 1906
      tmp___21 = tmp___24;
    }
#line 1906
    tmp___15 = tmp___21;
  } else {
#line 1906
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 1906
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 1906
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 1909
      tmp___0 = strrchr(display, ':');
#line 1909
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%d",
                       & display_number);
#line 1909
      if (tmp___1 != 1) {
#line 1910
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 1912
        return (-1);
      }
#line 1915
      sock = connect_local_xsocket((unsigned int )display_number);
#line 1916
      if (sock < 0) {
#line 1917
        return (-1);
      }
#line 1920
      return (sock);
    }
  }
#line 1926
  __builtin_strncpy(buf___1, display, sizeof(buf___1));
#line 1927
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 1928
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 1928
  cp = tmp___29;
#line 1929
  if (! cp) {
#line 1930
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 1931
    return (-1);
  }
#line 1933
  *cp = (char)0;
#line 1935
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%d",
                    & display_number);
#line 1935
  if (tmp___30 != 1) {
#line 1936
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 1938
    return (-1);
  }
#line 1942
  memset((void *)(& hints), 0, sizeof(hints));
#line 1943
  hints.ai_family = IPv4or6;
#line 1944
  hints.ai_socktype = 1;
#line 1945
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           6000 + display_number);
#line 1946
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 1946
  if (gaierr != 0) {
#line 1947
    tmp___31 = gai_strerror(gaierr);
#line 1947
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 1948
    return (-1);
  }
#line 1950
  ai = aitop;
#line 1950
  while (ai) {
#line 1952
    sock = socket(ai->ai_family, 1, 0);
#line 1953
    if (sock < 0) {
#line 1954
      tmp___32 = __errno_location();
#line 1954
      tmp___33 = strerror(*tmp___32);
#line 1954
      debug("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 1958
    tmp___36 = connect(sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 1958
    if (tmp___36 < 0) {
#line 1959
      tmp___34 = __errno_location();
#line 1959
      tmp___35 = strerror(*tmp___34);
#line 1959
      debug("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___35);
#line 1961
      close(sock);
      goto __Cont;
    }
#line 1965
    break;
    __Cont: /* CIL Label */ 
#line 1950
    ai = ai->ai_next;
  }
#line 1967
  freeaddrinfo(aitop);
#line 1968
  if (! ai) {
#line 1969
    tmp___37 = __errno_location();
#line 1969
    tmp___38 = strerror(*tmp___37);
#line 1969
    error("connect %.100s port %d: %.100s", buf___1, 6000 + display_number, tmp___38);
#line 1971
    return (-1);
  }
#line 1973
  return (sock);
}
}
#line 1982 "channels.c"
void x11_input_open(int type , int plen ) 
{ int remote_channel ;
  int sock ;
  int newch ;
  char *remote_host ;
  unsigned int remote_len ;
  unsigned int tmp ;
  int _p ;
  int _e ;
  int tmp___0 ;

  {
#line 1985
  sock = 0;
#line 1990
  tmp = packet_get_int();
#line 1990
  remote_channel = (int )tmp;
#line 1993
  if (have_hostname_in_open) {
#line 1994
    remote_host = packet_get_string(& remote_len);
#line 1995
    remote_len += 4U;
  } else {
#line 1997
    remote_host = xstrdup("unknown (remote did not supply name)");
#line 1998
    remote_len = 0U;
  }
#line 2001
  debug("Received X11 open request.");
#line 2002
  while (1) {
#line 2002
    _p = plen;
#line 2002
    _e = (int )(4U + remote_len);
#line 2002
    if (_p != _e) {
#line 2002
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2002);
#line 2002
      packet_disconnect("Packet integrity error. (%d)", 27);
    }
#line 2002
    break;
  }
#line 2005
  sock = x11_connect_display();
#line 2006
  if (sock == -1) {
#line 2008
    packet_start(22);
#line 2009
    packet_put_int((unsigned int )remote_channel);
#line 2010
    packet_send();
  } else {
#line 2013
    if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 2013
      tmp___0 = 4;
    } else {
#line 2013
      tmp___0 = 7;
    }
#line 2013
    newch = channel_allocate(tmp___0, sock, remote_host);
#line 2017
    (channels + newch)->remote_id = remote_channel;
#line 2020
    packet_start(21);
#line 2021
    packet_put_int((unsigned int )remote_channel);
#line 2022
    packet_put_int((unsigned int )newch);
#line 2023
    packet_send();
  }
#line 2025
  return;
}
}
#line 2032 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *proto ,
                                          char const   *data ) 
{ unsigned int data_len ;
  size_t tmp ;
  unsigned int i ;
  unsigned int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rand___0 ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
#line 2036
  tmp = strlen(data);
#line 2036
  data_len = tmp / 2U;
#line 2041
  rand___0 = (u_int32_t )0;
#line 2043
  tmp___0 = getenv("DISPLAY");
#line 2043
  cp = (char const   *)tmp___0;
#line 2044
  if (cp) {
#line 2045
    tmp___2 = __builtin_strchr((char *)cp, ':');
#line 2045
    cp = (char const   *)tmp___2;
  }
#line 2046
  if (cp) {
#line 2047
    tmp___4 = __builtin_strchr((char *)cp, '.');
#line 2047
    cp = (char const   *)tmp___4;
  }
#line 2048
  if (cp) {
#line 2049
    screen_number = atoi(cp + 1);
  } else {
#line 2051
    screen_number = 0;
  }
#line 2054
  x11_saved_proto = xstrdup(proto);
#line 2060
  tmp___5 = xmalloc(data_len);
#line 2060
  x11_saved_data = (char *)tmp___5;
#line 2061
  tmp___6 = xmalloc(data_len);
#line 2061
  x11_fake_data = (char *)tmp___6;
#line 2062
  i = 0U;
#line 2062
  while (i < data_len) {
#line 2063
    tmp___7 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                     & value);
#line 2063
    if (tmp___7 != 1) {
#line 2064
      fatal("x11_request_forwarding: bad authentication data: %.100s", data);
    }
#line 2065
    if (i % 4U == 0U) {
#line 2066
      rand___0 = arc4random();
    }
#line 2067
    *(x11_saved_data + i) = (char )value;
#line 2068
    *(x11_fake_data + i) = (char )(rand___0 & 255U);
#line 2069
    rand___0 >>= 8;
#line 2062
    i ++;
  }
#line 2071
  x11_saved_data_len = data_len;
#line 2072
  x11_fake_data_len = data_len;
#line 2075
  tmp___8 = xmalloc(2U * data_len + 1U);
#line 2075
  new_data = (char *)tmp___8;
#line 2076
  i = 0U;
#line 2076
  while (i < data_len) {
#line 2077
    sprintf((char * __restrict  )(new_data + 2U * i), (char const   * __restrict  )"%02x",
            (unsigned char )*(x11_fake_data + i));
#line 2076
    i ++;
  }
#line 2080
  if (compat20) {
#line 2081
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 2082
    packet_put_char(0);
  } else {
#line 2084
    packet_start(34);
  }
#line 2086
  packet_put_cstring(proto);
#line 2087
  packet_put_cstring((char const   *)new_data);
#line 2088
  packet_put_int((unsigned int )screen_number);
#line 2089
  packet_send();
#line 2090
  packet_write_wait();
#line 2091
  xfree((void *)new_data);
#line 2092
  return;
}
}
#line 2096 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 2099
  packet_start(30);
#line 2100
  packet_send();
#line 2101
  packet_write_wait();
#line 2102
  return;
}
}
#line 2110 "channels.c"
char *auth_get_socket_name(void) 
{ 

  {
#line 2113
  return (channel_forwarded_auth_socket_name);
}
}
#line 2118 "channels.c"
void cleanup_socket(void) 
{ 

  {
#line 2121
  remove((char const   *)channel_forwarded_auth_socket_name);
#line 2122
  rmdir((char const   *)channel_forwarded_auth_socket_dir);
#line 2123
  return;
}
}
#line 2130 "channels.c"
void auth_input_request_forwarding(struct passwd *pw ) 
{ int sock ;
  int newch ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int saved ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;

  {
#line 2136
  tmp = auth_get_socket_name();
#line 2136
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2137
    fatal("Protocol error: authentication forwarding requested twice.");
  }
#line 2140
  temporarily_use_uid(pw->pw_uid);
#line 2143
  tmp___0 = xmalloc(100U);
#line 2143
  channel_forwarded_auth_socket_name = (char *)tmp___0;
#line 2144
  tmp___1 = xmalloc(100U);
#line 2144
  channel_forwarded_auth_socket_dir = (char *)tmp___1;
#line 2145
  strlcpy(channel_forwarded_auth_socket_dir, "/tmp/ssh-XXXXXXXX", 100U);
#line 2148
  tmp___4 = mkdtemp(channel_forwarded_auth_socket_dir);
#line 2148
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 2149
    tmp___2 = __errno_location();
#line 2149
    tmp___3 = strerror(*tmp___2);
#line 2149
    packet_disconnect("mkdtemp: %.100s", tmp___3);
  }
#line 2150
  tmp___5 = getpid();
#line 2150
  snprintf((char * __restrict  )channel_forwarded_auth_socket_name, 100U, (char const   * __restrict  )"%s/agent.%d",
           channel_forwarded_auth_socket_dir, tmp___5);
#line 2153
  tmp___8 = atexit(& cleanup_socket);
#line 2153
  if (tmp___8 < 0) {
#line 2154
    tmp___6 = __errno_location();
#line 2154
    saved = *tmp___6;
#line 2155
    cleanup_socket();
#line 2156
    tmp___7 = strerror(saved);
#line 2156
    packet_disconnect("socket: %.100s", tmp___7);
  }
#line 2159
  sock = socket(1, 1, 0);
#line 2160
  if (sock < 0) {
#line 2161
    tmp___9 = __errno_location();
#line 2161
    tmp___10 = strerror(*tmp___9);
#line 2161
    packet_disconnect("socket: %.100s", tmp___10);
  }
#line 2164
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 2165
  sunaddr.sun_family = (unsigned short)1;
#line 2166
  __builtin_strncpy(sunaddr.sun_path, (char const   *)channel_forwarded_auth_socket_name,
                    sizeof(sunaddr.sun_path));
#line 2169
  tmp___13 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& sunaddr)),
                  sizeof(sunaddr));
#line 2169
  if (tmp___13 < 0) {
#line 2170
    tmp___11 = __errno_location();
#line 2170
    tmp___12 = strerror(*tmp___11);
#line 2170
    packet_disconnect("bind: %.100s", tmp___12);
  }
#line 2173
  restore_uid();
#line 2176
  tmp___16 = listen(sock, 5);
#line 2176
  if (tmp___16 < 0) {
#line 2177
    tmp___14 = __errno_location();
#line 2177
    tmp___15 = strerror(*tmp___14);
#line 2177
    packet_disconnect("listen: %.100s", tmp___15);
  }
#line 2180
  tmp___17 = xstrdup("auth socket");
#line 2180
  newch = channel_allocate(6, sock, tmp___17);
#line 2182
  strlcpy((channels + newch)->path, (char const   *)channel_forwarded_auth_socket_name,
          sizeof((channels + newch)->path));
#line 2184
  return;
}
}
#line 2188 "channels.c"
void auth_input_open_request(int type , int plen ) 
{ int remch ;
  int sock ;
  int newch ;
  char *dummyname ;
  int _p ;
  int _e ;
  unsigned int tmp ;

  {
#line 2194
  while (1) {
#line 2194
    _p = plen;
#line 2194
    _e = 4;
#line 2194
    if (_p != _e) {
#line 2194
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "channels.c", 2194);
#line 2194
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 2194
    break;
  }
#line 2197
  tmp = packet_get_int();
#line 2197
  remch = (int )tmp;
#line 2203
  sock = ssh_get_authentication_socket();
#line 2211
  if (sock < 0) {
#line 2212
    packet_start(22);
#line 2213
    packet_put_int((unsigned int )remch);
#line 2214
    packet_send();
#line 2215
    return;
  }
#line 2217
  debug("Forwarding authentication connection.");
#line 2224
  dummyname = xstrdup("authentication agent connection");
#line 2226
  newch = channel_allocate(4, sock, dummyname);
#line 2227
  (channels + newch)->remote_id = remch;
#line 2230
  packet_start(21);
#line 2231
  packet_put_int((unsigned int )remch);
#line 2232
  packet_put_int((unsigned int )newch);
#line 2233
  packet_send();
#line 2234
  return;
}
}
#line 2236 "channels.c"
void channel_start_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2239
  tmp = channel_lookup(id);
#line 2239
  c = tmp;
#line 2240
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2241
    log("channel_open: %d: bad id", id);
#line 2242
    return;
  }
#line 2244
  debug("send channel open %d", id);
#line 2245
  packet_start(90);
#line 2246
  packet_put_cstring((char const   *)c->ctype);
#line 2247
  packet_put_int((unsigned int )c->self);
#line 2248
  packet_put_int((unsigned int )c->local_window);
#line 2249
  packet_put_int((unsigned int )c->local_maxpacket);
#line 2250
  return;
}
}
#line 2251 "channels.c"
void channel_open(int id ) 
{ 

  {
#line 2255
  channel_start_open(id);
#line 2256
  packet_send();
#line 2257
  return;
}
}
#line 2258 "channels.c"
void channel_request(int id , char *service , int wantconfirm ) 
{ 

  {
#line 2261
  channel_request_start(id, service, wantconfirm);
#line 2262
  packet_send();
#line 2263
  debug("channel request %d: %s", id, service);
#line 2264
  return;
}
}
#line 2265 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2268
  tmp = channel_lookup(id);
#line 2268
  c = tmp;
#line 2269
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2270
    log("channel_request: %d: bad id", id);
#line 2271
    return;
  }
#line 2273
  packet_start(98);
#line 2274
  packet_put_int((unsigned int )c->remote_id);
#line 2275
  packet_put_cstring((char const   *)service);
#line 2276
  packet_put_char(wantconfirm);
#line 2277
  return;
}
}
#line 2278 "channels.c"
void channel_register_callback(int id , int mtype , channel_callback_fn *fn , void *arg ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2281
  tmp = channel_lookup(id);
#line 2281
  c = tmp;
#line 2282
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2283
    log("channel_register_callback: %d: bad id", id);
#line 2284
    return;
  }
#line 2286
  c->cb_event = mtype;
#line 2287
  c->cb_fn = fn;
#line 2288
  c->cb_arg = arg;
#line 2289
  return;
}
}
#line 2290 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2293
  tmp = channel_lookup(id);
#line 2293
  c = tmp;
#line 2294
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2295
    log("channel_register_cleanup: %d: bad id", id);
#line 2296
    return;
  }
#line 2298
  c->dettach_user = fn;
#line 2299
  return;
}
}
#line 2300 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2303
  tmp = channel_lookup(id);
#line 2303
  c = tmp;
#line 2304
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2305
    log("channel_cancel_cleanup: %d: bad id", id);
#line 2306
    return;
  }
#line 2308
  c->dettach_user = (channel_callback_fn *)((void *)0);
#line 2309
  return;
}
}
#line 2311 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 2314
  tmp = channel_lookup(id);
#line 2314
  c = tmp;
#line 2315
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2316
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 2315
    if (c->type != 10) {
#line 2316
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 2318
  channel_register_fds(c, rfd, wfd, efd, extusage);
#line 2319
  c->type = 4;
#line 2321
  c->local_window_max = c->local_maxpacket / 2;
#line 2321
  c->local_window = c->local_window_max;
#line 2322
  packet_start(93);
#line 2323
  packet_put_int((unsigned int )c->remote_id);
#line 2324
  packet_put_int((unsigned int )c->local_window);
#line 2325
  packet_send();
#line 2326
  return;
}
}
#line 1 "cipher.o"
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 138 "/usr/include/openssl/des.h"
extern void DES_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                            long length , DES_key_schedule *schedule , DES_cblock *ivec ,
                            int enc ) ;
#line 176
extern void DES_ede3_cbc_encrypt(unsigned char const   *input , unsigned char *output ,
                                 long length , DES_key_schedule *ks1 , DES_key_schedule *ks2 ,
                                 DES_key_schedule *ks3 , DES_cblock *ivec , int enc ) ;
#line 222
extern int DES_set_key(const_DES_cblock *key , DES_key_schedule *schedule ) ;
#line 108 "/usr/include/openssl/blowfish.h"
extern void BF_set_key(BF_KEY *key , int len , unsigned char const   *data ) ;
#line 115
extern void BF_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                           BF_KEY const   *schedule , unsigned char *ivec , int enc ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 87 "/usr/include/openssl/cast.h"
extern void CAST_set_key(CAST_KEY *key , int len , unsigned char const   *data ) ;
#line 92
extern void CAST_cbc_encrypt(unsigned char const   *in , unsigned char *out , long length ,
                             CAST_KEY *ks , unsigned char *iv , int enc ) ;
#line 68 "cipher.h"
unsigned int cipher_mask(void) ;
#line 70
unsigned int cipher_mask2(void) ;
#line 79
int cipher_number(char const   *name ) ;
#line 82
int ciphers_valid(char const   *names ) ;
#line 88
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) ;
#line 91
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 37 "cipher.c"
void SSH_3CBC_ENCRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 46
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 48
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks1, & iv1, 1);
#line 49
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 51
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 0);
#line 52
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )(& iv1), 8U);
#line 54
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks3, iv3, 1);
#line 55
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 56
  return;
}
}
#line 58 "cipher.c"
void SSH_3CBC_DECRYPT(DES_key_schedule ks1 , DES_key_schedule ks2 , DES_cblock *iv2 ,
                      DES_key_schedule ks3 , DES_cblock *iv3 , unsigned char *dest ,
                      unsigned char *src , unsigned int len ) 
{ DES_cblock iv1 ;

  {
#line 67
  memcpy((void * __restrict  )(& iv1), (void const   * __restrict  )iv2, 8U);
#line 69
  DES_cbc_encrypt((unsigned char const   *)src, dest, (long )len, & ks3, iv3, 0);
#line 70
  memcpy((void * __restrict  )iv3, (void const   * __restrict  )((src + len) - 8),
         8U);
#line 72
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks2, iv2, 1);
#line 73
  memcpy((void * __restrict  )iv2, (void const   * __restrict  )((dest + len) - 8),
         8U);
#line 75
  DES_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, & ks1, & iv1, 0);
#line 78
  return;
}
}
#line 84 "cipher.c"
static void swap_bytes(unsigned char const   *src , unsigned char *dst_ , int n___0 ) 
{ u_int32_t *dst ;
  union __anonunion_t_74 t ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  u_int32_t *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  u_int32_t *tmp___8 ;

  {
#line 88
  dst = (u_int32_t *)dst_;
#line 95
  n___0 /= 8;
#line 95
  while (n___0 > 0) {
#line 96
    tmp = src;
#line 96
    src ++;
#line 96
    t.c[3] = (char )*tmp;
#line 97
    tmp___0 = src;
#line 97
    src ++;
#line 97
    t.c[2] = (char )*tmp___0;
#line 98
    tmp___1 = src;
#line 98
    src ++;
#line 98
    t.c[1] = (char )*tmp___1;
#line 99
    tmp___2 = src;
#line 99
    src ++;
#line 99
    t.c[0] = (char )*tmp___2;
#line 100
    tmp___3 = dst;
#line 100
    dst ++;
#line 100
    *tmp___3 = t.i;
#line 102
    tmp___4 = src;
#line 102
    src ++;
#line 102
    t.c[3] = (char )*tmp___4;
#line 103
    tmp___5 = src;
#line 103
    src ++;
#line 103
    t.c[2] = (char )*tmp___5;
#line 104
    tmp___6 = src;
#line 104
    src ++;
#line 104
    t.c[1] = (char )*tmp___6;
#line 105
    tmp___7 = src;
#line 105
    src ++;
#line 105
    t.c[0] = (char )*tmp___7;
#line 106
    tmp___8 = dst;
#line 106
    dst ++;
#line 106
    *tmp___8 = t.i;
#line 95
    n___0 --;
  }
#line 108
  return;
}
}
#line 114 "cipher.c"
static char *cipher_names[12]  = 
#line 114
  {      (char *)"none",      (char *)"idea",      (char *)"des",      (char *)"3des", 
        (char *)"tss",      (char *)"rc4",      (char *)"blowfish",      (char *)"reserved", 
        (char *)"blowfish-cbc",      (char *)"3des-cbc",      (char *)"arcfour",      (char *)"cast128-cbc"};
#line 136 "cipher.c"
unsigned int cipher_mask1(void) 
{ unsigned int mask ;

  {
#line 139
  mask = 0U;
#line 140
  mask |= (unsigned int )(1 << 3);
#line 141
  mask |= (unsigned int )(1 << 6);
#line 142
  return (mask);
}
}
#line 144 "cipher.c"
unsigned int cipher_mask2(void) 
{ unsigned int mask ;

  {
#line 147
  mask = 0U;
#line 148
  mask |= (unsigned int )(1 << 8);
#line 149
  mask |= (unsigned int )(1 << 9);
#line 150
  mask |= (unsigned int )(1 << 10);
#line 151
  mask |= (unsigned int )(1 << 11);
#line 152
  return (mask);
}
}
#line 154 "cipher.c"
unsigned int cipher_mask(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 157
  tmp = cipher_mask1();
#line 157
  tmp___0 = cipher_mask2();
#line 157
  return (tmp | tmp___0);
}
}
#line 162 "cipher.c"
char const   *cipher_name(int cipher ) 
{ 

  {
#line 165
  if (cipher < 0) {
#line 167
    fatal("cipher_name: bad cipher name: %d", cipher);
  } else {
#line 165
    if ((unsigned int )cipher >= sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 167
      fatal("cipher_name: bad cipher name: %d", cipher);
    } else {
#line 165
      if ((unsigned int )cipher_names[cipher] == (unsigned int )((void *)0)) {
#line 167
        fatal("cipher_name: bad cipher name: %d", cipher);
      }
    }
  }
#line 168
  return ((char const   *)cipher_names[cipher]);
}
}
#line 174 "cipher.c"
int ciphers_valid(char const   *names ) 
{ char *ciphers ;
  char *p ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 181
  if (0) {
#line 181
    __s1_len = strlen(names);
#line 181
    __s2_len = strlen("");
#line 181
    if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
      goto _L___0;
    } else {
#line 181
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 181
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 181
          tmp___8 = 1;
        } else {
#line 181
          if (__s2_len >= 4U) {
#line 181
            tmp___8 = 1;
          } else {
#line 181
            tmp___8 = 0;
          }
        }
      } else {
#line 181
        tmp___8 = 0;
      }
    }
#line 181
    if (tmp___8) {
#line 181
      tmp___4 = __builtin_strcmp(names, "");
    } else {
#line 181
      tmp___7 = __builtin_strcmp(names, "");
#line 181
      tmp___4 = tmp___7;
    }
  } else {
#line 181
    tmp___7 = __builtin_strcmp(names, "");
#line 181
    tmp___4 = tmp___7;
  }
#line 181
  if (tmp___4 == 0) {
#line 182
    return (0);
  }
#line 183
  ciphers = xstrdup(names);
#line 184
  p = strtok((char * __restrict  )ciphers, (char const   * __restrict  )",");
#line 184
  while (p) {
#line 185
    i = cipher_number((char const   *)p);
#line 186
    if (i == -1) {
#line 187
      xfree((void *)ciphers);
#line 188
      return (0);
    } else {
#line 186
      tmp___9 = cipher_mask2();
#line 186
      if (! (tmp___9 & (unsigned int )(1 << i))) {
#line 187
        xfree((void *)ciphers);
#line 188
        return (0);
      }
    }
#line 184
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
  }
#line 191
  xfree((void *)ciphers);
#line 192
  return (1);
}
}
#line 200 "cipher.c"
int cipher_number(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 204
  i = 0;
#line 204
  while ((unsigned int )i < sizeof(cipher_names) / sizeof(cipher_names[0])) {
#line 205
    if (0) {
#line 205
      __s1_len = strlen((char const   *)cipher_names[i]);
#line 205
      __s2_len = strlen(name);
#line 205
      if (! ((unsigned int )((void const   *)(cipher_names[i] + 1)) - (unsigned int )((void const   *)cipher_names[i]) == 1U)) {
        goto _L___0;
      } else {
#line 205
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 205
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 205
            tmp___8 = 1;
          } else {
#line 205
            if (__s2_len >= 4U) {
#line 205
              tmp___8 = 1;
            } else {
#line 205
              tmp___8 = 0;
            }
          }
        } else {
#line 205
          tmp___8 = 0;
        }
      }
#line 205
      if (tmp___8) {
#line 205
        tmp___4 = __builtin_strcmp((char const   *)cipher_names[i], name);
      } else {
#line 205
        tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 205
        tmp___4 = tmp___7;
      }
    } else {
#line 205
      tmp___7 = __builtin_strcmp((char const   *)cipher_names[i], name);
#line 205
      tmp___4 = tmp___7;
    }
#line 205
    if (tmp___4 == 0) {
#line 205
      tmp___9 = cipher_mask();
#line 205
      if (tmp___9 & (unsigned int )(1 << i)) {
#line 207
        return (i);
      }
    }
#line 204
    i ++;
  }
#line 208
  return (-1);
}
}
#line 216 "cipher.c"
void cipher_set_key_string(CipherContext *context , int cipher , char const   *passphrase ) 
{ MD5_CTX md ;
  unsigned char digest___0[16] ;
  size_t tmp ;

  {
#line 222
  MD5_Init(& md);
#line 223
  tmp = strlen(passphrase);
#line 223
  MD5_Update(& md, (void const   *)((unsigned char const   *)passphrase), tmp);
#line 224
  MD5_Final(digest___0, & md);
#line 226
  cipher_set_key(context, cipher, (unsigned char const   *)(digest___0), 16);
#line 228
  memset((void *)(digest___0), 0, sizeof(digest___0));
#line 229
  memset((void *)(& md), 0, sizeof(md));
#line 230
  return;
}
}
#line 234 "cipher.c"
void cipher_set_key(CipherContext *context , int cipher , unsigned char const   *key ,
                    int keylen ) 
{ unsigned char padded[32] ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 241
  context->type = (unsigned int )cipher;
#line 245
  memset((void *)(padded), 0, sizeof(padded));
#line 246
  if ((unsigned int )keylen < sizeof(padded)) {
#line 246
    tmp = (unsigned int )keylen;
  } else {
#line 246
    tmp = sizeof(padded);
  }
#line 246
  memcpy((void * __restrict  )(padded), (void const   * __restrict  )key, tmp);
#line 249
  switch (cipher) {
  case 0: 
#line 255
  break;
  case 3: 
#line 263
  if (keylen < 16) {
#line 264
    error("Key length %d is insufficient for 3DES.", keylen);
  }
#line 265
  DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key1);
#line 266
  DES_set_key((const_DES_cblock *)((void *)(padded + 8)), & context->u.des3.key2);
#line 267
  if (keylen <= 16) {
#line 268
    DES_set_key((const_DES_cblock *)((void *)(padded)), & context->u.des3.key3);
  } else {
#line 270
    DES_set_key((const_DES_cblock *)((void *)(padded + 16)), & context->u.des3.key3);
  }
#line 271
  memset((void *)(context->u.des3.iv2), 0, sizeof(context->u.des3.iv2));
#line 272
  memset((void *)(context->u.des3.iv3), 0, sizeof(context->u.des3.iv3));
#line 273
  break;
  case 6: 
#line 276
  if (keylen < 16) {
#line 277
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 278
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)(padded));
#line 279
  memset((void *)(context->u.bf.iv), 0, 8U);
#line 280
  break;
  case 9: 
  case 8: 
  case 10: 
  case 11: 
#line 286
  tmp___0 = cipher_name(cipher);
#line 286
  fatal("cipher_set_key: illegal cipher: %s", tmp___0);
#line 287
  break;
  default: 
#line 290
  tmp___1 = cipher_name(cipher);
#line 290
  fatal("cipher_set_key: unknown cipher: %s", tmp___1);
  }
#line 292
  memset((void *)(padded), 0, sizeof(padded));
#line 293
  return;
}
}
#line 295 "cipher.c"
void cipher_set_key_iv(CipherContext *context , int cipher , unsigned char const   *key ,
                       int keylen , unsigned char const   *iv , int ivlen ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 301
  context->type = (unsigned int )cipher;
#line 304
  switch (cipher) {
  case 0: 
#line 306
  break;
  case 3: 
  case 6: 
#line 310
  tmp = cipher_name(cipher);
#line 310
  fatal("cipher_set_key_iv: illegal cipher: %s", tmp);
#line 311
  break;
  case 9: 
#line 314
  if (keylen < 24) {
#line 315
    error("Key length %d is insufficient for 3des-cbc.", keylen);
  }
#line 316
  DES_set_key((const_DES_cblock *)((void *)key), & context->u.des3.key1);
#line 317
  DES_set_key((const_DES_cblock *)((void *)(key + 8)), & context->u.des3.key2);
#line 318
  DES_set_key((const_DES_cblock *)((void *)(key + 16)), & context->u.des3.key3);
#line 319
  if (ivlen < 8) {
#line 320
    error("IV length %d is insufficient for 3des-cbc.", ivlen);
  }
#line 321
  memcpy((void * __restrict  )(context->u.des3.iv3), (void const   * __restrict  )((char *)iv),
         8U);
#line 322
  break;
  case 8: 
#line 325
  if (keylen < 16) {
#line 326
    error("Key length %d is insufficient for blowfish.", keylen);
  }
#line 327
  if (ivlen < 8) {
#line 328
    error("IV length %d is insufficient for blowfish.", ivlen);
  }
#line 329
  BF_set_key(& context->u.bf.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 330
  memcpy((void * __restrict  )(context->u.bf.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 331
  break;
  case 10: 
#line 334
  if (keylen < 16) {
#line 335
    error("Key length %d is insufficient for arcfour.", keylen);
  }
#line 336
  RC4_set_key(& context->u.rc4, keylen, (unsigned char const   *)((unsigned char *)key));
#line 337
  break;
  case 11: 
#line 340
  if (keylen < 16) {
#line 341
    error("Key length %d is insufficient for cast128.", keylen);
  }
#line 342
  if (ivlen < 8) {
#line 343
    error("IV length %d is insufficient for cast128.", ivlen);
  }
#line 344
  CAST_set_key(& context->u.cast.key, keylen, (unsigned char const   *)((unsigned char *)key));
#line 345
  memcpy((void * __restrict  )(context->u.cast.iv), (void const   * __restrict  )((char *)iv),
         8U);
#line 346
  break;
  default: 
#line 349
  tmp___0 = cipher_name(cipher);
#line 349
  fatal("cipher_set_key: unknown cipher: %s", tmp___0);
  }
#line 351
  return;
}
}
#line 355 "cipher.c"
void cipher_encrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 359
  if ((len & 7U) != 0U) {
#line 360
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 362
  switch ((int )context->type) {
  case 0: 
#line 364
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 365
  break;
  case 3: 
#line 368
  SSH_3CBC_ENCRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 372
  break;
  case 6: 
#line 375
  swap_bytes(src, dest, (int )len);
#line 376
  BF_cbc_encrypt((unsigned char const   *)dest, dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 379
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 380
  break;
  case 8: 
#line 383
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 1);
#line 386
  break;
  case 9: 
#line 389
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 1);
#line 392
  break;
  case 10: 
#line 395
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 396
  break;
  case 11: 
#line 399
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   1);
#line 401
  break;
  default: 
#line 404
  tmp = cipher_name((int )context->type);
#line 404
  fatal("cipher_encrypt: unknown cipher: %s", tmp);
  }
#line 406
  return;
}
}
#line 410 "cipher.c"
void cipher_decrypt(CipherContext *context , unsigned char *dest , unsigned char const   *src ,
                    unsigned int len ) 
{ char const   *tmp ;

  {
#line 414
  if ((len & 7U) != 0U) {
#line 415
    fatal("cipher_decrypt: bad ciphertext length %d", len);
  }
#line 417
  switch ((int )context->type) {
  case 0: 
#line 419
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, len);
#line 420
  break;
  case 3: 
#line 423
  SSH_3CBC_DECRYPT(context->u.des3.key1, context->u.des3.key2, & context->u.des3.iv2,
                   context->u.des3.key3, & context->u.des3.iv3, dest, (unsigned char *)src,
                   len);
#line 427
  break;
  case 6: 
#line 430
  swap_bytes(src, dest, (int )len);
#line 431
  BF_cbc_encrypt((unsigned char const   *)((void *)dest), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 434
  swap_bytes((unsigned char const   *)dest, dest, (int )len);
#line 435
  break;
  case 8: 
#line 438
  BF_cbc_encrypt((unsigned char const   *)((void *)src), dest, (long )len, (BF_KEY const   *)(& context->u.bf.key),
                 context->u.bf.iv, 0);
#line 441
  break;
  case 9: 
#line 444
  DES_ede3_cbc_encrypt(src, dest, (long )len, & context->u.des3.key1, & context->u.des3.key2,
                       & context->u.des3.key3, & context->u.des3.iv3, 0);
#line 447
  break;
  case 10: 
#line 450
  RC4(& context->u.rc4, (unsigned long )len, (unsigned char const   *)((unsigned char *)src),
      dest);
#line 451
  break;
  case 11: 
#line 454
  CAST_cbc_encrypt(src, dest, (long )len, & context->u.cast.key, context->u.cast.iv,
                   0);
#line 456
  break;
  default: 
#line 459
  tmp = cipher_name((int )context->type);
#line 459
  fatal("cipher_decrypt: unknown cipher: %s", tmp);
  }
#line 461
  return;
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 39 "compat.h"
void enable_compat13(void) ;
#line 40
void enable_compat20(void) ;
#line 41
void compat_datafellows(char const   *version ) ;
#line 42
int proto_spec(char const   *spec ) ;
#line 45
int datafellows ;
#line 38 "compat.c"
int compat13  =    0;
#line 39 "compat.c"
int compat20  =    0;
#line 40 "compat.c"
int datafellows  =    0;
#line 42 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 45
  verbose("Enabling compatibility mode for protocol 2.0");
#line 46
  compat20 = 1;
#line 47
  return;
}
}
#line 48 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 51
  verbose("Enabling compatibility mode for protocol 1.3");
#line 52
  compat13 = 1;
#line 53
  return;
}
}
#line 60 "compat.c"
static char const   *check[3]  = {      "2.0.1",      "2.1.0",      (char const   *)((void *)0)};
#line 55 "compat.c"
void compat_datafellows(char const   *version ) 
{ int i ;
  size_t len ;
  size_t tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 65
  i = 0;
#line 65
  while (check[i]) {
#line 66
    len = strlen(check[i]);
#line 67
    tmp = strlen(version);
#line 68
    if (tmp >= len) {
#line 68
      if (0) {
#line 68
        if (0) {
#line 68
          __s1_len___0 = strlen(version);
#line 68
          __s2_len___0 = strlen(check[i]);
#line 68
          if (! ((unsigned int )((void const   *)(version + 1)) - (unsigned int )((void const   *)version) == 1U)) {
            goto _L___2;
          } else {
#line 68
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 68
              if (! ((unsigned int )((void const   *)(check[i] + 1)) - (unsigned int )((void const   *)check[i]) == 1U)) {
#line 68
                tmp___23 = 1;
              } else {
#line 68
                if (__s2_len___0 >= 4U) {
#line 68
                  tmp___23 = 1;
                } else {
#line 68
                  tmp___23 = 0;
                }
              }
            } else {
#line 68
              tmp___23 = 0;
            }
          }
#line 68
          if (tmp___23) {
#line 68
            tmp___19 = __builtin_strcmp(version, check[i]);
          } else {
#line 68
            tmp___22 = __builtin_strcmp(version, check[i]);
#line 68
            tmp___19 = tmp___22;
          }
        } else {
#line 68
          tmp___22 = __builtin_strcmp(version, check[i]);
#line 68
          tmp___19 = tmp___22;
        }
#line 68
        tmp___13 = tmp___19;
      } else {
#line 68
        tmp___13 = strncmp(version, check[i], len);
      }
#line 68
      if (tmp___13 == 0) {
#line 69
        verbose("datafellows: %.200s", version);
#line 70
        datafellows = 1;
#line 71
        return;
      }
    }
#line 65
    i ++;
  }
#line 74
  return;
}
}
#line 77 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *tmp ;
  char *p ;
  int ret ;
  int tmp___0 ;

  {
#line 80
  tmp = xstrdup(spec);
#line 80
  s = tmp;
#line 82
  ret = 0;
#line 84
  p = strtok((char * __restrict  )s, (char const   * __restrict  )",");
#line 84
  while (p) {
#line 85
    tmp___0 = atoi((char const   *)p);
#line 85
    switch (tmp___0) {
    case 1: 
#line 87
    if (ret == 0) {
#line 88
      ret |= 2;
    }
#line 89
    ret |= 1;
#line 90
    break;
    case 2: 
#line 92
    ret |= 4;
#line 93
    break;
    default: 
#line 95
    log("ignoring bad proto spec: \'%s\'.", p);
#line 96
    break;
    }
#line 84
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
  }
#line 99
  xfree((void *)s);
#line 100
  return (ret);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 23 "compress.c"
static z_stream incoming_stream  ;
#line 24 "compress.c"
static z_stream outgoing_stream  ;
#line 31 "compress.c"
void buffer_compress_init(int level ) 
{ 

  {
#line 34
  debug("Enabling compression at level %d.", level);
#line 35
  if (level < 1) {
#line 36
    fatal("Bad compression level %d.", level);
  } else {
#line 35
    if (level > 9) {
#line 36
      fatal("Bad compression level %d.", level);
    }
  }
#line 37
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 38
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 39
  return;
}
}
#line 43 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 46
  if (outgoing_stream.total_in == 0UL) {
#line 46
    tmp = 0.0;
  } else {
#line 46
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 46
  debug("compress outgoing: raw data %lu, compressed %lu, factor %.2f", outgoing_stream.total_in,
        outgoing_stream.total_out, tmp);
#line 50
  if (incoming_stream.total_out == 0UL) {
#line 50
    tmp___0 = 0.0;
  } else {
#line 50
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 50
  debug("compress incoming: raw data %lu, compressed %lu, factor %.2f", incoming_stream.total_out,
        incoming_stream.total_in, tmp___0);
#line 54
  inflateEnd(& incoming_stream);
#line 55
  deflateEnd(& outgoing_stream);
#line 56
  return;
}
}
#line 67 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 74
  tmp = buffer_len(input_buffer);
#line 74
  if (tmp == 0U) {
#line 75
    return;
  }
#line 78
  tmp___0 = buffer_ptr(input_buffer);
#line 78
  outgoing_stream.next_in = (unsigned char *)tmp___0;
#line 79
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 82
  while (1) {
#line 84
    outgoing_stream.next_out = (unsigned char *)(buf___1);
#line 85
    outgoing_stream.avail_out = sizeof(buf___1);
#line 88
    status = deflate(& outgoing_stream, 1);
#line 89
    switch (status) {
    case 0: 
#line 92
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 94
    break;
    default: 
#line 96
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 82
    if (! (outgoing_stream.avail_out == 0U)) {
#line 82
      break;
    }
  }
#line 100
  return;
}
}
#line 111 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ char buf___1[4096] ;
  int status ;
  char *tmp ;

  {
#line 117
  tmp = buffer_ptr(input_buffer);
#line 117
  incoming_stream.next_in = (unsigned char *)tmp;
#line 118
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 120
  while (1) {
#line 122
    incoming_stream.next_out = (unsigned char *)(buf___1);
#line 123
    incoming_stream.avail_out = sizeof(buf___1);
#line 125
    status = inflate(& incoming_stream, 1);
#line 126
    switch (status) {
    case 0: 
#line 128
    buffer_append(output_buffer, (char const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 130
    break;
    case -5: 
#line 137
    return;
    default: 
#line 139
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 25 "crc32.h"
unsigned int crc32(unsigned char const   *s , unsigned int len ) ;
#line 53 "crc32.c"
static unsigned int crc32_tab[256]  = 
#line 53 "crc32.c"
  {      0U,      1996959894U,      3993919788U,      2567524794U, 
        124634137U,      1886057615U,      3915621685U,      2657392035U, 
        249268274U,      2044508324U,      3772115230U,      2547177864U, 
        162941995U,      2125561021U,      3887607047U,      2428444049U, 
        498536548U,      1789927666U,      4089016648U,      2227061214U, 
        450548861U,      1843258603U,      4107580753U,      2211677639U, 
        325883990U,      1684777152U,      4251122042U,      2321926636U, 
        335633487U,      1661365465U,      4195302755U,      2366115317U, 
        997073096U,      1281953886U,      3579855332U,      2724688242U, 
        1006888145U,      1258607687U,      3524101629U,      2768942443U, 
        901097722U,      1119000684U,      3686517206U,      2898065728U, 
        853044451U,      1172266101U,      3705015759U,      2882616665U, 
        651767980U,      1373503546U,      3369554304U,      3218104598U, 
        565507253U,      1454621731U,      3485111705U,      3099436303U, 
        671266974U,      1594198024U,      3322730930U,      2970347812U, 
        795835527U,      1483230225U,      3244367275U,      3060149565U, 
        1994146192U,      31158534U,      2563907772U,      4023717930U, 
        1907459465U,      112637215U,      2680153253U,      3904427059U, 
        2013776290U,      251722036U,      2517215374U,      3775830040U, 
        2137656763U,      141376813U,      2439277719U,      3865271297U, 
        1802195444U,      476864866U,      2238001368U,      4066508878U, 
        1812370925U,      453092731U,      2181625025U,      4111451223U, 
        1706088902U,      314042704U,      2344532202U,      4240017532U, 
        1658658271U,      366619977U,      2362670323U,      4224994405U, 
        1303535960U,      984961486U,      2747007092U,      3569037538U, 
        1256170817U,      1037604311U,      2765210733U,      3554079995U, 
        1131014506U,      879679996U,      2909243462U,      3663771856U, 
        1141124467U,      855842277U,      2852801631U,      3708648649U, 
        1342533948U,      654459306U,      3188396048U,      3373015174U, 
        1466479909U,      544179635U,      3110523913U,      3462522015U, 
        1591671054U,      702138776U,      2966460450U,      3352799412U, 
        1504918807U,      783551873U,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      62317068U,      1957810842U, 
        3939845945U,      2647816111U,      81470997U,      1943803523U, 
        3814918930U,      2489596804U,      225274430U,      2053790376U, 
        3826175755U,      2466906013U,      167816743U,      2097651377U, 
        4027552580U,      2265490386U,      503444072U,      1762050814U, 
        4150417245U,      2154129355U,      426522225U,      1852507879U, 
        4275313526U,      2312317920U,      282753626U,      1742555852U, 
        4189708143U,      2394877945U,      397917763U,      1622183637U, 
        3604390888U,      2714866558U,      953729732U,      1340076626U, 
        3518719985U,      2797360999U,      1068828381U,      1219638859U, 
        3624741850U,      2936675148U,      906185462U,      1090812512U, 
        3747672003U,      2825379669U,      829329135U,      1181335161U, 
        3412177804U,      3160834842U,      628085408U,      1382605366U, 
        3423369109U,      3138078467U,      570562233U,      1426400815U, 
        3317316542U,      2998733608U,      733239954U,      1555261956U, 
        3268935591U,      3050360625U,      752459403U,      1541320221U, 
        2607071920U,      3965973030U,      1969922972U,      40735498U, 
        2617837225U,      3943577151U,      1913087877U,      83908371U, 
        2512341634U,      3803740692U,      2075208622U,      213261112U, 
        2463272603U,      3855990285U,      2094854071U,      198958881U, 
        2262029012U,      4057260610U,      1759359992U,      534414190U, 
        2176718541U,      4139329115U,      1873836001U,      414664567U, 
        2282248934U,      4279200368U,      1711684554U,      285281116U, 
        2405801727U,      4167216745U,      1634467795U,      376229701U, 
        2685067896U,      3608007406U,      1308918612U,      956543938U, 
        2808555105U,      3495958263U,      1231636301U,      1047427035U, 
        2932959818U,      3654703836U,      1088359270U,      936918000U, 
        2847714899U,      3736837829U,      1202900863U,      817233897U, 
        3183342108U,      3401237130U,      1404277552U,      615818150U, 
        3134207493U,      3453421203U,      1423857449U,      601450431U, 
        3009837614U,      3294710456U,      1567103746U,      711928724U, 
        3020668471U,      3272380065U,      1510334235U,      755167117U};
#line 110 "crc32.c"
unsigned int crc32(unsigned char const   *s , unsigned int len ) 
{ unsigned int i ;
  unsigned int crc32val ;

  {
#line 116
  crc32val = 0U;
#line 117
  i = 0U;
#line 117
  while (i < len) {
#line 118
    crc32val = crc32_tab[(crc32val ^ (unsigned int )*(s + i)) & 255U] ^ (crc32val >> 8);
#line 117
    i ++;
  }
#line 120
  return (crc32val);
}
}
#line 1 "deattack.o"
#line 27 "deattack.h"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) ;
#line 49 "deattack.c"
void crc_update(u_int32_t *a , u_int32_t b ) 
{ 

  {
#line 52
  b ^= *a;
#line 53
  *a = crc32((unsigned char const   *)((unsigned char *)(& b)), sizeof(b));
#line 54
  return;
}
}
#line 57 "deattack.c"
int check_crc(unsigned char *S , unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ u_int32_t crc ;
  unsigned char *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 64
  crc = 0U;
#line 65
  if (IV) {
#line 65
    tmp = memcmp((void const   *)S, (void const   *)IV, 8U);
#line 65
    if (! tmp) {
#line 66
      crc_update(& crc, 1U);
#line 67
      crc_update(& crc, 0U);
    }
  }
#line 69
  c = buf___1;
#line 69
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 70
    tmp___0 = memcmp((void const   *)S, (void const   *)c, 8U);
#line 70
    if (tmp___0) {
#line 74
      crc_update(& crc, 0U);
#line 75
      crc_update(& crc, 0U);
    } else {
#line 71
      crc_update(& crc, 1U);
#line 72
      crc_update(& crc, 0U);
    }
#line 69
    c += 8;
  }
#line 78
  return (crc == 0U);
}
}
#line 86 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 87 "deattack.c"
static u_int16_t n  =    (u_int16_t )4096;
#line 83 "deattack.c"
int detect_attack(unsigned char *buf___1 , u_int32_t len , unsigned char *IV ) 
{ register u_int32_t i ;
  register u_int32_t j ;
  u_int32_t l ;
  register unsigned char *c ;
  unsigned char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (len > 262144U) {
#line 95
    fatal("detect_attack: bad length %d", len);
  } else {
#line 93
    if (len % 8U != 0U) {
#line 95
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 97
  l = (unsigned int )n;
#line 97
  while (l < ((len / 8U) * 3U) / 2U) {
#line 97
    l <<= 2;
  }
#line 100
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 101
    debug("Installing crc compensation attack detector.");
#line 102
    n = (unsigned short )l;
#line 103
    tmp = xmalloc((unsigned int )((int )n * 2));
#line 103
    h = (u_int16_t *)tmp;
  } else {
#line 105
    if (l > (u_int32_t )n) {
#line 106
      n = (unsigned short )l;
#line 107
      tmp___0 = xrealloc((void *)h, (unsigned int )((int )n * 2));
#line 107
      h = (u_int16_t *)tmp___0;
    }
  }
#line 111
  if (len <= 56U) {
#line 112
    c = buf___1;
#line 112
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 113
      if (IV) {
#line 113
        tmp___2 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 113
        if (! tmp___2) {
#line 114
          tmp___1 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 114
          if (tmp___1) {
#line 115
            return (1);
          } else {
#line 117
            break;
          }
        }
      }
#line 119
      d = buf___1;
#line 119
      while ((unsigned int )d < (unsigned int )c) {
#line 120
        tmp___4 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 120
        if (! tmp___4) {
#line 121
          tmp___3 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 121
          if (tmp___3) {
#line 122
            return (1);
          } else {
#line 124
            break;
          }
        }
#line 119
        d += 8;
      }
#line 112
      c += 8;
    }
#line 128
    return (0);
  }
#line 130
  memset((void *)h, 255, (unsigned int )((int )n * 2));
#line 132
  if (IV) {
#line 133
    *(h + ((((((unsigned long )*(IV + 0) << 24) | ((unsigned long )*(IV + 1) << 16)) | ((unsigned long )*(IV + 2) << 8)) | (unsigned long )*(IV + 3)) & (unsigned long )((int )n - 1))) = (unsigned short)65534;
  }
#line 135
  c = buf___1;
#line 135
  j = 0U;
#line 135
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 136
    i = (unsigned int )((((((unsigned long )*(c + 0) << 24) | ((unsigned long )*(c + 1) << 16)) | ((unsigned long )*(c + 2) << 8)) | (unsigned long )*(c + 3)) & (unsigned long )((int )n - 1));
#line 136
    while ((int )*(h + i) != 65535) {
#line 138
      if ((int )*(h + i) == 65534) {
#line 139
        tmp___6 = memcmp((void const   *)c, (void const   *)IV, 8U);
#line 139
        if (! tmp___6) {
#line 140
          tmp___5 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 140
          if (tmp___5) {
#line 141
            return (1);
          } else {
#line 143
            break;
          }
        }
      } else {
#line 145
        tmp___8 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                         8U);
#line 145
        if (! tmp___8) {
#line 146
          tmp___7 = check_crc(c, buf___1, len, (unsigned char *)IV);
#line 146
          if (tmp___7) {
#line 147
            return (1);
          } else {
#line 149
            break;
          }
        }
      }
#line 136
      i = (i + 1U) & (unsigned int )((int )n - 1);
    }
#line 152
    *(h + i) = (unsigned short )j;
#line 135
    c += 8;
#line 135
    j ++;
  }
#line 154
  return (0);
}
}
#line 1 "dispatch.o"
#line 8 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 9
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 10
void dispatch_run(int mode , int *done ) ;
#line 11
void dispatch_protocol_error(int type , int plen ) ;
#line 100 "packet.h"
int packet_read(int *payload_len_ptr ) ;
#line 116
int packet_read_poll(int *payload_len_ptr ) ;
#line 38 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 40 "dispatch.c"
void dispatch_protocol_error(int type , int plen ) 
{ 

  {
#line 43
  error("Hm, dispatch protocol error: type %d plen %d", type, plen);
#line 44
  return;
}
}
#line 45 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ int i ;

  {
#line 49
  i = 0;
#line 49
  while (i < 255) {
#line 50
    dispatch[i] = dflt;
#line 49
    i ++;
  }
#line 51
  return;
}
}
#line 52 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 55
  dispatch[type] = fn;
#line 56
  return;
}
}
#line 57 "dispatch.c"
void dispatch_run(int mode , int *done ) 
{ int plen ;
  int type ;

  {
#line 60
  while (1) {
#line 64
    if (mode == 0) {
#line 65
      type = packet_read(& plen);
    } else {
#line 67
      type = packet_read_poll(& plen);
#line 68
      if (type == 0) {
#line 69
        return;
      }
    }
#line 71
    if (type > 0) {
#line 71
      if (type < 255) {
#line 71
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 72
          (*(dispatch[type]))(type, plen);
        } else {
#line 74
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 74
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 74
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 75
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 75
      if (*done) {
#line 76
        return;
      }
    }
  }
}
}
#line 1 "dsa.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 597
extern EVP_MD const   *EVP_sha1(void) ;
#line 16 "key.h"
Key *key_new(int type ) ;
#line 17
void key_free(Key *k ) ;
#line 55 "dsa.c"
Key *dsa_key_from_blob(char *blob , int blen ) 
{ Buffer b ;
  char *ktype ;
  int rlen ;
  DSA *dsa ;
  Key *key ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 69
  key = key_new(1);
#line 70
  dsa = key->dsa;
#line 71
  buffer_init(& b);
#line 72
  buffer_append(& b, (char const   *)blob, (unsigned int )blen);
#line 73
  ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 74
  if (0) {
#line 74
    __s1_len = strlen("ssh-dss");
#line 74
    __s2_len = strlen((char const   *)ktype);
#line 74
    if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
      goto _L___0;
    } else {
#line 74
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 74
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 74
          tmp___8 = 1;
        } else {
#line 74
          if (__s2_len >= 4U) {
#line 74
            tmp___8 = 1;
          } else {
#line 74
            tmp___8 = 0;
          }
        }
      } else {
#line 74
        tmp___8 = 0;
      }
    }
#line 74
    if (tmp___8) {
#line 74
      tmp___4 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
    } else {
#line 74
      tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 74
      tmp___4 = tmp___7;
    }
  } else {
#line 74
    tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 74
    tmp___4 = tmp___7;
  }
#line 74
  if (tmp___4 != 0) {
#line 75
    error("dsa_key_from_blob: cannot handle type  %s", ktype);
#line 76
    key_free(key);
#line 77
    return ((Key *)((void *)0));
  }
#line 79
  buffer_get_bignum2(& b, dsa->p);
#line 80
  buffer_get_bignum2(& b, dsa->q);
#line 81
  buffer_get_bignum2(& b, dsa->g);
#line 82
  buffer_get_bignum2(& b, dsa->pub_key);
#line 83
  tmp___9 = buffer_len(& b);
#line 83
  rlen = (int )tmp___9;
#line 84
  if (rlen != 0) {
#line 85
    error("dsa_key_from_blob: remaining bytes in key blob %d", rlen);
  }
#line 86
  buffer_free(& b);
#line 88
  debug("keytype %s", ktype);
#line 92
  return (key);
}
}
#line 94 "dsa.c"
int dsa_make_key_blob(Key *key , unsigned char **blobp , unsigned int *lenp ) 
{ Buffer b ;
  int len ;
  unsigned char *buf___1 ;
  unsigned int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 101
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 102
    return (0);
  } else {
#line 101
    if (key->type != 1) {
#line 102
      return (0);
    }
  }
#line 103
  buffer_init(& b);
#line 104
  buffer_put_cstring(& b, "ssh-dss");
#line 105
  buffer_put_bignum2(& b, (key->dsa)->p);
#line 106
  buffer_put_bignum2(& b, (key->dsa)->q);
#line 107
  buffer_put_bignum2(& b, (key->dsa)->g);
#line 108
  buffer_put_bignum2(& b, (key->dsa)->pub_key);
#line 109
  tmp = buffer_len(& b);
#line 109
  len = (int )tmp;
#line 110
  tmp___0 = xmalloc((unsigned int )len);
#line 110
  buf___1 = (unsigned char *)tmp___0;
#line 111
  tmp___1 = buffer_ptr(& b);
#line 111
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )tmp___1, (unsigned int )len);
#line 112
  tmp___2 = buffer_ptr(& b);
#line 112
  memset((void *)tmp___2, 0, (unsigned int )len);
#line 113
  buffer_free(& b);
#line 114
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 115
    *lenp = (unsigned int )len;
  }
#line 116
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 117
    *blobp = buf___1;
  }
#line 118
  return (len);
}
}
#line 120 "dsa.c"
int dsa_sign(Key *key , unsigned char **sigp , int *lenp , unsigned char *data , int datalen ) 
{ unsigned char *digest___0 ;
  unsigned char *ret ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  unsigned int rlen ;
  unsigned int slen ;
  unsigned int len ;
  unsigned char sigblob[40] ;
  Buffer b ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 129
  tmp = EVP_sha1();
#line 129
  evp_md = (EVP_MD *)tmp;
#line 137
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 138
    error("dsa_sign: no DSA key");
#line 139
    return (-1);
  } else {
#line 137
    if (key->type != 1) {
#line 138
      error("dsa_sign: no DSA key");
#line 139
      return (-1);
    } else {
#line 137
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 138
        error("dsa_sign: no DSA key");
#line 139
        return (-1);
      }
    }
  }
#line 141
  tmp___0 = xmalloc((unsigned int )evp_md->md_size);
#line 141
  digest___0 = (unsigned char *)tmp___0;
#line 142
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 143
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 144
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 146
  sig = DSA_do_sign((unsigned char const   *)digest___0, evp_md->md_size, key->dsa);
#line 147
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 148
    fatal("dsa_sign: cannot sign");
  }
#line 151
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->r);
#line 151
  rlen = (unsigned int )((tmp___1 + 7) / 8);
#line 152
  tmp___2 = BN_num_bits((BIGNUM const   *)sig->s);
#line 152
  slen = (unsigned int )((tmp___2 + 7) / 8);
#line 153
  if (rlen > 20U) {
#line 154
    error("bad sig size %d %d", rlen, slen);
#line 155
    DSA_SIG_free(sig);
#line 156
    return (-1);
  } else {
#line 153
    if (slen > 20U) {
#line 154
      error("bad sig size %d %d", rlen, slen);
#line 155
      DSA_SIG_free(sig);
#line 156
      return (-1);
    }
  }
#line 158
  debug("sig size %d %d", rlen, slen);
#line 160
  memset((void *)(sigblob), 0, 40U);
#line 161
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 162
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 163
  DSA_SIG_free(sig);
#line 165
  if (datafellows) {
#line 166
    debug("datafellows");
#line 167
    tmp___3 = xmalloc(40U);
#line 167
    ret = (unsigned char *)tmp___3;
#line 168
    memcpy((void * __restrict  )ret, (void const   * __restrict  )(sigblob), 40U);
#line 169
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 170
      *lenp = 40;
    }
#line 171
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 172
      *sigp = ret;
    }
  } else {
#line 175
    buffer_init(& b);
#line 176
    buffer_put_cstring(& b, "ssh-dss");
#line 177
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 178
    len = buffer_len(& b);
#line 179
    tmp___4 = xmalloc(len);
#line 179
    ret = (unsigned char *)tmp___4;
#line 180
    tmp___5 = buffer_ptr(& b);
#line 180
    memcpy((void * __restrict  )ret, (void const   * __restrict  )tmp___5, len);
#line 181
    buffer_free(& b);
#line 182
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 183
      *lenp = (int )len;
    }
#line 184
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 185
      *sigp = ret;
    }
  }
#line 187
  return (0);
}
}
#line 189 "dsa.c"
int dsa_verify(Key *key , unsigned char *signature , int signaturelen , unsigned char *data ,
               int datalen ) 
{ Buffer b ;
  unsigned char *digest___0 ;
  DSA_SIG *sig ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char *ktype ;
  unsigned char *sigblob ;
  char *txt ;
  unsigned int len ;
  int rlen ;
  int ret ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;

  {
#line 198
  tmp = EVP_sha1();
#line 198
  evp_md = (EVP_MD *)tmp;
#line 207
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 208
    error("dsa_verify: no DSA key");
#line 209
    return (-1);
  } else {
#line 207
    if (key->type != 1) {
#line 208
      error("dsa_verify: no DSA key");
#line 209
      return (-1);
    } else {
#line 207
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 208
        error("dsa_verify: no DSA key");
#line 209
        return (-1);
      }
    }
  }
#line 212
  if (datafellows) {
#line 212
    if (signaturelen != 40) {
#line 213
      log("heh? datafellows ssh2 complies with ietf-drafts????");
#line 214
      datafellows = 0;
    }
  }
#line 217
  debug("len %d datafellows %d", signaturelen, datafellows);
#line 220
  if (datafellows) {
#line 221
    sigblob = signature;
#line 222
    len = (unsigned int )signaturelen;
  } else {
#line 225
    buffer_init(& b);
#line 226
    buffer_append(& b, (char const   *)((char *)signature), (unsigned int )signaturelen);
#line 227
    ktype = buffer_get_string(& b, (unsigned int *)((void *)0));
#line 228
    tmp___0 = buffer_get_string(& b, & len);
#line 228
    sigblob = (unsigned char *)tmp___0;
#line 229
    tmp___1 = buffer_len(& b);
#line 229
    rlen = (int )tmp___1;
#line 230
    if (rlen != 0) {
#line 231
      error("remaining bytes in signature %d", rlen);
    }
#line 232
    buffer_free(& b);
  }
#line 235
  if (len != 40U) {
#line 236
    fatal("bad sigbloblen %d != SIGBLOB_LEN", len);
  }
#line 240
  sig = DSA_SIG_new();
#line 241
  sig->r = BN_new();
#line 242
  sig->s = BN_new();
#line 243
  BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 244
  BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 245
  if (! datafellows) {
#line 246
    memset((void *)sigblob, 0, len);
#line 247
    xfree((void *)sigblob);
  }
#line 251
  tmp___2 = xmalloc((unsigned int )evp_md->md_size);
#line 251
  digest___0 = (unsigned char *)tmp___2;
#line 252
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 253
  EVP_DigestUpdate(& md, (void const   *)data, (unsigned int )datalen);
#line 254
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 256
  ret = DSA_do_verify((unsigned char const   *)digest___0, evp_md->md_size, sig, key->dsa);
#line 258
  memset((void *)digest___0, 0, (unsigned int )evp_md->md_size);
#line 259
  xfree((void *)digest___0);
#line 260
  DSA_SIG_free(sig);
#line 262
  switch (ret) {
  case 1: 
#line 264
  txt = (char *)"correct";
#line 265
  break;
  case 0: 
#line 267
  txt = (char *)"incorrect";
#line 268
  break;
  case -1: 
  default: 
#line 271
  txt = (char *)"error";
#line 272
  break;
  }
#line 274
  debug("dsa_verify: signature %s", txt);
#line 275
  return (ret);
}
}
#line 278 "dsa.c"
Key *dsa_generate_key(unsigned int bits ) 
{ DSA *dsa ;
  DSA *tmp ;
  Key *k ;
  int tmp___0 ;

  {
#line 281
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 281
  dsa = tmp;
#line 283
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 284
    fatal("DSA_generate_parameters failed");
  }
#line 286
  tmp___0 = DSA_generate_key(dsa);
#line 286
  if (! tmp___0) {
#line 287
    fatal("DSA_generate_keys failed");
  }
#line 290
  k = key_new(2);
#line 291
  k->type = 1;
#line 292
  k->dsa = dsa;
#line 293
  return (k);
}
}
#line 1 "fake-getaddrinfo.o"
#line 1 "fake-getnameinfo.o"
#line 1 "fingerprint.o"
#line 46 "fingerprint.c"
static char retval[80]  ;
#line 43 "fingerprint.c"
char *fingerprint(BIGNUM *e , BIGNUM *n___0 ) 
{ MD5_CTX md ;
  unsigned char d[16] ;
  unsigned char *buf___1 ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 52
  tmp = BN_num_bits((BIGNUM const   *)n___0);
#line 52
  nlen = (tmp + 7) / 8;
#line 53
  tmp___0 = BN_num_bits((BIGNUM const   *)e);
#line 53
  elen = (tmp___0 + 7) / 8;
#line 55
  tmp___1 = xmalloc((unsigned int )(nlen + elen));
#line 55
  buf___1 = (unsigned char *)tmp___1;
#line 57
  BN_bn2bin((BIGNUM const   *)n___0, buf___1);
#line 58
  BN_bn2bin((BIGNUM const   *)e, buf___1 + nlen);
#line 60
  MD5_Init(& md);
#line 61
  MD5_Update(& md, (void const   *)buf___1, (unsigned int )(nlen + elen));
#line 62
  MD5_Final(d, & md);
#line 63
  snprintf((char * __restrict  )(retval), sizeof(retval), (char const   * __restrict  )"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
           d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11],
           d[12], d[13], d[14], d[15]);
#line 66
  memset((void *)buf___1, 0, (unsigned int )(nlen + elen));
#line 67
  xfree((void *)buf___1);
#line 68
  return (retval);
}
}
#line 1 "hmac.o"
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 47 "hmac.c"
static unsigned char m[64]  ;
#line 39 "hmac.c"
unsigned char *hmac(EVP_MD *evp_md , unsigned int seqno , unsigned char *data , int datalen ,
                    unsigned char *key , int keylen ) 
{ HMAC_CTX c ;
  unsigned char b[4] ;

  {
#line 50
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 51
    fatal("hmac: no key");
  }
#line 52
  HMAC_Init(& c, (void const   *)key, keylen, (EVP_MD const   *)evp_md);
#line 53
  while (1) {
#line 53
    b[0] = (unsigned char )(seqno >> 24);
#line 53
    b[1] = (unsigned char )(seqno >> 16);
#line 53
    b[2] = (unsigned char )(seqno >> 8);
#line 53
    b[3] = (unsigned char )seqno;
#line 53
    break;
  }
#line 54
  HMAC_Update(& c, (unsigned char const   *)(b), sizeof(b));
#line 55
  HMAC_Update(& c, (unsigned char const   *)data, (unsigned int )datalen);
#line 56
  HMAC_Final(& c, m, (unsigned int *)((void *)0));
#line 57
  HMAC_CTX_cleanup(& c);
#line 58
  return (m);
}
}
#line 1 "hostfile.o"
#line 248 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 532
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 16 "match.h"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) ;
#line 381 "ssh.h"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) ;
#line 18 "key.h"
int key_equal(Key *a , Key *b ) ;
#line 21
int key_write(Key *key , FILE *f ) ;
#line 22
unsigned int key_read(Key *ret , char **cpp ) ;
#line 13 "hostfile.h"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) ;
#line 20
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) ;
#line 32 "hostfile.c"
int hostfile_read_key(char **cpp , unsigned int *bitsp , Key *ret ) 
{ unsigned int bits ;
  char *cp ;

  {
#line 39
  cp = *cpp;
#line 39
  while (1) {
#line 39
    if (! ((int )*cp == 32)) {
#line 39
      if (! ((int )*cp == 9)) {
#line 39
        break;
      }
    }
#line 39
    cp ++;
  }
#line 42
  bits = key_read(ret, & cp);
#line 43
  if (bits == 0U) {
#line 44
    return (0);
  }
#line 47
  while (1) {
#line 47
    if (! ((int )*cp == 32)) {
#line 47
      if (! ((int )*cp == 9)) {
#line 47
        break;
      }
    }
#line 47
    cp ++;
  }
#line 51
  *cpp = cp;
#line 52
  *bitsp = bits;
#line 53
  return (1);
}
}
#line 56 "hostfile.c"
int auth_rsa_read_key(char **cpp , unsigned int *bitsp , BIGNUM *e , BIGNUM *n___0 ) 
{ Key *k ;
  Key *tmp ;
  int ret ;
  int tmp___0 ;

  {
#line 59
  tmp = key_new(0);
#line 59
  k = tmp;
#line 60
  tmp___0 = hostfile_read_key(cpp, bitsp, k);
#line 60
  ret = tmp___0;
#line 61
  BN_copy(e, (BIGNUM const   *)(k->rsa)->e);
#line 62
  BN_copy(n___0, (BIGNUM const   *)(k->rsa)->n);
#line 63
  key_free(k);
#line 64
  return (ret);
}
}
#line 67 "hostfile.c"
int hostfile_check_key(int bits , Key *key , char const   *host , char const   *filename ,
                       int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 70
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 71
    return (1);
  } else {
#line 70
    if (key->type != 0) {
#line 71
      return (1);
    } else {
#line 70
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 71
        return (1);
      }
    }
  }
#line 72
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 72
  if (bits != tmp___1) {
#line 73
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 73
    log("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
        filename, linenum, host, tmp, bits);
#line 76
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 76
    log("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename, linenum);
  }
#line 79
  return (1);
}
}
#line 89 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key *key ,
                                  Key *found ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  unsigned int kbits ;
  unsigned int hostlen ;
  char *cp ;
  char *cp2 ;
  HostStatus end_return ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 94
  linenum = 0;
#line 99
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 100
    fatal("no key to look up");
  }
#line 102
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 103
  if (! f) {
#line 104
    return (1);
  }
#line 107
  hostlen = strlen(host);
#line 114
  end_return = 1;
#line 117
  while (1) {
#line 117
    tmp___3 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 117
    if (! tmp___3) {
#line 117
      break;
    }
#line 118
    cp = line;
#line 119
    linenum ++;
#line 122
    while (1) {
#line 122
      if (! ((int )*cp == 32)) {
#line 122
        if (! ((int )*cp == 9)) {
#line 122
          break;
        }
      }
#line 122
      cp ++;
    }
#line 124
    if (! *cp) {
#line 125
      continue;
    } else {
#line 124
      if ((int )*cp == 35) {
#line 125
        continue;
      } else {
#line 124
        if ((int )*cp == 10) {
#line 125
          continue;
        }
      }
    }
#line 128
    cp2 = cp;
#line 128
    while (1) {
#line 128
      if (*cp2) {
#line 128
        if ((int )*cp2 != 32) {
#line 128
          if (! ((int )*cp2 != 9)) {
#line 128
            break;
          }
        } else {
#line 128
          break;
        }
      } else {
#line 128
        break;
      }
#line 128
      cp2 ++;
    }
#line 132
    tmp = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 132
    if (! tmp) {
#line 133
      continue;
    }
#line 136
    cp = cp2;
#line 142
    tmp___0 = hostfile_read_key(& cp, & kbits, found);
#line 142
    if (! tmp___0) {
#line 143
      continue;
    }
#line 144
    tmp___1 = hostfile_check_key((int )kbits, found, host, filename, linenum);
#line 144
    if (! tmp___1) {
#line 145
      continue;
    }
#line 148
    tmp___2 = key_equal(key, found);
#line 148
    if (tmp___2) {
#line 150
      fclose(f);
#line 151
      return (0);
    }
#line 158
    end_return = 2;
  }
#line 161
  fclose(f);
#line 167
  return (end_return);
}
}
#line 175 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key *key ) 
{ FILE *f ;
  int success ;
  int tmp ;

  {
#line 179
  success = 0;
#line 180
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 181
    return (1);
  }
#line 182
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 183
  if (! f) {
#line 184
    return (0);
  }
#line 185
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", host);
#line 186
  tmp = key_write(key, f);
#line 186
  if (tmp) {
#line 187
    success = 1;
  } else {
#line 189
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 191
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 192
  fclose(f);
#line 193
  return (success);
}
}
#line 1 "key.o"
#line 603 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 593 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_md5(void) ;
#line 19 "key.h"
char *key_fingerprint(Key *k ) ;
#line 20
char *key_type(Key *k ) ;
#line 3 "uuencode.h"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) ;
#line 4
int uudecode(char const   *src , unsigned char *target , size_t targsize ) ;
#line 46 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 52
  tmp = xmalloc(sizeof(*k));
#line 52
  k = (Key *)tmp;
#line 53
  k->type = type;
#line 54
  k->dsa = (DSA *)((void *)0);
#line 55
  k->rsa = (RSA *)((void *)0);
#line 56
  switch (k->type) {
  case 0: 
#line 58
  rsa = RSA_new();
#line 59
  rsa->n = BN_new();
#line 60
  rsa->e = BN_new();
#line 61
  k->rsa = rsa;
#line 62
  break;
  case 1: 
#line 64
  dsa = DSA_new();
#line 65
  dsa->p = BN_new();
#line 66
  dsa->q = BN_new();
#line 67
  dsa->g = BN_new();
#line 68
  dsa->pub_key = BN_new();
#line 69
  k->dsa = dsa;
#line 70
  break;
  case 2: 
#line 72
  break;
  default: 
#line 74
  fatal("key_new: bad key type %d", k->type);
#line 75
  break;
  }
#line 77
  return (k);
}
}
#line 79 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 82
  switch (k->type) {
  case 0: 
#line 84
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 85
    RSA_free(k->rsa);
  }
#line 86
  k->rsa = (RSA *)((void *)0);
#line 87
  break;
  case 1: 
#line 89
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 90
    DSA_free(k->dsa);
  }
#line 91
  k->dsa = (DSA *)((void *)0);
#line 92
  break;
  default: 
#line 94
  fatal("key_free: bad key type %d", k->type);
#line 95
  break;
  }
#line 97
  xfree((void *)k);
#line 98
  return;
}
}
#line 99 "key.c"
int key_equal(Key *a , Key *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 102
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 103
    return (0);
  } else {
#line 102
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 103
      return (0);
    } else {
#line 102
      if (a->type != b->type) {
#line 103
        return (0);
      }
    }
  }
#line 104
  switch (a->type) {
  case 0: 
#line 106
  if ((unsigned int )a->rsa != (unsigned int )((void *)0)) {
#line 106
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 106
      tmp = BN_cmp((BIGNUM const   *)(a->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 106
      if (tmp == 0) {
#line 106
        tmp___0 = BN_cmp((BIGNUM const   *)(a->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 106
        if (tmp___0 == 0) {
#line 106
          tmp___1 = 1;
        } else {
#line 106
          tmp___1 = 0;
        }
      } else {
#line 106
        tmp___1 = 0;
      }
    } else {
#line 106
      tmp___1 = 0;
    }
  } else {
#line 106
    tmp___1 = 0;
  }
#line 106
  return (tmp___1);
#line 109
  break;
  case 1: 
#line 111
  if ((unsigned int )a->dsa != (unsigned int )((void *)0)) {
#line 111
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 111
      tmp___2 = BN_cmp((BIGNUM const   *)(a->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 111
      if (tmp___2 == 0) {
#line 111
        tmp___3 = BN_cmp((BIGNUM const   *)(a->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 111
        if (tmp___3 == 0) {
#line 111
          tmp___4 = BN_cmp((BIGNUM const   *)(a->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 111
          if (tmp___4 == 0) {
#line 111
            tmp___5 = BN_cmp((BIGNUM const   *)(a->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 111
            if (tmp___5 == 0) {
#line 111
              tmp___6 = 1;
            } else {
#line 111
              tmp___6 = 0;
            }
          } else {
#line 111
            tmp___6 = 0;
          }
        } else {
#line 111
          tmp___6 = 0;
        }
      } else {
#line 111
        tmp___6 = 0;
      }
    } else {
#line 111
      tmp___6 = 0;
    }
  } else {
#line 111
    tmp___6 = 0;
  }
#line 111
  return (tmp___6);
#line 116
  break;
  default: 
#line 118
  fatal("key_equal: bad key type %d", a->type);
#line 119
  break;
  }
#line 121
  return (0);
}
}
#line 133 "key.c"
static char retval___0[80]  ;
#line 130 "key.c"
char *key_fingerprint(Key *k ) 
{ unsigned char *blob ;
  int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned char d[16] ;
  EVP_MD_CTX md ;
  EVP_MD const   *tmp___2 ;

  {
#line 134
  blob = (unsigned char *)((void *)0);
#line 135
  len = 0;
#line 138
  switch (k->type) {
  case 0: 
#line 140
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 140
  nlen = (tmp + 7) / 8;
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 141
  elen = (tmp___0 + 7) / 8;
#line 142
  len = nlen + elen;
#line 143
  tmp___1 = xmalloc((unsigned int )len);
#line 143
  blob = (unsigned char *)tmp___1;
#line 144
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 145
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 146
  break;
  case 1: 
#line 148
  dsa_make_key_blob(k, & blob, (unsigned int *)(& len));
#line 149
  break;
  default: 
#line 151
  fatal("key_fingerprint: bad key type %d", k->type);
#line 152
  break;
  }
#line 154
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 157
    tmp___2 = EVP_md5();
#line 157
    EVP_DigestInit(& md, tmp___2);
#line 158
    EVP_DigestUpdate(& md, (void const   *)blob, (unsigned int )len);
#line 159
    EVP_DigestFinal(& md, d, (unsigned int *)((void *)0));
#line 160
    snprintf((char * __restrict  )(retval___0), sizeof(retval___0), (char const   * __restrict  )"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
             d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11],
             d[12], d[13], d[14], d[15]);
#line 163
    memset((void *)blob, 0, (unsigned int )len);
#line 164
    xfree((void *)blob);
  }
#line 166
  return (retval___0);
}
}
#line 176 "key.c"
int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 179
  cp = *cpp;
#line 183
  while (1) {
#line 183
    if (! ((int )*cp == 32)) {
#line 183
      if (! ((int )*cp == 9)) {
#line 183
        break;
      }
    }
#line 183
    cp ++;
  }
#line 187
  if ((int )*cp < 48) {
#line 188
    return (0);
  } else {
#line 187
    if ((int )*cp > 57) {
#line 188
      return (0);
    }
  }
#line 191
  *cpp = cp;
#line 194
  while (1) {
#line 194
    if ((int )*cp >= 48) {
#line 194
      if (! ((int )*cp <= 57)) {
#line 194
        break;
      }
    } else {
#line 194
      break;
    }
#line 194
    cp ++;
  }
#line 198
  old = (int )*cp;
#line 199
  *cp = (char)0;
#line 202
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 202
  if (tmp == 0) {
#line 203
    return (0);
  }
#line 206
  *cp = (char )old;
#line 209
  *cpp = cp;
#line 210
  return (1);
}
}
#line 212 "key.c"
int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 215
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 215
  buf___1 = tmp;
#line 216
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 217
    error("write_bignum: BN_bn2dec() failed");
#line 218
    return (0);
  }
#line 220
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 221
  free((void *)buf___1);
#line 222
  return (1);
}
}
#line 224 "key.c"
unsigned int key_read(Key *ret , char **cpp ) 
{ Key *k ;
  unsigned int bits ;
  char *cp ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  int tmp ;
  int tmp___0 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  int tmp___29 ;
  char *tmp___31 ;

  {
#line 228
  bits = 0U;
#line 233
  cp = *cpp;
#line 235
  switch (ret->type) {
  case 0: 
#line 238
  if ((int )*cp < 48) {
#line 239
    return (0U);
  } else {
#line 238
    if ((int )*cp > 57) {
#line 239
      return (0U);
    }
  }
#line 240
  bits = 0U;
#line 240
  while (1) {
#line 240
    if ((int )*cp >= 48) {
#line 240
      if (! ((int )*cp <= 57)) {
#line 240
        break;
      }
    } else {
#line 240
      break;
    }
#line 241
    bits = (10U * bits + (unsigned int )*cp) - 48U;
#line 240
    cp ++;
  }
#line 242
  if (bits == 0U) {
#line 243
    return (0U);
  }
#line 244
  *cpp = cp;
#line 246
  tmp = read_bignum(cpp, (ret->rsa)->e);
#line 246
  if (! tmp) {
#line 247
    return (0U);
  }
#line 248
  tmp___0 = read_bignum(cpp, (ret->rsa)->n);
#line 248
  if (! tmp___0) {
#line 249
    return (0U);
  }
#line 250
  break;
  case 1: 
#line 252
  if (0) {
#line 252
    if (0) {
#line 252
      __s1_len___0 = strlen((char const   *)cp);
#line 252
      __s2_len___0 = strlen("ssh-dss ");
#line 252
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___2;
      } else {
#line 252
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 252
          if (! ((unsigned int )((void const   *)("ssh-dss " + 1)) - (unsigned int )((void const   *)"ssh-dss ") == 1U)) {
#line 252
            tmp___24 = 1;
          } else {
#line 252
            if (__s2_len___0 >= 4U) {
#line 252
              tmp___24 = 1;
            } else {
#line 252
              tmp___24 = 0;
            }
          }
        } else {
#line 252
          tmp___24 = 0;
        }
      }
#line 252
      if (tmp___24) {
#line 252
        tmp___20 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
      } else {
#line 252
        tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 252
        tmp___20 = tmp___23;
      }
    } else {
#line 252
      tmp___23 = __builtin_strcmp((char const   *)cp, "ssh-dss ");
#line 252
      tmp___20 = tmp___23;
    }
#line 252
    tmp___14 = tmp___20;
  } else {
#line 252
    tmp___14 = strncmp((char const   *)cp, "ssh-dss ", 7U);
  }
#line 252
  if (tmp___14 != 0) {
#line 253
    return (0U);
  }
#line 254
  cp += 7;
#line 255
  tmp___27 = strlen((char const   *)cp);
#line 255
  len = (int )(2U * tmp___27);
#line 256
  tmp___28 = xmalloc((unsigned int )len);
#line 256
  blob = (unsigned char *)tmp___28;
#line 257
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 258
  if (n___0 < 0) {
#line 259
    error("uudecode %s failed", cp);
#line 260
    return (0U);
  }
#line 262
  k = dsa_key_from_blob((char *)blob, n___0);
#line 263
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 264
    return (0U);
  }
#line 265
  xfree((void *)blob);
#line 266
  if ((unsigned int )ret->dsa != (unsigned int )((void *)0)) {
#line 267
    DSA_free(ret->dsa);
  }
#line 268
  ret->dsa = k->dsa;
#line 269
  k->dsa = (DSA *)((void *)0);
#line 270
  key_free(k);
#line 271
  tmp___29 = BN_num_bits((BIGNUM const   *)(ret->dsa)->p);
#line 271
  bits = (unsigned int )tmp___29;
#line 272
  tmp___31 = __builtin_strchr(cp, '=');
#line 272
  cp = tmp___31;
#line 273
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 274
    return (0U);
  }
#line 275
  *cpp = cp + 1;
#line 276
  break;
  default: 
#line 278
  fatal("key_read: bad key type: %d", ret->type);
#line 279
  break;
  }
#line 281
  return (bits);
}
}
#line 283 "key.c"
int key_write(Key *key , FILE *f ) 
{ int success ;
  unsigned int bits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  int n___0 ;
  unsigned char *blob ;
  unsigned char *uu ;
  void *tmp___2 ;

  {
#line 286
  success = 0;
#line 287
  bits = 0U;
#line 289
  if (key->type == 0) {
#line 289
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 291
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 291
      bits = (unsigned int )tmp;
#line 292
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 293
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 293
      if (tmp___0) {
#line 293
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 293
        if (tmp___1) {
#line 295
          success = 1;
        } else {
#line 297
          error("key_write: failed for RSA key");
        }
      } else {
#line 297
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 299
    if (key->type == 1) {
#line 299
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
#line 302
        dsa_make_key_blob(key, & blob, (unsigned int *)(& len));
#line 303
        tmp___2 = xmalloc((unsigned int )(2 * len));
#line 303
        uu = (unsigned char *)tmp___2;
#line 304
        n___0 = uuencode(blob, (unsigned int )len, (char *)uu, (unsigned int )(2 * len));
#line 305
        if (n___0 > 0) {
#line 306
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s", "ssh-dss",
                  uu);
#line 307
          success = 1;
        }
#line 309
        xfree((void *)blob);
#line 310
        xfree((void *)uu);
      }
    }
  }
#line 312
  return (success);
}
}
#line 314 "key.c"
char *key_type(Key *k ) 
{ 

  {
#line 317
  switch (k->type) {
  case 0: 
#line 319
  return ((char *)"RSA");
#line 320
  break;
  case 1: 
#line 322
  return ((char *)"DSA");
#line 323
  break;
  }
#line 325
  return ((char *)"unknown");
}
}
#line 1 "kex.o"
#line 454 "/usr/include/openssl/bn.h"
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 459
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 480
extern int BN_print_fp(FILE *fp , BIGNUM const   *a ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 93 "kex.h"
Buffer *kex_init(char **myproposal___0 ) ;
#line 94
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 95
DH *dh_new_group1(void) ;
#line 96
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) ;
#line 97
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) ;
#line 98
void bignum_print(BIGNUM *b ) ;
#line 101
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) ;
#line 52 "kex.c"
Buffer *kex_init(char **myproposal___0 ) 
{ char c ;
  unsigned char cookie[16] ;
  u_int32_t rand___0 ;
  int i ;
  Buffer *ki ;
  void *tmp ;

  {
#line 55
  c = (char)0;
#line 57
  rand___0 = (u_int32_t )0;
#line 59
  tmp = xmalloc(sizeof(*ki));
#line 59
  ki = (Buffer *)tmp;
#line 60
  i = 0;
#line 60
  while (i < 16) {
#line 61
    if (i % 4 == 0) {
#line 62
      rand___0 = arc4random();
    }
#line 63
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 64
    rand___0 >>= 8;
#line 60
    i ++;
  }
#line 66
  buffer_init(ki);
#line 67
  buffer_append(ki, (char const   *)((char *)(cookie)), sizeof(cookie));
#line 68
  i = 0;
#line 68
  while (i < 10) {
#line 69
    buffer_put_cstring(ki, (char const   *)*(myproposal___0 + i));
#line 68
    i ++;
  }
#line 70
  buffer_append(ki, (char const   *)(& c), 1U);
#line 71
  buffer_put_int(ki, 0U);
#line 72
  return (ki);
}
}
#line 77 "kex.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 81
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 81
  n___0 = tmp;
#line 82
  bits_set = 0;
#line 85
  if ((dh->g)->top == 1) {
#line 85
    if (*((dh->g)->d + 0) == 2UL) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 85
    if (0) {
      _L: /* CIL Label */ 
#line 85
      if (! (! (dh->g)->neg)) {
#line 86
        log("invalid DH base != 2");
#line 87
        return (0);
      }
    } else {
#line 86
      log("invalid DH base != 2");
#line 87
      return (0);
    }
  }
#line 89
  if (dh_pub->neg) {
#line 90
    log("invalid public DH value: negativ");
#line 91
    return (0);
  }
#line 93
  i = 0;
#line 93
  while (i <= n___0) {
#line 94
    tmp___0 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 94
    if (tmp___0) {
#line 95
      bits_set ++;
    }
#line 93
    i ++;
  }
#line 96
  tmp___1 = BN_num_bits((BIGNUM const   *)dh->p);
#line 96
  debug("bits set: %d/%d", bits_set, tmp___1);
#line 99
  if (bits_set > 1) {
#line 99
    tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)dh->p);
#line 99
    if (tmp___2 == -1) {
#line 100
      return (1);
    }
  }
#line 101
  tmp___3 = BN_num_bits((BIGNUM const   *)dh->p);
#line 101
  log("invalid public DH value (%d/%d)", bits_set, tmp___3);
#line 102
  return (0);
}
}
#line 108 "kex.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 105 "kex.c"
DH *dh_new_group1(void) 
{ DH *dh ;
  int ret ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 116
  tries = 0;
#line 117
  dh = DH_new();
#line 118
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 119
    fatal("DH_new");
  }
#line 120
  ret = BN_hex2bn(& dh->p, (char const   *)group1);
#line 121
  if (ret < 0) {
#line 122
    fatal("BN_hex2bn");
  }
#line 123
  dh->g = BN_new();
#line 124
  if ((unsigned int )dh->g == (unsigned int )((void *)0)) {
#line 125
    fatal("DH_new g");
  }
#line 126
  BN_set_word(dh->g, 2UL);
#line 127
  while (1) {
#line 128
    tmp = DH_generate_key(dh);
#line 128
    if (tmp == 0) {
#line 129
      fatal("DH_generate_key");
    }
#line 130
    tmp___0 = tries;
#line 130
    tries ++;
#line 130
    if (tmp___0 > 10) {
#line 131
      fatal("dh_new_group1: too many bad keys: giving up");
    }
#line 127
    tmp___1 = dh_pub_is_valid(dh, dh->pub_key);
#line 127
    if (tmp___1) {
#line 127
      break;
    }
  }
#line 133
  return (dh);
}
}
#line 136 "kex.c"
void bignum_print(BIGNUM *b ) 
{ 

  {
#line 139
  BN_print_fp(stderr, (BIGNUM const   *)b);
#line 140
  return;
}
}
#line 142 "kex.c"
void dump_digest(unsigned char *digest___0 , int len ) 
{ int i ;

  {
#line 146
  i = 0;
#line 146
  while (i < len) {
#line 147
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(digest___0 + i));
#line 148
    if (i % 2 != 0) {
#line 149
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
    }
#line 146
    i ++;
  }
#line 151
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 152
  return;
}
}
#line 166 "kex.c"
static unsigned char digest[64]  ;
#line 154 "kex.c"
unsigned char *kex_hash(char *client_version_string___0 , char *server_version_string___0 ,
                        char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                        char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                        BIGNUM *server_dh_pub , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;

  {
#line 167
  tmp = EVP_sha1();
#line 167
  evp_md = (EVP_MD *)tmp;
#line 170
  buffer_init(& b);
#line 171
  tmp___0 = strlen((char const   *)client_version_string___0);
#line 171
  buffer_put_string(& b, (void const   *)client_version_string___0, tmp___0);
#line 172
  tmp___1 = strlen((char const   *)server_version_string___0);
#line 172
  buffer_put_string(& b, (void const   *)server_version_string___0, tmp___1);
#line 175
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 176
  buffer_put_char(& b, 20);
#line 177
  buffer_append(& b, (char const   *)ckexinit, (unsigned int )ckexinitlen);
#line 178
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 179
  buffer_put_char(& b, 20);
#line 180
  buffer_append(& b, (char const   *)skexinit, (unsigned int )skexinitlen);
#line 182
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 183
  buffer_put_bignum2(& b, client_dh_pub);
#line 184
  buffer_put_bignum2(& b, server_dh_pub);
#line 185
  buffer_put_bignum2(& b, shared_secret);
#line 191
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 192
  tmp___2 = buffer_len(& b);
#line 192
  tmp___3 = buffer_ptr(& b);
#line 192
  EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
#line 193
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 195
  buffer_free(& b);
#line 200
  return (digest);
}
}
#line 203 "kex.c"
unsigned char *derive_key(int id , int need , unsigned char *hash , BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  char c ;
  int have ;
  int mdsz ;
  unsigned char *digest___0 ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;

  {
#line 207
  tmp = EVP_sha1();
#line 207
  evp_md = (EVP_MD *)tmp;
#line 209
  c = (char )id;
#line 211
  mdsz = evp_md->md_size;
#line 212
  tmp___0 = xmalloc((unsigned int )((((need + mdsz) - 1) / mdsz) * mdsz));
#line 212
  digest___0 = (unsigned char *)tmp___0;
#line 214
  buffer_init(& b);
#line 215
  buffer_put_bignum2(& b, shared_secret);
#line 217
  EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 218
  tmp___1 = buffer_len(& b);
#line 218
  tmp___2 = buffer_ptr(& b);
#line 218
  EVP_DigestUpdate(& md, (void const   *)tmp___2, tmp___1);
#line 219
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 220
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 221
  EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 222
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 225
  have = mdsz;
#line 225
  while (need > have) {
#line 226
    EVP_DigestInit(& md, (EVP_MD const   *)evp_md);
#line 227
    tmp___3 = buffer_len(& b);
#line 227
    tmp___4 = buffer_ptr(& b);
#line 227
    EVP_DigestUpdate(& md, (void const   *)tmp___4, tmp___3);
#line 228
    EVP_DigestUpdate(& md, (void const   *)hash, (unsigned int )mdsz);
#line 229
    EVP_DigestUpdate(& md, (void const   *)digest___0, (unsigned int )have);
#line 230
    EVP_DigestFinal(& md, digest___0 + have, (unsigned int *)((void *)0));
#line 225
    have += mdsz;
  }
#line 232
  buffer_free(& b);
#line 237
  return (digest___0);
}
}
#line 245 "kex.c"
char *get_match(char *client , char *server ) 
{ char *sproposals[20] ;
  char *p ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 252
  p = strtok((char * __restrict  )server, (char const   * __restrict  )",");
#line 252
  i = 0;
#line 252
  while (p) {
#line 253
    if (i < 20) {
#line 254
      sproposals[i] = p;
    } else {
#line 256
      break;
    }
#line 252
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
#line 252
    i ++;
  }
#line 258
  nproposals = i;
#line 260
  p = strtok((char * __restrict  )client, (char const   * __restrict  )",");
#line 260
  i = 0;
#line 260
  while (p) {
#line 261
    j = 0;
#line 261
    while (j < nproposals) {
#line 262
      if (0) {
#line 262
        __s1_len = strlen((char const   *)p);
#line 262
        __s2_len = strlen((char const   *)sproposals[j]);
#line 262
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 262
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 262
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 262
              tmp___9 = 1;
            } else {
#line 262
              if (__s2_len >= 4U) {
#line 262
                tmp___9 = 1;
              } else {
#line 262
                tmp___9 = 0;
              }
            }
          } else {
#line 262
            tmp___9 = 0;
          }
        }
#line 262
        if (tmp___9) {
#line 262
          tmp___5 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 262
          tmp___8 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 262
          tmp___5 = tmp___8;
        }
      } else {
#line 262
        tmp___8 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 262
        tmp___5 = tmp___8;
      }
#line 262
      if (tmp___5 == 0) {
#line 263
        tmp = xstrdup((char const   *)p);
#line 263
        return (tmp);
      }
#line 261
      j ++;
    }
#line 260
    p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )",");
#line 260
    i ++;
  }
#line 265
  return ((char *)((void *)0));
}
}
#line 267 "kex.c"
void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 270
  tmp = get_match(client, server);
#line 270
  name = tmp;
#line 271
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 272
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 273
  enc->type = cipher_number((char const   *)name);
#line 275
  switch (enc->type) {
  case 9: 
#line 277
  enc->key_len = 24;
#line 278
  enc->iv_len = 8;
#line 279
  enc->block_size = 8;
#line 280
  break;
  case 8: 
  case 11: 
#line 283
  enc->key_len = 16;
#line 284
  enc->iv_len = 8;
#line 285
  enc->block_size = 8;
#line 286
  break;
  case 10: 
#line 288
  enc->key_len = 16;
#line 289
  enc->iv_len = 0;
#line 290
  enc->block_size = 8;
#line 291
  break;
  default: 
#line 293
  fatal("unsupported cipher %s", name);
  }
#line 295
  enc->name = name;
#line 296
  enc->enabled = 0;
#line 297
  enc->iv = (unsigned char *)((void *)0);
#line 298
  enc->key = (unsigned char *)((void *)0);
#line 299
  return;
}
}
#line 300 "kex.c"
void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  EVP_MD const   *tmp___0 ;
  EVP_MD const   *tmp___1 ;
  EVP_MD const   *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 303
  tmp = get_match(client, server);
#line 303
  name = tmp;
#line 304
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 305
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 306
  if (0) {
#line 306
    __s1_len___1 = strlen((char const   *)name);
#line 306
    __s2_len___1 = strlen("hmac-md5");
#line 306
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 306
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 306
        if (! ((unsigned int )((void const   *)("hmac-md5" + 1)) - (unsigned int )((void const   *)"hmac-md5") == 1U)) {
#line 306
          tmp___32 = 1;
        } else {
#line 306
          if (__s2_len___1 >= 4U) {
#line 306
            tmp___32 = 1;
          } else {
#line 306
            tmp___32 = 0;
          }
        }
      } else {
#line 306
        tmp___32 = 0;
      }
    }
#line 306
    if (tmp___32) {
#line 306
      tmp___28 = __builtin_strcmp((char const   *)name, "hmac-md5");
    } else {
#line 306
      tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 306
      tmp___28 = tmp___31;
    }
  } else {
#line 306
    tmp___31 = __builtin_strcmp((char const   *)name, "hmac-md5");
#line 306
    tmp___28 = tmp___31;
  }
#line 306
  if (tmp___28 == 0) {
#line 307
    tmp___0 = EVP_md5();
#line 307
    mac->md = (EVP_MD *)tmp___0;
  } else {
#line 308
    if (0) {
#line 308
      __s1_len___0 = strlen((char const   *)name);
#line 308
      __s2_len___0 = strlen("hmac-sha1");
#line 308
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 308
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 308
          if (! ((unsigned int )((void const   *)("hmac-sha1" + 1)) - (unsigned int )((void const   *)"hmac-sha1") == 1U)) {
#line 308
            tmp___22 = 1;
          } else {
#line 308
            if (__s2_len___0 >= 4U) {
#line 308
              tmp___22 = 1;
            } else {
#line 308
              tmp___22 = 0;
            }
          }
        } else {
#line 308
          tmp___22 = 0;
        }
      }
#line 308
      if (tmp___22) {
#line 308
        tmp___18 = __builtin_strcmp((char const   *)name, "hmac-sha1");
      } else {
#line 308
        tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 308
        tmp___18 = tmp___21;
      }
    } else {
#line 308
      tmp___21 = __builtin_strcmp((char const   *)name, "hmac-sha1");
#line 308
      tmp___18 = tmp___21;
    }
#line 308
    if (tmp___18 == 0) {
#line 309
      tmp___1 = EVP_sha1();
#line 309
      mac->md = (EVP_MD *)tmp___1;
    } else {
#line 310
      if (0) {
#line 310
        __s1_len = strlen((char const   *)name);
#line 310
        __s2_len = strlen("hmac-ripemd160@openssh.com");
#line 310
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 310
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 310
            if (! ((unsigned int )((void const   *)("hmac-ripemd160@openssh.com" + 1)) - (unsigned int )((void const   *)"hmac-ripemd160@openssh.com") == 1U)) {
#line 310
              tmp___12 = 1;
            } else {
#line 310
              if (__s2_len >= 4U) {
#line 310
                tmp___12 = 1;
              } else {
#line 310
                tmp___12 = 0;
              }
            }
          } else {
#line 310
            tmp___12 = 0;
          }
        }
#line 310
        if (tmp___12) {
#line 310
          tmp___8 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
        } else {
#line 310
          tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 310
          tmp___8 = tmp___11;
        }
      } else {
#line 310
        tmp___11 = __builtin_strcmp((char const   *)name, "hmac-ripemd160@openssh.com");
#line 310
        tmp___8 = tmp___11;
      }
#line 310
      if (tmp___8 == 0) {
#line 311
        tmp___2 = EVP_ripemd160();
#line 311
        mac->md = (EVP_MD *)tmp___2;
      } else {
#line 313
        fatal("unsupported mac %s", name);
      }
    }
  }
#line 315
  mac->name = name;
#line 316
  mac->mac_len = (mac->md)->md_size;
#line 317
  if (datafellows) {
#line 317
    mac->key_len = 16;
  } else {
#line 317
    mac->key_len = mac->mac_len;
  }
#line 318
  mac->key = (unsigned char *)((void *)0);
#line 319
  mac->enabled = 0;
#line 320
  return;
}
}
#line 321 "kex.c"
void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 324
  tmp = get_match(client, server);
#line 324
  name = tmp;
#line 325
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 326
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 327
  if (0) {
#line 327
    __s1_len___0 = strlen((char const   *)name);
#line 327
    __s2_len___0 = strlen("zlib");
#line 327
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___2;
    } else {
#line 327
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 327
        if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 327
          tmp___19 = 1;
        } else {
#line 327
          if (__s2_len___0 >= 4U) {
#line 327
            tmp___19 = 1;
          } else {
#line 327
            tmp___19 = 0;
          }
        }
      } else {
#line 327
        tmp___19 = 0;
      }
    }
#line 327
    if (tmp___19) {
#line 327
      tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
    } else {
#line 327
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 327
      tmp___15 = tmp___18;
    }
  } else {
#line 327
    tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 327
    tmp___15 = tmp___18;
  }
#line 327
  if (tmp___15 == 0) {
#line 328
    comp->type = 1;
  } else {
#line 329
    if (0) {
#line 329
      __s1_len = strlen((char const   *)name);
#line 329
      __s2_len = strlen("none");
#line 329
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 329
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 329
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 329
            tmp___9 = 1;
          } else {
#line 329
            if (__s2_len >= 4U) {
#line 329
              tmp___9 = 1;
            } else {
#line 329
              tmp___9 = 0;
            }
          }
        } else {
#line 329
          tmp___9 = 0;
        }
      }
#line 329
      if (tmp___9) {
#line 329
        tmp___5 = __builtin_strcmp((char const   *)name, "none");
      } else {
#line 329
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 329
        tmp___5 = tmp___8;
      }
    } else {
#line 329
      tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 329
      tmp___5 = tmp___8;
    }
#line 329
    if (tmp___5 == 0) {
#line 330
      comp->type = 0;
    } else {
#line 332
      fatal("unsupported comp %s", name);
    }
  }
#line 334
  comp->name = name;
#line 335
  return;
}
}
#line 336 "kex.c"
void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 339
  k->name = get_match(client, server);
#line 340
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 341
    fatal("no kex alg");
  }
#line 342
  if (0) {
#line 342
    __s1_len = strlen((char const   *)k->name);
#line 342
    __s2_len = strlen("diffie-hellman-group1-sha1");
#line 342
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___0;
    } else {
#line 342
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 342
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 342
          tmp___8 = 1;
        } else {
#line 342
          if (__s2_len >= 4U) {
#line 342
            tmp___8 = 1;
          } else {
#line 342
            tmp___8 = 0;
          }
        }
      } else {
#line 342
        tmp___8 = 0;
      }
    }
#line 342
    if (tmp___8) {
#line 342
      tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 342
      tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 342
      tmp___4 = tmp___7;
    }
  } else {
#line 342
    tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 342
    tmp___4 = tmp___7;
  }
#line 342
  if (tmp___4 != 0) {
#line 343
    fatal("bad kex alg %s", k->name);
  }
#line 344
  return;
}
}
#line 345 "kex.c"
void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 348
  k->hostkeyalg = get_match(client, server);
#line 349
  if ((unsigned int )k->hostkeyalg == (unsigned int )((void *)0)) {
#line 350
    fatal("no hostkey alg");
  }
#line 351
  if (0) {
#line 351
    __s1_len = strlen((char const   *)k->hostkeyalg);
#line 351
    __s2_len = strlen("ssh-dss");
#line 351
    if (! ((unsigned int )((void const   *)(k->hostkeyalg + 1)) - (unsigned int )((void const   *)k->hostkeyalg) == 1U)) {
      goto _L___0;
    } else {
#line 351
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 351
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 351
          tmp___8 = 1;
        } else {
#line 351
          if (__s2_len >= 4U) {
#line 351
            tmp___8 = 1;
          } else {
#line 351
            tmp___8 = 0;
          }
        }
      } else {
#line 351
        tmp___8 = 0;
      }
    }
#line 351
    if (tmp___8) {
#line 351
      tmp___4 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
    } else {
#line 351
      tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 351
      tmp___4 = tmp___7;
    }
  } else {
#line 351
    tmp___7 = __builtin_strcmp((char const   *)k->hostkeyalg, "ssh-dss");
#line 351
    tmp___4 = tmp___7;
  }
#line 351
  if (tmp___4 != 0) {
#line 352
    fatal("bad hostkey alg %s", k->hostkeyalg);
  }
#line 353
  return;
}
}
#line 355 "kex.c"
Kex *kex_choose_conf(char **cprop , char **sprop , int server ) 
{ int i ;
  int mode ;
  int ctos ;
  int need ;
  Kex *k ;
  void *tmp ;
  int nenc ;
  int nmac ;
  int ncomp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 364
  tmp = xmalloc(sizeof(*k));
#line 364
  k = (Kex *)tmp;
#line 365
  memset((void *)k, 0, sizeof(*k));
#line 366
  k->server = server;
#line 368
  mode = 0;
#line 368
  while (mode < 2) {
#line 370
    if (! k->server) {
#line 370
      if (mode == 1) {
#line 370
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 370
      if (k->server) {
#line 370
        if (mode == 0) {
#line 370
          tmp___0 = 1;
        } else {
#line 370
          tmp___0 = 0;
        }
      } else {
#line 370
        tmp___0 = 0;
      }
    }
#line 370
    ctos = tmp___0;
#line 371
    if (ctos) {
#line 371
      nenc = 2;
    } else {
#line 371
      nenc = 3;
    }
#line 372
    if (ctos) {
#line 372
      nmac = 4;
    } else {
#line 372
      nmac = 5;
    }
#line 373
    if (ctos) {
#line 373
      ncomp = 6;
    } else {
#line 373
      ncomp = 7;
    }
#line 374
    choose_enc(& k->enc[mode], *(cprop + nenc), *(sprop + nenc));
#line 375
    choose_mac(& k->mac[mode], *(cprop + nmac), *(sprop + nmac));
#line 376
    choose_comp(& k->comp[mode], *(cprop + ncomp), *(sprop + ncomp));
#line 377
    if (ctos) {
#line 377
      tmp___1 = "client->server";
    } else {
#line 377
      tmp___1 = "server->client";
    }
#line 377
    debug("kex: %s %s %s %s", tmp___1, k->enc[mode].name, k->mac[mode].name, k->comp[mode].name);
#line 368
    mode ++;
  }
#line 383
  choose_kex(k, *(cprop + 0), *(sprop + 0));
#line 384
  choose_hostkeyalg(k, *(cprop + 1), *(sprop + 1));
#line 386
  i = 0;
#line 386
  while (i < 10) {
#line 387
    xfree((void *)*(cprop + i));
#line 388
    xfree((void *)*(sprop + i));
#line 386
    i ++;
  }
#line 390
  need = 0;
#line 391
  mode = 0;
#line 391
  while (mode < 2) {
#line 392
    if (need < k->enc[mode].key_len) {
#line 393
      need = k->enc[mode].key_len;
    }
#line 394
    if (need < k->enc[mode].iv_len) {
#line 395
      need = k->enc[mode].iv_len;
    }
#line 396
    if (need < k->mac[mode].key_len) {
#line 397
      need = k->mac[mode].key_len;
    }
#line 391
    mode ++;
  }
#line 401
  k->we_need = 32;
#line 402
  k->we_need = need;
#line 403
  return (k);
}
}
#line 406 "kex.c"
int kex_derive_keys(Kex *k , unsigned char *hash , BIGNUM *shared_secret ) 
{ int i ;
  int mode ;
  int ctos ;
  unsigned char *keys[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 414
  i = 0;
#line 414
  while (i < 6) {
#line 415
    keys[i] = derive_key(65 + i, k->we_need, hash, shared_secret);
#line 414
    i ++;
  }
#line 417
  mode = 0;
#line 417
  while (mode < 2) {
#line 418
    if (! k->server) {
#line 418
      if (mode == 1) {
#line 418
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 418
      if (k->server) {
#line 418
        if (mode == 0) {
#line 418
          tmp = 1;
        } else {
#line 418
          tmp = 0;
        }
      } else {
#line 418
        tmp = 0;
      }
    }
#line 418
    ctos = tmp;
#line 419
    if (ctos) {
#line 419
      tmp___0 = 0;
    } else {
#line 419
      tmp___0 = 1;
    }
#line 419
    k->enc[mode].iv = keys[tmp___0];
#line 420
    if (ctos) {
#line 420
      tmp___1 = 2;
    } else {
#line 420
      tmp___1 = 3;
    }
#line 420
    k->enc[mode].key = keys[tmp___1];
#line 421
    if (ctos) {
#line 421
      tmp___2 = 4;
    } else {
#line 421
      tmp___2 = 5;
    }
#line 421
    k->mac[mode].key = keys[tmp___2];
#line 417
    mode ++;
  }
#line 423
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "log.o"
#line 325 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 454 "ssh.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 457
SyslogFacility log_facility_number(char *name ) ;
#line 458
LogLevel log_level_number(char *name ) ;
#line 478
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) ;
#line 13 "log.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 17
  __builtin_va_start(args, fmt);
#line 18
  do_log(1, fmt, args);
#line 19
  __builtin_va_end(args);
#line 20
  fatal_cleanup();
#line 21
  return;
}
}
#line 25 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 29
  __builtin_va_start(args, fmt);
#line 30
  do_log(2, fmt, args);
#line 31
  __builtin_va_end(args);
#line 32
  return;
}
}
#line 36 "log.c"
void ( /* format attribute */  log)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 40
  __builtin_va_start(args, fmt);
#line 41
  do_log(3, fmt, args);
#line 42
  __builtin_va_end(args);
#line 43
  return;
}
}
#line 47 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 51
  __builtin_va_start(args, fmt);
#line 52
  do_log(4, fmt, args);
#line 53
  __builtin_va_end(args);
#line 54
  return;
}
}
#line 58 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 62
  __builtin_va_start(args, fmt);
#line 63
  do_log(5, fmt, args);
#line 64
  __builtin_va_end(args);
#line 65
  return;
}
}
#line 75 "log.c"
static struct fatal_cleanup *fatal_cleanups  =    (struct fatal_cleanup *)((void *)0);
#line 79 "log.c"
void fatal_add_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup *cu ;
  void *tmp ;

  {
#line 84
  tmp = xmalloc(sizeof(*cu));
#line 84
  cu = (struct fatal_cleanup *)tmp;
#line 85
  cu->proc = proc;
#line 86
  cu->context = context;
#line 87
  cu->next = fatal_cleanups;
#line 88
  fatal_cleanups = cu;
#line 89
  return;
}
}
#line 93 "log.c"
void fatal_remove_cleanup(void (*proc)(void *context ) , void *context ) 
{ struct fatal_cleanup **cup ;
  struct fatal_cleanup *cu ;

  {
#line 98
  cup = & fatal_cleanups;
#line 98
  while (*cup) {
#line 99
    cu = *cup;
#line 100
    if ((unsigned int )cu->proc == (unsigned int )proc) {
#line 100
      if ((unsigned int )cu->context == (unsigned int )context) {
#line 101
        *cup = cu->next;
#line 102
        xfree((void *)cu);
#line 103
        return;
      }
    }
#line 98
    cup = & cu->next;
  }
#line 106
  fatal("fatal_remove_cleanup: no such cleanup function: 0x%lx 0x%lx\n", (unsigned long )proc,
        (unsigned long )context);
#line 108
  return;
}
}
#line 115 "log.c"
static int called  =    0;
#line 111 "log.c"
void fatal_cleanup(void) 
{ struct fatal_cleanup *cu ;
  struct fatal_cleanup *next_cu ;

  {
#line 117
  if (called) {
#line 118
    exit(255);
  }
#line 119
  called = 1;
#line 121
  cu = fatal_cleanups;
#line 121
  while (cu) {
#line 122
    next_cu = cu->next;
#line 123
    debug("Calling cleanup 0x%lx(0x%lx)", (unsigned long )cu->proc, (unsigned long )cu->context);
#line 125
    (*(cu->proc))(cu->context);
#line 121
    cu = next_cu;
  }
#line 127
  exit(255);
}
}
#line 132 "log.c"
static struct __anonstruct_log_facilities_74 log_facilities[12]  = 
#line 132
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"LOCAL0", 3}, 
        {"LOCAL1", 4}, 
        {"LOCAL2", 5}, 
        {"LOCAL3", 6}, 
        {"LOCAL4", 7}, 
        {"LOCAL5", 8}, 
        {"LOCAL6", 9}, 
        {"LOCAL7", 10}, 
        {(char const   *)((void *)0), (SyslogFacility )0}};
#line 150 "log.c"
static struct __anonstruct_log_levels_75 log_levels[7]  = {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {(char const   *)((void *)0), (LogLevel )0}};
#line 164 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 168
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 169
    i = 0;
#line 169
    while (log_facilities[i].name) {
#line 170
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 170
      if (tmp == 0) {
#line 171
        return (log_facilities[i].val);
      }
#line 169
      i ++;
    }
  }
#line 172
  return ((enum __anonenum_SyslogFacility_72 )-1);
}
}
#line 175 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 179
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 180
    i = 0;
#line 180
    while (log_levels[i].name) {
#line 181
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 181
      if (tmp == 0) {
#line 182
        return (log_levels[i].val);
      }
#line 180
      i ++;
    }
  }
#line 183
  return ((enum __anonenum_LogLevel_73 )-1);
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 26 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 29
  while (1) {
#line 31
    if (! *pattern) {
#line 32
      return (! *s);
    }
#line 34
    if ((int const   )*pattern == 42) {
#line 36
      pattern ++;
#line 39
      if (! *pattern) {
#line 40
        return (1);
      }
#line 43
      if ((int const   )*pattern != 63) {
#line 43
        if ((int const   )*pattern != 42) {
#line 49
          while (*s) {
#line 50
            if ((int const   )*s == (int const   )*pattern) {
#line 50
              tmp = match_pattern(s + 1, pattern + 1);
#line 50
              if (tmp) {
#line 52
                return (1);
              }
            }
#line 49
            s ++;
          }
#line 54
          return (0);
        }
      }
#line 60
      while (*s) {
#line 61
        tmp___0 = match_pattern(s, pattern);
#line 61
        if (tmp___0) {
#line 62
          return (1);
        }
#line 60
        s ++;
      }
#line 64
      return (0);
    }
#line 70
    if (! *s) {
#line 71
      return (0);
    }
#line 74
    if ((int const   )*pattern != 63) {
#line 74
      if ((int const   )*pattern != (int const   )*s) {
#line 75
        return (0);
      }
    }
#line 78
    s ++;
#line 79
    pattern ++;
  }
}
}
#line 91 "match.c"
int match_hostname(char const   *host , char const   *pattern , unsigned int len ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  unsigned int i ;
  unsigned int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 99
  got_positive = 0;
#line 100
  i = 0U;
#line 100
  while (i < len) {
#line 102
    if ((int const   )*(pattern + i) == 33) {
#line 103
      negated = 1;
#line 104
      i ++;
    } else {
#line 106
      negated = 0;
    }
#line 112
    subi = 0U;
#line 112
    while (1) {
#line 112
      if (i < len) {
#line 112
        if (subi < sizeof(sub) - 1U) {
#line 112
          if (! ((int const   )*(pattern + i) != 44)) {
#line 112
            break;
          }
        } else {
#line 112
          break;
        }
      } else {
#line 112
        break;
      }
#line 115
      tmp___6 = __ctype_b_loc();
#line 115
      if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 115
        if (sizeof(*(pattern + i)) > 1U) {
#line 115
          __res___0 = tolower((int )*(pattern + i));
        } else {
#line 115
          tmp___5 = __ctype_tolower_loc();
#line 115
          __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
        }
#line 115
        sub[subi] = (char )__res___0;
      } else {
#line 115
        sub[subi] = (char )*(pattern + i);
      }
#line 112
      subi ++;
#line 112
      i ++;
    }
#line 117
    if (subi >= sizeof(sub) - 1U) {
#line 118
      return (0);
    }
#line 121
    if (i < len) {
#line 121
      if ((int const   )*(pattern + i) == 44) {
#line 122
        i ++;
      }
    }
#line 125
    sub[subi] = (char )'\000';
#line 128
    tmp___7 = match_pattern(host, (char const   *)(sub));
#line 128
    if (tmp___7) {
#line 129
      if (negated) {
#line 130
        return (0);
      } else {
#line 132
        got_positive = 1;
      }
    }
  }
#line 140
  return (got_positive);
}
}
#line 1 "mpaux.o"
#line 26 "mpaux.c"
void compute_session_id(unsigned char *session_id___0 , unsigned char *cookie , BIGNUM *host_key_n ,
                        BIGNUM *session_key_n ) 
{ unsigned int host_key_bytes ;
  int tmp ;
  unsigned int session_key_bytes ;
  int tmp___0 ;
  unsigned int bytes ;
  unsigned char *buf___1 ;
  void *tmp___1 ;
  MD5_CTX md ;

  {
#line 32
  tmp = BN_num_bits((BIGNUM const   *)host_key_n);
#line 32
  host_key_bytes = (unsigned int )((tmp + 7) / 8);
#line 33
  tmp___0 = BN_num_bits((BIGNUM const   *)session_key_n);
#line 33
  session_key_bytes = (unsigned int )((tmp___0 + 7) / 8);
#line 34
  bytes = host_key_bytes + session_key_bytes;
#line 35
  tmp___1 = xmalloc(bytes);
#line 35
  buf___1 = (unsigned char *)tmp___1;
#line 38
  BN_bn2bin((BIGNUM const   *)host_key_n, buf___1);
#line 39
  BN_bn2bin((BIGNUM const   *)session_key_n, buf___1 + host_key_bytes);
#line 40
  MD5_Init(& md);
#line 41
  MD5_Update(& md, (void const   *)buf___1, bytes);
#line 42
  MD5_Update(& md, (void const   *)cookie, 8U);
#line 43
  MD5_Final((unsigned char *)session_id___0, & md);
#line 44
  memset((void *)buf___1, 0, bytes);
#line 45
  xfree((void *)buf___1);
#line 46
  return;
}
}
#line 1 "nchan.o"
#line 48 "nchan.c"
chan_event_fn *chan_rcvd_oclose  =    (chan_event_fn *)((void *)0);
#line 49 "nchan.c"
chan_event_fn *chan_read_failed  =    (chan_event_fn *)((void *)0);
#line 50 "nchan.c"
chan_event_fn *chan_ibuf_empty  =    (chan_event_fn *)((void *)0);
#line 52 "nchan.c"
chan_event_fn *chan_rcvd_ieof  =    (chan_event_fn *)((void *)0);
#line 53 "nchan.c"
chan_event_fn *chan_write_failed  =    (chan_event_fn *)((void *)0);
#line 54 "nchan.c"
chan_event_fn *chan_obuf_empty  =    (chan_event_fn *)((void *)0);
#line 58
static void chan_send_ieof1(Channel *c ) ;
#line 59
static void chan_send_oclose1(Channel *c ) ;
#line 60
static void chan_send_close2(Channel *c ) ;
#line 61
static void chan_send_eof2(Channel *c ) ;
#line 64 "nchan.c"
chan_event_fn *chan_delete_if_full_closed  =    (chan_event_fn *)((void *)0);
#line 67
static void chan_shutdown_write(Channel *c ) ;
#line 68
static void chan_shutdown_read(Channel *c ) ;
#line 74 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 77
  debug("channel %d: rcvd oclose", c->self);
#line 78
  switch (c->istate) {
  case 4: 
#line 80
  debug("channel %d: input wait_oclose -> closed", c->self);
#line 81
  c->istate = 8;
#line 82
  break;
  case 1: 
#line 84
  debug("channel %d: input open -> closed", c->self);
#line 85
  chan_shutdown_read(c);
#line 86
  chan_send_ieof1(c);
#line 87
  c->istate = 8;
#line 88
  break;
  case 2: 
#line 91
  log("channel %d: input drain -> closed", c->self);
#line 92
  chan_send_ieof1(c);
#line 93
  c->istate = 8;
#line 94
  break;
  default: 
#line 96
  error("channel %d: protocol error: chan_rcvd_oclose for istate %d", c->self, c->istate);
#line 98
  return;
  }
#line 100
  return;
}
}
#line 101 "nchan.c"
static void chan_read_failed_12(Channel *c ) 
{ 

  {
#line 104
  debug("channel %d: read failed", c->self);
#line 105
  switch (c->istate) {
  case 1: 
#line 107
  debug("channel %d: input open -> drain", c->self);
#line 108
  chan_shutdown_read(c);
#line 109
  c->istate = 2;
#line 110
  break;
  default: 
#line 112
  error("channel %d: internal error: we do not read, but chan_read_failed for istate %d",
        c->self, c->istate);
#line 114
  break;
  }
#line 116
  return;
}
}
#line 117 "nchan.c"
static void chan_ibuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 120
  debug("channel %d: ibuf empty", c->self);
#line 121
  tmp = buffer_len(& c->input);
#line 121
  if (tmp) {
#line 122
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 124
    return;
  }
#line 126
  switch (c->istate) {
  case 2: 
#line 128
  debug("channel %d: input drain -> wait_oclose", c->self);
#line 129
  chan_send_ieof1(c);
#line 130
  c->istate = 4;
#line 131
  break;
  default: 
#line 133
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 135
  break;
  }
#line 137
  return;
}
}
#line 138 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 141
  debug("channel %d: rcvd ieof", c->self);
#line 142
  if (c->type != 4) {
#line 143
    debug("channel %d: non-open", c->self);
#line 144
    if (c->istate == 1) {
#line 145
      debug("channel %d: non-open: input open -> wait_oclose", c->self);
#line 146
      chan_shutdown_read(c);
#line 147
      chan_send_ieof1(c);
#line 148
      c->istate = 4;
    } else {
#line 150
      error("channel %d: istate %d != open", c->self, c->istate);
    }
#line 152
    if (c->ostate == 16) {
#line 153
      debug("channel %d: non-open: output open -> closed", c->self);
#line 154
      chan_send_oclose1(c);
#line 155
      c->ostate = 128;
    } else {
#line 157
      error("channel %d: ostate %d != open", c->self, c->ostate);
    }
#line 159
    return;
  }
#line 161
  switch (c->ostate) {
  case 16: 
#line 163
  debug("channel %d: output open -> drain", c->self);
#line 164
  c->ostate = 32;
#line 165
  break;
  case 64: 
#line 167
  debug("channel %d: output wait_ieof -> closed", c->self);
#line 168
  c->ostate = 128;
#line 169
  break;
  default: 
#line 171
  error("channel %d: protocol error: chan_rcvd_ieof for ostate %d", c->self, c->ostate);
#line 173
  break;
  }
#line 175
  return;
}
}
#line 176 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 179
  debug("channel %d: write failed", c->self);
#line 180
  switch (c->ostate) {
  case 16: 
#line 182
  debug("channel %d: output open -> wait_ieof", c->self);
#line 183
  chan_send_oclose1(c);
#line 184
  c->ostate = 64;
#line 185
  break;
  case 32: 
#line 187
  debug("channel %d: output wait_drain -> closed", c->self);
#line 188
  chan_send_oclose1(c);
#line 189
  c->ostate = 128;
#line 190
  break;
  default: 
#line 192
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 194
  break;
  }
#line 196
  return;
}
}
#line 197 "nchan.c"
static void chan_obuf_empty1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 200
  debug("channel %d: obuf empty", c->self);
#line 201
  tmp = buffer_len(& c->output);
#line 201
  if (tmp) {
#line 202
    error("channel %d: internal error: chan_obuf_empty for non empty buffer", c->self);
#line 204
    return;
  }
#line 206
  switch (c->ostate) {
  case 32: 
#line 208
  debug("channel %d: output drain -> closed", c->self);
#line 209
  chan_send_oclose1(c);
#line 210
  c->ostate = 128;
#line 211
  break;
  default: 
#line 213
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 215
  break;
  }
#line 217
  return;
}
}
#line 218 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 221
  debug("channel %d: send ieof", c->self);
#line 222
  switch (c->istate) {
  case 1: 
  case 2: 
#line 225
  packet_start(24);
#line 226
  packet_put_int((unsigned int )c->remote_id);
#line 227
  packet_send();
#line 228
  break;
  default: 
#line 230
  error("channel %d: internal error: cannot send ieof for istate %d", c->self, c->istate);
#line 232
  break;
  }
#line 234
  return;
}
}
#line 235 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ unsigned int tmp ;

  {
#line 238
  debug("channel %d: send oclose", c->self);
#line 239
  switch (c->ostate) {
  case 16: 
  case 32: 
#line 242
  chan_shutdown_write(c);
#line 243
  tmp = buffer_len(& c->output);
#line 243
  buffer_consume(& c->output, tmp);
#line 244
  packet_start(25);
#line 245
  packet_put_int((unsigned int )c->remote_id);
#line 246
  packet_send();
#line 247
  break;
  default: 
#line 249
  error("channel %d: internal error: cannot send oclose for ostate %d", c->self, c->ostate);
#line 251
  break;
  }
#line 253
  return;
}
}
#line 254 "nchan.c"
static void chan_delete_if_full_closed1(Channel *c ) 
{ 

  {
#line 257
  if (c->istate == 8) {
#line 257
    if (c->ostate == 128) {
#line 258
      debug("channel %d: full closed", c->self);
#line 259
      channel_free(c->self);
    }
  }
#line 261
  return;
}
}
#line 266 "nchan.c"
static void chan_rcvd_oclose2(Channel *c ) 
{ 

  {
#line 269
  debug("channel %d: rcvd close", c->self);
#line 270
  if (c->flags & 2) {
#line 271
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 272
  c->flags |= 2;
#line 273
  if (c->type == 10) {
#line 275
    c->ostate = 128;
#line 276
    c->istate = 8;
#line 277
    return;
  }
#line 279
  switch (c->ostate) {
  case 16: 
#line 282
  debug("channel %d: output open -> drain", c->self);
#line 283
  c->ostate = 32;
#line 284
  break;
  }
#line 286
  switch (c->istate) {
  case 1: 
#line 288
  debug("channel %d: input open -> closed", c->self);
#line 289
  chan_shutdown_read(c);
#line 290
  break;
  case 2: 
#line 292
  debug("channel %d: input drain -> closed", c->self);
#line 293
  chan_send_eof2(c);
#line 294
  break;
  }
#line 296
  c->istate = 8;
#line 297
  return;
}
}
#line 298 "nchan.c"
static void chan_ibuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 301
  debug("channel %d: ibuf empty", c->self);
#line 302
  tmp = buffer_len(& c->input);
#line 302
  if (tmp) {
#line 303
    error("channel %d: internal error: chan_ibuf_empty for non empty buffer", c->self);
#line 305
    return;
  }
#line 307
  switch (c->istate) {
  case 2: 
#line 309
  debug("channel %d: input drain -> closed", c->self);
#line 310
  if (! (c->flags & 1)) {
#line 311
    chan_send_eof2(c);
  }
#line 312
  c->istate = 8;
#line 313
  break;
  default: 
#line 315
  error("channel %d: internal error: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 317
  break;
  }
#line 319
  return;
}
}
#line 320 "nchan.c"
static void chan_rcvd_ieof2(Channel *c ) 
{ 

  {
#line 323
  debug("channel %d: rcvd eof", c->self);
#line 324
  if (c->ostate == 16) {
#line 325
    debug("channel %d: output open -> drain", c->self);
#line 326
    c->ostate = 32;
  }
#line 328
  return;
}
}
#line 329 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 332
  debug("channel %d: write failed", c->self);
#line 333
  switch (c->ostate) {
  case 16: 
#line 335
  debug("channel %d: output open -> closed", c->self);
#line 336
  chan_shutdown_write(c);
#line 337
  c->ostate = 128;
#line 338
  break;
  case 32: 
#line 340
  debug("channel %d: output drain -> closed", c->self);
#line 341
  chan_shutdown_write(c);
#line 342
  c->ostate = 128;
#line 343
  break;
  default: 
#line 345
  error("channel %d: internal error: chan_write_failed for ostate %d", c->self, c->ostate);
#line 347
  break;
  }
#line 349
  return;
}
}
#line 350 "nchan.c"
static void chan_obuf_empty2(Channel *c ) 
{ unsigned int tmp ;

  {
#line 353
  debug("channel %d: obuf empty", c->self);
#line 354
  tmp = buffer_len(& c->output);
#line 354
  if (tmp) {
#line 355
    error("internal error: chan_obuf_empty %d for non empty buffer", c->self);
#line 357
    return;
  }
#line 359
  switch (c->ostate) {
  case 32: 
#line 361
  debug("channel %d: output drain -> closed", c->self);
#line 362
  chan_shutdown_write(c);
#line 363
  c->ostate = 128;
#line 364
  break;
  default: 
#line 366
  error("channel %d: internal error: chan_obuf_empty for ostate %d", c->self, c->ostate);
#line 368
  break;
  }
#line 370
  return;
}
}
#line 371 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 374
  debug("channel %d: send eof", c->self);
#line 375
  switch (c->istate) {
  case 2: 
#line 377
  packet_start(96);
#line 378
  packet_put_int((unsigned int )c->remote_id);
#line 379
  packet_send();
#line 380
  break;
  default: 
#line 382
  error("channel %d: internal error: cannot send eof for istate %d", c->self, c->istate);
#line 384
  break;
  }
#line 386
  return;
}
}
#line 387 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 390
  debug("channel %d: send close", c->self);
#line 391
  if (c->ostate != 128) {
#line 393
    error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
          c->self, c->istate, c->ostate);
  } else {
#line 391
    if (c->istate != 8) {
#line 393
      error("channel %d: internal error: cannot send close for istate/ostate %d/%d",
            c->self, c->istate, c->ostate);
    } else {
#line 395
      if (c->flags & 1) {
#line 396
        error("channel %d: internal error: already sent close", c->self);
      } else {
#line 398
        packet_start(97);
#line 399
        packet_put_int((unsigned int )c->remote_id);
#line 400
        packet_send();
#line 401
        c->flags |= 1;
      }
    }
  }
#line 403
  return;
}
}
#line 404 "nchan.c"
static void chan_delete_if_full_closed2(Channel *c ) 
{ 

  {
#line 407
  if (c->istate == 8) {
#line 407
    if (c->ostate == 128) {
#line 408
      if (! (c->flags & 1)) {
#line 409
        chan_send_close2(c);
      }
#line 411
      if (c->flags & 1) {
#line 411
        if (c->flags & 2) {
#line 413
          debug("channel %d: full closed2", c->self);
#line 414
          channel_free(c->self);
        }
      }
    }
  }
#line 417
  return;
}
}
#line 420 "nchan.c"
void chan_init_iostates(Channel *c ) 
{ 

  {
#line 423
  c->ostate = 16;
#line 424
  c->istate = 1;
#line 425
  c->flags = 0;
#line 426
  return;
}
}
#line 429 "nchan.c"
void chan_init(void) 
{ 

  {
#line 432
  if (compat20) {
#line 433
    chan_rcvd_oclose = & chan_rcvd_oclose2;
#line 434
    chan_read_failed = & chan_read_failed_12;
#line 435
    chan_ibuf_empty = & chan_ibuf_empty2;
#line 437
    chan_rcvd_ieof = & chan_rcvd_ieof2;
#line 438
    chan_write_failed = & chan_write_failed2;
#line 439
    chan_obuf_empty = & chan_obuf_empty2;
#line 441
    chan_delete_if_full_closed = & chan_delete_if_full_closed2;
  } else {
#line 443
    chan_rcvd_oclose = & chan_rcvd_oclose1;
#line 444
    chan_read_failed = & chan_read_failed_12;
#line 445
    chan_ibuf_empty = & chan_ibuf_empty1;
#line 447
    chan_rcvd_ieof = & chan_rcvd_ieof1;
#line 448
    chan_write_failed = & chan_write_failed1;
#line 449
    chan_obuf_empty = & chan_obuf_empty1;
#line 451
    chan_delete_if_full_closed = & chan_delete_if_full_closed1;
  }
#line 453
  return;
}
}
#line 456 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ unsigned int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 459
  tmp = buffer_len(& c->output);
#line 459
  buffer_consume(& c->output, tmp);
#line 460
  if (compat20) {
#line 460
    if (c->type == 10) {
#line 461
      return;
    }
  }
#line 463
  debug("channel %d: close_write", c->self);
#line 464
  if (c->sock != -1) {
#line 465
    tmp___2 = shutdown(c->sock, 1);
#line 465
    if (tmp___2 < 0) {
#line 466
      tmp___0 = __errno_location();
#line 466
      tmp___1 = strerror(*tmp___0);
#line 466
      debug("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
            c->self, c->sock, tmp___1);
    }
  } else {
#line 469
    tmp___5 = close(c->wfd);
#line 469
    if (tmp___5 < 0) {
#line 470
      tmp___3 = __errno_location();
#line 470
      tmp___4 = strerror(*tmp___3);
#line 470
      log("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
          c->wfd, tmp___4);
    }
#line 472
    c->wfd = -1;
  }
#line 474
  return;
}
}
#line 475 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 478
  if (compat20) {
#line 478
    if (c->type == 10) {
#line 479
      return;
    }
  }
#line 480
  debug("channel %d: close_read", c->self);
#line 481
  if (c->sock != -1) {
#line 482
    tmp___1 = shutdown(c->sock, 0);
#line 482
    if (tmp___1 < 0) {
#line 483
      tmp = __errno_location();
#line 483
      tmp___0 = strerror(*tmp);
#line 483
      error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
            c->self, c->sock, c->istate, c->ostate, tmp___0);
    }
  } else {
#line 486
    tmp___4 = close(c->rfd);
#line 486
    if (tmp___4 < 0) {
#line 487
      tmp___2 = __errno_location();
#line 487
      tmp___3 = strerror(*tmp___2);
#line 487
      log("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
          c->rfd, tmp___3);
    }
#line 489
    c->rfd = -1;
  }
#line 491
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 28 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 31
void packet_set_nonblocking(void) ;
#line 37
int packet_get_connection_out(void) ;
#line 43
void packet_close(void) ;
#line 50
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) ;
#line 58
void packet_set_protocol_flags(unsigned int protocol_flags ) ;
#line 61
unsigned int packet_get_protocol_flags(void) ;
#line 64
void packet_start_compression(int level ) ;
#line 70
void packet_set_interactive(int interactive , int keepalives ) ;
#line 85
void packet_put_bignum(BIGNUM *value ) ;
#line 86
void packet_put_bignum2(BIGNUM *value ) ;
#line 91
void packet_put_raw(char const   *buf___1 , unsigned int len ) ;
#line 122
void packet_process_incoming(char const   *buf___1 , unsigned int len ) ;
#line 125
unsigned int packet_get_char(void) ;
#line 134
void packet_get_bignum(BIGNUM *value , int *length_ptr ) ;
#line 135
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) ;
#line 136
char *packet_get_raw(int *length_ptr ) ;
#line 164
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 167
void packet_write_poll(void) ;
#line 173
int packet_have_data_to_write(void) ;
#line 176
int packet_not_very_much_data_to_write(void) ;
#line 180
int packet_set_maxsize(int s ) ;
#line 211
int packet_connection_is_ipv4(void) ;
#line 214
void packet_set_ssh2_format(void) ;
#line 99 "kex.h"
void packet_set_kex(Kex *k ) ;
#line 57 "packet.c"
static int connection_in  =    -1;
#line 58 "packet.c"
static int connection_out  =    -1;
#line 64 "packet.c"
static int cipher_type  =    0;
#line 67 "packet.c"
static unsigned int remote_protocol_flags  =    0U;
#line 70 "packet.c"
static CipherContext receive_context  ;
#line 73 "packet.c"
static CipherContext send_context  ;
#line 76 "packet.c"
static Buffer input  ;
#line 79 "packet.c"
static Buffer output  ;
#line 82 "packet.c"
static Buffer outgoing_packet  ;
#line 85 "packet.c"
static Buffer incoming_packet  ;
#line 88 "packet.c"
static Buffer compression_buffer  ;
#line 91 "packet.c"
static int packet_compression  =    0;
#line 94 "packet.c"
int max_packet_size  =    32768;
#line 97 "packet.c"
static int initialized  =    0;
#line 100 "packet.c"
static int interactive_mode  =    0;
#line 103 "packet.c"
int use_ssh2_packet_format  =    0;
#line 106 "packet.c"
Kex *kex  =    (Kex *)((void *)0);
#line 108 "packet.c"
void packet_set_kex(Kex *k ) 
{ 

  {
#line 111
  if ((unsigned int )k->mac[0].key == (unsigned int )((void *)0)) {
#line 117
    fatal("bad KEX");
  } else {
#line 111
    if ((unsigned int )k->enc[0].key == (unsigned int )((void *)0)) {
#line 117
      fatal("bad KEX");
    } else {
#line 111
      if ((unsigned int )k->enc[0].iv == (unsigned int )((void *)0)) {
#line 117
        fatal("bad KEX");
      } else {
#line 111
        if ((unsigned int )k->mac[1].key == (unsigned int )((void *)0)) {
#line 117
          fatal("bad KEX");
        } else {
#line 111
          if ((unsigned int )k->enc[1].key == (unsigned int )((void *)0)) {
#line 117
            fatal("bad KEX");
          } else {
#line 111
            if ((unsigned int )k->enc[1].iv == (unsigned int )((void *)0)) {
#line 117
              fatal("bad KEX");
            }
          }
        }
      }
    }
  }
#line 118
  kex = k;
#line 119
  return;
}
}
#line 120 "packet.c"
void clear_enc_keys(Enc *enc , int len ) 
{ 

  {
#line 123
  memset((void *)enc->iv, 0, (unsigned int )len);
#line 124
  memset((void *)enc->key, 0, (unsigned int )len);
#line 125
  xfree((void *)enc->iv);
#line 126
  xfree((void *)enc->key);
#line 127
  enc->iv = (unsigned char *)((void *)0);
#line 128
  enc->key = (unsigned char *)((void *)0);
#line 129
  return;
}
}
#line 130 "packet.c"
void packet_set_ssh2_format(void) 
{ 

  {
#line 134
  use_ssh2_packet_format = 1;
#line 135
  return;
}
}
#line 141 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ 

  {
#line 144
  connection_in = fd_in;
#line 145
  connection_out = fd_out;
#line 146
  cipher_type = 0;
#line 147
  cipher_set_key(& send_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 148
  cipher_set_key(& receive_context, 0, (unsigned char const   *)((unsigned char *)""),
                 0);
#line 149
  if (! initialized) {
#line 150
    initialized = 1;
#line 151
    buffer_init(& input);
#line 152
    buffer_init(& output);
#line 153
    buffer_init(& outgoing_packet);
#line 154
    buffer_init(& incoming_packet);
  }
#line 157
  fatal_add_cleanup((void (*)(void * ))(& packet_close), (void *)0);
#line 158
  return;
}
}
#line 162 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 169
  if (connection_in == connection_out) {
#line 170
    return (1);
  }
#line 171
  fromlen = sizeof(from);
#line 172
  memset((void *)(& from), 0, sizeof(from));
#line 173
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 173
  if (tmp < 0) {
#line 174
    return (0);
  }
#line 175
  tolen = sizeof(to);
#line 176
  memset((void *)(& to), 0, sizeof(to));
#line 177
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 177
  if (tmp___0 < 0) {
#line 178
    return (0);
  }
#line 179
  if (fromlen != tolen) {
#line 180
    return (0);
  } else {
#line 179
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 179
    if (tmp___1 != 0) {
#line 180
      return (0);
    }
  }
#line 181
  if ((int )from.ss_family != 2) {
#line 181
    if ((int )from.ss_family != 10) {
#line 182
      return (0);
    }
  }
#line 183
  return (1);
}
}
#line 188 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;

  {
#line 192
  tolen = sizeof(to);
#line 194
  memset((void *)(& to), 0, sizeof(to));
#line 195
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 195
  if (tmp < 0) {
#line 196
    return (0);
  }
#line 197
  if ((int )to.ss_family != 2) {
#line 198
    return (0);
  }
#line 199
  return (1);
}
}
#line 204 "packet.c"
void packet_set_nonblocking(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 208
  tmp___1 = fcntl(connection_in, 4, 2048);
#line 208
  if (tmp___1 < 0) {
#line 209
    tmp = __errno_location();
#line 209
    tmp___0 = strerror(*tmp);
#line 209
    error("fcntl O_NONBLOCK: %.100s", tmp___0);
  }
#line 211
  if (connection_out != connection_in) {
#line 212
    tmp___4 = fcntl(connection_out, 4, 2048);
#line 212
    if (tmp___4 < 0) {
#line 213
      tmp___2 = __errno_location();
#line 213
      tmp___3 = strerror(*tmp___2);
#line 213
      error("fcntl O_NONBLOCK: %.100s", tmp___3);
    }
  }
#line 215
  return;
}
}
#line 219 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 222
  return (connection_in);
}
}
#line 227 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 230
  return (connection_out);
}
}
#line 235 "packet.c"
void packet_close(void) 
{ 

  {
#line 238
  if (! initialized) {
#line 239
    return;
  }
#line 240
  initialized = 0;
#line 241
  if (connection_in == connection_out) {
#line 242
    shutdown(connection_out, 2);
#line 243
    close(connection_out);
  } else {
#line 245
    close(connection_in);
#line 246
    close(connection_out);
  }
#line 248
  buffer_free(& input);
#line 249
  buffer_free(& output);
#line 250
  buffer_free(& outgoing_packet);
#line 251
  buffer_free(& incoming_packet);
#line 252
  if (packet_compression) {
#line 253
    buffer_free(& compression_buffer);
#line 254
    buffer_compress_uninit();
  }
#line 256
  return;
}
}
#line 260 "packet.c"
void packet_set_protocol_flags(unsigned int protocol_flags ) 
{ 

  {
#line 263
  remote_protocol_flags = protocol_flags;
#line 264
  channel_set_options((protocol_flags & 2U) != 0U);
#line 265
  return;
}
}
#line 269 "packet.c"
unsigned int packet_get_protocol_flags(void) 
{ 

  {
#line 272
  return (remote_protocol_flags);
}
}
#line 281 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 284
  if (packet_compression) {
#line 285
    fatal("Compression already enabled.");
  }
#line 286
  packet_compression = 1;
#line 287
  buffer_init(& compression_buffer);
#line 288
  buffer_compress_init(level);
#line 289
  return;
}
}
#line 296 "packet.c"
void packet_encrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ 

  {
#line 300
  cipher_encrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 301
  return;
}
}
#line 308 "packet.c"
void packet_decrypt(CipherContext *cc , void *dest , void *src , unsigned int bytes ) 
{ int i ;

  {
#line 314
  if (bytes % 8U != 0U) {
#line 315
    fatal("packet_decrypt: bad ciphertext length %d", bytes);
  }
#line 322
  if (cc->type == 0U) {
#line 323
    i = 0;
  } else {
#line 322
    if (compat20) {
#line 323
      i = 0;
    } else {
#line 325
      i = detect_attack((unsigned char *)src, bytes, (unsigned char *)((void *)0));
    }
  }
#line 327
  if (i == 1) {
#line 328
    packet_disconnect("crc32 compensation attack: network attack detected");
  }
#line 330
  cipher_decrypt(cc, (unsigned char *)dest, (unsigned char const   *)src, bytes);
#line 331
  return;
}
}
#line 339 "packet.c"
void packet_set_encryption_key(unsigned char const   *key , unsigned int keylen ,
                               int cipher ) 
{ 

  {
#line 343
  if (keylen < 20U) {
#line 344
    fatal("keylen too small: %d", keylen);
  }
#line 347
  cipher_set_key(& receive_context, cipher, key, (int )keylen);
#line 348
  cipher_set_key(& send_context, cipher, key, (int )keylen);
#line 349
  return;
}
}
#line 353 "packet.c"
void packet_start1(int type ) 
{ char buf___1[9] ;

  {
#line 358
  buffer_clear(& outgoing_packet);
#line 359
  memset((void *)(buf___1), 0, 8U);
#line 360
  buf___1[8] = (char )type;
#line 361
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 9U);
#line 362
  return;
}
}
#line 364 "packet.c"
void packet_start2(int type ) 
{ char buf___1[6] ;

  {
#line 369
  buffer_clear(& outgoing_packet);
#line 370
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 373
  buf___1[5] = (char )(type & 255);
#line 374
  buffer_append(& outgoing_packet, (char const   *)(buf___1), sizeof(buf___1));
#line 375
  return;
}
}
#line 377 "packet.c"
void packet_start(int type ) 
{ 

  {
#line 381
  if (use_ssh2_packet_format) {
#line 382
    packet_start2(type);
  } else {
#line 384
    packet_start1(type);
  }
#line 385
  return;
}
}
#line 389 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 392
  ch = (char )value;
#line 393
  buffer_append(& outgoing_packet, (char const   *)(& ch), 1U);
#line 394
  return;
}
}
#line 398 "packet.c"
void packet_put_int(unsigned int value ) 
{ 

  {
#line 401
  buffer_put_int(& outgoing_packet, value);
#line 402
  return;
}
}
#line 406 "packet.c"
void packet_put_string(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 409
  buffer_put_string(& outgoing_packet, (void const   *)buf___1, len);
#line 410
  return;
}
}
#line 411 "packet.c"
void packet_put_cstring(char const   *str ) 
{ size_t tmp ;

  {
#line 414
  tmp = strlen(str);
#line 414
  buffer_put_string(& outgoing_packet, (void const   *)str, tmp);
#line 415
  return;
}
}
#line 417 "packet.c"
void packet_put_raw(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 420
  buffer_append(& outgoing_packet, buf___1, len);
#line 421
  return;
}
}
#line 426 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 429
  buffer_put_bignum(& outgoing_packet, value);
#line 430
  return;
}
}
#line 431 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 434
  buffer_put_bignum2(& outgoing_packet, value);
#line 435
  return;
}
}
#line 442 "packet.c"
void packet_send1(void) 
{ char buf___1[8] ;
  char *cp ;
  int i ;
  int padding ;
  int len ;
  unsigned int checksum ;
  u_int32_t rand___0 ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 448
  rand___0 = (u_int32_t )0;
#line 454
  if (packet_compression) {
#line 455
    buffer_clear(& compression_buffer);
#line 457
    buffer_consume(& outgoing_packet, 8U);
#line 459
    buffer_append(& compression_buffer, "\000\000\000\000\000\000\000\000", 8U);
#line 460
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 461
    buffer_clear(& outgoing_packet);
#line 462
    tmp = buffer_len(& compression_buffer);
#line 462
    tmp___0 = buffer_ptr(& compression_buffer);
#line 462
    buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
  }
#line 466
  tmp___1 = buffer_len(& outgoing_packet);
#line 466
  len = (int )((tmp___1 + 4U) - 8U);
#line 469
  padding = 8 - len % 8;
#line 470
  if (cipher_type != 0) {
#line 471
    cp = buffer_ptr(& outgoing_packet);
#line 472
    i = 0;
#line 472
    while (i < padding) {
#line 473
      if (i % 4 == 0) {
#line 474
        rand___0 = arc4random();
      }
#line 475
      *(cp + (7 - i)) = (char )(rand___0 & 255U);
#line 476
      rand___0 >>= 8;
#line 472
      i ++;
    }
  }
#line 479
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 482
  tmp___2 = buffer_len(& outgoing_packet);
#line 482
  tmp___3 = buffer_ptr(& outgoing_packet);
#line 482
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___3), tmp___2);
#line 484
  while (1) {
#line 484
    buf___1[0] = (char )(checksum >> 24);
#line 484
    buf___1[1] = (char )(checksum >> 16);
#line 484
    buf___1[2] = (char )(checksum >> 8);
#line 484
    buf___1[3] = (char )checksum;
#line 484
    break;
  }
#line 485
  buffer_append(& outgoing_packet, (char const   *)(buf___1), 4U);
#line 493
  while (1) {
#line 493
    buf___1[0] = (char )(len >> 24);
#line 493
    buf___1[1] = (char )(len >> 16);
#line 493
    buf___1[2] = (char )(len >> 8);
#line 493
    buf___1[3] = (char )len;
#line 493
    break;
  }
#line 494
  buffer_append(& output, (char const   *)(buf___1), 4U);
#line 495
  tmp___4 = buffer_len(& outgoing_packet);
#line 495
  buffer_append_space(& output, & cp, tmp___4);
#line 496
  tmp___5 = buffer_len(& outgoing_packet);
#line 496
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 496
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 504
  buffer_clear(& outgoing_packet);
#line 511
  return;
}
}
#line 524
void packet_send2(void) ;
#line 524 "packet.c"
static unsigned int seqnr  =    0U;
#line 516 "packet.c"
void packet_send2(void) 
{ unsigned char *macbuf ;
  char *cp ;
  unsigned int packet_length___0 ;
  unsigned int i ;
  unsigned int padlen ;
  unsigned int len ;
  u_int32_t rand___0 ;
  int type ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *tmp___6 ;

  {
#line 519
  macbuf = (unsigned char *)((void *)0);
#line 521
  packet_length___0 = 0U;
#line 523
  rand___0 = (u_int32_t )0;
#line 526
  enc = (Enc *)((void *)0);
#line 527
  mac = (Mac *)((void *)0);
#line 528
  comp = (Comp *)((void *)0);
#line 531
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 532
    enc = & kex->enc[1];
#line 533
    mac = & kex->mac[1];
#line 534
    comp = & kex->comp[1];
  }
#line 536
  if (enc) {
#line 536
    block_size = enc->block_size;
  } else {
#line 536
    block_size = 8;
  }
#line 538
  cp = buffer_ptr(& outgoing_packet);
#line 539
  type = (int )*(cp + 5) & 255;
#line 546
  if (comp) {
#line 546
    if (comp->enabled) {
#line 547
      len = buffer_len(& outgoing_packet);
#line 549
      buffer_consume(& outgoing_packet, 5U);
#line 550
      buffer_clear(& compression_buffer);
#line 551
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 552
      buffer_clear(& outgoing_packet);
#line 553
      buffer_append(& outgoing_packet, "\000\000\000\000\000", 5U);
#line 554
      tmp = buffer_len(& compression_buffer);
#line 554
      tmp___0 = buffer_ptr(& compression_buffer);
#line 554
      buffer_append(& outgoing_packet, (char const   *)tmp___0, tmp);
    }
  }
#line 561
  len = buffer_len(& outgoing_packet);
#line 567
  padlen = (unsigned int )block_size - len % (unsigned int )block_size;
#line 568
  if (padlen < 4U) {
#line 569
    padlen += (unsigned int )block_size;
  }
#line 570
  buffer_append_space(& outgoing_packet, & cp, padlen);
#line 571
  if (enc) {
#line 571
    if (enc->type != 0) {
#line 573
      i = 0U;
#line 573
      while (i < padlen) {
#line 574
        if (i % 4U == 0U) {
#line 575
          rand___0 = arc4random();
        }
#line 576
        *(cp + i) = (char )(rand___0 & 255U);
#line 577
        rand___0 <<= 8;
#line 573
        i ++;
      }
    } else {
#line 581
      memset((void *)cp, 0, padlen);
    }
  } else {
#line 581
    memset((void *)cp, 0, padlen);
  }
#line 584
  tmp___1 = buffer_len(& outgoing_packet);
#line 584
  packet_length___0 = tmp___1 - 4U;
#line 585
  cp = buffer_ptr(& outgoing_packet);
#line 586
  while (1) {
#line 586
    *(cp + 0) = (char )(packet_length___0 >> 24);
#line 586
    *(cp + 1) = (char )(packet_length___0 >> 16);
#line 586
    *(cp + 2) = (char )(packet_length___0 >> 8);
#line 586
    *(cp + 3) = (char )packet_length___0;
#line 586
    break;
  }
#line 587
  *(cp + 4) = (char )(padlen & 255U);
#line 591
  if (mac) {
#line 591
    if (mac->enabled) {
#line 592
      tmp___2 = buffer_len(& outgoing_packet);
#line 592
      tmp___3 = buffer_ptr(& outgoing_packet);
#line 592
      macbuf = hmac(mac->md, seqnr, (unsigned char *)tmp___3, (int )tmp___2, mac->key,
                    mac->key_len);
    }
  }
#line 600
  tmp___4 = buffer_len(& outgoing_packet);
#line 600
  buffer_append_space(& output, & cp, tmp___4);
#line 601
  tmp___5 = buffer_len(& outgoing_packet);
#line 601
  tmp___6 = buffer_ptr(& outgoing_packet);
#line 601
  packet_encrypt(& send_context, (void *)cp, (void *)tmp___6, tmp___5);
#line 604
  if (mac) {
#line 604
    if (mac->enabled) {
#line 605
      buffer_append(& output, (char const   *)((char *)macbuf), (unsigned int )mac->mac_len);
    }
  }
#line 611
  seqnr ++;
#line 611
  if (seqnr == 0U) {
#line 612
    log("outgoing seqnr wraps around");
  }
#line 613
  buffer_clear(& outgoing_packet);
#line 615
  if (type == 21) {
#line 616
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 617
      fatal("packet_send2: no KEX");
    } else {
#line 616
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 617
        fatal("packet_send2: no KEX");
      } else {
#line 616
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 617
          fatal("packet_send2: no KEX");
        } else {
#line 616
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 617
            fatal("packet_send2: no KEX");
          }
        }
      }
    }
#line 618
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 619
      mac->enabled = 1;
    }
#line 621
    cipher_set_key_iv(& send_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 624
    clear_enc_keys(enc, kex->we_need);
#line 625
    if (comp->type != 0) {
#line 625
      if (comp->enabled == 0) {
#line 626
        comp->enabled = 1;
#line 627
        if (! packet_compression) {
#line 628
          packet_start_compression(6);
        }
      }
    }
  }
#line 631
  return;
}
}
#line 633 "packet.c"
void packet_send(void) 
{ 

  {
#line 636
  if (use_ssh2_packet_format) {
#line 637
    packet_send2();
  } else {
#line 639
    packet_send1();
  }
#line 641
  return;
}
}
#line 649 "packet.c"
int packet_read(int *payload_len_ptr ) 
{ int type ;
  int len ;
  fd_set set ;
  char buf___1[8192] ;
  int _p ;
  int _e ;
  int __d0 ;
  int __d1 ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 658
  packet_write_wait();
#line 661
  while (1) {
#line 663
    type = packet_read_poll(payload_len_ptr);
#line 664
    if (! use_ssh2_packet_format) {
#line 664
      if (type == 14) {
        goto _L;
      } else {
#line 664
        if (type == 15) {
          goto _L;
        } else {
#line 664
          if (type == 19) {
            goto _L;
          } else {
#line 664
            if (type == 33) {
              _L: /* CIL Label */ 
#line 669
              while (1) {
#line 669
                _p = *payload_len_ptr;
#line 669
                _e = 0;
#line 669
                if (_p != _e) {
#line 669
                  log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "packet.c",
                      669);
#line 669
                  packet_disconnect("Packet integrity error. (%d)", type);
                }
#line 669
                break;
              }
            }
          }
        }
      }
    }
#line 671
    if (type != 0) {
#line 672
      return (type);
    }
#line 677
    while (1) {
#line 677
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 677
      break;
    }
#line 678
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 681
    select(connection_in + 1, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 684
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 685
    if (len == 0) {
#line 686
      tmp = get_remote_ipaddr();
#line 686
      log("Connection closed by %.200s", tmp);
#line 687
      fatal_cleanup();
    }
#line 689
    if (len < 0) {
#line 690
      tmp___0 = __errno_location();
#line 690
      tmp___1 = strerror(*tmp___0);
#line 690
      fatal("Read from socket failed: %.100s", tmp___1);
    }
#line 692
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 702 "packet.c"
void packet_read_expect(int *payload_len_ptr , int expected_type ) 
{ int type ;

  {
#line 707
  type = packet_read(payload_len_ptr);
#line 708
  if (type != expected_type) {
#line 709
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 711
  return;
}
}
#line 728 "packet.c"
int packet_read_poll1(int *payload_len_ptr ) 
{ unsigned int len ;
  unsigned int padded_len ;
  unsigned char *ucp ;
  char buf___1[8] ;
  char *cp ;
  unsigned int checksum ;
  unsigned int stored_checksum ;
  unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 737
  tmp = buffer_len(& input);
#line 737
  if (tmp < 12U) {
#line 738
    return (0);
  }
#line 740
  tmp___0 = buffer_ptr(& input);
#line 740
  ucp = (unsigned char *)tmp___0;
#line 741
  len = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 742
  if (len < 5U) {
#line 743
    packet_disconnect("Bad packet length %d.", len);
  } else {
#line 742
    if (len > 262144U) {
#line 743
      packet_disconnect("Bad packet length %d.", len);
    }
  }
#line 744
  padded_len = (len + 8U) & 4294967288U;
#line 747
  tmp___1 = buffer_len(& input);
#line 747
  if (tmp___1 < 4U + padded_len) {
#line 748
    return (0);
  }
#line 753
  buffer_consume(& input, 4U);
#line 756
  buffer_clear(& incoming_packet);
#line 757
  buffer_append_space(& incoming_packet, & cp, padded_len);
#line 758
  tmp___2 = buffer_ptr(& input);
#line 758
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___2, padded_len);
#line 759
  buffer_consume(& input, padded_len);
#line 767
  tmp___3 = buffer_len(& incoming_packet);
#line 767
  tmp___4 = buffer_ptr(& incoming_packet);
#line 767
  checksum = crc32((unsigned char const   *)((unsigned char *)tmp___4), tmp___3 - 4U);
#line 771
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 775
  tmp___6 = buffer_len(& incoming_packet);
#line 775
  if (len != tmp___6) {
#line 776
    tmp___5 = buffer_len(& incoming_packet);
#line 776
    packet_disconnect("packet_read_poll: len %d != buffer_len %d.", len, tmp___5);
  }
#line 779
  tmp___7 = buffer_ptr(& incoming_packet);
#line 779
  ucp = ((unsigned char *)tmp___7 + len) - 4;
#line 780
  stored_checksum = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 781
  if (checksum != stored_checksum) {
#line 782
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 783
  buffer_consume_end(& incoming_packet, 4U);
#line 786
  if (packet_compression) {
#line 787
    buffer_clear(& compression_buffer);
#line 788
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 789
    buffer_clear(& incoming_packet);
#line 790
    tmp___8 = buffer_len(& compression_buffer);
#line 790
    tmp___9 = buffer_ptr(& compression_buffer);
#line 790
    buffer_append(& incoming_packet, (char const   *)tmp___9, tmp___8);
  }
#line 794
  buffer_get(& incoming_packet, buf___1, 1U);
#line 797
  tmp___10 = buffer_len(& incoming_packet);
#line 797
  *payload_len_ptr = (int )tmp___10;
#line 800
  return ((int )((unsigned char )buf___1[0]));
}
}
#line 810
int packet_read_poll2(int *payload_len_ptr ) ;
#line 810 "packet.c"
static unsigned int packet_length  =    0U;
#line 811 "packet.c"
static unsigned int seqnr___0  =    0U;
#line 803 "packet.c"
int packet_read_poll2(int *payload_len_ptr ) 
{ unsigned int padlen ;
  unsigned int need ;
  unsigned char buf___1[8] ;
  unsigned char *macbuf ;
  unsigned char *ucp ;
  char *cp ;
  int type ;
  int maclen ;
  int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  unsigned int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 814
  enc = (Enc *)((void *)0);
#line 815
  mac = (Mac *)((void *)0);
#line 816
  comp = (Comp *)((void *)0);
#line 818
  if ((unsigned int )kex != (unsigned int )((void *)0)) {
#line 819
    enc = & kex->enc[0];
#line 820
    mac = & kex->mac[0];
#line 821
    comp = & kex->comp[0];
  }
#line 823
  if (mac) {
#line 823
    if (mac->enabled) {
#line 823
      maclen = mac->mac_len;
    } else {
#line 823
      maclen = 0;
    }
  } else {
#line 823
    maclen = 0;
  }
#line 824
  if (enc) {
#line 824
    block_size = enc->block_size;
  } else {
#line 824
    block_size = 8;
  }
#line 826
  if (packet_length == 0U) {
#line 831
    tmp = buffer_len(& input);
#line 831
    if (tmp < (unsigned int )block_size) {
#line 832
      return (0);
    }
#line 833
    buffer_clear(& incoming_packet);
#line 834
    buffer_append_space(& incoming_packet, & cp, (unsigned int )block_size);
#line 835
    tmp___0 = buffer_ptr(& input);
#line 835
    packet_decrypt(& receive_context, (void *)cp, (void *)tmp___0, (unsigned int )block_size);
#line 837
    tmp___1 = buffer_ptr(& incoming_packet);
#line 837
    ucp = (unsigned char *)tmp___1;
#line 838
    packet_length = (unsigned int )(((((unsigned long )*(ucp + 0) << 24) | ((unsigned long )*(ucp + 1) << 16)) | ((unsigned long )*(ucp + 2) << 8)) | (unsigned long )*(ucp + 3));
#line 839
    if (packet_length < 5U) {
#line 840
      buffer_dump(& incoming_packet);
#line 841
      packet_disconnect("Bad packet length %d.", packet_length);
    } else {
#line 839
      if (packet_length > 262144U) {
#line 840
        buffer_dump(& incoming_packet);
#line 841
        packet_disconnect("Bad packet length %d.", packet_length);
      }
    }
#line 844
    buffer_consume(& input, (unsigned int )block_size);
  }
#line 847
  need = (4U + packet_length) - (unsigned int )block_size;
#line 850
  if (need % (unsigned int )block_size != 0U) {
#line 851
    fatal("padding error: need %d block %d mod %d", need, block_size, need % (unsigned int )block_size);
  }
#line 857
  tmp___2 = buffer_len(& input);
#line 857
  if (tmp___2 < need + (unsigned int )maclen) {
#line 858
    return (0);
  }
#line 863
  buffer_append_space(& incoming_packet, & cp, need);
#line 864
  tmp___3 = buffer_ptr(& input);
#line 864
  packet_decrypt(& receive_context, (void *)cp, (void *)tmp___3, need);
#line 865
  buffer_consume(& input, need);
#line 870
  if (mac) {
#line 870
    if (mac->enabled) {
#line 871
      tmp___4 = buffer_len(& incoming_packet);
#line 871
      tmp___5 = buffer_ptr(& incoming_packet);
#line 871
      macbuf = hmac(mac->md, seqnr___0, (unsigned char *)tmp___5, (int )tmp___4, mac->key,
                    mac->key_len);
#line 876
      tmp___6 = buffer_ptr(& input);
#line 876
      tmp___7 = memcmp((void const   *)macbuf, (void const   *)tmp___6, (unsigned int )mac->mac_len);
#line 876
      if (tmp___7 != 0) {
#line 877
        packet_disconnect("Corrupted HMAC on input.");
      }
#line 879
      buffer_consume(& input, (unsigned int )mac->mac_len);
    }
  }
#line 881
  seqnr___0 ++;
#line 881
  if (seqnr___0 == 0U) {
#line 882
    log("incoming seqnr wraps around");
  }
#line 885
  tmp___8 = buffer_ptr(& incoming_packet);
#line 885
  cp = tmp___8 + 4;
#line 886
  padlen = (unsigned int )((int )*cp & 255);
#line 888
  if (padlen < 4U) {
#line 889
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 892
  buffer_consume(& incoming_packet, 5U);
#line 893
  buffer_consume_end(& incoming_packet, padlen);
#line 896
  if (comp) {
#line 896
    if (comp->enabled) {
#line 897
      buffer_clear(& compression_buffer);
#line 898
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 899
      buffer_clear(& incoming_packet);
#line 900
      tmp___9 = buffer_len(& compression_buffer);
#line 900
      tmp___10 = buffer_ptr(& compression_buffer);
#line 900
      buffer_append(& incoming_packet, (char const   *)tmp___10, tmp___9);
    }
  }
#line 908
  buffer_get(& incoming_packet, (char *)(buf___1), 1U);
#line 909
  tmp___11 = buffer_len(& incoming_packet);
#line 909
  *payload_len_ptr = (int )tmp___11;
#line 912
  packet_length = 0U;
#line 915
  type = (int )buf___1[0];
#line 917
  if (type == 21) {
#line 918
    if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 919
      fatal("packet_read_poll2: no KEX");
    } else {
#line 918
      if ((unsigned int )mac == (unsigned int )((void *)0)) {
#line 919
        fatal("packet_read_poll2: no KEX");
      } else {
#line 918
        if ((unsigned int )enc == (unsigned int )((void *)0)) {
#line 919
          fatal("packet_read_poll2: no KEX");
        } else {
#line 918
          if ((unsigned int )comp == (unsigned int )((void *)0)) {
#line 919
            fatal("packet_read_poll2: no KEX");
          }
        }
      }
    }
#line 920
    if ((unsigned int )mac->md != (unsigned int )((void *)0)) {
#line 921
      mac->enabled = 1;
    }
#line 923
    cipher_set_key_iv(& receive_context, enc->type, (unsigned char const   *)enc->key,
                      enc->key_len, (unsigned char const   *)enc->iv, enc->iv_len);
#line 926
    clear_enc_keys(enc, kex->we_need);
#line 927
    if (comp->type != 0) {
#line 927
      if (comp->enabled == 0) {
#line 928
        comp->enabled = 1;
#line 929
        if (! packet_compression) {
#line 930
          packet_start_compression(6);
        }
      }
    }
  }
#line 938
  return ((int )((unsigned char )type));
}
}
#line 941 "packet.c"
int packet_read_poll(int *payload_len_ptr ) 
{ char *msg ;
  int type ;
  int tmp___1 ;
  int reason ;
  unsigned int tmp___2 ;

  {
#line 945
  while (1) {
#line 946
    if (use_ssh2_packet_format) {
#line 946
      tmp___1 = packet_read_poll2(payload_len_ptr);
    } else {
#line 946
      tmp___1 = packet_read_poll1(payload_len_ptr);
    }
#line 946
    type = tmp___1;
#line 950
    if (compat20) {
#line 952
      if (type != 0) {

      }
#line 954
      switch (type) {
      case 2: 
#line 956
      break;
      case 4: 
#line 958
      packet_get_char();
#line 959
      msg = packet_get_string((unsigned int *)((void *)0));
#line 960
      debug("Remote: %.900s", msg);
#line 961
      xfree((void *)msg);
#line 962
      msg = packet_get_string((unsigned int *)((void *)0));
#line 963
      xfree((void *)msg);
#line 964
      break;
      case 1: 
#line 966
      tmp___2 = packet_get_int();
#line 966
      reason = (int )tmp___2;
#line 967
      msg = packet_get_string((unsigned int *)((void *)0));
#line 968
      log("Received disconnect: %d: %.900s", reason, msg);
#line 969
      xfree((void *)msg);
#line 970
      fatal_cleanup();
#line 971
      break;
      default: ;
#line 973
      return (type);
#line 974
      break;
      }
    } else {
#line 977
      switch (type) {
      case 32: 
#line 979
      break;
      case 36: 
#line 981
      msg = packet_get_string((unsigned int *)((void *)0));
#line 982
      debug("Remote: %.900s", msg);
#line 983
      xfree((void *)msg);
#line 984
      break;
      case 1: 
#line 986
      msg = packet_get_string((unsigned int *)((void *)0));
#line 987
      log("Received disconnect: %.900s", msg);
#line 988
      fatal_cleanup();
#line 989
      xfree((void *)msg);
#line 990
      break;
      default: ;
#line 992
      if (type != 0) {

      }
#line 994
      return (type);
#line 995
      break;
      }
    }
  }
}
}
#line 1006 "packet.c"
void packet_process_incoming(char const   *buf___1 , unsigned int len ) 
{ 

  {
#line 1009
  buffer_append(& input, buf___1, len);
#line 1010
  return;
}
}
#line 1014 "packet.c"
unsigned int packet_get_char(void) 
{ char ch ;

  {
#line 1018
  buffer_get(& incoming_packet, & ch, 1U);
#line 1019
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1024 "packet.c"
unsigned int packet_get_int(void) 
{ unsigned int tmp ;

  {
#line 1027
  tmp = buffer_get_int(& incoming_packet);
#line 1027
  return (tmp);
}
}
#line 1035 "packet.c"
void packet_get_bignum(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1038
  *length_ptr = buffer_get_bignum(& incoming_packet, value);
#line 1039
  return;
}
}
#line 1041 "packet.c"
void packet_get_bignum2(BIGNUM *value , int *length_ptr ) 
{ 

  {
#line 1044
  *length_ptr = buffer_get_bignum2(& incoming_packet, value);
#line 1045
  return;
}
}
#line 1047 "packet.c"
char *packet_get_raw(int *length_ptr ) 
{ int bytes ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 1050
  tmp = buffer_len(& incoming_packet);
#line 1050
  bytes = (int )tmp;
#line 1051
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1052
    *length_ptr = bytes;
  }
#line 1053
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1053
  return (tmp___0);
}
}
#line 1056 "packet.c"
int packet_remaining(void) 
{ unsigned int tmp ;

  {
#line 1059
  tmp = buffer_len(& incoming_packet);
#line 1059
  return ((int )tmp);
}
}
#line 1069 "packet.c"
char *packet_get_string(unsigned int *length_ptr ) 
{ char *tmp ;

  {
#line 1072
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1072
  return (tmp);
}
}
#line 1084 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1090
  __builtin_va_start(args, fmt);
#line 1091
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1092
  __builtin_va_end(args);
#line 1094
  if (compat20) {
#line 1095
    packet_start(4);
#line 1096
    packet_put_char(0);
#line 1097
    packet_put_cstring((char const   *)(buf___1));
#line 1098
    packet_put_cstring("");
  } else {
#line 1100
    packet_start(36);
#line 1101
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1103
  packet_send();
#line 1104
  packet_write_wait();
#line 1105
  return;
}
}
#line 1119 "packet.c"
static int disconnecting  =    0;
#line 1114 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;
  size_t tmp ;

  {
#line 1120
  if (disconnecting) {
#line 1121
    fatal("packet_disconnect called recursively.");
  }
#line 1122
  disconnecting = 1;
#line 1128
  __builtin_va_start(args, fmt);
#line 1129
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1130
  __builtin_va_end(args);
#line 1133
  if (compat20) {
#line 1134
    packet_start(1);
#line 1135
    packet_put_int(2U);
#line 1136
    packet_put_cstring((char const   *)(buf___1));
#line 1137
    packet_put_cstring("");
  } else {
#line 1139
    packet_start(1);
#line 1140
    tmp = strlen((char const   *)(buf___1));
#line 1140
    packet_put_string((char const   *)(buf___1), tmp);
  }
#line 1142
  packet_send();
#line 1143
  packet_write_wait();
#line 1146
  channel_stop_listening();
#line 1149
  packet_close();
#line 1152
  log("Disconnecting: %.100s", buf___1);
#line 1153
  fatal_cleanup();
#line 1154
  return;
}
}
#line 1158 "packet.c"
void packet_write_poll(void) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1161
  tmp = buffer_len(& output);
#line 1161
  len = (int )tmp;
#line 1162
  if (len > 0) {
#line 1163
    tmp___0 = buffer_ptr(& output);
#line 1163
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1164
    if (len <= 0) {
#line 1165
      tmp___3 = __errno_location();
#line 1165
      if (*tmp___3 == 11) {
#line 1166
        return;
      } else {
#line 1168
        tmp___1 = __errno_location();
#line 1168
        tmp___2 = strerror(*tmp___1);
#line 1168
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1170
    buffer_consume(& output, (unsigned int )len);
  }
#line 1172
  return;
}
}
#line 1179 "packet.c"
void packet_write_wait(void) 
{ fd_set set ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
#line 1182
  packet_write_poll();
#line 1183
  while (1) {
#line 1183
    tmp = packet_have_data_to_write();
#line 1183
    if (! tmp) {
#line 1183
      break;
    }
#line 1185
    while (1) {
#line 1185
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.__fds_bits[0]): "memory");
#line 1185
      break;
    }
#line 1186
    __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1187
    select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& set),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1188
    packet_write_poll();
  }
#line 1190
  return;
}
}
#line 1194 "packet.c"
int packet_have_data_to_write(void) 
{ unsigned int tmp ;

  {
#line 1197
  tmp = buffer_len(& output);
#line 1197
  return (tmp != 0U);
}
}
#line 1202 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1205
  if (interactive_mode) {
#line 1206
    tmp = buffer_len(& output);
#line 1206
    return (tmp < 16384U);
  } else {
#line 1208
    tmp___0 = buffer_len(& output);
#line 1208
    return (tmp___0 < 131072U);
  }
}
}
#line 1213 "packet.c"
void packet_set_interactive(int interactive , int keepalives ) 
{ int on ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int lowdelay ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int throughput ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 1216
  on = 1;
#line 1219
  interactive_mode = interactive;
#line 1222
  tmp = packet_connection_is_on_socket();
#line 1222
  if (! tmp) {
#line 1223
    return;
  }
#line 1224
  if (keepalives) {
#line 1226
    tmp___2 = setsockopt(connection_in, 1, 9, (void const   *)((void *)(& on)), sizeof(on));
#line 1226
    if (tmp___2 < 0) {
#line 1228
      tmp___0 = __errno_location();
#line 1228
      tmp___1 = strerror(*tmp___0);
#line 1228
      error("setsockopt SO_KEEPALIVE: %.100s", tmp___1);
    }
  }
#line 1233
  tmp___3 = packet_connection_is_ipv4();
#line 1233
  if (! tmp___3) {
#line 1234
    return;
  }
#line 1235
  if (interactive) {
#line 1240
    lowdelay = 16;
#line 1241
    tmp___6 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& lowdelay)),
                         sizeof(lowdelay));
#line 1241
    if (tmp___6 < 0) {
#line 1243
      tmp___4 = __errno_location();
#line 1243
      tmp___5 = strerror(*tmp___4);
#line 1243
      error("setsockopt IPTOS_LOWDELAY: %.100s", tmp___5);
    }
#line 1244
    tmp___9 = setsockopt(connection_in, 6, 1, (void const   *)((void *)(& on)), sizeof(on));
#line 1244
    if (tmp___9 < 0) {
#line 1246
      tmp___7 = __errno_location();
#line 1246
      tmp___8 = strerror(*tmp___7);
#line 1246
      error("setsockopt TCP_NODELAY: %.100s", tmp___8);
    }
  } else {
#line 1252
    throughput = 8;
#line 1253
    tmp___12 = setsockopt(connection_in, 0, 1, (void const   *)((void *)(& throughput)),
                          sizeof(throughput));
#line 1253
    if (tmp___12 < 0) {
#line 1255
      tmp___10 = __errno_location();
#line 1255
      tmp___11 = strerror(*tmp___10);
#line 1255
      error("setsockopt IPTOS_THROUGHPUT: %.100s", tmp___11);
    }
  }
#line 1257
  return;
}
}
#line 1261 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1264
  return (interactive_mode);
}
}
#line 1270 "packet.c"
static int called___0  =    0;
#line 1267 "packet.c"
int packet_set_maxsize(int s ) 
{ 

  {
#line 1271
  if (called___0) {
#line 1272
    log("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1274
    return (-1);
  }
#line 1276
  if (s < 4096) {
#line 1277
    log("packet_set_maxsize: bad size %d", s);
#line 1278
    return (-1);
  } else {
#line 1276
    if (s > 1048576) {
#line 1277
      log("packet_set_maxsize: bad size %d", s);
#line 1278
      return (-1);
    }
  }
#line 1280
  log("packet_set_maxsize: setting to %d", s);
#line 1281
  max_packet_size = s;
#line 1282
  return (s);
}
}
#line 1 "radix.o"
#line 1 "entropy.o"
#line 105 "/usr/include/openssl/rand.h"
extern void RAND_add(void const   *buf , int num , double entropy ) ;
#line 93 "entropy.c"
void get_random_bytes(unsigned char *buf___1 , int len ) ;
#line 93 "entropy.c"
static int random_pool  =    -1;
#line 91 "entropy.c"
void get_random_bytes(unsigned char *buf___1 , int len ) 
{ int c ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 96
  if (random_pool == -1) {
#line 97
    random_pool = open("/dev/urandom", 0);
#line 98
    if (random_pool == -1) {
#line 99
      tmp = __errno_location();
#line 99
      tmp___0 = strerror(*tmp);
#line 99
      fatal("Couldn\'t open random pool \"%s\": %s", "/dev/urandom", tmp___0);
    }
  }
#line 102
  c = atomicio((ssize_t (*)())(& read), random_pool, (void *)buf___1, (unsigned int )len);
#line 103
  if (c <= 0) {
#line 104
    tmp___1 = __errno_location();
#line 104
    tmp___2 = strerror(*tmp___1);
#line 104
    fatal("Couldn\'t read from random pool \"%s\": %s", "/dev/urandom", tmp___2);
  }
#line 105
  return;
}
}
#line 675 "entropy.c"
void seed_rng(void) 
{ char buf___1[32] ;

  {
#line 680
  debug("Seeding random number generator");
#line 681
  get_random_bytes((unsigned char *)(buf___1), (int )sizeof(buf___1));
#line 682
  RAND_add((void const   *)(buf___1), (int )sizeof(buf___1), (double )sizeof(buf___1));
#line 683
  memset((void *)(buf___1), '\000', sizeof(buf___1));
#line 684
  return;
}
}
#line 1 "readpass.o"
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 422 "ssh.h"
char *read_passphrase(char const   *prompt , int from_stdin ) ;
#line 40 "readpass.c"
int volatile   intr  ;
#line 42 "readpass.c"
void intcatch(void) 
{ 

  {
#line 45
  intr = (int volatile   )1;
#line 46
  return;
}
}
#line 53 "readpass.c"
char *read_passphrase(char const   *prompt , int from_stdin ) 
{ char buf___1[1024] ;
  char *p ;
  char ch ;
  struct termios tio ;
  struct termios saved_tio ;
  sigset_t oset ;
  sigset_t nset ;
  struct sigaction sa ;
  struct sigaction osa ;
  int input___0 ;
  int output___0 ;
  int echo ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  __pid_t tmp___3 ;

  {
#line 60
  echo = 0;
#line 62
  if (from_stdin) {
#line 63
    input___0 = 0;
#line 64
    output___0 = 2;
  } else {
#line 66
    output___0 = open("/dev/tty", 2);
#line 66
    input___0 = output___0;
  }
#line 68
  if (input___0 == -1) {
#line 69
    fatal("You have no controlling tty.  Cannot read passphrase.\n");
  }
#line 72
  sigemptyset(& nset);
#line 73
  sigaddset(& nset, 20);
#line 74
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 75
  memset((void *)(& sa), 0, sizeof(sa));
#line 76
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& intcatch);
#line 77
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& osa));
#line 79
  intr = (int volatile   )0;
#line 81
  tmp = tcgetattr(input___0, & saved_tio);
#line 81
  if (tmp == 0) {
#line 81
    if (saved_tio.c_lflag & 8U) {
#line 82
      echo = 1;
#line 83
      tio = saved_tio;
#line 84
      tio.c_lflag &= 4294967175U;
#line 85
      tcsetattr(input___0, 0, (struct termios  const  *)(& tio));
    }
  }
#line 88
  fflush(stdout);
#line 90
  tmp___0 = strlen(prompt);
#line 90
  write(output___0, (void const   *)prompt, tmp___0);
#line 91
  p = buf___1;
#line 91
  while (1) {
#line 91
    tmp___2 = read(input___0, (void *)(& ch), 1U);
#line 91
    if (tmp___2 == 1) {
#line 91
      if (! ((int )ch != 10)) {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
#line 92
    if (intr) {
#line 93
      break;
    }
#line 94
    if ((unsigned int )p < (unsigned int )((buf___1 + sizeof(buf___1)) - 1)) {
#line 95
      tmp___1 = p;
#line 95
      p ++;
#line 95
      *tmp___1 = ch;
    }
  }
#line 97
  *p = (char )'\000';
#line 98
  if (! intr) {
#line 99
    write(output___0, (void const   *)"\n", 1U);
  }
#line 102
  if (echo) {
#line 103
    tcsetattr(input___0, 0, (struct termios  const  *)(& saved_tio));
  }
#line 104
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 105
  sigaction(2, (struct sigaction  const  * __restrict  )(& osa), (struct sigaction * __restrict  )((void *)0));
#line 107
  if (intr) {
#line 108
    tmp___3 = getpid();
#line 108
    kill(tmp___3, 2);
#line 109
    sigemptyset(& nset);
#line 111
    sigsuspend((sigset_t const   *)(& nset));
  }
#line 114
  if (! from_stdin) {
#line 115
    close(input___0);
  }
#line 116
  p = xstrdup((char const   *)(buf___1));
#line 117
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 118
  return (p);
}
}
#line 1 "rsa.o"
#line 452 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 490
__inline static int putchar(int __c ) ;
#line 75 "/usr/include/bits/stdio.h"
__inline static int putchar(int __c ) 
{ int tmp ;

  {
#line 78
  tmp = _IO_putc(__c, stdout);
#line 78
  return (tmp);
}
}
#line 221 "/usr/include/openssl/rsa.h"
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 230
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 25 "rsa.h"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) ;
#line 31
void rsa_set_verbose(int verbose___0 ) ;
#line 33
int rsa_alive(void) ;
#line 35
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 36
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 45 "rsa.c"
int rsa_verbose  =    1;
#line 47 "rsa.c"
int rsa_alive(void) 
{ RSA *key ;

  {
#line 52
  seed_rng();
#line 53
  key = RSA_generate_key(32, 3UL, (void (*)(int  , int  , void * ))((void *)0), (void *)0);
#line 54
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 55
    return (0);
  }
#line 56
  RSA_free(key);
#line 57
  return (1);
}
}
#line 63 "rsa.c"
void keygen_progress(int p , int n___0 , void *arg ) 
{ char progress_chars[6] ;

  {
#line 66
  progress_chars[0] = (char )'.';
#line 66
  progress_chars[1] = (char )'o';
#line 66
  progress_chars[2] = (char )'+';
#line 66
  progress_chars[3] = (char )'O';
#line 66
  progress_chars[4] = (char )'?';
#line 66
  progress_chars[5] = (char )'\000';
#line 68
  if (p < 0) {
#line 69
    p = (int )(sizeof(progress_chars) - 2U);
  } else {
#line 68
    if ((unsigned int )p > sizeof(progress_chars) - 2U) {
#line 69
      p = (int )(sizeof(progress_chars) - 2U);
    }
  }
#line 71
  putchar((int )progress_chars[p]);
#line 72
  fflush(stdout);
#line 73
  return;
}
}
#line 81 "rsa.c"
void rsa_generate_key(RSA *prv , RSA *pub , unsigned int bits ) 
{ RSA *key ;

  {
#line 86
  seed_rng();
#line 88
  if (rsa_verbose) {
#line 89
    printf((char const   * __restrict  )"Generating RSA keys:  ");
#line 90
    fflush(stdout);
#line 91
    key = RSA_generate_key((int )bits, 35UL, & keygen_progress, (void *)0);
#line 92
    printf((char const   * __restrict  )"\n");
  } else {
#line 94
    key = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                           (void *)0);
  }
#line 96
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 97
    fatal("rsa_generate_key: key generation failed.");
  }
#line 100
  pub->n = BN_new();
#line 101
  BN_copy(pub->n, (BIGNUM const   *)key->n);
#line 102
  pub->e = BN_new();
#line 103
  BN_copy(pub->e, (BIGNUM const   *)key->e);
#line 106
  prv->n = BN_new();
#line 107
  BN_copy(prv->n, (BIGNUM const   *)key->n);
#line 108
  prv->e = BN_new();
#line 109
  BN_copy(prv->e, (BIGNUM const   *)key->e);
#line 110
  prv->d = BN_new();
#line 111
  BN_copy(prv->d, (BIGNUM const   *)key->d);
#line 112
  prv->p = BN_new();
#line 113
  BN_copy(prv->p, (BIGNUM const   *)key->p);
#line 114
  prv->q = BN_new();
#line 115
  BN_copy(prv->q, (BIGNUM const   *)key->q);
#line 117
  prv->dmp1 = BN_new();
#line 118
  BN_copy(prv->dmp1, (BIGNUM const   *)key->dmp1);
#line 120
  prv->dmq1 = BN_new();
#line 121
  BN_copy(prv->dmq1, (BIGNUM const   *)key->dmq1);
#line 123
  prv->iqmp = BN_new();
#line 124
  BN_copy(prv->iqmp, (BIGNUM const   *)key->iqmp);
#line 126
  RSA_free(key);
#line 128
  if (rsa_verbose) {
#line 129
    printf((char const   * __restrict  )"Key generation complete.\n");
  }
#line 130
  return;
}
}
#line 132 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 138
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 138
  if (tmp < 2) {
#line 139
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 138
    if ((key->e)->top > 0) {
#line 138
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 139
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 139
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 141
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 141
  olen = (tmp___0 + 7) / 8;
#line 142
  tmp___1 = xmalloc((unsigned int )olen);
#line 142
  outbuf = (unsigned char *)tmp___1;
#line 144
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 144
  ilen = (tmp___2 + 7) / 8;
#line 145
  tmp___3 = xmalloc((unsigned int )ilen);
#line 145
  inbuf = (unsigned char *)tmp___3;
#line 146
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 148
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 148
  if (len <= 0) {
#line 150
    fatal("rsa_public_encrypt() failed");
  }
#line 152
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 154
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 155
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 156
  xfree((void *)outbuf);
#line 157
  xfree((void *)inbuf);
#line 158
  return;
}
}
#line 160 "rsa.c"
void rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ unsigned char *inbuf ;
  unsigned char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 166
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 166
  olen = (tmp + 7) / 8;
#line 167
  tmp___0 = xmalloc((unsigned int )olen);
#line 167
  outbuf = (unsigned char *)tmp___0;
#line 169
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 169
  ilen = (tmp___1 + 7) / 8;
#line 170
  tmp___2 = xmalloc((unsigned int )ilen);
#line 170
  inbuf = (unsigned char *)tmp___2;
#line 171
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 173
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 173
  if (len <= 0) {
#line 175
    fatal("rsa_private_decrypt() failed");
  }
#line 177
  BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 179
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 180
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 181
  xfree((void *)outbuf);
#line 182
  xfree((void *)inbuf);
#line 183
  return;
}
}
#line 187 "rsa.c"
void rsa_set_verbose(int verbose___0 ) 
{ 

  {
#line 190
  rsa_verbose = verbose___0;
#line 191
  return;
}
}
#line 1 "tildexpand.o"
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 486 "ssh.h"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) ;
#line 18 "tildexpand.c"
char *tilde_expand_filename(char const   *filename , uid_t my_uid ) 
{ char const   *cp ;
  unsigned int userlen ;
  char *expanded ;
  struct passwd *pw ;
  char user[100] ;
  int len ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 29
  if ((int const   )*(filename + 0) != 126) {
#line 30
    tmp = xstrdup(filename);
#line 30
    return (tmp);
  }
#line 33
  filename ++;
#line 36
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 36
  cp = (char const   *)tmp___1;
#line 37
  if (cp) {
#line 38
    userlen = (unsigned int )(cp - filename);
  } else {
#line 40
    userlen = strlen(filename);
  }
#line 41
  if (userlen == 0U) {
#line 42
    pw = getpwuid(my_uid);
  } else {
#line 45
    if (userlen > sizeof(user) - 1U) {
#line 46
      fatal("User name after tilde too long.");
    }
#line 47
    memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, userlen);
#line 48
    user[userlen] = (char)0;
#line 49
    pw = getpwnam((char const   *)(user));
  }
#line 51
  if (! pw) {
#line 52
    fatal("Unknown user %100s.", user);
  }
#line 55
  if (! cp) {
#line 57
    tmp___2 = xstrdup((char const   *)pw->pw_dir);
#line 57
    return (tmp___2);
  }
#line 60
  tmp___3 = strlen((char const   *)pw->pw_dir);
#line 60
  tmp___4 = strlen(cp + 1);
#line 60
  len = (int )((tmp___3 + tmp___4) + 2U);
#line 61
  if (len > 4096) {
#line 62
    fatal("Home directory too long (%d > %d", len - 1, 4095);
  }
#line 63
  tmp___5 = xmalloc((unsigned int )len);
#line 63
  expanded = (char *)tmp___5;
#line 64
  snprintf((char * __restrict  )expanded, (unsigned int )len, (char const   * __restrict  )"%s/%s",
           pw->pw_dir, cp + 1);
#line 65
  return (expanded);
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 184 "packet.h"
void tty_make_modes(int fd ) ;
#line 187
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 26 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 29
  switch ((int )speed) {
  case 0: 
#line 31
  return (0);
  case 1: 
#line 33
  return (50);
  case 2: 
#line 35
  return (75);
  case 3: 
#line 37
  return (110);
  case 4: 
#line 39
  return (134);
  case 5: 
#line 41
  return (150);
  case 6: 
#line 43
  return (200);
  case 7: 
#line 45
  return (300);
  case 8: 
#line 47
  return (600);
  case 9: 
#line 49
  return (1200);
  case 10: 
#line 51
  return (1800);
  case 11: 
#line 53
  return (2400);
  case 12: 
#line 55
  return (4800);
  case 13: 
#line 57
  return (9600);
  case 14: 
#line 61
  return (19200);
  case 15: 
#line 71
  return (38400);
  case 4097: 
#line 93
  return (57600);
  case 4098: 
#line 101
  return (115200);
  case 4099: 
#line 105
  return (230400);
  default: ;
#line 108
  return (9600);
  }
}
}
#line 115 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 118
  switch (baud) {
  case 0: 
#line 120
  return (0U);
  case 50: 
#line 122
  return (1U);
  case 75: 
#line 124
  return (2U);
  case 110: 
#line 126
  return (3U);
  case 134: 
#line 128
  return (4U);
  case 150: 
#line 130
  return (5U);
  case 200: 
#line 132
  return (6U);
  case 300: 
#line 134
  return (7U);
  case 600: 
#line 136
  return (8U);
  case 1200: 
#line 138
  return (9U);
  case 1800: 
#line 140
  return (10U);
  case 2400: 
#line 142
  return (11U);
  case 4800: 
#line 144
  return (12U);
  case 9600: 
#line 146
  return (13U);
  case 19200: 
#line 150
  return (14U);
  case 38400: 
#line 160
  return (15U);
  case 57600: 
#line 182
  return (4097U);
  case 115200: 
#line 190
  return (4098U);
  case 230400: 
#line 194
  return (4099U);
  default: ;
#line 197
  return (13U);
  }
}
}
#line 206 "ttymodes.c"
void tty_make_modes(int fd ) 
{ struct termios tio ;
  int baud ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;

  {
#line 212
  tmp___1 = tcgetattr(fd, & tio);
#line 212
  if (tmp___1 < 0) {
#line 213
    packet_put_char(0);
#line 214
    tmp = __errno_location();
#line 214
    tmp___0 = strerror(*tmp);
#line 214
    log("tcgetattr: %.100s", tmp___0);
#line 215
    return;
  }
#line 218
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 218
  baud = speed_to_baud(tmp___2);
#line 219
  packet_put_char(193);
#line 220
  packet_put_int((unsigned int )baud);
#line 221
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 221
  baud = speed_to_baud(tmp___3);
#line 222
  packet_put_char(192);
#line 223
  packet_put_int((unsigned int )baud);
#line 37 "ttymodes.h"
  packet_put_char(1);
#line 37
  packet_put_char((int )tio.c_cc[0]);
#line 38
  packet_put_char(2);
#line 38
  packet_put_char((int )tio.c_cc[1]);
#line 39
  packet_put_char(3);
#line 39
  packet_put_char((int )tio.c_cc[2]);
#line 41
  packet_put_char(4);
#line 41
  packet_put_char((int )tio.c_cc[3]);
#line 43
  packet_put_char(5);
#line 43
  packet_put_char((int )tio.c_cc[4]);
#line 45
  packet_put_char(6);
#line 45
  packet_put_char((int )tio.c_cc[11]);
#line 48
  packet_put_char(7);
#line 48
  packet_put_char((int )tio.c_cc[16]);
#line 50
  packet_put_char(8);
#line 50
  packet_put_char((int )tio.c_cc[8]);
#line 51
  packet_put_char(9);
#line 51
  packet_put_char((int )tio.c_cc[9]);
#line 53
  packet_put_char(10);
#line 53
  packet_put_char((int )tio.c_cc[10]);
#line 59
  packet_put_char(12);
#line 59
  packet_put_char((int )tio.c_cc[12]);
#line 62
  packet_put_char(13);
#line 62
  packet_put_char((int )tio.c_cc[14]);
#line 65
  packet_put_char(14);
#line 65
  packet_put_char((int )tio.c_cc[15]);
#line 77
  packet_put_char(18);
#line 77
  packet_put_char((int )tio.c_cc[13]);
#line 81
  packet_put_char(30);
#line 81
  packet_put_char((tio.c_iflag & 4U) != 0U);
#line 82
  packet_put_char(31);
#line 82
  packet_put_char((tio.c_iflag & 8U) != 0U);
#line 83
  packet_put_char(32);
#line 83
  packet_put_char((tio.c_iflag & 16U) != 0U);
#line 84
  packet_put_char(33);
#line 84
  packet_put_char((tio.c_iflag & 32U) != 0U);
#line 85
  packet_put_char(34);
#line 85
  packet_put_char((tio.c_iflag & 64U) != 0U);
#line 86
  packet_put_char(35);
#line 86
  packet_put_char((tio.c_iflag & 128U) != 0U);
#line 87
  packet_put_char(36);
#line 87
  packet_put_char((tio.c_iflag & 256U) != 0U);
#line 89
  packet_put_char(37);
#line 89
  packet_put_char((tio.c_iflag & 512U) != 0U);
#line 91
  packet_put_char(38);
#line 91
  packet_put_char((tio.c_iflag & 1024U) != 0U);
#line 92
  packet_put_char(39);
#line 92
  packet_put_char((tio.c_iflag & 2048U) != 0U);
#line 93
  packet_put_char(40);
#line 93
  packet_put_char((tio.c_iflag & 4096U) != 0U);
#line 95
  packet_put_char(41);
#line 95
  packet_put_char((tio.c_iflag & 8192U) != 0U);
#line 98
  packet_put_char(50);
#line 98
  packet_put_char((tio.c_lflag & 1U) != 0U);
#line 99
  packet_put_char(51);
#line 99
  packet_put_char((tio.c_lflag & 2U) != 0U);
#line 101
  packet_put_char(52);
#line 101
  packet_put_char((tio.c_lflag & 4U) != 0U);
#line 103
  packet_put_char(53);
#line 103
  packet_put_char((tio.c_lflag & 8U) != 0U);
#line 104
  packet_put_char(54);
#line 104
  packet_put_char((tio.c_lflag & 16U) != 0U);
#line 105
  packet_put_char(55);
#line 105
  packet_put_char((tio.c_lflag & 32U) != 0U);
#line 106
  packet_put_char(56);
#line 106
  packet_put_char((tio.c_lflag & 64U) != 0U);
#line 107
  packet_put_char(57);
#line 107
  packet_put_char((tio.c_lflag & 128U) != 0U);
#line 108
  packet_put_char(58);
#line 108
  packet_put_char((tio.c_lflag & 256U) != 0U);
#line 110
  packet_put_char(59);
#line 110
  packet_put_char((tio.c_lflag & 32768U) != 0U);
#line 113
  packet_put_char(60);
#line 113
  packet_put_char((tio.c_lflag & 512U) != 0U);
#line 116
  packet_put_char(61);
#line 116
  packet_put_char((tio.c_lflag & 2048U) != 0U);
#line 119
  packet_put_char(62);
#line 119
  packet_put_char((tio.c_lflag & 16384U) != 0U);
#line 122
  packet_put_char(70);
#line 122
  packet_put_char((tio.c_oflag & 1U) != 0U);
#line 124
  packet_put_char(71);
#line 124
  packet_put_char((tio.c_oflag & 2U) != 0U);
#line 126
  packet_put_char(72);
#line 126
  packet_put_char((tio.c_oflag & 4U) != 0U);
#line 128
  packet_put_char(73);
#line 128
  packet_put_char((tio.c_oflag & 8U) != 0U);
#line 131
  packet_put_char(74);
#line 131
  packet_put_char((tio.c_oflag & 16U) != 0U);
#line 134
  packet_put_char(75);
#line 134
  packet_put_char((tio.c_oflag & 32U) != 0U);
#line 137
  packet_put_char(90);
#line 137
  packet_put_char((tio.c_cflag & 32U) != 0U);
#line 138
  packet_put_char(91);
#line 138
  packet_put_char((tio.c_cflag & 48U) != 0U);
#line 139
  packet_put_char(92);
#line 139
  packet_put_char((tio.c_cflag & 256U) != 0U);
#line 140
  packet_put_char(93);
#line 140
  packet_put_char((tio.c_cflag & 512U) != 0U);
#line 243 "ttymodes.c"
  packet_put_char(0);
#line 244
  return;
}
}
#line 250 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  speed_t tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  int _p ;
  int _e ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;

  {
#line 255
  n_bytes = 0;
#line 256
  failure = 0;
#line 263
  tmp = tcgetattr(fd, & tio);
#line 263
  if (tmp < 0) {
#line 264
    failure = -1;
  }
#line 266
  while (1) {
#line 267
    n_bytes ++;
#line 268
    tmp___0 = packet_get_char();
#line 268
    opcode = (int )tmp___0;
#line 269
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
#line 274
    n_bytes += 4;
#line 275
    tmp___1 = packet_get_int();
#line 275
    baud = (int )tmp___1;
#line 276
    if (failure != -1) {
#line 276
      tmp___2 = baud_to_speed(baud);
#line 276
      tmp___3 = cfsetispeed(& tio, tmp___2);
#line 276
      if (tmp___3 < 0) {
#line 277
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 278
    break;
    case 193: 
#line 281
    n_bytes += 4;
#line 282
    tmp___4 = packet_get_int();
#line 282
    baud = (int )tmp___4;
#line 283
    if (failure != -1) {
#line 283
      tmp___5 = baud_to_speed(baud);
#line 283
      tmp___6 = cfsetospeed(& tio, tmp___5);
#line 283
      if (tmp___6 < 0) {
#line 284
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 285
    break;
    case 1: 
#line 37 "ttymodes.h"
    n_bytes ++;
#line 37
    tmp___7 = packet_get_char();
#line 37
    tio.c_cc[0] = (unsigned char )tmp___7;
#line 37
    break;
    case 2: 
#line 38
    n_bytes ++;
#line 38
    tmp___8 = packet_get_char();
#line 38
    tio.c_cc[1] = (unsigned char )tmp___8;
#line 38
    break;
    case 3: 
#line 39
    n_bytes ++;
#line 39
    tmp___9 = packet_get_char();
#line 39
    tio.c_cc[2] = (unsigned char )tmp___9;
#line 39
    break;
    case 4: 
#line 41
    n_bytes ++;
#line 41
    tmp___10 = packet_get_char();
#line 41
    tio.c_cc[3] = (unsigned char )tmp___10;
#line 41
    break;
    case 5: 
#line 43
    n_bytes ++;
#line 43
    tmp___11 = packet_get_char();
#line 43
    tio.c_cc[4] = (unsigned char )tmp___11;
#line 43
    break;
    case 6: 
#line 45
    n_bytes ++;
#line 45
    tmp___12 = packet_get_char();
#line 45
    tio.c_cc[11] = (unsigned char )tmp___12;
#line 45
    break;
    case 7: 
#line 48
    n_bytes ++;
#line 48
    tmp___13 = packet_get_char();
#line 48
    tio.c_cc[16] = (unsigned char )tmp___13;
#line 48
    break;
    case 8: 
#line 50
    n_bytes ++;
#line 50
    tmp___14 = packet_get_char();
#line 50
    tio.c_cc[8] = (unsigned char )tmp___14;
#line 50
    break;
    case 9: 
#line 51
    n_bytes ++;
#line 51
    tmp___15 = packet_get_char();
#line 51
    tio.c_cc[9] = (unsigned char )tmp___15;
#line 51
    break;
    case 10: 
#line 53
    n_bytes ++;
#line 53
    tmp___16 = packet_get_char();
#line 53
    tio.c_cc[10] = (unsigned char )tmp___16;
#line 53
    break;
    case 12: 
#line 59
    n_bytes ++;
#line 59
    tmp___17 = packet_get_char();
#line 59
    tio.c_cc[12] = (unsigned char )tmp___17;
#line 59
    break;
    case 13: 
#line 62
    n_bytes ++;
#line 62
    tmp___18 = packet_get_char();
#line 62
    tio.c_cc[14] = (unsigned char )tmp___18;
#line 62
    break;
    case 14: 
#line 65
    n_bytes ++;
#line 65
    tmp___19 = packet_get_char();
#line 65
    tio.c_cc[15] = (unsigned char )tmp___19;
#line 65
    break;
    case 18: 
#line 77
    n_bytes ++;
#line 77
    tmp___20 = packet_get_char();
#line 77
    tio.c_cc[13] = (unsigned char )tmp___20;
#line 77
    break;
    case 30: 
#line 81
    n_bytes ++;
#line 81
    tmp___21 = packet_get_char();
#line 81
    if (tmp___21) {
#line 81
      tio.c_iflag |= 4U;
    } else {
#line 81
      tio.c_iflag &= 4294967291U;
    }
#line 81
    break;
    case 31: 
#line 82
    n_bytes ++;
#line 82
    tmp___22 = packet_get_char();
#line 82
    if (tmp___22) {
#line 82
      tio.c_iflag |= 8U;
    } else {
#line 82
      tio.c_iflag &= 4294967287U;
    }
#line 82
    break;
    case 32: 
#line 83
    n_bytes ++;
#line 83
    tmp___23 = packet_get_char();
#line 83
    if (tmp___23) {
#line 83
      tio.c_iflag |= 16U;
    } else {
#line 83
      tio.c_iflag &= 4294967279U;
    }
#line 83
    break;
    case 33: 
#line 84
    n_bytes ++;
#line 84
    tmp___24 = packet_get_char();
#line 84
    if (tmp___24) {
#line 84
      tio.c_iflag |= 32U;
    } else {
#line 84
      tio.c_iflag &= 4294967263U;
    }
#line 84
    break;
    case 34: 
#line 85
    n_bytes ++;
#line 85
    tmp___25 = packet_get_char();
#line 85
    if (tmp___25) {
#line 85
      tio.c_iflag |= 64U;
    } else {
#line 85
      tio.c_iflag &= 4294967231U;
    }
#line 85
    break;
    case 35: 
#line 86
    n_bytes ++;
#line 86
    tmp___26 = packet_get_char();
#line 86
    if (tmp___26) {
#line 86
      tio.c_iflag |= 128U;
    } else {
#line 86
      tio.c_iflag &= 4294967167U;
    }
#line 86
    break;
    case 36: 
#line 87
    n_bytes ++;
#line 87
    tmp___27 = packet_get_char();
#line 87
    if (tmp___27) {
#line 87
      tio.c_iflag |= 256U;
    } else {
#line 87
      tio.c_iflag &= 4294967039U;
    }
#line 87
    break;
    case 37: 
#line 89
    n_bytes ++;
#line 89
    tmp___28 = packet_get_char();
#line 89
    if (tmp___28) {
#line 89
      tio.c_iflag |= 512U;
    } else {
#line 89
      tio.c_iflag &= 4294966783U;
    }
#line 89
    break;
    case 38: 
#line 91
    n_bytes ++;
#line 91
    tmp___29 = packet_get_char();
#line 91
    if (tmp___29) {
#line 91
      tio.c_iflag |= 1024U;
    } else {
#line 91
      tio.c_iflag &= 4294966271U;
    }
#line 91
    break;
    case 39: 
#line 92
    n_bytes ++;
#line 92
    tmp___30 = packet_get_char();
#line 92
    if (tmp___30) {
#line 92
      tio.c_iflag |= 2048U;
    } else {
#line 92
      tio.c_iflag &= 4294965247U;
    }
#line 92
    break;
    case 40: 
#line 93
    n_bytes ++;
#line 93
    tmp___31 = packet_get_char();
#line 93
    if (tmp___31) {
#line 93
      tio.c_iflag |= 4096U;
    } else {
#line 93
      tio.c_iflag &= 4294963199U;
    }
#line 93
    break;
    case 41: 
#line 95
    n_bytes ++;
#line 95
    tmp___32 = packet_get_char();
#line 95
    if (tmp___32) {
#line 95
      tio.c_iflag |= 8192U;
    } else {
#line 95
      tio.c_iflag &= 4294959103U;
    }
#line 95
    break;
    case 50: 
#line 98
    n_bytes ++;
#line 98
    tmp___33 = packet_get_char();
#line 98
    if (tmp___33) {
#line 98
      tio.c_lflag |= 1U;
    } else {
#line 98
      tio.c_lflag &= 4294967294U;
    }
#line 98
    break;
    case 51: 
#line 99
    n_bytes ++;
#line 99
    tmp___34 = packet_get_char();
#line 99
    if (tmp___34) {
#line 99
      tio.c_lflag |= 2U;
    } else {
#line 99
      tio.c_lflag &= 4294967293U;
    }
#line 99
    break;
    case 52: 
#line 101
    n_bytes ++;
#line 101
    tmp___35 = packet_get_char();
#line 101
    if (tmp___35) {
#line 101
      tio.c_lflag |= 4U;
    } else {
#line 101
      tio.c_lflag &= 4294967291U;
    }
#line 101
    break;
    case 53: 
#line 103
    n_bytes ++;
#line 103
    tmp___36 = packet_get_char();
#line 103
    if (tmp___36) {
#line 103
      tio.c_lflag |= 8U;
    } else {
#line 103
      tio.c_lflag &= 4294967287U;
    }
#line 103
    break;
    case 54: 
#line 104
    n_bytes ++;
#line 104
    tmp___37 = packet_get_char();
#line 104
    if (tmp___37) {
#line 104
      tio.c_lflag |= 16U;
    } else {
#line 104
      tio.c_lflag &= 4294967279U;
    }
#line 104
    break;
    case 55: 
#line 105
    n_bytes ++;
#line 105
    tmp___38 = packet_get_char();
#line 105
    if (tmp___38) {
#line 105
      tio.c_lflag |= 32U;
    } else {
#line 105
      tio.c_lflag &= 4294967263U;
    }
#line 105
    break;
    case 56: 
#line 106
    n_bytes ++;
#line 106
    tmp___39 = packet_get_char();
#line 106
    if (tmp___39) {
#line 106
      tio.c_lflag |= 64U;
    } else {
#line 106
      tio.c_lflag &= 4294967231U;
    }
#line 106
    break;
    case 57: 
#line 107
    n_bytes ++;
#line 107
    tmp___40 = packet_get_char();
#line 107
    if (tmp___40) {
#line 107
      tio.c_lflag |= 128U;
    } else {
#line 107
      tio.c_lflag &= 4294967167U;
    }
#line 107
    break;
    case 58: 
#line 108
    n_bytes ++;
#line 108
    tmp___41 = packet_get_char();
#line 108
    if (tmp___41) {
#line 108
      tio.c_lflag |= 256U;
    } else {
#line 108
      tio.c_lflag &= 4294967039U;
    }
#line 108
    break;
    case 59: 
#line 110
    n_bytes ++;
#line 110
    tmp___42 = packet_get_char();
#line 110
    if (tmp___42) {
#line 110
      tio.c_lflag |= 32768U;
    } else {
#line 110
      tio.c_lflag &= 4294934527U;
    }
#line 110
    break;
    case 60: 
#line 113
    n_bytes ++;
#line 113
    tmp___43 = packet_get_char();
#line 113
    if (tmp___43) {
#line 113
      tio.c_lflag |= 512U;
    } else {
#line 113
      tio.c_lflag &= 4294966783U;
    }
#line 113
    break;
    case 61: 
#line 116
    n_bytes ++;
#line 116
    tmp___44 = packet_get_char();
#line 116
    if (tmp___44) {
#line 116
      tio.c_lflag |= 2048U;
    } else {
#line 116
      tio.c_lflag &= 4294965247U;
    }
#line 116
    break;
    case 62: 
#line 119
    n_bytes ++;
#line 119
    tmp___45 = packet_get_char();
#line 119
    if (tmp___45) {
#line 119
      tio.c_lflag |= 16384U;
    } else {
#line 119
      tio.c_lflag &= 4294950911U;
    }
#line 119
    break;
    case 70: 
#line 122
    n_bytes ++;
#line 122
    tmp___46 = packet_get_char();
#line 122
    if (tmp___46) {
#line 122
      tio.c_oflag |= 1U;
    } else {
#line 122
      tio.c_oflag &= 4294967294U;
    }
#line 122
    break;
    case 71: 
#line 124
    n_bytes ++;
#line 124
    tmp___47 = packet_get_char();
#line 124
    if (tmp___47) {
#line 124
      tio.c_oflag |= 2U;
    } else {
#line 124
      tio.c_oflag &= 4294967293U;
    }
#line 124
    break;
    case 72: 
#line 126
    n_bytes ++;
#line 126
    tmp___48 = packet_get_char();
#line 126
    if (tmp___48) {
#line 126
      tio.c_oflag |= 4U;
    } else {
#line 126
      tio.c_oflag &= 4294967291U;
    }
#line 126
    break;
    case 73: 
#line 128
    n_bytes ++;
#line 128
    tmp___49 = packet_get_char();
#line 128
    if (tmp___49) {
#line 128
      tio.c_oflag |= 8U;
    } else {
#line 128
      tio.c_oflag &= 4294967287U;
    }
#line 128
    break;
    case 74: 
#line 131
    n_bytes ++;
#line 131
    tmp___50 = packet_get_char();
#line 131
    if (tmp___50) {
#line 131
      tio.c_oflag |= 16U;
    } else {
#line 131
      tio.c_oflag &= 4294967279U;
    }
#line 131
    break;
    case 75: 
#line 134
    n_bytes ++;
#line 134
    tmp___51 = packet_get_char();
#line 134
    if (tmp___51) {
#line 134
      tio.c_oflag |= 32U;
    } else {
#line 134
      tio.c_oflag &= 4294967263U;
    }
#line 134
    break;
    case 90: 
#line 137
    n_bytes ++;
#line 137
    tmp___52 = packet_get_char();
#line 137
    if (tmp___52) {
#line 137
      tio.c_cflag |= 32U;
    } else {
#line 137
      tio.c_cflag &= 4294967263U;
    }
#line 137
    break;
    case 91: 
#line 138
    n_bytes ++;
#line 138
    tmp___53 = packet_get_char();
#line 138
    if (tmp___53) {
#line 138
      tio.c_cflag |= 48U;
    } else {
#line 138
      tio.c_cflag &= 4294967247U;
    }
#line 138
    break;
    case 92: 
#line 139
    n_bytes ++;
#line 139
    tmp___54 = packet_get_char();
#line 139
    if (tmp___54) {
#line 139
      tio.c_cflag |= 256U;
    } else {
#line 139
      tio.c_cflag &= 4294967039U;
    }
#line 139
    break;
    case 93: 
#line 140
    n_bytes ++;
#line 140
    tmp___55 = packet_get_char();
#line 140
    if (tmp___55) {
#line 140
      tio.c_cflag |= 512U;
    } else {
#line 140
      tio.c_cflag &= 4294966783U;
    }
#line 140
    break;
    default: 
#line 313 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 319
    if (opcode >= 0) {
#line 319
      if (opcode < 128) {
#line 320
        n_bytes ++;
#line 321
        packet_get_char();
#line 322
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 328
      if (opcode >= 128) {
#line 328
        if (opcode < 160) {
#line 329
          n_bytes += 4;
#line 330
          packet_get_int();
#line 331
          break;
        }
      }
    }
#line 341
    log("parse_tty_modes: unknown opcode %d", opcode);
#line 342
    while (1) {
#line 342
      _p = 0;
#line 342
      _e = 1;
#line 342
      if (_p != _e) {
#line 342
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "ttymodes.c", 342);
#line 342
        packet_disconnect("Packet integrity error. (%d)", 10);
      }
#line 342
      break;
    }
    goto set;
    }
  }
  set: 
#line 348
  if (*n_bytes_ptr != n_bytes) {
#line 349
    *n_bytes_ptr = n_bytes;
#line 350
    return;
  }
#line 352
  if (failure == -1) {
#line 353
    return;
  }
#line 356
  tmp___58 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 356
  if (tmp___58 < 0) {
#line 357
    tmp___56 = __errno_location();
#line 357
    tmp___57 = strerror(*tmp___56);
#line 357
    log("Setting tty modes failed: %.100s", tmp___57);
  }
#line 358
  return;
}
}
#line 1 "uidswap.o"
#line 645 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 34 "uidswap.h"
void permanently_set_uid(uid_t uid ) ;
#line 30 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 38 "uidswap.c"
void temporarily_use_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 43
  saved_euid = geteuid();
#line 46
  tmp___1 = seteuid(uid);
#line 46
  if (tmp___1 == -1) {
#line 47
    tmp = __errno_location();
#line 47
    tmp___0 = strerror(*tmp);
#line 47
    debug("seteuid %d: %.100s", (int )uid, tmp___0);
  }
#line 57
  return;
}
}
#line 62 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 67
  tmp___1 = seteuid(saved_euid);
#line 67
  if (tmp___1 < 0) {
#line 68
    tmp = __errno_location();
#line 68
    tmp___0 = strerror(*tmp);
#line 68
    debug("seteuid %d: %.100s", (int )saved_euid, tmp___0);
  }
#line 77
  return;
}
}
#line 83 "uidswap.c"
void permanently_set_uid(uid_t uid ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 86
  tmp___1 = setuid(uid);
#line 86
  if (tmp___1 < 0) {
#line 87
    tmp = __errno_location();
#line 87
    tmp___0 = strerror(*tmp);
#line 87
    debug("setuid %d: %.100s", (int )uid, tmp___0);
  }
#line 88
  return;
}
}
#line 1 "uuencode.o"
#line 9 "uuencode.c"
int uuencode(unsigned char *src , unsigned int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 13
  tmp = __b64_ntop((u_char const   *)src, srclength, target, targsize);
#line 13
  return (tmp);
}
}
#line 16 "uuencode.c"
int uudecode(char const   *src , unsigned char *target , size_t targsize ) 
{ int len ;
  char *encoded ;
  char *p ;

  {
#line 23
  encoded = xstrdup(src);
#line 25
  p = encoded;
#line 25
  while (1) {
#line 25
    if (! ((int )*p == 32)) {
#line 25
      if (! ((int )*p == 9)) {
#line 25
        break;
      }
    }
#line 25
    p ++;
  }
#line 27
  while (1) {
#line 27
    if ((int )*p != 0) {
#line 27
      if ((int )*p != 32) {
#line 27
        if (! ((int )*p != 9)) {
#line 27
          break;
        }
      } else {
#line 27
        break;
      }
    } else {
#line 27
      break;
    }
#line 27
    p ++;
  }
#line 30
  *p = (char )'\000';
#line 31
  len = __b64_pton((char const   *)encoded, target, targsize);
#line 32
  xfree((void *)encoded);
#line 33
  return (len);
}
}
#line 36 "uuencode.c"
void dump_base64(FILE *fp , unsigned char *data , int len ) 
{ unsigned char *buf___1 ;
  void *tmp ;
  int i ;
  int n___0 ;

  {
#line 39
  tmp = xmalloc((unsigned int )(2 * len));
#line 39
  buf___1 = (unsigned char *)tmp;
#line 41
  n___0 = uuencode(data, (unsigned int )len, (char *)buf___1, (unsigned int )(2 * len));
#line 42
  i = 0;
#line 42
  while (i < n___0) {
#line 43
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 44
    if (i % 70 == 69) {
#line 45
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 42
    i ++;
  }
#line 47
  if (i % 70 != 69) {
#line 48
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 49
  xfree((void *)buf___1);
#line 50
  return;
}
}
#line 1 "xmalloc.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 15 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;
  void *tmp ;

  {
#line 18
  tmp = malloc(size);
#line 18
  ptr = tmp;
#line 19
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 20
    fatal("xmalloc: out of memory (allocating %d bytes)", (int )size);
  }
#line 21
  return (ptr);
}
}
#line 24 "xmalloc.c"
void *xrealloc(void *ptr , size_t new_size ) 
{ void *new_ptr ;

  {
#line 29
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 30
    fatal("xrealloc: NULL pointer given as argument");
  }
#line 31
  new_ptr = realloc(ptr, new_size);
#line 32
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 33
    fatal("xrealloc: out of memory (new_size %d bytes)", (int )new_size);
  }
#line 34
  return (new_ptr);
}
}
#line 37 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 40
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 41
    fatal("xfree: NULL pointer given as argument");
  }
#line 42
  free(ptr);
#line 43
  return;
}
}
#line 45 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ int len ;
  size_t tmp ;
  char *cp ;
  void *tmp___0 ;

  {
#line 48
  tmp = strlen(str);
#line 48
  len = (int )(tmp + 1U);
#line 50
  tmp___0 = xmalloc((unsigned int )len);
#line 50
  cp = (char *)tmp___0;
#line 51
  strlcpy(cp, str, (unsigned int )len);
#line 52
  return (cp);
}
}
#line 1 "sshd.o"
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 903 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 451 "ssh.h"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 7 "auth-pam.h"
void finish_pam(void) ;
#line 101 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 107
void read_server_config(ServerOptions *options___0 , char const   *filename ) ;
#line 110
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 4 "auth.h"
void do_authentication(void) ;
#line 5
void do_authentication2(void) ;
#line 9 "myproposal.h"
static char const   *myproposal[10]  = 
#line 9 "myproposal.h"
  {      "diffie-hellman-group1-sha1",      "ssh-dss",      "blowfish-cbc,3des-cbc,arcfour,cast128-cbc",      "blowfish-cbc,3des-cbc,arcfour,cast128-cbc", 
        "hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      "hmac-sha1,hmac-md5,hmac-ripemd160@openssh.com",      "zlib,none",      "zlib,none", 
        "",      ""};
#line 57 "sshd.c"
ServerOptions options  ;
#line 60 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 69 "sshd.c"
int IPv4or6  =    0;
#line 78 "sshd.c"
int debug_flag  =    0;
#line 81 "sshd.c"
int inetd_flag  =    0;
#line 84 "sshd.c"
int log_stderr  =    0;
#line 87 "sshd.c"
char *av0  ;
#line 90 "sshd.c"
char **saved_argv  ;
#line 97 "sshd.c"
int listen_socks[16]  ;
#line 98 "sshd.c"
int num_listen_socks  =    0;
#line 104 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 105 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 115 "sshd.c"
struct __anonstruct_sensitive_data_76 sensitive_data  ;
#line 125 "sshd.c"
int key_used  =    0;
#line 128 "sshd.c"
int received_sighup  =    0;
#line 132 "sshd.c"
RSA *public_key  ;
#line 135 "sshd.c"
unsigned char session_id[16]  ;
#line 138 "sshd.c"
unsigned char *session_id2  =    (unsigned char *)((void *)0);
#line 139 "sshd.c"
int session_id2_len  =    0;
#line 142
void do_ssh1_kex(void) ;
#line 143
void do_ssh2_kex(void) ;
#line 148 "sshd.c"
void close_listen_socks(void) 
{ int i ;

  {
#line 152
  i = 0;
#line 152
  while (i < num_listen_socks) {
#line 153
    close(listen_socks[i]);
#line 152
    i ++;
  }
#line 154
  num_listen_socks = -1;
#line 155
  return;
}
}
#line 162 "sshd.c"
void sighup_handler(int sig ) 
{ 

  {
#line 165
  received_sighup = 1;
#line 166
  signal(1, & sighup_handler);
#line 167
  return;
}
}
#line 173 "sshd.c"
void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 176
  log("Received SIGHUP; restarting.");
#line 177
  close_listen_socks();
#line 178
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 179
  tmp = __errno_location();
#line 179
  tmp___0 = strerror(*tmp);
#line 179
  log("RESTART FAILED: av0=\'%s\', error: %s.", av0, tmp___0);
#line 180
  exit(1);
}
}
#line 188 "sshd.c"
void sigterm_handler(int sig ) 
{ 

  {
#line 191
  log("Received signal %d; terminating.", sig);
#line 192
  close_listen_socks();
#line 193
  unlink((char const   *)options.pid_file);
#line 194
  exit(255);
}
}
#line 201 "sshd.c"
void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int status ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
#line 204
  tmp = __errno_location();
#line 204
  save_errno = *tmp;
#line 207
  while (1) {
#line 207
    tmp___0 = waitpid(-1, & status, 1);
#line 207
    if (! (tmp___0 > 0)) {
#line 207
      break;
    }
  }
#line 210
  signal(17, & main_sigchld_handler);
#line 211
  tmp___1 = __errno_location();
#line 211
  *tmp___1 = save_errno;
#line 212
  return;
}
}
#line 217 "sshd.c"
void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 221
  packet_close();
#line 224
  tmp = get_remote_ipaddr();
#line 224
  fatal("Timeout before authentication for %s.", tmp);
#line 225
  return;
}
}
#line 235 "sshd.c"
void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 238
  tmp = __errno_location();
#line 238
  save_errno = *tmp;
#line 241
  if (key_used) {
#line 243
    log("Generating new %d bit RSA key.", options.server_key_bits);
#line 245
    if ((unsigned int )sensitive_data.private_key != (unsigned int )((void *)0)) {
#line 246
      RSA_free(sensitive_data.private_key);
    }
#line 247
    sensitive_data.private_key = RSA_new();
#line 249
    if ((unsigned int )public_key != (unsigned int )((void *)0)) {
#line 250
      RSA_free(public_key);
    }
#line 251
    public_key = RSA_new();
#line 253
    rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 255
    arc4random_stir();
#line 256
    key_used = 0;
#line 257
    log("RSA key generation complete.");
  }
#line 260
  signal(14, & key_regeneration_alarm);
#line 261
  alarm((unsigned int )options.key_regeneration_time);
#line 262
  tmp___0 = __errno_location();
#line 262
  *tmp___0 = save_errno;
#line 263
  return;
}
}
#line 265 "sshd.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 268
  t = s;
#line 269
  while (*t) {
#line 270
    if ((int )*t == 10) {
#line 271
      *t = (char )'\000';
#line 272
      return (s);
    } else {
#line 270
      if ((int )*t == 13) {
#line 271
        *t = (char )'\000';
#line 272
        return (s);
      }
    }
#line 274
    t ++;
  }
#line 276
  return (s);
}
}
#line 280 "sshd.c"
void sshd_exchange_identification(int sock_in , int sock_out ) 
{ int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;

  {
#line 290
  if (options.protocol & 1) {
#line 290
    if (options.protocol & 4) {
#line 292
      major = 1;
#line 293
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 294
    if (options.protocol & 4) {
#line 295
      major = 2;
#line 296
      minor = 0;
    } else {
#line 298
      major = 1;
#line 299
      minor = 5;
    }
  }
#line 301
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH-2.0");
#line 302
  server_version_string = xstrdup((char const   *)(buf___1));
#line 304
  if ((unsigned int )client_version_string == (unsigned int )((void *)0)) {
#line 306
    tmp___0 = strlen((char const   *)server_version_string);
#line 306
    tmp___1 = atomicio((ssize_t (*)())(& write), sock_out, (void *)server_version_string,
                       tmp___0);
#line 306
    tmp___2 = strlen((char const   *)server_version_string);
#line 306
    if ((size_t )tmp___1 != tmp___2) {
#line 308
      tmp = get_remote_ipaddr();
#line 308
      log("Could not write ident string to %s.", tmp);
#line 309
      fatal_cleanup();
    }
#line 313
    i = 0;
#line 313
    while ((unsigned int )i < sizeof(buf___1) - 1U) {
#line 314
      tmp___4 = read(sock_in, (void *)(& buf___1[i]), 1U);
#line 314
      if (tmp___4 != 1) {
#line 315
        tmp___3 = get_remote_ipaddr();
#line 315
        log("Did not receive ident string from %s.", tmp___3);
#line 316
        fatal_cleanup();
      }
#line 318
      if ((int )buf___1[i] == 13) {
#line 319
        buf___1[i] = (char )'\n';
#line 320
        buf___1[i + 1] = (char)0;
        goto __Cont;
      }
#line 323
      if ((int )buf___1[i] == 10) {
#line 325
        buf___1[i + 1] = (char)0;
#line 326
        break;
      }
      __Cont: /* CIL Label */ 
#line 313
      i ++;
    }
#line 329
    buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 330
    client_version_string = xstrdup((char const   *)(buf___1));
  }
#line 337
  tmp___7 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                   & remote_major, & remote_minor, remote_version);
#line 337
  if (tmp___7 != 3) {
#line 339
    s = (char *)"Protocol mismatch.\n";
#line 340
    tmp___5 = strlen((char const   *)s);
#line 340
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___5);
#line 341
    close(sock_in);
#line 342
    close(sock_out);
#line 343
    tmp___6 = get_remote_ipaddr();
#line 343
    log("Bad protocol version identification \'%.100s\' from %s", client_version_string,
        tmp___6);
#line 345
    fatal_cleanup();
  }
#line 347
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 350
  compat_datafellows((char const   *)(remote_version));
#line 352
  mismatch = 0;
#line 353
  switch (remote_major) {
  case 1: 
#line 355
  if (remote_minor == 99) {
#line 356
    if (options.protocol & 4) {
#line 357
      enable_compat20();
    } else {
#line 359
      mismatch = 1;
    }
#line 360
    break;
  }
#line 362
  if (! (options.protocol & 1)) {
#line 363
    mismatch = 1;
#line 364
    break;
  }
#line 366
  if (remote_minor < 3) {
#line 367
    packet_disconnect("Your ssh version is too old andis no longer supported.  Please install a newer version.");
  } else {
#line 369
    if (remote_minor == 3) {
#line 371
      enable_compat13();
    }
  }
#line 373
  break;
  case 2: 
#line 375
  if (options.protocol & 4) {
#line 376
    enable_compat20();
#line 377
    break;
  }
  default: 
#line 381
  mismatch = 1;
#line 382
  break;
  }
#line 384
  chop(server_version_string);
#line 385
  chop(client_version_string);
#line 386
  debug("Local version string %.200s", server_version_string);
#line 388
  if (mismatch) {
#line 389
    s = (char *)"Protocol major versions differ.\n";
#line 390
    tmp___8 = strlen((char const   *)s);
#line 390
    atomicio((ssize_t (*)())(& write), sock_out, (void *)s, tmp___8);
#line 391
    close(sock_in);
#line 392
    close(sock_out);
#line 393
    tmp___9 = get_remote_ipaddr();
#line 393
    log("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___9, server_version_string,
        client_version_string);
#line 396
    fatal_cleanup();
  }
#line 398
  if (compat20) {
#line 399
    packet_set_ssh2_format();
  }
#line 400
  return;
}
}
#line 403 "sshd.c"
void destroy_sensitive_data(void) 
{ 

  {
#line 407
  RSA_free(public_key);
#line 408
  RSA_free(sensitive_data.private_key);
#line 409
  RSA_free(sensitive_data.host_key);
#line 410
  if ((unsigned int )sensitive_data.dsa_host_key != (unsigned int )((void *)0)) {
#line 411
    key_free(sensitive_data.dsa_host_key);
  }
#line 412
  return;
}
}
#line 417 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  int i ;
  int fdsetsz ;
  int on ;
  pid_t pid ;
  socklen_t fromlen ;
  int silent ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct linger linger ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  int listen_sock ;
  int maxfd ;
  char *tmp ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Key k ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int fd ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int s1 ;
  int s2 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  __pid_t tmp___31 ;
  void *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  int tmp___36 ;
  register char __result ;
  int *tmp___37 ;
  char *tmp___38 ;
  int *tmp___39 ;
  int *tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;

  {
#line 422
  sock_in = 0;
#line 422
  sock_out = 0;
#line 422
  on = 1;
#line 425
  silent = 0;
#line 437
  saved_argv = av;
#line 438
  tmp___1 = __builtin_strchr(*(av + 0), '/');
#line 438
  if (tmp___1) {
#line 439
    tmp = strrchr((char const   *)*(av + 0), '/');
#line 439
    av0 = tmp + 1;
  } else {
#line 441
    av0 = *(av + 0);
  }
#line 444
  initialize_server_options(& options);
#line 447
  while (1) {
#line 447
    opt = getopt(ac, (char * const  *)av, "f:p:b:k:h:g:V:diqQ46");
#line 447
    if (! (opt != -1)) {
#line 447
      break;
    }
#line 448
    switch (opt) {
    case 52: 
#line 450
    IPv4or6 = 2;
#line 451
    break;
    case 54: 
#line 453
    IPv4or6 = 10;
#line 454
    break;
    case 102: 
#line 456
    config_file_name = optarg;
#line 457
    break;
    case 100: 
#line 459
    debug_flag = 1;
#line 460
    options.log_level = 5;
#line 461
    break;
    case 105: 
#line 463
    inetd_flag = 1;
#line 464
    break;
    case 81: 
#line 466
    silent = 1;
#line 467
    break;
    case 113: 
#line 469
    options.log_level = 0;
#line 470
    break;
    case 98: 
#line 472
    options.server_key_bits = atoi((char const   *)optarg);
#line 473
    break;
    case 112: 
#line 475
    options.ports_from_cmdline = 1U;
#line 476
    if (options.num_ports >= 256U) {
#line 477
      fatal("too many ports.\n");
    }
#line 478
    tmp___2 = options.num_ports;
#line 478
    (options.num_ports) ++;
#line 478
    tmp___3 = atoi((char const   *)optarg);
#line 478
    options.ports[tmp___2] = (unsigned short )tmp___3;
#line 479
    break;
    case 103: 
#line 481
    options.login_grace_time = atoi((char const   *)optarg);
#line 482
    break;
    case 107: 
#line 484
    options.key_regeneration_time = atoi((char const   *)optarg);
#line 485
    break;
    case 104: 
#line 487
    options.host_key_file = optarg;
#line 488
    break;
    case 86: 
#line 490
    client_version_string = optarg;
#line 492
    inetd_flag = 1;
#line 493
    break;
    case 63: 
    default: 
#line 496
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd version %s\n",
            "OpenSSH-2.0");
#line 497
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options]\n",
            av0);
#line 498
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Options:\n");
#line 499
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -f file    Configuration file (default %s)\n",
            "/usr/local/etc/sshd_config");
#line 500
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -d         Debugging mode\n");
#line 501
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -i         Started from inetd\n");
#line 502
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -q         Quiet (no logging)\n");
#line 503
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -p port    Listen on the specified port (default: 22)\n");
#line 504
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -k seconds Regenerate server key every this many seconds (default: 3600)\n");
#line 505
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -g seconds Grace period for authentication (default: 300)\n");
#line 506
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -b bits    Size of server RSA key (default: 768 bits)\n");
#line 507
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -h file    File from which to read host key (default: %s)\n",
            "/usr/local/etc/ssh_host_key");
#line 509
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -4         Use IPv4 only\n");
#line 510
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  -6         Use IPv6 only\n");
#line 511
    exit(1);
    }
  }
#line 519
  if (! silent) {
#line 519
    if (! inetd_flag) {
#line 519
      tmp___4 = 1;
    } else {
#line 519
      tmp___4 = 0;
    }
  } else {
#line 519
    tmp___4 = 0;
  }
#line 519
  if ((int )options.log_facility == -1) {
#line 519
    tmp___5 = 2;
  } else {
#line 519
    tmp___5 = (int )options.log_facility;
  }
#line 519
  if ((int )options.log_level == -1) {
#line 519
    tmp___6 = 3;
  } else {
#line 519
    tmp___6 = (int )options.log_level;
  }
#line 519
  log_init(av0, (enum __anonenum_LogLevel_73 )tmp___6, (enum __anonenum_SyslogFacility_72 )tmp___5,
           tmp___4);
#line 525
  read_server_config(& options, (char const   *)config_file_name);
#line 528
  fill_default_server_options(& options);
#line 531
  if (optind < ac) {
#line 532
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + optind));
#line 533
    exit(1);
  }
#line 536
  debug("sshd version %.100s", "OpenSSH-2.0");
#line 538
  sensitive_data.dsa_host_key = (Key *)((void *)0);
#line 539
  sensitive_data.host_key = (RSA *)((void *)0);
#line 542
  if (options.protocol & 1) {
#line 542
    tmp___7 = rsa_alive();
#line 542
    if (tmp___7 == 0) {
#line 544
      log("no RSA support in libssl and libcrypto.  See ssl(8)");
#line 545
      log("Disabling protocol version 1");
#line 546
      options.protocol &= -2;
    }
  }
#line 549
  if (options.protocol & 1) {
#line 551
    sensitive_data.host_key = RSA_new();
#line 552
    k.type = 0;
#line 553
    k.rsa = sensitive_data.host_key;
#line 554
    tmp___8 = __errno_location();
#line 554
    *tmp___8 = 0;
#line 555
    tmp___11 = load_private_key((char const   *)options.host_key_file, "", & k, (char **)((void *)0));
#line 555
    if (! tmp___11) {
#line 556
      tmp___9 = __errno_location();
#line 556
      tmp___10 = strerror(*tmp___9);
#line 556
      error("Could not load host key: %.200s: %.100s", options.host_key_file, tmp___10);
#line 558
      log("Disabling protocol version 1");
#line 559
      options.protocol &= -2;
    }
#line 561
    k.rsa = (RSA *)((void *)0);
  }
#line 563
  if (options.protocol & 4) {
#line 564
    sensitive_data.dsa_host_key = key_new(1);
#line 565
    tmp___12 = load_private_key((char const   *)options.host_dsa_key_file, "", sensitive_data.dsa_host_key,
                                (char **)((void *)0));
#line 565
    if (! tmp___12) {
#line 567
      error("Could not load DSA host key: %.200s", options.host_dsa_key_file);
#line 568
      log("Disabling protocol version 2");
#line 569
      options.protocol &= -5;
    }
  }
#line 572
  if (! options.protocol & 5) {
#line 573
    if (silent == 0) {
#line 574
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshd: no hostkeys available -- exiting.\n");
    }
#line 575
    log("sshd: no hostkeys available -- exiting.\n");
#line 576
    exit(1);
  }
#line 580
  if (options.protocol & 1) {
#line 581
    if (options.server_key_bits < 512) {
#line 583
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 584
      exit(1);
    } else {
#line 581
      if (options.server_key_bits > 32768) {
#line 583
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 584
        exit(1);
      }
    }
#line 591
    tmp___14 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 591
    if (options.server_key_bits > tmp___14 - 128) {
#line 591
      tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 591
      if (options.server_key_bits < tmp___15 + 128) {
#line 595
        tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 595
        options.server_key_bits = tmp___13 + 128;
#line 597
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 603
  if (debug_flag) {
#line 603
    if (! inetd_flag) {
#line 604
      log_stderr = 1;
    }
  }
#line 605
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 612
  if (! debug_flag) {
#line 612
    if (! inetd_flag) {
#line 616
      tmp___18 = daemon(0, 0);
#line 616
      if (tmp___18 < 0) {
#line 617
        tmp___16 = __errno_location();
#line 617
        tmp___17 = strerror(*tmp___16);
#line 617
        fatal("daemon() failed: %.200s", tmp___17);
      }
#line 621
      fd = open("/dev/tty", 258);
#line 622
      if (fd >= 0) {
#line 623
        ioctl(fd, 21538UL, (void *)0);
#line 624
        close(fd);
      }
    }
  }
#line 629
  log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 632
  rsa_set_verbose(0);
#line 635
  arc4random_stir();
#line 639
  chdir("/");
#line 642
  if (inetd_flag) {
#line 644
    s1 = dup(0);
#line 645
    s2 = dup(s1);
#line 646
    sock_in = dup(0);
#line 647
    sock_out = dup(1);
#line 653
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
#line 655
    if (options.protocol & 1) {
#line 656
      public_key = RSA_new();
#line 657
      sensitive_data.private_key = RSA_new();
#line 658
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 659
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 661
      arc4random_stir();
#line 662
      log("RSA key generation complete.");
    }
  } else {
#line 665
    ai = options.listen_addrs;
#line 665
    while (ai) {
#line 666
      if (ai->ai_family != 2) {
#line 666
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 668
      if (num_listen_socks >= 16) {
#line 669
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
      }
#line 671
      tmp___19 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr,
                             ai->ai_addrlen, (char * __restrict  )(ntop), sizeof(ntop),
                             (char * __restrict  )(strport), sizeof(strport), 3U);
#line 671
      if (tmp___19 != 0) {
#line 674
        error("getnameinfo failed");
        goto __Cont;
      }
#line 678
      listen_sock = socket(ai->ai_family, 1, 0);
#line 679
      if (listen_sock < 0) {
#line 681
        tmp___20 = __errno_location();
#line 681
        tmp___21 = strerror(*tmp___20);
#line 681
        verbose("socket: %.100s", tmp___21);
        goto __Cont;
      }
#line 684
      tmp___24 = fcntl(listen_sock, 4, 2048);
#line 684
      if (tmp___24 < 0) {
#line 685
        tmp___22 = __errno_location();
#line 685
        tmp___23 = strerror(*tmp___22);
#line 685
        error("listen_sock O_NONBLOCK: %s", tmp___23);
#line 686
        close(listen_sock);
        goto __Cont;
      }
#line 695
      setsockopt(listen_sock, 1, 2, (void const   *)((void *)(& on)), sizeof(on));
#line 697
      linger.l_onoff = 1;
#line 698
      linger.l_linger = 5;
#line 699
      setsockopt(listen_sock, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 702
      debug("Bind to port %s on %s.", strport, ntop);
#line 705
      tmp___27 = bind(listen_sock, (struct sockaddr  const  *)ai->ai_addr, ai->ai_addrlen);
#line 705
      if (tmp___27 < 0) {
#line 705
        if (! ai->ai_next) {
#line 707
          tmp___25 = __errno_location();
#line 707
          tmp___26 = strerror(*tmp___25);
#line 707
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___26);
#line 709
          close(listen_sock);
          goto __Cont;
        }
      }
#line 712
      listen_socks[num_listen_socks] = listen_sock;
#line 713
      num_listen_socks ++;
#line 716
      log("Server listening on %s port %s.", ntop, strport);
#line 717
      tmp___30 = listen(listen_sock, 5);
#line 717
      if (tmp___30 < 0) {
#line 718
        tmp___28 = __errno_location();
#line 718
        tmp___29 = strerror(*tmp___28);
#line 718
        fatal("listen: %.100s", tmp___29);
      }
      __Cont: /* CIL Label */ 
#line 665
      ai = ai->ai_next;
    }
#line 721
    freeaddrinfo(options.listen_addrs);
#line 723
    if (! num_listen_socks) {
#line 724
      fatal("Cannot bind any address.");
    }
#line 726
    if (! debug_flag) {
#line 734
      f = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"w");
#line 735
      if (f) {
#line 736
        tmp___31 = getpid();
#line 736
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u\n", (unsigned int )tmp___31);
#line 737
        fclose(f);
      }
    }
#line 740
    if (options.protocol & 1) {
#line 741
      public_key = RSA_new();
#line 742
      sensitive_data.private_key = RSA_new();
#line 744
      log("Generating %d bit RSA key.", options.server_key_bits);
#line 745
      rsa_generate_key(sensitive_data.private_key, public_key, (unsigned int )options.server_key_bits);
#line 747
      arc4random_stir();
#line 748
      log("RSA key generation complete.");
#line 751
      signal(14, & key_regeneration_alarm);
#line 752
      alarm((unsigned int )options.key_regeneration_time);
    }
#line 756
    signal(1, & sighup_handler);
#line 757
    signal(15, & sigterm_handler);
#line 758
    signal(3, & sigterm_handler);
#line 761
    signal(17, & main_sigchld_handler);
#line 764
    maxfd = 0;
#line 765
    i = 0;
#line 765
    while (i < num_listen_socks) {
#line 766
      if (listen_socks[i] > maxfd) {
#line 767
        maxfd = listen_socks[i];
      }
#line 765
      i ++;
    }
#line 768
    fdsetsz = (int )((((unsigned int )maxfd + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 769
    tmp___32 = xmalloc((unsigned int )fdsetsz);
#line 769
    fdset = (fd_set *)tmp___32;
#line 775
    while (1) {
#line 776
      if (received_sighup) {
#line 777
        sighup_restart();
      }
#line 779
      memset((void *)fdset, 0, (unsigned int )fdsetsz);
#line 780
      i = 0;
#line 780
      while (i < num_listen_socks) {
#line 781
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 780
        i ++;
      }
#line 782
      tmp___36 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 782
      if (tmp___36 < 0) {
#line 783
        tmp___35 = __errno_location();
#line 783
        if (*tmp___35 != 4) {
#line 784
          tmp___33 = __errno_location();
#line 784
          tmp___34 = strerror(*tmp___33);
#line 784
          error("select: %.100s", tmp___34);
        }
        goto __Cont___0;
      }
#line 787
      i = 0;
#line 787
      while (i < num_listen_socks) {
#line 788
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->__fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 788
        if (! __result) {
          goto __Cont___1;
        }
#line 790
        fromlen = sizeof(from);
#line 791
        newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                         (socklen_t * __restrict  )(& fromlen));
#line 793
        if (newsock < 0) {
#line 794
          tmp___39 = __errno_location();
#line 794
          if (*tmp___39 != 4) {
#line 794
            tmp___40 = __errno_location();
#line 794
            if (*tmp___40 != 11) {
#line 795
              tmp___37 = __errno_location();
#line 795
              tmp___38 = strerror(*tmp___37);
#line 795
              error("accept: %.100s", tmp___38);
            }
          }
          goto __Cont___1;
        }
#line 798
        tmp___43 = fcntl(newsock, 4, 0);
#line 798
        if (tmp___43 < 0) {
#line 799
          tmp___41 = __errno_location();
#line 799
          tmp___42 = strerror(*tmp___41);
#line 799
          error("newsock del O_NONBLOCK: %s", tmp___42);
          goto __Cont___1;
        }
#line 806
        if (debug_flag) {
#line 812
          debug("Server will not fork when running in debugging mode.");
#line 813
          close_listen_socks();
#line 814
          sock_in = newsock;
#line 815
          sock_out = newsock;
#line 816
          pid = getpid();
#line 817
          break;
        } else {
#line 824
          pid = fork();
#line 824
          if (pid == 0) {
#line 830
            close_listen_socks();
#line 831
            sock_in = newsock;
#line 832
            sock_out = newsock;
#line 833
            log_init(av0, options.log_level, options.log_facility, log_stderr);
#line 834
            break;
          }
        }
#line 839
        if (pid < 0) {
#line 840
          tmp___44 = __errno_location();
#line 840
          tmp___45 = strerror(*tmp___44);
#line 840
          error("fork: %.100s", tmp___45);
        } else {
#line 842
          debug("Forked child %d.", pid);
        }
#line 845
        key_used = 1;
#line 847
        arc4random_stir();
#line 850
        close(newsock);
        __Cont___1: /* CIL Label */ 
#line 787
        i ++;
      }
#line 853
      if (num_listen_socks < 0) {
#line 854
        break;
      }
      __Cont___0: /* CIL Label */ ;
    }
  }
#line 865
  alarm(0U);
#line 866
  signal(14, (void (*)(int  ))0);
#line 867
  signal(1, (void (*)(int  ))0);
#line 868
  signal(15, (void (*)(int  ))0);
#line 869
  signal(3, (void (*)(int  ))0);
#line 870
  signal(17, (void (*)(int  ))0);
#line 878
  linger.l_onoff = 1;
#line 879
  linger.l_linger = 5;
#line 880
  setsockopt(sock_in, 1, 13, (void const   *)((void *)(& linger)), sizeof(linger));
#line 886
  packet_set_connection(sock_in, sock_out);
#line 888
  remote_port = get_remote_port();
#line 889
  remote_ip = get_remote_ipaddr();
#line 909
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
#line 919
  signal(14, & grace_alarm_handler);
#line 920
  if (! debug_flag) {
#line 921
    alarm((unsigned int )options.login_grace_time);
  }
#line 923
  sshd_exchange_identification(sock_in, sock_out);
#line 931
  if (remote_port >= 1024) {
#line 933
    options.rhosts_authentication = 0;
#line 934
    options.rhosts_rsa_authentication = 0;
  } else {
#line 931
    if (remote_port < 512) {
#line 933
      options.rhosts_authentication = 0;
#line 934
      options.rhosts_rsa_authentication = 0;
    }
  }
#line 944
  packet_set_nonblocking();
#line 948
  if (compat20) {
#line 949
    do_ssh2_kex();
#line 950
    do_authentication2();
  } else {
#line 952
    do_ssh1_kex();
#line 953
    do_authentication();
  }
#line 963
  verbose("Closing connection to %.100s", remote_ip);
#line 966
  finish_pam();
#line 969
  packet_close();
#line 970
  exit(0);
}
}
#line 976 "sshd.c"
void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int plen ;
  int slen ;
  BIGNUM *session_key_int ;
  unsigned char session_key[32] ;
  unsigned char cookie[8] ;
  unsigned int cipher_type___0 ;
  unsigned int auth_mask ;
  unsigned int protocol_flags ;
  u_int32_t rand___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int _p ;
  int _e ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;

  {
#line 985
  rand___0 = (u_int32_t )0;
#line 996
  i = 0;
#line 996
  while (i < 8) {
#line 997
    if (i % 4 == 0) {
#line 998
      rand___0 = arc4random();
    }
#line 999
    cookie[i] = (unsigned char )(rand___0 & 255U);
#line 1000
    rand___0 >>= 8;
#line 996
    i ++;
  }
#line 1008
  packet_start(2);
#line 1009
  i = 0;
#line 1009
  while (i < 8) {
#line 1010
    packet_put_char((int )cookie[i]);
#line 1009
    i ++;
  }
#line 1013
  tmp = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1013
  packet_put_int((unsigned int )tmp);
#line 1014
  packet_put_bignum(public_key->e);
#line 1015
  packet_put_bignum(public_key->n);
#line 1018
  tmp___0 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1018
  packet_put_int((unsigned int )tmp___0);
#line 1019
  packet_put_bignum((sensitive_data.host_key)->e);
#line 1020
  packet_put_bignum((sensitive_data.host_key)->n);
#line 1023
  packet_put_int(2U);
#line 1026
  tmp___1 = cipher_mask1();
#line 1026
  packet_put_int(tmp___1);
#line 1029
  auth_mask = 0U;
#line 1030
  if (options.rhosts_authentication) {
#line 1031
    auth_mask |= (unsigned int )(1 << 1);
  }
#line 1032
  if (options.rhosts_rsa_authentication) {
#line 1033
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1034
  if (options.rsa_authentication) {
#line 1035
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1050
  if (options.password_authentication) {
#line 1051
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 1052
  packet_put_int(auth_mask);
#line 1055
  packet_send();
#line 1056
  packet_write_wait();
#line 1058
  tmp___2 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1058
  tmp___3 = BN_num_bits((BIGNUM const   *)public_key->n);
#line 1058
  debug("Sent %d bit public key and %d bit host key.", tmp___3, tmp___2);
#line 1062
  packet_read_expect(& plen, 3);
#line 1065
  cipher_type___0 = packet_get_char();
#line 1067
  tmp___4 = cipher_mask();
#line 1067
  if (! (tmp___4 & (unsigned int )(1 << cipher_type___0))) {
#line 1068
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 1072
  i = 0;
#line 1072
  while (i < 8) {
#line 1073
    tmp___5 = packet_get_char();
#line 1073
    if ((unsigned int )cookie[i] != tmp___5) {
#line 1074
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 1072
    i ++;
  }
#line 1076
  tmp___6 = cipher_name((int )cipher_type___0);
#line 1076
  debug("Encryption type: %.200s", tmp___6);
#line 1079
  session_key_int = BN_new();
#line 1080
  packet_get_bignum(session_key_int, & slen);
#line 1082
  protocol_flags = packet_get_int();
#line 1083
  packet_set_protocol_flags(protocol_flags);
#line 1085
  while (1) {
#line 1085
    _p = plen;
#line 1085
    _e = (9 + slen) + 4;
#line 1085
    if (_p != _e) {
#line 1085
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "sshd.c", 1085);
#line 1085
      packet_disconnect("Packet integrity error. (%d)", 3);
    }
#line 1085
    break;
  }
#line 1091
  tmp___17 = BN_cmp((BIGNUM const   *)(sensitive_data.private_key)->n, (BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1091
  if (tmp___17 > 0) {
#line 1093
    tmp___10 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1093
    tmp___11 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1093
    if (tmp___10 < tmp___11 + 128) {
#line 1095
      tmp___7 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1095
      tmp___8 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1095
      tmp___9 = get_remote_ipaddr();
#line 1095
      fatal("do_connection: %s: private_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___9, tmp___8, tmp___7, 128);
    }
#line 1101
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
#line 1103
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
  } else {
#line 1107
    tmp___15 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1107
    tmp___16 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1107
    if (tmp___15 < tmp___16 + 128) {
#line 1109
      tmp___12 = BN_num_bits((BIGNUM const   *)(sensitive_data.private_key)->n);
#line 1109
      tmp___13 = BN_num_bits((BIGNUM const   *)(sensitive_data.host_key)->n);
#line 1109
      tmp___14 = get_remote_ipaddr();
#line 1109
      fatal("do_connection: %s: host_key %d < private_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___14, tmp___13, tmp___12, 128);
    }
#line 1115
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.host_key);
#line 1117
    rsa_private_decrypt(session_key_int, session_key_int, sensitive_data.private_key);
  }
#line 1121
  compute_session_id((unsigned char *)(session_id), (unsigned char *)(cookie), (sensitive_data.host_key)->n,
                     (sensitive_data.private_key)->n);
#line 1126
  destroy_sensitive_data();
#line 1133
  BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 1134
  tmp___18 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 1134
  len = (tmp___18 + 7) / 8;
#line 1135
  if (len < 0) {
#line 1136
    tmp___19 = get_remote_ipaddr();
#line 1136
    fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
          tmp___19, len, sizeof(session_key));
  } else {
#line 1135
    if ((unsigned int )len > sizeof(session_key)) {
#line 1136
      tmp___19 = get_remote_ipaddr();
#line 1136
      fatal("do_connection: bad len from %s: session_key_int %d > sizeof(session_key) %d",
            tmp___19, len, sizeof(session_key));
    }
  }
#line 1139
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1140
  BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 1143
  BN_clear_free(session_key_int);
#line 1146
  i = 0;
#line 1146
  while (i < 16) {
#line 1147
    session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 1146
    i ++;
  }
#line 1150
  packet_set_encryption_key((unsigned char const   *)(session_key), 32U, (int )cipher_type___0);
#line 1153
  memset((void *)(session_key), 0, sizeof(session_key));
#line 1155
  debug("Received session key; encryption turned on.");
#line 1158
  packet_start(14);
#line 1159
  packet_send();
#line 1160
  packet_write_wait();
#line 1161
  return;
}
}
#line 1166 "sshd.c"
void do_ssh2_kex(void) 
{ Buffer *server_kexinit ;
  Buffer *client_kexinit ;
  int payload_len ;
  int dlen ;
  int slen ;
  unsigned int klen ;
  unsigned int kout ;
  char *ptr ;
  unsigned char *signature ;
  unsigned char *server_host_key_blob ;
  unsigned int sbloblen ;
  DH *dh ;
  BIGNUM *dh_client_pub ;
  BIGNUM *shared_secret ;
  int i ;
  unsigned char *kbuf ;
  unsigned char *hash ;
  Kex *kex___0 ;
  char *cprop[10] ;
  char *sprop[10] ;
  unsigned int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;

  {
#line 1175
  signature = (unsigned char *)((void *)0);
#line 1176
  server_host_key_blob = (unsigned char *)((void *)0);
#line 1179
  dh_client_pub = (BIGNUM *)0;
#line 1180
  shared_secret = (BIGNUM *)0;
#line 1190
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 1191
    myproposal[3] = (char const   *)options.ciphers;
#line 1191
    myproposal[2] = myproposal[3];
  }
#line 1195
  debug("Sending KEX init.");
#line 1197
  i = 0;
#line 1197
  while (i < 10) {
#line 1198
    sprop[i] = xstrdup(myproposal[i]);
#line 1197
    i ++;
  }
#line 1199
  server_kexinit = kex_init((char **)(sprop));
#line 1200
  packet_start(20);
#line 1201
  tmp = buffer_len(server_kexinit);
#line 1201
  tmp___0 = buffer_ptr(server_kexinit);
#line 1201
  packet_put_raw((char const   *)tmp___0, tmp);
#line 1202
  packet_send();
#line 1203
  packet_write_wait();
#line 1205
  debug("done");
#line 1207
  packet_read_expect(& payload_len, 20);
#line 1213
  tmp___1 = xmalloc(sizeof(*client_kexinit));
#line 1213
  client_kexinit = (Buffer *)tmp___1;
#line 1214
  buffer_init(client_kexinit);
#line 1215
  ptr = packet_get_raw(& payload_len);
#line 1216
  buffer_append(client_kexinit, (char const   *)ptr, (unsigned int )payload_len);
#line 1219
  i = 0;
#line 1219
  while (i < 16) {
#line 1220
    packet_get_char();
#line 1219
    i ++;
  }
#line 1222
  i = 0;
#line 1222
  while (i < 10) {
#line 1223
    cprop[i] = packet_get_string((unsigned int *)((void *)0));
#line 1224
    debug("got kexinit string: %s", cprop[i]);
#line 1222
    i ++;
  }
#line 1227
  tmp___2 = packet_get_char();
#line 1227
  i = (int )tmp___2;
#line 1228
  debug("first kex follow == %d", i);
#line 1229
  tmp___3 = packet_get_int();
#line 1229
  i = (int )tmp___3;
#line 1230
  debug("reserved == %d", i);
#line 1232
  debug("done read kexinit");
#line 1233
  kex___0 = kex_choose_conf((char **)(cprop), (char **)(sprop), 1);
#line 1237
  debug("Wait SSH2_MSG_KEXDH_INIT.");
#line 1238
  packet_read_expect(& payload_len, 30);
#line 1241
  dh_client_pub = BN_new();
#line 1242
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 1243
    fatal("dh_client_pub == NULL");
  }
#line 1244
  packet_get_bignum2(dh_client_pub, & dlen);
#line 1254
  dh = dh_new_group1();
#line 1265
  tmp___4 = dh_pub_is_valid(dh, dh_client_pub);
#line 1265
  if (! tmp___4) {
#line 1266
    packet_disconnect("bad client public DH value");
  }
#line 1268
  tmp___5 = DH_size((DH const   *)dh);
#line 1268
  klen = (unsigned int )tmp___5;
#line 1269
  tmp___6 = xmalloc(klen);
#line 1269
  kbuf = (unsigned char *)tmp___6;
#line 1270
  tmp___7 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 1270
  kout = (unsigned int )tmp___7;
#line 1279
  shared_secret = BN_new();
#line 1281
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
#line 1282
  memset((void *)kbuf, 0, klen);
#line 1283
  xfree((void *)kbuf);
#line 1286
  dsa_make_key_blob(sensitive_data.dsa_host_key, & server_host_key_blob, & sbloblen);
#line 1289
  tmp___8 = buffer_len(server_kexinit);
#line 1289
  tmp___9 = buffer_ptr(server_kexinit);
#line 1289
  tmp___10 = buffer_len(client_kexinit);
#line 1289
  tmp___11 = buffer_ptr(client_kexinit);
#line 1289
  hash = kex_hash(client_version_string, server_version_string, tmp___11, (int )tmp___10,
                  tmp___9, (int )tmp___8, (char *)server_host_key_blob, (int )sbloblen,
                  dh_client_pub, dh->pub_key, shared_secret);
#line 1299
  buffer_free(client_kexinit);
#line 1300
  buffer_free(server_kexinit);
#line 1301
  xfree((void *)client_kexinit);
#line 1302
  xfree((void *)server_kexinit);
#line 1311
  session_id2_len = 20;
#line 1312
  tmp___12 = xmalloc((unsigned int )session_id2_len);
#line 1312
  session_id2 = (unsigned char *)tmp___12;
#line 1313
  memcpy((void * __restrict  )session_id2, (void const   * __restrict  )hash, (unsigned int )session_id2_len);
#line 1317
  dsa_sign(sensitive_data.dsa_host_key, & signature, & slen, hash, 20);
#line 1319
  destroy_sensitive_data();
#line 1322
  packet_start(31);
#line 1323
  packet_put_string((char const   *)((char *)server_host_key_blob), sbloblen);
#line 1324
  packet_put_bignum2(dh->pub_key);
#line 1325
  packet_put_string((char const   *)((char *)signature), (unsigned int )slen);
#line 1326
  packet_send();
#line 1327
  xfree((void *)signature);
#line 1328
  xfree((void *)server_host_key_blob);
#line 1329
  packet_write_wait();
#line 1331
  kex_derive_keys(kex___0, hash, shared_secret);
#line 1332
  packet_set_kex(kex___0);
#line 1335
  DH_free(dh);
#line 1337
  debug("send SSH2_MSG_NEWKEYS.");
#line 1338
  packet_start(21);
#line 1339
  packet_send();
#line 1340
  packet_write_wait();
#line 1341
  debug("done: send SSH2_MSG_NEWKEYS.");
#line 1343
  debug("Wait SSH2_MSG_NEWKEYS.");
#line 1344
  packet_read_expect(& payload_len, 21);
#line 1345
  debug("GOT SSH2_MSG_NEWKEYS.");
#line 1354
  debug("done: KEX2.");
#line 1355
  return;
}
}
#line 1 "auth.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 382
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 10 "auth.h"
int allowed_user(struct passwd *pw ) ;
#line 43 "auth.c"
int allowed_user(struct passwd *pw ) 
{ struct stat st ;
  struct group *grp ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 54
  if (! pw) {
#line 55
    return (0);
  }
#line 58
  tmp = stat((char const   * __restrict  )pw->pw_shell, (struct stat * __restrict  )(& st));
#line 58
  if (tmp != 0) {
#line 59
    return (0);
  }
#line 60
  if (st.st_mode & 32768U) {
#line 60
    if (! (st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3)))) {
#line 61
      return (0);
    }
  } else {
#line 61
    return (0);
  }
#line 64
  if (options.num_deny_users > 0U) {
#line 65
    if (! pw->pw_name) {
#line 66
      return (0);
    }
#line 67
    i = 0;
#line 67
    while ((unsigned int )i < options.num_deny_users) {
#line 68
      tmp___0 = match_pattern((char const   *)pw->pw_name, (char const   *)options.deny_users[i]);
#line 68
      if (tmp___0) {
#line 69
        return (0);
      }
#line 67
      i ++;
    }
  }
#line 72
  if (options.num_allow_users > 0U) {
#line 73
    if (! pw->pw_name) {
#line 74
      return (0);
    }
#line 75
    i = 0;
#line 75
    while ((unsigned int )i < options.num_allow_users) {
#line 76
      tmp___1 = match_pattern((char const   *)pw->pw_name, (char const   *)options.allow_users[i]);
#line 76
      if (tmp___1) {
#line 77
        break;
      }
#line 75
      i ++;
    }
#line 79
    if ((unsigned int )i >= options.num_allow_users) {
#line 80
      return (0);
    }
  }
#line 83
  if (options.num_deny_groups > 0U) {
    goto _L;
  } else {
#line 83
    if (options.num_allow_groups > 0U) {
      _L: /* CIL Label */ 
#line 84
      grp = getgrgid(pw->pw_gid);
#line 85
      if (! grp) {
#line 86
        return (0);
      }
#line 89
      if (options.num_deny_groups > 0U) {
#line 90
        if (! grp->gr_name) {
#line 91
          return (0);
        }
#line 92
        i = 0;
#line 92
        while ((unsigned int )i < options.num_deny_groups) {
#line 93
          tmp___2 = match_pattern((char const   *)grp->gr_name, (char const   *)options.deny_groups[i]);
#line 93
          if (tmp___2) {
#line 94
            return (0);
          }
#line 92
          i ++;
        }
      }
#line 100
      if (options.num_allow_groups > 0U) {
#line 101
        if (! grp->gr_name) {
#line 102
          return (0);
        }
#line 103
        i = 0;
#line 103
        while ((unsigned int )i < options.num_allow_groups) {
#line 104
          tmp___3 = match_pattern((char const   *)grp->gr_name, (char const   *)options.allow_groups[i]);
#line 104
          if (tmp___3) {
#line 105
            break;
          }
#line 103
          i ++;
        }
#line 108
        if ((unsigned int )i >= options.num_allow_groups) {
#line 109
          return (0);
        }
      }
    }
  }
#line 119
  return (1);
}
}
#line 1 "auth1.o"
#line 355 "ssh.h"
int auth_rhosts(struct passwd *pw , char const   *client_user ) ;
#line 361
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) ;
#line 375
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) ;
#line 6 "auth-pam.h"
void start_pam(struct passwd *pw ) ;
#line 8
int auth_pam_password(struct passwd *pw , char const   *password ) ;
#line 10
int do_pam_account(char *username , char *remote_user ) ;
#line 5 "session.h"
void do_authenticated(struct passwd *pw ) ;
#line 23 "auth1.c"
char *forced_command ;
#line 31 "auth1.c"
static char buf[1024]  ;
#line 28 "auth1.c"
char *get_authname(int type ) 
{ 

  {
#line 32
  switch (type) {
  case 9: 
#line 34
  return ((char *)"password");
  case 6: 
#line 36
  return ((char *)"rsa");
  case 35: 
#line 38
  return ((char *)"rhosts-rsa");
  case 5: 
#line 40
  return ((char *)"rhosts");
  }
#line 50
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 51
  return (buf);
}
}
#line 58 "auth1.c"
void do_fake_authloop1(char *user ) 
{ int attempt___0 ;
  int tmp ;
  char const   *tmp___0 ;
  int plen ;

  {
#line 61
  attempt___0 = 0;
#line 63
  tmp = get_remote_port();
#line 63
  tmp___0 = get_remote_ipaddr();
#line 63
  log("Faking authloop for illegal user %.200s from %.200s port %d", user, tmp___0,
      tmp);
#line 75
  packet_start(15);
#line 76
  packet_send();
#line 77
  packet_write_wait();
#line 83
  attempt___0 = 1;
#line 83
  while (1) {
#line 87
    packet_read(& plen);
#line 113
    if (attempt___0 > 6) {
#line 114
      packet_disconnect("Too many authentication failures for %.100s", user);
    }
#line 120
    packet_start(15);
#line 121
    packet_send();
#line 122
    packet_write_wait();
#line 83
    attempt___0 ++;
  }
#line 125
  abort();
}
}
#line 132 "auth1.c"
void do_authloop(struct passwd *pw ) 
{ int attempt___0 ;
  unsigned int bits ;
  RSA *client_host_key ;
  BIGNUM *n___0 ;
  char *client_user ;
  char *password ;
  char user[1024] ;
  unsigned int dlen ;
  int plen ;
  int nlen ;
  int elen ;
  unsigned int ulen ;
  int type ;
  void (*authlog___0)(char const   *fmt  , ...) ;
  int authenticated ;
  int _p ;
  int _e ;
  int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 135
  attempt___0 = 0;
#line 139
  client_user = (char *)((void *)0);
#line 139
  password = (char *)((void *)0);
#line 144
  type = 0;
#line 145
  authlog___0 = (void (*)(char const   *fmt  , ...))(& verbose);
#line 148
  packet_start(15);
#line 149
  packet_send();
#line 150
  packet_write_wait();
#line 152
  attempt___0 = 1;
#line 152
  while (1) {
#line 153
    authenticated = 0;
#line 154
    strlcpy(user, "", sizeof(user));
#line 157
    type = packet_read(& plen);
#line 160
    switch (type) {
    case 5: 
#line 220
    if (! options.rhosts_authentication) {
#line 221
      verbose("Rhosts authentication disabled.");
#line 222
      break;
    }
#line 230
    client_user = packet_get_string(& ulen);
#line 231
    while (1) {
#line 231
      _p = plen;
#line 231
      _e = (int )(4U + ulen);
#line 231
      if (_p != _e) {
#line 231
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 231);
#line 231
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 231
      break;
    }
#line 235
    authenticated = auth_rhosts(pw, (char const   *)client_user);
#line 237
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 238
    break;
    case 35: 
#line 241
    if (! options.rhosts_rsa_authentication) {
#line 242
      verbose("Rhosts with RSA authentication disabled.");
#line 243
      break;
    }
#line 250
    client_user = packet_get_string(& ulen);
#line 253
    client_host_key = RSA_new();
#line 254
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 255
      fatal("RSA_new failed");
    }
#line 256
    client_host_key->e = BN_new();
#line 257
    client_host_key->n = BN_new();
#line 258
    if ((unsigned int )client_host_key->e == (unsigned int )((void *)0)) {
#line 259
      fatal("BN_new failed");
    } else {
#line 258
      if ((unsigned int )client_host_key->n == (unsigned int )((void *)0)) {
#line 259
        fatal("BN_new failed");
      }
    }
#line 260
    bits = packet_get_int();
#line 261
    packet_get_bignum(client_host_key->e, & elen);
#line 262
    packet_get_bignum(client_host_key->n, & nlen);
#line 264
    tmp___0 = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 264
    if (bits != (unsigned int )tmp___0) {
#line 265
      tmp = BN_num_bits((BIGNUM const   *)client_host_key->n);
#line 265
      log("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
          tmp, bits);
    }
#line 267
    while (1) {
#line 267
      _p___0 = plen;
#line 267
      _e___0 = (int )((((4U + ulen) + 4U) + (unsigned int )elen) + (unsigned int )nlen);
#line 267
      if (_p___0 != _e___0) {
#line 267
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "auth1.c",
            267);
#line 267
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 267
      break;
    }
#line 269
    authenticated = auth_rhosts_rsa(pw, (char const   *)client_user, client_host_key);
#line 270
    RSA_free(client_host_key);
#line 272
    snprintf((char * __restrict  )(user), sizeof(user), (char const   * __restrict  )" ruser %s",
             client_user);
#line 273
    break;
    case 6: 
#line 276
    if (! options.rsa_authentication) {
#line 277
      verbose("RSA authentication disabled.");
#line 278
      break;
    }
#line 281
    n___0 = BN_new();
#line 282
    packet_get_bignum(n___0, & nlen);
#line 283
    while (1) {
#line 283
      _p___1 = plen;
#line 283
      _e___1 = nlen;
#line 283
      if (_p___1 != _e___1) {
#line 283
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "auth1.c",
            283);
#line 283
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 283
      break;
    }
#line 284
    authenticated = auth_rsa(pw, n___0);
#line 285
    BN_clear_free(n___0);
#line 286
    break;
    case 9: 
#line 289
    if (! options.password_authentication) {
#line 290
      verbose("Password authentication disabled.");
#line 291
      break;
    }
#line 298
    password = packet_get_string(& dlen);
#line 299
    while (1) {
#line 299
      _p___2 = plen;
#line 299
      _e___2 = (int )(4U + dlen);
#line 299
      if (_p___2 != _e___2) {
#line 299
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "auth1.c",
            299);
#line 299
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 299
      break;
    }
#line 303
    authenticated = auth_pam_password(pw, (char const   *)password);
#line 309
    tmp___1 = strlen((char const   *)password);
#line 309
    memset((void *)password, 0, tmp___1);
#line 310
    xfree((void *)password);
#line 311
    break;
    case 39: 
#line 347
    log("TIS authentication unsupported.");
#line 348
    break;
    default: 
#line 356
    log("Unknown message during authentication: type %d", type);
#line 357
    break;
    }
#line 365
    if (authenticated) {
#line 365
      if (pw->pw_uid == 0U) {
#line 365
        if (! options.permit_root_login) {
#line 366
          if (forced_command) {
#line 367
            log("Root login accepted for forced command.");
          } else {
#line 369
            authenticated = 0;
#line 370
            tmp___2 = get_canonical_hostname();
#line 370
            log("ROOT LOGIN REFUSED FROM %.200s", tmp___2);
          }
        }
      }
    }
#line 376
    if (authenticated) {
#line 379
      authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 376
      if (attempt___0 == 3) {
#line 379
        authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
      } else {
#line 376
        if (type == 9) {
#line 379
          authlog___0 = (void (*)(char const   *fmt  , ...))(& log);
        }
      }
    }
#line 381
    tmp___3 = get_remote_port();
#line 381
    tmp___4 = get_remote_ipaddr();
#line 381
    if (pw->pw_uid == 0U) {
#line 381
      tmp___5 = "ROOT";
    } else {
#line 381
      tmp___5 = (char const   *)pw->pw_name;
    }
#line 381
    tmp___6 = get_authname(type);
#line 381
    if (authenticated) {
#line 381
      tmp___7 = "Accepted";
    } else {
#line 381
      tmp___7 = "Failed";
    }
#line 381
    (*authlog___0)("%s %s for %.200s from %.200s port %d%s", tmp___7, tmp___6, tmp___5,
                   tmp___4, tmp___3, user);
#line 390
    if (authenticated) {
#line 391
      tmp___8 = do_pam_account(pw->pw_name, client_user);
#line 391
      if (! tmp___8) {
#line 392
        if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 393
          xfree((void *)client_user);
#line 394
          client_user = (char *)((void *)0);
        }
#line 396
        do_fake_authloop1(pw->pw_name);
      }
#line 398
      return;
    }
#line 406
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 407
      xfree((void *)client_user);
#line 408
      client_user = (char *)((void *)0);
    }
#line 411
    if (attempt___0 > 6) {
#line 412
      packet_disconnect("Too many authentication failures for %.100s", pw->pw_name);
    }
#line 415
    packet_start(15);
#line 416
    packet_send();
#line 417
    packet_write_wait();
#line 152
    attempt___0 ++;
  }
}
}
#line 425 "auth1.c"
void do_authentication(void) 
{ struct passwd *pw ;
  struct passwd pwcopy ;
  int plen ;
  unsigned int ulen ;
  char *user ;
  int _p ;
  int _e ;
  int tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 437
  packet_read_expect(& plen, 4);
#line 440
  user = packet_get_string(& ulen);
#line 441
  while (1) {
#line 441
    _p = plen;
#line 441
    _e = (int )(4U + ulen);
#line 441
    if (_p != _e) {
#line 441
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth1.c", 441);
#line 441
      packet_disconnect("Packet integrity error. (%d)", 4);
    }
#line 441
    break;
  }
#line 443
  setproctitle("%s", user);
#line 454
  pw = getpwnam((char const   *)user);
#line 455
  if (! pw) {
#line 456
    do_fake_authloop1(user);
  } else {
#line 455
    tmp = allowed_user(pw);
#line 455
    if (! tmp) {
#line 456
      do_fake_authloop1(user);
    }
  }
#line 457
  xfree((void *)user);
#line 460
  memset((void *)(& pwcopy), 0, sizeof(pwcopy));
#line 461
  pwcopy.pw_name = xstrdup((char const   *)pw->pw_name);
#line 462
  pwcopy.pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 463
  pwcopy.pw_uid = pw->pw_uid;
#line 464
  pwcopy.pw_gid = pw->pw_gid;
#line 465
  pwcopy.pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 466
  pwcopy.pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 467
  pw = & pwcopy;
#line 470
  start_pam(pw);
#line 477
  tmp___0 = getuid();
#line 477
  if (tmp___0 != 0U) {
#line 477
    tmp___1 = getuid();
#line 477
    if (pw->pw_uid != tmp___1) {
#line 478
      packet_disconnect("Cannot change user when server not running as root.");
    }
  }
#line 480
  debug("Attempting authentication for %.100s.", pw->pw_name);
#line 483
  if (options.password_authentication) {
#line 483
    tmp___3 = auth_pam_password(pw, "");
#line 483
    if (tmp___3) {
#line 493
      tmp___2 = get_remote_ipaddr();
#line 493
      log("Login for user %s from %.100s, accepted without authentication.", pw->pw_name,
          tmp___2);
    } else {
#line 499
      do_authloop(pw);
    }
  } else {
#line 499
    do_authloop(pw);
  }
#line 506
  packet_start(14);
#line 507
  packet_send();
#line 508
  packet_write_wait();
#line 511
  do_authenticated(pw);
#line 512
  return;
}
}
#line 1 "auth2.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 7 "auth.h"
struct passwd *auth_get_user(void) ;
#line 8 "session.h"
void do_authenticated2(void) ;
#line 65 "auth2.c"
void input_service_request(int type , int plen ) ;
#line 66
void input_userauth_request(int type , int plen ) ;
#line 67
void protocol_error(int type , int plen ) ;
#line 70
int ssh2_auth_none(struct passwd *pw ) ;
#line 71
int ssh2_auth_password(struct passwd *pw ) ;
#line 72
int ssh2_auth_pubkey(struct passwd *pw , unsigned char *raw , unsigned int rlen ) ;
#line 75
struct passwd *auth_set_user(char *u , char *s ) ;
#line 76
int user_dsa_key_allowed(struct passwd *pw , Key *key ) ;
#line 85 "auth2.c"
static Authctxt *authctxt  =    (Authctxt *)((void *)0);
#line 86 "auth2.c"
static int userauth_success  =    0;
#line 92 "auth2.c"
void do_authentication2(void) 
{ 

  {
#line 103
  dispatch_init(& protocol_error);
#line 104
  dispatch_set(5, & input_service_request);
#line 105
  dispatch_run(0, & userauth_success);
#line 106
  do_authenticated2();
#line 107
  return;
}
}
#line 109 "auth2.c"
void protocol_error(int type , int plen ) 
{ 

  {
#line 112
  log("auth: protocol error: type %d plen %d", type, plen);
#line 113
  packet_start(3);
#line 114
  packet_put_int(0U);
#line 115
  packet_send();
#line 116
  packet_write_wait();
#line 117
  return;
}
}
#line 119 "auth2.c"
void input_service_request(int type , int plen ) 
{ unsigned int len ;
  int accept___0 ;
  char *service ;
  char *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 123
  accept___0 = 0;
#line 124
  tmp = packet_get_string(& len);
#line 124
  service = tmp;
#line 125
  while (1) {
#line 125
    tmp___0 = packet_remaining();
#line 125
    _len = tmp___0;
#line 125
    if (_len > 0) {
#line 125
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          125);
#line 125
      packet_disconnect("Packet integrity error.");
    }
#line 125
    break;
  }
#line 127
  if (0) {
#line 127
    __s1_len = strlen((char const   *)service);
#line 127
    __s2_len = strlen("ssh-userauth");
#line 127
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 127
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 127
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 127
          tmp___10 = 1;
        } else {
#line 127
          if (__s2_len >= 4U) {
#line 127
            tmp___10 = 1;
          } else {
#line 127
            tmp___10 = 0;
          }
        }
      } else {
#line 127
        tmp___10 = 0;
      }
    }
#line 127
    if (tmp___10) {
#line 127
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 127
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 127
      tmp___6 = tmp___9;
    }
  } else {
#line 127
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 127
    tmp___6 = tmp___9;
  }
#line 127
  if (tmp___6 == 0) {
#line 128
    if (! userauth_success) {
#line 129
      accept___0 = 1;
#line 131
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 136
  if (accept___0) {
#line 137
    packet_start(6);
#line 138
    packet_put_cstring((char const   *)service);
#line 139
    packet_send();
#line 140
    packet_write_wait();
  } else {
#line 142
    debug("bad service request %s", service);
#line 143
    packet_disconnect("bad service request %s", service);
  }
#line 145
  xfree((void *)service);
#line 146
  return;
}
}
#line 151 "auth2.c"
static void (*authlog)(char const   *fmt  , ...)  =    (void (*)(char const   *fmt  , ...))(& verbose);
#line 152 "auth2.c"
static int attempt  =    0;
#line 148 "auth2.c"
void input_userauth_request(int type , int plen ) 
{ unsigned int len ;
  unsigned int rlen ;
  int authenticated ;
  char *raw ;
  char *user ;
  char *service ;
  char *method ;
  char *authmsg ;
  struct passwd *pw ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;

  {
#line 154
  authenticated = 0;
#line 155
  authmsg = (char *)((void *)0);
#line 158
  attempt ++;
#line 158
  if (attempt == 6) {
#line 159
    packet_disconnect("too many failed userauth_requests");
  }
#line 161
  raw = packet_get_raw((int *)(& rlen));
#line 162
  if ((unsigned int )plen != rlen) {
#line 163
    fatal("plen != rlen");
  }
#line 164
  user = packet_get_string(& len);
#line 165
  service = packet_get_string(& len);
#line 166
  method = packet_get_string(& len);
#line 167
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 170
  pw = auth_set_user(user, service);
#line 171
  if (pw) {
#line 171
    if (0) {
#line 171
      __s1_len___2 = strlen((char const   *)service);
#line 171
      __s2_len___2 = strlen("ssh-connection");
#line 171
      if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
        goto _L___6;
      } else {
#line 171
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 171
          if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 171
            tmp___38 = 1;
          } else {
#line 171
            if (__s2_len___2 >= 4U) {
#line 171
              tmp___38 = 1;
            } else {
#line 171
              tmp___38 = 0;
            }
          }
        } else {
#line 171
          tmp___38 = 0;
        }
      }
#line 171
      if (tmp___38) {
#line 171
        tmp___34 = __builtin_strcmp((char const   *)service, "ssh-connection");
      } else {
#line 171
        tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 171
        tmp___34 = tmp___37;
      }
    } else {
#line 171
      tmp___37 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 171
      tmp___34 = tmp___37;
    }
#line 171
    if (tmp___34 == 0) {
#line 172
      if (0) {
#line 172
        __s1_len___1 = strlen((char const   *)method);
#line 172
        __s2_len___1 = strlen("none");
#line 172
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___4;
        } else {
#line 172
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 172
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 172
              tmp___28 = 1;
            } else {
#line 172
              if (__s2_len___1 >= 4U) {
#line 172
                tmp___28 = 1;
              } else {
#line 172
                tmp___28 = 0;
              }
            }
          } else {
#line 172
            tmp___28 = 0;
          }
        }
#line 172
        if (tmp___28) {
#line 172
          tmp___24 = __builtin_strcmp((char const   *)method, "none");
        } else {
#line 172
          tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 172
          tmp___24 = tmp___27;
        }
      } else {
#line 172
        tmp___27 = __builtin_strcmp((char const   *)method, "none");
#line 172
        tmp___24 = tmp___27;
      }
#line 172
      if (tmp___24 == 0) {
#line 173
        authenticated = ssh2_auth_none(pw);
      } else {
#line 174
        if (0) {
#line 174
          __s1_len___0 = strlen((char const   *)method);
#line 174
          __s2_len___0 = strlen("password");
#line 174
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___2;
          } else {
#line 174
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 174
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 174
                tmp___18 = 1;
              } else {
#line 174
                if (__s2_len___0 >= 4U) {
#line 174
                  tmp___18 = 1;
                } else {
#line 174
                  tmp___18 = 0;
                }
              }
            } else {
#line 174
              tmp___18 = 0;
            }
          }
#line 174
          if (tmp___18) {
#line 174
            tmp___14 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 174
            tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 174
            tmp___14 = tmp___17;
          }
        } else {
#line 174
          tmp___17 = __builtin_strcmp((char const   *)method, "password");
#line 174
          tmp___14 = tmp___17;
        }
#line 174
        if (tmp___14 == 0) {
#line 175
          authenticated = ssh2_auth_password(pw);
        } else {
#line 176
          if (0) {
#line 176
            __s1_len = strlen((char const   *)method);
#line 176
            __s2_len = strlen("publickey");
#line 176
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___0;
            } else {
#line 176
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 176
                if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
#line 176
                  tmp___8 = 1;
                } else {
#line 176
                  if (__s2_len >= 4U) {
#line 176
                    tmp___8 = 1;
                  } else {
#line 176
                    tmp___8 = 0;
                  }
                }
              } else {
#line 176
                tmp___8 = 0;
              }
            }
#line 176
            if (tmp___8) {
#line 176
              tmp___4 = __builtin_strcmp((char const   *)method, "publickey");
            } else {
#line 176
              tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 176
              tmp___4 = tmp___7;
            }
          } else {
#line 176
            tmp___7 = __builtin_strcmp((char const   *)method, "publickey");
#line 176
            tmp___4 = tmp___7;
          }
#line 176
          if (tmp___4 == 0) {
#line 177
            authenticated = ssh2_auth_pubkey(pw, (unsigned char *)raw, rlen);
          }
        }
      }
    }
  }
#line 180
  if (authenticated) {
#line 180
    if (pw) {
#line 180
      if (pw->pw_uid == 0U) {
#line 180
        if (! options.permit_root_login) {
#line 181
          authenticated = 0;
#line 182
          tmp___39 = get_canonical_hostname();
#line 182
          log("ROOT LOGIN REFUSED FROM %.200s", tmp___39);
        }
      }
    }
  }
#line 187
  if (authenticated) {
#line 187
    tmp___40 = do_pam_account(pw->pw_name, (char *)((void *)0));
#line 187
    if (! tmp___40) {
#line 188
      authenticated = 0;
    }
  }
#line 194
  if (authenticated == 1) {
#line 195
    authlog = (void (*)(char const   *fmt  , ...))(& log);
  } else {
#line 194
    if (attempt == 3) {
#line 195
      authlog = (void (*)(char const   *fmt  , ...))(& log);
    } else {
#line 194
      if (0) {
#line 194
        __s1_len___3 = strlen((char const   *)method);
#line 194
        __s2_len___3 = strlen("password");
#line 194
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___8;
        } else {
#line 194
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 194
            if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 194
              tmp___50 = 1;
            } else {
#line 194
              if (__s2_len___3 >= 4U) {
#line 194
                tmp___50 = 1;
              } else {
#line 194
                tmp___50 = 0;
              }
            }
          } else {
#line 194
            tmp___50 = 0;
          }
        }
#line 194
        if (tmp___50) {
#line 194
          tmp___46 = __builtin_strcmp((char const   *)method, "password");
        } else {
#line 194
          tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 194
          tmp___46 = tmp___49;
        }
      } else {
#line 194
        tmp___49 = __builtin_strcmp((char const   *)method, "password");
#line 194
        tmp___46 = tmp___49;
      }
#line 194
      if (tmp___46 == 0) {
#line 195
        authlog = (void (*)(char const   *fmt  , ...))(& log);
      }
    }
  }
#line 198
  if (authenticated == 1) {
#line 199
    authmsg = (char *)"Accepted";
  } else {
#line 200
    if (authenticated == 0) {
#line 201
      authmsg = (char *)"Failed";
    } else {
#line 203
      authmsg = (char *)"Postponed";
    }
  }
#line 205
  tmp___51 = get_remote_port();
#line 205
  tmp___52 = get_remote_ipaddr();
#line 205
  if (pw) {
#line 205
    if (pw->pw_uid == 0U) {
#line 205
      tmp___53 = "ROOT";
    } else {
#line 205
      tmp___53 = (char const   *)user;
    }
  } else {
#line 205
    tmp___53 = (char const   *)user;
  }
#line 205
  (*authlog)("%s %s for %.200s from %.200s port %d ssh2", authmsg, method, tmp___53,
             tmp___52, tmp___51);
#line 213
  if (authenticated == 1) {
#line 215
    dispatch_set(50, & protocol_error);
#line 216
    packet_start(52);
#line 217
    packet_send();
#line 218
    packet_write_wait();
#line 220
    userauth_success = 1;
  } else {
#line 221
    if (authenticated == 0) {
#line 222
      packet_start(51);
#line 223
      packet_put_cstring("publickey,password");
#line 224
      packet_put_char(0);
#line 225
      packet_send();
#line 226
      packet_write_wait();
    }
  }
#line 229
  xfree((void *)service);
#line 230
  xfree((void *)user);
#line 231
  xfree((void *)method);
#line 232
  return;
}
}
#line 234 "auth2.c"
int ssh2_auth_none(struct passwd *pw ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 237
  while (1) {
#line 237
    tmp = packet_remaining();
#line 237
    _len = tmp;
#line 237
    if (_len > 0) {
#line 237
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          237);
#line 237
      packet_disconnect("Packet integrity error.");
    }
#line 237
    break;
  }
#line 239
  tmp___0 = auth_pam_password(pw, "");
#line 239
  return (tmp___0);
}
}
#line 244 "auth2.c"
int ssh2_auth_password(struct passwd *pw ) 
{ char *password ;
  int authenticated ;
  int change ;
  unsigned int len ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 248
  authenticated = 0;
#line 251
  tmp = packet_get_char();
#line 251
  change = (int )tmp;
#line 252
  if (change) {
#line 253
    log("password change not supported");
  }
#line 254
  password = packet_get_string(& len);
#line 255
  while (1) {
#line 255
    tmp___0 = packet_remaining();
#line 255
    _len = tmp___0;
#line 255
    if (_len > 0) {
#line 255
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
          255);
#line 255
      packet_disconnect("Packet integrity error.");
    }
#line 255
    break;
  }
#line 256
  if (options.password_authentication) {
#line 256
    tmp___1 = auth_pam_password(pw, (char const   *)password);
#line 256
    if (tmp___1 == 1) {
#line 262
      authenticated = 1;
    }
  }
#line 263
  memset((void *)password, 0, len);
#line 264
  xfree((void *)password);
#line 265
  return (authenticated);
}
}
#line 267 "auth2.c"
int ssh2_auth_pubkey(struct passwd *pw , unsigned char *raw , unsigned int rlen ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *pkblob ;
  char *sig ;
  unsigned int alen ;
  unsigned int blen ;
  unsigned int slen ;
  int have_sig ;
  int authenticated ;
  unsigned int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int _len ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int _len___0 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 275
  authenticated = 0;
#line 277
  if (options.dsa_authentication == 0) {
#line 278
    debug("pubkey auth disabled");
#line 279
    return (0);
  }
#line 281
  tmp = packet_get_char();
#line 281
  have_sig = (int )tmp;
#line 282
  pkalg = packet_get_string(& alen);
#line 283
  if (0) {
#line 283
    __s1_len = strlen((char const   *)pkalg);
#line 283
    __s2_len = strlen("ssh-dss");
#line 283
    if (! ((unsigned int )((void const   *)(pkalg + 1)) - (unsigned int )((void const   *)pkalg) == 1U)) {
      goto _L___0;
    } else {
#line 283
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 283
        if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 283
          tmp___9 = 1;
        } else {
#line 283
          if (__s2_len >= 4U) {
#line 283
            tmp___9 = 1;
          } else {
#line 283
            tmp___9 = 0;
          }
        }
      } else {
#line 283
        tmp___9 = 0;
      }
    }
#line 283
    if (tmp___9) {
#line 283
      tmp___5 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
    } else {
#line 283
      tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 283
      tmp___5 = tmp___8;
    }
  } else {
#line 283
    tmp___8 = __builtin_strcmp((char const   *)pkalg, "ssh-dss");
#line 283
    tmp___5 = tmp___8;
  }
#line 283
  if (tmp___5 != 0) {
#line 284
    xfree((void *)pkalg);
#line 285
    log("bad pkalg %s", pkalg);
#line 286
    return (0);
  }
#line 288
  pkblob = packet_get_string(& blen);
#line 289
  key = dsa_key_from_blob(pkblob, (int )blen);
#line 290
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 291
    if (have_sig) {
#line 292
      sig = packet_get_string(& slen);
#line 293
      while (1) {
#line 293
        tmp___10 = packet_remaining();
#line 293
        _len = tmp___10;
#line 293
        if (_len > 0) {
#line 293
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
              293);
#line 293
          packet_disconnect("Packet integrity error.");
        }
#line 293
        break;
      }
#line 294
      buffer_init(& b);
#line 295
      buffer_append(& b, (char const   *)session_id2, (unsigned int )session_id2_len);
#line 296
      buffer_put_char(& b, 50);
#line 297
      if (slen + 4U > rlen) {
#line 298
        fatal("bad rlen/slen");
      }
#line 299
      buffer_append(& b, (char const   *)raw, (rlen - slen) - 4U);
#line 304
      tmp___11 = user_dsa_key_allowed(pw, key);
#line 304
      if (tmp___11) {
#line 304
        tmp___12 = buffer_len(& b);
#line 304
        tmp___13 = buffer_ptr(& b);
#line 304
        tmp___14 = dsa_verify(key, (unsigned char *)sig, (int )slen, (unsigned char *)tmp___13,
                              (int )tmp___12);
#line 304
        if (tmp___14 == 1) {
#line 306
          authenticated = 1;
        }
      }
#line 307
      buffer_clear(& b);
#line 308
      xfree((void *)sig);
    } else {
#line 310
      while (1) {
#line 310
        tmp___15 = packet_remaining();
#line 310
        _len___0 = tmp___15;
#line 310
        if (_len___0 > 0) {
#line 310
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2.c",
              310);
#line 310
          packet_disconnect("Packet integrity error.");
        }
#line 310
        break;
      }
#line 311
      debug("test key...");
#line 321
      tmp___16 = user_dsa_key_allowed(pw, key);
#line 321
      if (tmp___16) {
#line 322
        packet_start(60);
#line 323
        packet_put_string((char const   *)pkalg, alen);
#line 324
        packet_put_string((char const   *)pkblob, blen);
#line 325
        packet_send();
#line 326
        packet_write_wait();
#line 327
        authenticated = -1;
      }
    }
#line 330
    key_free(key);
  }
#line 332
  xfree((void *)pkalg);
#line 333
  xfree((void *)pkblob);
#line 334
  return (authenticated);
}
}
#line 339 "auth2.c"
struct passwd *auth_get_user(void) 
{ struct passwd *tmp ;

  {
#line 342
  if ((unsigned int )authctxt != (unsigned int )((void *)0)) {
#line 342
    if (authctxt->valid) {
#line 342
      tmp = & authctxt->pw;
    } else {
#line 342
      tmp = (struct passwd *)((void *)0);
    }
  } else {
#line 342
    tmp = (struct passwd *)((void *)0);
  }
#line 342
  return (tmp);
}
}
#line 345 "auth2.c"
struct passwd *auth_set_user(char *u , char *s ) 
{ struct passwd *pw ;
  struct passwd *copy ;
  void *tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  struct passwd *tmp___21 ;

  {
#line 350
  if ((unsigned int )authctxt == (unsigned int )((void *)0)) {
#line 351
    tmp = xmalloc(sizeof(*authctxt));
#line 351
    authctxt = (Authctxt *)tmp;
#line 352
    authctxt->valid = 0;
#line 353
    authctxt->user = xstrdup((char const   *)u);
#line 354
    authctxt->service = xstrdup((char const   *)s);
#line 355
    setproctitle("%s", u);
#line 356
    pw = getpwnam((char const   *)u);
#line 357
    if (! pw) {
#line 358
      log("auth_set_user: illegal user %s", u);
#line 359
      return ((struct passwd *)((void *)0));
    } else {
#line 357
      tmp___0 = allowed_user(pw);
#line 357
      if (! tmp___0) {
#line 358
        log("auth_set_user: illegal user %s", u);
#line 359
        return ((struct passwd *)((void *)0));
      }
    }
#line 362
    start_pam(pw);
#line 364
    copy = & authctxt->pw;
#line 365
    memset((void *)copy, 0, sizeof(*copy));
#line 366
    copy->pw_name = xstrdup((char const   *)pw->pw_name);
#line 367
    copy->pw_passwd = xstrdup((char const   *)pw->pw_passwd);
#line 368
    copy->pw_uid = pw->pw_uid;
#line 369
    copy->pw_gid = pw->pw_gid;
#line 370
    copy->pw_dir = xstrdup((char const   *)pw->pw_dir);
#line 371
    copy->pw_shell = xstrdup((char const   *)pw->pw_shell);
#line 372
    authctxt->valid = 1;
  } else {
#line 374
    if (0) {
#line 374
      __s1_len = strlen((char const   *)u);
#line 374
      __s2_len = strlen((char const   *)authctxt->user);
#line 374
      if (! ((unsigned int )((void const   *)(u + 1)) - (unsigned int )((void const   *)u) == 1U)) {
        goto _L___0;
      } else {
#line 374
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 374
          if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
#line 374
            tmp___10 = 1;
          } else {
#line 374
            if (__s2_len >= 4U) {
#line 374
              tmp___10 = 1;
            } else {
#line 374
              tmp___10 = 0;
            }
          }
        } else {
#line 374
          tmp___10 = 0;
        }
      }
#line 374
      if (tmp___10) {
#line 374
        tmp___6 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
      } else {
#line 374
        tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 374
        tmp___6 = tmp___9;
      }
    } else {
#line 374
      tmp___9 = __builtin_strcmp((char const   *)u, (char const   *)authctxt->user);
#line 374
      tmp___6 = tmp___9;
    }
#line 375
    if (tmp___6 != 0) {
#line 376
      log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 378
      return ((struct passwd *)((void *)0));
    } else {
#line 375
      if (0) {
#line 375
        __s1_len___0 = strlen((char const   *)s);
#line 375
        __s2_len___0 = strlen((char const   *)authctxt->service);
#line 375
        if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
          goto _L___2;
        } else {
#line 375
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 375
            if (! ((unsigned int )((void const   *)(authctxt->service + 1)) - (unsigned int )((void const   *)authctxt->service) == 1U)) {
#line 375
              tmp___20 = 1;
            } else {
#line 375
              if (__s2_len___0 >= 4U) {
#line 375
                tmp___20 = 1;
              } else {
#line 375
                tmp___20 = 0;
              }
            }
          } else {
#line 375
            tmp___20 = 0;
          }
        }
#line 375
        if (tmp___20) {
#line 375
          tmp___16 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
        } else {
#line 375
          tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 375
          tmp___16 = tmp___19;
        }
      } else {
#line 375
        tmp___19 = __builtin_strcmp((char const   *)s, (char const   *)authctxt->service);
#line 375
        tmp___16 = tmp___19;
      }
#line 375
      if (tmp___16 != 0) {
#line 376
        log("auth_set_user: missmatch: (%s,%s)!=(%s,%s)", u, s, authctxt->user, authctxt->service);
#line 378
        return ((struct passwd *)((void *)0));
      }
    }
  }
#line 381
  tmp___21 = auth_get_user();
#line 381
  return (tmp___21);
}
}
#line 429 "auth2.c"
static char const   *check___0[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 385 "auth2.c"
int user_dsa_key_allowed(struct passwd *pw , Key *key ) 
{ char line[8192] ;
  char file[1024] ;
  int found_key ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  Key *found ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 389
  found_key = 0;
#line 390
  bits = 4294967295U;
#line 392
  linenum = 0UL;
#line 397
  temporarily_use_uid(pw->pw_uid);
#line 400
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys2");
#line 404
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 404
  if (tmp < 0) {
#line 406
    restore_uid();
#line 407
    return (0);
  }
#line 410
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 411
  if (! f) {
#line 413
    restore_uid();
#line 414
    return (0);
  }
#line 416
  if (options.strict_modes) {
#line 417
    fail = 0;
#line 420
    tmp___1 = fileno(f);
#line 420
    tmp___2 = fstat(tmp___1, & st);
#line 420
    if (tmp___2 < 0) {
#line 423
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 425
      fail = 1;
    } else {
#line 420
      if (st.st_uid != 0U) {
#line 420
        if (st.st_uid != pw->pw_uid) {
#line 423
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 425
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 420
        if ((st.st_mode & 18U) != 0U) {
#line 423
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 425
          fail = 1;
        } else {
#line 432
          i = 0;
#line 432
          while (check___0[i]) {
#line 433
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___0[i]);
#line 435
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 435
            if (tmp___0 < 0) {
#line 438
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 442
              fail = 1;
#line 443
              break;
            } else {
#line 435
              if (st.st_uid != 0U) {
#line 435
                if (st.st_uid != pw->pw_uid) {
#line 438
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 442
                  fail = 1;
#line 443
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 435
                if ((st.st_mode & 18U) != 0U) {
#line 438
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"DSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 442
                  fail = 1;
#line 443
                  break;
                }
              }
            }
#line 432
            i ++;
          }
        }
      }
    }
#line 447
    if (fail) {
#line 448
      log((char const   *)(buf___1));
#line 449
      fclose(f);
#line 450
      restore_uid();
#line 451
      return (0);
    }
  }
#line 454
  found_key = 0;
#line 455
  found = key_new(1);
#line 457
  while (1) {
#line 457
    tmp___4 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 457
    if (! tmp___4) {
#line 457
      break;
    }
#line 459
    linenum ++;
#line 461
    cp = line;
#line 461
    while (1) {
#line 461
      if (! ((int )*cp == 32)) {
#line 461
        if (! ((int )*cp == 9)) {
#line 461
          break;
        }
      }
#line 461
      cp ++;
    }
#line 463
    if (! *cp) {
#line 464
      continue;
    } else {
#line 463
      if ((int )*cp == 10) {
#line 464
        continue;
      } else {
#line 463
        if ((int )*cp == 35) {
#line 464
          continue;
        }
      }
    }
#line 465
    bits = key_read(found, & cp);
#line 466
    if (bits == 0U) {
#line 467
      continue;
    }
#line 468
    tmp___3 = key_equal(found, key);
#line 468
    if (tmp___3) {
#line 469
      found_key = 1;
#line 470
      debug("matching key found: file %s, line %ld", file, linenum);
#line 472
      break;
    }
  }
#line 475
  restore_uid();
#line 476
  fclose(f);
#line 477
  key_free(found);
#line 478
  return (found_key);
}
}
#line 1 "auth-rhosts.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 33 "auth-rhosts.c"
int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                      char const   *client_user , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 42
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 43
  if (! f) {
#line 44
    return (0);
  }
#line 46
  while (1) {
#line 46
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 46
    if (! tmp___50) {
#line 46
      break;
    }
#line 51
    cp = buf___1;
#line 51
    while (1) {
#line 51
      if (! ((int )*cp == 32)) {
#line 51
        if (! ((int )*cp == 9)) {
#line 51
          break;
        }
      }
#line 51
      cp ++;
    }
#line 53
    if ((int )*cp == 35) {
#line 54
      continue;
    } else {
#line 53
      if ((int )*cp == 10) {
#line 54
        continue;
      } else {
#line 53
        if (! *cp) {
#line 54
          continue;
        }
      }
    }
#line 60
    if (0) {
#line 60
      if (0) {
#line 60
        __s1_len___0 = strlen((char const   *)cp);
#line 60
        __s2_len___0 = strlen("NO_PLUS");
#line 60
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 60
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 60
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 60
              tmp___22 = 1;
            } else {
#line 60
              if (__s2_len___0 >= 4U) {
#line 60
                tmp___22 = 1;
              } else {
#line 60
                tmp___22 = 0;
              }
            }
          } else {
#line 60
            tmp___22 = 0;
          }
        }
#line 60
        if (tmp___22) {
#line 60
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 60
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
          tmp___18 = tmp___21;
        }
      } else {
#line 60
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 60
        tmp___18 = tmp___21;
      }
#line 60
      tmp___12 = tmp___18;
    } else {
#line 60
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 60
    if (tmp___12 == 0) {
#line 61
      continue;
    }
#line 67
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%s %s %s",
                      hostbuf, userbuf, dummy);
#line 67
    switch (tmp___25) {
    case 0: 
#line 69
    packet_send_debug("Found empty line in %.100s.", filename);
#line 70
    continue;
    case 1: 
#line 73
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 74
    break;
    case 2: 
#line 77
    break;
    case 3: 
#line 79
    packet_send_debug("Found garbage in %.100s.", filename);
#line 80
    continue;
    default: ;
#line 83
    continue;
    }
#line 86
    host = hostbuf;
#line 87
    user = userbuf;
#line 88
    negated = 0;
#line 91
    if ((int )*(host + 0) == 45) {
#line 92
      negated = 1;
#line 93
      host ++;
    } else {
#line 94
      if ((int )*(host + 0) == 43) {
#line 95
        host ++;
      }
    }
#line 97
    if ((int )*(user + 0) == 45) {
#line 98
      negated = 1;
#line 99
      user ++;
    } else {
#line 100
      if ((int )*(user + 0) == 43) {
#line 101
        user ++;
      }
    }
#line 104
    if (! *(host + 0)) {
#line 106
      packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
      continue;
    } else {
#line 104
      if (! *(user + 0)) {
#line 106
        packet_send_debug("Ignoring wild host/user names in %.100s.", filename);
#line 108
        continue;
      }
    }
#line 111
    if ((int )*(host + 0) == 64) {
#line 112
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 112
      if (! tmp___26) {
#line 112
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 112
        if (! tmp___27) {
#line 114
          continue;
        }
      }
    } else {
#line 115
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 115
      if (tmp___28) {
#line 115
        if (0) {
#line 115
          __s1_len___1 = strlen((char const   *)host);
#line 115
          __s2_len___1 = strlen(ipaddr);
#line 115
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 115
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 115
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 115
                tmp___38 = 1;
              } else {
#line 115
                if (__s2_len___1 >= 4U) {
#line 115
                  tmp___38 = 1;
                } else {
#line 115
                  tmp___38 = 0;
                }
              }
            } else {
#line 115
              tmp___38 = 0;
            }
          }
#line 115
          if (tmp___38) {
#line 115
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 115
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
            tmp___34 = tmp___37;
          }
        } else {
#line 115
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 115
          tmp___34 = tmp___37;
        }
#line 115
        if (tmp___34 != 0) {
#line 116
          continue;
        }
      }
    }
#line 119
    if ((int )*(user + 0) == 64) {
#line 120
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user, (char const   *)((void *)0));
#line 120
      if (! tmp___39) {
#line 121
        continue;
      }
    } else {
#line 122
      if (0) {
#line 122
        __s1_len___2 = strlen((char const   *)user);
#line 122
        __s2_len___2 = strlen(client_user);
#line 122
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 122
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 122
            if (! ((unsigned int )((void const   *)(client_user + 1)) - (unsigned int )((void const   *)client_user) == 1U)) {
#line 122
              tmp___49 = 1;
            } else {
#line 122
              if (__s2_len___2 >= 4U) {
#line 122
                tmp___49 = 1;
              } else {
#line 122
                tmp___49 = 0;
              }
            }
          } else {
#line 122
            tmp___49 = 0;
          }
        }
#line 122
        if (tmp___49) {
#line 122
          tmp___45 = __builtin_strcmp((char const   *)user, client_user);
        } else {
#line 122
          tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
          tmp___45 = tmp___48;
        }
      } else {
#line 122
        tmp___48 = __builtin_strcmp((char const   *)user, client_user);
#line 122
        tmp___45 = tmp___48;
      }
#line 122
      if (tmp___45 != 0) {
#line 123
        continue;
      }
    }
#line 126
    fclose(f);
#line 129
    if (negated) {
#line 130
      packet_send_debug("Matched negative entry in %.100s.", filename);
#line 132
      return (0);
    }
#line 135
    return (1);
  }
#line 139
  fclose(f);
#line 140
  return (0);
}
}
#line 156 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 149 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user ) 
{ char buf___1[1024] ;
  char const   *hostname ;
  char const   *ipaddr ;
  struct stat st ;
  unsigned int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 160
  temporarily_use_uid(pw->pw_uid);
#line 166
  rhosts_file_index = 0U;
#line 166
  while (rhosts_files[rhosts_file_index]) {
#line 169
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 171
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 171
    if (tmp >= 0) {
#line 172
      break;
    }
#line 166
    rhosts_file_index ++;
  }
#line 175
  restore_uid();
#line 178
  if (! rhosts_files[rhosts_file_index]) {
#line 178
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 178
    if (tmp___0 < 0) {
#line 178
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 178
      if (tmp___1 < 0) {
#line 181
        return (0);
      }
    }
  }
#line 183
  hostname = get_canonical_hostname();
#line 184
  ipaddr = get_remote_ipaddr();
#line 187
  if (pw->pw_uid != 0U) {
#line 188
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 188
    if (tmp___2) {
#line 190
      packet_send_debug("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                        ipaddr);
#line 192
      return (1);
    }
#line 194
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 194
    if (tmp___3) {
#line 196
      packet_send_debug("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                        "/usr/local/etc/shosts.equiv");
#line 198
      return (1);
    }
  }
#line 205
  tmp___4 = stat((char const   * __restrict  )pw->pw_dir, (struct stat * __restrict  )(& st));
#line 205
  if (tmp___4 < 0) {
#line 206
    log("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
        pw->pw_dir);
#line 208
    packet_send_debug("Rhosts authentication refused for %.100s: no home directory %.200s",
                      pw->pw_name, pw->pw_dir);
#line 210
    return (0);
  }
#line 212
  if (options.strict_modes) {
#line 212
    if (st.st_uid != 0U) {
#line 212
      if (st.st_uid != pw->pw_uid) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 212
      if ((st.st_mode & 18U) != 0U) {
#line 215
        log("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
#line 217
        packet_send_debug("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                          pw->pw_name);
#line 219
        return (0);
      }
    }
  }
#line 222
  temporarily_use_uid(pw->pw_uid);
#line 225
  rhosts_file_index = 0U;
#line 225
  while (rhosts_files[rhosts_file_index]) {
#line 228
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
#line 230
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 230
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 239
    if (options.strict_modes) {
#line 239
      if (st.st_uid != 0U) {
#line 239
        if (st.st_uid != pw->pw_uid) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 239
        if ((st.st_mode & 18U) != 0U) {
#line 242
          log("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
#line 244
          packet_send_debug("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 248
    if (options.ignore_rhosts) {
#line 249
      packet_send_debug("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 254
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user,
                                (char const   *)pw->pw_name);
#line 254
    if (tmp___6) {
#line 255
      packet_send_debug("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 258
      restore_uid();
#line 259
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 225
    rhosts_file_index ++;
  }
#line 264
  restore_uid();
#line 265
  return (0);
}
}
#line 1 "auth-krb4.o"
#line 1 "auth-pam.o"
#line 167 "/usr/include/security/_pam_types.h"
extern int __attribute__((__nonnull__(1)))  pam_set_item(pam_handle_t *pamh , int item_type ,
                                                         void const   *item ) ;
#line 173
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 22 "/usr/include/security/pam_appl.h"
extern int __attribute__((__nonnull__(1,3,4)))  pam_start(char const   *service_name ,
                                                          char const   *user , struct pam_conv  const  *pam_conversation ,
                                                          pam_handle_t **pamh ) ;
#line 27
extern int __attribute__((__nonnull__(1)))  pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 32
extern int __attribute__((__nonnull__(1)))  pam_authenticate(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 35
extern int __attribute__((__nonnull__(1)))  pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 40
extern int __attribute__((__nonnull__(1)))  pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 45
extern int __attribute__((__nonnull__(1)))  pam_open_session(pam_handle_t *pamh ,
                                                             int flags ) ;
#line 48
extern int __attribute__((__nonnull__(1)))  pam_close_session(pam_handle_t *pamh ,
                                                              int flags ) ;
#line 9 "auth-pam.h"
char **fetch_pam_environment(void) ;
#line 11
void do_pam_session(char *username , char const   *ttyname___0 ) ;
#line 12
void do_pam_setcred(void) ;
#line 13
void print_pam_messages(void) ;
#line 19 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) ;
#line 21
void pam_cleanup_proc(void *context ) ;
#line 24 "auth-pam.c"
static struct pam_conv conv  =    {& pamconv, (void *)0};
#line 28 "auth-pam.c"
static struct pam_handle_t *pamh  =    (struct pam_handle_t *)((void *)0);
#line 29 "auth-pam.c"
static char const   *pampasswd  =    (char const   *)((void *)0);
#line 30 "auth-pam.c"
static char *pamconv_msg  =    (char *)((void *)0);
#line 34 "auth-pam.c"
static int pamconv(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
                   void *appdata_ptr ) 
{ struct pam_response *reply ;
  int count ;
  size_t msg_len ;
  char *p ;
  void *tmp ;
  size_t n___0 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 43
  tmp = malloc((unsigned int )num_msg * sizeof(*reply));
#line 43
  reply = (struct pam_response *)tmp;
#line 44
  if ((unsigned int )reply == (unsigned int )((void *)0)) {
#line 45
    return (19);
  }
#line 47
  count = 0;
#line 47
  while (count < num_msg) {
#line 48
    switch ((int )(*(msg + count))->msg_style) {
    case 1: 
#line 50
    if ((unsigned int )pampasswd == (unsigned int )((void *)0)) {
#line 51
      free((void *)reply);
#line 52
      return (19);
    }
#line 54
    (reply + count)->resp_retcode = 0;
#line 55
    (reply + count)->resp = xstrdup(pampasswd);
#line 56
    break;
    case 4: 
#line 59
    (reply + count)->resp_retcode = 0;
#line 60
    (reply + count)->resp = xstrdup("");
#line 62
    if ((unsigned int )(*(msg + count))->msg == (unsigned int )((void *)0)) {
#line 63
      break;
    }
#line 65
    debug("Adding PAM message: %s", (*(msg + count))->msg);
#line 67
    msg_len = strlen((char const   *)(*(msg + count))->msg);
#line 68
    if (pamconv_msg) {
#line 69
      tmp___0 = strlen((char const   *)pamconv_msg);
#line 69
      n___0 = tmp___0;
#line 70
      tmp___1 = xrealloc((void *)pamconv_msg, (n___0 + msg_len) + 2U);
#line 70
      pamconv_msg = (char *)tmp___1;
#line 71
      p = pamconv_msg + n___0;
    } else {
#line 73
      tmp___2 = xmalloc(msg_len + 2U);
#line 73
      p = (char *)tmp___2;
#line 73
      pamconv_msg = p;
    }
#line 75
    memcpy((void * __restrict  )p, (void const   * __restrict  )(*(msg + count))->msg,
           msg_len);
#line 76
    *(p + msg_len) = (char )'\n';
#line 77
    *(p + (msg_len + 1U)) = (char )'\000';
#line 78
    break;
    case 2: 
    case 3: 
    default: 
#line 83
    free((void *)reply);
#line 84
    return (19);
    }
#line 47
    count ++;
  }
#line 88
  *resp = reply;
#line 90
  return (0);
}
}
#line 94 "auth-pam.c"
void pam_cleanup_proc(void *context ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;

  {
#line 98
  if ((unsigned int )pamh != (unsigned int )((void *)0)) {
#line 100
    tmp = pam_close_session((pam_handle_t *)pamh, 0);
#line 100
    pam_retval = (int )tmp;
#line 101
    if (pam_retval != 0) {
#line 102
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 102
      log("Cannot close PAM session: %.200s", tmp___0);
    }
#line 106
    tmp___1 = pam_setcred((pam_handle_t *)pamh, 4);
#line 106
    pam_retval = (int )tmp___1;
#line 107
    if (pam_retval != 0) {
#line 108
      tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 108
      log("Cannot delete credentials: %.200s", tmp___2);
    }
#line 112
    tmp___3 = pam_end((pam_handle_t *)pamh, pam_retval);
#line 112
    pam_retval = (int )tmp___3;
#line 113
    if (pam_retval != 0) {
#line 114
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 114
      log("Cannot release PAM authentication: %.200s", tmp___4);
    }
  }
#line 118
  return;
}
}
#line 121 "auth-pam.c"
int auth_pam_password(struct passwd *pw , char const   *password ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 127
  if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 128
    return (0);
  }
#line 129
  if (pw->pw_uid == 0U) {
#line 129
    if (options.permit_root_login == 2) {
#line 130
      return (0);
    }
  }
#line 131
  if ((int const   )*password == 0) {
#line 131
    if (options.permit_empty_passwd == 0) {
#line 132
      return (0);
    }
  }
#line 134
  pampasswd = password;
#line 136
  tmp = pam_authenticate((pam_handle_t *)pamh, 0);
#line 136
  pam_retval = (int )tmp;
#line 137
  if (pam_retval == 0) {
#line 138
    debug("PAM Password authentication accepted for user \"%.100s\"", pw->pw_name);
#line 139
    return (1);
  } else {
#line 141
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 141
    debug("PAM Password authentication for \"%.100s\" failed: %s", pw->pw_name, tmp___0);
#line 143
    return (0);
  }
}
}
#line 148 "auth-pam.c"
int do_pam_account(char *username , char *remote_user ) 
{ int pam_retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;
  int __attribute__((__nonnull__(1)))  tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__nonnull__(1)))  tmp___5 ;
  char const   *tmp___6 ;

  {
#line 152
  tmp = get_canonical_hostname();
#line 152
  debug("PAM setting rhost to \"%.200s\"", tmp);
#line 153
  tmp___0 = get_canonical_hostname();
#line 153
  tmp___1 = pam_set_item((pam_handle_t *)pamh, 4, (void const   *)tmp___0);
#line 153
  pam_retval = (int )tmp___1;
#line 155
  if (pam_retval != 0) {
#line 156
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 156
    fatal("PAM set rhost failed: %.200s", tmp___2);
  }
#line 159
  if ((unsigned int )remote_user != (unsigned int )((void *)0)) {
#line 160
    debug("PAM setting ruser to \"%.200s\"", remote_user);
#line 161
    tmp___3 = pam_set_item((pam_handle_t *)pamh, 8, (void const   *)remote_user);
#line 161
    pam_retval = (int )tmp___3;
#line 162
    if (pam_retval != 0) {
#line 163
      tmp___4 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 163
      fatal("PAM set ruser failed: %.200s", tmp___4);
    }
  }
#line 167
  tmp___5 = pam_acct_mgmt((pam_handle_t *)pamh, 0);
#line 167
  pam_retval = (int )tmp___5;
#line 168
  if (pam_retval != 0) {
#line 169
    tmp___6 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 169
    log("PAM rejected by account configuration: %.200s", tmp___6);
#line 170
    return (0);
  }
#line 173
  return (1);
}
}
#line 177 "auth-pam.c"
void do_pam_session(char *username , char const   *ttyname___0 ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;
  int __attribute__((__nonnull__(1)))  tmp___1 ;
  char const   *tmp___2 ;

  {
#line 181
  if ((unsigned int )ttyname___0 != (unsigned int )((void *)0)) {
#line 182
    debug("PAM setting tty to \"%.200s\"", ttyname___0);
#line 183
    tmp = pam_set_item((pam_handle_t *)pamh, 3, (void const   *)ttyname___0);
#line 183
    pam_retval = (int )tmp;
#line 184
    if (pam_retval != 0) {
#line 185
      tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 185
      fatal("PAM set tty failed: %.200s", tmp___0);
    }
  }
#line 188
  tmp___1 = pam_open_session((pam_handle_t *)pamh, 0);
#line 188
  pam_retval = (int )tmp___1;
#line 189
  if (pam_retval != 0) {
#line 190
    tmp___2 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 190
    fatal("PAM session setup failed: %.200s", tmp___2);
  }
#line 191
  return;
}
}
#line 194 "auth-pam.c"
void do_pam_setcred(void) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1)))  tmp ;
  char const   *tmp___0 ;

  {
#line 198
  debug("PAM establishing creds");
#line 199
  tmp = pam_setcred((pam_handle_t *)pamh, 2);
#line 199
  pam_retval = (int )tmp;
#line 200
  if (pam_retval != 0) {
#line 201
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 201
    fatal("PAM setcred failed: %.200s", tmp___0);
  }
#line 202
  return;
}
}
#line 205 "auth-pam.c"
void finish_pam(void) 
{ 

  {
#line 207
  pam_cleanup_proc((void *)0);
#line 208
  fatal_remove_cleanup(& pam_cleanup_proc, (void *)0);
#line 209
  return;
}
}
#line 212 "auth-pam.c"
void start_pam(struct passwd *pw ) 
{ int pam_retval ;
  int __attribute__((__nonnull__(1,3,4)))  tmp ;
  char const   *tmp___0 ;

  {
#line 216
  debug("Starting up PAM with username \"%.200s\"", pw->pw_name);
#line 218
  tmp = pam_start("sshd", (char const   *)pw->pw_name, (struct pam_conv  const  *)(& conv),
                  (pam_handle_t **)(& pamh));
#line 218
  pam_retval = (int )tmp;
#line 220
  if (pam_retval != 0) {
#line 221
    tmp___0 = pam_strerror((pam_handle_t *)pamh, pam_retval);
#line 221
    fatal("PAM initialisation failed: %.200s", tmp___0);
  }
#line 223
  fatal_add_cleanup(& pam_cleanup_proc, (void *)0);
#line 224
  return;
}
}
#line 227 "auth-pam.c"
char **fetch_pam_environment(void) 
{ 

  {
#line 232
  return ((char **)((void *)0));
}
}
#line 238 "auth-pam.c"
void print_pam_messages(void) 
{ 

  {
#line 240
  if ((unsigned int )pamconv_msg != (unsigned int )((void *)0)) {
#line 241
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )pamconv_msg);
  }
#line 242
  return;
}
}
#line 1 "auth-passwd.o"
#line 1 "auth-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 212
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 401 "/usr/include/openssl/bn.h"
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 415 "ssh.h"
int auth_rsa_challenge_dialog(RSA *pk ) ;
#line 34 "auth-rsa.c"
int no_port_forwarding_flag ;
#line 35
int no_agent_forwarding_flag ;
#line 36
int no_x11_forwarding_flag ;
#line 37
int no_pty_flag ;
#line 39
struct envstring *custom_environment ;
#line 63 "auth-rsa.c"
int auth_rsa_challenge_dialog(RSA *pk ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  BN_CTX *ctx ;
  unsigned char buf___1[32] ;
  unsigned char mdbuf[16] ;
  unsigned char response[16] ;
  MD5_CTX md ;
  unsigned int i ;
  int plen ;
  int len ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 73
  encrypted_challenge = BN_new();
#line 74
  challenge = BN_new();
#line 77
  BN_rand(challenge, 256, 0, 0);
#line 78
  ctx = BN_CTX_new();
#line 79
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)pk->n,
         ctx);
#line 80
  BN_CTX_free(ctx);
#line 83
  rsa_public_encrypt(encrypted_challenge, challenge, pk);
#line 86
  packet_start(7);
#line 87
  packet_put_bignum(encrypted_challenge);
#line 88
  packet_send();
#line 89
  BN_clear_free(encrypted_challenge);
#line 90
  packet_write_wait();
#line 93
  packet_read_expect(& plen, 8);
#line 94
  while (1) {
#line 94
    _p = plen;
#line 94
    _e = 16;
#line 94
    if (_p != _e) {
#line 94
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "auth-rsa.c", 94);
#line 94
      packet_disconnect("Packet integrity error. (%d)", 8);
    }
#line 94
    break;
  }
#line 95
  i = 0U;
#line 95
  while (i < 16U) {
#line 96
    tmp = packet_get_char();
#line 96
    response[i] = (unsigned char )tmp;
#line 95
    i ++;
  }
#line 99
  tmp___0 = BN_num_bits((BIGNUM const   *)challenge);
#line 99
  len = (tmp___0 + 7) / 8;
#line 100
  if (len <= 0) {
#line 101
    fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
  } else {
#line 100
    if (len > 32) {
#line 101
      fatal("auth_rsa_challenge_dialog: bad challenge length %d", len);
    }
  }
#line 102
  memset((void *)(buf___1), 0, 32U);
#line 103
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 104
  MD5_Init(& md);
#line 105
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 106
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 107
  MD5_Final(mdbuf, & md);
#line 108
  BN_clear_free(challenge);
#line 111
  tmp___1 = memcmp((void const   *)(response), (void const   *)(mdbuf), 16U);
#line 111
  if (tmp___1 != 0) {
#line 113
    return (0);
  }
#line 116
  return (1);
}
}
#line 172 "auth-rsa.c"
static char const   *check___1[3]  = {      "",      ".ssh",      (char const   *)((void *)0)};
#line 125 "auth-rsa.c"
int auth_rsa(struct passwd *pw , BIGNUM *client_n ) 
{ char line[8192] ;
  char file[1024] ;
  int authenticated ;
  unsigned int bits ;
  FILE *f ;
  unsigned long linenum ;
  struct stat st ;
  RSA *pk ;
  int tmp ;
  int fail ;
  char buf___1[1024] ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cp ;
  char *options___0 ;
  int quoted ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___26 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___43 ;
  int tmp___61 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t tmp___72 ;
  size_t tmp___78 ;
  int tmp___96 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___102 ;
  int tmp___105 ;
  int tmp___106 ;
  size_t tmp___107 ;
  size_t tmp___113 ;
  int tmp___131 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___137 ;
  int tmp___140 ;
  int tmp___141 ;
  size_t tmp___142 ;
  int i___0 ;
  size_t tmp___148 ;
  size_t tmp___149 ;
  void *tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  char *tmp___153 ;
  int tmp___171 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___177 ;
  int tmp___180 ;
  int tmp___181 ;
  size_t tmp___182 ;
  int i___1 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___188 ;
  size_t tmp___189 ;
  void *tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  char *tmp___193 ;
  void *tmp___194 ;
  int tmp___212 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___218 ;
  int tmp___221 ;
  int tmp___222 ;
  size_t tmp___223 ;
  char *patterns ;
  size_t tmp___229 ;
  void *tmp___230 ;
  int i___2 ;
  size_t tmp___231 ;
  int tmp___232 ;
  int tmp___233 ;
  char *tmp___234 ;
  char const   *tmp___235 ;
  char const   *tmp___236 ;
  char const   *tmp___237 ;
  struct envstring *ce ;
  size_t tmp___238 ;
  char const   *tmp___239 ;
  int tmp___240 ;
  size_t tmp___241 ;
  char const   *tmp___242 ;
  int tmp___243 ;
  int tmp___261 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___267 ;
  int tmp___270 ;
  int tmp___271 ;
  size_t tmp___272 ;
  char *tmp___278 ;

  {
#line 133
  linenum = 0UL;
#line 138
  temporarily_use_uid(pw->pw_uid);
#line 141
  snprintf((char * __restrict  )(file), sizeof(file), (char const   * __restrict  )"%.500s/%.100s",
           pw->pw_dir, ".ssh/authorized_keys");
#line 145
  tmp = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& st));
#line 145
  if (tmp < 0) {
#line 147
    restore_uid();
#line 148
    return (0);
  }
#line 151
  f = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"r");
#line 152
  if (! f) {
#line 154
    restore_uid();
#line 155
    packet_send_debug("Could not open %.900s for reading.", file);
#line 156
    packet_send_debug("If your home is on an NFS volume, it may need to be world-readable.");
#line 157
    return (0);
  }
#line 159
  if (options.strict_modes) {
#line 160
    fail = 0;
#line 163
    tmp___1 = fileno(f);
#line 163
    tmp___2 = fstat(tmp___1, & st);
#line 163
    if (tmp___2 < 0) {
#line 166
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
               pw->pw_name, file);
#line 168
      fail = 1;
    } else {
#line 163
      if (st.st_uid != 0U) {
#line 163
        if (st.st_uid != pw->pw_uid) {
#line 166
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 163
        if ((st.st_mode & 18U) != 0U) {
#line 166
          snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                   pw->pw_name, file);
#line 168
          fail = 1;
        } else {
#line 175
          i = 0;
#line 175
          while (check___1[i]) {
#line 176
            snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.500s/%.100s",
                     pw->pw_dir, check___1[i]);
#line 177
            tmp___0 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 177
            if (tmp___0 < 0) {
#line 180
              snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                       pw->pw_name, line);
#line 182
              fail = 1;
#line 183
              break;
            } else {
#line 177
              if (st.st_uid != 0U) {
#line 177
                if (st.st_uid != pw->pw_uid) {
#line 180
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                } else {
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 177
                if ((st.st_mode & 18U) != 0U) {
#line 180
                  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"RSA authentication refused for %.100s: bad ownership or modes for \'%s\'.",
                           pw->pw_name, line);
#line 182
                  fail = 1;
#line 183
                  break;
                }
              }
            }
#line 175
            i ++;
          }
        }
      }
    }
#line 187
    if (fail) {
#line 188
      fclose(f);
#line 189
      log((char const   *)(buf___1));
#line 190
      packet_send_debug((char const   *)(buf___1));
#line 191
      restore_uid();
#line 192
      return (0);
    }
  }
#line 196
  authenticated = 0;
#line 198
  pk = RSA_new();
#line 199
  pk->e = BN_new();
#line 200
  pk->n = BN_new();
#line 207
  while (1) {
#line 207
    tmp___278 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 207
    if (! tmp___278) {
#line 207
      break;
    }
#line 211
    linenum ++;
#line 214
    cp = line;
#line 214
    while (1) {
#line 214
      if (! ((int )*cp == 32)) {
#line 214
        if (! ((int )*cp == 9)) {
#line 214
          break;
        }
      }
#line 214
      cp ++;
    }
#line 216
    if (! *cp) {
#line 217
      continue;
    } else {
#line 216
      if ((int )*cp == 10) {
#line 217
        continue;
      } else {
#line 216
        if ((int )*cp == 35) {
#line 217
          continue;
        }
      }
    }
#line 225
    if ((int )*cp < 48) {
      goto _L___2;
    } else {
#line 225
      if ((int )*cp > 57) {
        _L___2: /* CIL Label */ 
#line 226
        quoted = 0;
#line 227
        options___0 = cp;
#line 228
        while (1) {
#line 228
          if (*cp) {
#line 228
            if (! quoted) {
#line 228
              if ((int )*cp != 32) {
#line 228
                if (! ((int )*cp != 9)) {
#line 228
                  break;
                }
              } else {
#line 228
                break;
              }
            }
          } else {
#line 228
            break;
          }
#line 229
          if ((int )*cp == 92) {
#line 229
            if ((int )*(cp + 1) == 34) {
#line 230
              cp ++;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 231
            if ((int )*cp == 34) {
#line 232
              quoted = ! quoted;
            }
          }
#line 228
          cp ++;
        }
      } else {
#line 235
        options___0 = (char *)((void *)0);
      }
    }
#line 238
    tmp___3 = auth_rsa_read_key(& cp, & bits, pk->e, pk->n);
#line 238
    if (! tmp___3) {
#line 239
      debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys", linenum);
#line 241
      packet_send_debug("%.100s, line %lu: bad key syntax", ".ssh/authorized_keys",
                        linenum);
#line 243
      continue;
    }
#line 248
    tmp___4 = BN_cmp((BIGNUM const   *)pk->n, (BIGNUM const   *)client_n);
#line 248
    if (tmp___4 != 0) {
#line 249
      continue;
    }
#line 252
    tmp___6 = BN_num_bits((BIGNUM const   *)pk->n);
#line 252
    if (bits != (unsigned int )tmp___6) {
#line 253
      tmp___5 = BN_num_bits((BIGNUM const   *)pk->n);
#line 253
      log("Warning: %s, line %ld: keysize mismatch: actual %d vs. announced %d.",
          file, linenum, tmp___5, bits);
    }
#line 260
    tmp___7 = auth_rsa_challenge_dialog(pk);
#line 260
    if (! tmp___7) {
#line 262
      verbose("Wrong response to RSA authentication challenge.");
#line 263
      packet_send_debug("Wrong response to RSA authentication challenge.");
#line 264
      continue;
    }
#line 272
    authenticated = 1;
#line 275
    if (options___0) {
#line 276
      while (1) {
#line 276
        if (*options___0) {
#line 276
          if ((int )*options___0 != 32) {
#line 276
            if (! ((int )*options___0 != 9)) {
#line 276
              break;
            }
          } else {
#line 276
            break;
          }
        } else {
#line 276
          break;
        }
#line 277
        cp = (char *)"no-port-forwarding";
#line 278
        if (0) {
#line 278
          if (0) {
#line 278
            __s1_len___0 = strlen((char const   *)options___0);
#line 278
            __s2_len___0 = strlen((char const   *)cp);
#line 278
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___6;
            } else {
#line 278
              if (__s1_len___0 >= 4U) {
                _L___6: /* CIL Label */ 
#line 278
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 278
                  tmp___36 = 1;
                } else {
#line 278
                  if (__s2_len___0 >= 4U) {
#line 278
                    tmp___36 = 1;
                  } else {
#line 278
                    tmp___36 = 0;
                  }
                }
              } else {
#line 278
                tmp___36 = 0;
              }
            }
#line 278
            if (tmp___36) {
#line 278
              tmp___32 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 278
              tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 278
              tmp___32 = tmp___35;
            }
          } else {
#line 278
            tmp___35 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 278
            tmp___32 = tmp___35;
          }
#line 278
          tmp___26 = tmp___32;
        } else {
#line 278
          tmp___37 = strlen((char const   *)cp);
#line 278
          tmp___26 = strncmp((char const   *)options___0, (char const   *)cp, tmp___37);
        }
#line 278
        if (tmp___26 == 0) {
#line 279
          packet_send_debug("Port forwarding disabled.");
#line 280
          no_port_forwarding_flag = 1;
#line 281
          tmp___8 = strlen((char const   *)cp);
#line 281
          options___0 += tmp___8;
          goto next_option;
        }
#line 284
        cp = (char *)"no-agent-forwarding";
#line 285
        if (0) {
#line 285
          if (0) {
#line 285
            __s1_len___2 = strlen((char const   *)options___0);
#line 285
            __s2_len___2 = strlen((char const   *)cp);
#line 285
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___10;
            } else {
#line 285
              if (__s1_len___2 >= 4U) {
                _L___10: /* CIL Label */ 
#line 285
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 285
                  tmp___71 = 1;
                } else {
#line 285
                  if (__s2_len___2 >= 4U) {
#line 285
                    tmp___71 = 1;
                  } else {
#line 285
                    tmp___71 = 0;
                  }
                }
              } else {
#line 285
                tmp___71 = 0;
              }
            }
#line 285
            if (tmp___71) {
#line 285
              tmp___67 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 285
              tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 285
              tmp___67 = tmp___70;
            }
          } else {
#line 285
            tmp___70 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 285
            tmp___67 = tmp___70;
          }
#line 285
          tmp___61 = tmp___67;
        } else {
#line 285
          tmp___72 = strlen((char const   *)cp);
#line 285
          tmp___61 = strncmp((char const   *)options___0, (char const   *)cp, tmp___72);
        }
#line 285
        if (tmp___61 == 0) {
#line 286
          packet_send_debug("Agent forwarding disabled.");
#line 287
          no_agent_forwarding_flag = 1;
#line 288
          tmp___43 = strlen((char const   *)cp);
#line 288
          options___0 += tmp___43;
          goto next_option;
        }
#line 291
        cp = (char *)"no-X11-forwarding";
#line 292
        if (0) {
#line 292
          if (0) {
#line 292
            __s1_len___4 = strlen((char const   *)options___0);
#line 292
            __s2_len___4 = strlen((char const   *)cp);
#line 292
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___14;
            } else {
#line 292
              if (__s1_len___4 >= 4U) {
                _L___14: /* CIL Label */ 
#line 292
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 292
                  tmp___106 = 1;
                } else {
#line 292
                  if (__s2_len___4 >= 4U) {
#line 292
                    tmp___106 = 1;
                  } else {
#line 292
                    tmp___106 = 0;
                  }
                }
              } else {
#line 292
                tmp___106 = 0;
              }
            }
#line 292
            if (tmp___106) {
#line 292
              tmp___102 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 292
              tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 292
              tmp___102 = tmp___105;
            }
          } else {
#line 292
            tmp___105 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 292
            tmp___102 = tmp___105;
          }
#line 292
          tmp___96 = tmp___102;
        } else {
#line 292
          tmp___107 = strlen((char const   *)cp);
#line 292
          tmp___96 = strncmp((char const   *)options___0, (char const   *)cp, tmp___107);
        }
#line 292
        if (tmp___96 == 0) {
#line 293
          packet_send_debug("X11 forwarding disabled.");
#line 294
          no_x11_forwarding_flag = 1;
#line 295
          tmp___78 = strlen((char const   *)cp);
#line 295
          options___0 += tmp___78;
          goto next_option;
        }
#line 298
        cp = (char *)"no-pty";
#line 299
        if (0) {
#line 299
          if (0) {
#line 299
            __s1_len___6 = strlen((char const   *)options___0);
#line 299
            __s2_len___6 = strlen((char const   *)cp);
#line 299
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___18;
            } else {
#line 299
              if (__s1_len___6 >= 4U) {
                _L___18: /* CIL Label */ 
#line 299
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 299
                  tmp___141 = 1;
                } else {
#line 299
                  if (__s2_len___6 >= 4U) {
#line 299
                    tmp___141 = 1;
                  } else {
#line 299
                    tmp___141 = 0;
                  }
                }
              } else {
#line 299
                tmp___141 = 0;
              }
            }
#line 299
            if (tmp___141) {
#line 299
              tmp___137 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 299
              tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 299
              tmp___137 = tmp___140;
            }
          } else {
#line 299
            tmp___140 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 299
            tmp___137 = tmp___140;
          }
#line 299
          tmp___131 = tmp___137;
        } else {
#line 299
          tmp___142 = strlen((char const   *)cp);
#line 299
          tmp___131 = strncmp((char const   *)options___0, (char const   *)cp, tmp___142);
        }
#line 299
        if (tmp___131 == 0) {
#line 300
          packet_send_debug("Pty allocation disabled.");
#line 301
          no_pty_flag = 1;
#line 302
          tmp___113 = strlen((char const   *)cp);
#line 302
          options___0 += tmp___113;
          goto next_option;
        }
#line 305
        cp = (char *)"command=\"";
#line 306
        if (0) {
#line 306
          if (0) {
#line 306
            __s1_len___8 = strlen((char const   *)options___0);
#line 306
            __s2_len___8 = strlen((char const   *)cp);
#line 306
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___22;
            } else {
#line 306
              if (__s1_len___8 >= 4U) {
                _L___22: /* CIL Label */ 
#line 306
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 306
                  tmp___181 = 1;
                } else {
#line 306
                  if (__s2_len___8 >= 4U) {
#line 306
                    tmp___181 = 1;
                  } else {
#line 306
                    tmp___181 = 0;
                  }
                }
              } else {
#line 306
                tmp___181 = 0;
              }
            }
#line 306
            if (tmp___181) {
#line 306
              tmp___177 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 306
              tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 306
              tmp___177 = tmp___180;
            }
          } else {
#line 306
            tmp___180 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 306
            tmp___177 = tmp___180;
          }
#line 306
          tmp___171 = tmp___177;
        } else {
#line 306
          tmp___182 = strlen((char const   *)cp);
#line 306
          tmp___171 = strncmp((char const   *)options___0, (char const   *)cp, tmp___182);
        }
#line 306
        if (tmp___171 == 0) {
#line 308
          tmp___148 = strlen((char const   *)cp);
#line 308
          options___0 += tmp___148;
#line 309
          tmp___149 = strlen((char const   *)options___0);
#line 309
          tmp___150 = xmalloc(tmp___149 + 1U);
#line 309
          forced_command = (char *)tmp___150;
#line 310
          i___0 = 0;
#line 311
          while (*options___0) {
#line 312
            if ((int )*options___0 == 34) {
#line 313
              break;
            }
#line 314
            if ((int )*options___0 == 92) {
#line 314
              if ((int )*(options___0 + 1) == 34) {
#line 315
                options___0 += 2;
#line 316
                tmp___151 = i___0;
#line 316
                i___0 ++;
#line 316
                *(forced_command + tmp___151) = (char )'\"';
#line 317
                continue;
              }
            }
#line 319
            tmp___152 = i___0;
#line 319
            i___0 ++;
#line 319
            tmp___153 = options___0;
#line 319
            options___0 ++;
#line 319
            *(forced_command + tmp___152) = *tmp___153;
          }
#line 321
          if (! *options___0) {
#line 322
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 324
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 326
            continue;
          }
#line 328
          *(forced_command + i___0) = (char)0;
#line 329
          packet_send_debug("Forced command: %.900s", forced_command);
#line 330
          options___0 ++;
          goto next_option;
        }
#line 333
        cp = (char *)"environment=\"";
#line 334
        if (0) {
#line 334
          if (0) {
#line 334
            __s1_len___10 = strlen((char const   *)options___0);
#line 334
            __s2_len___10 = strlen((char const   *)cp);
#line 334
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___26;
            } else {
#line 334
              if (__s1_len___10 >= 4U) {
                _L___26: /* CIL Label */ 
#line 334
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 334
                  tmp___222 = 1;
                } else {
#line 334
                  if (__s2_len___10 >= 4U) {
#line 334
                    tmp___222 = 1;
                  } else {
#line 334
                    tmp___222 = 0;
                  }
                }
              } else {
#line 334
                tmp___222 = 0;
              }
            }
#line 334
            if (tmp___222) {
#line 334
              tmp___218 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 334
              tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 334
              tmp___218 = tmp___221;
            }
          } else {
#line 334
            tmp___221 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 334
            tmp___218 = tmp___221;
          }
#line 334
          tmp___212 = tmp___218;
        } else {
#line 334
          tmp___223 = strlen((char const   *)cp);
#line 334
          tmp___212 = strncmp((char const   *)options___0, (char const   *)cp, tmp___223);
        }
#line 334
        if (tmp___212 == 0) {
#line 338
          tmp___188 = strlen((char const   *)cp);
#line 338
          options___0 += tmp___188;
#line 339
          tmp___189 = strlen((char const   *)options___0);
#line 339
          tmp___190 = xmalloc(tmp___189 + 1U);
#line 339
          s = (char *)tmp___190;
#line 340
          i___1 = 0;
#line 341
          while (*options___0) {
#line 342
            if ((int )*options___0 == 34) {
#line 343
              break;
            }
#line 344
            if ((int )*options___0 == 92) {
#line 344
              if ((int )*(options___0 + 1) == 34) {
#line 345
                options___0 += 2;
#line 346
                tmp___191 = i___1;
#line 346
                i___1 ++;
#line 346
                *(s + tmp___191) = (char )'\"';
#line 347
                continue;
              }
            }
#line 349
            tmp___192 = i___1;
#line 349
            i___1 ++;
#line 349
            tmp___193 = options___0;
#line 349
            options___0 ++;
#line 349
            *(s + tmp___192) = *tmp___193;
          }
#line 351
          if (! *options___0) {
#line 352
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 354
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 356
            continue;
          }
#line 358
          *(s + i___1) = (char)0;
#line 359
          packet_send_debug("Adding to environment: %.900s", s);
#line 360
          debug("Adding to environment: %.900s", s);
#line 361
          options___0 ++;
#line 362
          tmp___194 = xmalloc(sizeof(struct envstring ));
#line 362
          new_envstring = (struct envstring *)tmp___194;
#line 363
          new_envstring->s = s;
#line 364
          new_envstring->next = custom_environment;
#line 365
          custom_environment = new_envstring;
          goto next_option;
        }
#line 368
        cp = (char *)"from=\"";
#line 369
        if (0) {
#line 369
          if (0) {
#line 369
            __s1_len___12 = strlen((char const   *)options___0);
#line 369
            __s2_len___12 = strlen((char const   *)cp);
#line 369
            if (! ((unsigned int )((void const   *)(options___0 + 1)) - (unsigned int )((void const   *)options___0) == 1U)) {
              goto _L___30;
            } else {
#line 369
              if (__s1_len___12 >= 4U) {
                _L___30: /* CIL Label */ 
#line 369
                if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 369
                  tmp___271 = 1;
                } else {
#line 369
                  if (__s2_len___12 >= 4U) {
#line 369
                    tmp___271 = 1;
                  } else {
#line 369
                    tmp___271 = 0;
                  }
                }
              } else {
#line 369
                tmp___271 = 0;
              }
            }
#line 369
            if (tmp___271) {
#line 369
              tmp___267 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
            } else {
#line 369
              tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 369
              tmp___267 = tmp___270;
            }
          } else {
#line 369
            tmp___270 = __builtin_strcmp((char const   *)options___0, (char const   *)cp);
#line 369
            tmp___267 = tmp___270;
          }
#line 369
          tmp___261 = tmp___267;
        } else {
#line 369
          tmp___272 = strlen((char const   *)cp);
#line 369
          tmp___261 = strncmp((char const   *)options___0, (char const   *)cp, tmp___272);
        }
#line 369
        if (tmp___261 == 0) {
#line 370
          tmp___229 = strlen((char const   *)options___0);
#line 370
          tmp___230 = xmalloc(tmp___229 + 1U);
#line 370
          patterns = (char *)tmp___230;
#line 372
          tmp___231 = strlen((char const   *)cp);
#line 372
          options___0 += tmp___231;
#line 373
          i___2 = 0;
#line 374
          while (*options___0) {
#line 375
            if ((int )*options___0 == 34) {
#line 376
              break;
            }
#line 377
            if ((int )*options___0 == 92) {
#line 377
              if ((int )*(options___0 + 1) == 34) {
#line 378
                options___0 += 2;
#line 379
                tmp___232 = i___2;
#line 379
                i___2 ++;
#line 379
                *(patterns + tmp___232) = (char )'\"';
#line 380
                continue;
              }
            }
#line 382
            tmp___233 = i___2;
#line 382
            i___2 ++;
#line 382
            tmp___234 = options___0;
#line 382
            options___0 ++;
#line 382
            *(patterns + tmp___233) = *tmp___234;
          }
#line 384
          if (! *options___0) {
#line 385
            debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys", linenum);
#line 387
            packet_send_debug("%.100s, line %lu: missing end quote", ".ssh/authorized_keys",
                              linenum);
#line 389
            continue;
          }
#line 391
          *(patterns + i___2) = (char)0;
#line 392
          options___0 ++;
#line 393
          tmp___238 = strlen((char const   *)patterns);
#line 393
          tmp___239 = get_canonical_hostname();
#line 393
          tmp___240 = match_hostname(tmp___239, (char const   *)patterns, tmp___238);
#line 393
          if (! tmp___240) {
#line 393
            tmp___241 = strlen((char const   *)patterns);
#line 393
            tmp___242 = get_remote_ipaddr();
#line 393
            tmp___243 = match_hostname(tmp___242, (char const   *)patterns, tmp___241);
#line 393
            if (! tmp___243) {
#line 397
              tmp___235 = get_remote_ipaddr();
#line 397
              tmp___236 = get_canonical_hostname();
#line 397
              log("RSA authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
                  pw->pw_name, tmp___236, tmp___235);
#line 400
              tmp___237 = get_canonical_hostname();
#line 400
              packet_send_debug("Your host \'%.200s\' is not permitted to use this key for login.",
                                tmp___237);
#line 402
              xfree((void *)patterns);
#line 404
              authenticated = 0;
#line 405
              no_agent_forwarding_flag = 0;
#line 406
              no_port_forwarding_flag = 0;
#line 407
              no_pty_flag = 0;
#line 408
              no_x11_forwarding_flag = 0;
#line 409
              while (custom_environment) {
#line 410
                ce = custom_environment;
#line 411
                custom_environment = ce->next;
#line 412
                xfree((void *)ce->s);
#line 413
                xfree((void *)ce);
              }
#line 415
              if (forced_command) {
#line 416
                xfree((void *)forced_command);
#line 417
                forced_command = (char *)((void *)0);
              }
#line 419
              break;
            }
          }
#line 421
          xfree((void *)patterns);
          goto next_option;
        }
        bad_option: 
#line 426
        log("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
            linenum, options___0);
#line 428
        packet_send_debug("Bad options in %.100s file, line %lu: %.50s", ".ssh/authorized_keys",
                          linenum, options___0);
#line 430
        authenticated = 0;
#line 431
        break;
        next_option: 
#line 438
        if (! *options___0) {
#line 439
          fatal("Bugs in auth-rsa.c option processing.");
        }
#line 440
        if ((int )*options___0 == 32) {
#line 441
          break;
        } else {
#line 440
          if ((int )*options___0 == 9) {
#line 441
            break;
          }
        }
#line 442
        if ((int )*options___0 != 44) {
          goto bad_option;
        }
#line 444
        options___0 ++;
#line 446
        continue;
      }
    }
#line 453
    if (authenticated) {
#line 454
      break;
    }
  }
#line 458
  restore_uid();
#line 461
  fclose(f);
#line 463
  RSA_free(pk);
#line 465
  if (authenticated) {
#line 466
    packet_send_debug("RSA authentication accepted.");
  }
#line 469
  return (authenticated);
}
}
#line 1 "auth-rh-rsa.o"
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 36 "auth-rh-rsa.c"
int auth_rhosts_rsa(struct passwd *pw , char const   *client_user , RSA *client_host_key ) 
{ char const   *canonical_hostname ;
  HostStatus host_status ;
  Key *client_key ;
  Key *found ;
  int tmp ;
  struct stat st ;
  char *user_hostfile ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 44
  debug("Trying rhosts with RSA host authentication for %.100s", client_user);
#line 46
  if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 47
    return (0);
  }
#line 50
  tmp = auth_rhosts(pw, client_user);
#line 50
  if (! tmp) {
#line 51
    return (0);
  }
#line 53
  canonical_hostname = get_canonical_hostname();
#line 55
  debug("Rhosts RSA authentication: canonical host %.900s", canonical_hostname);
#line 58
  client_key = key_new(0);
#line 59
  BN_copy((client_key->rsa)->e, (BIGNUM const   *)client_host_key->e);
#line 60
  BN_copy((client_key->rsa)->n, (BIGNUM const   *)client_host_key->n);
#line 61
  found = key_new(0);
#line 64
  host_status = check_host_in_hostfile("/usr/local/etc/ssh_known_hosts", canonical_hostname,
                                       client_key, found);
#line 68
  if ((int )host_status != 0) {
#line 68
    if (! options.ignore_user_known_hosts) {
#line 70
      tmp___0 = tilde_expand_filename("~/.ssh/known_hosts", pw->pw_uid);
#line 70
      user_hostfile = tmp___0;
#line 75
      if (options.strict_modes) {
#line 75
        tmp___1 = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 75
        if (tmp___1 == 0) {
#line 75
          if (st.st_uid != 0U) {
#line 75
            if (st.st_uid != pw->pw_uid) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 75
            if ((st.st_mode & 18U) != 0U) {
#line 79
              log("Rhosts RSA authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            } else {
#line 83
              temporarily_use_uid(pw->pw_uid);
#line 84
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   canonical_hostname, client_key,
                                                   found);
#line 86
              restore_uid();
            }
          }
        } else {
#line 83
          temporarily_use_uid(pw->pw_uid);
#line 84
          host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                               client_key, found);
#line 86
          restore_uid();
        }
      } else {
#line 83
        temporarily_use_uid(pw->pw_uid);
#line 84
        host_status = check_host_in_hostfile((char const   *)user_hostfile, canonical_hostname,
                                             client_key, found);
#line 86
        restore_uid();
      }
#line 88
      xfree((void *)user_hostfile);
    }
  }
#line 90
  key_free(client_key);
#line 91
  key_free(found);
#line 93
  if ((int )host_status != 0) {
#line 94
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 95
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 96
    return (0);
  }
#line 101
  tmp___2 = auth_rsa_challenge_dialog(client_host_key);
#line 101
  if (! tmp___2) {
#line 102
    log("Client on %.800s failed to respond correctly to host authentication.", canonical_hostname);
#line 104
    return (0);
  }
#line 111
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, client_user, canonical_hostname);
#line 113
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 114
  return (1);
}
}
#line 1 "pty.o"
#line 280 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 27 "pty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 33
void pty_release(char const   *ttyname___0 ) ;
#line 39
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) ;
#line 42
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 46
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) ;
#line 57 "pty.c"
extern int ( /* missing proto */  openpty)() ;
#line 49 "pty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ char buf___1[64] ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 57
  i = openpty(ptyfd, ttyfd, buf___1, (void *)0, (void *)0);
#line 58
  if (i < 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("openpty: %.100s", tmp___0);
#line 60
    return (0);
  }
#line 62
  strlcpy(namebuf, (char const   *)(buf___1), (unsigned int )namebuflen);
#line 63
  return (1);
}
}
#line 189 "pty.c"
void pty_release(char const   *ttyname___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 192
  tmp___1 = chown(ttyname___0, 0U, 0U);
#line 192
  if (tmp___1 < 0) {
#line 193
    tmp = __errno_location();
#line 193
    tmp___0 = strerror(*tmp);
#line 193
    error("chown %.100s 0 0 failed: %.100s", ttyname___0, tmp___0);
  }
#line 194
  tmp___4 = chmod(ttyname___0, 438U);
#line 194
  if (tmp___4 < 0) {
#line 195
    tmp___2 = __errno_location();
#line 195
    tmp___3 = strerror(*tmp___2);
#line 195
    error("chmod %.100s 0666 failed: %.100s", ttyname___0, tmp___3);
  }
#line 196
  return;
}
}
#line 200 "pty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *ttyname___0 ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  __sighandler_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 210
  fd = open("/dev/tty", 258);
#line 211
  if (fd >= 0) {
#line 212
    ioctl(fd, 21538UL, (void *)0);
#line 213
    close(fd);
  }
#line 216
  tmp___1 = setsid();
#line 216
  if (tmp___1 < 0) {
#line 217
    tmp = __errno_location();
#line 217
    tmp___0 = strerror(*tmp);
#line 217
    error("setsid: %.100s", tmp___0);
  }
#line 223
  fd = open("/dev/tty", 258);
#line 224
  if (fd >= 0) {
#line 225
    error("Failed to disconnect from controlling tty.");
#line 226
    close(fd);
  }
#line 230
  debug("Setting controlling tty using TIOCSCTTY.");
#line 236
  ioctl(*ttyfd, 21518UL, (void *)0);
#line 239
  tmp___2 = signal(1, (void (*)(int  ))1);
#line 239
  old = (void *)tmp___2;
#line 240
  vhangup();
#line 241
  signal(1, (void (*)(int  ))old);
#line 243
  fd = open(ttyname___0, 2);
#line 244
  if (fd < 0) {
#line 245
    tmp___3 = __errno_location();
#line 245
    tmp___4 = strerror(*tmp___3);
#line 245
    error("%.100s: %.100s", ttyname___0, tmp___4);
  } else {
#line 248
    close(*ttyfd);
#line 249
    *ttyfd = fd;
  }
#line 255
  fd = open("/dev/tty", 1);
#line 256
  if (fd < 0) {
#line 257
    tmp___5 = __errno_location();
#line 257
    tmp___6 = strerror(*tmp___5);
#line 257
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___6);
  } else {
#line 260
    close(fd);
  }
#line 262
  return;
}
}
#line 266 "pty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ struct winsize w ;

  {
#line 271
  w.ws_row = (unsigned short )row;
#line 272
  w.ws_col = (unsigned short )col;
#line 273
  w.ws_xpixel = (unsigned short )xpixel;
#line 274
  w.ws_ypixel = (unsigned short )ypixel;
#line 275
  ioctl(ptyfd, 21524UL, & w);
#line 276
  return;
}
}
#line 278 "pty.c"
void pty_setowner(struct passwd *pw , char const   *ttyname___0 ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 286
  grp = getgrnam("tty");
#line 287
  if (grp) {
#line 288
    gid = grp->gr_gid;
#line 289
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 291
    gid = pw->pw_gid;
#line 292
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 296
  tmp___1 = chown(ttyname___0, pw->pw_uid, gid);
#line 296
  if (tmp___1 < 0) {
#line 297
    tmp = __errno_location();
#line 297
    tmp___0 = strerror(*tmp);
#line 297
    fatal("chown(%.100s, %d, %d) failed: %.100s", ttyname___0, pw->pw_uid, gid, tmp___0);
  }
#line 299
  tmp___4 = chmod(ttyname___0, mode);
#line 299
  if (tmp___4 < 0) {
#line 300
    tmp___2 = __errno_location();
#line 300
    tmp___3 = strerror(*tmp___2);
#line 300
    fatal("chmod(%.100s, 0%o) failed: %.100s", ttyname___0, mode, tmp___3);
  }
#line 302
  return;
}
}
#line 1 "log-server.o"
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "log-server.c"
extern char *__progname ;
#line 31 "log-server.c"
static LogLevel log_level  =    3;
#line 32 "log-server.c"
static int log_on_stderr  =    0;
#line 33 "log-server.c"
static int log_facility  =    4 << 3;
#line 41 "log-server.c"
void log_init(char *av0___0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ 

  {
#line 44
  switch ((int )level) {
  case 0: 
  case 2: 
  case 1: 
  case 3: 
  case 4: 
  case 5: 
#line 51
  log_level = level;
#line 52
  break;
  default: 
#line 54
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 56
  exit(1);
  }
#line 58
  switch ((int )facility) {
  case 0: 
#line 60
  log_facility = 3 << 3;
#line 61
  break;
  case 1: 
#line 63
  log_facility = 1 << 3;
#line 64
  break;
  case 2: 
#line 66
  log_facility = 4 << 3;
#line 67
  break;
  case 3: 
#line 69
  log_facility = 16 << 3;
#line 70
  break;
  case 4: 
#line 72
  log_facility = 17 << 3;
#line 73
  break;
  case 5: 
#line 75
  log_facility = 18 << 3;
#line 76
  break;
  case 6: 
#line 78
  log_facility = 19 << 3;
#line 79
  break;
  case 7: 
#line 81
  log_facility = 20 << 3;
#line 82
  break;
  case 8: 
#line 84
  log_facility = 21 << 3;
#line 85
  break;
  case 9: 
#line 87
  log_facility = 22 << 3;
#line 88
  break;
  case 10: 
#line 90
  log_facility = 23 << 3;
#line 91
  break;
  default: 
#line 93
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 95
  exit(1);
  }
#line 97
  log_on_stderr = on_stderr;
#line 98
  return;
}
}
#line 102 "log-server.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;

  {
#line 107
  txt = (char *)((void *)0);
#line 108
  pri = 6;
#line 110
  if ((int )level > (int )log_level) {
#line 111
    return;
  }
#line 112
  switch ((int )level) {
  case 2: 
#line 114
  txt = (char *)"error";
#line 115
  pri = 3;
#line 116
  break;
  case 1: 
#line 118
  txt = (char *)"fatal";
#line 119
  pri = 3;
#line 120
  break;
  case 3: 
  case 4: 
#line 123
  pri = 6;
#line 124
  break;
  case 5: 
#line 126
  txt = (char *)"debug";
#line 127
  pri = 7;
#line 128
  break;
  default: 
#line 130
  txt = (char *)"internal error";
#line 131
  pri = 3;
#line 132
  break;
  }
#line 134
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 135
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 136
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 138
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 140
  if (log_on_stderr) {
#line 141
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msgbuf);
  } else {
#line 143
    openlog((char const   *)__progname, 1, log_facility);
#line 144
    syslog(pri, "%.500s", msgbuf);
#line 145
    closelog();
  }
#line 147
  return;
}
}
#line 1 "login.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 300 "ssh.h"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 ,
                                  unsigned int bufsize ) ;
#line 308
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) ;
#line 316
void record_logout(pid_t pid , char const   *ttyname___0 ) ;
#line 52 "login.c"
unsigned long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 ,
                                  unsigned int bufsize ) 
{ struct lastlog ll ;
  char *lastlog ;
  int fd ;
  ssize_t tmp ;

  {
#line 64
  lastlog = (char *)"/var/log/lastlog";
#line 65
  *(buf___1 + 0) = (char )'\000';
#line 68
  fd = open((char const   *)lastlog, 0);
#line 69
  if (fd < 0) {
#line 70
    return (0UL);
  }
#line 71
  lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)), 0);
#line 78
  tmp = read(fd, (void *)(& ll), sizeof(ll));
#line 78
  if ((unsigned int )tmp != sizeof(ll)) {
#line 79
    close(fd);
#line 80
    return (0UL);
  }
#line 82
  close(fd);
#line 83
  if (bufsize > sizeof(ll.ll_host) + 1U) {
#line 84
    bufsize = sizeof(ll.ll_host) + 1U;
  }
#line 85
  __builtin_strncpy(buf___1, (char const   *)(ll.ll_host), bufsize - 1U);
#line 86
  *(buf___1 + (bufsize - 1U)) = (char)0;
#line 87
  return ((unsigned long )ll.ll_time);
}
}
#line 138 "login.c"
void record_login(pid_t pid , char const   *ttyname___0 , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr ) 
{ struct lastlog ll ;
  char *lastlog ;
  struct utmp u ;
  struct sockaddr_in *in ;
  struct sockaddr_in6 *in6 ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 155
  memset((void *)(& u), 0, sizeof(u));
#line 156
  __builtin_strncpy(u.ut_line, ttyname___0 + 5, sizeof(u.ut_line));
#line 161
  __builtin_strncpy(u.ut_id, ttyname___0 + 8, sizeof(u.ut_id));
#line 164
  __builtin_strncpy(u.ut_user, user, sizeof(u.ut_user));
#line 166
  gettimeofday((struct timeval * __restrict  )(& u.ut_tv), (struct timezone * __restrict  )((void *)0));
#line 171
  u.ut_pid = pid;
#line 174
  if (uid == 4294967295U) {
#line 174
    u.ut_type = (short)8;
  } else {
#line 174
    u.ut_type = (short)7;
  }
#line 177
  __builtin_strncpy(u.ut_host, host, sizeof(u.ut_host));
#line 180
  if (addr) {
#line 181
    switch ((int )addr->sa_family) {
    case 2: 
#line 183
    in = (struct sockaddr_in *)addr;
#line 184
    memcpy((void * __restrict  )(& u.ut_addr_v6[0]), (void const   * __restrict  )(& in->sin_addr),
           sizeof(& in->sin_addr));
#line 185
    break;
    case 10: 
#line 189
    in6 = (struct sockaddr_in6 *)addr;
#line 190
    memcpy((void * __restrict  )(u.ut_addr_v6), (void const   * __restrict  )(& in6->sin6_addr),
           sizeof(& in6->sin6_addr));
#line 191
    break;
    default: ;
#line 195
    break;
    }
  }
#line 242
  login((struct utmp  const  *)(& u));
#line 246
  lastlog = (char *)"/var/log/lastlog";
#line 249
  if (0) {
#line 249
    __s1_len = strlen(user);
#line 249
    __s2_len = strlen("");
#line 249
    if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
      goto _L___0;
    } else {
#line 249
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 249
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 249
          tmp___11 = 1;
        } else {
#line 249
          if (__s2_len >= 4U) {
#line 249
            tmp___11 = 1;
          } else {
#line 249
            tmp___11 = 0;
          }
        }
      } else {
#line 249
        tmp___11 = 0;
      }
    }
#line 249
    if (tmp___11) {
#line 249
      tmp___7 = __builtin_strcmp(user, "");
    } else {
#line 249
      tmp___10 = __builtin_strcmp(user, "");
#line 249
      tmp___7 = tmp___10;
    }
  } else {
#line 249
    tmp___10 = __builtin_strcmp(user, "");
#line 249
    tmp___7 = tmp___10;
  }
#line 249
  if (tmp___7 != 0) {
#line 255
    memset((void *)(& ll), 0, sizeof(ll));
#line 258
    ll.ll_time = time((time_t *)((void *)0));
#line 259
    __builtin_strncpy(ll.ll_line, ttyname___0 + 5, sizeof(ll.ll_line));
#line 260
    __builtin_strncpy(ll.ll_host, host, sizeof(ll.ll_host));
#line 266
    fd = open((char const   *)lastlog, 2);
#line 267
    if (fd >= 0) {
#line 268
      lseek(fd, (long )((unsigned long )((long )uid) * (unsigned long )sizeof(ll)),
            0);
#line 270
      tmp___1 = write(fd, (void const   *)(& ll), sizeof(ll));
#line 270
      if ((unsigned int )tmp___1 != sizeof(ll)) {
#line 271
        tmp = __errno_location();
#line 271
        tmp___0 = strerror(*tmp);
#line 271
        log("Could not write %.100s: %.100s", lastlog, tmp___0);
      }
#line 272
      close(fd);
    }
  }
#line 276
  return;
}
}
#line 280 "login.c"
void record_logout(pid_t pid , char const   *ttyname___0 ) 
{ char const   *line ;
  int tmp ;

  {
#line 284
  line = ttyname___0 + 5;
#line 285
  tmp = logout(line);
#line 285
  if (tmp) {
#line 286
    logwtmp(line, "", "");
  }
#line 290
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "servconf.o"
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 23 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) ;
#line 27 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 30
  memset((void *)options___0, 0, sizeof(*options___0));
#line 31
  options___0->num_ports = 0U;
#line 32
  options___0->ports_from_cmdline = 0U;
#line 33
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 34
  options___0->host_key_file = (char *)((void *)0);
#line 35
  options___0->host_dsa_key_file = (char *)((void *)0);
#line 36
  options___0->pid_file = (char *)((void *)0);
#line 37
  options___0->server_key_bits = -1;
#line 38
  options___0->login_grace_time = -1;
#line 39
  options___0->key_regeneration_time = -1;
#line 40
  options___0->permit_root_login = -1;
#line 41
  options___0->ignore_rhosts = -1;
#line 42
  options___0->ignore_user_known_hosts = -1;
#line 43
  options___0->print_motd = -1;
#line 44
  options___0->check_mail = -1;
#line 45
  options___0->x11_forwarding = -1;
#line 46
  options___0->x11_display_offset = -1;
#line 47
  options___0->strict_modes = -1;
#line 48
  options___0->keepalives = -1;
#line 49
  options___0->log_facility = (enum __anonenum_SyslogFacility_72 )-1;
#line 50
  options___0->log_level = (enum __anonenum_LogLevel_73 )-1;
#line 51
  options___0->rhosts_authentication = -1;
#line 52
  options___0->rhosts_rsa_authentication = -1;
#line 53
  options___0->rsa_authentication = -1;
#line 54
  options___0->dsa_authentication = -1;
#line 64
  options___0->password_authentication = -1;
#line 68
  options___0->permit_empty_passwd = -1;
#line 69
  options___0->use_login = -1;
#line 70
  options___0->num_allow_users = 0U;
#line 71
  options___0->num_deny_users = 0U;
#line 72
  options___0->num_allow_groups = 0U;
#line 73
  options___0->num_deny_groups = 0U;
#line 74
  options___0->ciphers = (char *)((void *)0);
#line 75
  options___0->protocol = 0;
#line 76
  options___0->gateway_ports = -1;
#line 77
  return;
}
}
#line 79 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ unsigned int tmp ;

  {
#line 82
  if (options___0->num_ports == 0U) {
#line 83
    tmp = options___0->num_ports;
#line 83
    (options___0->num_ports) ++;
#line 83
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 84
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 85
    add_listen_addr(options___0, (char *)((void *)0));
  }
#line 86
  if ((unsigned int )options___0->host_key_file == (unsigned int )((void *)0)) {
#line 87
    options___0->host_key_file = (char *)"/usr/local/etc/ssh_host_key";
  }
#line 88
  if ((unsigned int )options___0->host_dsa_key_file == (unsigned int )((void *)0)) {
#line 89
    options___0->host_dsa_key_file = (char *)"/usr/local/etc/ssh_host_dsa_key";
  }
#line 90
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 91
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 92
  if (options___0->server_key_bits == -1) {
#line 93
    options___0->server_key_bits = 768;
  }
#line 94
  if (options___0->login_grace_time == -1) {
#line 95
    options___0->login_grace_time = 600;
  }
#line 96
  if (options___0->key_regeneration_time == -1) {
#line 97
    options___0->key_regeneration_time = 3600;
  }
#line 98
  if (options___0->permit_root_login == -1) {
#line 99
    options___0->permit_root_login = 1;
  }
#line 100
  if (options___0->ignore_rhosts == -1) {
#line 101
    options___0->ignore_rhosts = 1;
  }
#line 102
  if (options___0->ignore_user_known_hosts == -1) {
#line 103
    options___0->ignore_user_known_hosts = 0;
  }
#line 104
  if (options___0->check_mail == -1) {
#line 105
    options___0->check_mail = 0;
  }
#line 106
  if (options___0->print_motd == -1) {
#line 107
    options___0->print_motd = 1;
  }
#line 108
  if (options___0->x11_forwarding == -1) {
#line 109
    options___0->x11_forwarding = 0;
  }
#line 110
  if (options___0->x11_display_offset == -1) {
#line 111
    options___0->x11_display_offset = 10;
  }
#line 112
  if (options___0->strict_modes == -1) {
#line 113
    options___0->strict_modes = 1;
  }
#line 114
  if (options___0->keepalives == -1) {
#line 115
    options___0->keepalives = 1;
  }
#line 116
  if ((int )options___0->log_facility == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 117
    options___0->log_facility = 2;
  }
#line 118
  if ((int )options___0->log_level == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 119
    options___0->log_level = 3;
  }
#line 120
  if (options___0->rhosts_authentication == -1) {
#line 121
    options___0->rhosts_authentication = 0;
  }
#line 122
  if (options___0->rhosts_rsa_authentication == -1) {
#line 123
    options___0->rhosts_rsa_authentication = 0;
  }
#line 124
  if (options___0->rsa_authentication == -1) {
#line 125
    options___0->rsa_authentication = 1;
  }
#line 126
  if (options___0->dsa_authentication == -1) {
#line 127
    options___0->dsa_authentication = 1;
  }
#line 142
  if (options___0->password_authentication == -1) {
#line 143
    options___0->password_authentication = 1;
  }
#line 148
  if (options___0->permit_empty_passwd == -1) {
#line 149
    options___0->permit_empty_passwd = 0;
  }
#line 150
  if (options___0->use_login == -1) {
#line 151
    options___0->use_login = 0;
  }
#line 152
  if (options___0->protocol == 0) {
#line 153
    options___0->protocol = 5;
  }
#line 154
  if (options___0->gateway_ports == -1) {
#line 155
    options___0->gateway_ports = 0;
  }
#line 156
  return;
}
}
#line 184 "servconf.c"
static struct __anonstruct_keywords_76 keywords[35]  = 
#line 184
  {      {"port", 1}, 
        {"hostkey", 2}, 
        {"hostdsakey", 29}, 
        {"pidfile", 32}, 
        {"serverkeybits", 3}, 
        {"logingracetime", 4}, 
        {"keyregenerationinterval", 5}, 
        {"permitrootlogin", 6}, 
        {"syslogfacility", 7}, 
        {"loglevel", 8}, 
        {"rhostsauthentication", 9}, 
        {"rhostsrsaauthentication", 10}, 
        {"rsaauthentication", 11}, 
        {"dsaauthentication", 34}, 
        {"passwordauthentication", 12}, 
        {"checkmail", 22}, 
        {"listenaddress", 13}, 
        {"printmotd", 14}, 
        {"ignorerhosts", 15}, 
        {"ignoreuserknownhosts", 28}, 
        {"x11forwarding", 16}, 
        {"x11displayoffset", 17}, 
        {"strictmodes", 18}, 
        {"permitemptypasswords", 19}, 
        {"uselogin", 23}, 
        {"randomseed", 20}, 
        {"keepalive", 21}, 
        {"allowusers", 24}, 
        {"denyusers", 25}, 
        {"allowgroups", 26}, 
        {"denygroups", 27}, 
        {"ciphers", 30}, 
        {"protocol", 31}, 
        {"gatewayports", 33}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 242 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ unsigned int i ;
  int tmp ;

  {
#line 248
  i = 0U;
#line 248
  while (keywords[i].name) {
#line 249
    tmp = strcasecmp(cp, keywords[i].name);
#line 249
    if (tmp == 0) {
#line 250
      return (keywords[i].opcode);
    }
#line 248
    i ++;
  }
#line 252
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: line %d: Bad configuration option: %s\n",
          filename, linenum, cp);
#line 254
  return (0);
}
}
#line 260 "servconf.c"
void add_listen_addr(ServerOptions *options___0 , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int i ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 269
  if (options___0->num_ports == 0U) {
#line 270
    tmp = options___0->num_ports;
#line 270
    (options___0->num_ports) ++;
#line 270
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 271
  i = 0;
#line 271
  while ((unsigned int )i < options___0->num_ports) {
#line 272
    memset((void *)(& hints), 0, sizeof(hints));
#line 273
    hints.ai_family = IPv4or6;
#line 274
    hints.ai_socktype = 1;
#line 275
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 275
      hints.ai_flags = 1;
    } else {
#line 275
      hints.ai_flags = 0;
    }
#line 276
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             options___0->ports[i]);
#line 277
    gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 277
    if (gaierr != 0) {
#line 278
      tmp___0 = gai_strerror(gaierr);
#line 278
      if (addr) {
#line 278
        tmp___1 = (char const   *)addr;
      } else {
#line 278
        tmp___1 = "<NULL>";
      }
#line 278
      fatal("bad addr or host: %s (%s)\n", tmp___1, tmp___0);
    }
#line 281
    ai = aitop;
#line 281
    while (ai->ai_next) {
#line 281
      ai = ai->ai_next;
    }
#line 283
    ai->ai_next = options___0->listen_addrs;
#line 284
    options___0->listen_addrs = aitop;
#line 271
    i ++;
  }
#line 286
  return;
}
}
#line 290 "servconf.c"
void read_server_config(ServerOptions *options___0 , char const   *filename ) 
{ FILE *f ;
  char line[1024] ;
  char *cp ;
  char **charptr ;
  int linenum ;
  int *intptr ;
  int value ;
  int bad_options ;
  ServerOpCodes opcode ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  __uid_t tmp___33 ;
  __uid_t tmp___34 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___40 ;
  int tmp___43 ;
  int tmp___44 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___50 ;
  int tmp___53 ;
  int tmp___54 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___60 ;
  int tmp___63 ;
  int tmp___64 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___70 ;
  int tmp___73 ;
  int tmp___74 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___80 ;
  int tmp___83 ;
  int tmp___84 ;
  SyslogFacility tmp___85 ;
  char const   *tmp___86 ;
  LogLevel tmp___87 ;
  char const   *tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  char const   *tmp___93 ;
  int tmp___94 ;
  char const   *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;

  {
#line 297
  bad_options = 0;
#line 300
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 301
  if (! f) {
#line 302
    perror(filename);
#line 303
    exit(1);
  }
#line 305
  linenum = 0;
#line 306
  while (1) {
#line 306
    tmp___97 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 306
    if (! tmp___97) {
#line 306
      break;
    }
#line 307
    linenum ++;
#line 308
    tmp___30 = __builtin_strspn((char const   *)(line), " \t\r\n");
#line 308
    cp = line + tmp___30;
#line 309
    if (! *cp) {
#line 310
      continue;
    } else {
#line 309
      if ((int )*cp == 35) {
#line 310
        continue;
      }
    }
#line 311
    cp = strtok((char * __restrict  )cp, (char const   * __restrict  )" \t\r\n");
#line 312
    opcode = parse_token((char const   *)cp, filename, linenum);
#line 313
    switch ((int )opcode) {
    case 0: 
#line 315
    bad_options ++;
#line 316
    continue;
    case 1: 
#line 319
    if (options___0->ports_from_cmdline) {
#line 320
      continue;
    }
#line 321
    if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 322
      fatal("%s line %d: ports must be specified before ListenAdress.\n", filename,
            linenum);
    }
#line 324
    if (options___0->num_ports >= 256U) {
#line 325
      fatal("%s line %d: too many ports.\n", filename, linenum);
    }
#line 327
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 328
    if (! cp) {
#line 329
      fatal("%s line %d: missing port number.\n", filename, linenum);
    }
#line 331
    tmp___31 = options___0->num_ports;
#line 331
    (options___0->num_ports) ++;
#line 331
    tmp___32 = atoi((char const   *)cp);
#line 331
    options___0->ports[tmp___31] = (unsigned short )tmp___32;
#line 332
    break;
    case 3: 
#line 335
    intptr = & options___0->server_key_bits;
    parse_int: 
#line 337
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 338
    if (! cp) {
#line 339
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing integer value.\n",
              filename, linenum);
#line 341
      exit(1);
    }
#line 343
    value = atoi((char const   *)cp);
#line 344
    if (*intptr == -1) {
#line 345
      *intptr = value;
    }
#line 346
    break;
    case 4: 
#line 349
    intptr = & options___0->login_grace_time;
    goto parse_int;
    case 5: 
#line 353
    intptr = & options___0->key_regeneration_time;
    goto parse_int;
    case 13: 
#line 357
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 358
    if (! cp) {
#line 359
      fatal("%s line %d: missing inet addr.\n", filename, linenum);
    }
#line 361
    add_listen_addr(options___0, cp);
#line 362
    break;
    case 2: 
    case 29: 
#line 366
    if ((int )opcode == 2) {
#line 366
      charptr = & options___0->host_key_file;
    } else {
#line 366
      charptr = & options___0->host_dsa_key_file;
    }
#line 368
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 369
    if (! cp) {
#line 370
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 372
      exit(1);
    }
#line 374
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 375
      tmp___33 = getuid();
#line 375
      *charptr = tilde_expand_filename((char const   *)cp, tmp___33);
    }
#line 376
    break;
    case 32: 
#line 379
    charptr = & options___0->pid_file;
#line 380
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 381
    if (! cp) {
#line 382
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing file name.\n",
              filename, linenum);
#line 384
      exit(1);
    }
#line 386
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 387
      tmp___34 = getuid();
#line 387
      *charptr = tilde_expand_filename((char const   *)cp, tmp___34);
    }
#line 388
    break;
    case 20: 
#line 391
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: \"randomseed\" option is obsolete.\n",
            filename, linenum);
#line 393
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 394
    break;
    case 6: 
#line 397
    intptr = & options___0->permit_root_login;
#line 398
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 399
    if (! cp) {
#line 400
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/without-password/no argument.\n",
              filename, linenum);
#line 402
      exit(1);
    }
#line 404
    if (0) {
#line 404
      __s1_len___1 = strlen((char const   *)cp);
#line 404
      __s2_len___1 = strlen("without-password");
#line 404
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___4;
      } else {
#line 404
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 404
          if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 404
            tmp___64 = 1;
          } else {
#line 404
            if (__s2_len___1 >= 4U) {
#line 404
              tmp___64 = 1;
            } else {
#line 404
              tmp___64 = 0;
            }
          }
        } else {
#line 404
          tmp___64 = 0;
        }
      }
#line 404
      if (tmp___64) {
#line 404
        tmp___60 = __builtin_strcmp((char const   *)cp, "without-password");
      } else {
#line 404
        tmp___63 = __builtin_strcmp((char const   *)cp, "without-password");
#line 404
        tmp___60 = tmp___63;
      }
    } else {
#line 404
      tmp___63 = __builtin_strcmp((char const   *)cp, "without-password");
#line 404
      tmp___60 = tmp___63;
    }
#line 404
    if (tmp___60 == 0) {
#line 405
      value = 2;
    } else {
#line 406
      if (0) {
#line 406
        __s1_len___0 = strlen((char const   *)cp);
#line 406
        __s2_len___0 = strlen("yes");
#line 406
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 406
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 406
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 406
              tmp___54 = 1;
            } else {
#line 406
              if (__s2_len___0 >= 4U) {
#line 406
                tmp___54 = 1;
              } else {
#line 406
                tmp___54 = 0;
              }
            }
          } else {
#line 406
            tmp___54 = 0;
          }
        }
#line 406
        if (tmp___54) {
#line 406
          tmp___50 = __builtin_strcmp((char const   *)cp, "yes");
        } else {
#line 406
          tmp___53 = __builtin_strcmp((char const   *)cp, "yes");
#line 406
          tmp___50 = tmp___53;
        }
      } else {
#line 406
        tmp___53 = __builtin_strcmp((char const   *)cp, "yes");
#line 406
        tmp___50 = tmp___53;
      }
#line 406
      if (tmp___50 == 0) {
#line 407
        value = 1;
      } else {
#line 408
        if (0) {
#line 408
          __s1_len = strlen((char const   *)cp);
#line 408
          __s2_len = strlen("no");
#line 408
          if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
            goto _L___0;
          } else {
#line 408
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 408
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 408
                tmp___44 = 1;
              } else {
#line 408
                if (__s2_len >= 4U) {
#line 408
                  tmp___44 = 1;
                } else {
#line 408
                  tmp___44 = 0;
                }
              }
            } else {
#line 408
              tmp___44 = 0;
            }
          }
#line 408
          if (tmp___44) {
#line 408
            tmp___40 = __builtin_strcmp((char const   *)cp, "no");
          } else {
#line 408
            tmp___43 = __builtin_strcmp((char const   *)cp, "no");
#line 408
            tmp___40 = tmp___43;
          }
        } else {
#line 408
          tmp___43 = __builtin_strcmp((char const   *)cp, "no");
#line 408
          tmp___40 = tmp___43;
        }
#line 408
        if (tmp___40 == 0) {
#line 409
          value = 0;
        } else {
#line 411
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/without-password/no argument: %s\n",
                  filename, linenum, cp);
#line 413
          exit(1);
        }
      }
    }
#line 415
    if (*intptr == -1) {
#line 416
      *intptr = value;
    }
#line 417
    break;
    case 15: 
#line 420
    intptr = & options___0->ignore_rhosts;
    parse_flag: 
#line 422
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 423
    if (! cp) {
#line 424
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: missing yes/no argument.\n",
              filename, linenum);
#line 426
      exit(1);
    }
#line 428
    if (0) {
#line 428
      __s1_len___3 = strlen((char const   *)cp);
#line 428
      __s2_len___3 = strlen("yes");
#line 428
      if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
        goto _L___8;
      } else {
#line 428
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 428
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 428
            tmp___84 = 1;
          } else {
#line 428
            if (__s2_len___3 >= 4U) {
#line 428
              tmp___84 = 1;
            } else {
#line 428
              tmp___84 = 0;
            }
          }
        } else {
#line 428
          tmp___84 = 0;
        }
      }
#line 428
      if (tmp___84) {
#line 428
        tmp___80 = __builtin_strcmp((char const   *)cp, "yes");
      } else {
#line 428
        tmp___83 = __builtin_strcmp((char const   *)cp, "yes");
#line 428
        tmp___80 = tmp___83;
      }
    } else {
#line 428
      tmp___83 = __builtin_strcmp((char const   *)cp, "yes");
#line 428
      tmp___80 = tmp___83;
    }
#line 428
    if (tmp___80 == 0) {
#line 429
      value = 1;
    } else {
#line 430
      if (0) {
#line 430
        __s1_len___2 = strlen((char const   *)cp);
#line 430
        __s2_len___2 = strlen("no");
#line 430
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___6;
        } else {
#line 430
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 430
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 430
              tmp___74 = 1;
            } else {
#line 430
              if (__s2_len___2 >= 4U) {
#line 430
                tmp___74 = 1;
              } else {
#line 430
                tmp___74 = 0;
              }
            }
          } else {
#line 430
            tmp___74 = 0;
          }
        }
#line 430
        if (tmp___74) {
#line 430
          tmp___70 = __builtin_strcmp((char const   *)cp, "no");
        } else {
#line 430
          tmp___73 = __builtin_strcmp((char const   *)cp, "no");
#line 430
          tmp___70 = tmp___73;
        }
      } else {
#line 430
        tmp___73 = __builtin_strcmp((char const   *)cp, "no");
#line 430
        tmp___70 = tmp___73;
      }
#line 430
      if (tmp___70 == 0) {
#line 431
        value = 0;
      } else {
#line 433
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Bad yes/no argument: %s\n",
                filename, linenum, cp);
#line 435
        exit(1);
      }
    }
#line 437
    if (*intptr == -1) {
#line 438
      *intptr = value;
    }
#line 439
    break;
    case 28: 
#line 442
    intptr = & options___0->ignore_user_known_hosts;
    goto parse_flag;
    case 9: 
#line 446
    intptr = & options___0->rhosts_authentication;
    goto parse_flag;
    case 10: 
#line 450
    intptr = & options___0->rhosts_rsa_authentication;
    goto parse_flag;
    case 11: 
#line 454
    intptr = & options___0->rsa_authentication;
    goto parse_flag;
    case 34: 
#line 458
    intptr = & options___0->dsa_authentication;
    goto parse_flag;
    case 12: 
#line 486
    intptr = & options___0->password_authentication;
    goto parse_flag;
    case 22: 
#line 490
    intptr = & options___0->check_mail;
    goto parse_flag;
    case 14: 
#line 500
    intptr = & options___0->print_motd;
    goto parse_flag;
    case 16: 
#line 504
    intptr = & options___0->x11_forwarding;
    goto parse_flag;
    case 17: 
#line 508
    intptr = & options___0->x11_display_offset;
    goto parse_int;
    case 18: 
#line 512
    intptr = & options___0->strict_modes;
    goto parse_flag;
    case 21: 
#line 516
    intptr = & options___0->keepalives;
    goto parse_flag;
    case 19: 
#line 520
    intptr = & options___0->permit_empty_passwd;
    goto parse_flag;
    case 23: 
#line 524
    intptr = & options___0->use_login;
    goto parse_flag;
    case 33: 
#line 528
    intptr = & options___0->gateway_ports;
    goto parse_flag;
    case 7: 
#line 532
    intptr = (int *)(& options___0->log_facility);
#line 533
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 534
    tmp___85 = log_facility_number(cp);
#line 534
    value = (int )tmp___85;
#line 535
    if (value == (int )((enum __anonenum_SyslogFacility_72 )-1)) {
#line 536
      if (cp) {
#line 536
        tmp___86 = (char const   *)cp;
      } else {
#line 536
        tmp___86 = "<NONE>";
      }
#line 536
      fatal("%.200s line %d: unsupported log facility \'%s\'\n", filename, linenum,
            tmp___86);
    }
#line 538
    if (*intptr == -1) {
#line 539
      *intptr = (int )((enum __anonenum_SyslogFacility_72 )value);
    }
#line 540
    break;
    case 8: 
#line 543
    intptr = (int *)(& options___0->log_level);
#line 544
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 545
    tmp___87 = log_level_number(cp);
#line 545
    value = (int )tmp___87;
#line 546
    if (value == (int )((enum __anonenum_LogLevel_73 )-1)) {
#line 547
      if (cp) {
#line 547
        tmp___88 = (char const   *)cp;
      } else {
#line 547
        tmp___88 = "<NONE>";
      }
#line 547
      fatal("%.200s line %d: unsupported log level \'%s\'\n", filename, linenum, tmp___88);
    }
#line 549
    if (*intptr == -1) {
#line 550
      *intptr = (int )((enum __anonenum_LogLevel_73 )value);
    }
#line 551
    break;
    case 24: 
#line 554
    while (1) {
#line 554
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 554
      if (! cp) {
#line 554
        break;
      }
#line 555
      if (options___0->num_allow_users >= 256U) {
#line 556
        fatal("%s line %d: too many allow users.\n", filename, linenum);
      }
#line 558
      tmp___89 = options___0->num_allow_users;
#line 558
      (options___0->num_allow_users) ++;
#line 558
      options___0->allow_users[tmp___89] = xstrdup((char const   *)cp);
    }
#line 560
    break;
    case 25: 
#line 563
    while (1) {
#line 563
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 563
      if (! cp) {
#line 563
        break;
      }
#line 564
      if (options___0->num_deny_users >= 256U) {
#line 565
        fatal("%s line %d: too many deny users.\n", filename, linenum);
      }
#line 567
      tmp___90 = options___0->num_deny_users;
#line 567
      (options___0->num_deny_users) ++;
#line 567
      options___0->deny_users[tmp___90] = xstrdup((char const   *)cp);
    }
#line 569
    break;
    case 26: 
#line 572
    while (1) {
#line 572
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 572
      if (! cp) {
#line 572
        break;
      }
#line 573
      if (options___0->num_allow_groups >= 256U) {
#line 574
        fatal("%s line %d: too many allow groups.\n", filename, linenum);
      }
#line 576
      tmp___91 = options___0->num_allow_groups;
#line 576
      (options___0->num_allow_groups) ++;
#line 576
      options___0->allow_groups[tmp___91] = xstrdup((char const   *)cp);
    }
#line 578
    break;
    case 27: 
#line 581
    while (1) {
#line 581
      cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 581
      if (! cp) {
#line 581
        break;
      }
#line 582
      if (options___0->num_deny_groups >= 256U) {
#line 583
        fatal("%s line %d: too many deny groups.\n", filename, linenum);
      }
#line 585
      tmp___92 = options___0->num_deny_groups;
#line 585
      (options___0->num_deny_groups) ++;
#line 585
      options___0->deny_groups[tmp___92] = xstrdup((char const   *)cp);
    }
#line 587
    break;
    case 30: 
#line 590
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 591
    tmp___94 = ciphers_valid((char const   *)cp);
#line 591
    if (! tmp___94) {
#line 592
      if (cp) {
#line 592
        tmp___93 = (char const   *)cp;
      } else {
#line 592
        tmp___93 = "<NONE>";
      }
#line 592
      fatal("%s line %d: Bad cipher spec \'%s\'.", filename, linenum, tmp___93);
    }
#line 594
    if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 595
      options___0->ciphers = xstrdup((char const   *)cp);
    }
#line 596
    break;
    case 31: 
#line 599
    intptr = & options___0->protocol;
#line 600
    cp = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 601
    value = proto_spec((char const   *)cp);
#line 602
    if (value == 0) {
#line 603
      if (cp) {
#line 603
        tmp___95 = (char const   *)cp;
      } else {
#line 603
        tmp___95 = "<NONE>";
      }
#line 603
      fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___95);
    }
#line 605
    if (*intptr == 0) {
#line 606
      *intptr = value;
    }
#line 607
    break;
    default: 
#line 610
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: Missing handler for opcode %s (%d)\n",
            filename, linenum, cp, opcode);
#line 612
    exit(1);
    }
#line 614
    tmp___96 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\r\n");
#line 614
    if ((unsigned int )tmp___96 != (unsigned int )((void *)0)) {
#line 615
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s line %d: garbage at end of line.\n",
              filename, linenum);
#line 617
      exit(1);
    }
  }
#line 620
  fclose(f);
#line 621
  if (bad_options > 0) {
#line 622
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: terminating, %d bad configuration options\n",
            filename, bad_options);
#line 624
    exit(1);
  }
#line 626
  return;
}
}
#line 1 "serverloop.o"
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 495 "ssh.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 496
void server_loop2(void) ;
#line 9 "session.h"
int session_open(int chanid ) ;
#line 10
void session_input_channel_req(int id , void *arg ) ;
#line 11
void session_close_by_pid(pid_t pid , int status ) ;
#line 12
void session_close_by_channel(int id , void *arg ) ;
#line 27 "serverloop.c"
static Buffer stdin_buffer  ;
#line 28 "serverloop.c"
static Buffer stdout_buffer  ;
#line 29 "serverloop.c"
static Buffer stderr_buffer  ;
#line 30 "serverloop.c"
static int fdin  ;
#line 31 "serverloop.c"
static int fdout  ;
#line 33 "serverloop.c"
static int fderr  ;
#line 34 "serverloop.c"
static long stdin_bytes  =    0L;
#line 35 "serverloop.c"
static long stdout_bytes  =    0L;
#line 36 "serverloop.c"
static long stderr_bytes  =    0L;
#line 37 "serverloop.c"
static long fdout_bytes  =    0L;
#line 38 "serverloop.c"
static int stdin_eof  =    0;
#line 39 "serverloop.c"
static int fdout_eof  =    0;
#line 40 "serverloop.c"
static int fderr_eof  =    0;
#line 41 "serverloop.c"
static int connection_in___0  ;
#line 42 "serverloop.c"
static int connection_out___0  ;
#line 43 "serverloop.c"
static unsigned int buffer_high  ;
#line 44 "serverloop.c"
static int max_fd  ;
#line 55 "serverloop.c"
static pid_t child_pid  ;
#line 56 "serverloop.c"
static int volatile   child_terminated  ;
#line 57 "serverloop.c"
static int volatile   child_has_selected  ;
#line 58 "serverloop.c"
static int volatile   child_wait_status  ;
#line 60
void server_init_dispatch(void) ;
#line 62 "serverloop.c"
void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t wait_pid ;
  union __anonunion_77 __constr_expr_0 ;
  union __anonunion_78 __constr_expr_1 ;
  int *tmp___0 ;

  {
#line 65
  tmp = __errno_location();
#line 65
  save_errno = *tmp;
#line 68
  debug("Received SIGCHLD.");
#line 69
  wait_pid = wait((union wait *)((int *)(& child_wait_status)));
#line 70
  if (wait_pid != -1) {
#line 71
    if (wait_pid != child_pid) {
#line 72
      error("Strange, got SIGCHLD and wait returned pid %d but child is %d", wait_pid,
            child_pid);
    }
#line 74
    __constr_expr_0.__in = child_wait_status;
#line 74
    if ((__constr_expr_0.__i & 127) == 0) {
#line 76
      child_terminated = (int volatile   )1;
    } else {
#line 74
      __constr_expr_1.__in = child_wait_status;
#line 74
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 76
        child_terminated = (int volatile   )1;
      }
    }
#line 77
    child_has_selected = (int volatile   )0;
  }
#line 79
  signal(17, & sigchld_handler);
#line 80
  tmp___0 = __errno_location();
#line 80
  *tmp___0 = save_errno;
#line 81
  return;
}
}
#line 82 "serverloop.c"
void sigchld_handler2(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 85
  tmp = __errno_location();
#line 85
  save_errno = *tmp;
#line 86
  debug("Received SIGCHLD.");
#line 87
  child_terminated = (int volatile   )1;
#line 88
  signal(17, & sigchld_handler2);
#line 89
  tmp___0 = __errno_location();
#line 89
  *tmp___0 = save_errno;
#line 90
  return;
}
}
#line 96 "serverloop.c"
void make_packets_from_stderr_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 102
  while (1) {
#line 102
    tmp___2 = buffer_len(& stderr_buffer);
#line 102
    if (tmp___2 > 0U) {
#line 102
      tmp___3 = packet_not_very_much_data_to_write();
#line 102
      if (! tmp___3) {
#line 102
        break;
      }
    } else {
#line 102
      break;
    }
#line 104
    tmp = buffer_len(& stderr_buffer);
#line 104
    len = (int )tmp;
#line 105
    tmp___0 = packet_is_interactive();
#line 105
    if (tmp___0) {
#line 106
      if (len > 512) {
#line 107
        len = 512;
      }
    } else {
#line 110
      if (len > max_packet_size) {
#line 111
        len = max_packet_size;
      }
    }
#line 113
    packet_start(18);
#line 114
    tmp___1 = buffer_ptr(& stderr_buffer);
#line 114
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 115
    packet_send();
#line 116
    buffer_consume(& stderr_buffer, (unsigned int )len);
#line 117
    stderr_bytes += (long )len;
  }
#line 119
  return;
}
}
#line 125 "serverloop.c"
void make_packets_from_stdout_data(void) 
{ int len ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 131
  while (1) {
#line 131
    tmp___2 = buffer_len(& stdout_buffer);
#line 131
    if (tmp___2 > 0U) {
#line 131
      tmp___3 = packet_not_very_much_data_to_write();
#line 131
      if (! tmp___3) {
#line 131
        break;
      }
    } else {
#line 131
      break;
    }
#line 133
    tmp = buffer_len(& stdout_buffer);
#line 133
    len = (int )tmp;
#line 134
    tmp___0 = packet_is_interactive();
#line 134
    if (tmp___0) {
#line 135
      if (len > 512) {
#line 136
        len = 512;
      }
    } else {
#line 139
      if (len > max_packet_size) {
#line 140
        len = max_packet_size;
      }
    }
#line 142
    packet_start(17);
#line 143
    tmp___1 = buffer_ptr(& stdout_buffer);
#line 143
    packet_put_string((char const   *)tmp___1, (unsigned int )len);
#line 144
    packet_send();
#line 145
    buffer_consume(& stdout_buffer, (unsigned int )len);
#line 146
    stdout_bytes += (long )len;
  }
#line 148
  return;
}
}
#line 156 "serverloop.c"
void wait_until_can_do_something(fd_set *readset , fd_set *writeset , unsigned int max_time_milliseconds ) 
{ struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;

  {
  retry_select: 
#line 167
  while (1) {
#line 167
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readset->__fds_bits[0]): "memory");
#line 167
    break;
  }
#line 173
  if (compat20) {
#line 175
    tmp = channel_not_very_much_buffered_data();
#line 175
    if (tmp) {
#line 176
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
  } else {
#line 178
    tmp___0 = buffer_len(& stdin_buffer);
#line 178
    if (tmp___0 < 4096U) {
#line 178
      tmp___1 = channel_not_very_much_buffered_data();
#line 178
      if (tmp___1) {
#line 180
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 187
  if (! compat20) {
#line 187
    tmp___2 = packet_not_very_much_data_to_write();
#line 187
    if (tmp___2) {
#line 188
      if (! fdout_eof) {
#line 189
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 190
      if (! fderr_eof) {
#line 191
        __asm__  volatile   ("btsl %1,%0": "=m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 193
  while (1) {
#line 193
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& writeset->__fds_bits[0]): "memory");
#line 193
    break;
  }
#line 196
  channel_prepare_select(readset, writeset);
#line 202
  tmp___3 = packet_have_data_to_write();
#line 202
  if (tmp___3) {
#line 203
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 207
  if (! compat20) {
#line 207
    if (fdin != -1) {
#line 207
      tmp___4 = buffer_len(& stdin_buffer);
#line 207
      if (tmp___4 > 0U) {
#line 208
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 211
  tmp___5 = channel_max_fd();
#line 211
  if (tmp___5 > max_fd) {
#line 212
    max_fd = channel_max_fd();
  }
#line 218
  if (child_terminated) {
#line 218
    tmp___6 = packet_not_very_much_data_to_write();
#line 218
    if (tmp___6) {
#line 219
      if (max_time_milliseconds == 0U) {
#line 220
        max_time_milliseconds = 100U;
      }
    }
  }
#line 222
  if (max_time_milliseconds == 0U) {
#line 223
    tvp = (struct timeval *)((void *)0);
  } else {
#line 225
    tv.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 226
    tv.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 227
    tvp = & tv;
  }
#line 229
  if ((unsigned int )tvp != (unsigned int )((void *)0)) {
#line 230
    debug("tvp!=NULL kid %d mili %d", child_terminated, max_time_milliseconds);
  }
#line 233
  ret = select(max_fd + 1, (fd_set * __restrict  )readset, (fd_set * __restrict  )writeset,
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 235
  if (ret < 0) {
#line 236
    tmp___9 = __errno_location();
#line 236
    if (*tmp___9 != 4) {
#line 237
      tmp___7 = __errno_location();
#line 237
      tmp___8 = strerror(*tmp___7);
#line 237
      error("select: %.100s", tmp___8);
    } else {
      goto retry_select;
    }
  }
#line 242
  if (child_terminated) {
#line 243
    child_has_selected = (int volatile   )1;
  }
#line 244
  return;
}
}
#line 250 "serverloop.c"
void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  register char __result ;
  register char __result___0 ;
  register char __result___1 ;

  {
#line 257
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->__fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 257
  if (__result) {
#line 258
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 259
    if (len == 0) {
#line 260
      verbose("Connection closed by remote host.");
#line 261
      fatal_cleanup();
    }
#line 267
    if (len < 0) {
#line 267
      tmp = __errno_location();
#line 267
      if (*tmp == 11) {
#line 268
        len = 0;
      }
    }
#line 270
    if (len < 0) {
#line 271
      tmp___0 = __errno_location();
#line 271
      tmp___1 = strerror(*tmp___0);
#line 271
      verbose("Read error from remote host: %.100s", tmp___1);
#line 272
      fatal_cleanup();
    }
#line 275
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
#line 277
  if (compat20) {
#line 278
    return;
  }
#line 281
  if (! fdout_eof) {
#line 281
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 281
    if (__result___0) {
#line 282
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 283
      if (len <= 0) {
#line 284
        fdout_eof = 1;
      } else {
#line 286
        buffer_append(& stdout_buffer, (char const   *)(buf___1), (unsigned int )len);
#line 287
        fdout_bytes += (long )len;
      }
    }
  }
#line 291
  if (! fderr_eof) {
#line 291
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->__fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 291
    if (__result___1) {
#line 292
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 293
      if (len <= 0) {
#line 294
        fderr_eof = 1;
      } else {
#line 296
        buffer_append(& stderr_buffer, (char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 298
  return;
}
}
#line 303 "serverloop.c"
void process_output(fd_set *writeset ) 
{ int len ;
  unsigned int tmp ;
  char *tmp___0 ;
  register char __result ;
  register char __result___0 ;

  {
#line 309
  if (! compat20) {
#line 309
    if (fdin != -1) {
#line 309
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->__fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 309
      if (__result) {
#line 310
        tmp = buffer_len(& stdin_buffer);
#line 310
        tmp___0 = buffer_ptr(& stdin_buffer);
#line 310
        len = write(fdin, (void const   *)tmp___0, tmp);
#line 312
        if (len <= 0) {
#line 316
          if (fdin != fdout) {
#line 317
            close(fdin);
          } else {
#line 319
            shutdown(fdin, 1);
          }
#line 321
          fdin = -1;
        } else {
#line 324
          buffer_consume(& stdin_buffer, (unsigned int )len);
#line 326
          stdin_bytes += (long )len;
        }
      }
    }
  }
#line 330
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->__fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 330
  if (__result___0) {
#line 331
    packet_write_poll();
  }
#line 332
  return;
}
}
#line 338 "serverloop.c"
void drain_output(void) 
{ unsigned int tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 342
  tmp___2 = buffer_len(& stdout_buffer);
#line 342
  if (tmp___2 > 0U) {
#line 343
    packet_start(17);
#line 344
    tmp = buffer_len(& stdout_buffer);
#line 344
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 344
    packet_put_string((char const   *)tmp___0, tmp);
#line 346
    packet_send();
#line 348
    tmp___1 = buffer_len(& stdout_buffer);
#line 348
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 351
  tmp___6 = buffer_len(& stderr_buffer);
#line 351
  if (tmp___6 > 0U) {
#line 352
    packet_start(18);
#line 353
    tmp___3 = buffer_len(& stderr_buffer);
#line 353
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 353
    packet_put_string((char const   *)tmp___4, tmp___3);
#line 355
    packet_send();
#line 357
    tmp___5 = buffer_len(& stderr_buffer);
#line 357
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 360
  packet_write_wait();
#line 361
  return;
}
}
#line 363 "serverloop.c"
void process_buffered_input_packets(void) 
{ 

  {
#line 366
  dispatch_run(1, (int *)((void *)0));
#line 367
  return;
}
}
#line 376 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  unsigned int max_time_milliseconds ;
  unsigned int previous_stdout_buffer_bytes ;
  unsigned int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  fd_set readset ;
  fd_set writeset ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *s ;
  char *cp ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  union __anonunion_79 __constr_expr_0 ;
  union __anonunion_80 __constr_expr_1 ;
  int plen ;
  union __anonunion_81 __constr_expr_2 ;
  union __anonunion_82 __constr_expr_3 ;
  union __anonunion_83 __constr_expr_4 ;

  {
#line 381
  waiting_termination = 0;
#line 387
  debug("Entering interactive session.");
#line 390
  child_pid = pid;
#line 391
  child_terminated = (int volatile   )0;
#line 392
  child_has_selected = (int volatile   )0;
#line 393
  signal(17, & sigchld_handler);
#line 396
  fdin = fdin_arg;
#line 397
  fdout = fdout_arg;
#line 398
  fderr = fderr_arg;
#line 399
  connection_in___0 = packet_get_connection_in();
#line 400
  connection_out___0 = packet_get_connection_out();
#line 402
  previous_stdout_buffer_bytes = 0U;
#line 405
  tmp = packet_is_interactive();
#line 405
  if (tmp) {
#line 406
    buffer_high = 4096U;
  } else {
#line 408
    buffer_high = 65536U;
  }
#line 411
  max_fd = fdin;
#line 412
  if (fdout > max_fd) {
#line 413
    max_fd = fdout;
  }
#line 414
  if (fderr != -1) {
#line 414
    if (fderr > max_fd) {
#line 415
      max_fd = fderr;
    }
  }
#line 416
  if (connection_in___0 > max_fd) {
#line 417
    max_fd = connection_in___0;
  }
#line 418
  if (connection_out___0 > max_fd) {
#line 419
    max_fd = connection_out___0;
  }
#line 422
  buffer_init(& stdin_buffer);
#line 423
  buffer_init(& stdout_buffer);
#line 424
  buffer_init(& stderr_buffer);
#line 432
  if (fderr == -1) {
#line 433
    fderr_eof = 1;
  }
#line 435
  server_init_dispatch();
#line 438
  while (1) {
#line 442
    process_buffered_input_packets();
#line 448
    if (stdin_eof) {
#line 448
      if (fdin != -1) {
#line 448
        tmp___0 = buffer_len(& stdin_buffer);
#line 448
        if (tmp___0 == 0U) {
#line 452
          if (fdin != fdout) {
#line 453
            close(fdin);
          } else {
#line 455
            shutdown(fdin, 1);
          }
#line 457
          fdin = -1;
        }
      }
    }
#line 460
    make_packets_from_stderr_data();
#line 469
    max_time_milliseconds = 0U;
#line 470
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 471
    if (stdout_buffer_bytes != 0U) {
#line 471
      if (stdout_buffer_bytes < 256U) {
#line 471
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 474
          max_time_milliseconds = 10U;
        } else {
#line 477
          make_packets_from_stdout_data();
        }
      } else {
#line 477
        make_packets_from_stdout_data();
      }
    } else {
#line 477
      make_packets_from_stdout_data();
    }
#line 479
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 482
    tmp___1 = packet_not_very_much_data_to_write();
#line 482
    if (tmp___1) {
#line 483
      channel_output_poll();
    }
#line 490
    if (fdout_eof) {
#line 490
      if (fderr_eof) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 490
      if (child_terminated) {
#line 490
        if (child_has_selected) {
          _L: /* CIL Label */ 
#line 490
          tmp___5 = packet_have_data_to_write();
#line 490
          if (! tmp___5) {
#line 490
            tmp___6 = buffer_len(& stdout_buffer);
#line 490
            if (tmp___6 == 0U) {
#line 490
              tmp___7 = buffer_len(& stderr_buffer);
#line 490
              if (tmp___7 == 0U) {
#line 495
                tmp___2 = channel_still_open();
#line 495
                if (! tmp___2) {
#line 496
                  break;
                }
#line 497
                if (! waiting_termination) {
#line 498
                  s = "Waiting for forwarded connections to terminate...\r\n";
#line 500
                  waiting_termination = 1;
#line 501
                  tmp___3 = strlen(s);
#line 501
                  buffer_append(& stderr_buffer, s, tmp___3);
#line 504
                  cp = channel_open_message();
#line 505
                  tmp___4 = strlen((char const   *)cp);
#line 505
                  buffer_append(& stderr_buffer, (char const   *)cp, tmp___4);
#line 506
                  xfree((void *)cp);
                }
              }
            }
          }
        }
      }
    }
#line 510
    wait_until_can_do_something(& readset, & writeset, max_time_milliseconds);
#line 514
    channel_after_select(& readset, & writeset);
#line 517
    process_input(& readset);
#line 520
    process_output(& writeset);
  }
#line 526
  drain_output();
#line 528
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 532
  buffer_free(& stdin_buffer);
#line 533
  buffer_free(& stdout_buffer);
#line 534
  buffer_free(& stderr_buffer);
#line 537
  if (fdout != -1) {
#line 538
    close(fdout);
  }
#line 539
  fdout = -1;
#line 540
  fdout_eof = 1;
#line 541
  if (fderr != -1) {
#line 542
    close(fderr);
  }
#line 543
  fderr = -1;
#line 544
  fderr_eof = 1;
#line 545
  if (fdin != -1) {
#line 546
    close(fdin);
  }
#line 547
  fdin = -1;
#line 550
  channel_stop_listening();
#line 553
  wait_pid = wait((union wait *)(& wait_status));
#line 554
  if (wait_pid < 0) {
#line 560
    if (child_terminated) {
#line 561
      wait_status = (int )child_wait_status;
    } else {
#line 563
      tmp___8 = __errno_location();
#line 563
      tmp___9 = strerror(*tmp___8);
#line 563
      packet_disconnect("wait: %.100s", tmp___9);
    }
  } else {
#line 566
    if (wait_pid != pid) {
#line 567
      error("Strange, wait returned pid %d, expected %d", wait_pid, pid);
    }
  }
#line 572
  signal(17, (void (*)(int  ))0);
#line 575
  __constr_expr_2.__in = wait_status;
#line 575
  if ((__constr_expr_2.__i & 127) == 0) {
#line 577
    __constr_expr_0.__in = wait_status;
#line 577
    debug("Command exited with status %d.", (__constr_expr_0.__i & 65280) >> 8);
#line 578
    packet_start(20);
#line 579
    __constr_expr_1.__in = wait_status;
#line 579
    packet_put_int((unsigned int )((__constr_expr_1.__i & 65280) >> 8));
#line 580
    packet_send();
#line 581
    packet_write_wait();
#line 590
    while (1) {
#line 592
      type = packet_read(& plen);
#line 590
      if (! (type != 33)) {
#line 590
        break;
      }
    }
#line 596
    debug("Received exit confirmation.");
#line 597
    return;
  }
#line 600
  __constr_expr_4.__in = wait_status;
#line 600
  if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 601
    __constr_expr_3.__in = wait_status;
#line 601
    packet_disconnect("Command terminated on signal %d.", __constr_expr_3.__i & 127);
  }
#line 605
  packet_disconnect("wait returned status %04x.", wait_status);
#line 607
  return;
}
}
#line 609 "serverloop.c"
void server_loop2(void) 
{ fd_set readset ;
  fd_set writeset ;
  int had_channel ;
  int status ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 613
  had_channel = 0;
#line 617
  debug("Entering interactive session for SSH2.");
#line 619
  signal(17, & sigchld_handler2);
#line 620
  child_terminated = (int volatile   )0;
#line 621
  connection_in___0 = packet_get_connection_in();
#line 622
  connection_out___0 = packet_get_connection_out();
#line 623
  max_fd = connection_in___0;
#line 624
  if (connection_out___0 > max_fd) {
#line 625
    max_fd = connection_out___0;
  }
#line 626
  server_init_dispatch();
#line 628
  while (1) {
#line 629
    process_buffered_input_packets();
#line 630
    if (! had_channel) {
#line 630
      tmp = channel_still_open();
#line 630
      if (tmp) {
#line 631
        had_channel = 1;
      }
    }
#line 632
    if (had_channel) {
#line 632
      tmp___0 = channel_still_open();
#line 632
      if (! tmp___0) {
#line 633
        debug("!channel_still_open.");
#line 634
        break;
      }
    }
#line 636
    tmp___1 = packet_not_very_much_data_to_write();
#line 636
    if (tmp___1) {
#line 637
      channel_output_poll();
    }
#line 638
    wait_until_can_do_something(& readset, & writeset, 0U);
#line 639
    if (child_terminated) {
#line 640
      while (1) {
#line 640
        pid = waitpid(-1, & status, 1);
#line 640
        if (! (pid > 0)) {
#line 640
          break;
        }
#line 641
        session_close_by_pid(pid, status);
      }
#line 642
      child_terminated = (int volatile   )0;
    }
#line 644
    channel_after_select(& readset, & writeset);
#line 645
    process_input(& readset);
#line 646
    process_output(& writeset);
  }
#line 648
  signal(17, (void (*)(int  ))0);
#line 649
  while (1) {
#line 649
    pid = waitpid(-1, & status, 1);
#line 649
    if (! (pid > 0)) {
#line 649
      break;
    }
#line 650
    session_close_by_pid(pid, status);
  }
#line 651
  channel_stop_listening();
#line 652
  return;
}
}
#line 654 "serverloop.c"
void server_input_stdin_data(int type , int plen ) 
{ char *data ;
  unsigned int data_len ;
  int _p ;
  int _e ;

  {
#line 662
  if (fdin == -1) {
#line 663
    return;
  }
#line 664
  data = packet_get_string(& data_len);
#line 665
  while (1) {
#line 665
    _p = plen;
#line 665
    _e = (int )(4U + data_len);
#line 665
    if (_p != _e) {
#line 665
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 665);
#line 665
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 665
    break;
  }
#line 666
  buffer_append(& stdin_buffer, (char const   *)data, data_len);
#line 667
  memset((void *)data, 0, data_len);
#line 668
  xfree((void *)data);
#line 669
  return;
}
}
#line 671 "serverloop.c"
void server_input_eof(int type , int plen ) 
{ int _p ;
  int _e ;

  {
#line 679
  debug("EOF received for stdin.");
#line 680
  while (1) {
#line 680
    _p = plen;
#line 680
    _e = 0;
#line 680
    if (_p != _e) {
#line 680
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 680);
#line 680
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 680
    break;
  }
#line 681
  stdin_eof = 1;
#line 682
  return;
}
}
#line 684 "serverloop.c"
void server_input_window_size(int type , int plen ) 
{ int row ;
  unsigned int tmp ;
  int col ;
  unsigned int tmp___0 ;
  int xpixel ;
  unsigned int tmp___1 ;
  int ypixel ;
  unsigned int tmp___2 ;
  int _p ;
  int _e ;

  {
#line 687
  tmp = packet_get_int();
#line 687
  row = (int )tmp;
#line 688
  tmp___0 = packet_get_int();
#line 688
  col = (int )tmp___0;
#line 689
  tmp___1 = packet_get_int();
#line 689
  xpixel = (int )tmp___1;
#line 690
  tmp___2 = packet_get_int();
#line 690
  ypixel = (int )tmp___2;
#line 692
  debug("Window change received.");
#line 693
  while (1) {
#line 693
    _p = plen;
#line 693
    _e = 16;
#line 693
    if (_p != _e) {
#line 693
      log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "serverloop.c", 693);
#line 693
      packet_disconnect("Packet integrity error. (%d)", type);
    }
#line 693
    break;
  }
#line 694
  if (fdin != -1) {
#line 695
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 696
  return;
}
}
#line 698 "serverloop.c"
int input_direct_tcpip(void) 
{ int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 705
  target = packet_get_string((unsigned int *)((void *)0));
#line 706
  tmp = packet_get_int();
#line 706
  target_port = (int )tmp;
#line 707
  originator = packet_get_string((unsigned int *)((void *)0));
#line 708
  tmp___0 = packet_get_int();
#line 708
  originator_port = (int )tmp___0;
#line 709
  while (1) {
#line 709
    tmp___1 = packet_remaining();
#line 709
    _len = tmp___1;
#line 709
    if (_len > 0) {
#line 709
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
          709);
#line 709
      packet_disconnect("Packet integrity error.");
    }
#line 709
    break;
  }
#line 711
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 712
  xfree((void *)target);
#line 713
  xfree((void *)originator);
#line 714
  if (sock < 0) {
#line 715
    return (-1);
  }
#line 716
  tmp___2 = xstrdup("direct-tcpip");
#line 716
  tmp___3 = channel_new((char *)"direct-tcpip", 4, sock, sock, -1, 4096, 32768, 0,
                        tmp___2);
#line 716
  return (tmp___3);
}
}
#line 720 "serverloop.c"
void server_input_channel_open(int type , int plen ) 
{ Channel *c ;
  char *ctype ;
  int id ;
  unsigned int len ;
  int rchan ;
  int rmaxpack ;
  int rwindow ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int _len ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;

  {
#line 723
  c = (Channel *)((void *)0);
#line 731
  ctype = packet_get_string(& len);
#line 732
  tmp = packet_get_int();
#line 732
  rchan = (int )tmp;
#line 733
  tmp___0 = packet_get_int();
#line 733
  rwindow = (int )tmp___0;
#line 734
  tmp___1 = packet_get_int();
#line 734
  rmaxpack = (int )tmp___1;
#line 736
  debug("channel_input_open: ctype %s rchan %d win %d max %d", ctype, rchan, rwindow,
        rmaxpack);
#line 739
  if (0) {
#line 739
    __s1_len___0 = strlen((char const   *)ctype);
#line 739
    __s2_len___0 = strlen("session");
#line 739
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___2;
    } else {
#line 739
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 739
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 739
          tmp___24 = 1;
        } else {
#line 739
          if (__s2_len___0 >= 4U) {
#line 739
            tmp___24 = 1;
          } else {
#line 739
            tmp___24 = 0;
          }
        }
      } else {
#line 739
        tmp___24 = 0;
      }
    }
#line 739
    if (tmp___24) {
#line 739
      tmp___20 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 739
      tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 739
      tmp___20 = tmp___23;
    }
  } else {
#line 739
    tmp___23 = __builtin_strcmp((char const   *)ctype, "session");
#line 739
    tmp___20 = tmp___23;
  }
#line 739
  if (tmp___20 == 0) {
#line 740
    debug("open session");
#line 741
    while (1) {
#line 741
      tmp___2 = packet_remaining();
#line 741
      _len = tmp___2;
#line 741
      if (_len > 0) {
#line 741
        log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            741);
#line 741
        packet_disconnect("Packet integrity error.");
      }
#line 741
      break;
    }
#line 749
    tmp___3 = xstrdup("server-session");
#line 749
    id = channel_new(ctype, 10, -1, -1, -1, 0, 32768, 0, tmp___3);
#line 751
    tmp___4 = session_open(id);
#line 751
    if (tmp___4 == 1) {
#line 752
      channel_register_callback(id, 98, & session_input_channel_req, (void *)0);
#line 754
      channel_register_cleanup(id, & session_close_by_channel);
#line 755
      c = channel_lookup(id);
    } else {
#line 757
      debug("session open failed, free channel %d", id);
#line 758
      channel_free(id);
    }
  } else {
#line 760
    if (0) {
#line 760
      __s1_len = strlen((char const   *)ctype);
#line 760
      __s2_len = strlen("direct-tcpip");
#line 760
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___0;
      } else {
#line 760
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 760
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 760
            tmp___14 = 1;
          } else {
#line 760
            if (__s2_len >= 4U) {
#line 760
              tmp___14 = 1;
            } else {
#line 760
              tmp___14 = 0;
            }
          }
        } else {
#line 760
          tmp___14 = 0;
        }
      }
#line 760
      if (tmp___14) {
#line 760
        tmp___10 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 760
        tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 760
        tmp___10 = tmp___13;
      }
    } else {
#line 760
      tmp___13 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 760
      tmp___10 = tmp___13;
    }
#line 760
    if (tmp___10 == 0) {
#line 761
      debug("open direct-tcpip");
#line 762
      id = input_direct_tcpip();
#line 763
      if (id >= 0) {
#line 764
        c = channel_lookup(id);
      }
    }
  }
#line 766
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 767
    debug("confirm %s", ctype);
#line 768
    c->remote_id = rchan;
#line 769
    c->remote_window = rwindow;
#line 770
    c->remote_maxpacket = rmaxpack;
#line 772
    packet_start(91);
#line 773
    packet_put_int((unsigned int )c->remote_id);
#line 774
    packet_put_int((unsigned int )c->self);
#line 775
    packet_put_int((unsigned int )c->local_window);
#line 776
    packet_put_int((unsigned int )c->local_maxpacket);
#line 777
    packet_send();
  } else {
#line 779
    debug("failure %s", ctype);
#line 780
    packet_start(92);
#line 781
    packet_put_int((unsigned int )rchan);
#line 782
    packet_put_int(1U);
#line 783
    packet_put_cstring("bla bla");
#line 784
    packet_put_cstring("");
#line 785
    packet_send();
  }
#line 787
  xfree((void *)ctype);
#line 788
  return;
}
}
#line 790 "serverloop.c"
void server_init_dispatch_20(void) 
{ 

  {
#line 793
  debug("server_init_dispatch_20");
#line 794
  dispatch_init(& dispatch_protocol_error);
#line 795
  dispatch_set(97, & channel_input_oclose);
#line 796
  dispatch_set(94, & channel_input_data);
#line 797
  dispatch_set(96, & channel_input_ieof);
#line 798
  dispatch_set(95, & channel_input_extended_data);
#line 799
  dispatch_set(90, & server_input_channel_open);
#line 800
  dispatch_set(91, & channel_input_open_confirmation);
#line 801
  dispatch_set(92, & channel_input_open_failure);
#line 802
  dispatch_set(98, & channel_input_channel_request);
#line 803
  dispatch_set(93, & channel_input_window_adjust);
#line 804
  return;
}
}
#line 805 "serverloop.c"
void server_init_dispatch_13(void) 
{ 

  {
#line 808
  debug("server_init_dispatch_13");
#line 809
  dispatch_init((dispatch_fn *)((void *)0));
#line 810
  dispatch_set(19, & server_input_eof);
#line 811
  dispatch_set(16, & server_input_stdin_data);
#line 812
  dispatch_set(11, & server_input_window_size);
#line 813
  dispatch_set(24, & channel_input_close);
#line 814
  dispatch_set(25, & channel_input_close_confirmation);
#line 815
  dispatch_set(23, & channel_input_data);
#line 816
  dispatch_set(21, & channel_input_open_confirmation);
#line 817
  dispatch_set(22, & channel_input_open_failure);
#line 818
  dispatch_set(29, & channel_input_port_open);
#line 819
  return;
}
}
#line 820 "serverloop.c"
void server_init_dispatch_15(void) 
{ 

  {
#line 823
  server_init_dispatch_13();
#line 824
  debug("server_init_dispatch_15");
#line 825
  dispatch_set(24, & channel_input_ieof);
#line 826
  dispatch_set(25, & channel_input_oclose);
#line 827
  return;
}
}
#line 828 "serverloop.c"
void server_init_dispatch(void) 
{ 

  {
#line 831
  if (compat20) {
#line 832
    server_init_dispatch_20();
  } else {
#line 833
    if (compat13) {
#line 834
      server_init_dispatch_13();
    } else {
#line 836
      server_init_dispatch_15();
    }
  }
#line 837
  return;
}
}
#line 1 "bsd-login.o"
#line 1 "md5crypt.o"
#line 1 "session.o"
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 57 "session.c"
Session *session_new(void) ;
#line 58
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 59
void session_pty_cleanup(Session *s ) ;
#line 60
void session_proctitle(Session *s ) ;
#line 61
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 62
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) ;
#line 64
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) ;
#line 81 "session.c"
static char *xauthfile  ;
#line 85 "session.c"
Session sessions[10]  ;
#line 88 "session.c"
int no_port_forwarding_flag  =    0;
#line 89 "session.c"
int no_agent_forwarding_flag  =    0;
#line 90 "session.c"
int no_x11_forwarding_flag  =    0;
#line 91 "session.c"
int no_pty_flag  =    0;
#line 94 "session.c"
char *forced_command  =    (char *)((void *)0);
#line 97 "session.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 102 "session.c"
void xauthfile_cleanup_proc(void *ignore ) 
{ char *p ;

  {
#line 105
  debug("xauthfile_cleanup_proc called");
#line 107
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 109
    unlink((char const   *)xauthfile);
#line 110
    p = strrchr((char const   *)xauthfile, '/');
#line 111
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 112
      *p = (char )'\000';
#line 113
      rmdir((char const   *)xauthfile);
    }
#line 115
    xfree((void *)xauthfile);
#line 116
    xauthfile = (char *)((void *)0);
  }
#line 118
  return;
}
}
#line 124 "session.c"
void pty_cleanup_proc(void *session ) 
{ Session *s ;

  {
#line 127
  s = (Session *)session;
#line 128
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 129
    fatal("pty_cleanup_proc: no session");
  }
#line 130
  debug("pty_cleanup_proc: %s", s->tty);
#line 132
  if (s->pid != 0) {
#line 134
    record_logout(s->pid, (char const   *)(s->tty));
  }
#line 138
  pty_release((char const   *)(s->tty));
#line 139
  return;
}
}
#line 147 "session.c"
void do_authenticated(struct passwd *pw ) 
{ Session *s ;
  int type ;
  int compression_level ;
  int enable_compression_after_reply ;
  int have_pty ;
  char *command ;
  int n_bytes ;
  int plen ;
  unsigned int proto_len ;
  unsigned int data_len ;
  unsigned int dlen ;
  int success ;
  int _p ;
  int _e ;
  unsigned int tmp ;
  int tmp___0 ;
  int _p___0 ;
  int _e___0 ;
  size_t tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int _p___1 ;
  int _e___1 ;
  int _p___2 ;
  int _e___2 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  void *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int _p___3 ;
  int _e___3 ;
  int _p___4 ;
  int _e___4 ;
  int tmp___25 ;

  {
#line 152
  compression_level = 0;
#line 152
  enable_compression_after_reply = 0;
#line 153
  have_pty = 0;
#line 163
  alarm(0U);
#line 172
  if (! no_port_forwarding_flag) {
#line 173
    channel_permit_all_opens();
  }
#line 175
  s = session_new();
#line 176
  s->pw = pw;
#line 182
  while (1) {
#line 183
    success = 0;
#line 186
    type = packet_read(& plen);
#line 189
    switch (type) {
    case 37: 
#line 191
    while (1) {
#line 191
      _p = plen;
#line 191
      _e = 4;
#line 191
      if (_p != _e) {
#line 191
        log("Packet integrity error (%d != %d) at %s:%d", _p, _e, "session.c", 191);
#line 191
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 191
      break;
    }
#line 192
    tmp = packet_get_int();
#line 192
    compression_level = (int )tmp;
#line 193
    if (compression_level < 1) {
#line 194
      packet_send_debug("Received illegal compression level %d.", compression_level);
#line 196
      break;
    } else {
#line 193
      if (compression_level > 9) {
#line 194
        packet_send_debug("Received illegal compression level %d.", compression_level);
#line 196
        break;
      }
    }
#line 199
    enable_compression_after_reply = 1;
#line 200
    success = 1;
#line 201
    break;
    case 10: 
#line 204
    if (no_pty_flag) {
#line 205
      debug("Allocating a pty not permitted for this authentication.");
#line 206
      break;
    }
#line 208
    if (have_pty) {
#line 209
      packet_disconnect("Protocol error: you already have a pty.");
    }
#line 211
    debug("Allocating pty.");
#line 214
    tmp___0 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 214
    if (! tmp___0) {
#line 216
      error("Failed to allocate pty.");
#line 217
      break;
    }
#line 219
    fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 220
    pty_setowner(pw, (char const   *)(s->tty));
#line 223
    s->term = packet_get_string(& dlen);
#line 224
    while (1) {
#line 224
      _p___0 = (int )dlen;
#line 224
      tmp___1 = strlen((char const   *)s->term);
#line 224
      _e___0 = (int )tmp___1;
#line 224
      if (_p___0 != _e___0) {
#line 224
        log("Packet integrity error (%d != %d) at %s:%d", _p___0, _e___0, "session.c",
            224);
#line 224
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 224
      break;
    }
#line 227
    n_bytes = (int )((unsigned int )plen - ((4U + dlen) + 16U));
#line 229
    if (0) {
#line 229
      __s1_len = strlen((char const   *)s->term);
#line 229
      __s2_len = strlen("");
#line 229
      if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
        goto _L___0;
      } else {
#line 229
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 229
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 229
            tmp___11 = 1;
          } else {
#line 229
            if (__s2_len >= 4U) {
#line 229
              tmp___11 = 1;
            } else {
#line 229
              tmp___11 = 0;
            }
          }
        } else {
#line 229
          tmp___11 = 0;
        }
      }
#line 229
      if (tmp___11) {
#line 229
        tmp___7 = __builtin_strcmp((char const   *)s->term, "");
      } else {
#line 229
        tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 229
        tmp___7 = tmp___10;
      }
    } else {
#line 229
      tmp___10 = __builtin_strcmp((char const   *)s->term, "");
#line 229
      tmp___7 = tmp___10;
    }
#line 229
    if (tmp___7 == 0) {
#line 230
      xfree((void *)s->term);
#line 231
      s->term = (char *)((void *)0);
    }
#line 234
    tmp___12 = packet_get_int();
#line 234
    s->row = (int )tmp___12;
#line 235
    tmp___13 = packet_get_int();
#line 235
    s->col = (int )tmp___13;
#line 236
    tmp___14 = packet_get_int();
#line 236
    s->xpixel = (int )tmp___14;
#line 237
    tmp___15 = packet_get_int();
#line 237
    s->ypixel = (int )tmp___15;
#line 238
    pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 241
    tty_parse_modes(s->ttyfd, & n_bytes);
#line 242
    while (1) {
#line 242
      _p___1 = plen;
#line 242
      _e___1 = (int )(((4U + dlen) + 16U) + (unsigned int )n_bytes);
#line 242
      if (_p___1 != _e___1) {
#line 242
        log("Packet integrity error (%d != %d) at %s:%d", _p___1, _e___1, "session.c",
            242);
#line 242
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 242
      break;
    }
#line 244
    session_proctitle(s);
#line 247
    success = 1;
#line 248
    have_pty = 1;
#line 249
    break;
    case 34: 
#line 252
    if (! options.x11_forwarding) {
#line 253
      packet_send_debug("X11 forwarding disabled in server configuration file.");
#line 254
      break;
    }
#line 257
    if (no_x11_forwarding_flag) {
#line 258
      packet_send_debug("X11 forwarding not permitted for this authentication.");
#line 259
      break;
    }
#line 261
    debug("Received request for X11 forwarding with auth spoofing.");
#line 262
    if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 263
      packet_disconnect("Protocol error: X11 display already set.");
    }
#line 265
    s->auth_proto = packet_get_string(& proto_len);
#line 266
    s->auth_data = packet_get_string(& data_len);
#line 267
    while (1) {
#line 267
      _p___2 = plen;
#line 267
      _e___2 = (int )((((4U + proto_len) + 4U) + data_len) + 4U);
#line 267
      if (_p___2 != _e___2) {
#line 267
        log("Packet integrity error (%d != %d) at %s:%d", _p___2, _e___2, "session.c",
            267);
#line 267
        packet_disconnect("Packet integrity error. (%d)", type);
      }
#line 267
      break;
    }
#line 269
    tmp___17 = packet_get_protocol_flags();
#line 269
    if (tmp___17 & 1U) {
#line 270
      tmp___16 = packet_get_int();
#line 270
      s->screen = (int )tmp___16;
    } else {
#line 272
      s->screen = 0;
    }
#line 273
    s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 275
    if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 276
      break;
    }
#line 279
    tmp___18 = xmalloc(4096U);
#line 279
    xauthfile = (char *)tmp___18;
#line 280
    strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 281
    temporarily_use_uid(pw->pw_uid);
#line 282
    tmp___21 = mkdtemp(xauthfile);
#line 282
    if ((unsigned int )tmp___21 == (unsigned int )((void *)0)) {
#line 283
      restore_uid();
#line 284
      tmp___19 = __errno_location();
#line 284
      tmp___20 = strerror(*tmp___19);
#line 284
      error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___20);
#line 286
      xfree((void *)xauthfile);
#line 287
      xauthfile = (char *)((void *)0);
#line 289
      break;
    }
#line 291
    strlcat(xauthfile, "/cookies", 4096U);
#line 292
    open((char const   *)xauthfile, 194, 384);
#line 293
    restore_uid();
#line 294
    fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)0);
#line 295
    success = 1;
#line 296
    break;
    case 30: 
#line 303
    if (no_agent_forwarding_flag) {
#line 304
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 305
      break;
    } else {
#line 303
      if (compat13) {
#line 304
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 305
        break;
      }
    }
#line 307
    debug("Received authentication agent forwarding request.");
#line 308
    auth_input_request_forwarding(pw);
#line 309
    success = 1;
#line 310
    break;
    case 28: 
#line 313
    if (no_port_forwarding_flag) {
#line 314
      debug("Port forwarding not permitted for this authentication.");
#line 315
      break;
    }
#line 317
    debug("Received TCP/IP port forwarding request.");
#line 318
    channel_input_port_forward_request(pw->pw_uid == 0U, options.gateway_ports);
#line 319
    success = 1;
#line 320
    break;
    case 38: 
#line 323
    tmp___22 = packet_get_int();
#line 323
    tmp___23 = packet_set_maxsize((int )tmp___22);
#line 323
    if (tmp___23 > 0) {
#line 324
      success = 1;
    }
#line 325
    break;
    case 12: 
    case 13: 
#line 330
    if (have_pty) {
#line 330
      tmp___24 = 1;
    } else {
#line 330
      if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 330
        tmp___24 = 1;
      } else {
#line 330
        tmp___24 = 0;
      }
    }
#line 330
    packet_set_interactive(tmp___24, options.keepalives);
#line 333
    if (type == 13) {
#line 334
      command = packet_get_string(& dlen);
#line 335
      debug("Exec command \'%.500s\'", command);
#line 336
      while (1) {
#line 336
        _p___3 = plen;
#line 336
        _e___3 = (int )(4U + dlen);
#line 336
        if (_p___3 != _e___3) {
#line 336
          log("Packet integrity error (%d != %d) at %s:%d", _p___3, _e___3, "session.c",
              336);
#line 336
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 336
        break;
      }
    } else {
#line 338
      command = (char *)((void *)0);
#line 339
      while (1) {
#line 339
        _p___4 = plen;
#line 339
        _e___4 = 0;
#line 339
        if (_p___4 != _e___4) {
#line 339
          log("Packet integrity error (%d != %d) at %s:%d", _p___4, _e___4, "session.c",
              339);
#line 339
          packet_disconnect("Packet integrity error. (%d)", type);
        }
#line 339
        break;
      }
    }
#line 341
    if ((unsigned int )forced_command != (unsigned int )((void *)0)) {
#line 342
      command = forced_command;
#line 343
      debug("Forced command \'%.500s\'", forced_command);
    }
#line 345
    if (have_pty) {
#line 346
      do_exec_pty(s, (char const   *)command, pw);
    } else {
#line 348
      do_exec_no_pty(s, (char const   *)command, pw);
    }
#line 350
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 351
      xfree((void *)command);
    }
#line 353
    if (xauthfile) {
#line 354
      xauthfile_cleanup_proc((void *)0);
    }
#line 355
    return;
    default: 
#line 362
    log("Unknown packet type received after authentication: %d", type);
    }
#line 364
    if (success) {
#line 364
      tmp___25 = 14;
    } else {
#line 364
      tmp___25 = 15;
    }
#line 364
    packet_start(tmp___25);
#line 365
    packet_send();
#line 366
    packet_write_wait();
#line 369
    if (enable_compression_after_reply) {
#line 370
      enable_compression_after_reply = 0;
#line 371
      packet_start_compression(compression_level);
    }
  }
}
}
#line 381 "session.c"
void do_exec_no_pty(Session *s , char const   *command , struct passwd *pw ) 
{ int pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 395
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 395
  if (tmp___1 < 0) {
#line 397
    tmp = __errno_location();
#line 397
    tmp___0 = strerror(*tmp);
#line 397
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 395
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 395
    if (tmp___2 < 0) {
#line 397
      tmp = __errno_location();
#line 397
      tmp___0 = strerror(*tmp);
#line 397
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 400
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 401
    fatal("do_exec_no_pty: no session");
  }
#line 403
  session_proctitle(s);
#line 406
  do_pam_setcred();
#line 410
  pid = fork();
#line 410
  if (pid == 0) {
#line 412
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 418
    tmp___5 = setsid();
#line 418
    if (tmp___5 < 0) {
#line 419
      tmp___3 = __errno_location();
#line 419
      tmp___4 = strerror(*tmp___3);
#line 419
      error("setsid failed: %.100s", tmp___4);
    }
#line 448
    close(inout[1]);
#line 449
    close(err[1]);
#line 450
    tmp___6 = dup2(inout[0], 0);
#line 450
    if (tmp___6 < 0) {
#line 451
      perror("dup2 stdin");
    }
#line 452
    tmp___7 = dup2(inout[0], 1);
#line 452
    if (tmp___7 < 0) {
#line 453
      perror("dup2 stdout");
    }
#line 454
    tmp___8 = dup2(err[0], 2);
#line 454
    if (tmp___8 < 0) {
#line 455
      perror("dup2 stderr");
    }
#line 459
    do_child(command, pw, (char const   *)((void *)0), (char const   *)s->display,
             (char const   *)s->auth_proto, (char const   *)s->auth_data, (char const   *)((void *)0));
  }
#line 462
  if (pid < 0) {
#line 463
    tmp___9 = __errno_location();
#line 463
    tmp___10 = strerror(*tmp___9);
#line 463
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 464
  s->pid = pid;
#line 480
  close(inout[0]);
#line 481
  close(err[0]);
#line 487
  if (compat20) {
#line 488
    if (s->extended) {
#line 488
      tmp___11 = err[1];
    } else {
#line 488
      tmp___11 = -1;
    }
#line 488
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 490
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 494
  return;
}
}
#line 502 "session.c"
void do_exec_pty(Session *s , char const   *command , struct passwd *pw ) 
{ FILE *f ;
  char buf___1[100] ;
  char *time_string ;
  char line[256] ;
  char const   *hostname ;
  int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  int quiet_login ;
  pid_t pid ;
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct stat st ;
  time_t last_login_time ;
  unsigned long tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___19 ;
  char *tmp___21 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 517
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 518
    fatal("do_exec_pty: no session");
  }
#line 519
  ptyfd = s->ptyfd;
#line 520
  ttyfd = s->ttyfd;
#line 523
  hostname = get_canonical_hostname();
#line 529
  if (! options.use_login) {
#line 530
    tmp = get_last_login_time(pw->pw_uid, (char const   *)pw->pw_name, buf___1, sizeof(buf___1));
#line 530
    last_login_time = (long )tmp;
  }
#line 535
  do_pam_session(pw->pw_name, (char const   *)(s->tty));
#line 536
  do_pam_setcred();
#line 540
  pid = fork();
#line 540
  if (pid == 0) {
#line 541
    pid = getpid();
#line 545
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 548
    close(ptyfd);
#line 551
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 554
    tmp___2 = fileno(stdin);
#line 554
    tmp___3 = dup2(ttyfd, tmp___2);
#line 554
    if (tmp___3 < 0) {
#line 555
      tmp___0 = __errno_location();
#line 555
      tmp___1 = strerror(*tmp___0);
#line 555
      error("dup2 stdin failed: %.100s", tmp___1);
    }
#line 558
    tmp___6 = fileno(stdout);
#line 558
    tmp___7 = dup2(ttyfd, tmp___6);
#line 558
    if (tmp___7 < 0) {
#line 559
      tmp___4 = __errno_location();
#line 559
      tmp___5 = strerror(*tmp___4);
#line 559
      error("dup2 stdin failed: %.100s", tmp___5);
    }
#line 562
    tmp___10 = fileno(stderr);
#line 562
    tmp___11 = dup2(ttyfd, tmp___10);
#line 562
    if (tmp___11 < 0) {
#line 563
      tmp___8 = __errno_location();
#line 563
      tmp___9 = strerror(*tmp___8);
#line 563
      error("dup2 stdin failed: %.100s", tmp___9);
    }
#line 566
    close(ttyfd);
#line 574
    memset((void *)(& from), 0, sizeof(from));
#line 575
    tmp___16 = packet_connection_is_on_socket();
#line 575
    if (tmp___16) {
#line 576
      fromlen = sizeof(from);
#line 577
      tmp___14 = packet_get_connection_in();
#line 577
      tmp___15 = getpeername(tmp___14, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                             (socklen_t * __restrict  )(& fromlen));
#line 577
      if (tmp___15 < 0) {
#line 579
        tmp___12 = __errno_location();
#line 579
        tmp___13 = strerror(*tmp___12);
#line 579
        debug("getpeername: %.100s", tmp___13);
#line 580
        fatal_cleanup();
      }
    }
#line 584
    record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
                 hostname, (struct sockaddr *)(& from));
#line 588
    snprintf((char * __restrict  )(line), sizeof(line), (char const   * __restrict  )"%.200s/.hushlogin",
             pw->pw_dir);
#line 589
    tmp___17 = stat((char const   * __restrict  )(line), (struct stat * __restrict  )(& st));
#line 589
    quiet_login = tmp___17 >= 0;
#line 592
    if (! quiet_login) {
#line 593
      print_pam_messages();
    }
#line 604
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 604
      if (last_login_time != 0L) {
#line 604
        if (! quiet_login) {
#line 604
          if (! options.use_login) {
#line 607
            time_string = ctime((time_t const   *)(& last_login_time));
#line 609
            tmp___21 = __builtin_strchr(time_string, '\n');
#line 609
            if (tmp___21) {
#line 610
              tmp___19 = __builtin_strchr(time_string, '\n');
#line 610
              *tmp___19 = (char)0;
            }
#line 613
            if (0) {
#line 613
              __s1_len = strlen((char const   *)(buf___1));
#line 613
              __s2_len = strlen("");
#line 613
              if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
                goto _L___0;
              } else {
#line 613
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 613
                  if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 613
                    tmp___31 = 1;
                  } else {
#line 613
                    if (__s2_len >= 4U) {
#line 613
                      tmp___31 = 1;
                    } else {
#line 613
                      tmp___31 = 0;
                    }
                  }
                } else {
#line 613
                  tmp___31 = 0;
                }
              }
#line 613
              if (tmp___31) {
#line 613
                tmp___27 = __builtin_strcmp((char const   *)(buf___1), "");
              } else {
#line 613
                tmp___30 = __builtin_strcmp((char const   *)(buf___1), "");
#line 613
                tmp___27 = tmp___30;
              }
            } else {
#line 613
              tmp___30 = __builtin_strcmp((char const   *)(buf___1), "");
#line 613
              tmp___27 = tmp___30;
            }
#line 613
            if (tmp___27 == 0) {
#line 614
              printf((char const   * __restrict  )"Last login: %s\r\n", time_string);
            } else {
#line 616
              printf((char const   * __restrict  )"Last login: %s from %s\r\n", time_string,
                     buf___1);
            }
          }
        }
      }
    }
#line 624
    if ((unsigned int )command == (unsigned int )((void *)0)) {
#line 624
      if (options.print_motd) {
#line 624
        if (! quiet_login) {
#line 624
          if (! options.use_login) {
#line 627
            f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 628
            if (f) {
#line 629
              while (1) {
#line 629
                tmp___32 = fgets((char * __restrict  )(line), (int )sizeof(line),
                                 (FILE * __restrict  )f);
#line 629
                if (! tmp___32) {
#line 629
                  break;
                }
#line 630
                fputs((char const   * __restrict  )(line), (FILE * __restrict  )stdout);
              }
#line 631
              fclose(f);
            }
          }
        }
      }
    }
#line 635
    do_child(command, pw, (char const   *)s->term, (char const   *)s->display, (char const   *)s->auth_proto,
             (char const   *)s->auth_data, (char const   *)(s->tty));
  }
#line 638
  if (pid < 0) {
#line 639
    tmp___33 = __errno_location();
#line 639
    tmp___34 = strerror(*tmp___33);
#line 639
    packet_disconnect("fork failed: %.100s", tmp___34);
  }
#line 640
  s->pid = pid;
#line 643
  close(ttyfd);
#line 650
  fdout___0 = dup(ptyfd);
#line 651
  if (fdout___0 < 0) {
#line 652
    tmp___35 = __errno_location();
#line 652
    tmp___36 = strerror(*tmp___35);
#line 652
    packet_disconnect("dup #1 failed: %.100s", tmp___36);
  }
#line 655
  ptymaster = dup(ptyfd);
#line 656
  if (ptymaster < 0) {
#line 657
    tmp___37 = __errno_location();
#line 657
    tmp___38 = strerror(*tmp___37);
#line 657
    packet_disconnect("dup #2 failed: %.100s", tmp___38);
  }
#line 658
  s->ptymaster = ptymaster;
#line 661
  if (compat20) {
#line 662
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 664
    server_loop(pid, ptyfd, fdout___0, -1);
#line 666
    session_pty_cleanup(s);
  }
#line 668
  return;
}
}
#line 674 "session.c"
void child_set_env(char ***envp , unsigned int *envsizep , char const   *name , char const   *value ) 
{ unsigned int i ;
  unsigned int namelen ;
  char **env ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;

  {
#line 686
  env = *envp;
#line 687
  namelen = strlen(name);
#line 688
  i = 0U;
#line 688
  while (*(env + i)) {
#line 689
    if (0) {
#line 689
      if (0) {
#line 689
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 689
        __s2_len___0 = strlen(name);
#line 689
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 689
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 689
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 689
              tmp___22 = 1;
            } else {
#line 689
              if (__s2_len___0 >= 4U) {
#line 689
                tmp___22 = 1;
              } else {
#line 689
                tmp___22 = 0;
              }
            }
          } else {
#line 689
            tmp___22 = 0;
          }
        }
#line 689
        if (tmp___22) {
#line 689
          tmp___18 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 689
          tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 689
          tmp___18 = tmp___21;
        }
      } else {
#line 689
        tmp___21 = __builtin_strcmp((char const   *)*(env + i), name);
#line 689
        tmp___18 = tmp___21;
      }
#line 689
      tmp___12 = tmp___18;
    } else {
#line 689
      tmp___12 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 689
    if (tmp___12 == 0) {
#line 689
      if ((int )*(*(env + i) + namelen) == 61) {
#line 690
        break;
      }
    }
#line 688
    i ++;
  }
#line 691
  if (*(env + i)) {
#line 693
    xfree((void *)*(env + i));
  } else {
#line 696
    if (i >= *envsizep - 1U) {
#line 697
      *envsizep += 50U;
#line 698
      tmp___25 = xrealloc((void *)env, *envsizep * sizeof(char *));
#line 698
      *envp = (char **)tmp___25;
#line 698
      env = *envp;
    }
#line 701
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 705
  tmp___26 = strlen(name);
#line 705
  tmp___27 = strlen(value);
#line 705
  tmp___28 = xmalloc(((tmp___26 + 1U) + tmp___27) + 1U);
#line 705
  *(env + i) = (char *)tmp___28;
#line 706
  tmp___29 = strlen(name);
#line 706
  tmp___30 = strlen(value);
#line 706
  snprintf((char * __restrict  )*(env + i), ((tmp___29 + 1U) + tmp___30) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 707
  return;
}
}
#line 715 "session.c"
void read_environment_file(char ***env , unsigned int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  char *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 723
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 724
  if (! f) {
#line 725
    return;
  }
#line 727
  while (1) {
#line 727
    tmp___5 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 727
    if (! tmp___5) {
#line 727
      break;
    }
#line 728
    cp = buf___1;
#line 728
    while (1) {
#line 728
      if (! ((int )*cp == 32)) {
#line 728
        if (! ((int )*cp == 9)) {
#line 728
          break;
        }
      }
#line 728
      cp ++;
    }
#line 730
    if (! *cp) {
#line 731
      continue;
    } else {
#line 730
      if ((int )*cp == 35) {
#line 731
        continue;
      } else {
#line 730
        if ((int )*cp == 10) {
#line 731
          continue;
        }
      }
    }
#line 732
    tmp___2 = __builtin_strchr(cp, '\n');
#line 732
    if (tmp___2) {
#line 733
      tmp___0 = __builtin_strchr(cp, '\n');
#line 733
      *tmp___0 = (char )'\000';
    }
#line 734
    tmp___4 = __builtin_strchr(cp, '=');
#line 734
    value = tmp___4;
#line 735
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 736
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line in %.100s: %.200s\n",
              filename, buf___1);
#line 737
      continue;
    }
#line 740
    *value = (char )'\000';
#line 741
    value ++;
#line 742
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 744
  fclose(f);
#line 745
  return;
}
}
#line 751 "session.c"
void do_pam_environment(char ***env , int *envsize ) 
{ char *equals ;
  char var_name[512] ;
  char var_val[512] ;
  char **pam_env ;
  int i ;
  size_t tmp ;

  {
#line 757
  pam_env = fetch_pam_environment();
#line 757
  if ((unsigned int )pam_env == (unsigned int )((void *)0)) {
#line 758
    return;
  }
#line 760
  i = 0;
#line 760
  while ((unsigned int )*(pam_env + i) != (unsigned int )((void *)0)) {
#line 761
    equals = strstr((char const   *)*(pam_env + i), "=");
#line 761
    if ((unsigned int )equals == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 764
    tmp = strlen((char const   *)*(pam_env + i));
#line 764
    if (tmp < sizeof(var_name) - 1U) {
#line 765
      memset((void *)(var_name), '\000', sizeof(var_name));
#line 766
      memset((void *)(var_val), '\000', sizeof(var_val));
#line 768
      __builtin_strncpy(var_name, (char const   *)*(pam_env + i), (unsigned int )(equals - *(pam_env + i)));
#line 769
      strcpy((char * __restrict  )(var_val), (char const   * __restrict  )(equals + 1));
#line 771
      debug("PAM environment: %s=%s", var_name, var_val);
#line 773
      child_set_env(env, (unsigned int *)envsize, (char const   *)(var_name), (char const   *)(var_val));
    }
    __Cont: /* CIL Label */ 
#line 760
    i ++;
  }
#line 776
  return;
}
}
#line 794
extern char **environ ;
#line 784 "session.c"
void do_child(char const   *command , struct passwd *pw , char const   *term , char const   *display ,
              char const   *auth_proto , char const   *auth_data , char const   *ttyname___0 ) 
{ char const   *shell ;
  char const   *cp ;
  char buf___1[256] ;
  FILE *f ;
  unsigned int envsize ;
  unsigned int i ;
  char **env ;
  struct stat st ;
  char *argv[10] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct envstring *ce ;
  char *s ;
  int i___0 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char buf___2[256] ;
  char *mailbox ;
  struct stat mailstat ;
  int tmp___27 ;
  char const   *tmp___28 ;

  {
#line 789
  cp = (char const   *)((void *)0);
#line 811
  tmp___1 = setlogin((char const   *)pw->pw_name);
#line 811
  if (tmp___1 < 0) {
#line 812
    tmp = __errno_location();
#line 812
    tmp___0 = strerror(*tmp);
#line 812
    error("setlogin failed: %s", tmp___0);
  }
#line 817
  if (! options.use_login) {
#line 818
    tmp___4 = getuid();
#line 818
    if (tmp___4 == 0U) {
      goto _L;
    } else {
#line 818
      tmp___5 = geteuid();
#line 818
      if (tmp___5 == 0U) {
        _L: /* CIL Label */ 
#line 819
        tmp___2 = setgid(pw->pw_gid);
#line 819
        if (tmp___2 < 0) {
#line 820
          perror("setgid");
#line 821
          exit(1);
        }
#line 824
        tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
#line 824
        if (tmp___3 < 0) {
#line 825
          perror("initgroups");
#line 826
          exit(1);
        }
#line 828
        endgrent();
#line 831
        permanently_set_uid(pw->pw_uid);
      }
    }
#line 833
    tmp___6 = getuid();
#line 833
    if (tmp___6 != pw->pw_uid) {
#line 834
      fatal("Failed to set uids to %d.", (int )pw->pw_uid);
    } else {
#line 833
      tmp___7 = geteuid();
#line 833
      if (tmp___7 != pw->pw_uid) {
#line 834
        fatal("Failed to set uids to %d.", (int )pw->pw_uid);
      }
    }
  }
#line 840
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 840
    shell = "/bin/sh";
  } else {
#line 840
    shell = (char const   *)pw->pw_shell;
  }
#line 855
  envsize = 100U;
#line 856
  tmp___8 = xmalloc(envsize * sizeof(char *));
#line 856
  env = (char **)tmp___8;
#line 857
  *(env + 0) = (char *)((void *)0);
#line 859
  if (! options.use_login) {
#line 861
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
#line 862
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
#line 863
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
#line 864
    child_set_env(& env, & envsize, "PATH", "/usr/bin:/bin:/usr/sbin:/sbin");
#line 866
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw->pw_name);
#line 868
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 871
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 873
  tmp___10 = getenv("TZ");
#line 873
  if (tmp___10) {
#line 874
    tmp___9 = getenv("TZ");
#line 874
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___9);
  }
#line 877
  while (custom_environment) {
#line 878
    ce = custom_environment;
#line 879
    s = ce->s;
#line 881
    i___0 = 0;
#line 881
    while (1) {
#line 881
      if ((int )*(s + i___0) != 61) {
#line 881
        if (! *(s + i___0)) {
#line 881
          break;
        }
      } else {
#line 881
        break;
      }
#line 881
      i___0 ++;
    }
#line 882
    if ((int )*(s + i___0) == 61) {
#line 883
      *(s + i___0) = (char)0;
#line 884
      child_set_env(& env, & envsize, (char const   *)s, (char const   *)((s + i___0) + 1));
    }
#line 886
    custom_environment = ce->next;
#line 887
    xfree((void *)ce->s);
#line 888
    xfree((void *)ce);
  }
#line 891
  tmp___11 = get_local_port();
#line 891
  tmp___12 = get_remote_port();
#line 891
  tmp___13 = get_remote_ipaddr();
#line 891
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___13, tmp___12, tmp___11);
#line 893
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 895
  if (ttyname___0) {
#line 896
    child_set_env(& env, & envsize, "SSH_TTY", ttyname___0);
  }
#line 897
  if (term) {
#line 898
    child_set_env(& env, & envsize, "TERM", term);
  }
#line 899
  if (display) {
#line 900
    child_set_env(& env, & envsize, "DISPLAY", display);
  }
#line 925
  do_pam_environment(& env, (int *)(& envsize));
#line 928
  read_environment_file(& env, & envsize, "/etc/environment");
#line 930
  if (xauthfile) {
#line 931
    child_set_env(& env, & envsize, "XAUTHORITY", (char const   *)xauthfile);
  }
#line 932
  tmp___15 = auth_get_socket_name();
#line 932
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 933
    tmp___14 = auth_get_socket_name();
#line 933
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)tmp___14);
  }
#line 937
  if (! options.use_login) {
#line 938
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
             pw->pw_dir);
#line 939
    read_environment_file(& env, & envsize, (char const   *)(buf___1));
  }
#line 941
  if (debug_flag) {
#line 943
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 944
    i = 0U;
#line 944
    while (*(env + i)) {
#line 945
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 944
      i ++;
    }
  }
#line 954
  tmp___19 = packet_get_connection_in();
#line 954
  tmp___20 = packet_get_connection_out();
#line 954
  if (tmp___19 == tmp___20) {
#line 955
    tmp___16 = packet_get_connection_in();
#line 955
    close(tmp___16);
  } else {
#line 957
    tmp___17 = packet_get_connection_in();
#line 957
    close(tmp___17);
#line 958
    tmp___18 = packet_get_connection_out();
#line 958
    close(tmp___18);
  }
#line 965
  channel_close_all();
#line 971
  endpwent();
#line 979
  i = 3U;
#line 979
  while (i < 64U) {
#line 980
    close((int )i);
#line 979
    i ++;
  }
#line 983
  tmp___23 = chdir((char const   *)pw->pw_dir);
#line 983
  if (tmp___23 < 0) {
#line 984
    tmp___21 = __errno_location();
#line 984
    tmp___22 = strerror(*tmp___21);
#line 984
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___22);
  }
#line 991
  environ = env;
#line 997
  if (! options.use_login) {
#line 998
    tmp___25 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 998
    if (tmp___25 >= 0) {
#line 999
      if (debug_flag) {
#line 1000
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                ".ssh/rc");
      }
#line 1002
      f = popen("/bin/sh .ssh/rc", "w");
#line 1003
      if (f) {
#line 1004
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1004
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1005
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                    auth_proto, auth_data);
          }
        }
#line 1006
        pclose(f);
      } else {
#line 1008
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                ".ssh/rc");
      }
    } else {
#line 1009
      tmp___24 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1009
      if (tmp___24 >= 0) {
#line 1010
        if (debug_flag) {
#line 1011
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running /bin/sh %s\n",
                  "/usr/local/etc/sshrc");
        }
#line 1013
        f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1014
        if (f) {
#line 1015
          if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1015
            if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1016
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      auth_proto, auth_data);
            }
          }
#line 1017
          pclose(f);
        } else {
#line 1019
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                  "/usr/local/etc/sshrc");
        }
      } else {
#line 1024
        if ((unsigned int )auth_proto != (unsigned int )((void *)0)) {
#line 1024
          if ((unsigned int )auth_data != (unsigned int )((void *)0)) {
#line 1025
            if (debug_flag) {
#line 1026
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.100s add %.100s %.100s %.100s\n",
                      "/usr/bin//xauth", display, auth_proto, auth_data);
            }
#line 1029
            f = popen("/usr/bin//xauth -q -", "w");
#line 1030
            if (f) {
#line 1031
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                      display, auth_proto, auth_data);
#line 1032
              pclose(f);
            } else {
#line 1034
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s -q -\n",
                      "/usr/bin//xauth");
            }
          }
        }
      }
    }
#line 1040
    tmp___26 = strrchr(shell, '/');
#line 1040
    cp = (char const   *)tmp___26;
#line 1041
    if (cp) {
#line 1042
      cp ++;
    } else {
#line 1044
      cp = shell;
    }
  }
#line 1051
  if (! command) {
#line 1052
    if (! options.use_login) {
#line 1059
      if (ttyname___0) {
#line 1059
        if (options.check_mail) {
#line 1062
          mailbox = getenv("MAIL");
#line 1063
          if ((unsigned int )mailbox != (unsigned int )((void *)0)) {
#line 1064
            tmp___27 = stat((char const   * __restrict  )mailbox, (struct stat * __restrict  )(& mailstat));
#line 1064
            if (tmp___27 != 0) {
#line 1065
              printf((char const   * __restrict  )"No mail.\n");
            } else {
#line 1064
              if (mailstat.st_size == 0L) {
#line 1065
                printf((char const   * __restrict  )"No mail.\n");
              } else {
#line 1066
                if (mailstat.st_mtim.tv_sec < mailstat.st_atim.tv_sec) {
#line 1067
                  printf((char const   * __restrict  )"You have mail.\n");
                } else {
#line 1069
                  printf((char const   * __restrict  )"You have new mail.\n");
                }
              }
            }
          }
        }
      }
#line 1073
      buf___2[0] = (char )'-';
#line 1074
      __builtin_strncpy(buf___2 + 1, cp, sizeof(buf___2) - 1U);
#line 1075
      buf___2[sizeof(buf___2) - 1U] = (char)0;
#line 1078
      argv[0] = buf___2;
#line 1079
      argv[1] = (char *)((void *)0);
#line 1080
      execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1083
      perror(shell);
#line 1084
      exit(1);
    } else {
#line 1089
      tmp___28 = get_remote_ipaddr();
#line 1089
      execl("/usr/bin/login", "login", "-h", tmp___28, "-p", "-f", "--", pw->pw_name,
            (void *)0);
#line 1094
      perror("login");
#line 1095
      exit(1);
    }
  }
#line 1102
  argv[0] = (char *)cp;
#line 1103
  argv[1] = (char *)"-c";
#line 1104
  argv[2] = (char *)command;
#line 1105
  argv[3] = (char *)((void *)0);
#line 1106
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1107
  perror(shell);
#line 1108
  exit(1);
}
}
#line 1115 "session.c"
static int did_init___0  =    0;
#line 1111 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1116
  if (! did_init___0) {
#line 1117
    debug("session_new: init");
#line 1118
    i = 0;
#line 1118
    while (i < 10) {
#line 1119
      sessions[i].used = 0;
#line 1120
      sessions[i].self = i;
#line 1118
      i ++;
    }
#line 1122
    did_init___0 = 1;
  }
#line 1124
  i = 0;
#line 1124
  while (i < 10) {
#line 1125
    s = & sessions[i];
#line 1126
    if (! s->used) {
#line 1127
      s->pid = 0;
#line 1128
      s->extended = 0;
#line 1129
      s->chanid = -1;
#line 1130
      s->ptyfd = -1;
#line 1131
      s->ttyfd = -1;
#line 1132
      s->term = (char *)((void *)0);
#line 1133
      s->pw = (struct passwd *)((void *)0);
#line 1134
      s->display = (char *)((void *)0);
#line 1135
      s->screen = 0;
#line 1136
      s->auth_data = (char *)((void *)0);
#line 1137
      s->auth_proto = (char *)((void *)0);
#line 1138
      s->used = 1;
#line 1139
      s->pw = (struct passwd *)((void *)0);
#line 1140
      debug("session_new: session %d", i);
#line 1141
      return (s);
    }
#line 1124
    i ++;
  }
#line 1144
  return ((Session *)((void *)0));
}
}
#line 1147 "session.c"
void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1151
  i = 0;
#line 1151
  while (i < 10) {
#line 1152
    s = & sessions[i];
#line 1153
    debug("dump: used %d session %d %p channel %d pid %d", s->used, s->self, s, s->chanid,
          s->pid);
#line 1151
    i ++;
  }
#line 1160
  return;
}
}
#line 1162 "session.c"
int session_open(int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1165
  tmp = session_new();
#line 1165
  s = tmp;
#line 1166
  debug("session_open: channel %d", chanid);
#line 1167
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1168
    error("no more sessions");
#line 1169
    return (0);
  }
#line 1171
  s->pw = auth_get_user();
#line 1172
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1173
    fatal("no user for session %i", s->self);
  }
#line 1174
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1175
  s->chanid = chanid;
#line 1176
  return (1);
}
}
#line 1179 "session.c"
Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1183
  i = 0;
#line 1183
  while (i < 10) {
#line 1184
    s = & sessions[i];
#line 1185
    if (s->used) {
#line 1185
      if (s->chanid == id) {
#line 1186
        debug("session_by_channel: session %d channel %d", i, id);
#line 1187
        return (s);
      }
    }
#line 1183
    i ++;
  }
#line 1190
  debug("session_by_channel: unknown channel %d", id);
#line 1191
  session_dump();
#line 1192
  return ((Session *)((void *)0));
}
}
#line 1195 "session.c"
Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1199
  debug("session_by_pid: pid %d", pid);
#line 1200
  i = 0;
#line 1200
  while (i < 10) {
#line 1201
    s = & sessions[i];
#line 1202
    if (s->used) {
#line 1202
      if (s->pid == pid) {
#line 1203
        return (s);
      }
    }
#line 1200
    i ++;
  }
#line 1205
  error("session_by_pid: unknown pid %d", pid);
#line 1206
  session_dump();
#line 1207
  return ((Session *)((void *)0));
}
}
#line 1210 "session.c"
int session_window_change_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 1213
  tmp = packet_get_int();
#line 1213
  s->col = (int )tmp;
#line 1214
  tmp___0 = packet_get_int();
#line 1214
  s->row = (int )tmp___0;
#line 1215
  tmp___1 = packet_get_int();
#line 1215
  s->xpixel = (int )tmp___1;
#line 1216
  tmp___2 = packet_get_int();
#line 1216
  s->ypixel = (int )tmp___2;
#line 1217
  while (1) {
#line 1217
    tmp___3 = packet_remaining();
#line 1217
    _len = tmp___3;
#line 1217
    if (_len > 0) {
#line 1217
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1217);
#line 1217
      packet_disconnect("Packet integrity error.");
    }
#line 1217
    break;
  }
#line 1218
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1219
  return (1);
}
}
#line 1222 "session.c"
int session_pty_req(Session *s ) 
{ unsigned int len ;
  char *term_modes ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int _len ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1228
  if (s->ttyfd != -1) {
#line 1229
    return (0);
  }
#line 1230
  s->term = packet_get_string(& len);
#line 1231
  tmp = packet_get_int();
#line 1231
  s->col = (int )tmp;
#line 1232
  tmp___0 = packet_get_int();
#line 1232
  s->row = (int )tmp___0;
#line 1233
  tmp___1 = packet_get_int();
#line 1233
  s->xpixel = (int )tmp___1;
#line 1234
  tmp___2 = packet_get_int();
#line 1234
  s->ypixel = (int )tmp___2;
#line 1235
  term_modes = packet_get_string(& len);
#line 1236
  while (1) {
#line 1236
    tmp___3 = packet_remaining();
#line 1236
    _len = tmp___3;
#line 1236
    if (_len > 0) {
#line 1236
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1236);
#line 1236
      packet_disconnect("Packet integrity error.");
    }
#line 1236
    break;
  }
#line 1238
  if (0) {
#line 1238
    __s1_len = strlen((char const   *)s->term);
#line 1238
    __s2_len = strlen("");
#line 1238
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1238
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1238
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1238
          tmp___13 = 1;
        } else {
#line 1238
          if (__s2_len >= 4U) {
#line 1238
            tmp___13 = 1;
          } else {
#line 1238
            tmp___13 = 0;
          }
        }
      } else {
#line 1238
        tmp___13 = 0;
      }
    }
#line 1238
    if (tmp___13) {
#line 1238
      tmp___9 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1238
      tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1238
      tmp___9 = tmp___12;
    }
  } else {
#line 1238
    tmp___12 = __builtin_strcmp((char const   *)s->term, "");
#line 1238
    tmp___9 = tmp___12;
  }
#line 1238
  if (tmp___9 == 0) {
#line 1239
    xfree((void *)s->term);
#line 1240
    s->term = (char *)((void *)0);
  }
#line 1243
  tmp___14 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
#line 1243
  if (! tmp___14) {
#line 1244
    xfree((void *)s->term);
#line 1245
    s->term = (char *)((void *)0);
#line 1246
    s->ptyfd = -1;
#line 1247
    s->ttyfd = -1;
#line 1248
    error("session_pty_req: session %d alloc failed", s->self);
#line 1249
    xfree((void *)term_modes);
#line 1250
    return (0);
  }
#line 1252
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1257
  fatal_add_cleanup(& pty_cleanup_proc, (void *)s);
#line 1258
  pty_setowner(s->pw, (char const   *)(s->tty));
#line 1260
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1262
  session_proctitle(s);
#line 1265
  xfree((void *)term_modes);
#line 1266
  return (1);
}
}
#line 1269 "session.c"
int session_subsystem_req(Session *s ) 
{ unsigned int len ;
  int success ;
  char *subsys ;
  char *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 1273
  success = 0;
#line 1274
  tmp = packet_get_string(& len);
#line 1274
  subsys = tmp;
#line 1276
  while (1) {
#line 1276
    tmp___0 = packet_remaining();
#line 1276
    _len = tmp___0;
#line 1276
    if (_len > 0) {
#line 1276
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1276);
#line 1276
      packet_disconnect("Packet integrity error.");
    }
#line 1276
    break;
  }
#line 1277
  log("subsystem request for %s", subsys);
#line 1279
  xfree((void *)subsys);
#line 1280
  return (success);
}
}
#line 1283 "session.c"
int session_x11_req(Session *s ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1286
  if (! options.x11_forwarding) {
#line 1287
    debug("X11 forwarding disabled in server configuration file.");
#line 1288
    return (0);
  }
#line 1290
  if ((unsigned int )xauthfile != (unsigned int )((void *)0)) {
#line 1291
    debug("X11 fwd already started.");
#line 1292
    return (0);
  }
#line 1295
  debug("Received request for X11 forwarding with auth spoofing.");
#line 1296
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1297
    packet_disconnect("Protocol error: X11 display already set.");
  }
#line 1299
  tmp = packet_get_char();
#line 1299
  s->single_connection = (int )tmp;
#line 1300
  s->auth_proto = packet_get_string((unsigned int *)((void *)0));
#line 1301
  s->auth_data = packet_get_string((unsigned int *)((void *)0));
#line 1302
  tmp___0 = packet_get_int();
#line 1302
  s->screen = (int )tmp___0;
#line 1303
  while (1) {
#line 1303
    tmp___1 = packet_remaining();
#line 1303
    _len = tmp___1;
#line 1303
    if (_len > 0) {
#line 1303
      log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
          1303);
#line 1303
      packet_disconnect("Packet integrity error.");
    }
#line 1303
    break;
  }
#line 1305
  s->display = x11_create_display_inet(s->screen, options.x11_display_offset);
#line 1306
  if ((unsigned int )s->display == (unsigned int )((void *)0)) {
#line 1307
    xfree((void *)s->auth_proto);
#line 1308
    xfree((void *)s->auth_data);
#line 1309
    return (0);
  }
#line 1311
  tmp___2 = xmalloc(4096U);
#line 1311
  xauthfile = (char *)tmp___2;
#line 1312
  strlcpy(xauthfile, "/tmp/ssh-XXXXXXXX", 4096U);
#line 1313
  temporarily_use_uid((s->pw)->pw_uid);
#line 1314
  tmp___5 = mkdtemp(xauthfile);
#line 1314
  if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 1315
    restore_uid();
#line 1316
    tmp___3 = __errno_location();
#line 1316
    tmp___4 = strerror(*tmp___3);
#line 1316
    error("private X11 dir: mkdtemp %s failed: %s", xauthfile, tmp___4);
#line 1318
    xfree((void *)xauthfile);
#line 1319
    xauthfile = (char *)((void *)0);
#line 1320
    xfree((void *)s->auth_proto);
#line 1321
    xfree((void *)s->auth_data);
#line 1323
    return (0);
  }
#line 1325
  strlcat(xauthfile, "/cookies", 4096U);
#line 1326
  open((char const   *)xauthfile, 194, 384);
#line 1327
  restore_uid();
#line 1328
  fatal_add_cleanup(& xauthfile_cleanup_proc, (void *)s);
#line 1329
  return (1);
}
}
#line 1332 "session.c"
void session_input_channel_req(int id , void *arg ) 
{ unsigned int len ;
  int reply ;
  int success ;
  char *rtype ;
  Session *s ;
  Channel *c ;
  unsigned int tmp ;
  int _len ;
  int tmp___0 ;
  char *command ;
  char *tmp___1 ;
  int _len___0 ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;

  {
#line 1337
  success = 0;
#line 1342
  rtype = packet_get_string(& len);
#line 1343
  tmp = packet_get_char();
#line 1343
  reply = (int )tmp;
#line 1345
  s = session_by_channel(id);
#line 1346
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1347
    fatal("session_input_channel_req: channel %d: no session", id);
  }
#line 1348
  c = channel_lookup(id);
#line 1349
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1350
    fatal("session_input_channel_req: channel %d: bad channel", id);
  }
#line 1352
  debug("session_input_channel_req: session %d channel %d request %s reply %d", s->self,
        id, rtype, reply);
#line 1359
  if (c->type == 10) {
#line 1360
    if (0) {
#line 1360
      __s1_len___3 = strlen((char const   *)rtype);
#line 1360
      __s2_len___3 = strlen("shell");
#line 1360
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___8;
      } else {
#line 1360
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 1360
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 1360
            tmp___52 = 1;
          } else {
#line 1360
            if (__s2_len___3 >= 4U) {
#line 1360
              tmp___52 = 1;
            } else {
#line 1360
              tmp___52 = 0;
            }
          }
        } else {
#line 1360
          tmp___52 = 0;
        }
      }
#line 1360
      if (tmp___52) {
#line 1360
        tmp___48 = __builtin_strcmp((char const   *)rtype, "shell");
      } else {
#line 1360
        tmp___51 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1360
        tmp___48 = tmp___51;
      }
    } else {
#line 1360
      tmp___51 = __builtin_strcmp((char const   *)rtype, "shell");
#line 1360
      tmp___48 = tmp___51;
    }
#line 1360
    if (tmp___48 == 0) {
#line 1361
      while (1) {
#line 1361
        tmp___0 = packet_remaining();
#line 1361
        _len = tmp___0;
#line 1361
        if (_len > 0) {
#line 1361
          log("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
              1361);
#line 1361
          packet_disconnect("Packet integrity error.");
        }
#line 1361
        break;
      }
#line 1362
      s->extended = 1;
#line 1363
      if (s->ttyfd == -1) {
#line 1364
        do_exec_no_pty(s, (char const   *)((void *)0), s->pw);
      } else {
#line 1366
        do_exec_pty(s, (char const   *)((void *)0), s->pw);
      }
#line 1367
      success = 1;
    } else {
#line 1368
      if (0) {
#line 1368
        __s1_len___2 = strlen((char const   *)rtype);
#line 1368
        __s2_len___2 = strlen("exec");
#line 1368
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___6;
        } else {
#line 1368
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 1368
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 1368
              tmp___42 = 1;
            } else {
#line 1368
              if (__s2_len___2 >= 4U) {
#line 1368
                tmp___42 = 1;
              } else {
#line 1368
                tmp___42 = 0;
              }
            }
          } else {
#line 1368
            tmp___42 = 0;
          }
        }
#line 1368
        if (tmp___42) {
#line 1368
          tmp___38 = __builtin_strcmp((char const   *)rtype, "exec");
        } else {
#line 1368
          tmp___41 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1368
          tmp___38 = tmp___41;
        }
      } else {
#line 1368
        tmp___41 = __builtin_strcmp((char const   *)rtype, "exec");
#line 1368
        tmp___38 = tmp___41;
      }
#line 1368
      if (tmp___38 == 0) {
#line 1369
        tmp___1 = packet_get_string(& len);
#line 1369
        command = tmp___1;
#line 1370
        while (1) {
#line 1370
          tmp___2 = packet_remaining();
#line 1370
          _len___0 = tmp___2;
#line 1370
          if (_len___0 > 0) {
#line 1370
            log("Packet integrity error (%d bytes remaining) at %s:%d", _len___0,
                "session.c", 1370);
#line 1370
            packet_disconnect("Packet integrity error.");
          }
#line 1370
          break;
        }
#line 1371
        s->extended = 1;
#line 1372
        if (s->ttyfd == -1) {
#line 1373
          do_exec_no_pty(s, (char const   *)command, s->pw);
        } else {
#line 1375
          do_exec_pty(s, (char const   *)command, s->pw);
        }
#line 1376
        xfree((void *)command);
#line 1377
        success = 1;
      } else {
#line 1378
        if (0) {
#line 1378
          __s1_len___1 = strlen((char const   *)rtype);
#line 1378
          __s2_len___1 = strlen("pty-req");
#line 1378
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___4;
          } else {
#line 1378
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 1378
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 1378
                tmp___32 = 1;
              } else {
#line 1378
                if (__s2_len___1 >= 4U) {
#line 1378
                  tmp___32 = 1;
                } else {
#line 1378
                  tmp___32 = 0;
                }
              }
            } else {
#line 1378
              tmp___32 = 0;
            }
          }
#line 1378
          if (tmp___32) {
#line 1378
            tmp___28 = __builtin_strcmp((char const   *)rtype, "pty-req");
          } else {
#line 1378
            tmp___31 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1378
            tmp___28 = tmp___31;
          }
        } else {
#line 1378
          tmp___31 = __builtin_strcmp((char const   *)rtype, "pty-req");
#line 1378
          tmp___28 = tmp___31;
        }
#line 1378
        if (tmp___28 == 0) {
#line 1379
          success = session_pty_req(s);
        } else {
#line 1380
          if (0) {
#line 1380
            __s1_len___0 = strlen((char const   *)rtype);
#line 1380
            __s2_len___0 = strlen("x11-req");
#line 1380
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___2;
            } else {
#line 1380
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 1380
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 1380
                  tmp___22 = 1;
                } else {
#line 1380
                  if (__s2_len___0 >= 4U) {
#line 1380
                    tmp___22 = 1;
                  } else {
#line 1380
                    tmp___22 = 0;
                  }
                }
              } else {
#line 1380
                tmp___22 = 0;
              }
            }
#line 1380
            if (tmp___22) {
#line 1380
              tmp___18 = __builtin_strcmp((char const   *)rtype, "x11-req");
            } else {
#line 1380
              tmp___21 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1380
              tmp___18 = tmp___21;
            }
          } else {
#line 1380
            tmp___21 = __builtin_strcmp((char const   *)rtype, "x11-req");
#line 1380
            tmp___18 = tmp___21;
          }
#line 1380
          if (tmp___18 == 0) {
#line 1381
            success = session_x11_req(s);
          } else {
#line 1382
            if (0) {
#line 1382
              __s1_len = strlen((char const   *)rtype);
#line 1382
              __s2_len = strlen("subsystem");
#line 1382
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___0;
              } else {
#line 1382
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
#line 1382
                  if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 1382
                    tmp___12 = 1;
                  } else {
#line 1382
                    if (__s2_len >= 4U) {
#line 1382
                      tmp___12 = 1;
                    } else {
#line 1382
                      tmp___12 = 0;
                    }
                  }
                } else {
#line 1382
                  tmp___12 = 0;
                }
              }
#line 1382
              if (tmp___12) {
#line 1382
                tmp___8 = __builtin_strcmp((char const   *)rtype, "subsystem");
              } else {
#line 1382
                tmp___11 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1382
                tmp___8 = tmp___11;
              }
            } else {
#line 1382
              tmp___11 = __builtin_strcmp((char const   *)rtype, "subsystem");
#line 1382
              tmp___8 = tmp___11;
            }
#line 1382
            if (tmp___8 == 0) {
#line 1383
              success = session_subsystem_req(s);
            }
          }
        }
      }
    }
  }
#line 1386
  if (0) {
#line 1386
    __s1_len___4 = strlen((char const   *)rtype);
#line 1386
    __s2_len___4 = strlen("window-change");
#line 1386
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___10;
    } else {
#line 1386
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 1386
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 1386
          tmp___62 = 1;
        } else {
#line 1386
          if (__s2_len___4 >= 4U) {
#line 1386
            tmp___62 = 1;
          } else {
#line 1386
            tmp___62 = 0;
          }
        }
      } else {
#line 1386
        tmp___62 = 0;
      }
    }
#line 1386
    if (tmp___62) {
#line 1386
      tmp___58 = __builtin_strcmp((char const   *)rtype, "window-change");
    } else {
#line 1386
      tmp___61 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1386
      tmp___58 = tmp___61;
    }
  } else {
#line 1386
    tmp___61 = __builtin_strcmp((char const   *)rtype, "window-change");
#line 1386
    tmp___58 = tmp___61;
  }
#line 1386
  if (tmp___58 == 0) {
#line 1387
    success = session_window_change_req(s);
  }
#line 1390
  if (reply) {
#line 1391
    if (success) {
#line 1391
      tmp___63 = 99;
    } else {
#line 1391
      tmp___63 = 100;
    }
#line 1391
    packet_start(tmp___63);
#line 1393
    packet_put_int((unsigned int )c->remote_id);
#line 1394
    packet_send();
  }
#line 1396
  xfree((void *)rtype);
#line 1397
  return;
}
}
#line 1399 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 1402
  if (! compat20) {
#line 1403
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 1408
  if (s->chanid == -1) {
#line 1409
    fatal("no channel for session %d", s->self);
  }
#line 1410
  if (fderr___0 == -1) {
#line 1410
    tmp = 0;
  } else {
#line 1410
    tmp = 1;
  }
#line 1410
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp);
#line 1413
  return;
}
}
#line 1415 "session.c"
void session_pty_cleanup(Session *s ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1418
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1419
    return;
  } else {
#line 1418
    if (s->ttyfd == -1) {
#line 1419
      return;
    }
  }
#line 1421
  debug("session_pty_cleanup: session %i release %s", s->self, s->tty);
#line 1424
  fatal_remove_cleanup(& pty_cleanup_proc, (void *)s);
#line 1427
  record_logout(s->pid, (char const   *)(s->tty));
#line 1430
  pty_release((char const   *)(s->tty));
#line 1437
  tmp___1 = close(s->ptymaster);
#line 1437
  if (tmp___1 < 0) {
#line 1438
    tmp = __errno_location();
#line 1438
    tmp___0 = strerror(*tmp);
#line 1438
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 1439
  return;
}
}
#line 1441 "session.c"
void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion_76 __constr_expr_0 ;
  union __anonunion_77___0 __constr_expr_1 ;
  union __anonunion_78___0 __constr_expr_2 ;
  union __anonunion_79___0 __constr_expr_3 ;
  union __anonunion_80___0 __constr_expr_4 ;

  {
#line 1445
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1446
    fatal("session_close: no session");
  }
#line 1447
  c = channel_lookup(s->chanid);
#line 1448
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1449
    fatal("session_close: session %d: no channel %d", s->self, s->chanid);
  }
#line 1451
  debug("session_exit_message: session %d channel %d pid %d", s->self, s->chanid,
        s->pid);
#line 1454
  __constr_expr_4.__in = status;
#line 1454
  if ((__constr_expr_4.__i & 127) == 0) {
#line 1455
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 1457
    __constr_expr_0.__in = status;
#line 1457
    packet_put_int((unsigned int )((__constr_expr_0.__i & 65280) >> 8));
#line 1458
    packet_send();
  } else {
#line 1459
    __constr_expr_3.__in = status;
#line 1459
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 1460
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 1462
      __constr_expr_1.__in = status;
#line 1462
      packet_put_int((unsigned int )(__constr_expr_1.__i & 127));
#line 1463
      __constr_expr_2.__in = status;
#line 1463
      packet_put_char(__constr_expr_2.__i & 128);
#line 1464
      packet_put_cstring("");
#line 1465
      packet_put_cstring("");
#line 1466
      packet_send();
    } else {
#line 1469
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 1473
  debug("session_exit_message: release channel %d", s->chanid);
#line 1474
  channel_cancel_cleanup(s->chanid);
#line 1481
  if (c->ostate != 128) {
#line 1482
    (*chan_write_failed)(c);
  }
#line 1483
  s->chanid = -1;
#line 1484
  return;
}
}
#line 1486 "session.c"
void session_free(Session *s ) 
{ 

  {
#line 1489
  debug("session_free: session %d pid %d", s->self, s->pid);
#line 1490
  if (s->term) {
#line 1491
    xfree((void *)s->term);
  }
#line 1492
  if (s->display) {
#line 1493
    xfree((void *)s->display);
  }
#line 1494
  if (s->auth_data) {
#line 1495
    xfree((void *)s->auth_data);
  }
#line 1496
  if (s->auth_proto) {
#line 1497
    xfree((void *)s->auth_proto);
  }
#line 1498
  s->used = 0;
#line 1499
  return;
}
}
#line 1501 "session.c"
void session_close(Session *s ) 
{ 

  {
#line 1504
  session_pty_cleanup(s);
#line 1505
  session_free(s);
#line 1506
  session_proctitle(s);
#line 1507
  return;
}
}
#line 1509 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1512
  tmp = session_by_pid(pid);
#line 1512
  s = tmp;
#line 1513
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1514
    debug("session_close_by_pid: no session for pid %d", s->pid);
#line 1515
    return;
  }
#line 1517
  if (s->chanid != -1) {
#line 1518
    session_exit_message(s, status);
  }
#line 1519
  session_close(s);
#line 1520
  return;
}
}
#line 1526 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1529
  tmp = session_by_channel(id);
#line 1529
  s = tmp;
#line 1530
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1531
    debug("session_close_by_channel: no session for channel %d", id);
#line 1532
    return;
  }
#line 1535
  channel_cancel_cleanup(s->chanid);
#line 1536
  s->chanid = -1;
#line 1538
  debug("session_close_by_channel: channel %d kill %d", id, s->pid);
#line 1539
  if (s->pid == 0) {
#line 1541
    session_close(s);
  } else {
#line 1544
    if (s->ttyfd == -1) {
#line 1544
      tmp___2 = 15;
    } else {
#line 1544
      tmp___2 = 1;
    }
#line 1544
    tmp___3 = kill(s->pid, tmp___2);
#line 1544
    if (tmp___3 < 0) {
#line 1545
      tmp___0 = __errno_location();
#line 1545
      tmp___1 = strerror(*tmp___0);
#line 1545
      error("session_close_by_channel: kill %d: %s", s->pid, tmp___1);
    }
  }
#line 1548
  return;
}
}
#line 1553 "session.c"
static char buf___0[1024]  ;
#line 1550 "session.c"
char *session_tty_list(void) 
{ int i ;
  Session *s ;
  char *tmp ;

  {
#line 1555
  buf___0[0] = (char )'\000';
#line 1556
  i = 0;
#line 1556
  while (i < 10) {
#line 1557
    s = & sessions[i];
#line 1558
    if (s->used) {
#line 1558
      if (s->ttyfd != -1) {
#line 1559
        if ((int )buf___0[0] != 0) {
#line 1560
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 1561
        tmp = strrchr((char const   *)(s->tty), '/');
#line 1561
        strlcat(buf___0, (char const   *)(tmp + 1), sizeof(buf___0));
      }
    }
#line 1556
    i ++;
  }
#line 1564
  if ((int )buf___0[0] == 0) {
#line 1565
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 1566
  return (buf___0);
}
}
#line 1569 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 1572
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1573
    error("no user for session %d", s->self);
  } else {
#line 1575
    tmp = session_tty_list();
#line 1575
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 1576
  return;
}
}
#line 1578 "session.c"
void do_authenticated2(void) 
{ 

  {
#line 1585
  alarm(0U);
#line 1586
  server_loop2();
#line 1587
  if (xauthfile) {
#line 1588
    xauthfile_cleanup_proc((void *)0);
  }
#line 1589
  return;
}
}
