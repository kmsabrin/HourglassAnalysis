/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 71 "/usr/include/openssl/rc4.h"
struct rc4_key_st {
   unsigned int x ;
   unsigned int y ;
   unsigned int data[256] ;
};
#line 71 "/usr/include/openssl/rc4.h"
typedef struct rc4_key_st RC4_KEY;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 302 "/usr/include/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_51 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_52 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_53 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_54 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_55 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_56 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_50 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_51 _kill ;
   struct __anonstruct__timer_52 _timer ;
   struct __anonstruct__rt_53 _rt ;
   struct __anonstruct__sigchld_54 _sigchld ;
   struct __anonstruct__sigfault_55 _sigfault ;
   struct __anonstruct__sigpoll_56 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_50 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_65 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_65 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 141 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 49 "./openbsd-compat/glob.h"
struct dirent;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 20 "./openbsd-compat/port-tun.h"
struct Channel;
#line 19 "./buffer.h"
struct __anonstruct_Buffer_48 {
   u_char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "./buffer.h"
typedef struct __anonstruct_Buffer_48 Buffer;
#line 108 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 63 "./channels.h"
typedef void channel_callback_fn(int  , void * );
#line 64 "./channels.h"
typedef int channel_infilter_fn(struct Channel * , char * , int  );
#line 65 "./channels.h"
typedef u_char *channel_outfilter_fn(struct Channel * , u_char ** , u_int * );
#line 67 "./channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   u_int istate ;
   u_int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int ctl_fd ;
   int isatty ;
   int wfd_isatty ;
   int client_tty ;
   int force_drain ;
   int delayed ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[256] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   u_int remote_window ;
   u_int remote_maxpacket ;
   u_int local_window ;
   u_int local_window_max ;
   u_int local_consumed ;
   u_int local_maxpacket ;
   int extended_usage ;
   int single_connection ;
   char *ctype ;
   channel_callback_fn *confirm ;
   void *confirm_ctx ;
   channel_callback_fn *detach_user ;
   int detach_close ;
   channel_infilter_fn *input_filter ;
   channel_outfilter_fn *output_filter ;
   int datagram ;
};
#line 4 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_57 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 4 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_57 sync_serial_settings;
#line 10 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_58 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 10 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_58 te1_settings;
#line 17 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_59 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 17 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_59 raw_hdlc_proto;
#line 22 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_60 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 22 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_60 fr_proto;
#line 32 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_61 {
   unsigned int dlci ;
};
#line 32 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_61 fr_proto_pvc;
#line 36 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_62 {
   unsigned int dlci ;
   char master[16] ;
};
#line 36 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_62 fr_proto_pvc_info;
#line 41 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_63 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 41 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_63 cisco_proto;
#line 118 "/usr/include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 129 "/usr/include/linux/if.h"
union __anonunion_ifs_ifsu_66 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 129 "/usr/include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_66 ifs_ifsu ;
};
#line 154 "/usr/include/linux/if.h"
union __anonunion_ifr_ifrn_67 {
   char ifrn_name[16] ;
};
#line 154 "/usr/include/linux/if.h"
union __anonunion_ifr_ifru_68 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 154 "/usr/include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_67 ifr_ifrn ;
   union __anonunion_ifr_ifru_68 ifr_ifru ;
};
#line 40 "openbsd-compat/strtonum.c"
struct errval {
   char const   *errstr ;
   int err ;
};
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128U - 2U * sizeof(__uint32_t )] ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 87
struct sockaddr_in6;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 193 "/usr/include/netinet/in.h"
union __anonunion_in6_u_23 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_23 in6_u ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_31 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_31 HEADER;
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_44 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_44 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_45 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_47 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_46 {
   char pad[52] ;
   struct __anonstruct__ext_47 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   char unused[3] ;
   struct __anonstruct_sort_list_45 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *ns , u_char const   **query ,
                            int *querylen , u_char *ans , int anssiz , int *resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *ns , u_char const   *query ,
                            int querylen , u_char *ans , int anssiz , int *resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_46 _u ;
};
#line 88 "./openbsd-compat/getrrsetbyname.h"
struct rdatainfo {
   unsigned int rdi_length ;
   unsigned char *rdi_data ;
};
#line 93 "./openbsd-compat/getrrsetbyname.h"
struct rrsetinfo {
   unsigned int rri_flags ;
   unsigned int rri_rdclass ;
   unsigned int rri_rdtype ;
   unsigned int rri_ttl ;
   unsigned int rri_nrdatas ;
   unsigned int rri_nsigs ;
   char *rri_name ;
   struct rdatainfo *rri_rdatas ;
   struct rdatainfo *rri_sigs ;
};
#line 148 "openbsd-compat/getrrsetbyname.c"
struct dns_query {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   struct dns_query *next ;
};
#line 155 "openbsd-compat/getrrsetbyname.c"
struct dns_rr {
   char *name ;
   u_int16_t type ;
   u_int16_t class ;
   u_int16_t ttl ;
   u_int16_t size ;
   void *rdata ;
   struct dns_rr *next ;
};
#line 165 "openbsd-compat/getrrsetbyname.c"
struct dns_response {
   HEADER header ;
   struct dns_query *query ;
   struct dns_rr *answer ;
   struct dns_rr *authority ;
   struct dns_rr *additional ;
};
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 173 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 49 "./openbsd-compat/glob.h"
struct __anonstruct_glob_t_30 {
   int gl_pathc ;
   int gl_matchc ;
   int gl_offs ;
   int gl_flags ;
   char **gl_pathv ;
   int (*gl_errfunc)(char const   * , int  ) ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 49 "./openbsd-compat/glob.h"
typedef struct __anonstruct_glob_t_30 glob_t;
#line 118 "openbsd-compat/glob.c"
typedef u_short Char;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 30 "acss.h"
struct acss_key_st {
   unsigned int lfsr17 ;
   unsigned int lfsr25 ;
   unsigned int lfsrsum ;
   unsigned char seed[5] ;
   unsigned char data[5] ;
   unsigned char subkey[5] ;
   int encrypt ;
   int mode ;
   int seeded ;
   int subkey_avilable ;
};
#line 30 "acss.h"
typedef struct acss_key_st ACSS_KEY;
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_un;
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 285 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 296 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 320 "/usr/include/openssl/bn.h"
union __anonunion_cb_49 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 320 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_49 cb ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 106 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 106 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 112 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 139 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "key.h"
struct Key;
#line 32 "key.h"
typedef struct Key Key;
#line 51 "key.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 63 "authfd.h"
struct __anonstruct_AuthenticationConnection_75 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 63 "authfd.h"
typedef struct __anonstruct_AuthenticationConnection_75 AuthenticationConnection;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 116
struct evp_cipher_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 117
struct evp_cipher_ctx_st;
#line 117 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 120
struct evp_pkey_st;
#line 120 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 206 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 206 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 222 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 222 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 488 "/usr/include/openssl/asn1.h"
union __anonunion_value_51 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 488 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_51 value ;
};
#line 488 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 126 "/usr/include/openssl/evp.h"
union __anonunion_pkey_52 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 126 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_52 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 297 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 357 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 95 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 113 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 529 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 61 "cipher.h"
struct Cipher;
#line 61 "cipher.h"
typedef struct Cipher Cipher;
#line 62
struct CipherContext;
#line 62 "cipher.h"
typedef struct CipherContext CipherContext;
#line 65 "cipher.h"
struct CipherContext {
   int plaintext ;
   EVP_CIPHER_CTX evp ;
   Cipher *cipher ;
};
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 61 "channels.h"
typedef struct Channel Channel;
#line 108 "channels.c"
struct __anonstruct_ForwardPermission_58 {
   char *host_to_connect ;
   u_short port_to_connect ;
   u_short listen_port ;
};
#line 108 "channels.c"
typedef struct __anonstruct_ForwardPermission_58 ForwardPermission;
#line 740 "channels.c"
typedef void chan_fn(Channel *c , fd_set *readset , fd_set *writeset );
#line 956 "channels.c"
struct __anonstruct_s4_req_59 {
   u_int8_t version ;
   u_int8_t command ;
   u_int16_t dest_port ;
   struct in_addr dest_addr ;
};
#line 1032 "channels.c"
struct __anonstruct_s5_req_60 {
   u_int8_t version ;
   u_int8_t command ;
   u_int8_t reserved ;
   u_int8_t atyp ;
};
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 60 "cipher.c"
struct Cipher {
   char *name ;
   int number ;
   u_int block_size ;
   u_int key_len ;
   u_int discard_len ;
   EVP_CIPHER const   *(*evptype)(void) ;
};
#line 29 "cipher-acss.c"
struct __anonstruct_EVP_ACSS_KEY_53 {
   ACSS_KEY ks ;
};
#line 29 "cipher-acss.c"
typedef struct __anonstruct_EVP_ACSS_KEY_53 EVP_ACSS_KEY;
#line 74 "/usr/include/openssl/aes.h"
struct aes_key_st {
   unsigned int rd_key[60] ;
   int rounds ;
};
#line 82 "/usr/include/openssl/aes.h"
typedef struct aes_key_st AES_KEY;
#line 39 "cipher-ctr.c"
struct ssh_aes_ctr_ctx {
   AES_KEY aes_ctx ;
   u_char aes_counter[16] ;
};
#line 54 "cipher-3des1.c"
struct ssh1_3des_ctx {
   EVP_CIPHER_CTX k1 ;
   EVP_CIPHER_CTX k2 ;
   EVP_CIPHER_CTX k3 ;
};
#line 62 "compat.c"
struct __anonstruct_check_52 {
   char *pat ;
   int bugs ;
};
#line 261 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 263 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 264 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 270 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 279 "/usr/include/zconf.h"
typedef void *voidpf;
#line 80 "/usr/include/zlib.h"
struct internal_state;
#line 82 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 82 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 103 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1346 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 37 "log.h"
enum __anonenum_LogLevel_51 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
#line 37 "log.h"
typedef enum __anonenum_LogLevel_51 LogLevel;
#line 118 "/usr/include/openssl/ossl_typ.h"
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 220 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 280 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 75 "/usr/include/openssl/hmac.h"
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
#line 75 "/usr/include/openssl/hmac.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 17 "hostfile.h"
enum __anonenum_HostStatus_54 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2,
    HOST_FOUND = 3
} ;
#line 17 "hostfile.h"
typedef enum __anonenum_HostStatus_54 HostStatus;
#line 19 "log.h"
typedef int SyslogFacility;
#line 67 "log.c"
struct __anonstruct_log_facilities_55 {
   char const   *name ;
   SyslogFacility val ;
};
#line 88 "log.c"
struct __anonstruct_log_levels_56 {
   char const   *name ;
   LogLevel val ;
};
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 73 "kex.h"
struct Mac;
#line 73 "kex.h"
typedef struct Mac Mac;
#line 74
struct Comp;
#line 74 "kex.h"
typedef struct Comp Comp;
#line 75
struct Enc;
#line 75 "kex.h"
typedef struct Enc Enc;
#line 76
struct Newkeys;
#line 76 "kex.h"
typedef struct Newkeys Newkeys;
#line 78 "kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_int key_len ;
   u_int block_size ;
   u_char *key ;
   u_char *iv ;
};
#line 87
struct umac_ctx;
#line 87 "kex.h"
struct Mac {
   char *name ;
   int enabled ;
   u_int mac_len ;
   u_char *key ;
   u_int key_len ;
   int type ;
   EVP_MD const   *evp_md ;
   HMAC_CTX evp_ctx ;
   struct umac_ctx *umac_ctx ;
};
#line 98 "kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 103 "kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 143 "packet.c"
struct packet_state {
   u_int32_t seqnr ;
   u_int32_t packets ;
   u_int64_t blocks ;
};
#line 159 "packet.c"
struct __anonstruct_next_77 {
   struct packet *tqe_next ;
   struct packet **tqe_prev ;
};
#line 159 "packet.c"
struct packet {
   struct __anonstruct_next_77 next ;
   u_char type ;
   Buffer payload ;
};
#line 164 "packet.c"
struct __anonstruct_outgoing_78 {
   struct packet *tqh_first ;
   struct packet **tqh_last ;
};
#line 96 "readpass.c"
union __anonunion___u_75 {
   int __in ;
   int __i ;
};
#line 96 "readpass.c"
union __anonunion___u_76 {
   int __in ;
   int __i ;
};
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 37 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 40 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 39 "key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
#line 34 "dispatch.h"
typedef void dispatch_fn(int  , u_int32_t  , void * );
#line 72 "kex.h"
struct Kex;
#line 72 "kex.h"
typedef struct Kex Kex;
#line 108 "kex.h"
struct Kex {
   u_char *session_id ;
   u_int session_id_len ;
   Newkeys *newkeys[2] ;
   u_int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   sig_atomic_t done ;
   int flags ;
   EVP_MD const   *evp_md ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
   int (*host_key_index)(Key * ) ;
   void (*kex[4])(Kex * ) ;
};
#line 50 "mac.c"
struct __anonstruct_macs_74 {
   char *name ;
   int type ;
   EVP_MD const   *(*mdfunc)(void) ;
   int truncatebits ;
   int key_len ;
   int len ;
};
#line 40 "misc.h"
struct arglist;
#line 40 "misc.h"
typedef struct arglist arglist;
#line 41 "misc.h"
struct arglist {
   char **list ;
   u_int num ;
   u_int nalloc ;
};
#line 567 "misc.c"
struct __anonstruct_keys_56 {
   char const   *key ;
   char const   *repl ;
};
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 233 "/usr/include/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 52 "monitor_fdpass.c"
union __anonunion_cmsgbuf_52 {
   struct cmsghdr hdr ;
   char tmp[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
   char buf[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
};
#line 107 "monitor_fdpass.c"
union __anonunion_cmsgbuf_53 {
   struct cmsghdr hdr ;
   char buf[(((sizeof(int ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))] ;
};
#line 35 "rijndael.h"
typedef unsigned char u8;
#line 37 "rijndael.h"
typedef unsigned int u32;
#line 40 "rijndael.h"
struct __anonstruct_rijndael_ctx_50 {
   int decrypt ;
   int Nr ;
   u32 ek[60] ;
   u32 dk[60] ;
};
#line 40 "rijndael.h"
typedef struct __anonstruct_rijndael_ctx_50 rijndael_ctx;
#line 29 "dh.h"
struct dhgroup {
   int size ;
   BIGNUM *g ;
   BIGNUM *p ;
};
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 80 "umac.c"
typedef u_int8_t UINT8;
#line 82 "umac.c"
typedef u_int32_t UINT32;
#line 83 "umac.c"
typedef u_int64_t UINT64;
#line 84 "umac.c"
typedef unsigned int UWORD;
#line 173 "umac.c"
typedef AES_KEY aes_int_key[1];
#line 215 "umac.c"
struct __anonstruct_pdf_ctx_53 {
   UINT8 cache[16] ;
   UINT8 nonce[16] ;
   aes_int_key prf_key ;
};
#line 215 "umac.c"
typedef struct __anonstruct_pdf_ctx_53 pdf_ctx;
#line 315 "umac.c"
struct __anonstruct_nh_ctx_54 {
   UINT8 nh_key[1040] ;
   UINT8 data[64] ;
   int next_data_empty ;
   int bytes_hashed ;
   UINT64 state[2] ;
};
#line 315 "umac.c"
typedef struct __anonstruct_nh_ctx_54 nh_ctx;
#line 770 "umac.c"
struct uhash_ctx {
   nh_ctx hash ;
   UINT64 poly_key_8[2] ;
   UINT64 poly_accum[2] ;
   UINT64 ip_keys[8] ;
   UINT32 ip_trans[2] ;
   UINT32 msg_len ;
};
#line 770 "umac.c"
typedef struct uhash_ctx uhash_ctx;
#line 779 "umac.c"
typedef struct uhash_ctx *uhash_ctx_t;
#line 1175 "umac.c"
struct umac_ctx {
   uhash_ctx hash ;
   pdf_ctx pdf ;
   void *free_ptr ;
};
#line 42 "servconf.h"
struct __anonstruct_ServerOptions_78 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   int address_family ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   int x11_use_localhost ;
   char *xauth_location ;
   int strict_modes ;
   int tcp_keep_alive ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int kerberos_authentication ;
   int kerberos_or_local_passwd ;
   int kerberos_ticket_cleanup ;
   int kerberos_get_afs_token ;
   int gss_authentication ;
   int gss_cleanup_creds ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int permit_empty_passwd ;
   int permit_user_env ;
   int use_login ;
   int compression ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   char *subsystem_args[256] ;
   u_int num_accept_env ;
   char *accept_env[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   int max_authtries ;
   char *banner ;
   int use_dns ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   char *adm_forced_command ;
   int use_pam ;
   int permit_tun ;
   int num_permitted_opens ;
   char *chroot_directory ;
};
#line 42 "servconf.h"
typedef struct __anonstruct_ServerOptions_78 ServerOptions;
#line 45 "auth.h"
struct Authctxt;
#line 45 "auth.h"
typedef struct Authctxt Authctxt;
#line 49 "auth.h"
struct Authctxt {
   sig_atomic_t success ;
   int authenticated ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   int force_pwchange ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
   Buffer *loginmsg ;
   void *methoddata ;
};
#line 31 "monitor_mm.h"
struct __anonstruct_next_82 {
   struct mm_share *rbe_left ;
   struct mm_share *rbe_right ;
   struct mm_share *rbe_parent ;
   int rbe_color ;
};
#line 31 "monitor_mm.h"
struct mm_share {
   struct __anonstruct_next_82 next ;
   void *address ;
   size_t size ;
};
#line 37 "monitor_mm.h"
struct mmtree {
   struct mm_share *rbh_root ;
};
#line 37 "monitor_mm.h"
struct mm_master {
   struct mmtree rb_free ;
   struct mmtree rb_allocated ;
   void *address ;
   size_t size ;
   struct mm_master *mmalloc ;
   int write ;
   int read ;
};
#line 67 "monitor.h"
struct monitor {
   int m_recvfd ;
   int m_sendfd ;
   struct mm_master *m_zback ;
   struct mm_master *m_zlib ;
   struct Kex **m_pkex ;
   pid_t m_pid ;
};
#line 203 "sshd.c"
struct __anonstruct_sensitive_data_83 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 42 "loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 62 "loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[128] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 270 "servconf.c"
enum __anonenum_ServerOpCodes_78 {
    sBadOption = 0,
    sUsePAM = 1,
    sPort = 2,
    sHostKeyFile = 3,
    sServerKeyBits = 4,
    sLoginGraceTime = 5,
    sKeyRegenerationTime = 6,
    sPermitRootLogin = 7,
    sLogFacility = 8,
    sLogLevel = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sKerberosAuthentication = 12,
    sKerberosOrLocalPasswd = 13,
    sKerberosTicketCleanup = 14,
    sKerberosGetAFSToken = 15,
    sKerberosTgtPassing = 16,
    sChallengeResponseAuthentication = 17,
    sPasswordAuthentication = 18,
    sKbdInteractiveAuthentication = 19,
    sListenAddress = 20,
    sAddressFamily = 21,
    sPrintMotd = 22,
    sPrintLastLog = 23,
    sIgnoreRhosts = 24,
    sX11Forwarding = 25,
    sX11DisplayOffset = 26,
    sX11UseLocalhost = 27,
    sStrictModes = 28,
    sEmptyPasswd = 29,
    sTCPKeepAlive = 30,
    sPermitUserEnvironment = 31,
    sUseLogin = 32,
    sAllowTcpForwarding = 33,
    sCompression = 34,
    sAllowUsers = 35,
    sDenyUsers = 36,
    sAllowGroups = 37,
    sDenyGroups = 38,
    sIgnoreUserKnownHosts = 39,
    sCiphers = 40,
    sMacs = 41,
    sProtocol = 42,
    sPidFile = 43,
    sGatewayPorts = 44,
    sPubkeyAuthentication = 45,
    sXAuthLocation = 46,
    sSubsystem = 47,
    sMaxStartups = 48,
    sMaxAuthTries = 49,
    sBanner = 50,
    sUseDNS = 51,
    sHostbasedAuthentication = 52,
    sHostbasedUsesNameFromPacketOnly = 53,
    sClientAliveInterval = 54,
    sClientAliveCountMax = 55,
    sAuthorizedKeysFile = 56,
    sAuthorizedKeysFile2 = 57,
    sGssAuthentication = 58,
    sGssCleanupCreds = 59,
    sAcceptEnv = 60,
    sPermitTunnel = 61,
    sMatch = 62,
    sPermitOpen = 63,
    sForceCommand = 64,
    sChrootDirectory = 65,
    sUsePrivilegeSeparation = 66,
    sDeprecated = 67,
    sUnsupported = 68
} ;
#line 270 "servconf.c"
typedef enum __anonenum_ServerOpCodes_78 ServerOpCodes;
#line 305 "servconf.c"
struct __anonstruct_keywords_79 {
   char const   *name ;
   ServerOpCodes opcode ;
   u_int flags ;
};
#line 30 "session.h"
struct Session;
#line 30 "session.h"
typedef struct Session Session;
#line 31 "session.h"
struct __anonstruct_env_80 {
   char *name ;
   char *val ;
};
#line 31 "session.h"
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   u_int row ;
   u_int col ;
   u_int xpixel ;
   u_int ypixel ;
   char tty[64] ;
   u_int display_number ;
   char *display ;
   u_int screen ;
   char *auth_display ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int *x11_chanids ;
   int is_subsystem ;
   u_int num_env ;
   struct __anonstruct_env_80 *env ;
};
#line 757 "serverloop.c"
union __anonunion___u_82 {
   int __in ;
   int __i ;
};
#line 759 "serverloop.c"
union __anonunion___u_83 {
   int __in ;
   int __i ;
};
#line 755 "serverloop.c"
union __anonunion___u_84 {
   int __in ;
   int __i ;
};
#line 781 "serverloop.c"
union __anonunion___u_85 {
   int __in ;
   int __i ;
};
#line 779 "serverloop.c"
union __anonunion___u_86 {
   int __in ;
   int __i ;
};
#line 55 "auth1.c"
struct AuthMethod1 {
   int type ;
   char *name ;
   int *enabled ;
   int (*method)(Authctxt * , char * , size_t  ) ;
};
#line 46 "auth.h"
struct Authmethod;
#line 46 "auth.h"
typedef struct Authmethod Authmethod;
#line 82 "auth.h"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 19 "auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 2289 "session.c"
union __anonunion___u_81 {
   int __in ;
   int __i ;
};
#line 2293 "session.c"
union __anonunion___u_82___0 {
   int __in ;
   int __i ;
};
#line 2295 "session.c"
union __anonunion___u_83___0 {
   int __in ;
   int __i ;
};
#line 2295 "session.c"
union __anonunion___u_84___0 {
   int __in ;
   int __i ;
};
#line 2291 "session.c"
union __anonunion___u_85___0 {
   int __in ;
   int __i ;
};
#line 2287 "session.c"
union __anonunion___u_86___0 {
   int __in ;
   int __i ;
};
#line 47 "auth.h"
struct KbdintDevice;
#line 47 "auth.h"
typedef struct KbdintDevice KbdintDevice;
#line 95 "auth.h"
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
#line 78 "auth2-chall.c"
struct KbdintAuthctxt;
#line 78 "auth2-chall.c"
typedef struct KbdintAuthctxt KbdintAuthctxt;
#line 79 "auth2-chall.c"
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
   u_int nreq ;
};
#line 31 "monitor.h"
enum monitor_reqtype {
    MONITOR_REQ_MODULI = 0,
    MONITOR_ANS_MODULI = 1,
    MONITOR_REQ_FREE = 2,
    MONITOR_REQ_AUTHSERV = 3,
    MONITOR_REQ_SIGN = 4,
    MONITOR_ANS_SIGN = 5,
    MONITOR_REQ_PWNAM = 6,
    MONITOR_ANS_PWNAM = 7,
    MONITOR_REQ_AUTH2_READ_BANNER = 8,
    MONITOR_ANS_AUTH2_READ_BANNER = 9,
    MONITOR_REQ_AUTHPASSWORD = 10,
    MONITOR_ANS_AUTHPASSWORD = 11,
    MONITOR_REQ_BSDAUTHQUERY = 12,
    MONITOR_ANS_BSDAUTHQUERY = 13,
    MONITOR_REQ_BSDAUTHRESPOND = 14,
    MONITOR_ANS_BSDAUTHRESPOND = 15,
    MONITOR_REQ_SKEYQUERY = 16,
    MONITOR_ANS_SKEYQUERY = 17,
    MONITOR_REQ_SKEYRESPOND = 18,
    MONITOR_ANS_SKEYRESPOND = 19,
    MONITOR_REQ_KEYALLOWED = 20,
    MONITOR_ANS_KEYALLOWED = 21,
    MONITOR_REQ_KEYVERIFY = 22,
    MONITOR_ANS_KEYVERIFY = 23,
    MONITOR_REQ_KEYEXPORT = 24,
    MONITOR_REQ_PTY = 25,
    MONITOR_ANS_PTY = 26,
    MONITOR_REQ_PTYCLEANUP = 27,
    MONITOR_REQ_SESSKEY = 28,
    MONITOR_ANS_SESSKEY = 29,
    MONITOR_REQ_SESSID = 30,
    MONITOR_REQ_RSAKEYALLOWED = 31,
    MONITOR_ANS_RSAKEYALLOWED = 32,
    MONITOR_REQ_RSACHALLENGE = 33,
    MONITOR_ANS_RSACHALLENGE = 34,
    MONITOR_REQ_RSARESPONSE = 35,
    MONITOR_ANS_RSARESPONSE = 36,
    MONITOR_REQ_GSSSETUP = 37,
    MONITOR_ANS_GSSSETUP = 38,
    MONITOR_REQ_GSSSTEP = 39,
    MONITOR_ANS_GSSSTEP = 40,
    MONITOR_REQ_GSSUSEROK = 41,
    MONITOR_ANS_GSSUSEROK = 42,
    MONITOR_REQ_GSSCHECKMIC = 43,
    MONITOR_ANS_GSSCHECKMIC = 44,
    MONITOR_REQ_PAM_START = 45,
    MONITOR_REQ_PAM_ACCOUNT = 46,
    MONITOR_ANS_PAM_ACCOUNT = 47,
    MONITOR_REQ_PAM_INIT_CTX = 48,
    MONITOR_ANS_PAM_INIT_CTX = 49,
    MONITOR_REQ_PAM_QUERY = 50,
    MONITOR_ANS_PAM_QUERY = 51,
    MONITOR_REQ_PAM_RESPOND = 52,
    MONITOR_ANS_PAM_RESPOND = 53,
    MONITOR_REQ_PAM_FREE_CTX = 54,
    MONITOR_ANS_PAM_FREE_CTX = 55,
    MONITOR_REQ_AUDIT_EVENT = 56,
    MONITOR_REQ_AUDIT_COMMAND = 57,
    MONITOR_REQ_TERM = 58
} ;
#line 84
struct mon_table;
#line 34 "monitor_wrap.h"
enum mm_keytype {
    MM_NOKEY = 0,
    MM_HOSTKEY = 1,
    MM_USERKEY = 2,
    MM_RSAHOSTKEY = 3,
    MM_RSAUSERKEY = 4
} ;
#line 108 "monitor.c"
struct __anonstruct_child_state_82 {
   z_stream incoming ;
   z_stream outgoing ;
   u_char *keyin ;
   u_int keyinlen ;
   u_char *keyout ;
   u_int keyoutlen ;
   u_char *ivin ;
   u_int ivinlen ;
   u_char *ivout ;
   u_int ivoutlen ;
   u_char *ssh1key ;
   u_int ssh1keylen ;
   int ssh1cipher ;
   int ssh1protoflags ;
   u_char *input ;
   u_int ilen ;
   u_char *output ;
   u_int olen ;
};
#line 187 "monitor.c"
struct mon_table {
   enum monitor_reqtype type ;
   int flags ;
   int (*f)(int  , Buffer * ) ;
};
#line 1559 "monitor.c"
union __anonunion___u_83___1 {
   int __in ;
   int __i ;
};
#line 1559 "monitor.c"
union __anonunion___u_84___1 {
   int __in ;
   int __i ;
};
#line 1559 "monitor.c"
union __anonunion___u_85___1 {
   int __in ;
   int __i ;
};
#line 1559 "monitor.c"
union __anonunion___u_86___1 {
   int __in ;
   int __i ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 31 "sftp-common.h"
struct Attrib;
#line 31 "sftp-common.h"
typedef struct Attrib Attrib;
#line 34 "sftp-common.h"
struct Attrib {
   u_int32_t flags ;
   u_int64_t size ;
   u_int32_t uid ;
   u_int32_t gid ;
   u_int32_t perm ;
   u_int32_t atime ;
   u_int32_t mtime ;
};
#line 69 "sftp-server.c"
struct Stat;
#line 69 "sftp-server.c"
typedef struct Stat Stat;
#line 71 "sftp-server.c"
struct Stat {
   char *name ;
   char *long_name ;
   Attrib attrib ;
};
#line 165
struct Handle;
#line 165 "sftp-server.c"
typedef struct Handle Handle;
#line 166 "sftp-server.c"
struct Handle {
   int use ;
   DIR *dirp ;
   int fd ;
   char *name ;
   u_int64_t bytes_read ;
   u_int64_t bytes_write ;
   int next_unused ;
};
#line 1 "port-irix.o"
#line 1 "port-aix.o"
#line 1 "bsd-arc4random.o"
#line 150 "./openbsd-compat/openbsd-compat.h"
unsigned int arc4random(void) ;
#line 151
void arc4random_stir(void) ;
#line 32 "./entropy.h"
void seed_rng(void) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 54 "./log.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 102 "/usr/include/openssl/rand.h"
extern int RAND_bytes(unsigned char *buf , int num ) ;
#line 79 "/usr/include/openssl/rc4.h"
extern void RC4_set_key(RC4_KEY *key , int len , unsigned char const   *data ) ;
#line 80
extern void RC4(RC4_KEY *key , unsigned long len , unsigned char const   *indata ,
                unsigned char *outdata ) ;
#line 258 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 38 "openbsd-compat/bsd-arc4random.c"
static int rc4_ready  =    0;
#line 39 "openbsd-compat/bsd-arc4random.c"
static RC4_KEY rc4  ;
#line 45 "openbsd-compat/bsd-arc4random.c"
static int first_time  =    1;
#line 41 "openbsd-compat/bsd-arc4random.c"
unsigned int arc4random(void) 
{ unsigned int r ;

  {
#line 44
  r = 0U;
#line 47
  if (rc4_ready <= 0) {
#line 48
    if (first_time) {
#line 49
      seed_rng();
    }
#line 50
    first_time = 0;
#line 51
    arc4random_stir();
  }
#line 54
  RC4(& rc4, (unsigned long )sizeof(r), (unsigned char const   *)((unsigned char *)(& r)),
      (unsigned char *)(& r));
#line 56
  rc4_ready = (int )((unsigned int )rc4_ready - sizeof(r));
#line 58
  return (r);
}
}
#line 61 "openbsd-compat/bsd-arc4random.c"
void arc4random_stir(void) 
{ unsigned char rand_buf[20] ;
  int i ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 67
  memset((void *)(& rc4), 0, sizeof(rc4));
#line 68
  tmp___0 = RAND_bytes(rand_buf, (int )sizeof(rand_buf));
#line 68
  if (tmp___0 <= 0) {
#line 69
    tmp = ERR_get_error();
#line 69
    fatal("Couldn\'t obtain random bytes (error %ld)", tmp);
  }
#line 71
  RC4_set_key(& rc4, (int )sizeof(rand_buf), (unsigned char const   *)(rand_buf));
#line 77
  i = 0;
#line 77
  while (i <= 256) {
#line 78
    RC4(& rc4, (unsigned long )sizeof(rand_buf), (unsigned char const   *)(rand_buf),
        rand_buf);
#line 77
    i = (int )((unsigned int )i + sizeof(rand_buf));
  }
#line 80
  memset((void *)(rand_buf), 0, sizeof(rand_buf));
#line 82
  rc4_ready = 1 << 24;
#line 83
  return;
}
}
#line 1 "bsd-cray.o"
#line 1 "bsd-cygwin_util.o"
#line 1 "bsd-getpeereid.o"
#line 185 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 146 "./openbsd-compat/openbsd-compat.h"
int getpeereid(int s , uid_t *euid , gid_t *gid ) ;
#line 27 "openbsd-compat/bsd-getpeereid.c"
int getpeereid(int s , uid_t *euid , gid_t *gid ) 
{ struct ucred cred ;
  socklen_t len ;
  int tmp ;

  {
#line 31
  len = sizeof(cred);
#line 33
  tmp = getsockopt(s, 1, 17, (void * __restrict  )(& cred), (socklen_t * __restrict  )(& len));
#line 33
  if (tmp < 0) {
#line 34
    return (-1);
  }
#line 35
  *euid = cred.uid;
#line 36
  *gid = cred.gid;
#line 38
  return (0);
}
}
#line 1 "bsd-misc.o"
#line 24 "./openbsd-compat/bsd-misc.h"
char *ssh_get_progname(char *argv0___0 ) ;
#line 35
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 94
 __attribute__((__nothrow__)) void (*mysignal(int sig , void (*act)(int  ) ))(int  ) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 23 "./xmalloc.h"
char *xstrdup(char const   *str ) ;
#line 46 "openbsd-compat/bsd-misc.c"
extern char *__progname ;
#line 43 "openbsd-compat/bsd-misc.c"
char *ssh_get_progname(char *argv0___0 ) 
{ char *tmp ;

  {
#line 48
  tmp = xstrdup((char const   *)__progname);
#line 48
  return (tmp);
}
}
#line 65
 __attribute__((__nothrow__)) int setlogin(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 65 "openbsd-compat/bsd-misc.c"
int setlogin(char const   *name ) 
{ 

  {
#line 67
  return (0);
}
}
#line 202
 __attribute__((__nothrow__)) void (*mysignal(int sig , void (*act)(int  ) ))(int  ) ;
#line 202 "openbsd-compat/bsd-misc.c"
void (*mysignal(int sig , void (*act)(int  ) ))(int  ) 
{ struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;
  int tmp___0 ;

  {
#line 208
  tmp = sigaction(sig, (struct sigaction  const  * __restrict  )((void *)0), (struct sigaction * __restrict  )(& osa));
#line 208
  if (tmp == -1) {
#line 209
    return ((void (*)(int  ))-1);
  }
#line 210
  if ((unsigned int )osa.__sigaction_handler.sa_handler != (unsigned int )act) {
#line 211
    memset((void *)(& sa), 0, sizeof(sa));
#line 212
    sigemptyset(& sa.sa_mask);
#line 213
    sa.sa_flags = 0;
#line 215
    if (sig == 14) {
#line 216
      sa.sa_flags |= 536870912;
    }
#line 218
    sa.__sigaction_handler.sa_handler = act;
#line 219
    tmp___0 = sigaction(sig, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 219
    if (tmp___0 == -1) {
#line 220
      return ((void (*)(int  ))-1);
    }
  }
#line 222
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 1 "bsd-nextstep.o"
#line 1 "bsd-openpty.o"
#line 1 "bsd-snprintf.o"
#line 1 "bsd-waitpid.o"
#line 1 "bsd-closefrom.o"
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 357 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 57 "./openbsd-compat/openbsd-compat.h"
void closefrom(int lowfd ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 564
extern  __attribute__((__nothrow__)) long sysconf(int __name )  __attribute__((__const__)) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 166
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64") __attribute__((__nonnull__(1))) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 68 "openbsd-compat/bsd-closefrom.c"
void closefrom(int lowfd ) 
{ long fd ;
  long maxfd ;
  char fdpath[4096] ;
  char *endp ;
  struct dirent *dent ;
  DIR *dirp ;
  int len ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 79
  tmp = getpid();
#line 79
  len = snprintf((char * __restrict  )(fdpath), sizeof(fdpath), (char const   * __restrict  )"/proc/%ld/fd",
                 (long )tmp);
#line 80
  if (len > 0) {
#line 80
    if ((unsigned int )len <= sizeof(fdpath)) {
#line 80
      dirp = opendir((char const   *)(fdpath));
#line 80
      if (dirp) {
#line 81
        while (1) {
#line 81
          dent = readdir(dirp);
#line 81
          if (! ((unsigned int )dent != (unsigned int )((void *)0))) {
#line 81
            break;
          }
#line 82
          fd = strtol((char const   * __restrict  )(dent->d_name), (char ** __restrict  )(& endp),
                      10);
#line 83
          if ((unsigned int )(dent->d_name) != (unsigned int )endp) {
#line 83
            if ((int )*endp == 0) {
#line 83
              if (fd >= 0L) {
#line 83
                if (fd < 2147483647L) {
#line 83
                  if (fd >= (long )lowfd) {
#line 83
                    tmp___0 = dirfd(dirp);
#line 83
                    if (fd != (long )tmp___0) {
#line 85
                      close((int )fd);
                    }
                  }
                }
              }
            }
          }
        }
#line 87
        closedir(dirp);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 97
    maxfd = sysconf(4);
#line 101
    if (maxfd < 0L) {
#line 102
      maxfd = 256L;
    }
#line 104
    fd = (long )lowfd;
#line 104
    while (fd < maxfd) {
#line 105
      close((int )fd);
#line 104
      fd ++;
    }
  }
#line 107
  return;
}
}
#line 1 "fake-rfc2553.o"
#line 1 "xmmap.o"
#line 307 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 712 "/usr/include/stdlib.h"
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 189 "./openbsd-compat/openbsd-compat.h"
void *xmmap(size_t size ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 792 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 973
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 47 "openbsd-compat/xmmap.c"
void *xmmap(size_t size ) 
{ void *address ;
  char tmpname[sizeof("/var/run/sshd.mm.XXXXXXXX")] ;
  int tmpfd ;
  mode_t old_umask ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 54
  address = mmap((void *)0, size, 3, 33, -1, 0LL);
#line 62
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 63
    tmpname[0] = (char )'/';
#line 63
    tmpname[1] = (char )'v';
#line 63
    tmpname[2] = (char )'a';
#line 63
    tmpname[3] = (char )'r';
#line 63
    tmpname[4] = (char )'/';
#line 63
    tmpname[5] = (char )'r';
#line 63
    tmpname[6] = (char )'u';
#line 63
    tmpname[7] = (char )'n';
#line 63
    tmpname[8] = (char )'/';
#line 63
    tmpname[9] = (char )'s';
#line 63
    tmpname[10] = (char )'s';
#line 63
    tmpname[11] = (char )'h';
#line 63
    tmpname[12] = (char )'d';
#line 63
    tmpname[13] = (char )'.';
#line 63
    tmpname[14] = (char )'m';
#line 63
    tmpname[15] = (char )'m';
#line 63
    tmpname[16] = (char )'.';
#line 63
    tmpname[17] = (char )'X';
#line 63
    tmpname[18] = (char )'X';
#line 63
    tmpname[19] = (char )'X';
#line 63
    tmpname[20] = (char )'X';
#line 63
    tmpname[21] = (char )'X';
#line 63
    tmpname[22] = (char )'X';
#line 63
    tmpname[23] = (char )'X';
#line 63
    tmpname[24] = (char )'X';
#line 63
    tmpname[25] = (char )'\000';
#line 67
    old_umask = umask(127U);
#line 68
    tmpfd = mkstemp(tmpname);
#line 69
    umask(old_umask);
#line 70
    if (tmpfd == -1) {
#line 71
      tmp = __errno_location();
#line 71
      tmp___0 = strerror(*tmp);
#line 71
      fatal("mkstemp(\"%s\"): %s", "/var/run/sshd.mm.XXXXXXXX", tmp___0);
    }
#line 73
    unlink((char const   *)(tmpname));
#line 74
    ftruncate(tmpfd, (long long )size);
#line 75
    address = mmap((void *)0, size, 3, 1, tmpfd, 0LL);
#line 77
    close(tmpfd);
  }
#line 80
  return (address);
}
}
#line 1 "xcrypt.o"
#line 190 "./openbsd-compat/openbsd-compat.h"
char *xcrypt(char const   *password , char const   *salt ) ;
#line 191
char *shadow_pw(struct passwd *pw___0 ) ;
#line 1073 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 60 "openbsd-compat/xcrypt.c"
char *xcrypt(char const   *password , char const   *salt ) 
{ char *crypted ;

  {
#line 78
  crypted = crypt(password, salt);
#line 81
  return (crypted);
}
}
#line 89 "openbsd-compat/xcrypt.c"
char *shadow_pw(struct passwd *pw___0 ) 
{ char *pw_password ;
  struct spwd *spw ;
  struct spwd *tmp ;

  {
#line 92
  pw_password = pw___0->pw_passwd;
#line 95
  tmp = getspnam((char const   *)pw___0->pw_name);
#line 95
  spw = tmp;
#line 97
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 98
    pw_password = spw->sp_pwdp;
  }
#line 116
  return (pw_password);
}
}
#line 1 "port-tun.o"
#line 38 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 41
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 24 "./openbsd-compat/port-tun.h"
int sys_tun_open(int tun , int mode ) ;
#line 29
int sys_tun_infilter(struct Channel *c , char *buf___1 , int len ) ;
#line 30
u_char *sys_tun_outfilter(struct Channel *c , u_char **data , u_int *dlen ) ;
#line 68 "./buffer.h"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) ;
#line 69
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) ;
#line 51 "/usr/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 88 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
#line 59 "./log.h"
void ( /* format attribute */  debug)(char const   *fmt  , ...) ;
#line 56 "openbsd-compat/port-tun.c"
int sys_tun_open(int tun , int mode ) 
{ struct ifreq ifr ;
  int fd ;
  char const   *name ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 60
  fd = -1;
#line 61
  name = (char const   *)((void *)0);
#line 63
  fd = open("/dev/net/tun", 2);
#line 63
  if (fd == -1) {
#line 64
    tmp = __errno_location();
#line 64
    tmp___0 = strerror(*tmp);
#line 64
    debug("%s: failed to open tunnel control interface: %s", "sys_tun_open", tmp___0);
#line 66
    return (-1);
  }
#line 69
  bzero((void *)(& ifr), sizeof(ifr));
#line 71
  if (mode == 2) {
#line 72
    ifr.ifr_ifru.ifru_flags = (short)2;
#line 73
    name = "tap%d";
  } else {
#line 75
    ifr.ifr_ifru.ifru_flags = (short)1;
#line 76
    name = "tun%d";
  }
#line 78
  ifr.ifr_ifru.ifru_flags = (short )((int )ifr.ifr_ifru.ifru_flags | 4096);
#line 80
  if (tun != 2147483647) {
#line 81
    if (tun > 2147483645) {
#line 82
      tmp___1 = __errno_location();
#line 82
      tmp___2 = strerror(*tmp___1);
#line 82
      debug("%s: invalid tunnel id %x: %s", "sys_tun_open", tun, tmp___2);
      goto failed;
    }
#line 86
    snprintf((char * __restrict  )(ifr.ifr_ifrn.ifrn_name), sizeof(ifr.ifr_ifrn.ifrn_name),
             (char const   * __restrict  )name, tun);
  }
#line 89
  if (sizeof(int ) == sizeof(int [1])) {
#line 89
    if (sizeof(int ) < (unsigned int )(1 << 14)) {
#line 89
      tmp___5 = sizeof(int );
    } else {
#line 89
      tmp___5 = __invalid_size_argument_for_IOC;
    }
  } else {
#line 89
    tmp___5 = __invalid_size_argument_for_IOC;
  }
#line 89
  tmp___6 = ioctl(fd, (unsigned long )((((1U << 30) | (unsigned int )(84 << 8)) | 202U) | (tmp___5 << 16)),
                  & ifr);
#line 89
  if (tmp___6 == -1) {
#line 90
    tmp___3 = __errno_location();
#line 90
    tmp___4 = strerror(*tmp___3);
#line 90
    debug("%s: failed to configure tunnel (mode %d): %s", "sys_tun_open", mode, tmp___4);
    goto failed;
  }
#line 95
  if (tun == 2147483647) {
#line 96
    debug("%s: tunnel mode %d fd %d", "sys_tun_open", mode, fd);
  } else {
#line 98
    debug("%s: %s mode %d fd %d", "sys_tun_open", ifr.ifr_ifrn.ifrn_name, mode, fd);
  }
#line 100
  return (fd);
  failed: 
#line 103
  close(fd);
#line 104
  return (-1);
}
}
#line 201 "openbsd-compat/port-tun.c"
int sys_tun_infilter(struct Channel *c , char *buf___1 , int len ) 
{ char rbuf[16384] ;
  struct ip *iph ;
  u_int32_t *af ;
  char *ptr ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  register unsigned int __v___1 ;
  register unsigned int __x___1 ;

  {
#line 209
  ptr = buf___1;
#line 212
  if (len <= 0) {
#line 213
    return (-1);
  } else {
#line 212
    if (len > (int )(sizeof(rbuf) - sizeof(*af))) {
#line 213
      return (-1);
    }
  }
#line 214
  ptr = rbuf;
#line 215
  bcopy((void const   *)buf___1, (void *)(ptr + sizeof(u_int32_t )), (unsigned int )len);
#line 216
  len = (int )((unsigned int )len + sizeof(u_int32_t ));
#line 217
  af = (u_int32_t *)ptr;
#line 219
  iph = (struct ip *)(ptr + sizeof(u_int32_t ));
#line 220
  switch ((int )iph->ip_v) {
  case 6: 
#line 222
  *af = 10U;
#line 223
  break;
  case 4: 
  default: 
#line 226
  *af = 2U;
#line 227
  break;
  }
#line 232
  if (len < (int )sizeof(u_int32_t )) {
#line 233
    return (-1);
  }
#line 235
  af = (u_int32_t *)ptr;
#line 236
  __x___1 = 10U;
#line 236
  __asm__  ("rorw $8, %w0;"
            "rorl $16, %0;"
            "rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 236
  if (*af == __v___1) {
#line 237
    __x = 24U;
#line 237
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 237
    *af = __v;
  } else {
#line 239
    __x___0 = 2U;
#line 239
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 239
    *af = __v___0;
  }
#line 242
  buffer_put_string(& c->input, (void const   *)ptr, (unsigned int )len);
#line 243
  return (0);
}
}
#line 246 "openbsd-compat/port-tun.c"
u_char *sys_tun_outfilter(struct Channel *c , u_char **data , u_int *dlen ) 
{ u_char *buf___1 ;
  u_int32_t *af ;
  void *tmp ;

  {
#line 252
  tmp = buffer_get_string(& c->output, dlen);
#line 252
  *data = (u_char *)tmp;
#line 253
  if (*dlen < sizeof(*af)) {
#line 254
    return ((u_char *)((void *)0));
  }
#line 255
  buf___1 = *data;
#line 258
  *dlen -= sizeof(u_int32_t );
#line 259
  buf___1 = *data + sizeof(u_int32_t );
#line 268
  return (buf___1);
}
}
#line 1 "strtonum.o"
#line 210 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 306
extern  __attribute__((__nothrow__)) long long __strtoll_internal(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr ,
                                                                  int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 380
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 380 "/usr/include/stdlib.h"
__inline static long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) 
{ long long tmp ;

  {
#line 384
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
#line 384
  return (tmp);
}
}
#line 174 "./openbsd-compat/openbsd-compat.h"
long long strtonum(char const   *numstr , long long minval , long long maxval , char const   **errstrp ) ;
#line 33 "openbsd-compat/strtonum.c"
long long strtonum(char const   *numstr , long long minval , long long maxval , char const   **errstrp ) 
{ long long ll ;
  char *ep ;
  int error___0 ;
  struct errval ev[4] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 37
  ll = 0LL;
#line 39
  error___0 = 0;
#line 40
  ev[0].errstr = (char const   *)((void *)0);
#line 40
  ev[0].err = 0;
#line 40
  ev[1].errstr = "invalid";
#line 40
  ev[1].err = 22;
#line 40
  ev[2].errstr = "too small";
#line 40
  ev[2].err = 34;
#line 40
  ev[3].errstr = "too large";
#line 40
  ev[3].err = 34;
#line 50
  tmp = __errno_location();
#line 50
  ev[0].err = *tmp;
#line 51
  tmp___0 = __errno_location();
#line 51
  *tmp___0 = 0;
#line 52
  if (minval > maxval) {
#line 53
    error___0 = 1;
  } else {
#line 55
    ll = strtoll((char const   * __restrict  )numstr, (char ** __restrict  )(& ep),
                 10);
#line 56
    if ((unsigned int )numstr == (unsigned int )ep) {
#line 57
      error___0 = 1;
    } else {
#line 56
      if ((int )*ep != 0) {
#line 57
        error___0 = 1;
      } else {
#line 58
        if (ll == (-0x7FFFFFFFFFFFFFFF-1)) {
#line 58
          tmp___2 = __errno_location();
#line 58
          if (*tmp___2 == 34) {
#line 59
            error___0 = 2;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 58
          if (ll < minval) {
#line 59
            error___0 = 2;
          } else {
#line 60
            if (ll == 9223372036854775807LL) {
#line 60
              tmp___1 = __errno_location();
#line 60
              if (*tmp___1 == 34) {
#line 61
                error___0 = 3;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 60
              if (ll > maxval) {
#line 61
                error___0 = 3;
              }
            }
          }
        }
      }
    }
  }
#line 63
  if ((unsigned int )errstrp != (unsigned int )((void *)0)) {
#line 64
    *errstrp = ev[error___0].errstr;
  }
#line 65
  tmp___3 = __errno_location();
#line 65
  *tmp___3 = ev[error___0].err;
#line 66
  if (error___0) {
#line 67
    ll = 0LL;
  }
#line 69
  return (ll);
}
}
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "base64.o"
#line 323 "/usr/include/resolv.h"
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 324
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 65 "openbsd-compat/base64.c"
static char const   Base64[65]  = 
#line 65 "openbsd-compat/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 67 "openbsd-compat/base64.c"
static char const   Pad64  =    (char const   )'=';
#line 133
 __attribute__((__nothrow__)) int __b64_ntop(u_char const   *src , size_t srclength ,
                                             char *target , size_t targsize ) ;
#line 133 "openbsd-compat/base64.c"
int __b64_ntop(u_char const   *src , size_t srclength , char *target , size_t targsize ) 
{ size_t datalength ;
  u_char input___0[3] ;
  u_char output___0[4] ;
  u_int i ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  u_char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 136
  datalength = (size_t )0;
#line 141
  while (2U < srclength) {
#line 142
    tmp = src;
#line 142
    src ++;
#line 142
    input___0[0] = (unsigned char )*tmp;
#line 143
    tmp___0 = src;
#line 143
    src ++;
#line 143
    input___0[1] = (unsigned char )*tmp___0;
#line 144
    tmp___1 = src;
#line 144
    src ++;
#line 144
    input___0[2] = (unsigned char )*tmp___1;
#line 145
    srclength -= 3U;
#line 147
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 148
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 149
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 150
    output___0[3] = (unsigned char )((int )input___0[2] & 63);
#line 152
    if (datalength + 4U > targsize) {
#line 153
      return (-1);
    }
#line 154
    tmp___2 = datalength;
#line 154
    datalength ++;
#line 154
    *(target + tmp___2) = (char )Base64[output___0[0]];
#line 155
    tmp___3 = datalength;
#line 155
    datalength ++;
#line 155
    *(target + tmp___3) = (char )Base64[output___0[1]];
#line 156
    tmp___4 = datalength;
#line 156
    datalength ++;
#line 156
    *(target + tmp___4) = (char )Base64[output___0[2]];
#line 157
    tmp___5 = datalength;
#line 157
    datalength ++;
#line 157
    *(target + tmp___5) = (char )Base64[output___0[3]];
  }
#line 161
  if (0U != srclength) {
#line 163
    input___0[2] = (unsigned char )'\000';
#line 163
    input___0[1] = input___0[2];
#line 163
    input___0[0] = input___0[1];
#line 164
    i = 0U;
#line 164
    while (i < srclength) {
#line 165
      tmp___6 = src;
#line 165
      src ++;
#line 165
      input___0[i] = (unsigned char )*tmp___6;
#line 164
      i ++;
    }
#line 167
    output___0[0] = (unsigned char )((int )input___0[0] >> 2);
#line 168
    output___0[1] = (unsigned char )((((int )input___0[0] & 3) << 4) + ((int )input___0[1] >> 4));
#line 169
    output___0[2] = (unsigned char )((((int )input___0[1] & 15) << 2) + ((int )input___0[2] >> 6));
#line 171
    if (datalength + 4U > targsize) {
#line 172
      return (-1);
    }
#line 173
    tmp___7 = datalength;
#line 173
    datalength ++;
#line 173
    *(target + tmp___7) = (char )Base64[output___0[0]];
#line 174
    tmp___8 = datalength;
#line 174
    datalength ++;
#line 174
    *(target + tmp___8) = (char )Base64[output___0[1]];
#line 175
    if (srclength == 1U) {
#line 176
      tmp___9 = datalength;
#line 176
      datalength ++;
#line 176
      *(target + tmp___9) = (char )Pad64;
    } else {
#line 178
      tmp___10 = datalength;
#line 178
      datalength ++;
#line 178
      *(target + tmp___10) = (char )Base64[output___0[2]];
    }
#line 179
    tmp___11 = datalength;
#line 179
    datalength ++;
#line 179
    *(target + tmp___11) = (char )Pad64;
  }
#line 181
  if (datalength >= targsize) {
#line 182
    return (-1);
  }
#line 183
  *(target + datalength) = (char )'\000';
#line 184
  return ((int )datalength);
}
}
#line 196
 __attribute__((__nothrow__)) int __b64_pton(char const   *src , u_char *target ,
                                             size_t targsize ) ;
#line 196 "openbsd-compat/base64.c"
int __b64_pton(char const   *src , u_char *target , size_t targsize ) 
{ u_int tarindex ;
  u_int state ;
  int ch ;
  char *pos ;
  unsigned short const   **tmp ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 203
  state = 0U;
#line 204
  tarindex = 0U;
#line 206
  while (1) {
#line 206
    tmp___2 = src;
#line 206
    src ++;
#line 206
    ch = (int )*tmp___2;
#line 206
    if (! (ch != 0)) {
#line 206
      break;
    }
#line 207
    tmp = __ctype_b_loc();
#line 207
    if ((int const   )*(*tmp + ch) & 8192) {
#line 208
      continue;
    }
#line 210
    if (ch == (int )Pad64) {
#line 211
      break;
    }
#line 213
    tmp___1 = __builtin_strchr((char *)(Base64), ch);
#line 213
    pos = tmp___1;
#line 214
    if ((unsigned int )pos == (unsigned int )((char *)0)) {
#line 215
      return (-1);
    }
#line 217
    switch ((int )state) {
    case 0: 
#line 219
    if (target) {
#line 220
      if (tarindex >= targsize) {
#line 221
        return (-1);
      }
#line 222
      *(target + tarindex) = (unsigned char )((pos - (char *)(Base64)) << 2);
    }
#line 224
    state = 1U;
#line 225
    break;
    case 1: 
#line 227
    if (target) {
#line 228
      if (tarindex + 1U >= targsize) {
#line 229
        return (-1);
      }
#line 230
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 4));
#line 231
      *(target + (tarindex + 1U)) = (unsigned char )(((pos - (char *)(Base64)) & 15) << 4);
    }
#line 234
    tarindex ++;
#line 235
    state = 2U;
#line 236
    break;
    case 2: 
#line 238
    if (target) {
#line 239
      if (tarindex + 1U >= targsize) {
#line 240
        return (-1);
      }
#line 241
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | ((pos - (char *)(Base64)) >> 2));
#line 242
      *(target + (tarindex + 1U)) = (unsigned char )(((pos - (char *)(Base64)) & 3) << 6);
    }
#line 245
    tarindex ++;
#line 246
    state = 3U;
#line 247
    break;
    case 3: 
#line 249
    if (target) {
#line 250
      if (tarindex >= targsize) {
#line 251
        return (-1);
      }
#line 252
      *(target + tarindex) = (unsigned char )((int )*(target + tarindex) | (pos - (char *)(Base64)));
    }
#line 254
    tarindex ++;
#line 255
    state = 0U;
#line 256
    break;
    }
  }
#line 265
  if (ch == (int )Pad64) {
#line 266
    tmp___3 = src;
#line 266
    src ++;
#line 266
    ch = (int )*tmp___3;
#line 267
    switch ((int )state) {
    case 0: 
    case 1: 
#line 270
    return (-1);
    case 2: 
#line 274
    while (ch != 0) {
#line 275
      tmp___5 = __ctype_b_loc();
#line 275
      if (! ((int const   )*(*tmp___5 + ch) & 8192)) {
#line 276
        break;
      }
#line 274
      tmp___4 = src;
#line 274
      src ++;
#line 274
      ch = (int )*tmp___4;
    }
#line 278
    if (ch != (int )Pad64) {
#line 279
      return (-1);
    }
#line 280
    tmp___6 = src;
#line 280
    src ++;
#line 280
    ch = (int )*tmp___6;
    case 3: 
#line 289
    while (ch != 0) {
#line 290
      tmp___8 = __ctype_b_loc();
#line 290
      if (! ((int const   )*(*tmp___8 + ch) & 8192)) {
#line 291
        return (-1);
      }
#line 289
      tmp___7 = src;
#line 289
      src ++;
#line 289
      ch = (int )*tmp___7;
    }
#line 299
    if (target) {
#line 299
      if ((int )*(target + tarindex) != 0) {
#line 300
        return (-1);
      }
    }
    }
  } else {
#line 307
    if (state != 0U) {
#line 308
      return (-1);
    }
  }
#line 311
  return ((int )tarindex);
}
}
#line 1 "basename.o"
#line 1 "bindresvport.o"
#line 110 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 114
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 53 "./openbsd-compat/openbsd-compat.h"
int bindresvport_sa(int sd , struct sockaddr *sa ) ;
#line 52 "openbsd-compat/bindresvport.c"
int bindresvport_sa(int sd , struct sockaddr *sa ) 
{ int error___0 ;
  int af ;
  struct sockaddr_storage myaddr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  u_int16_t *portp ;
  u_int16_t port___0 ;
  socklen_t salen ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  unsigned int tmp___1 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 64
  if ((unsigned int )sa == (unsigned int )((void *)0)) {
#line 65
    memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 66
    sa = (struct sockaddr *)(& myaddr);
#line 68
    tmp = getsockname(sd, (struct sockaddr * __restrict  )sa, (socklen_t * __restrict  )(& salen));
#line 68
    if (tmp == -1) {
#line 69
      return (-1);
    }
#line 71
    af = (int )sa->sa_family;
#line 72
    memset((void *)(& myaddr), 0, salen);
  } else {
#line 74
    af = (int )sa->sa_family;
  }
#line 76
  if (af == 2) {
#line 77
    sin = (struct sockaddr_in *)sa;
#line 78
    salen = sizeof(struct sockaddr_in );
#line 79
    portp = & sin->sin_port;
  } else {
#line 80
    if (af == 10) {
#line 81
      sin6 = (struct sockaddr_in6 *)sa;
#line 82
      salen = sizeof(struct sockaddr_in6 );
#line 83
      portp = & sin6->sin6_port;
    } else {
#line 85
      tmp___0 = __errno_location();
#line 85
      *tmp___0 = 96;
#line 86
      return (-1);
    }
  }
#line 88
  sa->sa_family = (unsigned short )af;
#line 90
  __x = *portp;
#line 90
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 90
  port___0 = __v;
#line 91
  if ((int )port___0 == 0) {
#line 92
    tmp___1 = arc4random();
#line 92
    port___0 = (unsigned short )(tmp___1 % 424U + 600U);
  }
#line 95
  error___0 = -1;
#line 97
  i = 0;
#line 97
  while (i < 424) {
#line 98
    __x___0 = port___0;
#line 98
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 98
    *portp = __v___0;
#line 100
    error___0 = bind(sd, (struct sockaddr  const  * __restrict  )sa, salen);
#line 103
    if (error___0 == 0) {
#line 104
      break;
    }
#line 107
    if (error___0 < 0) {
#line 107
      tmp___2 = __errno_location();
#line 107
      if (! (*tmp___2 == 98)) {
#line 107
        tmp___3 = __errno_location();
#line 107
        if (! (*tmp___3 == 22)) {
#line 108
          break;
        }
      }
    }
#line 110
    port___0 = (u_int16_t )((int )port___0 + 1);
#line 111
    if ((int )port___0 > 1023) {
#line 112
      port___0 = (unsigned short)600;
    }
#line 97
    i ++;
  }
#line 115
  return (error___0);
}
}
#line 1 "daemon.o"
#line 1 "dirname.o"
#line 1 "getcwd.o"
#line 1 "getgrouplist.o"
#line 1 "getopt.o"
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 131 "./openbsd-compat/openbsd-compat.h"
 __attribute__((__nothrow__)) int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 43 "openbsd-compat/getopt.c"
int BSDopterr  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptind  =    1;
#line 43 "openbsd-compat/getopt.c"
int BSDoptopt  ;
#line 43 "openbsd-compat/getopt.c"
int BSDoptreset  ;
#line 47 "openbsd-compat/getopt.c"
char *BSDoptarg  ;
#line 64 "openbsd-compat/getopt.c"
static char *place  =    (char *)"";
#line 57
 __attribute__((__nothrow__)) int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 57 "openbsd-compat/getopt.c"
int BSDgetopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ char *oli ;
  char *tmp ;
  char *tmp___1 ;

  {
#line 67
  if ((unsigned int )ostr == (unsigned int )((void *)0)) {
#line 68
    return (-1);
  }
#line 70
  if (BSDoptreset) {
    goto _L;
  } else {
#line 70
    if (! *place) {
      _L: /* CIL Label */ 
#line 71
      BSDoptreset = 0;
#line 72
      if (BSDoptind >= nargc) {
#line 73
        place = (char *)"";
#line 74
        return (-1);
      } else {
#line 72
        place = (char *)*(nargv + BSDoptind);
#line 72
        if ((int )*place != 45) {
#line 73
          place = (char *)"";
#line 74
          return (-1);
        }
      }
#line 76
      if (*(place + 1)) {
#line 76
        place ++;
#line 76
        if ((int )*place == 45) {
#line 77
          BSDoptind ++;
#line 78
          place = (char *)"";
#line 79
          return (-1);
        }
      }
    }
  }
#line 82
  tmp = place;
#line 82
  place ++;
#line 82
  BSDoptopt = (int )*tmp;
#line 82
  if (BSDoptopt == 58) {
    goto _L___0;
  } else {
#line 82
    tmp___1 = __builtin_strchr((char *)ostr, BSDoptopt);
#line 82
    oli = tmp___1;
#line 82
    if (! oli) {
      _L___0: /* CIL Label */ 
#line 88
      if (BSDoptopt == 45) {
#line 89
        return (-1);
      }
#line 90
      if (! *place) {
#line 91
        BSDoptind ++;
      }
#line 92
      if (BSDopterr) {
#line 92
        if ((int const   )*ostr != 58) {
#line 93
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- %c\n",
                  __progname, BSDoptopt);
        }
      }
#line 95
      return ('?');
    }
  }
#line 97
  oli ++;
#line 97
  if ((int )*oli != 58) {
#line 98
    BSDoptarg = (char *)((void *)0);
#line 99
    if (! *place) {
#line 100
      BSDoptind ++;
    }
  } else {
#line 103
    if (*place) {
#line 104
      BSDoptarg = place;
    } else {
#line 105
      BSDoptind ++;
#line 105
      if (nargc <= BSDoptind) {
#line 106
        place = (char *)"";
#line 107
        if ((int const   )*ostr == 58) {
#line 108
          return (':');
        }
#line 109
        if (BSDopterr) {
#line 110
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  __progname, BSDoptopt);
        }
#line 113
        return ('?');
      } else {
#line 116
        BSDoptarg = (char *)*(nargv + BSDoptind);
      }
    }
#line 117
    place = (char *)"";
#line 118
    BSDoptind ++;
  }
#line 120
  return (BSDoptopt);
}
}
#line 1 "getrrsetbyname.o"
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 591
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 237 "/usr/include/resolv.h"
extern struct __res_state *__res_state(void)  __attribute__((__const__)) ;
#line 261
extern  __attribute__((__nothrow__)) int __res_init(void) ;
#line 265
extern  __attribute__((__nothrow__)) int __res_query(char const   * , int  , int  ,
                                                     u_char * , int  ) ;
#line 345
extern  __attribute__((__nothrow__)) int __dn_expand(u_char const   * , u_char const   * ,
                                                     u_char const   * , char * , int  ) ;
#line 105 "./openbsd-compat/getrrsetbyname.h"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) ;
#line 106
void freerrset(struct rrsetinfo *rrset ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 127 "openbsd-compat/getrrsetbyname.c"
extern u_int16_t _getshort(u_char const   * ) ;
#line 141
extern u_int32_t _getlong(u_char const   * ) ;
#line 173
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) ;
#line 174
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) ;
#line 176
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) ;
#line 179
static void free_dns_query(struct dns_query *p ) ;
#line 180
static void free_dns_rr(struct dns_rr *p ) ;
#line 181
static void free_dns_response(struct dns_response *p ) ;
#line 183
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) ;
#line 185 "openbsd-compat/getrrsetbyname.c"
int getrrsetbyname(char const   *hostname , unsigned int rdclass , unsigned int rdtype ,
                   unsigned int flags , struct rrsetinfo **res ) 
{ struct __res_state *_resp ;
  struct __res_state *tmp ;
  int result ;
  struct rrsetinfo *rrset ;
  struct dns_response *response ;
  struct dns_rr *rr ;
  struct rdatainfo *rdata ;
  int length ;
  unsigned int index_ans ;
  unsigned int index_sig ;
  u_char answer[65536] ;
  int tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  void *tmp___19 ;

  {
#line 190
  tmp = __res_state();
#line 190
  _resp = tmp;
#line 192
  rrset = (struct rrsetinfo *)((void *)0);
#line 193
  response = (struct dns_response *)((void *)0);
#line 201
  if (rdclass > 65535U) {
#line 202
    result = 3;
    goto fail;
  } else {
#line 201
    if (rdtype > 65535U) {
#line 202
      result = 3;
      goto fail;
    }
  }
#line 207
  if (rdclass == 255U) {
#line 208
    result = 3;
    goto fail;
  } else {
#line 207
    if (rdtype == 255U) {
#line 208
      result = 3;
      goto fail;
    }
  }
#line 213
  if (flags) {
#line 214
    result = 3;
    goto fail;
  }
#line 219
  if ((_resp->options & 1UL) == 0UL) {
#line 219
    tmp___0 = __res_init();
#line 219
    if (tmp___0 == -1) {
#line 220
      result = 2;
      goto fail;
    }
  }
#line 235
  length = __res_query(hostname, (int )rdclass, (int )rdtype, answer, (int )sizeof(answer));
#line 237
  if (length < 0) {
#line 238
    tmp___1 = __h_errno_location();
#line 238
    switch (*tmp___1) {
    case 1: 
#line 240
    result = 4;
    goto fail;
    case 4: 
#line 243
    result = 5;
    goto fail;
    default: 
#line 246
    result = 2;
    goto fail;
    }
  }
#line 252
  response = parse_dns_response((u_char const   *)(answer), length);
#line 253
  if ((unsigned int )response == (unsigned int )((void *)0)) {
#line 254
    result = 2;
    goto fail;
  }
#line 258
  if (response->header.qdcount != 1U) {
#line 259
    result = 2;
    goto fail;
  }
#line 264
  tmp___2 = calloc(1U, sizeof(struct rrsetinfo ));
#line 264
  rrset = (struct rrsetinfo *)tmp___2;
#line 265
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 266
    result = 1;
    goto fail;
  }
#line 269
  rrset->rri_rdclass = (unsigned int )(response->query)->class;
#line 270
  rrset->rri_rdtype = (unsigned int )(response->query)->type;
#line 271
  rrset->rri_ttl = (unsigned int )(response->answer)->ttl;
#line 272
  rrset->rri_nrdatas = response->header.ancount;
#line 276
  if (response->header.ad == 1U) {
#line 277
    rrset->rri_flags |= 1U;
  }
#line 281
  tmp___12 = __strdup((char const   *)(response->answer)->name);
#line 281
  rrset->rri_name = tmp___12;
#line 282
  if ((unsigned int )rrset->rri_name == (unsigned int )((void *)0)) {
#line 283
    result = 1;
    goto fail;
  }
#line 288
  tmp___13 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short )rrset->rri_rdtype);
#line 288
  rrset->rri_nrdatas = (unsigned int )tmp___13;
#line 290
  tmp___14 = count_dns_rr(response->answer, (unsigned short )rrset->rri_rdclass, (unsigned short)46);
#line 290
  rrset->rri_nsigs = (unsigned int )tmp___14;
#line 294
  tmp___15 = calloc(rrset->rri_nrdatas, sizeof(struct rdatainfo ));
#line 294
  rrset->rri_rdatas = (struct rdatainfo *)tmp___15;
#line 296
  if ((unsigned int )rrset->rri_rdatas == (unsigned int )((void *)0)) {
#line 297
    result = 1;
    goto fail;
  }
#line 302
  if (rrset->rri_nsigs > 0U) {
#line 303
    tmp___16 = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo ));
#line 303
    rrset->rri_sigs = (struct rdatainfo *)tmp___16;
#line 304
    if ((unsigned int )rrset->rri_sigs == (unsigned int )((void *)0)) {
#line 305
      result = 1;
      goto fail;
    }
  }
#line 311
  rr = response->answer;
#line 311
  index_ans = 0U;
#line 311
  index_sig = 0U;
#line 311
  while (rr) {
#line 314
    rdata = (struct rdatainfo *)((void *)0);
#line 316
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 316
      if ((unsigned int )rr->type == rrset->rri_rdtype) {
#line 318
        tmp___17 = index_ans;
#line 318
        index_ans ++;
#line 318
        rdata = rrset->rri_rdatas + tmp___17;
      }
    }
#line 320
    if ((unsigned int )rr->class == rrset->rri_rdclass) {
#line 320
      if ((int )rr->type == 46) {
#line 322
        tmp___18 = index_sig;
#line 322
        index_sig ++;
#line 322
        rdata = rrset->rri_sigs + tmp___18;
      }
    }
#line 324
    if (rdata) {
#line 325
      rdata->rdi_length = (unsigned int )rr->size;
#line 326
      tmp___19 = malloc((unsigned int )rr->size);
#line 326
      rdata->rdi_data = (unsigned char *)tmp___19;
#line 328
      if ((unsigned int )rdata->rdi_data == (unsigned int )((void *)0)) {
#line 329
        result = 1;
        goto fail;
      }
#line 332
      memcpy((void * __restrict  )rdata->rdi_data, (void const   * __restrict  )rr->rdata,
             (unsigned int )rr->size);
    }
#line 311
    rr = rr->next;
  }
#line 335
  free_dns_response(response);
#line 337
  *res = rrset;
#line 338
  return (0);
  fail: 
#line 341
  if ((unsigned int )rrset != (unsigned int )((void *)0)) {
#line 342
    freerrset(rrset);
  }
#line 343
  if ((unsigned int )response != (unsigned int )((void *)0)) {
#line 344
    free_dns_response(response);
  }
#line 345
  return (result);
}
}
#line 348 "openbsd-compat/getrrsetbyname.c"
void freerrset(struct rrsetinfo *rrset ) 
{ u_int16_t i ;

  {
#line 353
  if ((unsigned int )rrset == (unsigned int )((void *)0)) {
#line 354
    return;
  }
#line 356
  if (rrset->rri_rdatas) {
#line 357
    i = (unsigned short)0;
#line 357
    while ((unsigned int )i < rrset->rri_nrdatas) {
#line 358
      if ((unsigned int )(rrset->rri_rdatas + i)->rdi_data == (unsigned int )((void *)0)) {
#line 359
        break;
      }
#line 360
      free((void *)(rrset->rri_rdatas + i)->rdi_data);
#line 357
      i = (u_int16_t )((int )i + 1);
    }
#line 362
    free((void *)rrset->rri_rdatas);
  }
#line 365
  if (rrset->rri_sigs) {
#line 366
    i = (unsigned short)0;
#line 366
    while ((unsigned int )i < rrset->rri_nsigs) {
#line 367
      if ((unsigned int )(rrset->rri_sigs + i)->rdi_data == (unsigned int )((void *)0)) {
#line 368
        break;
      }
#line 369
      free((void *)(rrset->rri_sigs + i)->rdi_data);
#line 366
      i = (u_int16_t )((int )i + 1);
    }
#line 371
    free((void *)rrset->rri_sigs);
  }
#line 374
  if (rrset->rri_name) {
#line 375
    free((void *)rrset->rri_name);
  }
#line 376
  free((void *)rrset);
#line 377
  return;
}
}
#line 382 "openbsd-compat/getrrsetbyname.c"
static struct dns_response *parse_dns_response(u_char const   *answer , int size ) 
{ struct dns_response *resp ;
  u_char const   *cp ;
  void *tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  register unsigned short __v___2 ;
  register unsigned short __x___2 ;

  {
#line 389
  tmp = calloc(1U, sizeof(*resp));
#line 389
  resp = (struct dns_response *)tmp;
#line 390
  if ((unsigned int )resp == (unsigned int )((void *)0)) {
#line 391
    return ((struct dns_response *)((void *)0));
  }
#line 394
  cp = answer;
#line 397
  memcpy((void * __restrict  )(& resp->header), (void const   * __restrict  )cp, 12U);
#line 398
  cp += 12;
#line 401
  __x = (unsigned short )resp->header.qdcount;
#line 401
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 401
  resp->header.qdcount = (unsigned int )__v;
#line 402
  __x___0 = (unsigned short )resp->header.ancount;
#line 402
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 402
  resp->header.ancount = (unsigned int )__v___0;
#line 403
  __x___1 = (unsigned short )resp->header.nscount;
#line 403
  __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 403
  resp->header.nscount = (unsigned int )__v___1;
#line 404
  __x___2 = (unsigned short )resp->header.arcount;
#line 404
  __asm__  ("rorw $8, %w0": "=r" (__v___2): "0" (__x___2): "cc");
#line 404
  resp->header.arcount = (unsigned int )__v___2;
#line 407
  if (resp->header.qdcount < 1U) {
#line 408
    free_dns_response(resp);
#line 409
    return ((struct dns_response *)((void *)0));
  }
#line 413
  resp->query = parse_dns_qsection(answer, size, & cp, (int )resp->header.qdcount);
#line 415
  if (resp->header.qdcount) {
#line 415
    if ((unsigned int )resp->query == (unsigned int )((void *)0)) {
#line 416
      free_dns_response(resp);
#line 417
      return ((struct dns_response *)((void *)0));
    }
  }
#line 421
  resp->answer = parse_dns_rrsection(answer, size, & cp, (int )resp->header.ancount);
#line 423
  if (resp->header.ancount) {
#line 423
    if ((unsigned int )resp->answer == (unsigned int )((void *)0)) {
#line 424
      free_dns_response(resp);
#line 425
      return ((struct dns_response *)((void *)0));
    }
  }
#line 429
  resp->authority = parse_dns_rrsection(answer, size, & cp, (int )resp->header.nscount);
#line 431
  if (resp->header.nscount) {
#line 431
    if ((unsigned int )resp->authority == (unsigned int )((void *)0)) {
#line 432
      free_dns_response(resp);
#line 433
      return ((struct dns_response *)((void *)0));
    }
  }
#line 437
  resp->additional = parse_dns_rrsection(answer, size, & cp, (int )resp->header.arcount);
#line 439
  if (resp->header.arcount) {
#line 439
    if ((unsigned int )resp->additional == (unsigned int )((void *)0)) {
#line 440
      free_dns_response(resp);
#line 441
      return ((struct dns_response *)((void *)0));
    }
  }
#line 444
  return (resp);
}
}
#line 447 "openbsd-compat/getrrsetbyname.c"
static struct dns_query *parse_dns_qsection(u_char const   *answer , int size , u_char const   **cp ,
                                            int count ) 
{ struct dns_query *head ;
  struct dns_query *curr ;
  struct dns_query *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;

  {
#line 454
  i = 1;
#line 454
  head = (struct dns_query *)((void *)0);
#line 454
  prev = (struct dns_query *)((void *)0);
#line 454
  while (i <= count) {
#line 457
    tmp = calloc(1U, sizeof(struct dns_query ));
#line 457
    curr = (struct dns_query *)tmp;
#line 458
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 459
      free_dns_query(head);
#line 460
      return ((struct dns_query *)((void *)0));
    }
#line 462
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 463
      head = curr;
    }
#line 464
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 465
      prev->next = curr;
    }
#line 468
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 470
    if (length < 0) {
#line 471
      free_dns_query(head);
#line 472
      return ((struct dns_query *)((void *)0));
    }
#line 474
    tmp___9 = __strdup((char const   *)(name));
#line 474
    curr->name = tmp___9;
#line 475
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 476
      free_dns_query(head);
#line 477
      return ((struct dns_query *)((void *)0));
    }
#line 479
    *cp += length;
#line 482
    curr->type = _getshort(*cp);
#line 483
    *cp += 2;
#line 486
    curr->class = _getshort(*cp);
#line 487
    *cp += 2;
#line 454
    i ++;
#line 454
    prev = curr;
  }
#line 490
  return (head);
}
}
#line 493 "openbsd-compat/getrrsetbyname.c"
static struct dns_rr *parse_dns_rrsection(u_char const   *answer , int size , u_char const   **cp ,
                                          int count ) 
{ struct dns_rr *head ;
  struct dns_rr *curr ;
  struct dns_rr *prev ;
  int i ;
  int length ;
  char name[1025] ;
  void *tmp ;
  char *tmp___9 ;
  u_int32_t tmp___10 ;

  {
#line 501
  i = 1;
#line 501
  head = (struct dns_rr *)((void *)0);
#line 501
  prev = (struct dns_rr *)((void *)0);
#line 501
  while (i <= count) {
#line 504
    tmp = calloc(1U, sizeof(struct dns_rr ));
#line 504
    curr = (struct dns_rr *)tmp;
#line 505
    if ((unsigned int )curr == (unsigned int )((void *)0)) {
#line 506
      free_dns_rr(head);
#line 507
      return ((struct dns_rr *)((void *)0));
    }
#line 509
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 510
      head = curr;
    }
#line 511
    if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 512
      prev->next = curr;
    }
#line 515
    length = __dn_expand(answer, answer + size, *cp, name, (int )sizeof(name));
#line 517
    if (length < 0) {
#line 518
      free_dns_rr(head);
#line 519
      return ((struct dns_rr *)((void *)0));
    }
#line 521
    tmp___9 = __strdup((char const   *)(name));
#line 521
    curr->name = tmp___9;
#line 522
    if ((unsigned int )curr->name == (unsigned int )((void *)0)) {
#line 523
      free_dns_rr(head);
#line 524
      return ((struct dns_rr *)((void *)0));
    }
#line 526
    *cp += length;
#line 529
    curr->type = _getshort(*cp);
#line 530
    *cp += 2;
#line 533
    curr->class = _getshort(*cp);
#line 534
    *cp += 2;
#line 537
    tmp___10 = _getlong(*cp);
#line 537
    curr->ttl = (unsigned short )tmp___10;
#line 538
    *cp += 4;
#line 541
    curr->size = _getshort(*cp);
#line 542
    *cp += 2;
#line 545
    curr->rdata = malloc((unsigned int )curr->size);
#line 546
    if ((unsigned int )curr->rdata == (unsigned int )((void *)0)) {
#line 547
      free_dns_rr(head);
#line 548
      return ((struct dns_rr *)((void *)0));
    }
#line 550
    memcpy((void * __restrict  )curr->rdata, (void const   * __restrict  )*cp, (unsigned int )curr->size);
#line 551
    *cp += (int )curr->size;
#line 501
    i ++;
#line 501
    prev = curr;
  }
#line 554
  return (head);
}
}
#line 557 "openbsd-compat/getrrsetbyname.c"
static void free_dns_query(struct dns_query *p ) 
{ 

  {
#line 560
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 561
    return;
  }
#line 563
  if (p->name) {
#line 564
    free((void *)p->name);
  }
#line 565
  free_dns_query(p->next);
#line 566
  free((void *)p);
#line 567
  return;
}
}
#line 569 "openbsd-compat/getrrsetbyname.c"
static void free_dns_rr(struct dns_rr *p ) 
{ 

  {
#line 572
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 573
    return;
  }
#line 575
  if (p->name) {
#line 576
    free((void *)p->name);
  }
#line 577
  if (p->rdata) {
#line 578
    free(p->rdata);
  }
#line 579
  free_dns_rr(p->next);
#line 580
  free((void *)p);
#line 581
  return;
}
}
#line 583 "openbsd-compat/getrrsetbyname.c"
static void free_dns_response(struct dns_response *p ) 
{ 

  {
#line 586
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 587
    return;
  }
#line 589
  free_dns_query(p->query);
#line 590
  free_dns_rr(p->answer);
#line 591
  free_dns_rr(p->authority);
#line 592
  free_dns_rr(p->additional);
#line 593
  free((void *)p);
#line 594
  return;
}
}
#line 596 "openbsd-compat/getrrsetbyname.c"
static int count_dns_rr(struct dns_rr *p , u_int16_t class , u_int16_t type ) 
{ int n___0 ;

  {
#line 599
  n___0 = 0;
#line 601
  while (p) {
#line 602
    if ((int )p->class == (int )class) {
#line 602
      if ((int )p->type == (int )type) {
#line 603
        n___0 ++;
      }
    }
#line 604
    p = p->next;
  }
#line 607
  return (n___0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
#line 1 "glob.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 394
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __asm__("__xstat64") __attribute__((__nonnull__(2,3))) ;
#line 397
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __asm__("__lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 436
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 443
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 443
  return (tmp);
}
}
#line 600 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 93 "./openbsd-compat/glob.h"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) ;
#line 94
void globfree(glob_t *pglob ) ;
#line 74 "./openbsd-compat/openbsd-compat.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 54 "openbsd-compat/glob.c"
static long get_arg_max(void) 
{ 

  {
#line 58
  return (131072L);
}
}
#line 143
static int compare(void const   *p , void const   *q ) ;
#line 144
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) ;
#line 145
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 146
static DIR *g_opendir(Char *str , glob_t *pglob ) ;
#line 147
static Char *g_strchr(Char *str , int ch ) ;
#line 148
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) ;
#line 149
static int glob0(Char const   *pattern , glob_t *pglob ) ;
#line 150
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 151
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) ;
#line 153
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *restpattern , Char *restpattern_last , glob_t *pglob ,
                 size_t *limitp ) ;
#line 155
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) ;
#line 156
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) ;
#line 158
static int globexp1(Char const   *pattern , glob_t *pglob ) ;
#line 159
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) ;
#line 160
static int match(Char *name , Char *pat , Char *patend ) ;
#line 165 "openbsd-compat/glob.c"
int glob(char const   *pattern , int flags , int (*errfunc)(char const   * , int  ) ,
         glob_t *pglob ) 
{ u_char const   *patnext ;
  int c ;
  Char *bufnext ;
  Char *bufend ;
  Char patbuf[4096] ;
  Char *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  u_char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 173
  patnext = (u_char const   *)((u_char *)pattern);
#line 174
  if (! (flags & 1)) {
#line 175
    pglob->gl_pathc = 0;
#line 176
    pglob->gl_pathv = (char **)((void *)0);
#line 177
    if (! (flags & 2)) {
#line 178
      pglob->gl_offs = 0;
    }
  }
#line 180
  pglob->gl_flags = flags & -257;
#line 181
  pglob->gl_errfunc = errfunc;
#line 182
  pglob->gl_matchc = 0;
#line 184
  bufnext = patbuf;
#line 185
  bufend = (bufnext + 4096) - 1;
#line 186
  if (flags & 4096) {
#line 187
    while (1) {
#line 187
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 187
        tmp___0 = patnext;
#line 187
        patnext ++;
#line 187
        c = (int )*tmp___0;
#line 187
        if (! (c != 0)) {
#line 187
          break;
        }
      } else {
#line 187
        break;
      }
#line 188
      tmp = bufnext;
#line 188
      bufnext ++;
#line 188
      *tmp = (unsigned short )c;
    }
  } else {
#line 191
    while (1) {
#line 191
      if ((unsigned int )bufnext < (unsigned int )bufend) {
#line 191
        tmp___4 = patnext;
#line 191
        patnext ++;
#line 191
        c = (int )*tmp___4;
#line 191
        if (! (c != 0)) {
#line 191
          break;
        }
      } else {
#line 191
        break;
      }
#line 192
      if (c == 92) {
#line 193
        tmp___1 = patnext;
#line 193
        patnext ++;
#line 193
        c = (int )*tmp___1;
#line 193
        if (c == 0) {
#line 194
          c = '\\';
#line 195
          patnext --;
        }
#line 197
        tmp___2 = bufnext;
#line 197
        bufnext ++;
#line 197
        *tmp___2 = (unsigned short )(c | 16384);
      } else {
#line 199
        tmp___3 = bufnext;
#line 199
        bufnext ++;
#line 199
        *tmp___3 = (unsigned short )c;
      }
    }
  }
#line 201
  *bufnext = (unsigned short )'\000';
#line 203
  if (flags & 128) {
#line 204
    tmp___5 = globexp1((Char const   *)(patbuf), pglob);
#line 204
    return (tmp___5);
  } else {
#line 206
    tmp___6 = glob0((Char const   *)(patbuf), pglob);
#line 206
    return (tmp___6);
  }
}
}
#line 214 "openbsd-compat/glob.c"
static int globexp1(Char const   *pattern , glob_t *pglob ) 
{ Char const   *ptr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  int tmp___2 ;

  {
#line 217
  ptr = pattern;
#line 221
  if ((int const   )*(pattern + 0) == 123) {
#line 221
    if ((int const   )*(pattern + 1) == 125) {
#line 221
      if ((int const   )*(pattern + 2) == 0) {
#line 222
        tmp = glob0(pattern, pglob);
#line 222
        return (tmp);
      }
    }
  }
#line 224
  while (1) {
#line 224
    tmp___1 = g_strchr((Char *)ptr, '{');
#line 224
    ptr = (Char const   *)tmp___1;
#line 224
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 224
      break;
    }
#line 225
    tmp___0 = globexp2(ptr, pattern, pglob, & rv);
#line 225
    if (! tmp___0) {
#line 226
      return (rv);
    }
  }
#line 228
  tmp___2 = glob0(pattern, pglob);
#line 228
  return (tmp___2);
}
}
#line 237 "openbsd-compat/glob.c"
static int globexp2(Char const   *ptr , Char const   *pattern , glob_t *pglob , int *rv ) 
{ int i ;
  Char *lm ;
  Char *ls ;
  Char const   *pe ;
  Char const   *pm ;
  Char const   *pl ;
  Char patbuf[4096] ;
  Char *tmp ;
  Char const   *tmp___0 ;
  Char const   *tmp___1 ;
  Char const   *tmp___2 ;
  Char *tmp___3 ;
  Char const   *tmp___4 ;
  Char *tmp___5 ;
  Char const   *tmp___6 ;

  {
#line 246
  lm = patbuf;
#line 246
  pm = pattern;
#line 246
  while ((unsigned int )pm != (unsigned int )ptr) {
#line 246
    tmp = lm;
#line 246
    lm ++;
#line 246
    tmp___0 = pm;
#line 246
    pm ++;
#line 246
    *tmp = (unsigned short )*tmp___0;
  }
#line 248
  *lm = (unsigned short )'\000';
#line 249
  ls = lm;
#line 252
  i = 0;
#line 252
  ptr ++;
#line 252
  pe = ptr;
#line 252
  while (*pe) {
#line 253
    if ((int const   )*pe == 91) {
#line 255
      tmp___1 = pe;
#line 255
      pe ++;
#line 255
      pm = tmp___1;
#line 255
      while (1) {
#line 255
        if ((int const   )*pe != 93) {
#line 255
          if (! ((int const   )*pe != 0)) {
#line 255
            break;
          }
        } else {
#line 255
          break;
        }
#line 255
        pe ++;
      }
#line 257
      if ((int const   )*pe == 0) {
#line 262
        pe = pm;
      }
    } else {
#line 264
      if ((int const   )*pe == 123) {
#line 265
        i ++;
      } else {
#line 266
        if ((int const   )*pe == 125) {
#line 267
          if (i == 0) {
#line 268
            break;
          }
#line 269
          i --;
        }
      }
    }
#line 252
    pe ++;
  }
#line 273
  if (i != 0) {
#line 274
    *rv = glob0((Char const   *)(patbuf), pglob);
#line 275
    return (0);
  } else {
#line 273
    if ((int const   )*pe == 0) {
#line 274
      *rv = glob0((Char const   *)(patbuf), pglob);
#line 275
      return (0);
    }
  }
#line 278
  i = 0;
#line 278
  pm = ptr;
#line 278
  pl = pm;
#line 278
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 279
    switch ((int )*pm) {
    case 91: 
#line 282
    tmp___2 = pm;
#line 282
    pm ++;
#line 282
    pl = tmp___2;
#line 282
    while (1) {
#line 282
      if ((int const   )*pm != 93) {
#line 282
        if (! ((int const   )*pm != 0)) {
#line 282
          break;
        }
      } else {
#line 282
        break;
      }
#line 282
      pm ++;
    }
#line 284
    if ((int const   )*pm == 0) {
#line 289
      pm = pl;
    }
#line 291
    break;
    case 123: 
#line 294
    i ++;
#line 295
    break;
    case 125: 
#line 298
    if (i) {
#line 299
      i --;
#line 300
      break;
    }
    case 44: 
#line 304
    if (i) {
#line 304
      if ((int const   )*pm == 44) {
#line 305
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 308
      lm = ls;
#line 308
      while ((unsigned int )pl < (unsigned int )pm) {
#line 308
        tmp___3 = lm;
#line 308
        lm ++;
#line 308
        tmp___4 = pl;
#line 308
        pl ++;
#line 308
        *tmp___3 = (unsigned short )*tmp___4;
      }
#line 315
      pl = pe + 1;
#line 315
      while (1) {
#line 315
        tmp___5 = lm;
#line 315
        lm ++;
#line 315
        tmp___6 = pl;
#line 315
        pl ++;
#line 315
        *tmp___5 = (unsigned short )*tmp___6;
#line 315
        if (! ((int )*tmp___5 != 0)) {
#line 315
          break;
        }
      }
#line 322
      *rv = globexp1((Char const   *)(patbuf), pglob);
#line 325
      pl = pm + 1;
    }
#line 327
    break;
    default: ;
#line 330
    break;
    }
#line 278
    pm ++;
  }
#line 333
  *rv = 0;
#line 334
  return (0);
}
}
#line 342 "openbsd-compat/glob.c"
static Char const   *globtilde(Char const   *pattern , Char *patbuf , size_t patbuf_len ,
                               glob_t *pglob ) 
{ struct passwd *pwd ;
  char *h___0 ;
  Char const   *p ;
  Char *b ;
  Char *eb ;
  char *tmp ;
  Char const   *tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  __uid_t tmp___3 ;
  Char *tmp___4 ;
  char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;

  {
#line 350
  if ((int const   )*pattern != 126) {
#line 351
    return (pattern);
  } else {
#line 350
    if (! (pglob->gl_flags & 2048)) {
#line 351
      return (pattern);
    }
  }
#line 354
  eb = patbuf + (patbuf_len - 1U);
#line 355
  p = pattern + 1;
#line 355
  h___0 = (char *)patbuf;
#line 355
  while (1) {
#line 355
    if ((unsigned int )h___0 < (unsigned int )((char *)eb)) {
#line 355
      if (*p) {
#line 355
        if (! ((int const   )*p != 47)) {
#line 355
          break;
        }
      } else {
#line 355
        break;
      }
    } else {
#line 355
      break;
    }
#line 355
    tmp = h___0;
#line 355
    h___0 ++;
#line 355
    tmp___0 = p;
#line 355
    p ++;
#line 355
    *tmp = (char )*tmp___0;
  }
#line 359
  *h___0 = (char )'\000';
#line 366
  if ((int )*((char *)patbuf + 0) == 0) {
#line 374
    tmp___2 = getuid();
#line 374
    tmp___3 = geteuid();
#line 374
    if (tmp___2 != tmp___3) {
      goto _L;
    } else {
#line 374
      h___0 = getenv("HOME");
#line 374
      if ((unsigned int )h___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 375
        tmp___1 = getuid();
#line 375
        pwd = getpwuid(tmp___1);
#line 375
        if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 376
          return (pattern);
        } else {
#line 378
          h___0 = pwd->pw_dir;
        }
      }
    }
  } else {
#line 384
    pwd = getpwnam((char const   *)((char *)patbuf));
#line 384
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 385
      return (pattern);
    } else {
#line 387
      h___0 = pwd->pw_dir;
    }
  }
#line 391
  b = patbuf;
#line 391
  while (1) {
#line 391
    if ((unsigned int )b < (unsigned int )eb) {
#line 391
      if (! *h___0) {
#line 391
        break;
      }
    } else {
#line 391
      break;
    }
#line 391
    tmp___4 = b;
#line 391
    b ++;
#line 391
    tmp___5 = h___0;
#line 391
    h___0 ++;
#line 391
    *tmp___4 = (unsigned short )*tmp___5;
  }
#line 395
  while (1) {
#line 395
    if ((unsigned int )b < (unsigned int )eb) {
#line 395
      tmp___6 = b;
#line 395
      b ++;
#line 395
      tmp___7 = p;
#line 395
      p ++;
#line 395
      *tmp___6 = (unsigned short )*tmp___7;
#line 395
      if (! ((int )*tmp___6 != 0)) {
#line 395
        break;
      }
    } else {
#line 395
      break;
    }
  }
#line 397
  *b = (unsigned short )'\000';
#line 399
  return ((Char const   *)patbuf);
}
}
#line 410 "openbsd-compat/glob.c"
static int glob0(Char const   *pattern , glob_t *pglob ) 
{ Char const   *qpatnext ;
  int c ;
  int err ;
  int oldpathc ;
  Char *bufnext ;
  Char patbuf[4096] ;
  size_t limit ;
  Char *tmp ;
  Char *tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char const   *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  Char const   *tmp___7 ;
  Char *tmp___8 ;
  Char *tmp___9 ;
  Char *tmp___10 ;
  Char *tmp___11 ;
  Char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 416
  limit = (size_t )0;
#line 418
  qpatnext = globtilde(pattern, patbuf, 4096U, pglob);
#line 419
  oldpathc = pglob->gl_pathc;
#line 420
  bufnext = patbuf;
#line 423
  while (1) {
#line 423
    tmp___12 = qpatnext;
#line 423
    qpatnext ++;
#line 423
    c = (int )*tmp___12;
#line 423
    if (! (c != 0)) {
#line 423
      break;
    }
#line 424
    switch (c) {
    case 91: 
#line 426
    c = (int )*qpatnext;
#line 427
    if (c == 33) {
#line 428
      qpatnext ++;
    }
#line 429
    if ((int const   )*qpatnext == 0) {
      goto _L;
    } else {
#line 429
      tmp___0 = g_strchr((Char *)qpatnext + 1, ']');
#line 429
      if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 431
        tmp = bufnext;
#line 431
        bufnext ++;
#line 431
        *tmp = (unsigned short )'[';
#line 432
        if (c == 33) {
#line 433
          qpatnext --;
        }
#line 434
        break;
      }
    }
#line 436
    tmp___1 = bufnext;
#line 436
    bufnext ++;
#line 436
    *tmp___1 = (unsigned short)32859;
#line 437
    if (c == 33) {
#line 438
      tmp___2 = bufnext;
#line 438
      bufnext ++;
#line 438
      *tmp___2 = (unsigned short)32801;
    }
#line 439
    tmp___3 = qpatnext;
#line 439
    qpatnext ++;
#line 439
    c = (int )*tmp___3;
#line 440
    while (1) {
#line 441
      tmp___4 = bufnext;
#line 441
      bufnext ++;
#line 441
      *tmp___4 = (unsigned short )(c & 255);
#line 442
      if ((int const   )*qpatnext == 45) {
#line 442
        c = (int )*(qpatnext + 1);
#line 442
        if (c != 93) {
#line 444
          tmp___5 = bufnext;
#line 444
          bufnext ++;
#line 444
          *tmp___5 = (unsigned short)32813;
#line 445
          tmp___6 = bufnext;
#line 445
          bufnext ++;
#line 445
          *tmp___6 = (unsigned short )(c & 255);
#line 446
          qpatnext += 2;
        }
      }
#line 440
      tmp___7 = qpatnext;
#line 440
      qpatnext ++;
#line 440
      c = (int )*tmp___7;
#line 440
      if (! (c != 93)) {
#line 440
        break;
      }
    }
#line 449
    pglob->gl_flags |= 256;
#line 450
    tmp___8 = bufnext;
#line 450
    bufnext ++;
#line 450
    *tmp___8 = (unsigned short)32861;
#line 451
    break;
    case 63: 
#line 453
    pglob->gl_flags |= 256;
#line 454
    tmp___9 = bufnext;
#line 454
    bufnext ++;
#line 454
    *tmp___9 = (unsigned short)32831;
#line 455
    break;
    case 42: 
#line 457
    pglob->gl_flags |= 256;
#line 461
    if ((unsigned int )bufnext == (unsigned int )(patbuf)) {
#line 462
      tmp___10 = bufnext;
#line 462
      bufnext ++;
#line 462
      *tmp___10 = (unsigned short)32810;
    } else {
#line 461
      if ((int )*(bufnext + -1) != 32810) {
#line 462
        tmp___10 = bufnext;
#line 462
        bufnext ++;
#line 462
        *tmp___10 = (unsigned short)32810;
      }
    }
#line 463
    break;
    default: 
#line 465
    tmp___11 = bufnext;
#line 465
    bufnext ++;
#line 465
    *tmp___11 = (unsigned short )(c & 255);
#line 466
    break;
    }
  }
#line 469
  *bufnext = (unsigned short )'\000';
#line 474
  err = glob1(patbuf, (patbuf + 4096) - 1, pglob, & limit);
#line 474
  if (err != 0) {
#line 475
    return (err);
  }
#line 483
  if (pglob->gl_pathc == oldpathc) {
#line 484
    if (pglob->gl_flags & 16) {
#line 487
      tmp___13 = globextend(pattern, pglob, & limit);
#line 487
      return (tmp___13);
    } else {
#line 484
      if (pglob->gl_flags & 512) {
#line 484
        if (! (pglob->gl_flags & 256)) {
#line 487
          tmp___13 = globextend(pattern, pglob, & limit);
#line 487
          return (tmp___13);
        } else {
#line 489
          return (-3);
        }
      } else {
#line 489
        return (-3);
      }
    }
  }
#line 491
  if (! (pglob->gl_flags & 32)) {
#line 492
    qsort((void *)((pglob->gl_pathv + pglob->gl_offs) + oldpathc), (unsigned int )(pglob->gl_pathc - oldpathc),
          sizeof(char *), & compare);
  }
#line 494
  return (0);
}
}
#line 497 "openbsd-compat/glob.c"
static int compare(void const   *p , void const   *q ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 500
  if (0) {
#line 500
    __s1_len = strlen((char const   *)*((char **)p));
#line 500
    __s2_len = strlen((char const   *)*((char **)q));
#line 500
    if (! ((unsigned int )((void const   *)(*((char **)p) + 1)) - (unsigned int )((void const   *)*((char **)p)) == 1U)) {
      goto _L___0;
    } else {
#line 500
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 500
        if (! ((unsigned int )((void const   *)(*((char **)q) + 1)) - (unsigned int )((void const   *)*((char **)q)) == 1U)) {
#line 500
          tmp___8 = 1;
        } else {
#line 500
          if (__s2_len >= 4U) {
#line 500
            tmp___8 = 1;
          } else {
#line 500
            tmp___8 = 0;
          }
        }
      } else {
#line 500
        tmp___8 = 0;
      }
    }
#line 500
    if (tmp___8) {
#line 500
      tmp___4 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
    } else {
#line 500
      tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 500
      tmp___4 = tmp___7;
    }
  } else {
#line 500
    tmp___7 = __builtin_strcmp((char const   *)*((char **)p), (char const   *)*((char **)q));
#line 500
    tmp___4 = tmp___7;
  }
#line 500
  return (tmp___4);
}
}
#line 503 "openbsd-compat/glob.c"
static int glob1(Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ Char pathbuf[4096] ;
  int tmp ;

  {
#line 509
  if ((int )*pattern == 0) {
#line 510
    return (0);
  }
#line 511
  tmp = glob2(pathbuf, (pathbuf + 4096) - 1, pathbuf, (pathbuf + 4096) - 1, pattern,
              pattern_last, pglob, limitp);
#line 511
  return (tmp);
}
}
#line 521 "openbsd-compat/glob.c"
static int glob2(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *pattern_last , glob_t *pglob , size_t *limitp ) 
{ struct stat sb ;
  Char *p ;
  Char *q ;
  int anymeta ;
  int tmp ;
  Char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;
  Char *tmp___6 ;
  int tmp___7 ;

  {
#line 533
  anymeta = 0;
#line 533
  while (1) {
#line 534
    if ((int )*pattern == 0) {
#line 535
      *pathend = (unsigned short )'\000';
#line 536
      tmp = g_lstat(pathbuf, & sb, pglob);
#line 536
      if (tmp) {
#line 537
        return (0);
      }
#line 539
      if (pglob->gl_flags & 8) {
#line 539
        if ((int )*(pathend + -1) != 47) {
#line 539
          if ((sb.st_mode & 61440U) == 16384U) {
            goto _L;
          } else {
#line 539
            if ((sb.st_mode & 61440U) == 40960U) {
#line 539
              tmp___1 = g_stat(pathbuf, & sb, pglob);
#line 539
              if (tmp___1 == 0) {
#line 539
                if ((sb.st_mode & 61440U) == 16384U) {
                  _L: /* CIL Label */ 
#line 544
                  if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 545
                    return (1);
                  }
#line 546
                  tmp___0 = pathend;
#line 546
                  pathend ++;
#line 546
                  *tmp___0 = (unsigned short )'/';
#line 547
                  *pathend = (unsigned short )'\000';
                }
              }
            }
          }
        }
      }
#line 549
      (pglob->gl_matchc) ++;
#line 550
      tmp___2 = globextend((Char const   *)pathbuf, pglob, limitp);
#line 550
      return (tmp___2);
    }
#line 554
    q = pathend;
#line 555
    p = pattern;
#line 556
    while (1) {
#line 556
      if ((int )*p != 0) {
#line 556
        if (! ((int )*p != 47)) {
#line 556
          break;
        }
      } else {
#line 556
        break;
      }
#line 557
      if (((int )*p & 32768) != 0) {
#line 558
        anymeta = 1;
      }
#line 559
      if ((unsigned int )(q + 1) > (unsigned int )pathend_last) {
#line 560
        return (1);
      }
#line 561
      tmp___3 = q;
#line 561
      q ++;
#line 561
      tmp___4 = p;
#line 561
      p ++;
#line 561
      *tmp___3 = *tmp___4;
    }
#line 564
    if (! anymeta) {
#line 565
      pathend = q;
#line 566
      pattern = p;
#line 567
      while ((int )*pattern == 47) {
#line 568
        if ((unsigned int )(pathend + 1) > (unsigned int )pathend_last) {
#line 569
          return (1);
        }
#line 570
        tmp___5 = pathend;
#line 570
        pathend ++;
#line 570
        tmp___6 = pattern;
#line 570
        pattern ++;
#line 570
        *tmp___5 = *tmp___6;
      }
    } else {
#line 574
      tmp___7 = glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, p, pattern_last,
                      pglob, limitp);
#line 574
      return (tmp___7);
    }
  }
}
}
#line 581 "openbsd-compat/glob.c"
static int glob3(Char *pathbuf , Char *pathbuf_last , Char *pathend , Char *pathend_last ,
                 Char *pattern , Char *restpattern , Char *restpattern_last , glob_t *pglob ,
                 size_t *limitp ) 
{ struct dirent *dp ;
  DIR *dirp ;
  int err ;
  char buf___1[4096] ;
  struct dirent *(*readdirfunc)(void * ) ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  u_char *sc ;
  Char *dc ;
  Char *tmp___3 ;
  u_char *tmp___4 ;
  int tmp___5 ;

  {
#line 599
  if ((unsigned int )pathend > (unsigned int )pathend_last) {
#line 600
    return (1);
  }
#line 601
  *pathend = (unsigned short )'\000';
#line 602
  tmp = __errno_location();
#line 602
  *tmp = 0;
#line 604
  dirp = g_opendir(pathbuf, pglob);
#line 604
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 606
    if (pglob->gl_errfunc) {
#line 607
      tmp___0 = g_Ctoc((Char const   *)pathbuf, buf___1, sizeof(buf___1));
#line 607
      if (tmp___0) {
#line 608
        return (-2);
      }
#line 609
      tmp___1 = __errno_location();
#line 609
      tmp___2 = (*(pglob->gl_errfunc))((char const   *)(buf___1), *tmp___1);
#line 609
      if (tmp___2) {
#line 611
        return (-2);
      } else {
#line 609
        if (pglob->gl_flags & 4) {
#line 611
          return (-2);
        }
      }
    }
#line 613
    return (0);
  }
#line 616
  err = 0;
#line 619
  if (pglob->gl_flags & 64) {
#line 620
    readdirfunc = pglob->gl_readdir;
  } else {
#line 622
    readdirfunc = (struct dirent *(*)(void * ))(& readdir);
  }
#line 623
  while (1) {
#line 623
    dp = (*readdirfunc)((void *)dirp);
#line 623
    if (! dp) {
#line 623
      break;
    }
#line 628
    if ((int )dp->d_name[0] == 46) {
#line 628
      if ((int )*pattern != 46) {
#line 629
        continue;
      }
    }
#line 630
    dc = pathend;
#line 631
    sc = (u_char *)(dp->d_name);
#line 632
    while (1) {
#line 632
      if ((unsigned int )dc < (unsigned int )pathend_last) {
#line 632
        tmp___3 = dc;
#line 632
        dc ++;
#line 632
        tmp___4 = sc;
#line 632
        sc ++;
#line 632
        *tmp___3 = (unsigned short )*tmp___4;
#line 632
        if (! ((int )*tmp___3 != 0)) {
#line 632
          break;
        }
      } else {
#line 632
        break;
      }
    }
#line 634
    if ((unsigned int )dc >= (unsigned int )pathend_last) {
#line 635
      *dc = (unsigned short )'\000';
#line 636
      err = 1;
#line 637
      break;
    }
#line 640
    tmp___5 = match(pathend, pattern, restpattern);
#line 640
    if (! tmp___5) {
#line 641
      *pathend = (unsigned short )'\000';
#line 642
      continue;
    }
#line 644
    dc --;
#line 644
    err = glob2(pathbuf, pathbuf_last, dc, pathend_last, restpattern, restpattern_last,
                pglob, limitp);
#line 646
    if (err) {
#line 647
      break;
    }
  }
#line 650
  if (pglob->gl_flags & 64) {
#line 651
    (*(pglob->gl_closedir))((void *)dirp);
  } else {
#line 653
    closedir(dirp);
  }
#line 654
  return (err);
}
}
#line 672 "openbsd-compat/glob.c"
static int globextend(Char const   *path , glob_t *pglob , size_t *limitp ) 
{ char **pathv ;
  int i ;
  u_int newsize ;
  u_int len ;
  char *copy ;
  Char const   *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  Char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;

  {
#line 681
  newsize = sizeof(*pathv) * (unsigned int )((2 + pglob->gl_pathc) + pglob->gl_offs);
#line 682
  if (pglob->gl_pathv) {
#line 682
    tmp___1 = realloc((void *)((char *)pglob->gl_pathv), newsize);
#line 682
    pathv = (char **)tmp___1;
  } else {
#line 682
    tmp___2 = malloc(newsize);
#line 682
    pathv = (char **)tmp___2;
  }
#line 684
  if ((unsigned int )pathv == (unsigned int )((void *)0)) {
#line 685
    if (pglob->gl_pathv) {
#line 686
      free((void *)pglob->gl_pathv);
#line 687
      pglob->gl_pathv = (char **)((void *)0);
    }
#line 689
    return (-1);
  }
#line 692
  if ((unsigned int )pglob->gl_pathv == (unsigned int )((void *)0)) {
#line 692
    if (pglob->gl_offs > 0) {
#line 694
      pathv += pglob->gl_offs;
#line 695
      i = pglob->gl_offs;
#line 695
      while (1) {
#line 695
        i --;
#line 695
        if (! (i >= 0)) {
#line 695
          break;
        }
#line 696
        pathv --;
#line 696
        *pathv = (char *)((void *)0);
      }
    }
  }
#line 698
  pglob->gl_pathv = pathv;
#line 700
  p = path;
#line 700
  while (1) {
#line 700
    tmp___3 = p;
#line 700
    p ++;
#line 700
    if (! *tmp___3) {
#line 700
      break;
    }
  }
#line 702
  len = (unsigned int )(p - path);
#line 703
  *limitp += len;
#line 704
  tmp___6 = malloc(len);
#line 704
  copy = (char *)tmp___6;
#line 704
  if ((unsigned int )copy != (unsigned int )((void *)0)) {
#line 705
    tmp___4 = g_Ctoc(path, copy, len);
#line 705
    if (tmp___4) {
#line 706
      free((void *)copy);
#line 707
      return (-1);
    }
#line 709
    tmp___5 = pglob->gl_pathc;
#line 709
    (pglob->gl_pathc) ++;
#line 709
    *(pathv + (pglob->gl_offs + tmp___5)) = copy;
  }
#line 711
  *(pathv + (pglob->gl_offs + pglob->gl_pathc)) = (char *)((void *)0);
#line 713
  if (pglob->gl_flags & 8192) {
#line 713
    tmp___8 = get_arg_max();
#line 713
    if (newsize + *limitp >= (unsigned int )tmp___8) {
#line 715
      tmp___7 = __errno_location();
#line 715
      *tmp___7 = 0;
#line 716
      return (-1);
    }
  }
#line 719
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 719
    tmp___9 = -1;
  } else {
#line 719
    tmp___9 = 0;
  }
#line 719
  return (tmp___9);
}
}
#line 727 "openbsd-compat/glob.c"
static int match(Char *name , Char *pat , Char *patend ) 
{ int ok ;
  int negate_range ;
  Char c ;
  Char k ;
  Char *tmp ;
  int tmp___0 ;
  Char *tmp___1 ;
  Char *tmp___2 ;
  Char *tmp___3 ;
  Char *tmp___4 ;
  Char *tmp___5 ;

  {
#line 733
  while ((unsigned int )pat < (unsigned int )patend) {
#line 734
    tmp = pat;
#line 734
    pat ++;
#line 734
    c = *tmp;
#line 735
    switch ((int )c & 65535) {
    case (unsigned short)32810: 
#line 737
    if ((unsigned int )pat == (unsigned int )patend) {
#line 738
      return (1);
    }
#line 739
    while (1) {
#line 740
      tmp___0 = match(name, pat, patend);
#line 740
      if (tmp___0) {
#line 741
        return (1);
      }
#line 739
      tmp___1 = name;
#line 739
      name ++;
#line 739
      if (! ((int )*tmp___1 != 0)) {
#line 739
        break;
      }
    }
#line 743
    return (0);
    case (unsigned short)32831: 
#line 745
    tmp___2 = name;
#line 745
    name ++;
#line 745
    if ((int )*tmp___2 == 0) {
#line 746
      return (0);
    }
#line 747
    break;
    case (unsigned short)32859: 
#line 749
    ok = 0;
#line 750
    tmp___3 = name;
#line 750
    name ++;
#line 750
    k = *tmp___3;
#line 750
    if ((int )k == 0) {
#line 751
      return (0);
    }
#line 752
    negate_range = ((int )*pat & 65535) == 32801;
#line 752
    if (negate_range != 0) {
#line 753
      pat ++;
    }
#line 754
    while (1) {
#line 754
      tmp___4 = pat;
#line 754
      pat ++;
#line 754
      c = *tmp___4;
#line 754
      if (! (((int )c & 65535) != 32861)) {
#line 754
        break;
      }
#line 755
      if (((int )*pat & 65535) == 32813) {
#line 756
        if ((int )c <= (int )k) {
#line 756
          if ((int )k <= (int )*(pat + 1)) {
#line 757
            ok = 1;
          }
        }
#line 758
        pat += 2;
      } else {
#line 759
        if ((int )c == (int )k) {
#line 760
          ok = 1;
        }
      }
    }
#line 761
    if (ok == negate_range) {
#line 762
      return (0);
    }
#line 763
    break;
    default: 
#line 765
    tmp___5 = name;
#line 765
    name ++;
#line 765
    if ((int )*tmp___5 != (int )c) {
#line 766
      return (0);
    }
#line 767
    break;
    }
  }
#line 770
  return ((int )*name == 0);
}
}
#line 774 "openbsd-compat/glob.c"
void globfree(glob_t *pglob ) 
{ int i ;
  char **pp ;
  int tmp ;

  {
#line 780
  if ((unsigned int )pglob->gl_pathv != (unsigned int )((void *)0)) {
#line 781
    pp = pglob->gl_pathv + pglob->gl_offs;
#line 782
    i = pglob->gl_pathc;
#line 782
    while (1) {
#line 782
      tmp = i;
#line 782
      i --;
#line 782
      if (! tmp) {
#line 782
        break;
      }
#line 783
      if (*pp) {
#line 784
        free((void *)*pp);
      }
#line 782
      pp ++;
    }
#line 785
    free((void *)pglob->gl_pathv);
#line 786
    pglob->gl_pathv = (char **)((void *)0);
  }
#line 788
  return;
}
}
#line 790 "openbsd-compat/glob.c"
static DIR *g_opendir(Char *str , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  void *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 795
  if (! *str) {
#line 796
    strlcpy(buf___1, ".", sizeof(buf___1));
  } else {
#line 798
    tmp = g_Ctoc((Char const   *)str, buf___1, sizeof(buf___1));
#line 798
    if (tmp) {
#line 799
      return ((DIR *)((void *)0));
    }
  }
#line 802
  if (pglob->gl_flags & 64) {
#line 803
    tmp___0 = (*(pglob->gl_opendir))((char const   *)(buf___1));
#line 803
    return ((DIR *)tmp___0);
  }
#line 805
  tmp___1 = opendir((char const   *)(buf___1));
#line 805
  return (tmp___1);
}
}
#line 808 "openbsd-compat/glob.c"
static int g_lstat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 813
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 813
  if (tmp) {
#line 814
    return (-1);
  }
#line 815
  if (pglob->gl_flags & 64) {
#line 816
    tmp___0 = (*(pglob->gl_lstat))((char const   *)(buf___1), sb);
#line 816
    return (tmp___0);
  }
#line 817
  tmp___1 = lstat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 817
  return (tmp___1);
}
}
#line 820 "openbsd-compat/glob.c"
static int g_stat(Char *fn , struct stat *sb , glob_t *pglob ) 
{ char buf___1[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 825
  tmp = g_Ctoc((Char const   *)fn, buf___1, sizeof(buf___1));
#line 825
  if (tmp) {
#line 826
    return (-1);
  }
#line 827
  if (pglob->gl_flags & 64) {
#line 828
    tmp___0 = (*(pglob->gl_stat))((char const   *)(buf___1), sb);
#line 828
    return (tmp___0);
  }
#line 829
  tmp___1 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )sb);
#line 829
  return (tmp___1);
}
}
#line 832 "openbsd-compat/glob.c"
static Char *g_strchr(Char *str , int ch ) 
{ Char *tmp ;

  {
#line 835
  while (1) {
#line 836
    if ((int )*str == ch) {
#line 837
      return (str);
    }
#line 835
    tmp = str;
#line 835
    str ++;
#line 835
    if (! *tmp) {
#line 835
      break;
    }
  }
#line 839
  return ((Char *)((void *)0));
}
}
#line 842 "openbsd-compat/glob.c"
static int g_Ctoc(Char const   *str , char *buf___1 , u_int len ) 
{ char *tmp ;
  Char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 846
  while (1) {
#line 846
    tmp___1 = len;
#line 846
    len --;
#line 846
    if (! tmp___1) {
#line 846
      break;
    }
#line 847
    tmp = buf___1;
#line 847
    buf___1 ++;
#line 847
    tmp___0 = str;
#line 847
    str ++;
#line 847
    *tmp = (char )*tmp___0;
#line 847
    if ((int )*tmp == 0) {
#line 848
      return (0);
    }
  }
#line 850
  return (1);
}
}
#line 1 "inet_aton.o"
#line 1 "inet_ntoa.o"
#line 1 "inet_ntop.o"
#line 1 "mktemp.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 316
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 729 "/usr/include/stdlib.h"
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 91 "./openbsd-compat/openbsd-compat.h"
int mkstemps(char *path , int slen ) ;
#line 48 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) ;
#line 50 "openbsd-compat/mktemp.c"
int mkstemps(char *path , int slen ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 55
  tmp___1 = _gettemp(path, & fd, 0, slen);
#line 55
  if (tmp___1) {
#line 55
    tmp___0 = fd;
  } else {
#line 55
    tmp___0 = -1;
  }
#line 55
  return (tmp___0);
}
}
#line 58
int mkstemp(char *path )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 58 "openbsd-compat/mktemp.c"
int mkstemp(char *path ) 
{ int fd ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 63
  tmp___1 = _gettemp(path, & fd, 0, 0);
#line 63
  if (tmp___1) {
#line 63
    tmp___0 = fd;
  } else {
#line 63
    tmp___0 = -1;
  }
#line 63
  return (tmp___0);
}
}
#line 66
 __attribute__((__nothrow__)) char *mkdtemp(char *path )  __attribute__((__nonnull__(1))) ;
#line 66 "openbsd-compat/mktemp.c"
char *mkdtemp(char *path ) 
{ char *tmp___0 ;
  int tmp___1 ;

  {
#line 69
  tmp___1 = _gettemp(path, (int *)((void *)0), 1, 0);
#line 69
  if (tmp___1) {
#line 69
    tmp___0 = path;
  } else {
#line 69
    tmp___0 = (char *)((void *)0);
  }
#line 69
  return (tmp___0);
}
}
#line 72 "openbsd-compat/mktemp.c"
static int _gettemp(char *path , int *doopen , int domkdir , int slen ) 
{ register char *start___0 ;
  register char *trv ;
  register char *suffp ;
  struct stat sbuf ;
  int rval ;
  pid_t pid ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char c ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
#line 84
  if (doopen) {
#line 84
    if (domkdir) {
#line 85
      tmp = __errno_location();
#line 85
      *tmp = 22;
#line 86
      return (0);
    }
  }
#line 89
  trv = path;
#line 89
  while (*trv) {
#line 89
    trv ++;
  }
#line 91
  trv -= slen;
#line 92
  suffp = trv;
#line 93
  trv --;
#line 94
  if ((unsigned int )trv < (unsigned int )path) {
#line 95
    tmp___0 = __errno_location();
#line 95
    *tmp___0 = 22;
#line 96
    return (0);
  }
#line 98
  pid = getpid();
#line 99
  while (1) {
#line 99
    if ((unsigned int )trv >= (unsigned int )path) {
#line 99
      if ((int )*trv == 88) {
#line 99
        if (! (pid != 0)) {
#line 99
          break;
        }
      } else {
#line 99
        break;
      }
    } else {
#line 99
      break;
    }
#line 100
    tmp___1 = trv;
#line 100
    trv --;
#line 100
    *tmp___1 = (char )(pid % 10 + 48);
#line 101
    pid /= 10;
  }
#line 103
  while (1) {
#line 103
    if ((unsigned int )trv >= (unsigned int )path) {
#line 103
      if (! ((int )*trv == 88)) {
#line 103
        break;
      }
    } else {
#line 103
      break;
    }
#line 106
    tmp___2 = arc4random();
#line 106
    pid = (int )((tmp___2 & 65535U) % 52U);
#line 107
    if (pid < 26) {
#line 108
      c = (char )(pid + 65);
    } else {
#line 110
      c = (char )((pid - 26) + 97);
    }
#line 111
    tmp___3 = trv;
#line 111
    trv --;
#line 111
    *tmp___3 = c;
  }
#line 113
  start___0 = trv + 1;
#line 119
  if (doopen) {
    goto _L;
  } else {
#line 119
    if (domkdir) {
      _L: /* CIL Label */ 
#line 120
      while (! ((unsigned int )trv <= (unsigned int )path)) {
#line 123
        if ((int )*trv == 47) {
#line 124
          *trv = (char )'\000';
#line 125
          rval = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 126
          *trv = (char )'/';
#line 127
          if (rval != 0) {
#line 128
            return (0);
          }
#line 129
          if (! ((sbuf.st_mode & 61440U) == 16384U)) {
#line 130
            tmp___4 = __errno_location();
#line 130
            *tmp___4 = 20;
#line 131
            return (0);
          }
#line 133
          break;
        }
#line 120
        trv --;
      }
    }
  }
#line 138
  while (1) {
#line 139
    if (doopen) {
#line 140
      *doopen = open((char const   *)path, 194, 384);
#line 140
      if (*doopen >= 0) {
#line 142
        return (1);
      }
#line 143
      tmp___5 = __errno_location();
#line 143
      if (*tmp___5 != 17) {
#line 144
        return (0);
      }
    } else {
#line 145
      if (domkdir) {
#line 146
        tmp___6 = mkdir((char const   *)path, 448U);
#line 146
        if (tmp___6 == 0) {
#line 147
          return (1);
        }
#line 148
        tmp___7 = __errno_location();
#line 148
        if (*tmp___7 != 17) {
#line 149
          return (0);
        }
      } else {
#line 150
        tmp___11 = lstat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
#line 150
        if (tmp___11) {
#line 151
          tmp___10 = __errno_location();
#line 151
          if (*tmp___10 == 2) {
#line 151
            tmp___9 = 1;
          } else {
#line 151
            tmp___9 = 0;
          }
#line 151
          return (tmp___9);
        }
      }
    }
#line 154
    trv = start___0;
#line 154
    while (1) {
#line 155
      if (! *trv) {
#line 156
        return (0);
      }
#line 157
      if ((int )*trv == 90) {
#line 158
        if ((unsigned int )trv == (unsigned int )suffp) {
#line 159
          return (0);
        }
#line 160
        tmp___12 = trv;
#line 160
        trv ++;
#line 160
        *tmp___12 = (char )'a';
      } else {
#line 162
        tmp___13 = __ctype_b_loc();
#line 162
        if ((int const   )*(*tmp___13 + (int )*trv) & 2048) {
#line 163
          *trv = (char )'a';
        } else {
#line 164
          if ((int )*trv == 122) {
#line 165
            *trv = (char )'A';
          } else {
#line 167
            if ((unsigned int )trv == (unsigned int )suffp) {
#line 168
              return (0);
            }
#line 169
            *trv = (char )((int )*trv + 1);
          }
        }
#line 171
        break;
      }
    }
  }
}
}
#line 1 "readpassphrase.o"
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 40 "./openbsd-compat/readpassphrase.h"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 83 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 327 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 49 "openbsd-compat/readpassphrase.c"
static sig_atomic_t volatile   signo  ;
#line 51
static void handler(int s ) ;
#line 53 "openbsd-compat/readpassphrase.c"
char *readpassphrase(char const   *prompt , char *buf___1 , size_t bufsiz , int flags ) 
{ ssize_t nr ;
  int input___0 ;
  int output___0 ;
  int save_errno ;
  char ch ;
  char *p ;
  char *end ;
  struct termios term ;
  struct termios oterm ;
  struct sigaction sa ;
  struct sigaction savealrm ;
  struct sigaction saveint ;
  struct sigaction savehup ;
  struct sigaction savequit ;
  struct sigaction saveterm ;
  struct sigaction savetstp ;
  struct sigaction savettin ;
  struct sigaction savettou ;
  struct sigaction savepipe ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int __res ;
  __int32_t const   **tmp___5 ;
  int __res___0 ;
  __int32_t const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  __pid_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;

  {
#line 64
  if (bufsiz == 0U) {
#line 65
    tmp = __errno_location();
#line 65
    *tmp = 22;
#line 66
    return ((char *)((void *)0));
  }
  restart: 
#line 70
  signo = (int volatile   )0;
#line 75
  if (flags & 32) {
    goto _L;
  } else {
#line 75
    output___0 = open("/dev/tty", 2);
#line 75
    input___0 = output___0;
#line 75
    if (input___0 == -1) {
      _L: /* CIL Label */ 
#line 77
      if (flags & 2) {
#line 78
        tmp___0 = __errno_location();
#line 78
        *tmp___0 = 25;
#line 79
        return ((char *)((void *)0));
      }
#line 81
      input___0 = 0;
#line 82
      output___0 = 2;
    }
  }
#line 90
  sigemptyset(& sa.sa_mask);
#line 91
  sa.sa_flags = 0;
#line 92
  sa.__sigaction_handler.sa_handler = & handler;
#line 93
  sigaction(14, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savealrm));
#line 94
  sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savehup));
#line 95
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveint));
#line 96
  sigaction(13, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savepipe));
#line 97
  sigaction(3, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savequit));
#line 98
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& saveterm));
#line 99
  sigaction(20, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savetstp));
#line 100
  sigaction(21, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettin));
#line 101
  sigaction(22, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& savettou));
#line 104
  if (input___0 != 0) {
#line 104
    tmp___1 = tcgetattr(input___0, & oterm);
#line 104
    if (tmp___1 == 0) {
#line 105
      memcpy((void * __restrict  )(& term), (void const   * __restrict  )(& oterm),
             sizeof(term));
#line 106
      if (! (flags & 1)) {
#line 107
        term.c_lflag &= 4294967223U;
      }
#line 112
      tcsetattr(input___0, 2, (struct termios  const  *)(& term));
    } else {
#line 114
      memset((void *)(& term), 0, sizeof(term));
#line 115
      term.c_lflag |= 8U;
#line 116
      memset((void *)(& oterm), 0, sizeof(oterm));
#line 117
      oterm.c_lflag |= 8U;
    }
  } else {
#line 114
    memset((void *)(& term), 0, sizeof(term));
#line 115
    term.c_lflag |= 8U;
#line 116
    memset((void *)(& oterm), 0, sizeof(oterm));
#line 117
    oterm.c_lflag |= 8U;
  }
#line 120
  if (! (flags & 32)) {
#line 121
    tmp___2 = strlen(prompt);
#line 121
    write(output___0, (void const   *)prompt, tmp___2);
  }
#line 122
  end = (buf___1 + bufsiz) - 1;
#line 123
  p = buf___1;
#line 123
  while (1) {
#line 123
    nr = read(input___0, (void *)(& ch), 1U);
#line 123
    if (nr == 1) {
#line 123
      if ((int )ch != 10) {
#line 123
        if (! ((int )ch != 13)) {
#line 123
          break;
        }
      } else {
#line 123
        break;
      }
    } else {
#line 123
      break;
    }
#line 124
    if ((unsigned int )p < (unsigned int )end) {
#line 125
      if (flags & 16) {
#line 126
        ch = (char )((int )ch & 127);
      }
#line 127
      tmp___9 = __ctype_b_loc();
#line 127
      if ((int const   )*(*tmp___9 + (int )ch) & 1024) {
#line 128
        if (flags & 4) {
#line 129
          if (sizeof(ch) > 1U) {
#line 129
            __res = tolower((int )ch);
          } else {
#line 129
            tmp___5 = __ctype_tolower_loc();
#line 129
            __res = (int )*(*tmp___5 + (int )ch);
          }
#line 129
          ch = (char )__res;
        }
#line 130
        if (flags & 8) {
#line 131
          if (sizeof(ch) > 1U) {
#line 131
            __res___0 = toupper((int )ch);
          } else {
#line 131
            tmp___8 = __ctype_toupper_loc();
#line 131
            __res___0 = (int )*(*tmp___8 + (int )ch);
          }
#line 131
          ch = (char )__res___0;
        }
      }
#line 133
      tmp___10 = p;
#line 133
      p ++;
#line 133
      *tmp___10 = ch;
    }
  }
#line 136
  *p = (char )'\000';
#line 137
  tmp___11 = __errno_location();
#line 137
  save_errno = *tmp___11;
#line 138
  if (! (term.c_lflag & 8U)) {
#line 139
    write(output___0, (void const   *)"\n", 1U);
  }
#line 142
  tmp___14 = memcmp((void const   *)(& term), (void const   *)(& oterm), sizeof(term));
#line 142
  if (tmp___14 != 0) {
#line 143
    while (1) {
#line 143
      tmp___12 = tcsetattr(input___0, 2, (struct termios  const  *)(& oterm));
#line 143
      if (tmp___12 == -1) {
#line 143
        tmp___13 = __errno_location();
#line 143
        if (! (*tmp___13 == 4)) {
#line 143
          break;
        }
      } else {
#line 143
        break;
      }
#line 145
      continue;
    }
  }
#line 147
  sigaction(14, (struct sigaction  const  * __restrict  )(& savealrm), (struct sigaction * __restrict  )((void *)0));
#line 148
  sigaction(1, (struct sigaction  const  * __restrict  )(& savehup), (struct sigaction * __restrict  )((void *)0));
#line 149
  sigaction(2, (struct sigaction  const  * __restrict  )(& saveint), (struct sigaction * __restrict  )((void *)0));
#line 150
  sigaction(3, (struct sigaction  const  * __restrict  )(& savequit), (struct sigaction * __restrict  )((void *)0));
#line 151
  sigaction(13, (struct sigaction  const  * __restrict  )(& savepipe), (struct sigaction * __restrict  )((void *)0));
#line 152
  sigaction(15, (struct sigaction  const  * __restrict  )(& saveterm), (struct sigaction * __restrict  )((void *)0));
#line 153
  sigaction(20, (struct sigaction  const  * __restrict  )(& savetstp), (struct sigaction * __restrict  )((void *)0));
#line 154
  sigaction(21, (struct sigaction  const  * __restrict  )(& savettin), (struct sigaction * __restrict  )((void *)0));
#line 155
  if (input___0 != 0) {
#line 156
    close(input___0);
  }
#line 162
  if (signo) {
#line 163
    tmp___15 = getpid();
#line 163
    kill(tmp___15, (int )signo);
#line 164
    switch ((int )signo) {
    case 20: 
    case 21: 
    case 22: 
    goto restart;
    }
  }
#line 172
  tmp___16 = __errno_location();
#line 172
  *tmp___16 = save_errno;
#line 173
  if (nr == -1) {
#line 173
    tmp___17 = (char *)((void *)0);
  } else {
#line 173
    tmp___17 = buf___1;
  }
#line 173
  return (tmp___17);
}
}
#line 186 "openbsd-compat/readpassphrase.c"
static void handler(int s ) 
{ 

  {
#line 189
  signo = (int volatile   )s;
#line 190
  return;
}
}
#line 1 "realpath.o"
#line 1 "rresvport.o"
#line 1 "setenv.o"
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "setproctitle.o"
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 79 "./openbsd-compat/openbsd-compat.h"
size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 121
void setproctitle(char const   *fmt  , ...) ;
#line 122
void compat_init_setproctitle(int argc , char **argv ) ;
#line 498 "/usr/include/unistd.h"
extern char **environ ;
#line 59 "openbsd-compat/setproctitle.c"
static char *argv_start  =    (char *)((void *)0);
#line 60 "openbsd-compat/setproctitle.c"
static size_t argv_env_len  =    (size_t )0;
#line 65 "openbsd-compat/setproctitle.c"
void compat_init_setproctitle(int argc , char **argv ) 
{ char *lastargv ;
  char **envp ;
  int i ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___11 ;

  {
#line 70
  lastargv = (char *)((void *)0);
#line 71
  envp = environ;
#line 80
  if (argc == 0) {
#line 81
    return;
  } else {
#line 80
    if ((unsigned int )*(argv + 0) == (unsigned int )((void *)0)) {
#line 81
      return;
    }
  }
#line 84
  i = 0;
#line 84
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 84
    i ++;
  }
#line 86
  tmp = calloc((unsigned int )(i + 1), sizeof(*environ));
#line 86
  environ = (char **)tmp;
#line 86
  if ((unsigned int )environ == (unsigned int )((void *)0)) {
#line 87
    environ = envp;
#line 88
    return;
  }
#line 95
  i = 0;
#line 95
  while (i < argc) {
#line 96
    if ((unsigned int )lastargv == (unsigned int )((void *)0)) {
#line 97
      tmp___0 = strlen((char const   *)*(argv + i));
#line 97
      lastargv = *(argv + i) + tmp___0;
    } else {
#line 96
      if ((unsigned int )(lastargv + 1) == (unsigned int )*(argv + i)) {
#line 97
        tmp___0 = strlen((char const   *)*(argv + i));
#line 97
        lastargv = *(argv + i) + tmp___0;
      }
    }
#line 95
    i ++;
  }
#line 99
  i = 0;
#line 99
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 100
    if ((unsigned int )(lastargv + 1) == (unsigned int )*(envp + i)) {
#line 101
      tmp___1 = strlen((char const   *)*(envp + i));
#line 101
      lastargv = *(envp + i) + tmp___1;
    }
#line 99
    i ++;
  }
#line 104
  *(argv + 1) = (char *)((void *)0);
#line 105
  argv_start = *(argv + 0);
#line 106
  argv_env_len = (unsigned int )((lastargv - *(argv + 0)) - 1);
#line 112
  i = 0;
#line 112
  while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
#line 113
    tmp___11 = __strdup((char const   *)*(envp + i));
#line 113
    *(environ + i) = tmp___11;
#line 112
    i ++;
  }
#line 114
  *(environ + i) = (char *)((void *)0);
#line 116
  return;
}
}
#line 119 "openbsd-compat/setproctitle.c"
void setproctitle(char const   *fmt  , ...) 
{ va_list ap ;
  char buf___1[1024] ;
  size_t len ;

  {
#line 132
  if (argv_env_len <= 0U) {
#line 133
    return;
  }
#line 136
  strlcpy(buf___1, (char const   *)__progname, sizeof(buf___1));
#line 138
  __builtin_va_start(ap, fmt);
#line 139
  if ((unsigned int )fmt != (unsigned int )((void *)0)) {
#line 140
    len = strlcat(buf___1, ": ", sizeof(buf___1));
#line 141
    if (len < sizeof(buf___1)) {
#line 142
      vsnprintf((char * __restrict  )(buf___1 + len), sizeof(buf___1) - len, (char const   * __restrict  )fmt,
                ap);
    }
  }
#line 144
  __builtin_va_end(ap);
#line 152
  len = strlcpy(argv_start, (char const   *)(buf___1), argv_env_len);
#line 153
  while (len < argv_env_len) {
#line 154
    *(argv_start + len) = (char )'\000';
#line 153
    len ++;
  }
#line 158
  return;
}
}
#line 1 "sigact.o"
#line 1 "strlcat.o"
#line 34 "openbsd-compat/strlcat.c"
size_t strlcat(char *dst , char const   *src , size_t siz ) 
{ char *d ;
  char const   *s ;
  size_t n___0 ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 37
  d = dst;
#line 38
  s = src;
#line 39
  n___0 = siz;
#line 43
  while (1) {
#line 43
    tmp = n___0;
#line 43
    n___0 --;
#line 43
    if (tmp != 0U) {
#line 43
      if (! ((int )*d != 0)) {
#line 43
        break;
      }
    } else {
#line 43
      break;
    }
#line 44
    d ++;
  }
#line 45
  dlen = (unsigned int )(d - dst);
#line 46
  n___0 = siz - dlen;
#line 48
  if (n___0 == 0U) {
#line 49
    tmp___0 = strlen(s);
#line 49
    return (dlen + tmp___0);
  }
#line 50
  while ((int const   )*s != 0) {
#line 51
    if (n___0 != 1U) {
#line 52
      tmp___1 = d;
#line 52
      d ++;
#line 52
      *tmp___1 = (char )*s;
#line 53
      n___0 --;
    }
#line 55
    s ++;
  }
#line 57
  *d = (char )'\000';
#line 59
  return (dlen + (size_t )(s - src));
}
}
#line 1 "strlcpy.o"
#line 32 "openbsd-compat/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ char *d ;
  char const   *s ;
  size_t n___0 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 35
  d = dst;
#line 36
  s = src;
#line 37
  n___0 = siz;
#line 40
  if (n___0 != 0U) {
#line 40
    n___0 --;
#line 40
    if (n___0 != 0U) {
#line 41
      while (1) {
#line 42
        tmp = d;
#line 42
        d ++;
#line 42
        tmp___0 = s;
#line 42
        s ++;
#line 42
        *tmp = (char )*tmp___0;
#line 42
        if ((int )*tmp == 0) {
#line 43
          break;
        }
#line 41
        n___0 --;
#line 41
        if (! (n___0 != 0U)) {
#line 41
          break;
        }
      }
    }
  }
#line 48
  if (n___0 == 0U) {
#line 49
    if (siz != 0U) {
#line 50
      *d = (char )'\000';
    }
#line 51
    while (1) {
#line 51
      tmp___1 = s;
#line 51
      s ++;
#line 51
      if (! *tmp___1) {
#line 51
        break;
      }
    }
  }
#line 55
  return ((unsigned int )((s - src) - 1));
}
}
#line 1 "strmode.o"
#line 87 "./openbsd-compat/openbsd-compat.h"
void strmode(int mode , char *p ) ;
#line 42 "openbsd-compat/strmode.c"
void strmode(int mode , char *p ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 46
  switch (mode & 61440) {
  case 16384: 
#line 48
  tmp = p;
#line 48
  p ++;
#line 48
  *tmp = (char )'d';
#line 49
  break;
  case 8192: 
#line 51
  tmp___0 = p;
#line 51
  p ++;
#line 51
  *tmp___0 = (char )'c';
#line 52
  break;
  case 24576: 
#line 54
  tmp___1 = p;
#line 54
  p ++;
#line 54
  *tmp___1 = (char )'b';
#line 55
  break;
  case 32768: 
#line 57
  tmp___2 = p;
#line 57
  p ++;
#line 57
  *tmp___2 = (char )'-';
#line 58
  break;
  case 40960: 
#line 60
  tmp___3 = p;
#line 60
  p ++;
#line 60
  *tmp___3 = (char )'l';
#line 61
  break;
  case 49152: 
#line 64
  tmp___4 = p;
#line 64
  p ++;
#line 64
  *tmp___4 = (char )'s';
#line 65
  break;
  case 4096: 
#line 69
  tmp___5 = p;
#line 69
  p ++;
#line 69
  *tmp___5 = (char )'p';
#line 70
  break;
  default: 
#line 73
  tmp___6 = p;
#line 73
  p ++;
#line 73
  *tmp___6 = (char )'?';
#line 74
  break;
  }
#line 77
  if (mode & 256) {
#line 78
    tmp___7 = p;
#line 78
    p ++;
#line 78
    *tmp___7 = (char )'r';
  } else {
#line 80
    tmp___8 = p;
#line 80
    p ++;
#line 80
    *tmp___8 = (char )'-';
  }
#line 81
  if (mode & 128) {
#line 82
    tmp___9 = p;
#line 82
    p ++;
#line 82
    *tmp___9 = (char )'w';
  } else {
#line 84
    tmp___10 = p;
#line 84
    p ++;
#line 84
    *tmp___10 = (char )'-';
  }
#line 85
  switch (mode & 2112) {
  case 0: 
#line 87
  tmp___11 = p;
#line 87
  p ++;
#line 87
  *tmp___11 = (char )'-';
#line 88
  break;
  case 64: 
#line 90
  tmp___12 = p;
#line 90
  p ++;
#line 90
  *tmp___12 = (char )'x';
#line 91
  break;
  case 2048: 
#line 93
  tmp___13 = p;
#line 93
  p ++;
#line 93
  *tmp___13 = (char )'S';
#line 94
  break;
  case 2112: 
#line 96
  tmp___14 = p;
#line 96
  p ++;
#line 96
  *tmp___14 = (char )'s';
#line 97
  break;
  }
#line 100
  if (mode & (256 >> 3)) {
#line 101
    tmp___15 = p;
#line 101
    p ++;
#line 101
    *tmp___15 = (char )'r';
  } else {
#line 103
    tmp___16 = p;
#line 103
    p ++;
#line 103
    *tmp___16 = (char )'-';
  }
#line 104
  if (mode & (128 >> 3)) {
#line 105
    tmp___17 = p;
#line 105
    p ++;
#line 105
    *tmp___17 = (char )'w';
  } else {
#line 107
    tmp___18 = p;
#line 107
    p ++;
#line 107
    *tmp___18 = (char )'-';
  }
#line 108
  switch (mode & ((64 >> 3) | 1024)) {
  case 0: 
#line 110
  tmp___19 = p;
#line 110
  p ++;
#line 110
  *tmp___19 = (char )'-';
#line 111
  break;
  case 64 >> 3: 
#line 113
  tmp___20 = p;
#line 113
  p ++;
#line 113
  *tmp___20 = (char )'x';
#line 114
  break;
  case 1024: 
#line 116
  tmp___21 = p;
#line 116
  p ++;
#line 116
  *tmp___21 = (char )'S';
#line 117
  break;
  case (64 >> 3) | 1024: 
#line 119
  tmp___22 = p;
#line 119
  p ++;
#line 119
  *tmp___22 = (char )'s';
#line 120
  break;
  }
#line 123
  if (mode & ((256 >> 3) >> 3)) {
#line 124
    tmp___23 = p;
#line 124
    p ++;
#line 124
    *tmp___23 = (char )'r';
  } else {
#line 126
    tmp___24 = p;
#line 126
    p ++;
#line 126
    *tmp___24 = (char )'-';
  }
#line 127
  if (mode & ((128 >> 3) >> 3)) {
#line 128
    tmp___25 = p;
#line 128
    p ++;
#line 128
    *tmp___25 = (char )'w';
  } else {
#line 130
    tmp___26 = p;
#line 130
    p ++;
#line 130
    *tmp___26 = (char )'-';
  }
#line 131
  switch (mode & (((64 >> 3) >> 3) | 512)) {
  case 0: 
#line 133
  tmp___27 = p;
#line 133
  p ++;
#line 133
  *tmp___27 = (char )'-';
#line 134
  break;
  case (64 >> 3) >> 3: 
#line 136
  tmp___28 = p;
#line 136
  p ++;
#line 136
  *tmp___28 = (char )'x';
#line 137
  break;
  case 512: 
#line 139
  tmp___29 = p;
#line 139
  p ++;
#line 139
  *tmp___29 = (char )'T';
#line 140
  break;
  case ((64 >> 3) >> 3) | 512: 
#line 142
  tmp___30 = p;
#line 142
  p ++;
#line 142
  *tmp___30 = (char )'t';
#line 143
  break;
  }
#line 145
  tmp___31 = p;
#line 145
  p ++;
#line 145
  *tmp___31 = (char )' ';
#line 146
  *p = (char )'\000';
#line 147
  return;
}
}
#line 1 "strsep.o"
#line 1 "strtoul.o"
#line 1 "vis.o"
#line 82 "./openbsd-compat/vis.h"
char *vis(char *dst , int c , int flag , int nextc ) ;
#line 83
int strvis(char *dst , char const   *src , int flag ) ;
#line 84
int strnvis(char *dst , char const   *src , size_t siz , int flag ) ;
#line 86
int strvisx(char *dst , char const   *src , size_t len , int flag ) ;
#line 56 "openbsd-compat/vis.c"
char *vis(char *dst , int c , int flag , int nextc ) 
{ char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned short const   **tmp___34 ;

  {
#line 59
  if ((unsigned int )c <= 255U) {
#line 59
    if (((int )((unsigned char )c) & -128) == 0) {
#line 59
      if (c != 42) {
#line 59
        if (c != 63) {
#line 59
          if (c != 91) {
#line 59
            if (c != 35) {
              goto _L___6;
            } else {
              goto _L___9;
            }
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
#line 59
        if ((flag & 256) == 0) {
          _L___6: /* CIL Label */ 
#line 59
          tmp___1 = __ctype_b_loc();
#line 59
          if ((int const   )*(*tmp___1 + (int )((unsigned char )c)) & 32768) {
            goto _L___0;
          } else {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      }
    } else {
      goto _L___10;
    }
  } else {
    _L___10: /* CIL Label */ 
#line 59
    if ((flag & 4) == 0) {
#line 59
      if (c == 32) {
        goto _L___0;
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 59
      if ((flag & 8) == 0) {
#line 59
        if (c == 9) {
          goto _L___0;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 59
        if ((flag & 16) == 0) {
#line 59
          if (c == 10) {
            goto _L___0;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 59
          if (flag & 32) {
#line 59
            if (c == 8) {
              goto _L___0;
            } else {
#line 59
              if (c == 7) {
                goto _L___0;
              } else {
#line 59
                if (c == 13) {
                  goto _L___0;
                } else {
#line 59
                  tmp___2 = __ctype_b_loc();
#line 59
                  if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
                    _L___0: /* CIL Label */ 
#line 60
                    tmp = dst;
#line 60
                    dst ++;
#line 60
                    *tmp = (char )c;
#line 61
                    if (c == 92) {
#line 61
                      if ((flag & 64) == 0) {
#line 62
                        tmp___0 = dst;
#line 62
                        dst ++;
#line 62
                        *tmp___0 = (char )'\\';
                      }
                    }
#line 63
                    *dst = (char )'\000';
#line 64
                    return (dst);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 67
  if (flag & 2) {
#line 68
    switch (c) {
    case 10: 
#line 70
    tmp___3 = dst;
#line 70
    dst ++;
#line 70
    *tmp___3 = (char )'\\';
#line 71
    tmp___4 = dst;
#line 71
    dst ++;
#line 71
    *tmp___4 = (char )'n';
    goto done;
    case 13: 
#line 74
    tmp___5 = dst;
#line 74
    dst ++;
#line 74
    *tmp___5 = (char )'\\';
#line 75
    tmp___6 = dst;
#line 75
    dst ++;
#line 75
    *tmp___6 = (char )'r';
    goto done;
    case 8: 
#line 78
    tmp___7 = dst;
#line 78
    dst ++;
#line 78
    *tmp___7 = (char )'\\';
#line 79
    tmp___8 = dst;
#line 79
    dst ++;
#line 79
    *tmp___8 = (char )'b';
    goto done;
    case 7: 
#line 82
    tmp___9 = dst;
#line 82
    dst ++;
#line 82
    *tmp___9 = (char )'\\';
#line 83
    tmp___10 = dst;
#line 83
    dst ++;
#line 83
    *tmp___10 = (char )'a';
    goto done;
    case 11: 
#line 86
    tmp___11 = dst;
#line 86
    dst ++;
#line 86
    *tmp___11 = (char )'\\';
#line 87
    tmp___12 = dst;
#line 87
    dst ++;
#line 87
    *tmp___12 = (char )'v';
    goto done;
    case 9: 
#line 90
    tmp___13 = dst;
#line 90
    dst ++;
#line 90
    *tmp___13 = (char )'\\';
#line 91
    tmp___14 = dst;
#line 91
    dst ++;
#line 91
    *tmp___14 = (char )'t';
    goto done;
    case 12: 
#line 94
    tmp___15 = dst;
#line 94
    dst ++;
#line 94
    *tmp___15 = (char )'\\';
#line 95
    tmp___16 = dst;
#line 95
    dst ++;
#line 95
    *tmp___16 = (char )'f';
    goto done;
    case 32: 
#line 98
    tmp___17 = dst;
#line 98
    dst ++;
#line 98
    *tmp___17 = (char )'\\';
#line 99
    tmp___18 = dst;
#line 99
    dst ++;
#line 99
    *tmp___18 = (char )'s';
    goto done;
    case 0: 
#line 102
    tmp___19 = dst;
#line 102
    dst ++;
#line 102
    *tmp___19 = (char )'\\';
#line 103
    tmp___20 = dst;
#line 103
    dst ++;
#line 103
    *tmp___20 = (char )'0';
#line 104
    if ((int )((unsigned char )nextc) >= 48) {
#line 104
      if ((int )((unsigned char )nextc) <= 55) {
#line 105
        tmp___21 = dst;
#line 105
        dst ++;
#line 105
        *tmp___21 = (char )'0';
#line 106
        tmp___22 = dst;
#line 106
        dst ++;
#line 106
        *tmp___22 = (char )'0';
      }
    }
    goto done;
    }
  }
#line 111
  if ((c & 127) == 32) {
    goto _L___12;
  } else {
#line 111
    if (flag & 1) {
      goto _L___12;
    } else {
#line 111
      if (flag & 256) {
#line 111
        if (c == 42) {
          goto _L___12;
        } else {
#line 111
          if (c == 63) {
            goto _L___12;
          } else {
#line 111
            if (c == 91) {
              goto _L___12;
            } else {
#line 111
              if (c == 35) {
                _L___12: /* CIL Label */ 
#line 113
                tmp___23 = dst;
#line 113
                dst ++;
#line 113
                *tmp___23 = (char )'\\';
#line 114
                tmp___24 = dst;
#line 114
                dst ++;
#line 114
                *tmp___24 = (char )((((int )((unsigned char )c) >> 6) & 7) + 48);
#line 115
                tmp___25 = dst;
#line 115
                dst ++;
#line 115
                *tmp___25 = (char )((((int )((unsigned char )c) >> 3) & 7) + 48);
#line 116
                tmp___26 = dst;
#line 116
                dst ++;
#line 116
                *tmp___26 = (char )(((int )((unsigned char )c) & 7) + 48);
                goto done;
              }
            }
          }
        }
      }
    }
  }
#line 119
  if ((flag & 64) == 0) {
#line 120
    tmp___27 = dst;
#line 120
    dst ++;
#line 120
    *tmp___27 = (char )'\\';
  }
#line 121
  if (c & 128) {
#line 122
    c &= 127;
#line 123
    tmp___28 = dst;
#line 123
    dst ++;
#line 123
    *tmp___28 = (char )'M';
  }
#line 125
  tmp___34 = __ctype_b_loc();
#line 125
  if ((int const   )*(*tmp___34 + (int )((unsigned char )c)) & 2) {
#line 126
    tmp___29 = dst;
#line 126
    dst ++;
#line 126
    *tmp___29 = (char )'^';
#line 127
    if (c == 127) {
#line 128
      tmp___30 = dst;
#line 128
      dst ++;
#line 128
      *tmp___30 = (char )'?';
    } else {
#line 130
      tmp___31 = dst;
#line 130
      dst ++;
#line 130
      *tmp___31 = (char )(c + 64);
    }
  } else {
#line 132
    tmp___32 = dst;
#line 132
    dst ++;
#line 132
    *tmp___32 = (char )'-';
#line 133
    tmp___33 = dst;
#line 133
    dst ++;
#line 133
    *tmp___33 = (char )c;
  }
  done: 
#line 136
  *dst = (char )'\000';
#line 137
  return (dst);
}
}
#line 153 "openbsd-compat/vis.c"
int strvis(char *dst , char const   *src , int flag ) 
{ char c ;
  char *start___0 ;

  {
#line 159
  start___0 = dst;
#line 159
  while (1) {
#line 159
    c = (char )*src;
#line 159
    if (! c) {
#line 159
      break;
    }
#line 160
    src ++;
#line 160
    dst = vis(dst, (int )c, flag, (int )*src);
  }
#line 161
  *dst = (char )'\000';
#line 162
  return (dst - start___0);
}
}
#line 165 "openbsd-compat/vis.c"
int strnvis(char *dst , char const   *src , size_t siz , int flag ) 
{ char *start___0 ;
  char *end ;
  char tbuf[5] ;
  int c ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
#line 172
  i = 0;
#line 173
  start___0 = dst;
#line 173
  end = (start___0 + siz) - 1;
#line 173
  while (1) {
#line 173
    c = (int )*src;
#line 173
    if (c) {
#line 173
      if (! ((unsigned int )dst < (unsigned int )end)) {
#line 173
        break;
      }
    } else {
#line 173
      break;
    }
#line 174
    if ((unsigned int )c <= 255U) {
#line 174
      if (((int )((unsigned char )c) & -128) == 0) {
#line 174
        if (c != 42) {
#line 174
          if (c != 63) {
#line 174
            if (c != 91) {
#line 174
              if (c != 35) {
                goto _L___7;
              } else {
                goto _L___10;
              }
            } else {
              goto _L___10;
            }
          } else {
            goto _L___10;
          }
        } else {
          _L___10: /* CIL Label */ 
#line 174
          if ((flag & 256) == 0) {
            _L___7: /* CIL Label */ 
#line 174
            tmp___2 = __ctype_b_loc();
#line 174
            if ((int const   )*(*tmp___2 + (int )((unsigned char )c)) & 32768) {
              goto _L___1;
            } else {
              goto _L___11;
            }
          } else {
            goto _L___11;
          }
        }
      } else {
        goto _L___11;
      }
    } else {
      _L___11: /* CIL Label */ 
#line 174
      if ((flag & 4) == 0) {
#line 174
        if (c == 32) {
          goto _L___1;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 174
        if ((flag & 8) == 0) {
#line 174
          if (c == 9) {
            goto _L___1;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 174
          if ((flag & 16) == 0) {
#line 174
            if (c == 10) {
              goto _L___1;
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 174
            if (flag & 32) {
#line 174
              if (c == 8) {
                goto _L___1;
              } else {
#line 174
                if (c == 7) {
                  goto _L___1;
                } else {
#line 174
                  if (c == 13) {
                    goto _L___1;
                  } else {
#line 174
                    tmp___3 = __ctype_b_loc();
#line 174
                    if ((int const   )*(*tmp___3 + (int )((unsigned char )c)) & 32768) {
                      _L___1: /* CIL Label */ 
#line 175
                      i = 1;
#line 176
                      tmp = dst;
#line 176
                      dst ++;
#line 176
                      *tmp = (char )c;
#line 177
                      if (c == 92) {
#line 177
                        if ((flag & 64) == 0) {
#line 179
                          if ((unsigned int )dst < (unsigned int )end) {
#line 180
                            tmp___0 = dst;
#line 180
                            dst ++;
#line 180
                            *tmp___0 = (char )'\\';
                          } else {
#line 182
                            dst --;
#line 183
                            i = 2;
#line 184
                            break;
                          }
                        }
                      }
#line 187
                      src ++;
                    } else {
                      goto _L___0;
                    }
                  }
                }
              }
            } else {
              _L___0: /* CIL Label */ 
#line 189
              src ++;
#line 189
              tmp___1 = vis(tbuf, c, flag, (int )*src);
#line 189
              i = tmp___1 - tbuf;
#line 190
              if ((unsigned int )(dst + i) <= (unsigned int )end) {
#line 191
                memcpy((void * __restrict  )dst, (void const   * __restrict  )(tbuf),
                       (unsigned int )i);
#line 192
                dst += i;
              } else {
#line 194
                src --;
#line 195
                break;
              }
            }
          }
        }
      }
    }
  }
#line 199
  if (siz > 0U) {
#line 200
    *dst = (char )'\000';
  }
#line 201
  if ((unsigned int )(dst + i) > (unsigned int )end) {
#line 203
    while (1) {
#line 203
      c = (int )*src;
#line 203
      if (! c) {
#line 203
        break;
      }
#line 204
      src ++;
#line 204
      tmp___4 = vis(tbuf, c, flag, (int )*src);
#line 204
      dst += tmp___4 - tbuf;
    }
  }
#line 206
  return (dst - start___0);
}
}
#line 209 "openbsd-compat/vis.c"
int strvisx(char *dst , char const   *src , size_t len , int flag ) 
{ char c ;
  char *start___0 ;

  {
#line 215
  start___0 = dst;
#line 215
  while (len > 1U) {
#line 216
    c = (char )*src;
#line 217
    src ++;
#line 217
    dst = vis(dst, (int )c, flag, (int )*src);
#line 215
    len --;
  }
#line 219
  if (len) {
#line 220
    dst = vis(dst, (int )*src, flag, '\000');
  }
#line 221
  *dst = (char )'\000';
#line 222
  return (dst - start___0);
}
}
#line 1 "acss.o"
#line 43 "acss.h"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) ;
#line 44
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) ;
#line 45
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) ;
#line 29 "acss.c"
static unsigned char sboxdec[256]  = 
#line 29 "acss.c"
  {      (unsigned char)51,      (unsigned char)115,      (unsigned char)59,      (unsigned char)38, 
        (unsigned char)99,      (unsigned char)35,      (unsigned char)107,      (unsigned char)118, 
        (unsigned char)62,      (unsigned char)126,      (unsigned char)54,      (unsigned char)43, 
        (unsigned char)110,      (unsigned char)46,      (unsigned char)102,      (unsigned char)123, 
        (unsigned char)211,      (unsigned char)147,      (unsigned char)219,      (unsigned char)6, 
        (unsigned char)67,      (unsigned char)3,      (unsigned char)75,      (unsigned char)150, 
        (unsigned char)222,      (unsigned char)158,      (unsigned char)214,      (unsigned char)11, 
        (unsigned char)78,      (unsigned char)14,      (unsigned char)70,      (unsigned char)155, 
        (unsigned char)87,      (unsigned char)23,      (unsigned char)95,      (unsigned char)130, 
        (unsigned char)199,      (unsigned char)135,      (unsigned char)207,      (unsigned char)18, 
        (unsigned char)90,      (unsigned char)26,      (unsigned char)82,      (unsigned char)143, 
        (unsigned char)202,      (unsigned char)138,      (unsigned char)194,      (unsigned char)31, 
        (unsigned char)217,      (unsigned char)153,      (unsigned char)209,      (unsigned char)0, 
        (unsigned char)73,      (unsigned char)9,      (unsigned char)65,      (unsigned char)144, 
        (unsigned char)216,      (unsigned char)152,      (unsigned char)208,      (unsigned char)1, 
        (unsigned char)72,      (unsigned char)8,      (unsigned char)64,      (unsigned char)145, 
        (unsigned char)61,      (unsigned char)125,      (unsigned char)53,      (unsigned char)36, 
        (unsigned char)109,      (unsigned char)45,      (unsigned char)101,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)124,      (unsigned char)52,      (unsigned char)37, 
        (unsigned char)108,      (unsigned char)44,      (unsigned char)100,      (unsigned char)117, 
        (unsigned char)221,      (unsigned char)157,      (unsigned char)213,      (unsigned char)4, 
        (unsigned char)77,      (unsigned char)13,      (unsigned char)69,      (unsigned char)148, 
        (unsigned char)220,      (unsigned char)156,      (unsigned char)212,      (unsigned char)5, 
        (unsigned char)76,      (unsigned char)12,      (unsigned char)68,      (unsigned char)149, 
        (unsigned char)89,      (unsigned char)25,      (unsigned char)81,      (unsigned char)128, 
        (unsigned char)201,      (unsigned char)137,      (unsigned char)193,      (unsigned char)16, 
        (unsigned char)88,      (unsigned char)24,      (unsigned char)80,      (unsigned char)129, 
        (unsigned char)200,      (unsigned char)136,      (unsigned char)192,      (unsigned char)17, 
        (unsigned char)215,      (unsigned char)151,      (unsigned char)223,      (unsigned char)2, 
        (unsigned char)71,      (unsigned char)7,      (unsigned char)79,      (unsigned char)146, 
        (unsigned char)218,      (unsigned char)154,      (unsigned char)210,      (unsigned char)15, 
        (unsigned char)74,      (unsigned char)10,      (unsigned char)66,      (unsigned char)159, 
        (unsigned char)83,      (unsigned char)19,      (unsigned char)91,      (unsigned char)134, 
        (unsigned char)195,      (unsigned char)131,      (unsigned char)203,      (unsigned char)22, 
        (unsigned char)94,      (unsigned char)30,      (unsigned char)86,      (unsigned char)139, 
        (unsigned char)206,      (unsigned char)142,      (unsigned char)198,      (unsigned char)27, 
        (unsigned char)179,      (unsigned char)243,      (unsigned char)187,      (unsigned char)166, 
        (unsigned char)227,      (unsigned char)163,      (unsigned char)235,      (unsigned char)246, 
        (unsigned char)190,      (unsigned char)254,      (unsigned char)182,      (unsigned char)171, 
        (unsigned char)238,      (unsigned char)174,      (unsigned char)230,      (unsigned char)251, 
        (unsigned char)55,      (unsigned char)119,      (unsigned char)63,      (unsigned char)34, 
        (unsigned char)103,      (unsigned char)39,      (unsigned char)111,      (unsigned char)114, 
        (unsigned char)58,      (unsigned char)122,      (unsigned char)50,      (unsigned char)47, 
        (unsigned char)106,      (unsigned char)42,      (unsigned char)98,      (unsigned char)127, 
        (unsigned char)185,      (unsigned char)249,      (unsigned char)177,      (unsigned char)160, 
        (unsigned char)233,      (unsigned char)169,      (unsigned char)225,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)248,      (unsigned char)176,      (unsigned char)161, 
        (unsigned char)232,      (unsigned char)168,      (unsigned char)224,      (unsigned char)241, 
        (unsigned char)93,      (unsigned char)29,      (unsigned char)85,      (unsigned char)132, 
        (unsigned char)205,      (unsigned char)141,      (unsigned char)197,      (unsigned char)20, 
        (unsigned char)92,      (unsigned char)28,      (unsigned char)84,      (unsigned char)133, 
        (unsigned char)204,      (unsigned char)140,      (unsigned char)196,      (unsigned char)21, 
        (unsigned char)189,      (unsigned char)253,      (unsigned char)181,      (unsigned char)164, 
        (unsigned char)237,      (unsigned char)173,      (unsigned char)229,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)252,      (unsigned char)180,      (unsigned char)165, 
        (unsigned char)236,      (unsigned char)172,      (unsigned char)228,      (unsigned char)245, 
        (unsigned char)57,      (unsigned char)121,      (unsigned char)49,      (unsigned char)32, 
        (unsigned char)105,      (unsigned char)41,      (unsigned char)97,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)120,      (unsigned char)48,      (unsigned char)33, 
        (unsigned char)104,      (unsigned char)40,      (unsigned char)96,      (unsigned char)113, 
        (unsigned char)183,      (unsigned char)247,      (unsigned char)191,      (unsigned char)162, 
        (unsigned char)231,      (unsigned char)167,      (unsigned char)239,      (unsigned char)242, 
        (unsigned char)186,      (unsigned char)250,      (unsigned char)178,      (unsigned char)175, 
        (unsigned char)234,      (unsigned char)170,      (unsigned char)226,      (unsigned char)255};
#line 65 "acss.c"
static unsigned char sboxenc[256]  = 
#line 65
  {      (unsigned char)51,      (unsigned char)59,      (unsigned char)115,      (unsigned char)21, 
        (unsigned char)83,      (unsigned char)91,      (unsigned char)19,      (unsigned char)117, 
        (unsigned char)61,      (unsigned char)53,      (unsigned char)125,      (unsigned char)27, 
        (unsigned char)93,      (unsigned char)85,      (unsigned char)29,      (unsigned char)123, 
        (unsigned char)103,      (unsigned char)111,      (unsigned char)39,      (unsigned char)129, 
        (unsigned char)199,      (unsigned char)207,      (unsigned char)135,      (unsigned char)33, 
        (unsigned char)105,      (unsigned char)97,      (unsigned char)41,      (unsigned char)143, 
        (unsigned char)201,      (unsigned char)193,      (unsigned char)137,      (unsigned char)47, 
        (unsigned char)227,      (unsigned char)235,      (unsigned char)163,      (unsigned char)5, 
        (unsigned char)67,      (unsigned char)75,      (unsigned char)3,      (unsigned char)165, 
        (unsigned char)237,      (unsigned char)229,      (unsigned char)173,      (unsigned char)11, 
        (unsigned char)77,      (unsigned char)69,      (unsigned char)13,      (unsigned char)171, 
        (unsigned char)234,      (unsigned char)226,      (unsigned char)170,      (unsigned char)0, 
        (unsigned char)74,      (unsigned char)66,      (unsigned char)10,      (unsigned char)160, 
        (unsigned char)232,      (unsigned char)224,      (unsigned char)168,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)64,      (unsigned char)8,      (unsigned char)162, 
        (unsigned char)62,      (unsigned char)54,      (unsigned char)126,      (unsigned char)20, 
        (unsigned char)94,      (unsigned char)86,      (unsigned char)30,      (unsigned char)116, 
        (unsigned char)60,      (unsigned char)52,      (unsigned char)124,      (unsigned char)22, 
        (unsigned char)92,      (unsigned char)84,      (unsigned char)28,      (unsigned char)118, 
        (unsigned char)106,      (unsigned char)98,      (unsigned char)42,      (unsigned char)128, 
        (unsigned char)202,      (unsigned char)194,      (unsigned char)138,      (unsigned char)32, 
        (unsigned char)104,      (unsigned char)96,      (unsigned char)40,      (unsigned char)130, 
        (unsigned char)200,      (unsigned char)192,      (unsigned char)136,      (unsigned char)34, 
        (unsigned char)238,      (unsigned char)230,      (unsigned char)174,      (unsigned char)4, 
        (unsigned char)78,      (unsigned char)70,      (unsigned char)14,      (unsigned char)164, 
        (unsigned char)236,      (unsigned char)228,      (unsigned char)172,      (unsigned char)6, 
        (unsigned char)76,      (unsigned char)68,      (unsigned char)12,      (unsigned char)166, 
        (unsigned char)231,      (unsigned char)239,      (unsigned char)167,      (unsigned char)1, 
        (unsigned char)71,      (unsigned char)79,      (unsigned char)7,      (unsigned char)161, 
        (unsigned char)233,      (unsigned char)225,      (unsigned char)169,      (unsigned char)15, 
        (unsigned char)73,      (unsigned char)65,      (unsigned char)9,      (unsigned char)175, 
        (unsigned char)99,      (unsigned char)107,      (unsigned char)35,      (unsigned char)133, 
        (unsigned char)195,      (unsigned char)203,      (unsigned char)131,      (unsigned char)37, 
        (unsigned char)109,      (unsigned char)101,      (unsigned char)45,      (unsigned char)139, 
        (unsigned char)205,      (unsigned char)197,      (unsigned char)141,      (unsigned char)43, 
        (unsigned char)55,      (unsigned char)63,      (unsigned char)119,      (unsigned char)17, 
        (unsigned char)87,      (unsigned char)95,      (unsigned char)23,      (unsigned char)113, 
        (unsigned char)57,      (unsigned char)49,      (unsigned char)121,      (unsigned char)31, 
        (unsigned char)89,      (unsigned char)81,      (unsigned char)25,      (unsigned char)127, 
        (unsigned char)179,      (unsigned char)187,      (unsigned char)243,      (unsigned char)149, 
        (unsigned char)211,      (unsigned char)219,      (unsigned char)147,      (unsigned char)245, 
        (unsigned char)189,      (unsigned char)181,      (unsigned char)253,      (unsigned char)155, 
        (unsigned char)221,      (unsigned char)213,      (unsigned char)157,      (unsigned char)251, 
        (unsigned char)186,      (unsigned char)178,      (unsigned char)250,      (unsigned char)144, 
        (unsigned char)218,      (unsigned char)210,      (unsigned char)154,      (unsigned char)240, 
        (unsigned char)184,      (unsigned char)176,      (unsigned char)248,      (unsigned char)146, 
        (unsigned char)216,      (unsigned char)208,      (unsigned char)152,      (unsigned char)242, 
        (unsigned char)110,      (unsigned char)102,      (unsigned char)46,      (unsigned char)132, 
        (unsigned char)206,      (unsigned char)198,      (unsigned char)142,      (unsigned char)36, 
        (unsigned char)108,      (unsigned char)100,      (unsigned char)44,      (unsigned char)134, 
        (unsigned char)204,      (unsigned char)196,      (unsigned char)140,      (unsigned char)38, 
        (unsigned char)58,      (unsigned char)50,      (unsigned char)122,      (unsigned char)16, 
        (unsigned char)90,      (unsigned char)82,      (unsigned char)26,      (unsigned char)112, 
        (unsigned char)56,      (unsigned char)48,      (unsigned char)120,      (unsigned char)18, 
        (unsigned char)88,      (unsigned char)80,      (unsigned char)24,      (unsigned char)114, 
        (unsigned char)190,      (unsigned char)182,      (unsigned char)254,      (unsigned char)148, 
        (unsigned char)222,      (unsigned char)214,      (unsigned char)158,      (unsigned char)244, 
        (unsigned char)188,      (unsigned char)180,      (unsigned char)252,      (unsigned char)150, 
        (unsigned char)220,      (unsigned char)212,      (unsigned char)156,      (unsigned char)246, 
        (unsigned char)183,      (unsigned char)191,      (unsigned char)247,      (unsigned char)145, 
        (unsigned char)215,      (unsigned char)223,      (unsigned char)151,      (unsigned char)241, 
        (unsigned char)185,      (unsigned char)177,      (unsigned char)249,      (unsigned char)159, 
        (unsigned char)217,      (unsigned char)209,      (unsigned char)153,      (unsigned char)255};
#line 100 "acss.c"
static unsigned char reverse[256]  = 
#line 100
  {      (unsigned char)0,      (unsigned char)128,      (unsigned char)64,      (unsigned char)192, 
        (unsigned char)32,      (unsigned char)160,      (unsigned char)96,      (unsigned char)224, 
        (unsigned char)16,      (unsigned char)144,      (unsigned char)80,      (unsigned char)208, 
        (unsigned char)48,      (unsigned char)176,      (unsigned char)112,      (unsigned char)240, 
        (unsigned char)8,      (unsigned char)136,      (unsigned char)72,      (unsigned char)200, 
        (unsigned char)40,      (unsigned char)168,      (unsigned char)104,      (unsigned char)232, 
        (unsigned char)24,      (unsigned char)152,      (unsigned char)88,      (unsigned char)216, 
        (unsigned char)56,      (unsigned char)184,      (unsigned char)120,      (unsigned char)248, 
        (unsigned char)4,      (unsigned char)132,      (unsigned char)68,      (unsigned char)196, 
        (unsigned char)36,      (unsigned char)164,      (unsigned char)100,      (unsigned char)228, 
        (unsigned char)20,      (unsigned char)148,      (unsigned char)84,      (unsigned char)212, 
        (unsigned char)52,      (unsigned char)180,      (unsigned char)116,      (unsigned char)244, 
        (unsigned char)12,      (unsigned char)140,      (unsigned char)76,      (unsigned char)204, 
        (unsigned char)44,      (unsigned char)172,      (unsigned char)108,      (unsigned char)236, 
        (unsigned char)28,      (unsigned char)156,      (unsigned char)92,      (unsigned char)220, 
        (unsigned char)60,      (unsigned char)188,      (unsigned char)124,      (unsigned char)252, 
        (unsigned char)2,      (unsigned char)130,      (unsigned char)66,      (unsigned char)194, 
        (unsigned char)34,      (unsigned char)162,      (unsigned char)98,      (unsigned char)226, 
        (unsigned char)18,      (unsigned char)146,      (unsigned char)82,      (unsigned char)210, 
        (unsigned char)50,      (unsigned char)178,      (unsigned char)114,      (unsigned char)242, 
        (unsigned char)10,      (unsigned char)138,      (unsigned char)74,      (unsigned char)202, 
        (unsigned char)42,      (unsigned char)170,      (unsigned char)106,      (unsigned char)234, 
        (unsigned char)26,      (unsigned char)154,      (unsigned char)90,      (unsigned char)218, 
        (unsigned char)58,      (unsigned char)186,      (unsigned char)122,      (unsigned char)250, 
        (unsigned char)6,      (unsigned char)134,      (unsigned char)70,      (unsigned char)198, 
        (unsigned char)38,      (unsigned char)166,      (unsigned char)102,      (unsigned char)230, 
        (unsigned char)22,      (unsigned char)150,      (unsigned char)86,      (unsigned char)214, 
        (unsigned char)54,      (unsigned char)182,      (unsigned char)118,      (unsigned char)246, 
        (unsigned char)14,      (unsigned char)142,      (unsigned char)78,      (unsigned char)206, 
        (unsigned char)46,      (unsigned char)174,      (unsigned char)110,      (unsigned char)238, 
        (unsigned char)30,      (unsigned char)158,      (unsigned char)94,      (unsigned char)222, 
        (unsigned char)62,      (unsigned char)190,      (unsigned char)126,      (unsigned char)254, 
        (unsigned char)1,      (unsigned char)129,      (unsigned char)65,      (unsigned char)193, 
        (unsigned char)33,      (unsigned char)161,      (unsigned char)97,      (unsigned char)225, 
        (unsigned char)17,      (unsigned char)145,      (unsigned char)81,      (unsigned char)209, 
        (unsigned char)49,      (unsigned char)177,      (unsigned char)113,      (unsigned char)241, 
        (unsigned char)9,      (unsigned char)137,      (unsigned char)73,      (unsigned char)201, 
        (unsigned char)41,      (unsigned char)169,      (unsigned char)105,      (unsigned char)233, 
        (unsigned char)25,      (unsigned char)153,      (unsigned char)89,      (unsigned char)217, 
        (unsigned char)57,      (unsigned char)185,      (unsigned char)121,      (unsigned char)249, 
        (unsigned char)5,      (unsigned char)133,      (unsigned char)69,      (unsigned char)197, 
        (unsigned char)37,      (unsigned char)165,      (unsigned char)101,      (unsigned char)229, 
        (unsigned char)21,      (unsigned char)149,      (unsigned char)85,      (unsigned char)213, 
        (unsigned char)53,      (unsigned char)181,      (unsigned char)117,      (unsigned char)245, 
        (unsigned char)13,      (unsigned char)141,      (unsigned char)77,      (unsigned char)205, 
        (unsigned char)45,      (unsigned char)173,      (unsigned char)109,      (unsigned char)237, 
        (unsigned char)29,      (unsigned char)157,      (unsigned char)93,      (unsigned char)221, 
        (unsigned char)61,      (unsigned char)189,      (unsigned char)125,      (unsigned char)253, 
        (unsigned char)3,      (unsigned char)131,      (unsigned char)67,      (unsigned char)195, 
        (unsigned char)35,      (unsigned char)163,      (unsigned char)99,      (unsigned char)227, 
        (unsigned char)19,      (unsigned char)147,      (unsigned char)83,      (unsigned char)211, 
        (unsigned char)51,      (unsigned char)179,      (unsigned char)115,      (unsigned char)243, 
        (unsigned char)11,      (unsigned char)139,      (unsigned char)75,      (unsigned char)203, 
        (unsigned char)43,      (unsigned char)171,      (unsigned char)107,      (unsigned char)235, 
        (unsigned char)27,      (unsigned char)155,      (unsigned char)91,      (unsigned char)219, 
        (unsigned char)59,      (unsigned char)187,      (unsigned char)123,      (unsigned char)251, 
        (unsigned char)7,      (unsigned char)135,      (unsigned char)71,      (unsigned char)199, 
        (unsigned char)39,      (unsigned char)167,      (unsigned char)103,      (unsigned char)231, 
        (unsigned char)23,      (unsigned char)151,      (unsigned char)87,      (unsigned char)215, 
        (unsigned char)55,      (unsigned char)183,      (unsigned char)119,      (unsigned char)247, 
        (unsigned char)15,      (unsigned char)143,      (unsigned char)79,      (unsigned char)207, 
        (unsigned char)47,      (unsigned char)175,      (unsigned char)111,      (unsigned char)239, 
        (unsigned char)31,      (unsigned char)159,      (unsigned char)95,      (unsigned char)223, 
        (unsigned char)63,      (unsigned char)191,      (unsigned char)127,      (unsigned char)255};
#line 162 "acss.c"
int acss(ACSS_KEY *key , unsigned long len , unsigned char const   *in , unsigned char *out ) 
{ unsigned long i ;
  unsigned long lfsr17tmp ;
  unsigned long lfsr25tmp ;
  unsigned long lfsrsumtmp ;

  {
#line 169
  lfsr25tmp = 0UL;
#line 169
  lfsr17tmp = lfsr25tmp;
#line 169
  lfsrsumtmp = lfsr17tmp;
#line 172
  i = 0UL;
#line 172
  while (i < len) {
#line 173
    lfsr17tmp = (unsigned long )(key->lfsr17 ^ (key->lfsr17 >> 14));
#line 174
    key->lfsr17 = (unsigned int )((((unsigned long )(key->lfsr17 >> 8) ^ (lfsr17tmp << 9)) ^ (lfsr17tmp << 12)) ^ (lfsr17tmp << 15));
#line 178
    key->lfsr17 &= 131071U;
#line 180
    lfsr25tmp = (unsigned long )(((key->lfsr25 ^ (key->lfsr25 >> 3)) ^ (key->lfsr25 >> 4)) ^ (key->lfsr25 >> 12));
#line 184
    key->lfsr25 = (unsigned int )((unsigned long )(key->lfsr25 >> 8) ^ (lfsr25tmp << 17));
#line 185
    key->lfsr25 &= 33554431U;
#line 187
    lfsrsumtmp = (unsigned long )key->lfsrsum;
#line 190
    switch (key->mode) {
    case 0: 
    case 3: 
#line 193
    key->lfsrsum = 255U & ~ (key->lfsr17 >> 9);
#line 194
    key->lfsrsum += key->lfsr25 >> 17;
#line 195
    break;
    case 1: 
#line 197
    key->lfsrsum = key->lfsr17 >> 9;
#line 198
    key->lfsrsum += key->lfsr25 >> 17;
#line 199
    break;
    case 2: 
#line 201
    key->lfsrsum = key->lfsr17 >> 9;
#line 202
    key->lfsrsum += 255U & ~ (key->lfsr25 >> 17);
#line 203
    break;
    default: ;
#line 205
    return (1);
    }
#line 207
    key->lfsrsum = (unsigned int )((unsigned long )key->lfsrsum + (lfsrsumtmp >> 8));
#line 209
    if (key->encrypt) {
#line 210
      *(out + i) = sboxenc[((unsigned int )*(in + i) ^ key->lfsrsum) & 255U];
    } else {
#line 212
      *(out + i) = (unsigned char )(((unsigned int )sboxdec[*(in + i)] ^ key->lfsrsum) & 255U);
    }
#line 172
    i ++;
  }
#line 216
  return (0);
}
}
#line 219 "acss.c"
static void acss_seed(ACSS_KEY *key ) 
{ int i ;

  {
#line 225
  if (key->subkey_avilable) {
#line 226
    i = 0;
#line 226
    while (i < 5) {
#line 227
      key->seed[i] = reverse[(int )key->data[i] ^ (int )key->subkey[i]];
#line 226
      i ++;
    }
  } else {
#line 229
    i = 0;
#line 229
    while (i < 5) {
#line 230
      key->seed[i] = reverse[key->data[i]];
#line 229
      i ++;
    }
  }
#line 234
  key->lfsr17 = (unsigned int )(((int )key->seed[1] | ((int )key->seed[0] << 9)) | (1 << 8));
#line 237
  key->lfsr25 = (unsigned int )(((((int )key->seed[4] | ((int )key->seed[3] << 8)) | (((int )key->seed[2] & 31) << 16)) | (((int )key->seed[2] & 224) << 17)) | (1 << 21));
#line 243
  key->lfsrsum = 0U;
#line 244
  return;
}
}
#line 246 "acss.c"
void acss_setkey(ACSS_KEY *key , unsigned char const   *data , int enc , int mode ) 
{ 

  {
#line 249
  memcpy((void * __restrict  )(key->data), (void const   * __restrict  )data, sizeof(key->data));
#line 250
  memset((void *)(key->subkey), 0, sizeof(key->subkey));
#line 252
  if (enc != -1) {
#line 253
    key->encrypt = enc;
  }
#line 254
  key->mode = mode;
#line 255
  key->subkey_avilable = 0;
#line 257
  acss_seed(key);
#line 258
  return;
}
}
#line 260 "acss.c"
void acss_setsubkey(ACSS_KEY *key , unsigned char const   *subkey ) 
{ 

  {
#line 263
  memcpy((void * __restrict  )(key->subkey), (void const   * __restrict  )subkey,
         sizeof(key->subkey));
#line 264
  key->subkey_avilable = 1;
#line 265
  acss_seed(key);
#line 266
  return;
}
}
#line 1 "authfd.o"
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 26 "buffer.h"
void buffer_init(Buffer *buffer ) ;
#line 27
void buffer_clear(Buffer *buffer ) ;
#line 28
void buffer_free(Buffer *buffer ) ;
#line 30
u_int buffer_len(Buffer *buffer ) ;
#line 31
void *buffer_ptr(Buffer *buffer ) ;
#line 33
void buffer_append(Buffer *buffer , void const   *data , u_int len ) ;
#line 405 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 51 "buffer.h"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) ;
#line 52
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) ;
#line 53
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) ;
#line 59
u_int buffer_get_int(Buffer *buffer ) ;
#line 60
void buffer_put_int(Buffer *buffer , u_int value ) ;
#line 65
int buffer_get_char(Buffer *buffer ) ;
#line 66
void buffer_put_char(Buffer *buffer , int value ) ;
#line 70
void buffer_put_cstring(Buffer *buffer , char const   *s ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 19 "xmalloc.h"
void *xmalloc(size_t size ) ;
#line 22
void xfree(void *ptr ) ;
#line 58 "key.h"
Key *key_new(int type ) ;
#line 74
Key *key_from_blob(u_char const   *blob , u_int blen ) ;
#line 75
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) ;
#line 76
char const   *key_ssh_name(Key const   *k ) ;
#line 69 "authfd.h"
int ssh_agent_present(void) ;
#line 70
int ssh_get_authentication_socket(void) ;
#line 71
void ssh_close_authentication_socket(int sock ) ;
#line 73
AuthenticationConnection *ssh_get_authentication_connection(void) ;
#line 74
void ssh_close_authentication_connection(AuthenticationConnection *auth ) ;
#line 75
int ssh_get_num_identities(AuthenticationConnection *auth , int version___0 ) ;
#line 76
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version___0 ) ;
#line 77
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version___0 ) ;
#line 78
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) ;
#line 79
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) ;
#line 81
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) ;
#line 82
int ssh_remove_all_identities(AuthenticationConnection *auth , int version___0 ) ;
#line 83
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) ;
#line 84
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) ;
#line 87
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) ;
#line 91
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) ;
#line 69 "compat.h"
int datafellows ;
#line 55 "log.h"
void ( /* format attribute */  error)(char const   *fmt  , ...) ;
#line 57
void ( /* format attribute */  logit)(char const   *fmt  , ...) ;
#line 35 "atomicio.h"
size_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) ;
#line 68 "misc.h"
u_int32_t get_u32(void const   *vp ) ;
#line 74
void put_u32(void *vp , u_int32_t v ) ;
#line 67 "authfd.c"
static int agent_present  =    0;
#line 70
int decode_reply(int type ) ;
#line 77 "authfd.c"
int ssh_agent_present(void) 
{ int authfd ;

  {
#line 82
  if (agent_present) {
#line 83
    return (1);
  }
#line 84
  authfd = ssh_get_authentication_socket();
#line 84
  if (authfd == -1) {
#line 85
    return (0);
  } else {
#line 87
    ssh_close_authentication_socket(authfd);
#line 88
    return (1);
  }
}
}
#line 94 "authfd.c"
int ssh_get_authentication_socket(void) 
{ char const   *authsocket ;
  int sock ;
  struct sockaddr_un sunaddr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 101
  tmp = getenv("SSH_AUTH_SOCK");
#line 101
  authsocket = (char const   *)tmp;
#line 102
  if (! authsocket) {
#line 103
    return (-1);
  }
#line 105
  sunaddr.sun_family = (unsigned short)1;
#line 106
  strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
#line 108
  sock = socket(1, 1, 0);
#line 109
  if (sock < 0) {
#line 110
    return (-1);
  }
#line 113
  tmp___0 = fcntl(sock, 2, 1);
#line 113
  if (tmp___0 == -1) {
#line 114
    close(sock);
#line 115
    return (-1);
  }
#line 117
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                    sizeof(sunaddr));
#line 117
  if (tmp___1 < 0) {
#line 118
    close(sock);
#line 119
    return (-1);
  }
#line 121
  agent_present = 1;
#line 122
  return (sock);
}
}
#line 125 "authfd.c"
static int ssh_request_reply(AuthenticationConnection *auth , Buffer *request , Buffer *reply ) 
{ u_int l ;
  u_int len ;
  char buf___1[1024] ;
  size_t tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  u_int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 132
  len = buffer_len(request);
#line 133
  put_u32((void *)(buf___1), len);
#line 136
  tmp = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd, (void *)(buf___1),
                 4U);
#line 136
  if (tmp != 4U) {
#line 139
    error("Error writing to authentication socket.");
#line 140
    return (0);
  } else {
#line 136
    tmp___0 = buffer_len(request);
#line 136
    tmp___1 = buffer_ptr(request);
#line 136
    tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), auth->fd,
                       tmp___1, tmp___0);
#line 136
    tmp___3 = buffer_len(request);
#line 136
    if (tmp___2 != tmp___3) {
#line 139
      error("Error writing to authentication socket.");
#line 140
      return (0);
    }
  }
#line 146
  tmp___4 = atomicio(& read, auth->fd, (void *)(buf___1), 4U);
#line 146
  if (tmp___4 != 4U) {
#line 147
    error("Error reading response length from authentication socket.");
#line 148
    return (0);
  }
#line 152
  len = get_u32((void const   *)(buf___1));
#line 153
  if (len > 262144U) {
#line 154
    fatal("Authentication response too long: %u", len);
  }
#line 157
  buffer_clear(reply);
#line 158
  while (len > 0U) {
#line 159
    l = len;
#line 160
    if (l > sizeof(buf___1)) {
#line 161
      l = sizeof(buf___1);
    }
#line 162
    tmp___5 = atomicio(& read, auth->fd, (void *)(buf___1), l);
#line 162
    if (tmp___5 != l) {
#line 163
      error("Error reading response from authentication socket.");
#line 164
      return (0);
    }
#line 166
    buffer_append(reply, (void const   *)(buf___1), l);
#line 167
    len -= l;
  }
#line 169
  return (1);
}
}
#line 178 "authfd.c"
void ssh_close_authentication_socket(int sock ) 
{ char *tmp ;

  {
#line 181
  tmp = getenv("SSH_AUTH_SOCK");
#line 181
  if (tmp) {
#line 182
    close(sock);
  }
#line 183
  return;
}
}
#line 193 "authfd.c"
AuthenticationConnection *ssh_get_authentication_connection(void) 
{ AuthenticationConnection *auth ;
  int sock ;
  void *tmp ;

  {
#line 199
  sock = ssh_get_authentication_socket();
#line 205
  if (sock < 0) {
#line 206
    return ((AuthenticationConnection *)((void *)0));
  }
#line 208
  tmp = xmalloc(sizeof(*auth));
#line 208
  auth = (AuthenticationConnection *)tmp;
#line 209
  auth->fd = sock;
#line 210
  buffer_init(& auth->identities);
#line 211
  auth->howmany = 0;
#line 213
  return (auth);
}
}
#line 221 "authfd.c"
void ssh_close_authentication_connection(AuthenticationConnection *auth ) 
{ 

  {
#line 224
  buffer_free(& auth->identities);
#line 225
  close(auth->fd);
#line 226
  xfree((void *)auth);
#line 227
  return;
}
}
#line 230 "authfd.c"
int ssh_lock_agent(AuthenticationConnection *auth , int lock , char const   *password ) 
{ int type ;
  Buffer msg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 236
  buffer_init(& msg);
#line 237
  if (lock) {
#line 237
    tmp = 22;
  } else {
#line 237
    tmp = 23;
  }
#line 237
  buffer_put_char(& msg, tmp);
#line 238
  buffer_put_cstring(& msg, password);
#line 240
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 240
  if (tmp___0 == 0) {
#line 241
    buffer_free(& msg);
#line 242
    return (0);
  }
#line 244
  type = buffer_get_char(& msg);
#line 245
  buffer_free(& msg);
#line 246
  tmp___1 = decode_reply(type);
#line 246
  return (tmp___1);
}
}
#line 253 "authfd.c"
int ssh_get_num_identities(AuthenticationConnection *auth , int version___0 ) 
{ int type ;
  int code1 ;
  int code2 ;
  Buffer request ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 256
  code1 = 0;
#line 256
  code2 = 0;
#line 259
  switch (version___0) {
  case 1: 
#line 261
  code1 = 1;
#line 262
  code2 = 2;
#line 263
  break;
  case 2: 
#line 265
  code1 = 11;
#line 266
  code2 = 12;
#line 267
  break;
  default: ;
#line 269
  return (0);
  }
#line 276
  buffer_init(& request);
#line 277
  buffer_put_char(& request, code1);
#line 279
  buffer_clear(& auth->identities);
#line 280
  tmp = ssh_request_reply(auth, & request, & auth->identities);
#line 280
  if (tmp == 0) {
#line 281
    buffer_free(& request);
#line 282
    return (0);
  }
#line 284
  buffer_free(& request);
#line 287
  type = buffer_get_char(& auth->identities);
#line 288
  if (type == 5) {
#line 289
    return (0);
  } else {
#line 288
    if (type == 102) {
#line 289
      return (0);
    } else {
#line 288
      if (type == 30) {
#line 289
        return (0);
      } else {
#line 290
        if (type != code2) {
#line 291
          fatal("Bad authentication reply message type: %d", type);
        }
      }
    }
  }
#line 295
  tmp___0 = buffer_get_int(& auth->identities);
#line 295
  auth->howmany = (int )tmp___0;
#line 296
  if ((unsigned int )auth->howmany > 1024U) {
#line 297
    fatal("Too many identities in authentication reply: %d", auth->howmany);
  }
#line 300
  return (auth->howmany);
}
}
#line 303 "authfd.c"
Key *ssh_get_first_identity(AuthenticationConnection *auth , char **comment , int version___0 ) 
{ Key *tmp ;
  int tmp___0 ;

  {
#line 307
  tmp___0 = ssh_get_num_identities(auth, version___0);
#line 307
  if (tmp___0 > 0) {
#line 308
    tmp = ssh_get_next_identity(auth, comment, version___0);
#line 308
    return (tmp);
  }
#line 309
  return ((Key *)((void *)0));
}
}
#line 312 "authfd.c"
Key *ssh_get_next_identity(AuthenticationConnection *auth , char **comment , int version___0 ) 
{ int keybits ;
  u_int bits ;
  u_char *blob ;
  u_int blen ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 319
  key = (Key *)((void *)0);
#line 322
  if (auth->howmany <= 0) {
#line 323
    return ((Key *)((void *)0));
  }
#line 329
  switch (version___0) {
  case 1: 
#line 331
  key = key_new(0);
#line 332
  bits = buffer_get_int(& auth->identities);
#line 333
  buffer_get_bignum(& auth->identities, (key->rsa)->e);
#line 334
  buffer_get_bignum(& auth->identities, (key->rsa)->n);
#line 335
  tmp = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 335
  *comment = (char *)tmp;
#line 336
  keybits = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 337
  if (keybits < 0) {
#line 338
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 338
    logit("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0,
          bits);
  } else {
#line 337
    if (bits != (unsigned int )keybits) {
#line 338
      tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 338
      logit("Warning: identity keysize mismatch: actual %d, announced %u", tmp___0,
            bits);
    }
  }
#line 340
  break;
  case 2: 
#line 342
  tmp___1 = buffer_get_string(& auth->identities, & blen);
#line 342
  blob = (u_char *)tmp___1;
#line 343
  tmp___2 = buffer_get_string(& auth->identities, (u_int *)((void *)0));
#line 343
  *comment = (char *)tmp___2;
#line 344
  key = key_from_blob((u_char const   *)blob, blen);
#line 345
  xfree((void *)blob);
#line 346
  break;
  default: ;
#line 348
  return ((Key *)((void *)0));
  }
#line 351
  (auth->howmany) --;
#line 352
  return (key);
}
}
#line 363 "authfd.c"
int ssh_decrypt_challenge(AuthenticationConnection *auth , Key *key , BIGNUM *challenge ,
                          u_char *session_id___0 , u_int response_type , u_char *response ) 
{ Buffer buffer ;
  int success ;
  int i ;
  int type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 371
  success = 0;
#line 375
  if (key->type != 0) {
#line 376
    return (0);
  }
#line 377
  if (response_type == 0U) {
#line 378
    logit("Compatibility with ssh protocol version 1.0 no longer supported.");
#line 379
    return (0);
  }
#line 381
  buffer_init(& buffer);
#line 382
  buffer_put_char(& buffer, 3);
#line 383
  tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 383
  buffer_put_int(& buffer, (unsigned int )tmp);
#line 384
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->e);
#line 385
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->n);
#line 386
  buffer_put_bignum(& buffer, (BIGNUM const   *)challenge);
#line 387
  buffer_append(& buffer, (void const   *)session_id___0, 16U);
#line 388
  buffer_put_int(& buffer, response_type);
#line 390
  tmp___0 = ssh_request_reply(auth, & buffer, & buffer);
#line 390
  if (tmp___0 == 0) {
#line 391
    buffer_free(& buffer);
#line 392
    return (0);
  }
#line 394
  type = buffer_get_char(& buffer);
#line 396
  if (type == 5) {
#line 397
    logit("Agent admitted failure to authenticate using the key.");
  } else {
#line 396
    if (type == 102) {
#line 397
      logit("Agent admitted failure to authenticate using the key.");
    } else {
#line 396
      if (type == 30) {
#line 397
        logit("Agent admitted failure to authenticate using the key.");
      } else {
#line 398
        if (type != 4) {
#line 399
          fatal("Bad authentication response: %d", type);
        } else {
#line 401
          success = 1;
#line 406
          i = 0;
#line 406
          while (i < 16) {
#line 407
            tmp___1 = buffer_get_char(& buffer);
#line 407
            *(response + i) = (unsigned char )tmp___1;
#line 406
            i ++;
          }
        }
      }
    }
  }
#line 409
  buffer_free(& buffer);
#line 410
  return (success);
}
}
#line 414 "authfd.c"
int ssh_agent_sign(AuthenticationConnection *auth , Key *key , u_char **sigp , u_int *lenp ,
                   u_char *data , u_int datalen ) 
{ Buffer msg ;
  u_char *blob ;
  u_int blen ;
  int type ;
  int flags ;
  int ret___0 ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 424
  flags = 0;
#line 425
  ret___0 = -1;
#line 427
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 427
  if (tmp == 0) {
#line 428
    return (-1);
  }
#line 430
  if (datafellows & 1) {
#line 431
    flags = 1;
  }
#line 433
  buffer_init(& msg);
#line 434
  buffer_put_char(& msg, 13);
#line 435
  buffer_put_string(& msg, (void const   *)blob, blen);
#line 436
  buffer_put_string(& msg, (void const   *)data, datalen);
#line 437
  buffer_put_int(& msg, (unsigned int )flags);
#line 438
  xfree((void *)blob);
#line 440
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 440
  if (tmp___0 == 0) {
#line 441
    buffer_free(& msg);
#line 442
    return (-1);
  }
#line 444
  type = buffer_get_char(& msg);
#line 445
  if (type == 5) {
#line 446
    logit("Agent admitted failure to sign using the key.");
  } else {
#line 445
    if (type == 102) {
#line 446
      logit("Agent admitted failure to sign using the key.");
    } else {
#line 445
      if (type == 30) {
#line 446
        logit("Agent admitted failure to sign using the key.");
      } else {
#line 447
        if (type != 14) {
#line 448
          fatal("Bad authentication response: %d", type);
        } else {
#line 450
          ret___0 = 0;
#line 451
          tmp___1 = buffer_get_string(& msg, lenp);
#line 451
          *sigp = (u_char *)tmp___1;
        }
      }
    }
  }
#line 453
  buffer_free(& msg);
#line 454
  return (ret___0);
}
}
#line 459 "authfd.c"
static void ssh_encode_identity_rsa1(Buffer *b , RSA *key , char const   *comment ) 
{ int tmp ;

  {
#line 462
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 462
  buffer_put_int(b, (unsigned int )tmp);
#line 463
  buffer_put_bignum(b, (BIGNUM const   *)key->n);
#line 464
  buffer_put_bignum(b, (BIGNUM const   *)key->e);
#line 465
  buffer_put_bignum(b, (BIGNUM const   *)key->d);
#line 467
  buffer_put_bignum(b, (BIGNUM const   *)key->iqmp);
#line 468
  buffer_put_bignum(b, (BIGNUM const   *)key->q);
#line 469
  buffer_put_bignum(b, (BIGNUM const   *)key->p);
#line 470
  buffer_put_cstring(b, comment);
#line 471
  return;
}
}
#line 473 "authfd.c"
static void ssh_encode_identity_ssh2(Buffer *b , Key *key , char const   *comment ) 
{ char const   *tmp ;

  {
#line 476
  tmp = key_ssh_name((Key const   *)key);
#line 476
  buffer_put_cstring(b, tmp);
#line 477
  switch (key->type) {
  case 1: 
#line 479
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->n);
#line 480
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->e);
#line 481
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->d);
#line 482
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->iqmp);
#line 483
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->p);
#line 484
  buffer_put_bignum2(b, (BIGNUM const   *)(key->rsa)->q);
#line 485
  break;
  case 2: 
#line 487
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->p);
#line 488
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->q);
#line 489
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->g);
#line 490
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 491
  buffer_put_bignum2(b, (BIGNUM const   *)(key->dsa)->priv_key);
#line 492
  break;
  }
#line 494
  buffer_put_cstring(b, comment);
#line 495
  return;
}
}
#line 502 "authfd.c"
int ssh_add_identity_constrained(AuthenticationConnection *auth , Key *key , char const   *comment ,
                                 u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 507
  if (life) {
#line 507
    tmp = 1;
  } else {
#line 507
    if (confirm) {
#line 507
      tmp = 1;
    } else {
#line 507
      tmp = 0;
    }
  }
#line 507
  constrained = tmp;
#line 509
  buffer_init(& msg);
#line 511
  switch (key->type) {
  case 0: 
#line 513
  if (constrained) {
#line 513
    type = 24;
  } else {
#line 513
    type = 7;
  }
#line 516
  buffer_put_char(& msg, type);
#line 517
  ssh_encode_identity_rsa1(& msg, key->rsa, comment);
#line 518
  break;
  case 1: 
  case 2: 
#line 521
  if (constrained) {
#line 521
    type = 25;
  } else {
#line 521
    type = 17;
  }
#line 524
  buffer_put_char(& msg, type);
#line 525
  ssh_encode_identity_ssh2(& msg, key, comment);
#line 526
  break;
  default: 
#line 528
  buffer_free(& msg);
#line 529
  return (0);
  }
#line 531
  if (constrained) {
#line 532
    if (life != 0U) {
#line 533
      buffer_put_char(& msg, 1);
#line 534
      buffer_put_int(& msg, life);
    }
#line 536
    if (confirm != 0U) {
#line 537
      buffer_put_char(& msg, 2);
    }
  }
#line 539
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 539
  if (tmp___0 == 0) {
#line 540
    buffer_free(& msg);
#line 541
    return (0);
  }
#line 543
  type = buffer_get_char(& msg);
#line 544
  buffer_free(& msg);
#line 545
  tmp___1 = decode_reply(type);
#line 545
  return (tmp___1);
}
}
#line 548 "authfd.c"
int ssh_add_identity(AuthenticationConnection *auth , Key *key , char const   *comment ) 
{ int tmp ;

  {
#line 551
  tmp = ssh_add_identity_constrained(auth, key, comment, 0U, 0U);
#line 551
  return (tmp);
}
}
#line 559 "authfd.c"
int ssh_remove_identity(AuthenticationConnection *auth , Key *key ) 
{ Buffer msg ;
  int type ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 567
  buffer_init(& msg);
#line 569
  if (key->type == 0) {
#line 570
    buffer_put_char(& msg, 8);
#line 571
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 571
    buffer_put_int(& msg, (unsigned int )tmp);
#line 572
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->e);
#line 573
    buffer_put_bignum(& msg, (BIGNUM const   *)(key->rsa)->n);
  } else {
#line 574
    if (key->type == 2) {
#line 575
      key_to_blob((Key const   *)key, & blob, & blen);
#line 576
      buffer_put_char(& msg, 18);
#line 577
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 578
      xfree((void *)blob);
    } else {
#line 574
      if (key->type == 1) {
#line 575
        key_to_blob((Key const   *)key, & blob, & blen);
#line 576
        buffer_put_char(& msg, 18);
#line 577
        buffer_put_string(& msg, (void const   *)blob, blen);
#line 578
        xfree((void *)blob);
      } else {
#line 580
        buffer_free(& msg);
#line 581
        return (0);
      }
    }
  }
#line 583
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 583
  if (tmp___0 == 0) {
#line 584
    buffer_free(& msg);
#line 585
    return (0);
  }
#line 587
  type = buffer_get_char(& msg);
#line 588
  buffer_free(& msg);
#line 589
  tmp___1 = decode_reply(type);
#line 589
  return (tmp___1);
}
}
#line 592 "authfd.c"
int ssh_update_card(AuthenticationConnection *auth , int add , char const   *reader_id ,
                    char const   *pin , u_int life , u_int confirm ) 
{ Buffer msg ;
  int type ;
  int constrained ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 597
  if (life) {
#line 597
    tmp = 1;
  } else {
#line 597
    if (confirm) {
#line 597
      tmp = 1;
    } else {
#line 597
      tmp = 0;
    }
  }
#line 597
  constrained = tmp;
#line 599
  if (add) {
#line 600
    if (constrained) {
#line 600
      type = 26;
    } else {
#line 600
      type = 20;
    }
  } else {
#line 604
    type = 21;
  }
#line 606
  buffer_init(& msg);
#line 607
  buffer_put_char(& msg, type);
#line 608
  buffer_put_cstring(& msg, reader_id);
#line 609
  buffer_put_cstring(& msg, pin);
#line 611
  if (constrained) {
#line 612
    if (life != 0U) {
#line 613
      buffer_put_char(& msg, 1);
#line 614
      buffer_put_int(& msg, life);
    }
#line 616
    if (confirm != 0U) {
#line 617
      buffer_put_char(& msg, 2);
    }
  }
#line 620
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 620
  if (tmp___0 == 0) {
#line 621
    buffer_free(& msg);
#line 622
    return (0);
  }
#line 624
  type = buffer_get_char(& msg);
#line 625
  buffer_free(& msg);
#line 626
  tmp___1 = decode_reply(type);
#line 626
  return (tmp___1);
}
}
#line 634 "authfd.c"
int ssh_remove_all_identities(AuthenticationConnection *auth , int version___0 ) 
{ Buffer msg ;
  int type ;
  int code ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 639
  if (version___0 == 1) {
#line 639
    tmp = 9;
  } else {
#line 639
    tmp = 19;
  }
#line 639
  code = tmp;
#line 643
  buffer_init(& msg);
#line 644
  buffer_put_char(& msg, code);
#line 646
  tmp___0 = ssh_request_reply(auth, & msg, & msg);
#line 646
  if (tmp___0 == 0) {
#line 647
    buffer_free(& msg);
#line 648
    return (0);
  }
#line 650
  type = buffer_get_char(& msg);
#line 651
  buffer_free(& msg);
#line 652
  tmp___1 = decode_reply(type);
#line 652
  return (tmp___1);
}
}
#line 655 "authfd.c"
int decode_reply(int type ) 
{ 

  {
#line 658
  switch (type) {
  case 5: 
  case 102: 
  case 30: 
#line 662
  logit("SSH_AGENT_FAILURE");
#line 663
  return (0);
  case 6: 
#line 665
  return (1);
  default: 
#line 667
  fatal("Bad response from authentication agent: %d", type);
  }
#line 670
  return (0);
}
}
#line 1 "authfile.o"
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 391
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64") __attribute__((__nonnull__(3))) ;
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 450
  tmp = __fxstat(3, __fd, __statbuf);
#line 450
  return (tmp);
}
}
#line 213 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 259
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 34 "buffer.h"
void *buffer_append_space(Buffer *buffer , u_int len ) ;
#line 639 "/usr/include/openssl/evp.h"
extern EVP_CIPHER const   *EVP_des_ede3_cbc(void) ;
#line 749
extern struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 754
extern struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 763
extern void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 298 "/usr/include/openssl/rsa.h"
extern int RSA_blinding_on(RSA *rsa , BN_CTX *ctx ) ;
#line 616 "/usr/include/openssl/pem.h"
extern int PEM_write_RSAPrivateKey(FILE *fp , RSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 625
extern int PEM_write_DSAPrivateKey(FILE *fp , DSA *x , EVP_CIPHER const   *enc , unsigned char *kstr ,
                                   int klen , pem_password_cb *cb , void *u ) ;
#line 640
extern EVP_PKEY *PEM_read_PrivateKey(FILE *fp , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 304 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 73 "cipher.h"
Cipher *cipher_by_number(int id ) ;
#line 79
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) ;
#line 80
void cipher_cleanup(CipherContext *cc ) ;
#line 81
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int do_encrypt ) ;
#line 59 "key.h"
Key *key_new_private(int type ) ;
#line 60
void key_free(Key *k ) ;
#line 65
char const   *key_type(Key const   *k ) ;
#line 67
int key_read(Key *ret___0 , char **cpp ) ;
#line 61 "log.h"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) ;
#line 18 "authfile.h"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) ;
#line 19
Key *key_load_public(char const   *filename , char **commentp ) ;
#line 20
Key *key_load_public_type(int type , char const   *filename , char **commentp ) ;
#line 21
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) ;
#line 22
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp , int *perm_ok ) ;
#line 23
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) ;
#line 24
int key_perm_ok(int fd , char const   *filename ) ;
#line 24 "rsa.h"
void rsa_generate_additional_parameters(RSA *rsa ) ;
#line 89 "misc.h"
int read_keyfile_line(FILE *f , char const   *filename , char *buf___1 , size_t bufsz ,
                      u_long *lineno ) ;
#line 70 "authfile.c"
static char const   authfile_id_string[33]  = 
#line 70 "authfile.c"
  {      (char const   )'S',      (char const   )'S',      (char const   )'H',      (char const   )' ', 
        (char const   )'P',      (char const   )'R',      (char const   )'I',      (char const   )'V', 
        (char const   )'A',      (char const   )'T',      (char const   )'E',      (char const   )' ', 
        (char const   )'K',      (char const   )'E',      (char const   )'Y',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'L',      (char const   )'E', 
        (char const   )' ',      (char const   )'F',      (char const   )'O',      (char const   )'R', 
        (char const   )'M',      (char const   )'A',      (char const   )'T',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'1',      (char const   )'\n', 
        (char const   )'\000'};
#line 80 "authfile.c"
static int key_save_private_rsa1(Key *key , char const   *filename , char const   *passphrase ,
                                 char const   *comment ) 
{ Buffer buffer ;
  Buffer encrypted ;
  u_char buf___1[100] ;
  u_char *cp ;
  int fd ;
  int i ;
  int cipher_num ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  u_int32_t rnd ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  u_int tmp___19 ;
  int tmp___20 ;
  u_int tmp___21 ;
  void *tmp___22 ;
  u_int tmp___23 ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  u_int tmp___29 ;
  void *tmp___30 ;
  size_t tmp___31 ;
  u_int tmp___32 ;

  {
#line 95
  if (0) {
#line 95
    __s1_len___0 = strlen(passphrase);
#line 95
    __s2_len___0 = strlen("");
#line 95
    if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
      goto _L___2;
    } else {
#line 95
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 95
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 95
          tmp___18 = 1;
        } else {
#line 95
          if (__s2_len___0 >= 4U) {
#line 95
            tmp___18 = 1;
          } else {
#line 95
            tmp___18 = 0;
          }
        }
      } else {
#line 95
        tmp___18 = 0;
      }
    }
#line 95
    if (tmp___18) {
#line 95
      tmp___14 = __builtin_strcmp(passphrase, "");
    } else {
#line 95
      tmp___17 = __builtin_strcmp(passphrase, "");
#line 95
      tmp___14 = tmp___17;
    }
  } else {
#line 95
    tmp___17 = __builtin_strcmp(passphrase, "");
#line 95
    tmp___14 = tmp___17;
  }
#line 95
  if (tmp___14 == 0) {
#line 95
    cipher_num = 0;
  } else {
#line 95
    cipher_num = 3;
  }
#line 97
  cipher = cipher_by_number(cipher_num);
#line 97
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 98
    fatal("save_private_key_rsa: bad cipher");
  }
#line 101
  buffer_init(& buffer);
#line 104
  rnd = arc4random();
#line 105
  buf___1[0] = (unsigned char )(rnd & 255U);
#line 106
  buf___1[1] = (unsigned char )((rnd >> 8) & 255U);
#line 107
  buf___1[2] = buf___1[0];
#line 108
  buf___1[3] = buf___1[1];
#line 109
  buffer_append(& buffer, (void const   *)(buf___1), 4U);
#line 116
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->d);
#line 117
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->iqmp);
#line 118
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->q);
#line 119
  buffer_put_bignum(& buffer, (BIGNUM const   *)(key->rsa)->p);
#line 122
  while (1) {
#line 122
    tmp___19 = buffer_len(& buffer);
#line 122
    if (! (tmp___19 % 8U != 0U)) {
#line 122
      break;
    }
#line 123
    buffer_put_char(& buffer, 0);
  }
#line 126
  buffer_init(& encrypted);
#line 129
  i = 0;
#line 129
  while (authfile_id_string[i]) {
#line 130
    buffer_put_char(& encrypted, (int )authfile_id_string[i]);
#line 129
    i ++;
  }
#line 131
  buffer_put_char(& encrypted, 0);
#line 134
  buffer_put_char(& encrypted, cipher_num);
#line 135
  buffer_put_int(& encrypted, 0U);
#line 138
  tmp___20 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 138
  buffer_put_int(& encrypted, (unsigned int )tmp___20);
#line 139
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->n);
#line 140
  buffer_put_bignum(& encrypted, (BIGNUM const   *)(key->rsa)->e);
#line 141
  buffer_put_cstring(& encrypted, comment);
#line 144
  tmp___21 = buffer_len(& buffer);
#line 144
  tmp___22 = buffer_append_space(& encrypted, tmp___21);
#line 144
  cp = (u_char *)tmp___22;
#line 146
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 1);
#line 148
  tmp___23 = buffer_len(& buffer);
#line 148
  tmp___24 = buffer_ptr(& buffer);
#line 148
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___24, tmp___23);
#line 150
  cipher_cleanup(& ciphercontext);
#line 151
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 154
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 155
  buffer_free(& buffer);
#line 157
  fd = open(filename, 577, 384);
#line 158
  if (fd < 0) {
#line 159
    tmp___25 = __errno_location();
#line 159
    tmp___26 = strerror(*tmp___25);
#line 159
    error("open %s failed: %s.", filename, tmp___26);
#line 160
    buffer_free(& encrypted);
#line 161
    return (0);
  }
#line 163
  tmp___29 = buffer_len(& encrypted);
#line 163
  tmp___30 = buffer_ptr(& encrypted);
#line 163
  tmp___31 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, tmp___30,
                      tmp___29);
#line 163
  tmp___32 = buffer_len(& encrypted);
#line 163
  if (tmp___31 != tmp___32) {
#line 165
    tmp___27 = __errno_location();
#line 165
    tmp___28 = strerror(*tmp___27);
#line 165
    error("write to key file %s failed: %s", filename, tmp___28);
#line 167
    buffer_free(& encrypted);
#line 168
    close(fd);
#line 169
    unlink(filename);
#line 170
    return (0);
  }
#line 172
  close(fd);
#line 173
  buffer_free(& encrypted);
#line 174
  return (1);
}
}
#line 178 "authfile.c"
static int key_save_private_pem(Key *key , char const   *filename , char const   *_passphrase ,
                                char const   *comment ) 
{ FILE *fp ;
  int fd ;
  int success ;
  int len ;
  size_t tmp ;
  u_char *passphrase ;
  u_char *tmp___0 ;
  EVP_CIPHER const   *cipher ;
  EVP_CIPHER const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 184
  success = 0;
#line 185
  tmp = strlen(_passphrase);
#line 185
  len = (int )tmp;
#line 186
  if (len > 0) {
#line 186
    tmp___0 = (u_char *)_passphrase;
  } else {
#line 186
    tmp___0 = (u_char *)((void *)0);
  }
#line 186
  passphrase = tmp___0;
#line 187
  if (len > 0) {
#line 187
    tmp___2 = EVP_des_ede3_cbc();
  } else {
#line 187
    tmp___2 = (EVP_CIPHER const   *)((void *)0);
  }
#line 187
  cipher = tmp___2;
#line 189
  if (len > 0) {
#line 189
    if (len <= 4) {
#line 190
      error("passphrase too short: have %d bytes, need > 4", len);
#line 191
      return (0);
    }
  }
#line 193
  fd = open(filename, 577, 384);
#line 194
  if (fd < 0) {
#line 195
    tmp___3 = __errno_location();
#line 195
    tmp___4 = strerror(*tmp___3);
#line 195
    error("open %s failed: %s.", filename, tmp___4);
#line 196
    return (0);
  }
#line 198
  fp = fdopen(fd, "w");
#line 199
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 200
    tmp___5 = __errno_location();
#line 200
    tmp___6 = strerror(*tmp___5);
#line 200
    error("fdopen %s failed: %s.", filename, tmp___6);
#line 201
    close(fd);
#line 202
    return (0);
  }
#line 204
  switch (key->type) {
  case 2: 
#line 206
  success = PEM_write_DSAPrivateKey(fp, key->dsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 208
  break;
  case 1: 
#line 210
  success = PEM_write_RSAPrivateKey(fp, key->rsa, cipher, passphrase, len, (pem_password_cb *)((void *)0),
                                    (void *)0);
#line 212
  break;
  }
#line 214
  fclose(fp);
#line 215
  return (success);
}
}
#line 218 "authfile.c"
int key_save_private(Key *key , char const   *filename , char const   *passphrase ,
                     char const   *comment ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 222
  switch (key->type) {
  case 0: 
#line 224
  tmp = key_save_private_rsa1(key, filename, passphrase, comment);
#line 224
  return (tmp);
  case 2: 
  case 1: 
#line 228
  tmp___0 = key_save_private_pem(key, filename, passphrase, comment);
#line 228
  return (tmp___0);
  default: ;
#line 231
  break;
  }
#line 233
  error("key_save_private: cannot save key type %d", key->type);
#line 234
  return (0);
}
}
#line 243 "authfile.c"
static Key *key_load_public_rsa1(int fd , char const   *filename , char **commentp ) 
{ Buffer buffer ;
  Key *pub ;
  struct stat st ;
  char *cp ;
  u_int i ;
  size_t len ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 253
  tmp___1 = fstat(fd, & st);
#line 253
  if (tmp___1 < 0) {
#line 254
    tmp = __errno_location();
#line 254
    tmp___0 = strerror(*tmp);
#line 254
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 256
    return ((Key *)((void *)0));
  }
#line 258
  if (st.st_size > 1048576LL) {
#line 259
    error("key file %.200s too large", filename);
#line 260
    return ((Key *)((void *)0));
  }
#line 262
  len = (unsigned int )st.st_size;
#line 264
  buffer_init(& buffer);
#line 265
  tmp___2 = buffer_append_space(& buffer, len);
#line 265
  cp = (char *)tmp___2;
#line 267
  tmp___5 = atomicio(& read, fd, (void *)cp, len);
#line 267
  if (tmp___5 != len) {
#line 268
    tmp___3 = __errno_location();
#line 268
    tmp___4 = strerror(*tmp___3);
#line 268
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 270
    buffer_free(& buffer);
#line 271
    return ((Key *)((void *)0));
  }
#line 275
  if (len < sizeof(authfile_id_string)) {
#line 276
    debug3("Not a RSA1 key file %.200s.", filename);
#line 277
    buffer_free(& buffer);
#line 278
    return ((Key *)((void *)0));
  }
#line 284
  i = 0U;
#line 284
  while (i < sizeof(authfile_id_string)) {
#line 285
    tmp___6 = buffer_get_char(& buffer);
#line 285
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 286
      debug3("Not a RSA1 key file %.200s.", filename);
#line 287
      buffer_free(& buffer);
#line 288
      return ((Key *)((void *)0));
    }
#line 284
    i ++;
  }
#line 291
  buffer_get_char(& buffer);
#line 292
  buffer_get_int(& buffer);
#line 295
  buffer_get_int(& buffer);
#line 296
  pub = key_new(0);
#line 297
  buffer_get_bignum(& buffer, (pub->rsa)->n);
#line 298
  buffer_get_bignum(& buffer, (pub->rsa)->e);
#line 299
  if (commentp) {
#line 300
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 300
    *commentp = (char *)tmp___7;
  }
#line 303
  buffer_free(& buffer);
#line 304
  return (pub);
}
}
#line 308 "authfile.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ Key *pub ;
  int fd ;

  {
#line 314
  if (type == 0) {
#line 315
    fd = open(filename, 0);
#line 316
    if (fd < 0) {
#line 317
      return ((Key *)((void *)0));
    }
#line 318
    pub = key_load_public_rsa1(fd, filename, commentp);
#line 319
    close(fd);
#line 320
    return (pub);
  }
#line 322
  return ((Key *)((void *)0));
}
}
#line 332 "authfile.c"
static Key *key_load_private_rsa1(int fd , char const   *filename , char const   *passphrase ,
                                  char **commentp ) 
{ u_int i ;
  int check1 ;
  int check2 ;
  int cipher_type ;
  size_t len ;
  Buffer buffer ;
  Buffer decrypted ;
  u_char *cp ;
  CipherContext ciphercontext ;
  Cipher *cipher ;
  Key *prv ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 343
  prv = (Key *)((void *)0);
#line 346
  tmp___1 = fstat(fd, & st);
#line 346
  if (tmp___1 < 0) {
#line 347
    tmp = __errno_location();
#line 347
    tmp___0 = strerror(*tmp);
#line 347
    error("fstat for key file %.200s failed: %.100s", filename, tmp___0);
#line 349
    close(fd);
#line 350
    return ((Key *)((void *)0));
  }
#line 352
  if (st.st_size > 1048576LL) {
#line 353
    error("key file %.200s too large", filename);
#line 354
    close(fd);
#line 355
    return ((Key *)((void *)0));
  }
#line 357
  len = (unsigned int )st.st_size;
#line 359
  buffer_init(& buffer);
#line 360
  tmp___2 = buffer_append_space(& buffer, len);
#line 360
  cp = (u_char *)tmp___2;
#line 362
  tmp___5 = atomicio(& read, fd, (void *)cp, len);
#line 362
  if (tmp___5 != len) {
#line 363
    tmp___3 = __errno_location();
#line 363
    tmp___4 = strerror(*tmp___3);
#line 363
    debug("Read from key file %.200s failed: %.100s", filename, tmp___4);
#line 365
    buffer_free(& buffer);
#line 366
    close(fd);
#line 367
    return ((Key *)((void *)0));
  }
#line 371
  if (len < sizeof(authfile_id_string)) {
#line 372
    debug3("Not a RSA1 key file %.200s.", filename);
#line 373
    buffer_free(& buffer);
#line 374
    close(fd);
#line 375
    return ((Key *)((void *)0));
  }
#line 381
  i = 0U;
#line 381
  while (i < sizeof(authfile_id_string)) {
#line 382
    tmp___6 = buffer_get_char(& buffer);
#line 382
    if (tmp___6 != (int )authfile_id_string[i]) {
#line 383
      debug3("Not a RSA1 key file %.200s.", filename);
#line 384
      buffer_free(& buffer);
#line 385
      close(fd);
#line 386
      return ((Key *)((void *)0));
    }
#line 381
    i ++;
  }
#line 390
  cipher_type = buffer_get_char(& buffer);
#line 391
  buffer_get_int(& buffer);
#line 394
  buffer_get_int(& buffer);
#line 395
  prv = key_new_private(0);
#line 397
  buffer_get_bignum(& buffer, (prv->rsa)->n);
#line 398
  buffer_get_bignum(& buffer, (prv->rsa)->e);
#line 399
  if (commentp) {
#line 400
    tmp___7 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 400
    *commentp = (char *)tmp___7;
  } else {
#line 402
    tmp___8 = buffer_get_string(& buffer, (u_int *)((void *)0));
#line 402
    xfree(tmp___8);
  }
#line 405
  cipher = cipher_by_number(cipher_type);
#line 406
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 407
    debug("Unsupported cipher %d used in key file %.200s.", cipher_type, filename);
#line 409
    buffer_free(& buffer);
    goto fail;
  }
#line 413
  buffer_init(& decrypted);
#line 414
  tmp___9 = buffer_len(& buffer);
#line 414
  tmp___10 = buffer_append_space(& decrypted, tmp___9);
#line 414
  cp = (u_char *)tmp___10;
#line 417
  cipher_set_key_string(& ciphercontext, cipher, passphrase, 0);
#line 419
  tmp___11 = buffer_len(& buffer);
#line 419
  tmp___12 = buffer_ptr(& buffer);
#line 419
  cipher_crypt(& ciphercontext, cp, (u_char const   *)tmp___12, tmp___11);
#line 421
  cipher_cleanup(& ciphercontext);
#line 422
  memset((void *)(& ciphercontext), 0, sizeof(ciphercontext));
#line 423
  buffer_free(& buffer);
#line 425
  check1 = buffer_get_char(& decrypted);
#line 426
  check2 = buffer_get_char(& decrypted);
#line 427
  tmp___23 = buffer_get_char(& decrypted);
#line 427
  if (check1 != tmp___23) {
    goto _L___1;
  } else {
#line 427
    tmp___24 = buffer_get_char(& decrypted);
#line 427
    if (check2 != tmp___24) {
      _L___1: /* CIL Label */ 
#line 429
      if (0) {
#line 429
        __s1_len = strlen(passphrase);
#line 429
        __s2_len = strlen("");
#line 429
        if (! ((unsigned int )((void const   *)(passphrase + 1)) - (unsigned int )((void const   *)passphrase) == 1U)) {
          goto _L___0;
        } else {
#line 429
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 429
            if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 429
              tmp___22 = 1;
            } else {
#line 429
              if (__s2_len >= 4U) {
#line 429
                tmp___22 = 1;
              } else {
#line 429
                tmp___22 = 0;
              }
            }
          } else {
#line 429
            tmp___22 = 0;
          }
        }
#line 429
        if (tmp___22) {
#line 429
          tmp___18 = __builtin_strcmp(passphrase, "");
        } else {
#line 429
          tmp___21 = __builtin_strcmp(passphrase, "");
#line 429
          tmp___18 = tmp___21;
        }
      } else {
#line 429
        tmp___21 = __builtin_strcmp(passphrase, "");
#line 429
        tmp___18 = tmp___21;
      }
#line 429
      if (tmp___18 != 0) {
#line 430
        debug("Bad passphrase supplied for key file %.200s.", filename);
      }
#line 433
      buffer_free(& decrypted);
      goto fail;
    }
  }
#line 437
  buffer_get_bignum(& decrypted, (prv->rsa)->d);
#line 438
  buffer_get_bignum(& decrypted, (prv->rsa)->iqmp);
#line 440
  buffer_get_bignum(& decrypted, (prv->rsa)->q);
#line 441
  buffer_get_bignum(& decrypted, (prv->rsa)->p);
#line 444
  rsa_generate_additional_parameters(prv->rsa);
#line 446
  buffer_free(& decrypted);
#line 449
  tmp___25 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 449
  if (tmp___25 != 1) {
#line 450
    error("key_load_private_rsa1: RSA_blinding_on failed");
    goto fail;
  }
#line 453
  close(fd);
#line 454
  return (prv);
  fail: 
#line 457
  if (commentp) {
#line 458
    xfree((void *)*commentp);
  }
#line 459
  close(fd);
#line 460
  key_free(prv);
#line 461
  return ((Key *)((void *)0));
}
}
#line 464 "authfile.c"
Key *key_load_private_pem(int fd , int type , char const   *passphrase , char **commentp ) 
{ FILE *fp ;
  EVP_PKEY *pk ;
  Key *prv ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;

  {
#line 469
  pk = (EVP_PKEY *)((void *)0);
#line 470
  prv = (Key *)((void *)0);
#line 471
  name = (char *)"<no key>";
#line 473
  fp = fdopen(fd, "r");
#line 474
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 475
    tmp = __errno_location();
#line 475
    tmp___0 = strerror(*tmp);
#line 475
    error("fdopen failed: %s", tmp___0);
#line 476
    close(fd);
#line 477
    return ((Key *)((void *)0));
  }
#line 479
  pk = PEM_read_PrivateKey(fp, (EVP_PKEY **)((void *)0), (pem_password_cb *)((void *)0),
                           (void *)((char *)passphrase));
#line 480
  if ((unsigned int )pk == (unsigned int )((void *)0)) {
#line 481
    debug("PEM_read_PrivateKey failed");
#line 482
    ERR_get_error();
  } else {
#line 483
    if (pk->type == 6) {
#line 483
      if (type == 3) {
        goto _L___0;
      } else {
#line 483
        if (type == 1) {
          _L___0: /* CIL Label */ 
#line 485
          prv = key_new(3);
#line 486
          prv->rsa = EVP_PKEY_get1_RSA(pk);
#line 487
          prv->type = 1;
#line 488
          name = (char *)"rsa w/o comment";
#line 492
          tmp___1 = RSA_blinding_on(prv->rsa, (BN_CTX *)((void *)0));
#line 492
          if (tmp___1 != 1) {
#line 493
            error("key_load_private_pem: RSA_blinding_on failed");
#line 494
            key_free(prv);
#line 495
            prv = (Key *)((void *)0);
          }
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 497
      if (pk->type == 116) {
#line 497
        if (type == 3) {
#line 499
          prv = key_new(3);
#line 500
          prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 501
          prv->type = 2;
#line 502
          name = (char *)"dsa w/o comment";
        } else {
#line 497
          if (type == 2) {
#line 499
            prv = key_new(3);
#line 500
            prv->dsa = EVP_PKEY_get1_DSA(pk);
#line 501
            prv->type = 2;
#line 502
            name = (char *)"dsa w/o comment";
          } else {
#line 507
            error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d",
                  pk->save_type);
          }
        }
      } else {
#line 507
        error("PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type %d", pk->save_type);
      }
    }
  }
#line 510
  fclose(fp);
#line 511
  if ((unsigned int )pk != (unsigned int )((void *)0)) {
#line 512
    EVP_PKEY_free(pk);
  }
#line 513
  if ((unsigned int )prv != (unsigned int )((void *)0)) {
#line 513
    if (commentp) {
#line 514
      *commentp = xstrdup((char const   *)name);
    }
  }
#line 515
  if (prv) {
#line 515
    tmp___3 = key_type((Key const   *)prv);
  } else {
#line 515
    tmp___3 = "<unknown>";
  }
#line 515
  debug("read PEM private key done: type %s", tmp___3);
#line 517
  return (prv);
}
}
#line 520 "authfile.c"
int key_perm_ok(int fd , char const   *filename ) 
{ struct stat st ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 525
  tmp = fstat(fd, & st);
#line 525
  if (tmp < 0) {
#line 526
    return (0);
  }
#line 535
  tmp___0 = getuid();
#line 535
  if (st.st_uid == tmp___0) {
#line 535
    if ((st.st_mode & 63U) != 0U) {
#line 536
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 537
      error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
#line 538
      error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
#line 539
      error("Permissions 0%3.3o for \'%s\' are too open.", st.st_mode & 511U, filename);
#line 541
      error("It is recommended that your private key files are NOT accessible by others.");
#line 542
      error("This private key will be ignored.");
#line 543
      return (0);
    }
  }
#line 545
  return (1);
}
}
#line 548 "authfile.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp , int *perm_ok ) 
{ int fd ;
  int tmp ;
  Key *tmp___0 ;
  Key *tmp___1 ;

  {
#line 554
  fd = open(filename, 0);
#line 555
  if (fd < 0) {
#line 556
    return ((Key *)((void *)0));
  }
#line 557
  tmp = key_perm_ok(fd, filename);
#line 557
  if (! tmp) {
#line 558
    if ((unsigned int )perm_ok != (unsigned int )((void *)0)) {
#line 559
      *perm_ok = 0;
    }
#line 560
    error("bad permissions: ignore key: %s", filename);
#line 561
    close(fd);
#line 562
    return ((Key *)((void *)0));
  }
#line 564
  if ((unsigned int )perm_ok != (unsigned int )((void *)0)) {
#line 565
    *perm_ok = 1;
  }
#line 566
  switch (type) {
  case 0: 
#line 568
  tmp___0 = key_load_private_rsa1(fd, filename, passphrase, commentp);
#line 568
  return (tmp___0);
  case 2: 
  case 1: 
  case 3: 
#line 574
  tmp___1 = key_load_private_pem(fd, type, passphrase, commentp);
#line 574
  return (tmp___1);
  default: 
#line 577
  close(fd);
#line 578
  break;
  }
#line 580
  return ((Key *)((void *)0));
}
}
#line 583 "authfile.c"
Key *key_load_private(char const   *filename , char const   *passphrase , char **commentp ) 
{ Key *pub ;
  Key *prv ;
  int fd ;
  int tmp ;

  {
#line 590
  fd = open(filename, 0);
#line 591
  if (fd < 0) {
#line 592
    return ((Key *)((void *)0));
  }
#line 593
  tmp = key_perm_ok(fd, filename);
#line 593
  if (! tmp) {
#line 594
    error("bad permissions: ignore key: %s", filename);
#line 595
    close(fd);
#line 596
    return ((Key *)((void *)0));
  }
#line 598
  pub = key_load_public_rsa1(fd, filename, commentp);
#line 599
  lseek(fd, 0LL, 0);
#line 600
  if ((unsigned int )pub == (unsigned int )((void *)0)) {
#line 602
    prv = key_load_private_pem(fd, 3, passphrase, (char **)((void *)0));
#line 604
    if (commentp) {
#line 604
      if (prv) {
#line 605
        *commentp = xstrdup(filename);
      }
    }
  } else {
#line 608
    key_free(pub);
#line 610
    prv = key_load_private_rsa1(fd, filename, passphrase, (char **)((void *)0));
  }
#line 612
  return (prv);
}
}
#line 615 "authfile.c"
static int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ FILE *f ;
  char line[8192] ;
  char *cp ;
  u_long linenum ;
  int tmp ;
  int tmp___0 ;

  {
#line 621
  linenum = (u_long )0;
#line 623
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 624
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 625
    while (1) {
#line 625
      tmp___0 = read_keyfile_line(f, filename, line, sizeof(line), & linenum);
#line 625
      if (! (tmp___0 != -1)) {
#line 625
        break;
      }
#line 627
      cp = line;
#line 628
      switch ((int )*cp) {
      case 35: 
      case 10: 
      case 0: 
#line 632
      continue;
      }
#line 635
      while (1) {
#line 635
        if (*cp) {
#line 635
          if (! ((int )*cp == 32)) {
#line 635
            if (! ((int )*cp == 9)) {
#line 635
              break;
            }
          }
        } else {
#line 635
          break;
        }
#line 635
        cp ++;
      }
#line 637
      if (*cp) {
#line 638
        tmp = key_read(k, & cp);
#line 638
        if (tmp == 1) {
#line 639
          if (commentp) {
#line 640
            *commentp = xstrdup(filename);
          }
#line 641
          fclose(f);
#line 642
          return (1);
        }
      }
    }
#line 646
    fclose(f);
  }
#line 648
  return (0);
}
}
#line 652 "authfile.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ Key *pub ;
  char file___0[4096] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 659
  pub = key_load_public_type(0, filename, commentp);
#line 660
  if ((unsigned int )pub != (unsigned int )((void *)0)) {
#line 661
    return (pub);
  }
#line 664
  pub = key_new(0);
#line 665
  tmp = key_try_load_public(pub, filename, commentp);
#line 665
  if (tmp == 1) {
#line 666
    return (pub);
  }
#line 667
  key_free(pub);
#line 670
  pub = key_new(3);
#line 671
  tmp___0 = key_try_load_public(pub, filename, commentp);
#line 671
  if (tmp___0 == 1) {
#line 672
    return (pub);
  }
#line 673
  tmp___1 = strlcpy(file___0, filename, sizeof(file___0));
#line 673
  if (tmp___1 < sizeof(file___0)) {
#line 673
    tmp___2 = strlcat(file___0, ".pub", sizeof(file___0));
#line 673
    if (tmp___2 < sizeof(file___0)) {
#line 673
      tmp___3 = key_try_load_public(pub, (char const   *)(file___0), commentp);
#line 673
      if (tmp___3 == 1) {
#line 676
        return (pub);
      }
    }
  }
#line 677
  key_free(pub);
#line 678
  return ((Key *)((void *)0));
}
}
#line 1 "bufaux.o"
#line 45 "buffer.h"
int buffer_get_ret(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 56
u_short buffer_get_short(Buffer *buffer ) ;
#line 57
void buffer_put_short(Buffer *buffer , u_short value ) ;
#line 62
u_int64_t buffer_get_int64(Buffer *buffer ) ;
#line 63
void buffer_put_int64(Buffer *buffer , u_int64_t value ) ;
#line 79
int buffer_get_short_ret(u_short *ret___0 , Buffer *buffer ) ;
#line 80
int buffer_get_int_ret(u_int *ret___0 , Buffer *buffer ) ;
#line 81
int buffer_get_int64_ret(u_int64_t *ret___0 , Buffer *buffer ) ;
#line 82
void *buffer_get_string_ret(Buffer *buffer , u_int *length_ptr ) ;
#line 83
int buffer_get_char_ret(char *ret___0 , Buffer *buffer ) ;
#line 66 "misc.h"
u_int64_t get_u64(void const   *vp ) ;
#line 70
u_int16_t get_u16(void const   *vp ) ;
#line 72
void put_u64(void *vp , u_int64_t v ) ;
#line 76
void put_u16(void *vp , u_int16_t v ) ;
#line 58 "bufaux.c"
int buffer_get_short_ret(u_short *ret___0 , Buffer *buffer ) 
{ u_char buf___1[2] ;
  int tmp ;

  {
#line 63
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 2U);
#line 63
  if (tmp == -1) {
#line 64
    return (-1);
  }
#line 65
  *ret___0 = get_u16((void const   *)(buf___1));
#line 66
  return (0);
}
}
#line 69 "bufaux.c"
u_short buffer_get_short(Buffer *buffer ) 
{ u_short ret___0 ;
  int tmp ;

  {
#line 74
  tmp = buffer_get_short_ret(& ret___0, buffer);
#line 74
  if (tmp == -1) {
#line 75
    fatal("buffer_get_short: buffer error");
  }
#line 77
  return (ret___0);
}
}
#line 80 "bufaux.c"
int buffer_get_int_ret(u_int *ret___0 , Buffer *buffer ) 
{ u_char buf___1[4] ;
  int tmp ;

  {
#line 85
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 4U);
#line 85
  if (tmp == -1) {
#line 86
    return (-1);
  }
#line 87
  *ret___0 = get_u32((void const   *)(buf___1));
#line 88
  return (0);
}
}
#line 91 "bufaux.c"
u_int buffer_get_int(Buffer *buffer ) 
{ u_int ret___0 ;
  int tmp ;

  {
#line 96
  tmp = buffer_get_int_ret(& ret___0, buffer);
#line 96
  if (tmp == -1) {
#line 97
    fatal("buffer_get_int: buffer error");
  }
#line 99
  return (ret___0);
}
}
#line 102 "bufaux.c"
int buffer_get_int64_ret(u_int64_t *ret___0 , Buffer *buffer ) 
{ u_char buf___1[8] ;
  int tmp ;

  {
#line 107
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 8U);
#line 107
  if (tmp == -1) {
#line 108
    return (-1);
  }
#line 109
  *ret___0 = get_u64((void const   *)(buf___1));
#line 110
  return (0);
}
}
#line 113 "bufaux.c"
u_int64_t buffer_get_int64(Buffer *buffer ) 
{ u_int64_t ret___0 ;
  int tmp ;

  {
#line 118
  tmp = buffer_get_int64_ret(& ret___0, buffer);
#line 118
  if (tmp == -1) {
#line 119
    fatal("buffer_get_int: buffer error");
  }
#line 121
  return (ret___0);
}
}
#line 127 "bufaux.c"
void buffer_put_short(Buffer *buffer , u_short value ) 
{ char buf___1[2] ;

  {
#line 132
  put_u16((void *)(buf___1), value);
#line 133
  buffer_append(buffer, (void const   *)(buf___1), 2U);
#line 134
  return;
}
}
#line 136 "bufaux.c"
void buffer_put_int(Buffer *buffer , u_int value ) 
{ char buf___1[4] ;

  {
#line 141
  put_u32((void *)(buf___1), value);
#line 142
  buffer_append(buffer, (void const   *)(buf___1), 4U);
#line 143
  return;
}
}
#line 145 "bufaux.c"
void buffer_put_int64(Buffer *buffer , u_int64_t value ) 
{ char buf___1[8] ;

  {
#line 150
  put_u64((void *)(buf___1), value);
#line 151
  buffer_append(buffer, (void const   *)(buf___1), 8U);
#line 152
  return;
}
}
#line 162 "bufaux.c"
void *buffer_get_string_ret(Buffer *buffer , u_int *length_ptr ) 
{ u_char *value ;
  u_int len ;
  void *tmp ;
  int tmp___0 ;

  {
#line 169
  len = buffer_get_int(buffer);
#line 170
  if (len > 262144U) {
#line 171
    error("buffer_get_string_ret: bad string length %u", len);
#line 172
    return ((void *)0);
  }
#line 175
  tmp = xmalloc(len + 1U);
#line 175
  value = (u_char *)tmp;
#line 177
  tmp___0 = buffer_get_ret(buffer, (void *)value, len);
#line 177
  if (tmp___0 == -1) {
#line 178
    error("buffer_get_string_ret: buffer_get failed");
#line 179
    xfree((void *)value);
#line 180
    return ((void *)0);
  }
#line 183
  *(value + len) = (unsigned char)0;
#line 185
  if (length_ptr) {
#line 186
    *length_ptr = len;
  }
#line 187
  return ((void *)value);
}
}
#line 190 "bufaux.c"
void *buffer_get_string(Buffer *buffer , u_int *length_ptr ) 
{ void *ret___0 ;

  {
#line 195
  ret___0 = buffer_get_string_ret(buffer, length_ptr);
#line 195
  if ((unsigned int )ret___0 == (unsigned int )((void *)0)) {
#line 196
    fatal("buffer_get_string: buffer error");
  }
#line 197
  return (ret___0);
}
}
#line 203 "bufaux.c"
void buffer_put_string(Buffer *buffer , void const   *buf___1 , u_int len ) 
{ 

  {
#line 206
  buffer_put_int(buffer, len);
#line 207
  buffer_append(buffer, buf___1, len);
#line 208
  return;
}
}
#line 209 "bufaux.c"
void buffer_put_cstring(Buffer *buffer , char const   *s ) 
{ size_t tmp ;

  {
#line 212
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 213
    fatal("buffer_put_cstring: s == NULL");
  }
#line 214
  tmp = strlen(s);
#line 214
  buffer_put_string(buffer, (void const   *)s, tmp);
#line 215
  return;
}
}
#line 220 "bufaux.c"
int buffer_get_char_ret(char *ret___0 , Buffer *buffer ) 
{ int tmp ;

  {
#line 223
  tmp = buffer_get_ret(buffer, (void *)ret___0, 1U);
#line 223
  if (tmp == -1) {
#line 224
    error("buffer_get_char_ret: buffer_get_ret failed");
#line 225
    return (-1);
  }
#line 227
  return (0);
}
}
#line 230 "bufaux.c"
int buffer_get_char(Buffer *buffer ) 
{ char ch ;
  int tmp ;

  {
#line 235
  tmp = buffer_get_char_ret(& ch, buffer);
#line 235
  if (tmp == -1) {
#line 236
    fatal("buffer_get_char: buffer error");
  }
#line 237
  return ((int )((unsigned char )ch));
}
}
#line 243 "bufaux.c"
void buffer_put_char(Buffer *buffer , int value ) 
{ char ch ;

  {
#line 246
  ch = (char )value;
#line 248
  buffer_append(buffer, (void const   *)(& ch), 1U);
#line 249
  return;
}
}
#line 1 "bufbn.o"
#line 46 "buffer.h"
int buffer_consume_ret(Buffer *buffer , u_int bytes ) ;
#line 412 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 413
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 54 "buffer.h"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) ;
#line 75
int buffer_put_bignum_ret(Buffer *buffer , BIGNUM const   *value ) ;
#line 76
int buffer_get_bignum_ret(Buffer *buffer , BIGNUM *value ) ;
#line 77
int buffer_put_bignum2_ret(Buffer *buffer , BIGNUM const   *value ) ;
#line 78
int buffer_get_bignum2_ret(Buffer *buffer , BIGNUM *value ) ;
#line 58 "bufbn.c"
int buffer_put_bignum_ret(Buffer *buffer , BIGNUM const   *value ) 
{ int bits ;
  int tmp ;
  int bin_size ;
  u_char *buf___1 ;
  void *tmp___0 ;
  int oi ;
  char msg[2] ;

  {
#line 61
  tmp = BN_num_bits(value);
#line 61
  bits = tmp;
#line 62
  bin_size = (bits + 7) / 8;
#line 63
  tmp___0 = xmalloc((unsigned int )bin_size);
#line 63
  buf___1 = (u_char *)tmp___0;
#line 68
  oi = BN_bn2bin(value, buf___1);
#line 69
  if (oi != bin_size) {
#line 70
    error("buffer_put_bignum_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi, bin_size);
#line 72
    xfree((void *)buf___1);
#line 73
    return (-1);
  }
#line 77
  put_u16((void *)(msg), (unsigned short )bits);
#line 78
  buffer_append(buffer, (void const   *)(msg), 2U);
#line 80
  buffer_append(buffer, (void const   *)buf___1, (unsigned int )oi);
#line 82
  memset((void *)buf___1, 0, (unsigned int )bin_size);
#line 83
  xfree((void *)buf___1);
#line 85
  return (0);
}
}
#line 88 "bufbn.c"
void buffer_put_bignum(Buffer *buffer , BIGNUM const   *value ) 
{ int tmp ;

  {
#line 91
  tmp = buffer_put_bignum_ret(buffer, value);
#line 91
  if (tmp == -1) {
#line 92
    fatal("buffer_put_bignum: buffer error");
  }
#line 93
  return;
}
}
#line 98 "bufbn.c"
int buffer_get_bignum_ret(Buffer *buffer , BIGNUM *value ) 
{ u_int bits ;
  u_int bytes ;
  u_char buf___1[2] ;
  u_char *bin ;
  int tmp ;
  u_int16_t tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  BIGNUM *tmp___3 ;
  int tmp___4 ;

  {
#line 105
  tmp = buffer_get_ret(buffer, (void *)((char *)(buf___1)), 2U);
#line 105
  if (tmp == -1) {
#line 106
    error("buffer_get_bignum_ret: invalid length");
#line 107
    return (-1);
  }
#line 109
  tmp___0 = get_u16((void const   *)(buf___1));
#line 109
  bits = (unsigned int )tmp___0;
#line 111
  bytes = (bits + 7U) / 8U;
#line 112
  if (bytes > 8192U) {
#line 113
    error("buffer_get_bignum_ret: cannot handle BN of size %d", bytes);
#line 114
    return (-1);
  }
#line 116
  tmp___1 = buffer_len(buffer);
#line 116
  if (tmp___1 < bytes) {
#line 117
    error("buffer_get_bignum_ret: input buffer too small");
#line 118
    return (-1);
  }
#line 120
  tmp___2 = buffer_ptr(buffer);
#line 120
  bin = (u_char *)tmp___2;
#line 121
  tmp___3 = BN_bin2bn((unsigned char const   *)bin, (int )bytes, value);
#line 121
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 122
    error("buffer_get_bignum_ret: BN_bin2bn failed");
#line 123
    return (-1);
  }
#line 125
  tmp___4 = buffer_consume_ret(buffer, bytes);
#line 125
  if (tmp___4 == -1) {
#line 126
    error("buffer_get_bignum_ret: buffer_consume failed");
#line 127
    return (-1);
  }
#line 129
  return (0);
}
}
#line 132 "bufbn.c"
void buffer_get_bignum(Buffer *buffer , BIGNUM *value ) 
{ int tmp ;

  {
#line 135
  tmp = buffer_get_bignum_ret(buffer, value);
#line 135
  if (tmp == -1) {
#line 136
    fatal("buffer_get_bignum: buffer error");
  }
#line 137
  return;
}
}
#line 142 "bufbn.c"
int buffer_put_bignum2_ret(Buffer *buffer , BIGNUM const   *value ) 
{ u_int bytes ;
  u_char *buf___1 ;
  int oi ;
  u_int hasnohigh ;
  int tmp ;
  void *tmp___0 ;

  {
#line 148
  hasnohigh = (u_int )0;
#line 150
  if (value->top == 0) {
#line 151
    buffer_put_int(buffer, 0U);
#line 152
    return (0);
  }
#line 154
  if (value->neg) {
#line 155
    error("buffer_put_bignum2_ret: negative numbers not supported");
#line 156
    return (-1);
  }
#line 158
  tmp = BN_num_bits(value);
#line 158
  bytes = (unsigned int )((tmp + 7) / 8 + 1);
#line 159
  if (bytes < 2U) {
#line 160
    error("buffer_put_bignum2_ret: BN too small");
#line 161
    return (-1);
  }
#line 163
  tmp___0 = xmalloc(bytes);
#line 163
  buf___1 = (u_char *)tmp___0;
#line 164
  *(buf___1 + 0) = (unsigned char)0;
#line 166
  oi = BN_bn2bin(value, buf___1 + 1);
#line 167
  if (oi < 0) {
#line 168
    error("buffer_put_bignum2_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi,
          bytes);
#line 170
    xfree((void *)buf___1);
#line 171
    return (-1);
  } else {
#line 167
    if ((unsigned int )oi != bytes - 1U) {
#line 168
      error("buffer_put_bignum2_ret: BN_bn2bin() failed: oi %d != bin_size %d", oi,
            bytes);
#line 170
      xfree((void *)buf___1);
#line 171
      return (-1);
    }
  }
#line 173
  if ((int )*(buf___1 + 1) & 128) {
#line 173
    hasnohigh = 0U;
  } else {
#line 173
    hasnohigh = 1U;
  }
#line 174
  buffer_put_string(buffer, (void const   *)(buf___1 + hasnohigh), bytes - hasnohigh);
#line 175
  memset((void *)buf___1, 0, bytes);
#line 176
  xfree((void *)buf___1);
#line 177
  return (0);
}
}
#line 180 "bufbn.c"
void buffer_put_bignum2(Buffer *buffer , BIGNUM const   *value ) 
{ int tmp ;

  {
#line 183
  tmp = buffer_put_bignum2_ret(buffer, value);
#line 183
  if (tmp == -1) {
#line 184
    fatal("buffer_put_bignum2: buffer error");
  }
#line 185
  return;
}
}
#line 187 "bufbn.c"
int buffer_get_bignum2_ret(Buffer *buffer , BIGNUM *value ) 
{ u_int len ;
  u_char *bin ;
  void *tmp ;
  BIGNUM *tmp___0 ;

  {
#line 193
  tmp = buffer_get_string_ret(buffer, & len);
#line 193
  bin = (u_char *)tmp;
#line 193
  if ((unsigned int )bin == (unsigned int )((void *)0)) {
#line 194
    error("buffer_get_bignum2_ret: invalid bignum");
#line 195
    return (-1);
  }
#line 198
  if (len > 0U) {
#line 198
    if ((int )*(bin + 0) & 128) {
#line 199
      error("buffer_get_bignum2_ret: negative numbers not supported");
#line 200
      xfree((void *)bin);
#line 201
      return (-1);
    }
  }
#line 203
  if (len > 8192U) {
#line 204
    error("buffer_get_bignum2_ret: cannot handle BN of size %d", len);
#line 206
    xfree((void *)bin);
#line 207
    return (-1);
  }
#line 209
  tmp___0 = BN_bin2bn((unsigned char const   *)bin, (int )len, value);
#line 209
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 210
    error("buffer_get_bignum2_ret: BN_bin2bn failed");
#line 211
    xfree((void *)bin);
#line 212
    return (-1);
  }
#line 214
  xfree((void *)bin);
#line 215
  return (0);
}
}
#line 218 "bufbn.c"
void buffer_get_bignum2(Buffer *buffer , BIGNUM *value ) 
{ int tmp ;

  {
#line 221
  tmp = buffer_get_bignum2_ret(buffer, value);
#line 221
  if (tmp == -1) {
#line 222
    fatal("buffer_get_bignum2: buffer error");
  }
#line 223
  return;
}
}
#line 1 "buffer.o"
#line 36 "buffer.h"
int buffer_check_alloc(Buffer *buffer , u_int len ) ;
#line 38
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) ;
#line 40
void buffer_consume(Buffer *buffer , u_int bytes ) ;
#line 41
void buffer_consume_end(Buffer *buffer , u_int bytes ) ;
#line 43
void buffer_dump(Buffer *buffer ) ;
#line 47
int buffer_consume_end_ret(Buffer *buffer , u_int bytes ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 21 "xmalloc.h"
void *xrealloc(void *ptr , size_t nmemb , size_t size ) ;
#line 33 "buffer.c"
void buffer_init(Buffer *buffer ) 
{ u_int len ;
  void *tmp ;

  {
#line 36
  len = (u_int )4096;
#line 38
  buffer->alloc = 0U;
#line 39
  tmp = xmalloc(len);
#line 39
  buffer->buf = (u_char *)tmp;
#line 40
  buffer->alloc = len;
#line 41
  buffer->offset = 0U;
#line 42
  buffer->end = 0U;
#line 43
  return;
}
}
#line 47 "buffer.c"
void buffer_free(Buffer *buffer ) 
{ 

  {
#line 50
  if (buffer->alloc > 0U) {
#line 51
    memset((void *)buffer->buf, 0, buffer->alloc);
#line 52
    buffer->alloc = 0U;
#line 53
    xfree((void *)buffer->buf);
  }
#line 55
  return;
}
}
#line 62 "buffer.c"
void buffer_clear(Buffer *buffer ) 
{ 

  {
#line 65
  buffer->offset = 0U;
#line 66
  buffer->end = 0U;
#line 67
  return;
}
}
#line 71 "buffer.c"
void buffer_append(Buffer *buffer , void const   *data , u_int len ) 
{ void *p ;

  {
#line 75
  p = buffer_append_space(buffer, len);
#line 76
  memcpy((void * __restrict  )p, (void const   * __restrict  )data, len);
#line 77
  return;
}
}
#line 79 "buffer.c"
static int buffer_compact(Buffer *buffer ) 
{ u_int tmp ;

  {
#line 86
  if (buffer->alloc < 1048576U) {
#line 86
    tmp = buffer->alloc;
  } else {
#line 86
    tmp = 1048576U;
  }
#line 86
  if (buffer->offset > tmp) {
#line 87
    memmove((void *)buffer->buf, (void const   *)(buffer->buf + buffer->offset), buffer->end - buffer->offset);
#line 89
    buffer->end -= buffer->offset;
#line 90
    buffer->offset = 0U;
#line 91
    return (1);
  }
#line 93
  return (0);
}
}
#line 102 "buffer.c"
void *buffer_append_space(Buffer *buffer , u_int len ) 
{ u_int newlen ;
  void *p ;
  int tmp ;
  void *tmp___0 ;

  {
#line 108
  if (len > 1048576U) {
#line 109
    fatal("buffer_append_space: len %u not supported", len);
  }
#line 112
  if (buffer->offset == buffer->end) {
#line 113
    buffer->offset = 0U;
#line 114
    buffer->end = 0U;
  }
  restart: 
#line 118
  if (buffer->end + len < buffer->alloc) {
#line 119
    p = (void *)(buffer->buf + buffer->end);
#line 120
    buffer->end += len;
#line 121
    return (p);
  }
#line 125
  tmp = buffer_compact(buffer);
#line 125
  if (tmp) {
    goto restart;
  }
#line 129
  newlen = (((buffer->alloc + len) + 32768U) - 1U) & 4294934528U;
#line 130
  if (newlen > 10485760U) {
#line 131
    fatal("buffer_append_space: alloc %u not supported", newlen);
  }
#line 133
  tmp___0 = xrealloc((void *)buffer->buf, 1U, newlen);
#line 133
  buffer->buf = (u_char *)tmp___0;
#line 134
  buffer->alloc = newlen;
  goto restart;
}
}
#line 143 "buffer.c"
int buffer_check_alloc(Buffer *buffer , u_int len ) 
{ int tmp ;

  {
#line 146
  if (buffer->offset == buffer->end) {
#line 147
    buffer->offset = 0U;
#line 148
    buffer->end = 0U;
  }
  restart: 
#line 151
  if (buffer->end + len < buffer->alloc) {
#line 152
    return (1);
  }
#line 153
  tmp = buffer_compact(buffer);
#line 153
  if (tmp) {
    goto restart;
  }
#line 155
  if (((((buffer->alloc + len) + 32768U) - 1U) & 4294934528U) <= 10485760U) {
#line 156
    return (1);
  }
#line 157
  return (0);
}
}
#line 162 "buffer.c"
u_int buffer_len(Buffer *buffer ) 
{ 

  {
#line 165
  return (buffer->end - buffer->offset);
}
}
#line 170 "buffer.c"
int buffer_get_ret(Buffer *buffer , void *buf___1 , u_int len ) 
{ 

  {
#line 173
  if (len > buffer->end - buffer->offset) {
#line 174
    error("buffer_get_ret: trying to get more bytes %d than in buffer %d", len, buffer->end - buffer->offset);
#line 176
    return (-1);
  }
#line 178
  memcpy((void * __restrict  )buf___1, (void const   * __restrict  )(buffer->buf + buffer->offset),
         len);
#line 179
  buffer->offset += len;
#line 180
  return (0);
}
}
#line 183 "buffer.c"
void buffer_get(Buffer *buffer , void *buf___1 , u_int len ) 
{ int tmp ;

  {
#line 186
  tmp = buffer_get_ret(buffer, buf___1, len);
#line 186
  if (tmp == -1) {
#line 187
    fatal("buffer_get: buffer error");
  }
#line 188
  return;
}
}
#line 192 "buffer.c"
int buffer_consume_ret(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 195
  if (bytes > buffer->end - buffer->offset) {
#line 196
    error("buffer_consume_ret: trying to get more bytes than in buffer");
#line 197
    return (-1);
  }
#line 199
  buffer->offset += bytes;
#line 200
  return (0);
}
}
#line 203 "buffer.c"
void buffer_consume(Buffer *buffer , u_int bytes ) 
{ int tmp ;

  {
#line 206
  tmp = buffer_consume_ret(buffer, bytes);
#line 206
  if (tmp == -1) {
#line 207
    fatal("buffer_consume: buffer error");
  }
#line 208
  return;
}
}
#line 212 "buffer.c"
int buffer_consume_end_ret(Buffer *buffer , u_int bytes ) 
{ 

  {
#line 215
  if (bytes > buffer->end - buffer->offset) {
#line 216
    return (-1);
  }
#line 217
  buffer->end -= bytes;
#line 218
  return (0);
}
}
#line 221 "buffer.c"
void buffer_consume_end(Buffer *buffer , u_int bytes ) 
{ int tmp ;

  {
#line 224
  tmp = buffer_consume_end_ret(buffer, bytes);
#line 224
  if (tmp == -1) {
#line 225
    fatal("buffer_consume_end: trying to get more bytes than in buffer");
  }
#line 226
  return;
}
}
#line 230 "buffer.c"
void *buffer_ptr(Buffer *buffer ) 
{ 

  {
#line 233
  return ((void *)(buffer->buf + buffer->offset));
}
}
#line 238 "buffer.c"
void buffer_dump(Buffer *buffer ) 
{ u_int i ;
  u_char *ucp ;

  {
#line 242
  ucp = buffer->buf;
#line 244
  i = buffer->offset;
#line 244
  while (i < buffer->end) {
#line 245
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%02x", *(ucp + i));
#line 246
    if ((i - buffer->offset) % 16U == 15U) {
#line 247
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
    } else {
#line 248
      if ((i - buffer->offset) % 2U == 1U) {
#line 249
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" ");
      }
    }
#line 244
    i ++;
  }
#line 251
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\r\n");
#line 252
  return;
}
}
#line 1 "canohost.o"
#line 128 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 352 "/usr/include/netdb.h"
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 25 "packet.h"
int packet_get_connection_in(void) ;
#line 79
int packet_connection_is_on_socket(void) ;
#line 64 "log.h"
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 15 "canohost.h"
char const   *get_canonical_hostname(int use_dns ) ;
#line 16
char const   *get_remote_ipaddr(void) ;
#line 17
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) ;
#line 19
char *get_peer_ipaddr(int sock ) ;
#line 20
int get_peer_port(int sock ) ;
#line 21
char *get_local_ipaddr(int sock ) ;
#line 22
char *get_local_name(int sock ) ;
#line 24
int get_remote_port(void) ;
#line 25
int get_local_port(void) ;
#line 27
void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) ;
#line 38 "misc.h"
char const   *ssh_gai_strerror(int gaierr ) ;
#line 37 "canohost.c"
static void check_ip_options(int sock , char *ipaddr ) ;
#line 44 "canohost.c"
static char *get_remote_hostname(int sock , int use_dns ) 
{ struct sockaddr_storage from ;
  int i ;
  socklen_t fromlen ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char name[1025] ;
  char ntop[1025] ;
  char ntop2[1025] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int __res ;
  __int32_t const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
#line 54
  fromlen = sizeof(from);
#line 55
  memset((void *)(& from), 0, sizeof(from));
#line 56
  tmp___1 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 56
  if (tmp___1 < 0) {
#line 57
    tmp = __errno_location();
#line 57
    tmp___0 = strerror(*tmp);
#line 57
    debug("getpeername failed: %.100s", tmp___0);
#line 58
    cleanup_exit(255);
  }
#line 61
  if ((int )from.ss_family == 2) {
#line 62
    check_ip_options(sock, ntop);
  }
#line 64
  ipv64_normalise_mapped(& from, & fromlen);
#line 66
  if ((int )from.ss_family == 10) {
#line 67
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 69
  tmp___2 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                        0U, 1U);
#line 69
  if (tmp___2 != 0) {
#line 71
    fatal("get_remote_hostname: getnameinfo NI_NUMERICHOST failed");
  }
#line 73
  if (! use_dns) {
#line 74
    tmp___3 = xstrdup((char const   *)(ntop));
#line 74
    return (tmp___3);
  }
#line 76
  debug3("Trying to reverse map address %.100s.", ntop);
#line 78
  tmp___5 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                        fromlen, (char * __restrict  )(name), sizeof(name), (char * __restrict  )((void *)0),
                        0U, 8U);
#line 78
  if (tmp___5 != 0) {
#line 81
    tmp___4 = xstrdup((char const   *)(ntop));
#line 81
    return (tmp___4);
  }
#line 89
  memset((void *)(& hints), 0, sizeof(hints));
#line 90
  hints.ai_socktype = 2;
#line 91
  hints.ai_flags = 4;
#line 92
  tmp___7 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )"0",
                        (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 92
  if (tmp___7 == 0) {
#line 93
    logit("Nasty PTR record \"%s\" is set up for %s, ignoring", name, ntop);
#line 95
    freeaddrinfo(ai);
#line 96
    tmp___6 = xstrdup((char const   *)(ntop));
#line 96
    return (tmp___6);
  }
#line 103
  i = 0;
#line 103
  while (name[i]) {
#line 104
    tmp___11 = __ctype_b_loc();
#line 104
    if ((int const   )*(*tmp___11 + (int )name[i]) & 256) {
#line 105
      if (sizeof(name[i]) > 1U) {
#line 105
        __res = tolower((int )name[i]);
      } else {
#line 105
        tmp___10 = __ctype_tolower_loc();
#line 105
        __res = (int )*(*tmp___10 + (int )name[i]);
      }
#line 105
      name[i] = (char )__res;
    }
#line 103
    i ++;
  }
#line 115
  memset((void *)(& hints), 0, sizeof(hints));
#line 116
  hints.ai_family = (int )from.ss_family;
#line 117
  hints.ai_socktype = 1;
#line 118
  tmp___13 = getaddrinfo((char const   * __restrict  )(name), (char const   * __restrict  )((void *)0),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 118
  if (tmp___13 != 0) {
#line 119
    logit("reverse mapping checking getaddrinfo for %.700s [%s] failed - POSSIBLE BREAK-IN ATTEMPT!",
          name, ntop);
#line 121
    tmp___12 = xstrdup((char const   *)(ntop));
#line 121
    return (tmp___12);
  }
#line 124
  ai = aitop;
#line 124
  while (ai) {
#line 125
    tmp___14 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop2), sizeof(ntop2), (char * __restrict  )((void *)0),
                           0U, 1U);
#line 127
    if (tmp___14 == 0) {
#line 127
      if (0) {
#line 127
        __s1_len = strlen((char const   *)(ntop));
#line 127
        __s2_len = strlen((char const   *)(ntop2));
#line 127
        if (! ((unsigned int )((void const   *)(ntop + 1)) - (unsigned int )((void const   *)(ntop)) == 1U)) {
          goto _L___0;
        } else {
#line 127
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 127
            if (! ((unsigned int )((void const   *)(ntop2 + 1)) - (unsigned int )((void const   *)(ntop2)) == 1U)) {
#line 127
              tmp___24 = 1;
            } else {
#line 127
              if (__s2_len >= 4U) {
#line 127
                tmp___24 = 1;
              } else {
#line 127
                tmp___24 = 0;
              }
            }
          } else {
#line 127
            tmp___24 = 0;
          }
        }
#line 127
        if (tmp___24) {
#line 127
          tmp___20 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
        } else {
#line 127
          tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 127
          tmp___20 = tmp___23;
        }
      } else {
#line 127
        tmp___23 = __builtin_strcmp((char const   *)(ntop), (char const   *)(ntop2));
#line 127
        tmp___20 = tmp___23;
      }
#line 127
      if (tmp___20 == 0) {
#line 128
        break;
      }
    }
#line 124
    ai = ai->ai_next;
  }
#line 130
  freeaddrinfo(aitop);
#line 132
  if (! ai) {
#line 134
    logit("Address %.100s maps to %.600s, but this does not map back to the address - POSSIBLE BREAK-IN ATTEMPT!",
          ntop, name);
#line 137
    tmp___25 = xstrdup((char const   *)(ntop));
#line 137
    return (tmp___25);
  }
#line 139
  tmp___26 = xstrdup((char const   *)(name));
#line 139
  return (tmp___26);
}
}
#line 154 "canohost.c"
static void check_ip_options(int sock , char *ipaddr ) 
{ u_char options___0[200] ;
  char text[sizeof(options___0) * 3U + 1U] ;
  socklen_t option_size ;
  u_int i ;
  int ipproto ;
  struct protoent *ip ;
  int tmp ;

  {
#line 165
  ip = getprotobyname("ip");
#line 165
  if ((unsigned int )ip != (unsigned int )((void *)0)) {
#line 166
    ipproto = ip->p_proto;
  } else {
#line 168
    ipproto = 0;
  }
#line 169
  option_size = sizeof(options___0);
#line 170
  tmp = getsockopt(sock, ipproto, 4, (void * __restrict  )(options___0), (socklen_t * __restrict  )(& option_size));
#line 170
  if (tmp >= 0) {
#line 170
    if (option_size != 0U) {
#line 172
      text[0] = (char )'\000';
#line 173
      i = 0U;
#line 173
      while (i < option_size) {
#line 174
        snprintf((char * __restrict  )(text + i * 3U), sizeof(text) - i * 3U, (char const   * __restrict  )" %2.2x",
                 options___0[i]);
#line 173
        i ++;
      }
#line 176
      fatal("Connection from %.100s with IP options:%.800s", ipaddr, text);
    }
  }
#line 180
  return;
}
}
#line 182 "canohost.c"
void ipv64_normalise_mapped(struct sockaddr_storage *addr , socklen_t *len ) 
{ struct sockaddr_in6 *a6 ;
  struct sockaddr_in *a4 ;
  struct in_addr inaddr ;
  u_int16_t port___0 ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 185
  a6 = (struct sockaddr_in6 *)addr;
#line 186
  a4 = (struct sockaddr_in *)addr;
#line 191
  if ((int )addr->ss_family != 10) {
#line 192
    return;
  } else {
#line 191
    if (*((uint32_t const   *)(& a6->sin6_addr) + 0) == 0U) {
#line 191
      if (*((uint32_t const   *)(& a6->sin6_addr) + 1) == 0U) {
#line 191
        __x = 65535U;
#line 191
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 191
        if (! (*((uint32_t const   *)(& a6->sin6_addr) + 2) == (uint32_t const   )__v)) {
#line 192
          return;
        }
      } else {
#line 192
        return;
      }
    } else {
#line 192
      return;
    }
  }
#line 194
  debug3("Normalising mapped IPv4 in IPv6 address");
#line 196
  memcpy((void * __restrict  )(& inaddr), (void const   * __restrict  )((char *)(& a6->sin6_addr) + 12),
         sizeof(inaddr));
#line 197
  port___0 = a6->sin6_port;
#line 199
  memset((void *)addr, 0, sizeof(*a4));
#line 201
  a4->sin_family = (unsigned short)2;
#line 202
  *len = sizeof(*a4);
#line 203
  memcpy((void * __restrict  )(& a4->sin_addr), (void const   * __restrict  )(& inaddr),
         sizeof(inaddr));
#line 204
  a4->sin_port = port___0;
#line 205
  return;
}
}
#line 217 "canohost.c"
static char *canonical_host_name  =    (char *)((void *)0);
#line 218 "canohost.c"
static char *remote_ip  =    (char *)((void *)0);
#line 213 "canohost.c"
char const   *get_canonical_hostname(int use_dns ) 
{ char *host ;
  int tmp ;
  int tmp___0 ;

  {
#line 221
  if (use_dns) {
#line 221
    if ((unsigned int )canonical_host_name != (unsigned int )((void *)0)) {
#line 222
      return ((char const   *)canonical_host_name);
    }
  }
#line 223
  if (! use_dns) {
#line 223
    if ((unsigned int )remote_ip != (unsigned int )((void *)0)) {
#line 224
      return ((char const   *)remote_ip);
    }
  }
#line 227
  tmp___0 = packet_connection_is_on_socket();
#line 227
  if (tmp___0) {
#line 228
    tmp = packet_get_connection_in();
#line 228
    host = get_remote_hostname(tmp, use_dns);
  } else {
#line 230
    host = (char *)"UNKNOWN";
  }
#line 232
  if (use_dns) {
#line 233
    canonical_host_name = host;
  } else {
#line 235
    remote_ip = host;
  }
#line 236
  return ((char const   *)host);
}
}
#line 243 "canohost.c"
static char *get_socket_address(int sock , int remote___0 , int flags ) 
{ struct sockaddr_storage addr ;
  socklen_t addrlen ;
  char ntop[1025] ;
  int r ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 252
  addrlen = sizeof(addr);
#line 253
  memset((void *)(& addr), 0, sizeof(addr));
#line 255
  if (remote___0) {
#line 256
    tmp = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                      (socklen_t * __restrict  )(& addrlen));
#line 256
    if (tmp < 0) {
#line 258
      return ((char *)((void *)0));
    }
  } else {
#line 260
    tmp___0 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                          (socklen_t * __restrict  )(& addrlen));
#line 260
    if (tmp___0 < 0) {
#line 262
      return ((char *)((void *)0));
    }
  }
#line 266
  if ((int )addr.ss_family == 10) {
#line 267
    addrlen = sizeof(struct sockaddr_in6 );
  }
#line 269
  ipv64_normalise_mapped(& addr, & addrlen);
#line 272
  r = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                  addrlen, (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )((void *)0),
                  0U, (unsigned int )flags);
#line 272
  if (r != 0) {
#line 274
    tmp___1 = ssh_gai_strerror(r);
#line 274
    error("get_socket_address: getnameinfo %d failed: %s", flags, tmp___1);
#line 276
    return ((char *)((void *)0));
  }
#line 278
  tmp___2 = xstrdup((char const   *)(ntop));
#line 278
  return (tmp___2);
}
}
#line 281 "canohost.c"
char *get_peer_ipaddr(int sock ) 
{ char *p ;
  char *tmp ;

  {
#line 286
  p = get_socket_address(sock, 1, 1);
#line 286
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 287
    return (p);
  }
#line 288
  tmp = xstrdup("UNKNOWN");
#line 288
  return (tmp);
}
}
#line 291 "canohost.c"
char *get_local_ipaddr(int sock ) 
{ char *p ;
  char *tmp ;

  {
#line 296
  p = get_socket_address(sock, 0, 1);
#line 296
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 297
    return (p);
  }
#line 298
  tmp = xstrdup("UNKNOWN");
#line 298
  return (tmp);
}
}
#line 301 "canohost.c"
char *get_local_name(int sock ) 
{ char *tmp ;

  {
#line 304
  tmp = get_socket_address(sock, 0, 8);
#line 304
  return (tmp);
}
}
#line 315 "canohost.c"
static char *canonical_host_ip  =    (char *)((void *)0);
#line 312 "canohost.c"
char const   *get_remote_ipaddr(void) 
{ int tmp ;
  int tmp___0 ;

  {
#line 318
  if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 319
    tmp___0 = packet_connection_is_on_socket();
#line 319
    if (tmp___0) {
#line 320
      tmp = packet_get_connection_in();
#line 320
      canonical_host_ip = get_peer_ipaddr(tmp);
#line 322
      if ((unsigned int )canonical_host_ip == (unsigned int )((void *)0)) {
#line 323
        cleanup_exit(255);
      }
    } else {
#line 326
      canonical_host_ip = xstrdup("UNKNOWN");
    }
  }
#line 329
  return ((char const   *)canonical_host_ip);
}
}
#line 335 "canohost.c"
static char const   *remote  =    "";
#line 332 "canohost.c"
char const   *get_remote_name_or_ip(u_int utmp_len___0 , int use_dns ) 
{ size_t tmp ;

  {
#line 336
  if (utmp_len___0 > 0U) {
#line 337
    remote = get_canonical_hostname(use_dns);
  }
#line 338
  if (utmp_len___0 == 0U) {
#line 339
    remote = get_remote_ipaddr();
  } else {
#line 338
    tmp = strlen(remote);
#line 338
    if (tmp > utmp_len___0) {
#line 339
      remote = get_remote_ipaddr();
    }
  }
#line 340
  return (remote);
}
}
#line 345 "canohost.c"
static int get_sock_port(int sock , int local ) 
{ struct sockaddr_storage from ;
  socklen_t fromlen ;
  char strport[32] ;
  int r ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 354
  fromlen = sizeof(from);
#line 355
  memset((void *)(& from), 0, sizeof(from));
#line 356
  if (local) {
#line 357
    tmp___1 = getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 357
    if (tmp___1 < 0) {
#line 358
      tmp = __errno_location();
#line 358
      tmp___0 = strerror(*tmp);
#line 358
      error("getsockname failed: %.100s", tmp___0);
#line 359
      return (0);
    }
  } else {
#line 362
    tmp___4 = getpeername(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 362
    if (tmp___4 < 0) {
#line 363
      tmp___2 = __errno_location();
#line 363
      tmp___3 = strerror(*tmp___2);
#line 363
      debug("getpeername failed: %.100s", tmp___3);
#line 364
      return (-1);
    }
  }
#line 369
  if ((int )from.ss_family == 10) {
#line 370
    fromlen = sizeof(struct sockaddr_in6 );
  }
#line 373
  r = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& from)),
                  fromlen, (char * __restrict  )((void *)0), 0U, (char * __restrict  )(strport),
                  sizeof(strport), 2U);
#line 373
  if (r != 0) {
#line 375
    tmp___5 = ssh_gai_strerror(r);
#line 375
    fatal("get_sock_port: getnameinfo NI_NUMERICSERV failed: %s", tmp___5);
  }
#line 377
  tmp___6 = atoi((char const   *)(strport));
#line 377
  return (tmp___6);
}
}
#line 382 "canohost.c"
static int get_port(int local ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 389
  tmp = packet_connection_is_on_socket();
#line 389
  if (! tmp) {
#line 390
    return (65535);
  }
#line 393
  tmp___0 = packet_get_connection_in();
#line 393
  tmp___1 = get_sock_port(tmp___0, local);
#line 393
  return (tmp___1);
}
}
#line 396 "canohost.c"
int get_peer_port(int sock ) 
{ int tmp ;

  {
#line 399
  tmp = get_sock_port(sock, 0);
#line 399
  return (tmp);
}
}
#line 405 "canohost.c"
static int port  =    -1;
#line 402 "canohost.c"
int get_remote_port(void) 
{ 

  {
#line 408
  if (port == -1) {
#line 409
    port = get_port(0);
  }
#line 411
  return (port);
}
}
#line 414 "canohost.c"
int get_local_port(void) 
{ int tmp ;

  {
#line 417
  tmp = get_port(1);
#line 417
  return (tmp);
}
}
#line 1 "channels.o"
#line 192 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 407 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 65
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
#line 745 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 20 "xmalloc.h"
void *xcalloc(size_t nmemb , size_t size ) ;
#line 31 "packet.h"
u_int packet_get_protocol_flags(void) ;
#line 34
int packet_is_interactive(void) ;
#line 38
void packet_start(u_char type ) ;
#line 39
void packet_put_char(int value ) ;
#line 40
void packet_put_int(u_int value ) ;
#line 43
void packet_put_string(void const   *buf___1 , u_int len ) ;
#line 44
void packet_put_cstring(char const   *str ) ;
#line 46
void packet_send(void) ;
#line 48
int packet_read(void) ;
#line 56
u_int packet_get_int(void) ;
#line 60
void *packet_get_string(u_int *length_ptr ) ;
#line 61
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 75
void packet_write_wait(void) ;
#line 81
int packet_remaining(void) ;
#line 82
void packet_send_ignore(int nbytes ) ;
#line 88
u_int max_packet_size ;
#line 58 "log.h"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) ;
#line 60
void ( /* format attribute */  debug2)(char const   *fmt  , ...) ;
#line 22 "misc.h"
int set_nonblock(int fd ) ;
#line 24
void set_nodelay(int fd ) ;
#line 34
char *tohex(void const   *vp , size_t l ) ;
#line 162 "channels.h"
Channel *channel_by_id(int id ) ;
#line 163
Channel *channel_lookup(int id ) ;
#line 164
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) ;
#line 165
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) ;
#line 166
void channel_free(Channel *c ) ;
#line 167
void channel_free_all(void) ;
#line 168
void channel_stop_listening(void) ;
#line 170
void channel_send_open(int id ) ;
#line 171
void channel_request_start(int id , char *service , int wantconfirm ) ;
#line 172
void channel_register_cleanup(int id , channel_callback_fn *fn , int do_close ) ;
#line 173
void channel_register_confirm(int id , channel_callback_fn *fn , void *ctx ) ;
#line 174
void channel_register_filter(int id , channel_infilter_fn *ifn , channel_outfilter_fn *ofn ) ;
#line 175
void channel_cancel_cleanup(int id ) ;
#line 176
int channel_close_fd(int *fdp ) ;
#line 177
void channel_send_window_changes(void) ;
#line 181
void channel_input_close(int type , u_int32_t seq , void *ctxt ) ;
#line 182
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 183
void channel_input_data(int type , u_int32_t seq , void *ctxt ) ;
#line 184
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) ;
#line 185
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) ;
#line 186
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) ;
#line 187
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) ;
#line 188
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) ;
#line 189
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) ;
#line 190
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) ;
#line 194
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            u_int *nallocp , int rekeying___0 ) ;
#line 195
void channel_after_select(fd_set *readset , fd_set *writeset ) ;
#line 196
void channel_output_poll(void) ;
#line 198
int channel_not_very_much_buffered_data(void) ;
#line 199
void channel_close_all(void) ;
#line 200
int channel_still_open(void) ;
#line 201
char *channel_open_message(void) ;
#line 202
int channel_find_open(void) ;
#line 205
void channel_set_af(int af ) ;
#line 206
void channel_permit_all_opens(void) ;
#line 207
void channel_add_permitted_opens(char *host , int port___0 ) ;
#line 208
int channel_add_adm_permitted_opens(char *host , int port___0 ) ;
#line 209
void channel_clear_permitted_opens(void) ;
#line 210
void channel_clear_adm_permitted_opens(void) ;
#line 211
int channel_input_port_forward_request(int is_root , int gateway_ports ) ;
#line 212
int channel_connect_to(char const   *host , u_short port___0 ) ;
#line 213
int channel_connect_by_listen_address(u_short listen_port ) ;
#line 214
int channel_request_remote_forwarding(char const   *listen_host , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ) ;
#line 216
int channel_setup_local_fwd_listener(char const   *listen_host , u_short listen_port ,
                                     char const   *host_to_connect , u_short port_to_connect ,
                                     int gateway_ports ) ;
#line 218
void channel_request_rforward_cancel(char const   *host , u_short port___0 ) ;
#line 219
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) ;
#line 220
int channel_cancel_rport_listener(char const   *host , u_short port___0 ) ;
#line 224
int x11_connect_display(void) ;
#line 225
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp , int **chanids ) ;
#line 226
void x11_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 227
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *disp ,
                                          char const   *proto , char const   *data ) ;
#line 229
void deny_input_open(int type , u_int32_t seq , void *ctxt ) ;
#line 233
void auth_request_forwarding(void) ;
#line 237
int chan_is_dead(Channel *c , int do_send ) ;
#line 238
void chan_mark_dead(Channel *c ) ;
#line 242
void chan_rcvd_oclose(Channel *c ) ;
#line 243
void chan_read_failed(Channel *c ) ;
#line 244
void chan_ibuf_empty(Channel *c ) ;
#line 246
void chan_rcvd_ieof(Channel *c ) ;
#line 247
void chan_write_failed(Channel *c ) ;
#line 248
void chan_obuf_empty(Channel *c ) ;
#line 67 "compat.h"
int compat13 ;
#line 68
int compat20 ;
#line 85 "channels.c"
static Channel **channels  =    (Channel **)((void *)0);
#line 91 "channels.c"
static u_int channels_alloc  =    (u_int )0;
#line 97 "channels.c"
static int channel_max_fd  =    0;
#line 115 "channels.c"
static ForwardPermission permitted_opens[100]  ;
#line 118 "channels.c"
static ForwardPermission permitted_adm_opens[100]  ;
#line 121 "channels.c"
static int num_permitted_opens  =    0;
#line 124 "channels.c"
static int num_adm_permitted_opens  =    0;
#line 131 "channels.c"
static int all_opens_permitted  =    0;
#line 140 "channels.c"
static char *x11_saved_display  =    (char *)((void *)0);
#line 143 "channels.c"
static char *x11_saved_proto  =    (char *)((void *)0);
#line 146 "channels.c"
static char *x11_saved_data  =    (char *)((void *)0);
#line 147 "channels.c"
static u_int x11_saved_data_len  =    (u_int )0;
#line 153 "channels.c"
static u_char *x11_fake_data  =    (u_char *)((void *)0);
#line 154 "channels.c"
static u_int x11_fake_data_len  ;
#line 162 "channels.c"
static int IPv4or6  =    0;
#line 165
static void port_open_helper(Channel *c , char *rtype ) ;
#line 169 "channels.c"
Channel *channel_by_id(int id ) 
{ Channel *c ;

  {
#line 174
  if (id < 0) {
#line 175
    logit("channel_by_id: %d: bad id", id);
#line 176
    return ((Channel *)((void *)0));
  } else {
#line 174
    if ((unsigned int )id >= channels_alloc) {
#line 175
      logit("channel_by_id: %d: bad id", id);
#line 176
      return ((Channel *)((void *)0));
    }
  }
#line 178
  c = *(channels + id);
#line 179
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 180
    logit("channel_by_id: %d: bad id: channel free", id);
#line 181
    return ((Channel *)((void *)0));
  }
#line 183
  return (c);
}
}
#line 190 "channels.c"
Channel *channel_lookup(int id ) 
{ Channel *c ;

  {
#line 195
  c = channel_by_id(id);
#line 195
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 196
    return ((Channel *)((void *)0));
  }
#line 198
  switch (c->type) {
  case 7: 
  case 10: 
  case 12: 
  case 13: 
  case 3: 
  case 4: 
  case 8: 
  case 9: 
#line 207
  return (c);
  }
#line 209
  logit("Non-public channel %d, type %d.", id, c->type);
#line 210
  return ((Channel *)((void *)0));
}
}
#line 217 "channels.c"
static void channel_register_fds(Channel *c , int rfd , int wfd , int efd , int extusage ,
                                 int nonblock ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 222
  if (channel_max_fd > rfd) {
#line 222
    channel_max_fd = channel_max_fd;
  } else {
#line 222
    channel_max_fd = rfd;
  }
#line 223
  if (channel_max_fd > wfd) {
#line 223
    channel_max_fd = channel_max_fd;
  } else {
#line 223
    channel_max_fd = wfd;
  }
#line 224
  if (channel_max_fd > efd) {
#line 224
    channel_max_fd = channel_max_fd;
  } else {
#line 224
    channel_max_fd = efd;
  }
#line 228
  c->rfd = rfd;
#line 229
  c->wfd = wfd;
#line 230
  if (rfd == wfd) {
#line 230
    c->sock = rfd;
  } else {
#line 230
    c->sock = -1;
  }
#line 231
  c->ctl_fd = -1;
#line 232
  c->efd = efd;
#line 233
  c->extended_usage = extusage;
#line 236
  if (nonblock) {
#line 236
    tmp___0 = isatty(c->rfd);
#line 236
    if (tmp___0) {
#line 237
      debug2("channel %d: rfd %d isatty", c->self, c->rfd);
#line 238
      c->isatty = 1;
#line 239
      tmp = isatty(c->wfd);
#line 239
      if (! tmp) {
#line 240
        error("channel %d: wfd %d is not a tty?", c->self, c->wfd);
      }
    } else {
#line 244
      c->isatty = 0;
    }
  } else {
#line 244
    c->isatty = 0;
  }
#line 246
  c->wfd_isatty = isatty(c->wfd);
#line 249
  if (nonblock) {
#line 250
    if (rfd != -1) {
#line 251
      set_nonblock(rfd);
    }
#line 252
    if (wfd != -1) {
#line 253
      set_nonblock(wfd);
    }
#line 254
    if (efd != -1) {
#line 255
      set_nonblock(efd);
    }
  }
#line 257
  return;
}
}
#line 263 "channels.c"
Channel *channel_new(char *ctype , int type , int rfd , int wfd , int efd , u_int window ,
                     u_int maxpack , int extusage , char *remote_name , int nonblock ) 
{ int found ;
  u_int i ;
  Channel *c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 272
  if (channels_alloc == 0U) {
#line 273
    channels_alloc = 10U;
#line 274
    tmp = xcalloc(channels_alloc, sizeof(Channel *));
#line 274
    channels = (Channel **)tmp;
#line 275
    i = 0U;
#line 275
    while (i < channels_alloc) {
#line 276
      *(channels + i) = (Channel *)((void *)0);
#line 275
      i ++;
    }
  }
#line 279
  found = -1;
#line 279
  i = 0U;
#line 279
  while (i < channels_alloc) {
#line 280
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
#line 282
      found = (int )i;
#line 283
      break;
    }
#line 279
    i ++;
  }
#line 285
  if (found < 0) {
#line 287
    found = (int )channels_alloc;
#line 288
    if (channels_alloc > 10000U) {
#line 289
      fatal("channel_new: internal error: channels_alloc %d too big.", channels_alloc);
    }
#line 291
    tmp___0 = xrealloc((void *)channels, channels_alloc + 10U, sizeof(Channel *));
#line 291
    channels = (Channel **)tmp___0;
#line 293
    channels_alloc += 10U;
#line 294
    debug2("channel: expanding %d", channels_alloc);
#line 295
    i = (unsigned int )found;
#line 295
    while (i < channels_alloc) {
#line 296
      *(channels + i) = (Channel *)((void *)0);
#line 295
      i ++;
    }
  }
#line 299
  tmp___1 = xcalloc(1U, sizeof(Channel ));
#line 299
  *(channels + found) = (Channel *)tmp___1;
#line 299
  c = *(channels + found);
#line 300
  buffer_init(& c->input);
#line 301
  buffer_init(& c->output);
#line 302
  buffer_init(& c->extended);
#line 303
  c->ostate = 0U;
#line 304
  c->istate = 0U;
#line 305
  c->flags = 0;
#line 306
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 307
  c->self = found;
#line 308
  c->type = type;
#line 309
  c->ctype = ctype;
#line 310
  c->local_window = window;
#line 311
  c->local_window_max = window;
#line 312
  c->local_consumed = 0U;
#line 313
  c->local_maxpacket = maxpack;
#line 314
  c->remote_id = -1;
#line 315
  c->remote_name = xstrdup((char const   *)remote_name);
#line 316
  c->remote_window = 0U;
#line 317
  c->remote_maxpacket = 0U;
#line 318
  c->force_drain = 0;
#line 319
  c->single_connection = 0;
#line 320
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 321
  c->detach_close = 0;
#line 322
  c->confirm = (channel_callback_fn *)((void *)0);
#line 323
  c->confirm_ctx = (void *)0;
#line 324
  c->input_filter = (channel_infilter_fn *)((void *)0);
#line 325
  c->output_filter = (channel_outfilter_fn *)((void *)0);
#line 326
  debug("channel %d: new [%s]", found, remote_name);
#line 327
  return (c);
}
}
#line 330 "channels.c"
static int channel_find_maxfd(void) 
{ u_int i ;
  int max ;
  Channel *c ;

  {
#line 334
  max = 0;
#line 337
  i = 0U;
#line 337
  while (i < channels_alloc) {
#line 338
    c = *(channels + i);
#line 339
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 340
      if (max > c->rfd) {
#line 340
        max = max;
      } else {
#line 340
        max = c->rfd;
      }
#line 341
      if (max > c->wfd) {
#line 341
        max = max;
      } else {
#line 341
        max = c->wfd;
      }
#line 342
      if (max > c->efd) {
#line 342
        max = max;
      } else {
#line 342
        max = c->efd;
      }
    }
#line 337
    i ++;
  }
#line 345
  return (max);
}
}
#line 348 "channels.c"
int channel_close_fd(int *fdp ) 
{ int ret___0 ;
  int fd ;

  {
#line 351
  ret___0 = 0;
#line 351
  fd = *fdp;
#line 353
  if (fd != -1) {
#line 354
    ret___0 = close(fd);
#line 355
    *fdp = -1;
#line 356
    if (fd == channel_max_fd) {
#line 357
      channel_max_fd = channel_find_maxfd();
    }
  }
#line 359
  return (ret___0);
}
}
#line 363 "channels.c"
static void channel_close_fds(Channel *c ) 
{ 

  {
#line 366
  debug3("channel %d: close_fds r %d w %d e %d c %d", c->self, c->rfd, c->wfd, c->efd,
         c->ctl_fd);
#line 369
  channel_close_fd(& c->sock);
#line 370
  channel_close_fd(& c->ctl_fd);
#line 371
  channel_close_fd(& c->rfd);
#line 372
  channel_close_fd(& c->wfd);
#line 373
  channel_close_fd(& c->efd);
#line 374
  return;
}
}
#line 377 "channels.c"
void channel_free(Channel *c ) 
{ char *s ;
  u_int i ;
  u_int n___0 ;
  char const   *tmp ;

  {
#line 383
  n___0 = 0U;
#line 383
  i = 0U;
#line 383
  while (i < channels_alloc) {
#line 384
    if (*(channels + i)) {
#line 385
      n___0 ++;
    }
#line 383
    i ++;
  }
#line 386
  if (c->remote_name) {
#line 386
    tmp = (char const   *)c->remote_name;
  } else {
#line 386
    tmp = "???";
  }
#line 386
  debug("channel %d: free: %s, nchannels %u", c->self, tmp, n___0);
#line 389
  s = channel_open_message();
#line 390
  debug3("channel %d: status: %s", c->self, s);
#line 391
  xfree((void *)s);
#line 393
  if (c->sock != -1) {
#line 394
    shutdown(c->sock, 2);
  }
#line 395
  if (c->ctl_fd != -1) {
#line 396
    shutdown(c->ctl_fd, 2);
  }
#line 397
  channel_close_fds(c);
#line 398
  buffer_free(& c->input);
#line 399
  buffer_free(& c->output);
#line 400
  buffer_free(& c->extended);
#line 401
  if (c->remote_name) {
#line 402
    xfree((void *)c->remote_name);
#line 403
    c->remote_name = (char *)((void *)0);
  }
#line 405
  *(channels + c->self) = (Channel *)((void *)0);
#line 406
  xfree((void *)c);
#line 407
  return;
}
}
#line 409 "channels.c"
void channel_free_all(void) 
{ u_int i ;

  {
#line 414
  i = 0U;
#line 414
  while (i < channels_alloc) {
#line 415
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 416
      channel_free(*(channels + i));
    }
#line 414
    i ++;
  }
#line 417
  return;
}
}
#line 423 "channels.c"
void channel_close_all(void) 
{ u_int i ;

  {
#line 428
  i = 0U;
#line 428
  while (i < channels_alloc) {
#line 429
    if ((unsigned int )*(channels + i) != (unsigned int )((void *)0)) {
#line 430
      channel_close_fds(*(channels + i));
    }
#line 428
    i ++;
  }
#line 431
  return;
}
}
#line 436 "channels.c"
void channel_stop_listening(void) 
{ u_int i ;
  Channel *c ;

  {
#line 442
  i = 0U;
#line 442
  while (i < channels_alloc) {
#line 443
    c = *(channels + i);
#line 444
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 445
      switch (c->type) {
      case 6: 
      case 2: 
      case 11: 
      case 1: 
#line 450
      channel_close_fd(& c->sock);
#line 451
      channel_free(c);
#line 452
      break;
      }
    }
#line 442
    i ++;
  }
#line 456
  return;
}
}
#line 462 "channels.c"
int channel_not_very_much_buffered_data(void) 
{ u_int i ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 468
  i = 0U;
#line 468
  while (i < channels_alloc) {
#line 469
    c = *(channels + i);
#line 470
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 470
      if (c->type == 4) {
#line 479
        tmp___0 = buffer_len(& c->output);
#line 479
        if (tmp___0 > max_packet_size) {
#line 480
          tmp = buffer_len(& c->output);
#line 480
          debug2("channel %d: big output buffer %u > %u", c->self, tmp, max_packet_size);
#line 483
          return (0);
        }
      }
    }
#line 468
    i ++;
  }
#line 487
  return (1);
}
}
#line 491 "channels.c"
int channel_still_open(void) 
{ u_int i ;
  Channel *c ;

  {
#line 497
  i = 0U;
#line 497
  while (i < channels_alloc) {
#line 498
    c = *(channels + i);
#line 499
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 501
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 13: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
#line 512
    if (! compat20) {
#line 513
      fatal("cannot happen: SSH_CHANNEL_LARVAL");
    }
    goto __Cont;
    case 3: 
    case 4: 
    case 7: 
#line 518
    return (1);
    case 8: 
    case 9: 
#line 521
    if (! compat13) {
#line 522
      fatal("cannot happen: OUT_DRAIN");
    }
#line 523
    return (1);
    default: 
#line 525
    fatal("channel_still_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 497
    i ++;
  }
#line 529
  return (0);
}
}
#line 533 "channels.c"
int channel_find_open(void) 
{ u_int i ;
  Channel *c ;

  {
#line 539
  i = 0U;
#line 539
  while (i < channels_alloc) {
#line 540
    c = *(channels + i);
#line 541
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 541
      if (c->remote_id < 0) {
        goto __Cont;
      }
    }
#line 543
    switch (c->type) {
    case 5: 
    case 13: 
    case 1: 
    case 2: 
    case 11: 
    case 3: 
    case 12: 
    case 14: 
    goto __Cont;
    case 10: 
    case 6: 
    case 4: 
    case 7: 
#line 557
    return ((int )i);
    case 8: 
    case 9: 
#line 560
    if (! compat13) {
#line 561
      fatal("cannot happen: OUT_DRAIN");
    }
#line 562
    return ((int )i);
    default: 
#line 564
    fatal("channel_find_open: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 539
    i ++;
  }
#line 568
  return (-1);
}
}
#line 577 "channels.c"
char *channel_open_message(void) 
{ Buffer buffer ;
  Channel *c ;
  char buf___1[1024] ;
  char *cp ;
  u_int i ;
  size_t tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 585
  buffer_init(& buffer);
#line 586
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"The following connections are open:\r\n");
#line 587
  tmp = strlen((char const   *)(buf___1));
#line 587
  buffer_append(& buffer, (void const   *)(buf___1), tmp);
#line 588
  i = 0U;
#line 588
  while (i < channels_alloc) {
#line 589
    c = *(channels + i);
#line 590
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 592
    switch (c->type) {
    case 1: 
    case 2: 
    case 11: 
    case 5: 
    case 6: 
    case 14: 
    goto __Cont;
    case 10: 
    case 3: 
    case 12: 
    case 13: 
    case 4: 
    case 7: 
    case 8: 
    case 9: 
#line 608
    tmp___0 = buffer_len(& c->output);
#line 608
    tmp___1 = buffer_len(& c->input);
#line 608
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"  #%d %.300s (t%d r%d i%d/%d o%d/%d fd %d/%d cfd %d)\r\n",
             c->self, c->remote_name, c->type, c->remote_id, c->istate, tmp___1, c->ostate,
             tmp___0, c->rfd, c->wfd, c->ctl_fd);
#line 615
    tmp___2 = strlen((char const   *)(buf___1));
#line 615
    buffer_append(& buffer, (void const   *)(buf___1), tmp___2);
    goto __Cont;
    default: 
#line 618
    fatal("channel_open_message: bad channel type %d", c->type);
    }
    __Cont: /* CIL Label */ 
#line 588
    i ++;
  }
#line 622
  buffer_append(& buffer, (void const   *)"\000", 1U);
#line 623
  tmp___3 = buffer_ptr(& buffer);
#line 623
  cp = xstrdup((char const   *)tmp___3);
#line 624
  buffer_free(& buffer);
#line 625
  return (cp);
}
}
#line 628 "channels.c"
void channel_send_open(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 631
  tmp = channel_lookup(id);
#line 631
  c = tmp;
#line 633
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 634
    logit("channel_send_open: %d: bad id", id);
#line 635
    return;
  }
#line 637
  debug2("channel %d: send open", id);
#line 638
  packet_start((unsigned char)90);
#line 639
  packet_put_cstring((char const   *)c->ctype);
#line 640
  packet_put_int((unsigned int )c->self);
#line 641
  packet_put_int(c->local_window);
#line 642
  packet_put_int(c->local_maxpacket);
#line 643
  packet_send();
#line 644
  return;
}
}
#line 646 "channels.c"
void channel_request_start(int id , char *service , int wantconfirm ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 649
  tmp = channel_lookup(id);
#line 649
  c = tmp;
#line 651
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 652
    logit("channel_request_start: %d: unknown channel id", id);
#line 653
    return;
  }
#line 655
  debug2("channel %d: request %s confirm %d", id, service, wantconfirm);
#line 656
  packet_start((unsigned char)98);
#line 657
  packet_put_int((unsigned int )c->remote_id);
#line 658
  packet_put_cstring((char const   *)service);
#line 659
  packet_put_char(wantconfirm);
#line 660
  return;
}
}
#line 662 "channels.c"
void channel_register_confirm(int id , channel_callback_fn *fn , void *ctx ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 665
  tmp = channel_lookup(id);
#line 665
  c = tmp;
#line 667
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 668
    logit("channel_register_comfirm: %d: bad id", id);
#line 669
    return;
  }
#line 671
  c->confirm = fn;
#line 672
  c->confirm_ctx = ctx;
#line 673
  return;
}
}
#line 675 "channels.c"
void channel_register_cleanup(int id , channel_callback_fn *fn , int do_close ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 678
  tmp = channel_by_id(id);
#line 678
  c = tmp;
#line 680
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 681
    logit("channel_register_cleanup: %d: bad id", id);
#line 682
    return;
  }
#line 684
  c->detach_user = fn;
#line 685
  c->detach_close = do_close;
#line 686
  return;
}
}
#line 688 "channels.c"
void channel_cancel_cleanup(int id ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 691
  tmp = channel_by_id(id);
#line 691
  c = tmp;
#line 693
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 694
    logit("channel_cancel_cleanup: %d: bad id", id);
#line 695
    return;
  }
#line 697
  c->detach_user = (channel_callback_fn *)((void *)0);
#line 698
  c->detach_close = 0;
#line 699
  return;
}
}
#line 701 "channels.c"
void channel_register_filter(int id , channel_infilter_fn *ifn , channel_outfilter_fn *ofn ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 705
  tmp = channel_lookup(id);
#line 705
  c = tmp;
#line 707
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 708
    logit("channel_register_filter: %d: bad id", id);
#line 709
    return;
  }
#line 711
  c->input_filter = ifn;
#line 712
  c->output_filter = ofn;
#line 713
  return;
}
}
#line 715 "channels.c"
void channel_set_fds(int id , int rfd , int wfd , int efd , int extusage , int nonblock ,
                     u_int window_max ) 
{ Channel *c ;
  Channel *tmp ;

  {
#line 719
  tmp = channel_lookup(id);
#line 719
  c = tmp;
#line 721
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 722
    fatal("channel_activate for non-larval channel %d.", id);
  } else {
#line 721
    if (c->type != 10) {
#line 722
      fatal("channel_activate for non-larval channel %d.", id);
    }
  }
#line 723
  channel_register_fds(c, rfd, wfd, efd, extusage, nonblock);
#line 724
  c->type = 4;
#line 725
  c->local_window_max = window_max;
#line 725
  c->local_window = c->local_window_max;
#line 726
  packet_start((unsigned char)93);
#line 727
  packet_put_int((unsigned int )c->remote_id);
#line 728
  packet_put_int(c->local_window);
#line 729
  packet_send();
#line 730
  return;
}
}
#line 741 "channels.c"
chan_fn *channel_pre[15]  ;
#line 742 "channels.c"
chan_fn *channel_post[15]  ;
#line 745 "channels.c"
static void channel_pre_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 748
  __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 749
  return;
}
}
#line 752 "channels.c"
static void channel_pre_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 755
  debug3("channel %d: waiting for connection", c->self);
#line 756
  __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 757
  return;
}
}
#line 759 "channels.c"
static void channel_pre_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 762
  tmp = buffer_len(& c->input);
#line 762
  if (tmp < max_packet_size) {
#line 763
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 764
  tmp___0 = buffer_len(& c->output);
#line 764
  if (tmp___0 > 0U) {
#line 765
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 766
  return;
}
}
#line 768 "channels.c"
static void channel_pre_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int limit ;
  u_int tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 771
  if (compat20) {
#line 771
    tmp = c->remote_window;
  } else {
#line 771
    tmp = max_packet_size;
  }
#line 771
  limit = tmp;
#line 773
  if (c->istate == 0U) {
#line 773
    if (limit > 0U) {
#line 773
      tmp___0 = buffer_len(& c->input);
#line 773
      if (tmp___0 < limit) {
#line 773
        tmp___1 = buffer_check_alloc(& c->input, 16384U);
#line 773
        if (tmp___1) {
#line 777
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 778
  if (c->ostate == 0U) {
    goto _L;
  } else {
#line 778
    if (c->ostate == 1U) {
      _L: /* CIL Label */ 
#line 780
      tmp___4 = buffer_len(& c->output);
#line 780
      if (tmp___4 > 0U) {
#line 781
        __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      } else {
#line 782
        if (c->ostate == 1U) {
#line 783
          if (compat20) {
#line 783
            if (c->extended_usage == 2) {
#line 783
              if (c->efd != -1) {
#line 783
                if (! (c->flags & 10)) {
#line 784
                  tmp___2 = buffer_len(& c->extended);
#line 784
                  debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___2);
                } else {
#line 783
                  tmp___3 = buffer_len(& c->extended);
#line 783
                  if (tmp___3 > 0U) {
#line 784
                    tmp___2 = buffer_len(& c->extended);
#line 784
                    debug2("channel %d: obuf_empty delayed efd %d/(%d)", c->self,
                           c->efd, tmp___2);
                  } else {
#line 787
                    chan_obuf_empty(c);
                  }
                }
              } else {
#line 787
                chan_obuf_empty(c);
              }
            } else {
#line 787
              chan_obuf_empty(c);
            }
          } else {
#line 787
            chan_obuf_empty(c);
          }
        }
      }
    }
  }
#line 791
  if (compat20) {
#line 791
    if (c->efd != -1) {
#line 792
      if (c->extended_usage == 2) {
#line 792
        tmp___6 = buffer_len(& c->extended);
#line 792
        if (tmp___6 > 0U) {
#line 794
          __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 795
        if (! (c->flags & 4)) {
#line 795
          if (c->extended_usage == 1) {
#line 795
            tmp___5 = buffer_len(& c->extended);
#line 795
            if (tmp___5 < c->remote_window) {
#line 798
              __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))): "cc",
                                   "memory");
            }
          }
        }
      }
    }
  }
#line 801
  if (compat20) {
#line 801
    if (c->ctl_fd != -1) {
#line 801
      if (c->istate == 0U) {
#line 801
        if (c->ostate == 0U) {
#line 803
          __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->ctl_fd / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->ctl_fd % (8U * sizeof(__fd_mask ))): "cc",
                               "memory");
        }
      }
    }
  }
#line 804
  return;
}
}
#line 807 "channels.c"
static void channel_pre_input_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 810
  tmp = buffer_len(& c->input);
#line 810
  if (tmp == 0U) {
#line 811
    packet_start((unsigned char)24);
#line 812
    packet_put_int((unsigned int )c->remote_id);
#line 813
    packet_send();
#line 814
    c->type = 5;
#line 815
    debug2("channel %d: closing after input drain.", c->self);
  }
#line 817
  return;
}
}
#line 820 "channels.c"
static void channel_pre_output_draining(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_int tmp ;

  {
#line 823
  tmp = buffer_len(& c->output);
#line 823
  if (tmp == 0U) {
#line 824
    chan_mark_dead(c);
  } else {
#line 826
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 827
  return;
}
}
#line 838 "channels.c"
static int x11_open_helper(Buffer *b ) 
{ u_char *ucp ;
  u_int proto_len ;
  u_int data_len ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 845
  tmp = buffer_len(b);
#line 845
  if (tmp < 12U) {
#line 846
    return (0);
  }
#line 849
  tmp___0 = buffer_ptr(b);
#line 849
  ucp = (u_char *)tmp___0;
#line 850
  if ((int )*(ucp + 0) == 66) {
#line 851
    proto_len = (unsigned int )(256 * (int )*(ucp + 6) + (int )*(ucp + 7));
#line 852
    data_len = (unsigned int )(256 * (int )*(ucp + 8) + (int )*(ucp + 9));
  } else {
#line 853
    if ((int )*(ucp + 0) == 108) {
#line 854
      proto_len = (unsigned int )((int )*(ucp + 6) + 256 * (int )*(ucp + 7));
#line 855
      data_len = (unsigned int )((int )*(ucp + 8) + 256 * (int )*(ucp + 9));
    } else {
#line 857
      debug2("Initial X11 packet contains bad byte order byte: 0x%x", *(ucp + 0));
#line 859
      return (-1);
    }
  }
#line 863
  tmp___1 = buffer_len(b);
#line 863
  if (tmp___1 < (12U + ((proto_len + 3U) & 4294967292U)) + ((data_len + 3U) & 4294967292U)) {
#line 865
    return (0);
  }
#line 868
  tmp___2 = strlen((char const   *)x11_saved_proto);
#line 868
  if (proto_len != tmp___2) {
#line 870
    debug2("X11 connection uses different authentication protocol.");
#line 871
    return (-1);
  } else {
#line 868
    tmp___3 = memcmp((void const   *)(ucp + 12), (void const   *)x11_saved_proto,
                     proto_len);
#line 868
    if (tmp___3 != 0) {
#line 870
      debug2("X11 connection uses different authentication protocol.");
#line 871
      return (-1);
    }
  }
#line 874
  if (data_len != x11_fake_data_len) {
#line 877
    debug2("X11 auth data does not match fake data.");
#line 878
    return (-1);
  } else {
#line 874
    tmp___4 = memcmp((void const   *)((ucp + 12) + ((proto_len + 3U) & 4294967292U)),
                     (void const   *)x11_fake_data, x11_fake_data_len);
#line 874
    if (tmp___4 != 0) {
#line 877
      debug2("X11 auth data does not match fake data.");
#line 878
      return (-1);
    }
  }
#line 881
  if (x11_fake_data_len != x11_saved_data_len) {
#line 882
    error("X11 fake_data_len %d != saved_data_len %d", x11_fake_data_len, x11_saved_data_len);
#line 884
    return (-1);
  }
#line 891
  memcpy((void * __restrict  )((ucp + 12) + ((proto_len + 3U) & 4294967292U)), (void const   * __restrict  )x11_saved_data,
         x11_saved_data_len);
#line 893
  return (1);
}
}
#line 896 "channels.c"
static void channel_pre_x11_open_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret___0 ;
  int tmp ;

  {
#line 899
  tmp = x11_open_helper(& c->output);
#line 899
  ret___0 = tmp;
#line 901
  if (ret___0 == 1) {
#line 903
    c->type = 4;
#line 904
    channel_pre_open_13(c, readset, writeset);
  } else {
#line 905
    if (ret___0 == -1) {
#line 910
      logit("X11 connection rejected because of wrong authentication.");
#line 911
      buffer_clear(& c->input);
#line 912
      buffer_clear(& c->output);
#line 913
      channel_close_fd(& c->sock);
#line 914
      c->sock = -1;
#line 915
      c->type = 5;
#line 916
      packet_start((unsigned char)24);
#line 917
      packet_put_int((unsigned int )c->remote_id);
#line 918
      packet_send();
    }
  }
#line 920
  return;
}
}
#line 922 "channels.c"
static void channel_pre_x11_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int ret___0 ;
  int tmp ;

  {
#line 925
  tmp = x11_open_helper(& c->output);
#line 925
  ret___0 = tmp;
#line 929
  if (ret___0 == 1) {
#line 930
    c->type = 4;
#line 931
    channel_pre_open(c, readset, writeset);
  } else {
#line 932
    if (ret___0 == -1) {
#line 933
      logit("X11 connection rejected because of wrong authentication.");
#line 934
      debug2("X11 rejected %d i%d/o%d", c->self, c->istate, c->ostate);
#line 935
      chan_read_failed(c);
#line 936
      buffer_clear(& c->input);
#line 937
      chan_ibuf_empty(c);
#line 938
      buffer_clear(& c->output);
#line 940
      if (compat20) {
#line 941
        chan_write_failed(c);
      } else {
#line 943
        c->type = 4;
      }
#line 944
      debug2("X11 closed %d i%d/o%d", c->self, c->istate, c->ostate);
    }
  }
#line 946
  return;
}
}
#line 950 "channels.c"
static int channel_decode_socks4(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char *p ;
  char *host ;
  u_int len ;
  u_int have ;
  u_int i ;
  u_int found ;
  char username[256] ;
  struct __anonstruct_s4_req_59 s4_req ;
  struct __anonstruct_s4_req_59 s4_rsp ;
  void *tmp ;
  void *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 963
  debug2("channel %d: decode socks4", c->self);
#line 965
  have = buffer_len(& c->input);
#line 966
  len = sizeof(s4_req);
#line 967
  if (have < len) {
#line 968
    return (0);
  }
#line 969
  tmp = buffer_ptr(& c->input);
#line 969
  p = (char *)tmp;
#line 970
  found = 0U;
#line 970
  i = len;
#line 970
  while (i < have) {
#line 971
    if ((int )*(p + i) == 0) {
#line 972
      found = 1U;
#line 973
      break;
    }
#line 975
    if (i > 1024U) {
#line 977
      debug("channel %d: decode socks4: too long", c->self);
#line 979
      return (-1);
    }
#line 970
    i ++;
  }
#line 982
  if (! found) {
#line 983
    return (0);
  }
#line 984
  buffer_get(& c->input, (void *)((char *)(& s4_req.version)), 1U);
#line 985
  buffer_get(& c->input, (void *)((char *)(& s4_req.command)), 1U);
#line 986
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_port)), 2U);
#line 987
  buffer_get(& c->input, (void *)((char *)(& s4_req.dest_addr)), 4U);
#line 988
  have = buffer_len(& c->input);
#line 989
  tmp___0 = buffer_ptr(& c->input);
#line 989
  p = (char *)tmp___0;
#line 990
  len = strlen((char const   *)p);
#line 991
  debug2("channel %d: decode socks4: user %s/%d", c->self, p, len);
#line 992
  if (len > have) {
#line 993
    fatal("channel %d: decode socks4: len %d > have %d", c->self, len, have);
  }
#line 995
  strlcpy(username, (char const   *)p, sizeof(username));
#line 996
  buffer_consume(& c->input, len);
#line 997
  buffer_consume(& c->input, 1U);
#line 999
  host = inet_ntoa(s4_req.dest_addr);
#line 1000
  strlcpy(c->path, (char const   *)host, sizeof(c->path));
#line 1001
  __x = s4_req.dest_port;
#line 1001
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1001
  c->host_port = (int )__v;
#line 1003
  debug2("channel %d: dynamic request: socks4 host %s port %u command %u", c->self,
         host, c->host_port, s4_req.command);
#line 1006
  if ((int )s4_req.command != 1) {
#line 1007
    debug("channel %d: cannot handle: socks4 cn %d", c->self, s4_req.command);
#line 1009
    return (-1);
  }
#line 1011
  s4_rsp.version = (unsigned char)0;
#line 1012
  s4_rsp.command = (unsigned char)90;
#line 1013
  s4_rsp.dest_port = (unsigned short)0;
#line 1014
  s4_rsp.dest_addr.s_addr = 0U;
#line 1015
  buffer_append(& c->output, (void const   *)(& s4_rsp), sizeof(s4_rsp));
#line 1016
  return (1);
}
}
#line 1029 "channels.c"
static int channel_decode_socks5(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct __anonstruct_s5_req_60 s5_req ;
  struct __anonstruct_s5_req_60 s5_rsp ;
  u_int16_t dest_port ;
  u_char *p ;
  u_char dest_addr[256] ;
  u_int have ;
  u_int need ;
  u_int i ;
  u_int found ;
  u_int nmethods ;
  u_int addrlen ;
  u_int af ;
  void *tmp ;
  char const   *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;

  {
#line 1042
  debug2("channel %d: decode socks5", c->self);
#line 1043
  tmp = buffer_ptr(& c->input);
#line 1043
  p = (u_char *)tmp;
#line 1044
  if ((int )*(p + 0) != 5) {
#line 1045
    return (-1);
  }
#line 1046
  have = buffer_len(& c->input);
#line 1047
  if (! (c->flags & 4096)) {
#line 1049
    if (have < 2U) {
#line 1050
      return (0);
    }
#line 1051
    nmethods = (unsigned int )*(p + 1);
#line 1052
    if (have < nmethods + 2U) {
#line 1053
      return (0);
    }
#line 1055
    found = 0U;
#line 1055
    i = 2U;
#line 1055
    while (i < nmethods + 2U) {
#line 1056
      if ((int )*(p + i) == 0) {
#line 1057
        found = 1U;
#line 1058
        break;
      }
#line 1055
      i ++;
    }
#line 1061
    if (! found) {
#line 1062
      debug("channel %d: method SSH_SOCKS5_NOAUTH not found", c->self);
#line 1064
      return (-1);
    }
#line 1066
    buffer_consume(& c->input, nmethods + 2U);
#line 1067
    buffer_put_char(& c->output, 5);
#line 1068
    buffer_put_char(& c->output, 0);
#line 1069
    __asm__  volatile   ("btsl %1,%0": "=m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1070
    c->flags |= 4096;
#line 1071
    debug2("channel %d: socks5 auth done", c->self);
#line 1072
    return (0);
  }
#line 1074
  debug2("channel %d: socks5 post auth", c->self);
#line 1075
  if (have < sizeof(s5_req) + 1U) {
#line 1076
    return (0);
  }
#line 1077
  memcpy((void * __restrict  )(& s5_req), (void const   * __restrict  )p, sizeof(s5_req));
#line 1078
  if ((int )s5_req.version != 5) {
#line 1081
    debug2("channel %d: only socks5 connect supported", c->self);
#line 1082
    return (-1);
  } else {
#line 1078
    if ((int )s5_req.command != 1) {
#line 1081
      debug2("channel %d: only socks5 connect supported", c->self);
#line 1082
      return (-1);
    } else {
#line 1078
      if ((int )s5_req.reserved != 0) {
#line 1081
        debug2("channel %d: only socks5 connect supported", c->self);
#line 1082
        return (-1);
      }
    }
  }
#line 1084
  switch ((int )s5_req.atyp) {
  case 1: 
#line 1086
  addrlen = 4U;
#line 1087
  af = 2U;
#line 1088
  break;
  case 3: 
#line 1090
  addrlen = (unsigned int )*(p + sizeof(s5_req));
#line 1091
  af = 4294967295U;
#line 1092
  break;
  case 4: 
#line 1094
  addrlen = 16U;
#line 1095
  af = 10U;
#line 1096
  break;
  default: 
#line 1098
  debug2("channel %d: bad socks5 atyp %d", c->self, s5_req.atyp);
#line 1099
  return (-1);
  }
#line 1101
  need = (sizeof(s5_req) + addrlen) + 2U;
#line 1102
  if ((int )s5_req.atyp == 3) {
#line 1103
    need ++;
  }
#line 1104
  if (have < need) {
#line 1105
    return (0);
  }
#line 1106
  buffer_consume(& c->input, sizeof(s5_req));
#line 1107
  if ((int )s5_req.atyp == 3) {
#line 1108
    buffer_consume(& c->input, 1U);
  }
#line 1109
  buffer_get(& c->input, (void *)((char *)(& dest_addr)), addrlen);
#line 1110
  buffer_get(& c->input, (void *)((char *)(& dest_port)), 2U);
#line 1111
  dest_addr[addrlen] = (unsigned char )'\000';
#line 1112
  if ((int )s5_req.atyp == 3) {
#line 1113
    strlcpy(c->path, (char const   *)((char *)(dest_addr)), sizeof(c->path));
  } else {
#line 1114
    tmp___0 = inet_ntop((int )af, (void const   * __restrict  )(dest_addr), (char * __restrict  )(c->path),
                        sizeof(c->path));
#line 1114
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 1115
      return (-1);
    }
  }
#line 1116
  __x = dest_port;
#line 1116
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1116
  c->host_port = (int )__v;
#line 1118
  debug2("channel %d: dynamic request: socks5 host %s port %u command %u", c->self,
         c->path, c->host_port, s5_req.command);
#line 1121
  s5_rsp.version = (unsigned char)5;
#line 1122
  s5_rsp.command = (unsigned char)0;
#line 1123
  s5_rsp.reserved = (unsigned char)0;
#line 1124
  s5_rsp.atyp = (unsigned char)1;
#line 1125
  ((struct in_addr *)(& dest_addr))->s_addr = 0U;
#line 1126
  dest_port = (unsigned short)0;
#line 1128
  buffer_append(& c->output, (void const   *)(& s5_rsp), sizeof(s5_rsp));
#line 1129
  buffer_append(& c->output, (void const   *)(& dest_addr), sizeof(struct in_addr ));
#line 1130
  buffer_append(& c->output, (void const   *)(& dest_port), sizeof(dest_port));
#line 1131
  return (1);
}
}
#line 1135 "channels.c"
static void channel_pre_dynamic(Channel *c , fd_set *readset , fd_set *writeset ) 
{ u_char *p ;
  u_int have ;
  int ret___0 ;
  void *tmp ;

  {
#line 1142
  have = buffer_len(& c->input);
#line 1143
  c->delayed = 0;
#line 1144
  debug2("channel %d: pre_dynamic: have %d", c->self, have);
#line 1147
  if (have < 3U) {
#line 1149
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1150
    return;
  }
#line 1153
  tmp = buffer_ptr(& c->input);
#line 1153
  p = (u_char *)tmp;
#line 1154
  switch ((int )*(p + 0)) {
  case 4: 
#line 1156
  ret___0 = channel_decode_socks4(c, readset, writeset);
#line 1157
  break;
  case 5: 
#line 1159
  ret___0 = channel_decode_socks5(c, readset, writeset);
#line 1160
  break;
  default: 
#line 1162
  ret___0 = -1;
#line 1163
  break;
  }
#line 1165
  if (ret___0 < 0) {
#line 1166
    chan_mark_dead(c);
  } else {
#line 1167
    if (ret___0 == 0) {
#line 1168
      debug2("channel %d: pre_dynamic: need more", c->self);
#line 1170
      __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    } else {
#line 1173
      c->type = 3;
#line 1174
      port_open_helper(c, (char *)"direct-tcpip");
    }
  }
#line 1176
  return;
}
}
#line 1180 "channels.c"
static void channel_post_x11_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  socklen_t addrlen ;
  char buf___1[16384] ;
  char *remote_ipaddr ;
  int remote_port ;
  int *tmp ;
  char *tmp___0 ;
  u_int tmp___1 ;
  register char __result ;

  {
#line 1190
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1190
  if (__result) {
#line 1191
    debug("X11 connection requested.");
#line 1192
    addrlen = sizeof(addr);
#line 1193
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1194
    if (c->single_connection) {
#line 1195
      debug2("single_connection: closing X11 listener.");
#line 1196
      channel_close_fd(& c->sock);
#line 1197
      chan_mark_dead(c);
    }
#line 1199
    if (newsock < 0) {
#line 1200
      tmp = __errno_location();
#line 1200
      tmp___0 = strerror(*tmp);
#line 1200
      error("accept: %.100s", tmp___0);
#line 1201
      return;
    }
#line 1203
    set_nodelay(newsock);
#line 1204
    remote_ipaddr = get_peer_ipaddr(newsock);
#line 1205
    remote_port = get_peer_port(newsock);
#line 1206
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"X11 connection from %.200s port %d",
             remote_ipaddr, remote_port);
#line 1209
    nc = channel_new((char *)"accepted x11 socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, buf___1, 1);
#line 1212
    if (compat20) {
#line 1213
      packet_start((unsigned char)90);
#line 1214
      packet_put_cstring("x11");
#line 1215
      packet_put_int((unsigned int )nc->self);
#line 1216
      packet_put_int(nc->local_window_max);
#line 1217
      packet_put_int(nc->local_maxpacket);
#line 1219
      packet_put_cstring((char const   *)remote_ipaddr);
#line 1220
      if (datafellows & 8) {
#line 1221
        debug2("ssh2 x11 bug compat mode");
      } else {
#line 1223
        packet_put_int((unsigned int )remote_port);
      }
#line 1225
      packet_send();
    } else {
#line 1227
      packet_start((unsigned char)27);
#line 1228
      packet_put_int((unsigned int )nc->self);
#line 1229
      tmp___1 = packet_get_protocol_flags();
#line 1229
      if (tmp___1 & 2U) {
#line 1231
        packet_put_cstring((char const   *)(buf___1));
      }
#line 1232
      packet_send();
    }
#line 1234
    xfree((void *)remote_ipaddr);
  }
#line 1236
  return;
}
}
#line 1238 "channels.c"
static void port_open_helper(Channel *c , char *rtype ) 
{ int direct ;
  char buf___1[1024] ;
  char *remote_ipaddr ;
  char *tmp ;
  int remote_port ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;

  {
#line 1243
  tmp = get_peer_ipaddr(c->sock);
#line 1243
  remote_ipaddr = tmp;
#line 1244
  tmp___0 = get_peer_port(c->sock);
#line 1244
  remote_port = tmp___0;
#line 1246
  if (0) {
#line 1246
    __s1_len = strlen((char const   *)rtype);
#line 1246
    __s2_len = strlen("direct-tcpip");
#line 1246
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___0;
    } else {
#line 1246
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1246
        if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1246
          tmp___10 = 1;
        } else {
#line 1246
          if (__s2_len >= 4U) {
#line 1246
            tmp___10 = 1;
          } else {
#line 1246
            tmp___10 = 0;
          }
        }
      } else {
#line 1246
        tmp___10 = 0;
      }
    }
#line 1246
    if (tmp___10) {
#line 1246
      tmp___6 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
    } else {
#line 1246
      tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1246
      tmp___6 = tmp___9;
    }
  } else {
#line 1246
    tmp___9 = __builtin_strcmp((char const   *)rtype, "direct-tcpip");
#line 1246
    tmp___6 = tmp___9;
  }
#line 1246
  direct = tmp___6 == 0;
#line 1248
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s: listening port %d for %.100s port %d, connect from %.200s port %d",
           rtype, c->listening_port, c->path, c->host_port, remote_ipaddr, remote_port);
#line 1254
  xfree((void *)c->remote_name);
#line 1255
  c->remote_name = xstrdup((char const   *)(buf___1));
#line 1257
  if (compat20) {
#line 1258
    packet_start((unsigned char)90);
#line 1259
    packet_put_cstring((char const   *)rtype);
#line 1260
    packet_put_int((unsigned int )c->self);
#line 1261
    packet_put_int(c->local_window_max);
#line 1262
    packet_put_int(c->local_maxpacket);
#line 1263
    if (direct) {
#line 1265
      packet_put_cstring((char const   *)(c->path));
#line 1266
      packet_put_int((unsigned int )c->host_port);
    } else {
#line 1269
      packet_put_cstring((char const   *)(c->path));
#line 1270
      packet_put_int((unsigned int )c->listening_port);
    }
#line 1273
    packet_put_cstring((char const   *)remote_ipaddr);
#line 1274
    packet_put_int((unsigned int )remote_port);
#line 1275
    packet_send();
  } else {
#line 1277
    packet_start((unsigned char)29);
#line 1278
    packet_put_int((unsigned int )c->self);
#line 1279
    packet_put_cstring((char const   *)(c->path));
#line 1280
    packet_put_int((unsigned int )c->host_port);
#line 1281
    tmp___11 = packet_get_protocol_flags();
#line 1281
    if (tmp___11 & 2U) {
#line 1283
      packet_put_cstring((char const   *)c->remote_name);
    }
#line 1284
    packet_send();
  }
#line 1286
  xfree((void *)remote_ipaddr);
#line 1287
  return;
}
}
#line 1289 "channels.c"
static void channel_set_reuseaddr(int fd ) 
{ int on ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1292
  on = 1;
#line 1298
  tmp___1 = setsockopt(fd, 1, 2, (void const   *)(& on), sizeof(on));
#line 1298
  if (tmp___1 == -1) {
#line 1299
    tmp = __errno_location();
#line 1299
    tmp___0 = strerror(*tmp);
#line 1299
    error("setsockopt SO_REUSEADDR fd %d: %s", fd, tmp___0);
  }
#line 1300
  return;
}
}
#line 1306 "channels.c"
static void channel_post_port_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  struct sockaddr addr ;
  int newsock ;
  int nextstate ;
  socklen_t addrlen ;
  char *rtype ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1315
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1315
  if (__result) {
#line 1316
    debug("Connection to port %d forwarding to %.100s port %d requested.", c->listening_port,
          c->path, c->host_port);
#line 1320
    if (c->type == 11) {
#line 1321
      nextstate = 3;
#line 1322
      rtype = (char *)"forwarded-tcpip";
    } else {
#line 1324
      if (c->host_port == 0) {
#line 1325
        nextstate = 13;
#line 1326
        rtype = (char *)"dynamic-tcpip";
      } else {
#line 1328
        nextstate = 3;
#line 1329
        rtype = (char *)"direct-tcpip";
      }
    }
#line 1333
    addrlen = sizeof(addr);
#line 1334
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1335
    if (newsock < 0) {
#line 1336
      tmp = __errno_location();
#line 1336
      tmp___0 = strerror(*tmp);
#line 1336
      error("accept: %.100s", tmp___0);
#line 1337
      return;
    }
#line 1339
    set_nodelay(newsock);
#line 1340
    nc = channel_new(rtype, nextstate, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, rtype, 1);
#line 1342
    nc->listening_port = c->listening_port;
#line 1343
    nc->host_port = c->host_port;
#line 1344
    strlcpy(nc->path, (char const   *)(c->path), sizeof(nc->path));
#line 1346
    if (nextstate == 13) {
#line 1352
      nc->delayed = 1;
    } else {
#line 1354
      port_open_helper(nc, rtype);
    }
  }
#line 1357
  return;
}
}
#line 1364 "channels.c"
static void channel_post_auth_listener(Channel *c , fd_set *readset , fd_set *writeset ) 
{ Channel *nc ;
  int newsock ;
  struct sockaddr addr ;
  socklen_t addrlen ;
  int *tmp ;
  char *tmp___0 ;
  register char __result ;

  {
#line 1372
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1372
  if (__result) {
#line 1373
    addrlen = sizeof(addr);
#line 1374
    newsock = accept(c->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addrlen));
#line 1375
    if (newsock < 0) {
#line 1376
      tmp = __errno_location();
#line 1376
      tmp___0 = strerror(*tmp);
#line 1376
      error("accept from auth socket: %.100s", tmp___0);
#line 1377
      return;
    }
#line 1379
    nc = channel_new((char *)"accepted auth socket", 3, newsock, newsock, -1, c->local_window_max,
                     c->local_maxpacket, 0, (char *)"accepted auth socket", 1);
#line 1383
    if (compat20) {
#line 1384
      packet_start((unsigned char)90);
#line 1385
      packet_put_cstring("auth-agent@openssh.com");
#line 1386
      packet_put_int((unsigned int )nc->self);
#line 1387
      packet_put_int(c->local_window_max);
#line 1388
      packet_put_int(c->local_maxpacket);
    } else {
#line 1390
      packet_start((unsigned char)31);
#line 1391
      packet_put_int((unsigned int )nc->self);
    }
#line 1393
    packet_send();
  }
#line 1395
  return;
}
}
#line 1398 "channels.c"
static void channel_post_connecting(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int err ;
  socklen_t sz ;
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register char __result ;

  {
#line 1401
  err = 0;
#line 1402
  sz = sizeof(err);
#line 1404
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1404
  if (__result) {
#line 1405
    tmp___0 = getsockopt(c->sock, 1, 4, (void * __restrict  )(& err), (socklen_t * __restrict  )(& sz));
#line 1405
    if (tmp___0 < 0) {
#line 1406
      tmp = __errno_location();
#line 1406
      err = *tmp;
#line 1407
      error("getsockopt SO_ERROR failed");
    }
#line 1409
    if (err == 0) {
#line 1410
      debug("channel %d: connected", c->self);
#line 1411
      c->type = 4;
#line 1412
      if (compat20) {
#line 1413
        packet_start((unsigned char)91);
#line 1414
        packet_put_int((unsigned int )c->remote_id);
#line 1415
        packet_put_int((unsigned int )c->self);
#line 1416
        packet_put_int(c->local_window);
#line 1417
        packet_put_int(c->local_maxpacket);
      } else {
#line 1419
        packet_start((unsigned char)21);
#line 1420
        packet_put_int((unsigned int )c->remote_id);
#line 1421
        packet_put_int((unsigned int )c->self);
      }
    } else {
#line 1424
      tmp___1 = strerror(err);
#line 1424
      debug("channel %d: not connected: %s", c->self, tmp___1);
#line 1426
      if (compat20) {
#line 1427
        packet_start((unsigned char)92);
#line 1428
        packet_put_int((unsigned int )c->remote_id);
#line 1429
        packet_put_int(2U);
#line 1430
        if (! (datafellows & 131072)) {
#line 1431
          tmp___2 = strerror(err);
#line 1431
          packet_put_cstring((char const   *)tmp___2);
#line 1432
          packet_put_cstring("");
        }
      } else {
#line 1435
        packet_start((unsigned char)22);
#line 1436
        packet_put_int((unsigned int )c->remote_id);
      }
#line 1438
      chan_mark_dead(c);
    }
#line 1440
    packet_send();
  }
#line 1442
  return;
}
}
#line 1445 "channels.c"
static int channel_handle_rfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  int force ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  register char __result ;

  {
#line 1451
  if (c->isatty) {
#line 1451
    if (c->detach_close) {
#line 1451
      if (c->istate != 3U) {
#line 1451
        tmp = 1;
      } else {
#line 1451
        tmp = 0;
      }
    } else {
#line 1451
      tmp = 0;
    }
  } else {
#line 1451
    tmp = 0;
  }
#line 1451
  force = tmp;
#line 1452
  if (c->rfd != -1) {
#line 1452
    if (force) {
      goto _L;
    } else {
#line 1452
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->rfd % (8U * sizeof(__fd_mask ))),
                           "m" (readset->fds_bits[(unsigned int )c->rfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1452
      if (__result) {
        _L: /* CIL Label */ 
#line 1453
        tmp___0 = __errno_location();
#line 1453
        *tmp___0 = 0;
#line 1454
        len = read(c->rfd, (void *)(buf___1), sizeof(buf___1));
#line 1455
        if (len < 0) {
#line 1455
          tmp___1 = __errno_location();
#line 1455
          if (*tmp___1 == 4) {
#line 1456
            return (1);
          } else {
#line 1455
            tmp___2 = __errno_location();
#line 1455
            if (*tmp___2 == 11) {
#line 1455
              if (! force) {
#line 1456
                return (1);
              }
            }
          }
        }
#line 1458
        if (len <= 0) {
#line 1463
          debug2("channel %d: read<=0 rfd %d len %d", c->self, c->rfd, len);
#line 1465
          if (c->type != 4) {
#line 1466
            debug2("channel %d: not open", c->self);
#line 1467
            chan_mark_dead(c);
#line 1468
            return (-1);
          } else {
#line 1469
            if (compat13) {
#line 1470
              buffer_clear(& c->output);
#line 1471
              c->type = 8;
#line 1472
              debug2("channel %d: input draining.", c->self);
            } else {
#line 1474
              chan_read_failed(c);
            }
          }
#line 1476
          return (-1);
        }
#line 1478
        if ((unsigned int )c->input_filter != (unsigned int )((void *)0)) {
#line 1479
          tmp___3 = (*(c->input_filter))(c, buf___1, len);
#line 1479
          if (tmp___3 == -1) {
#line 1480
            debug2("channel %d: filter stops", c->self);
#line 1481
            chan_read_failed(c);
          }
        } else {
#line 1483
          if (c->datagram) {
#line 1484
            buffer_put_string(& c->input, (void const   *)(buf___1), (unsigned int )len);
          } else {
#line 1486
            buffer_append(& c->input, (void const   *)(buf___1), (unsigned int )len);
          }
        }
      }
    }
  }
#line 1489
  return (1);
}
}
#line 1493 "channels.c"
static int channel_handle_wfd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_char *buf___1 ;
  u_int dlen ;
  int len ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  register char __result ;
  u_int tmp___6 ;

  {
#line 1497
  data = (u_char *)((void *)0);
#line 1503
  if (c->wfd != -1) {
#line 1503
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->wfd % (8U * sizeof(__fd_mask ))),
                         "m" (writeset->fds_bits[(unsigned int )c->wfd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1503
    if (__result) {
#line 1503
      tmp___6 = buffer_len(& c->output);
#line 1503
      if (tmp___6 > 0U) {
#line 1505
        if ((unsigned int )c->output_filter != (unsigned int )((void *)0)) {
#line 1506
          buf___1 = (*(c->output_filter))(c, & data, & dlen);
#line 1506
          if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 1507
            debug2("channel %d: filter stops", c->self);
#line 1508
            if (c->type != 4) {
#line 1509
              chan_mark_dead(c);
            } else {
#line 1511
              chan_write_failed(c);
            }
#line 1512
            return (-1);
          }
        } else {
#line 1514
          if (c->datagram) {
#line 1515
            tmp = buffer_get_string(& c->output, & dlen);
#line 1515
            data = (u_char *)tmp;
#line 1515
            buf___1 = data;
          } else {
#line 1517
            tmp___0 = buffer_ptr(& c->output);
#line 1517
            data = (u_char *)tmp___0;
#line 1517
            buf___1 = data;
#line 1518
            dlen = buffer_len(& c->output);
          }
        }
#line 1521
        if (c->datagram) {
#line 1523
          c->local_consumed += dlen + 4U;
#line 1524
          len = write(c->wfd, (void const   *)buf___1, dlen);
#line 1525
          xfree((void *)data);
#line 1526
          if (len < 0) {
#line 1526
            tmp___1 = __errno_location();
#line 1526
            if (*tmp___1 == 4) {
#line 1527
              return (1);
            } else {
#line 1526
              tmp___2 = __errno_location();
#line 1526
              if (*tmp___2 == 11) {
#line 1527
                return (1);
              }
            }
          }
#line 1528
          if (len <= 0) {
#line 1529
            if (c->type != 4) {
#line 1530
              chan_mark_dead(c);
            } else {
#line 1532
              chan_write_failed(c);
            }
#line 1533
            return (-1);
          }
#line 1535
          return (1);
        }
#line 1543
        len = write(c->wfd, (void const   *)buf___1, dlen);
#line 1544
        if (len < 0) {
#line 1544
          tmp___3 = __errno_location();
#line 1544
          if (*tmp___3 == 4) {
#line 1545
            return (1);
          } else {
#line 1544
            tmp___4 = __errno_location();
#line 1544
            if (*tmp___4 == 11) {
#line 1545
              return (1);
            }
          }
        }
#line 1546
        if (len <= 0) {
#line 1547
          if (c->type != 4) {
#line 1548
            debug2("channel %d: not open", c->self);
#line 1549
            chan_mark_dead(c);
#line 1550
            return (-1);
          } else {
#line 1551
            if (compat13) {
#line 1552
              buffer_clear(& c->output);
#line 1553
              debug2("channel %d: input draining.", c->self);
#line 1554
              c->type = 8;
            } else {
#line 1556
              chan_write_failed(c);
            }
          }
#line 1558
          return (-1);
        }
#line 1560
        if (compat20) {
#line 1560
          if (c->isatty) {
#line 1560
            if (dlen >= 1U) {
#line 1560
              if ((int )*(buf___1 + 0) != 13) {
#line 1561
                tmp___5 = tcgetattr(c->wfd, & tio);
#line 1561
                if (tmp___5 == 0) {
#line 1561
                  if (! (tio.c_lflag & 8U)) {
#line 1561
                    if (tio.c_lflag & 2U) {
#line 1569
                      packet_send_ignore(4 + len);
#line 1570
                      packet_send();
                    }
                  }
                }
              }
            }
          }
        }
#line 1573
        buffer_consume(& c->output, (unsigned int )len);
#line 1574
        if (compat20) {
#line 1574
          if (len > 0) {
#line 1575
            c->local_consumed += (u_int )len;
          }
        }
      }
    }
  }
#line 1578
  return (1);
}
}
#line 1581 "channels.c"
static int channel_handle_efd(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16384] ;
  int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  register char __result___0 ;
  u_int tmp___5 ;

  {
#line 1588
  if (c->efd != -1) {
#line 1590
    if (c->extended_usage == 2) {
#line 1590
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1590
      if (__result___0) {
#line 1590
        tmp___5 = buffer_len(& c->extended);
#line 1590
        if (tmp___5 > 0U) {
#line 1592
          tmp = buffer_len(& c->extended);
#line 1592
          tmp___0 = buffer_ptr(& c->extended);
#line 1592
          len = write(c->efd, (void const   *)tmp___0, tmp);
#line 1594
          debug2("channel %d: written %d to efd %d", c->self, len, c->efd);
#line 1596
          if (len < 0) {
#line 1596
            tmp___1 = __errno_location();
#line 1596
            if (*tmp___1 == 4) {
#line 1597
              return (1);
            } else {
#line 1596
              tmp___2 = __errno_location();
#line 1596
              if (*tmp___2 == 11) {
#line 1597
                return (1);
              }
            }
          }
#line 1598
          if (len <= 0) {
#line 1599
            debug2("channel %d: closing write-efd %d", c->self, c->efd);
#line 1601
            channel_close_fd(& c->efd);
          } else {
#line 1603
            buffer_consume(& c->extended, (unsigned int )len);
#line 1604
            c->local_consumed += (u_int )len;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1607
      if (c->extended_usage == 1) {
#line 1607
        if (c->detach_close) {
          goto _L;
        } else {
#line 1607
          __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->efd % (8U * sizeof(__fd_mask ))),
                               "m" (readset->fds_bits[(unsigned int )c->efd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1607
          if (__result) {
            _L: /* CIL Label */ 
#line 1608
            len = read(c->efd, (void *)(buf___1), sizeof(buf___1));
#line 1609
            debug2("channel %d: read %d from efd %d", c->self, len, c->efd);
#line 1611
            if (len < 0) {
#line 1611
              tmp___3 = __errno_location();
#line 1611
              if (*tmp___3 == 4) {
#line 1613
                return (1);
              } else {
#line 1611
                tmp___4 = __errno_location();
#line 1611
                if (*tmp___4 == 11) {
#line 1611
                  if (! c->detach_close) {
#line 1613
                    return (1);
                  }
                }
              }
            }
#line 1614
            if (len <= 0) {
#line 1615
              debug2("channel %d: closing read-efd %d", c->self, c->efd);
#line 1617
              channel_close_fd(& c->efd);
            } else {
#line 1619
              buffer_append(& c->extended, (void const   *)(buf___1), (unsigned int )len);
            }
          }
        }
      }
    }
  }
#line 1623
  return (1);
}
}
#line 1627 "channels.c"
static int channel_handle_ctl(Channel *c , fd_set *readset , fd_set *writeset ) 
{ char buf___1[16] ;
  int len ;
  int *tmp ;
  int *tmp___0 ;
  register char __result ;

  {
#line 1634
  if (c->ctl_fd != -1) {
#line 1634
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->ctl_fd % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )c->ctl_fd / (8U * sizeof(__fd_mask ))]): "cc");
#line 1634
    if (__result) {
#line 1635
      len = read(c->ctl_fd, (void *)(buf___1), sizeof(buf___1));
#line 1636
      if (len < 0) {
#line 1636
        tmp = __errno_location();
#line 1636
        if (*tmp == 4) {
#line 1637
          return (1);
        } else {
#line 1636
          tmp___0 = __errno_location();
#line 1636
          if (*tmp___0 == 11) {
#line 1637
            return (1);
          }
        }
      }
#line 1638
      if (len <= 0) {
#line 1639
        debug2("channel %d: ctl read<=0", c->self);
#line 1640
        if (c->type != 4) {
#line 1641
          debug2("channel %d: not open", c->self);
#line 1642
          chan_mark_dead(c);
#line 1643
          return (-1);
        } else {
#line 1645
          chan_read_failed(c);
#line 1646
          chan_write_failed(c);
        }
#line 1648
        return (-1);
      } else {
#line 1650
        fatal("%s: unexpected data on ctl fd", "channel_handle_ctl");
      }
    }
  }
#line 1652
  return (1);
}
}
#line 1655 "channels.c"
static int channel_check_window(Channel *c ) 
{ 

  {
#line 1658
  if (c->type == 4) {
#line 1658
    if (! (c->flags & 3)) {
#line 1658
      if (c->local_window_max - c->local_window > c->local_maxpacket * 3U) {
        goto _L;
      } else {
#line 1658
        if (c->local_window < c->local_window_max / 2U) {
          _L: /* CIL Label */ 
#line 1658
          if (c->local_consumed > 0U) {
#line 1664
            packet_start((unsigned char)93);
#line 1665
            packet_put_int((unsigned int )c->remote_id);
#line 1666
            packet_put_int(c->local_consumed);
#line 1667
            packet_send();
#line 1668
            debug2("channel %d: window %d sent adjust %d", c->self, c->local_window,
                   c->local_consumed);
#line 1671
            c->local_window += c->local_consumed;
#line 1672
            c->local_consumed = 0U;
          }
        }
      }
    }
  }
#line 1674
  return (1);
}
}
#line 1677 "channels.c"
static void channel_post_open(Channel *c , fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1680
  if (c->delayed) {
#line 1681
    return;
  }
#line 1682
  channel_handle_rfd(c, readset, writeset);
#line 1683
  channel_handle_wfd(c, readset, writeset);
#line 1684
  if (! compat20) {
#line 1685
    return;
  }
#line 1686
  channel_handle_efd(c, readset, writeset);
#line 1687
  channel_handle_ctl(c, readset, writeset);
#line 1688
  channel_check_window(c);
#line 1689
  return;
}
}
#line 1692 "channels.c"
static void channel_post_output_drain_13(Channel *c , fd_set *readset , fd_set *writeset ) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  register char __result ;
  u_int tmp___1 ;

  {
#line 1698
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )c->sock % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )c->sock / (8U * sizeof(__fd_mask ))]): "cc");
#line 1698
  if (__result) {
#line 1698
    tmp___1 = buffer_len(& c->output);
#line 1698
    if (tmp___1 > 0U) {
#line 1699
      tmp = buffer_len(& c->output);
#line 1699
      tmp___0 = buffer_ptr(& c->output);
#line 1699
      len = write(c->sock, (void const   *)tmp___0, tmp);
#line 1701
      if (len <= 0) {
#line 1702
        buffer_clear(& c->output);
      } else {
#line 1704
        buffer_consume(& c->output, (unsigned int )len);
      }
    }
  }
#line 1706
  return;
}
}
#line 1708 "channels.c"
static void channel_handler_init_20(void) 
{ 

  {
#line 1711
  channel_pre[4] = & channel_pre_open;
#line 1712
  channel_pre[7] = & channel_pre_x11_open;
#line 1713
  channel_pre[2] = & channel_pre_listener;
#line 1714
  channel_pre[11] = & channel_pre_listener;
#line 1715
  channel_pre[1] = & channel_pre_listener;
#line 1716
  channel_pre[6] = & channel_pre_listener;
#line 1717
  channel_pre[12] = & channel_pre_connecting;
#line 1718
  channel_pre[13] = & channel_pre_dynamic;
#line 1720
  channel_post[4] = & channel_post_open;
#line 1721
  channel_post[2] = & channel_post_port_listener;
#line 1722
  channel_post[11] = & channel_post_port_listener;
#line 1723
  channel_post[1] = & channel_post_x11_listener;
#line 1724
  channel_post[6] = & channel_post_auth_listener;
#line 1725
  channel_post[12] = & channel_post_connecting;
#line 1726
  channel_post[13] = & channel_post_open;
#line 1727
  return;
}
}
#line 1729 "channels.c"
static void channel_handler_init_13(void) 
{ 

  {
#line 1732
  channel_pre[4] = & channel_pre_open_13;
#line 1733
  channel_pre[7] = & channel_pre_x11_open_13;
#line 1734
  channel_pre[1] = & channel_pre_listener;
#line 1735
  channel_pre[2] = & channel_pre_listener;
#line 1736
  channel_pre[6] = & channel_pre_listener;
#line 1737
  channel_pre[8] = & channel_pre_input_draining;
#line 1738
  channel_pre[9] = & channel_pre_output_draining;
#line 1739
  channel_pre[12] = & channel_pre_connecting;
#line 1740
  channel_pre[13] = & channel_pre_dynamic;
#line 1742
  channel_post[4] = & channel_post_open;
#line 1743
  channel_post[1] = & channel_post_x11_listener;
#line 1744
  channel_post[2] = & channel_post_port_listener;
#line 1745
  channel_post[6] = & channel_post_auth_listener;
#line 1746
  channel_post[9] = & channel_post_output_drain_13;
#line 1747
  channel_post[12] = & channel_post_connecting;
#line 1748
  channel_post[13] = & channel_post_open;
#line 1749
  return;
}
}
#line 1751 "channels.c"
static void channel_handler_init_15(void) 
{ 

  {
#line 1754
  channel_pre[4] = & channel_pre_open;
#line 1755
  channel_pre[7] = & channel_pre_x11_open;
#line 1756
  channel_pre[1] = & channel_pre_listener;
#line 1757
  channel_pre[2] = & channel_pre_listener;
#line 1758
  channel_pre[6] = & channel_pre_listener;
#line 1759
  channel_pre[12] = & channel_pre_connecting;
#line 1760
  channel_pre[13] = & channel_pre_dynamic;
#line 1762
  channel_post[1] = & channel_post_x11_listener;
#line 1763
  channel_post[2] = & channel_post_port_listener;
#line 1764
  channel_post[6] = & channel_post_auth_listener;
#line 1765
  channel_post[4] = & channel_post_open;
#line 1766
  channel_post[12] = & channel_post_connecting;
#line 1767
  channel_post[13] = & channel_post_open;
#line 1768
  return;
}
}
#line 1770 "channels.c"
static void channel_handler_init(void) 
{ int i ;

  {
#line 1775
  i = 0;
#line 1775
  while (i < 15) {
#line 1776
    channel_pre[i] = (chan_fn *)((void *)0);
#line 1777
    channel_post[i] = (chan_fn *)((void *)0);
#line 1775
    i ++;
  }
#line 1779
  if (compat20) {
#line 1780
    channel_handler_init_20();
  } else {
#line 1781
    if (compat13) {
#line 1782
      channel_handler_init_13();
    } else {
#line 1784
      channel_handler_init_15();
    }
  }
#line 1785
  return;
}
}
#line 1788 "channels.c"
static void channel_garbage_collect(Channel *c ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1791
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1792
    return;
  }
#line 1793
  if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1794
    tmp = chan_is_dead(c, c->detach_close);
#line 1794
    if (! tmp) {
#line 1795
      return;
    }
#line 1796
    debug2("channel %d: gc: notify user", c->self);
#line 1797
    (*(c->detach_user))(c->self, (void *)0);
#line 1799
    if ((unsigned int )c->detach_user != (unsigned int )((void *)0)) {
#line 1800
      return;
    }
#line 1801
    debug2("channel %d: gc: user detached", c->self);
  }
#line 1803
  tmp___0 = chan_is_dead(c, 1);
#line 1803
  if (! tmp___0) {
#line 1804
    return;
  }
#line 1805
  debug2("channel %d: garbage collecting", c->self);
#line 1806
  channel_free(c);
#line 1807
  return;
}
}
#line 1812
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) ;
#line 1812 "channels.c"
static int did_init  =    0;
#line 1809 "channels.c"
static void channel_handler(chan_fn **ftab , fd_set *readset , fd_set *writeset ) 
{ u_int i ;
  Channel *c ;

  {
#line 1816
  if (! did_init) {
#line 1817
    channel_handler_init();
#line 1818
    did_init = 1;
  }
#line 1820
  i = 0U;
#line 1820
  while (i < channels_alloc) {
#line 1821
    c = *(channels + i);
#line 1822
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1824
    if ((unsigned int )*(ftab + c->type) != (unsigned int )((void *)0)) {
#line 1825
      (*(*(ftab + c->type)))(c, readset, writeset);
    }
#line 1826
    channel_garbage_collect(c);
    __Cont: /* CIL Label */ 
#line 1820
    i ++;
  }
#line 1828
  return;
}
}
#line 1834 "channels.c"
void channel_prepare_select(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                            u_int *nallocp , int rekeying___0 ) 
{ u_int n___0 ;
  u_int sz ;
  u_int nfdset ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1840
  if (*maxfdp > channel_max_fd) {
#line 1840
    n___0 = (unsigned int )*maxfdp;
  } else {
#line 1840
    n___0 = (unsigned int )channel_max_fd;
  }
#line 1842
  nfdset = ((n___0 + 1U) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ));
#line 1844
  if (nfdset) {
#line 1844
    if (4294967295UL / (unsigned long )nfdset < (unsigned long )sizeof(fd_mask )) {
#line 1845
      fatal("channel_prepare_select: max_fd (%d) is too large", n___0);
    }
  }
#line 1846
  sz = nfdset * sizeof(fd_mask );
#line 1849
  if ((unsigned int )*readsetp == (unsigned int )((void *)0)) {
#line 1850
    tmp = xrealloc((void *)*readsetp, nfdset, sizeof(fd_mask ));
#line 1850
    *readsetp = (fd_set *)tmp;
#line 1851
    tmp___0 = xrealloc((void *)*writesetp, nfdset, sizeof(fd_mask ));
#line 1851
    *writesetp = (fd_set *)tmp___0;
#line 1852
    *nallocp = sz;
  } else {
#line 1849
    if (sz > *nallocp) {
#line 1850
      tmp = xrealloc((void *)*readsetp, nfdset, sizeof(fd_mask ));
#line 1850
      *readsetp = (fd_set *)tmp;
#line 1851
      tmp___0 = xrealloc((void *)*writesetp, nfdset, sizeof(fd_mask ));
#line 1851
      *writesetp = (fd_set *)tmp___0;
#line 1852
      *nallocp = sz;
    }
  }
#line 1854
  *maxfdp = (int )n___0;
#line 1855
  memset((void *)*readsetp, 0, sz);
#line 1856
  memset((void *)*writesetp, 0, sz);
#line 1858
  if (! rekeying___0) {
#line 1859
    channel_handler(channel_pre, *readsetp, *writesetp);
  }
#line 1860
  return;
}
}
#line 1866 "channels.c"
void channel_after_select(fd_set *readset , fd_set *writeset ) 
{ 

  {
#line 1869
  channel_handler(channel_post, readset, writeset);
#line 1870
  return;
}
}
#line 1874 "channels.c"
void channel_output_poll(void) 
{ Channel *c ;
  u_int i ;
  u_int len ;
  u_char *data ;
  u_int dlen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;

  {
#line 1880
  i = 0U;
#line 1880
  while (i < channels_alloc) {
#line 1881
    c = *(channels + i);
#line 1882
    if ((unsigned int )c == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 1889
    if (compat13) {
#line 1890
      if (c->type != 4) {
#line 1890
        if (c->type != 8) {
          goto __Cont;
        }
      }
    } else {
#line 1894
      if (c->type != 4) {
        goto __Cont;
      }
    }
#line 1897
    if (compat20) {
#line 1897
      if (c->flags & 3) {
#line 1900
        debug3("channel %d: will not send data after close", c->self);
        goto __Cont;
      }
    }
#line 1905
    if (c->istate == 0U) {
      goto _L___0;
    } else {
#line 1905
      if (c->istate == 1U) {
        _L___0: /* CIL Label */ 
#line 1905
        len = buffer_len(& c->input);
#line 1905
        if (len > 0U) {
#line 1908
          if (c->datagram) {
#line 1909
            if (len > 0U) {
#line 1913
              tmp = buffer_get_string(& c->input, & dlen);
#line 1913
              data = (u_char *)tmp;
#line 1915
              packet_start((unsigned char)94);
#line 1916
              packet_put_int((unsigned int )c->remote_id);
#line 1917
              packet_put_string((void const   *)data, dlen);
#line 1918
              packet_send();
#line 1919
              c->remote_window -= dlen + 4U;
#line 1920
              xfree((void *)data);
            }
            goto __Cont;
          }
#line 1928
          if (compat20) {
#line 1929
            if (len > c->remote_window) {
#line 1930
              len = c->remote_window;
            }
#line 1931
            if (len > c->remote_maxpacket) {
#line 1932
              len = c->remote_maxpacket;
            }
          } else {
#line 1934
            tmp___0 = packet_is_interactive();
#line 1934
            if (tmp___0) {
#line 1935
              if (len > 1024U) {
#line 1936
                len = 512U;
              }
            } else {
#line 1939
              if (len > max_packet_size / 2U) {
#line 1940
                len = max_packet_size / 2U;
              }
            }
          }
#line 1943
          if (len > 0U) {
#line 1944
            if (compat20) {
#line 1944
              tmp___1 = 94;
            } else {
#line 1944
              tmp___1 = 23;
            }
#line 1944
            packet_start((unsigned char )tmp___1);
#line 1946
            packet_put_int((unsigned int )c->remote_id);
#line 1947
            tmp___2 = buffer_ptr(& c->input);
#line 1947
            packet_put_string((void const   *)tmp___2, len);
#line 1948
            packet_send();
#line 1949
            buffer_consume(& c->input, len);
#line 1950
            c->remote_window -= len;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1952
        if (c->istate == 1U) {
#line 1953
          if (compat13) {
#line 1954
            fatal("cannot happen: istate == INPUT_WAIT_DRAIN for proto 1.3");
          }
#line 1960
          if (compat20) {
#line 1960
            if (c->extended_usage == 1) {
#line 1960
              if (c->efd != -1) {
#line 1961
                tmp___3 = buffer_len(& c->extended);
#line 1961
                debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                       tmp___3);
              } else {
#line 1960
                tmp___4 = buffer_len(& c->extended);
#line 1960
                if (tmp___4 > 0U) {
#line 1961
                  tmp___3 = buffer_len(& c->extended);
#line 1961
                  debug2("channel %d: ibuf_empty delayed efd %d/(%d)", c->self, c->efd,
                         tmp___3);
                } else {
#line 1964
                  chan_ibuf_empty(c);
                }
              }
            } else {
#line 1964
              chan_ibuf_empty(c);
            }
          } else {
#line 1964
            chan_ibuf_empty(c);
          }
        }
      }
    }
#line 1967
    if (compat20) {
#line 1967
      if (! (c->flags & 4)) {
#line 1967
        if (c->remote_window > 0U) {
#line 1967
          len = buffer_len(& c->extended);
#line 1967
          if (len > 0U) {
#line 1967
            if (c->extended_usage == 1) {
#line 1972
              tmp___5 = buffer_len(& c->extended);
#line 1972
              debug2("channel %d: rwin %u elen %u euse %d", c->self, c->remote_window,
                     tmp___5, c->extended_usage);
#line 1975
              if (len > c->remote_window) {
#line 1976
                len = c->remote_window;
              }
#line 1977
              if (len > c->remote_maxpacket) {
#line 1978
                len = c->remote_maxpacket;
              }
#line 1979
              packet_start((unsigned char)95);
#line 1980
              packet_put_int((unsigned int )c->remote_id);
#line 1981
              packet_put_int(1U);
#line 1982
              tmp___6 = buffer_ptr(& c->extended);
#line 1982
              packet_put_string((void const   *)tmp___6, len);
#line 1983
              packet_send();
#line 1984
              buffer_consume(& c->extended, len);
#line 1985
              c->remote_window -= len;
#line 1986
              debug2("channel %d: sent ext data %d", c->self, len);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1880
    i ++;
  }
#line 1989
  return;
}
}
#line 1995 "channels.c"
void channel_input_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2004
  tmp = packet_get_int();
#line 2004
  id = (int )tmp;
#line 2005
  c = channel_lookup(id);
#line 2006
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2007
    packet_disconnect("Received data for nonexistent channel %d.", id);
  }
#line 2010
  if (c->type != 4) {
#line 2010
    if (c->type != 7) {
#line 2012
      return;
    }
  }
#line 2015
  tmp___0 = packet_get_string(& data_len);
#line 2015
  data = (char *)tmp___0;
#line 2024
  if (! compat13) {
#line 2024
    if (c->ostate != 0U) {
#line 2025
      if (compat20) {
#line 2026
        c->local_window -= data_len;
#line 2027
        c->local_consumed += data_len;
      }
#line 2029
      xfree((void *)data);
#line 2030
      return;
    }
  }
#line 2033
  if (compat20) {
#line 2034
    if (data_len > c->local_maxpacket) {
#line 2035
      logit("channel %d: rcvd big packet %d, maxpack %d", c->self, data_len, c->local_maxpacket);
    }
#line 2038
    if (data_len > c->local_window) {
#line 2039
      logit("channel %d: rcvd too much data %d, win %d", c->self, data_len, c->local_window);
#line 2041
      xfree((void *)data);
#line 2042
      return;
    }
#line 2044
    c->local_window -= data_len;
  }
#line 2046
  while (1) {
#line 2046
    tmp___1 = packet_remaining();
#line 2046
    _len = tmp___1;
#line 2046
    if (_len > 0) {
#line 2046
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2046);
#line 2046
      packet_disconnect("Packet integrity error.");
    }
#line 2046
    break;
  }
#line 2047
  if (c->datagram) {
#line 2048
    buffer_put_string(& c->output, (void const   *)data, data_len);
  } else {
#line 2050
    buffer_append(& c->output, (void const   *)data, data_len);
  }
#line 2051
  xfree((void *)data);
#line 2052
  return;
}
}
#line 2055 "channels.c"
void channel_input_extended_data(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  char *data ;
  u_int data_len ;
  u_int tcode ;
  Channel *c ;
  u_int tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2064
  tmp = packet_get_int();
#line 2064
  id = (int )tmp;
#line 2065
  c = channel_lookup(id);
#line 2067
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2068
    packet_disconnect("Received extended_data for bad channel %d.", id);
  }
#line 2069
  if (c->type != 4) {
#line 2070
    logit("channel %d: ext data for non open", id);
#line 2071
    return;
  }
#line 2073
  if (c->flags & 8) {
#line 2074
    if (datafellows & 2097152) {
#line 2075
      debug("channel %d: accepting ext data after eof", id);
    } else {
#line 2077
      packet_disconnect("Received extended_data after EOF on channel %d.", id);
    }
  }
#line 2080
  tcode = packet_get_int();
#line 2081
  if (c->efd == -1) {
#line 2084
    logit("channel %d: bad ext data", c->self);
#line 2085
    return;
  } else {
#line 2081
    if (c->extended_usage != 2) {
#line 2084
      logit("channel %d: bad ext data", c->self);
#line 2085
      return;
    } else {
#line 2081
      if (tcode != 1U) {
#line 2084
        logit("channel %d: bad ext data", c->self);
#line 2085
        return;
      }
    }
  }
#line 2087
  tmp___0 = packet_get_string(& data_len);
#line 2087
  data = (char *)tmp___0;
#line 2088
  while (1) {
#line 2088
    tmp___1 = packet_remaining();
#line 2088
    _len = tmp___1;
#line 2088
    if (_len > 0) {
#line 2088
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2088);
#line 2088
      packet_disconnect("Packet integrity error.");
    }
#line 2088
    break;
  }
#line 2089
  if (data_len > c->local_window) {
#line 2090
    logit("channel %d: rcvd too much extended_data %d, win %d", c->self, data_len,
          c->local_window);
#line 2092
    xfree((void *)data);
#line 2093
    return;
  }
#line 2095
  debug2("channel %d: rcvd ext data %d", c->self, data_len);
#line 2096
  c->local_window -= data_len;
#line 2097
  buffer_append(& c->extended, (void const   *)data, data_len);
#line 2098
  xfree((void *)data);
#line 2099
  return;
}
}
#line 2102 "channels.c"
void channel_input_ieof(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;
  u_int tmp___1 ;

  {
#line 2108
  tmp = packet_get_int();
#line 2108
  id = (int )tmp;
#line 2109
  while (1) {
#line 2109
    tmp___0 = packet_remaining();
#line 2109
    _len = tmp___0;
#line 2109
    if (_len > 0) {
#line 2109
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2109);
#line 2109
      packet_disconnect("Packet integrity error.");
    }
#line 2109
    break;
  }
#line 2110
  c = channel_lookup(id);
#line 2111
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2112
    packet_disconnect("Received ieof for nonexistent channel %d.", id);
  }
#line 2113
  chan_rcvd_ieof(c);
#line 2116
  if (c->force_drain) {
#line 2116
    if (c->istate == 0U) {
#line 2117
      debug("channel %d: FORCE input drain", c->self);
#line 2118
      c->istate = 1U;
#line 2119
      tmp___1 = buffer_len(& c->input);
#line 2119
      if (tmp___1 == 0U) {
#line 2120
        chan_ibuf_empty(c);
      }
    }
  }
#line 2123
  return;
}
}
#line 2126 "channels.c"
void channel_input_close(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  Channel *c ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2132
  tmp = packet_get_int();
#line 2132
  id = (int )tmp;
#line 2133
  while (1) {
#line 2133
    tmp___0 = packet_remaining();
#line 2133
    _len = tmp___0;
#line 2133
    if (_len > 0) {
#line 2133
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2133);
#line 2133
      packet_disconnect("Packet integrity error.");
    }
#line 2133
    break;
  }
#line 2134
  c = channel_lookup(id);
#line 2135
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2136
    packet_disconnect("Received close for nonexistent channel %d.", id);
  }
#line 2142
  packet_start((unsigned char)25);
#line 2143
  packet_put_int((unsigned int )c->remote_id);
#line 2144
  packet_send();
#line 2153
  if (c->type != 5) {
#line 2158
    buffer_clear(& c->input);
#line 2159
    c->type = 9;
  }
#line 2161
  return;
}
}
#line 2165 "channels.c"
void channel_input_oclose(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2168
  tmp = packet_get_int();
#line 2168
  id = (int )tmp;
#line 2169
  tmp___0 = channel_lookup(id);
#line 2169
  c = tmp___0;
#line 2171
  while (1) {
#line 2171
    tmp___1 = packet_remaining();
#line 2171
    _len = tmp___1;
#line 2171
    if (_len > 0) {
#line 2171
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2171);
#line 2171
      packet_disconnect("Packet integrity error.");
    }
#line 2171
    break;
  }
#line 2172
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2173
    packet_disconnect("Received oclose for nonexistent channel %d.", id);
  }
#line 2174
  chan_rcvd_oclose(c);
#line 2175
  return;
}
}
#line 2178 "channels.c"
void channel_input_close_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  u_int tmp ;
  Channel *c ;
  Channel *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2181
  tmp = packet_get_int();
#line 2181
  id = (int )tmp;
#line 2182
  tmp___0 = channel_lookup(id);
#line 2182
  c = tmp___0;
#line 2184
  while (1) {
#line 2184
    tmp___1 = packet_remaining();
#line 2184
    _len = tmp___1;
#line 2184
    if (_len > 0) {
#line 2184
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2184);
#line 2184
      packet_disconnect("Packet integrity error.");
    }
#line 2184
    break;
  }
#line 2185
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2186
    packet_disconnect("Received close confirmation for out-of-range channel %d.",
                      id);
  }
#line 2188
  if (c->type != 5) {
#line 2189
    packet_disconnect("Received close confirmation for non-closed channel %d (type %d).",
                      id, c->type);
  }
#line 2191
  channel_free(c);
#line 2192
  return;
}
}
#line 2195 "channels.c"
void channel_input_open_confirmation(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int remote_id ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 2201
  tmp = packet_get_int();
#line 2201
  id = (int )tmp;
#line 2202
  c = channel_lookup(id);
#line 2204
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2205
    packet_disconnect("Received open confirmation for non-opening channel %d.", id);
  } else {
#line 2204
    if (c->type != 3) {
#line 2205
      packet_disconnect("Received open confirmation for non-opening channel %d.",
                        id);
    }
  }
#line 2207
  tmp___0 = packet_get_int();
#line 2207
  remote_id = (int )tmp___0;
#line 2209
  c->remote_id = remote_id;
#line 2210
  c->type = 4;
#line 2212
  if (compat20) {
#line 2213
    c->remote_window = packet_get_int();
#line 2214
    c->remote_maxpacket = packet_get_int();
#line 2215
    if (c->confirm) {
#line 2216
      debug2("callback start");
#line 2217
      (*(c->confirm))(c->self, c->confirm_ctx);
#line 2218
      debug2("callback done");
    }
#line 2220
    debug2("channel %d: open confirm rwindow %u rmax %u", c->self, c->remote_window,
           c->remote_maxpacket);
  }
#line 2223
  while (1) {
#line 2223
    tmp___1 = packet_remaining();
#line 2223
    _len = tmp___1;
#line 2223
    if (_len > 0) {
#line 2223
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2223);
#line 2223
      packet_disconnect("Packet integrity error.");
    }
#line 2223
    break;
  }
#line 2224
  return;
}
}
#line 2226 "channels.c"
static char *reason2txt(int reason ) 
{ 

  {
#line 2229
  switch (reason) {
  case 1: 
#line 2231
  return ((char *)"administratively prohibited");
  case 2: 
#line 2233
  return ((char *)"connect failed");
  case 3: 
#line 2235
  return ((char *)"unknown channel type");
  case 4: 
#line 2237
  return ((char *)"resource shortage");
  }
#line 2239
  return ((char *)"unknown reason");
}
}
#line 2243 "channels.c"
void channel_input_open_failure(int type , u_int32_t seq , void *ctxt ) 
{ int id ;
  int reason ;
  char *msg ;
  char *lang ;
  Channel *c ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int _len ;
  int tmp___6 ;

  {
#line 2247
  msg = (char *)((void *)0);
#line 2247
  lang = (char *)((void *)0);
#line 2250
  tmp = packet_get_int();
#line 2250
  id = (int )tmp;
#line 2251
  c = channel_lookup(id);
#line 2253
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2254
    packet_disconnect("Received open failure for non-opening channel %d.", id);
  } else {
#line 2253
    if (c->type != 3) {
#line 2254
      packet_disconnect("Received open failure for non-opening channel %d.", id);
    }
  }
#line 2256
  if (compat20) {
#line 2257
    tmp___0 = packet_get_int();
#line 2257
    reason = (int )tmp___0;
#line 2258
    if (! (datafellows & 131072)) {
#line 2259
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 2259
      msg = (char *)tmp___1;
#line 2260
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2260
      lang = (char *)tmp___2;
    }
#line 2262
    if (msg) {
#line 2262
      tmp___3 = (char const   *)msg;
    } else {
#line 2262
      tmp___3 = "";
    }
#line 2262
    if (msg) {
#line 2262
      tmp___4 = ": ";
    } else {
#line 2262
      tmp___4 = "";
    }
#line 2262
    tmp___5 = reason2txt(reason);
#line 2262
    logit("channel %d: open failed: %s%s%s", id, tmp___5, tmp___4, tmp___3);
#line 2264
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 2265
      xfree((void *)msg);
    }
#line 2266
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
#line 2267
      xfree((void *)lang);
    }
  }
#line 2269
  while (1) {
#line 2269
    tmp___6 = packet_remaining();
#line 2269
    _len = tmp___6;
#line 2269
    if (_len > 0) {
#line 2269
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2269);
#line 2269
      packet_disconnect("Packet integrity error.");
    }
#line 2269
    break;
  }
#line 2271
  channel_free(c);
#line 2272
  return;
}
}
#line 2275 "channels.c"
void channel_input_window_adjust(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  u_int adjust ;
  u_int tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2282
  if (! compat20) {
#line 2283
    return;
  }
#line 2286
  tmp = packet_get_int();
#line 2286
  id = (int )tmp;
#line 2287
  c = channel_lookup(id);
#line 2289
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2290
    logit("Received window adjust for non-open channel %d.", id);
#line 2291
    return;
  }
#line 2293
  adjust = packet_get_int();
#line 2294
  while (1) {
#line 2294
    tmp___0 = packet_remaining();
#line 2294
    _len = tmp___0;
#line 2294
    if (_len > 0) {
#line 2294
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2294);
#line 2294
      packet_disconnect("Packet integrity error.");
    }
#line 2294
    break;
  }
#line 2295
  debug2("channel %d: rcvd adjust %u", id, adjust);
#line 2296
  c->remote_window += adjust;
#line 2297
  return;
}
}
#line 2300 "channels.c"
void channel_input_port_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  u_short host_port ;
  char *host ;
  char *originator_string ;
  int remote_id ;
  int sock ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  int _len ;
  int tmp___4 ;

  {
#line 2303
  c = (Channel *)((void *)0);
#line 2306
  sock = -1;
#line 2308
  tmp = packet_get_int();
#line 2308
  remote_id = (int )tmp;
#line 2309
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2309
  host = (char *)tmp___0;
#line 2310
  tmp___1 = packet_get_int();
#line 2310
  host_port = (unsigned short )tmp___1;
#line 2312
  tmp___3 = packet_get_protocol_flags();
#line 2312
  if (tmp___3 & 2U) {
#line 2313
    tmp___2 = packet_get_string((u_int *)((void *)0));
#line 2313
    originator_string = (char *)tmp___2;
  } else {
#line 2315
    originator_string = xstrdup("unknown (remote did not supply name)");
  }
#line 2317
  while (1) {
#line 2317
    tmp___4 = packet_remaining();
#line 2317
    _len = tmp___4;
#line 2317
    if (_len > 0) {
#line 2317
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            2317);
#line 2317
      packet_disconnect("Packet integrity error.");
    }
#line 2317
    break;
  }
#line 2318
  sock = channel_connect_to((char const   *)host, host_port);
#line 2319
  if (sock != -1) {
#line 2320
    c = channel_new((char *)"connected socket", 12, sock, sock, -1, 0U, 0U, 0, originator_string,
                    1);
#line 2323
    c->remote_id = remote_id;
  }
#line 2325
  xfree((void *)originator_string);
#line 2326
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2327
    packet_start((unsigned char)22);
#line 2328
    packet_put_int((unsigned int )remote_id);
#line 2329
    packet_send();
  }
#line 2331
  xfree((void *)host);
#line 2332
  return;
}
}
#line 2337 "channels.c"
void channel_set_af(int af ) 
{ 

  {
#line 2340
  IPv4or6 = af;
#line 2341
  return;
}
}
#line 2343 "channels.c"
static int channel_setup_fwd_listener(int type , char const   *listen_addr , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ,
                                      int gateway_ports ) 
{ Channel *c ;
  int sock ;
  int r ;
  int success ;
  int wildcard ;
  int is_client ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char const   *host ;
  char const   *addr ;
  char ntop[1025] ;
  char strport[32] ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;

  {
#line 2348
  success = 0;
#line 2348
  wildcard = 0;
#line 2353
  if (type == 11) {
#line 2353
    host = listen_addr;
  } else {
#line 2353
    host = host_to_connect;
  }
#line 2355
  is_client = type == 2;
#line 2357
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2358
    error("No forward host name.");
#line 2359
    return (0);
  }
#line 2361
  tmp = strlen(host);
#line 2361
  if (tmp > 255U) {
#line 2362
    error("Forward host name too long.");
#line 2363
    return (0);
  }
#line 2381
  addr = (char const   *)((void *)0);
#line 2382
  if ((unsigned int )listen_addr == (unsigned int )((void *)0)) {
#line 2384
    if (gateway_ports) {
#line 2385
      wildcard = 1;
    }
  } else {
#line 2386
    if (gateway_ports) {
      goto _L___8;
    } else {
#line 2386
      if (is_client) {
        _L___8: /* CIL Label */ 
#line 2389
        if (datafellows & 16777216) {
#line 2388
          if (0) {
#line 2388
            __s1_len___0 = strlen(listen_addr);
#line 2388
            __s2_len___0 = strlen("0.0.0.0");
#line 2388
            if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
              goto _L___2;
            } else {
#line 2388
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2388
                if (! ((unsigned int )((void const   *)("0.0.0.0" + 1)) - (unsigned int )((void const   *)"0.0.0.0") == 1U)) {
#line 2388
                  tmp___19 = 1;
                } else {
#line 2388
                  if (__s2_len___0 >= 4U) {
#line 2388
                    tmp___19 = 1;
                  } else {
#line 2388
                    tmp___19 = 0;
                  }
                }
              } else {
#line 2388
                tmp___19 = 0;
              }
            }
#line 2388
            if (tmp___19) {
#line 2388
              tmp___15 = __builtin_strcmp(listen_addr, "0.0.0.0");
            } else {
#line 2388
              tmp___18 = __builtin_strcmp(listen_addr, "0.0.0.0");
#line 2388
              tmp___15 = tmp___18;
            }
          } else {
#line 2388
            tmp___18 = __builtin_strcmp(listen_addr, "0.0.0.0");
#line 2388
            tmp___15 = tmp___18;
          }
#line 2389
          if (tmp___15 == 0) {
#line 2389
            if (is_client == 0) {
#line 2391
              wildcard = 1;
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ 
#line 2389
          if ((int const   )*listen_addr == 0) {
#line 2391
            wildcard = 1;
          } else {
#line 2389
            if (0) {
#line 2389
              __s1_len___1 = strlen(listen_addr);
#line 2389
              __s2_len___1 = strlen("*");
#line 2389
              if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
                goto _L___4;
              } else {
#line 2389
                if (__s1_len___1 >= 4U) {
                  _L___4: /* CIL Label */ 
#line 2389
                  if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2389
                    tmp___29 = 1;
                  } else {
#line 2389
                    if (__s2_len___1 >= 4U) {
#line 2389
                      tmp___29 = 1;
                    } else {
#line 2389
                      tmp___29 = 0;
                    }
                  }
                } else {
#line 2389
                  tmp___29 = 0;
                }
              }
#line 2389
              if (tmp___29) {
#line 2389
                tmp___25 = __builtin_strcmp(listen_addr, "*");
              } else {
#line 2389
                tmp___28 = __builtin_strcmp(listen_addr, "*");
#line 2389
                tmp___25 = tmp___28;
              }
            } else {
#line 2389
              tmp___28 = __builtin_strcmp(listen_addr, "*");
#line 2389
              tmp___25 = tmp___28;
            }
#line 2389
            if (tmp___25 == 0) {
#line 2391
              wildcard = 1;
            } else {
#line 2389
              if (! is_client) {
#line 2389
                if (gateway_ports == 1) {
#line 2391
                  wildcard = 1;
                } else {
                  goto _L___5;
                }
              } else {
                _L___5: /* CIL Label */ 
#line 2392
                if (0) {
#line 2392
                  __s1_len = strlen(listen_addr);
#line 2392
                  __s2_len = strlen("localhost");
#line 2392
                  if (! ((unsigned int )((void const   *)(listen_addr + 1)) - (unsigned int )((void const   *)listen_addr) == 1U)) {
                    goto _L___0;
                  } else {
#line 2392
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 2392
                      if (! ((unsigned int )((void const   *)("localhost" + 1)) - (unsigned int )((void const   *)"localhost") == 1U)) {
#line 2392
                        tmp___9 = 1;
                      } else {
#line 2392
                        if (__s2_len >= 4U) {
#line 2392
                          tmp___9 = 1;
                        } else {
#line 2392
                          tmp___9 = 0;
                        }
                      }
                    } else {
#line 2392
                      tmp___9 = 0;
                    }
                  }
#line 2392
                  if (tmp___9) {
#line 2392
                    tmp___5 = __builtin_strcmp(listen_addr, "localhost");
                  } else {
#line 2392
                    tmp___8 = __builtin_strcmp(listen_addr, "localhost");
#line 2392
                    tmp___5 = tmp___8;
                  }
                } else {
#line 2392
                  tmp___8 = __builtin_strcmp(listen_addr, "localhost");
#line 2392
                  tmp___5 = tmp___8;
                }
#line 2392
                if (tmp___5 != 0) {
#line 2393
                  addr = listen_addr;
                }
              }
            }
          }
        }
      }
    }
  }
#line 2396
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 2396
    tmp___30 = "NULL";
  } else {
#line 2396
    tmp___30 = addr;
  }
#line 2396
  debug3("channel_setup_fwd_listener: type %d wildcard %d addr %s", type, wildcard,
         tmp___30);
#line 2403
  memset((void *)(& hints), 0, sizeof(hints));
#line 2404
  hints.ai_family = IPv4or6;
#line 2405
  if (wildcard) {
#line 2405
    hints.ai_flags = 1;
  } else {
#line 2405
    hints.ai_flags = 0;
  }
#line 2406
  hints.ai_socktype = 1;
#line 2407
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           listen_port);
#line 2408
  r = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                  (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2408
  if (r != 0) {
#line 2409
    if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 2411
      tmp___31 = ssh_gai_strerror(r);
#line 2411
      packet_disconnect("getaddrinfo: fatal error: %s", tmp___31);
    } else {
#line 2414
      tmp___32 = ssh_gai_strerror(r);
#line 2414
      error("channel_setup_fwd_listener: getaddrinfo(%.64s): %s", addr, tmp___32);
    }
#line 2418
    return (0);
  }
#line 2421
  ai = aitop;
#line 2421
  while (ai) {
#line 2422
    if (ai->ai_family != 2) {
#line 2422
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2424
    tmp___33 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                           (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                           sizeof(strport), 3U);
#line 2424
    if (tmp___33 != 0) {
#line 2426
      error("channel_setup_fwd_listener: getnameinfo failed");
      goto __Cont;
    }
#line 2430
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2431
    if (sock < 0) {
#line 2433
      tmp___34 = __errno_location();
#line 2433
      tmp___35 = strerror(*tmp___34);
#line 2433
      verbose("socket: %.100s", tmp___35);
      goto __Cont;
    }
#line 2437
    channel_set_reuseaddr(sock);
#line 2439
    debug("Local forwarding listening on %s port %s.", ntop, strport);
#line 2442
    tmp___40 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2442
    if (tmp___40 < 0) {
#line 2444
      if (! ai->ai_next) {
#line 2445
        tmp___36 = __errno_location();
#line 2445
        tmp___37 = strerror(*tmp___36);
#line 2445
        error("bind: %.100s", tmp___37);
      } else {
#line 2447
        tmp___38 = __errno_location();
#line 2447
        tmp___39 = strerror(*tmp___38);
#line 2447
        verbose("bind: %.100s", tmp___39);
      }
#line 2449
      close(sock);
      goto __Cont;
    }
#line 2453
    tmp___43 = listen(sock, 128);
#line 2453
    if (tmp___43 < 0) {
#line 2454
      tmp___41 = __errno_location();
#line 2454
      tmp___42 = strerror(*tmp___41);
#line 2454
      error("listen: %.100s", tmp___42);
#line 2455
      close(sock);
      goto __Cont;
    }
#line 2459
    c = channel_new((char *)"port listener", type, sock, sock, -1, 2097152U, 32768U,
                    0, (char *)"port listener", 1);
#line 2462
    strlcpy(c->path, host, sizeof(c->path));
#line 2463
    c->host_port = (int )port_to_connect;
#line 2464
    c->listening_port = (int )listen_port;
#line 2465
    success = 1;
    __Cont: /* CIL Label */ 
#line 2421
    ai = ai->ai_next;
  }
#line 2467
  if (success == 0) {
#line 2468
    error("channel_setup_fwd_listener: cannot listen to port: %d", listen_port);
  }
#line 2470
  freeaddrinfo(aitop);
#line 2471
  return (success);
}
}
#line 2474 "channels.c"
int channel_cancel_rport_listener(char const   *host , u_short port___0 ) 
{ u_int i ;
  int found ;
  Channel *c ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 2478
  found = 0;
#line 2480
  i = 0U;
#line 2480
  while (i < channels_alloc) {
#line 2481
    c = *(channels + i);
#line 2484
    if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 2484
      if (c->type == 11) {
#line 2484
        if (0) {
#line 2484
          if (0) {
#line 2484
            __s1_len___0 = strlen((char const   *)(c->path));
#line 2484
            __s2_len___0 = strlen(host);
#line 2484
            if (! ((unsigned int )((void const   *)(c->path + 1)) - (unsigned int )((void const   *)(c->path)) == 1U)) {
              goto _L___2;
            } else {
#line 2484
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2484
                if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2484
                  tmp___22 = 1;
                } else {
#line 2484
                  if (__s2_len___0 >= 4U) {
#line 2484
                    tmp___22 = 1;
                  } else {
#line 2484
                    tmp___22 = 0;
                  }
                }
              } else {
#line 2484
                tmp___22 = 0;
              }
            }
#line 2484
            if (tmp___22) {
#line 2484
              tmp___18 = __builtin_strcmp((char const   *)(c->path), host);
            } else {
#line 2484
              tmp___21 = __builtin_strcmp((char const   *)(c->path), host);
#line 2484
              tmp___18 = tmp___21;
            }
          } else {
#line 2484
            tmp___21 = __builtin_strcmp((char const   *)(c->path), host);
#line 2484
            tmp___18 = tmp___21;
          }
#line 2484
          tmp___12 = tmp___18;
        } else {
#line 2484
          tmp___12 = strncmp((char const   *)(c->path), host, sizeof(c->path));
        }
#line 2484
        if (tmp___12 == 0) {
#line 2484
          if (c->listening_port == (int )port___0) {
#line 2486
            debug2("%s: close channel %d", "channel_cancel_rport_listener", i);
#line 2487
            channel_free(c);
#line 2488
            found = 1;
          }
        }
      }
    }
#line 2480
    i ++;
  }
#line 2492
  return (found);
}
}
#line 2496 "channels.c"
int channel_setup_local_fwd_listener(char const   *listen_host , u_short listen_port ,
                                     char const   *host_to_connect , u_short port_to_connect ,
                                     int gateway_ports ) 
{ int tmp ;

  {
#line 2500
  tmp = channel_setup_fwd_listener(2, listen_host, listen_port, host_to_connect, port_to_connect,
                                   gateway_ports);
#line 2500
  return (tmp);
}
}
#line 2506 "channels.c"
int channel_setup_remote_fwd_listener(char const   *listen_address , u_short listen_port ,
                                      int gateway_ports ) 
{ int tmp ;

  {
#line 2510
  tmp = channel_setup_fwd_listener(11, listen_address, listen_port, (char const   *)((void *)0),
                                   (unsigned short)0, gateway_ports);
#line 2510
  return (tmp);
}
}
#line 2519 "channels.c"
int channel_request_remote_forwarding(char const   *listen_host , u_short listen_port ,
                                      char const   *host_to_connect , u_short port_to_connect ) 
{ int type ;
  int success ;
  char const   *address_to_bind ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2523
  success = 0;
#line 2526
  if (num_permitted_opens >= 100) {
#line 2527
    fatal("channel_request_remote_forwarding: too many forwards");
  }
#line 2530
  if (compat20) {
#line 2532
    if ((unsigned int )listen_host == (unsigned int )((void *)0)) {
#line 2533
      if (datafellows & 33554432) {
#line 2534
        address_to_bind = "127.0.0.1";
      } else {
#line 2536
        address_to_bind = "localhost";
      }
    } else {
#line 2538
      if ((int const   )*listen_host == 0) {
        goto _L___1;
      } else {
#line 2538
        if (0) {
#line 2538
          __s1_len = strlen(listen_host);
#line 2538
          __s2_len = strlen("*");
#line 2538
          if (! ((unsigned int )((void const   *)(listen_host + 1)) - (unsigned int )((void const   *)listen_host) == 1U)) {
            goto _L___0;
          } else {
#line 2538
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 2538
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2538
                tmp___8 = 1;
              } else {
#line 2538
                if (__s2_len >= 4U) {
#line 2538
                  tmp___8 = 1;
                } else {
#line 2538
                  tmp___8 = 0;
                }
              }
            } else {
#line 2538
              tmp___8 = 0;
            }
          }
#line 2538
          if (tmp___8) {
#line 2538
            tmp___4 = __builtin_strcmp(listen_host, "*");
          } else {
#line 2538
            tmp___7 = __builtin_strcmp(listen_host, "*");
#line 2538
            tmp___4 = tmp___7;
          }
        } else {
#line 2538
          tmp___7 = __builtin_strcmp(listen_host, "*");
#line 2538
          tmp___4 = tmp___7;
        }
#line 2538
        if (tmp___4 == 0) {
          _L___1: /* CIL Label */ 
#line 2539
          if (datafellows & 33554432) {
#line 2540
            address_to_bind = "0.0.0.0";
          } else {
#line 2542
            address_to_bind = "";
          }
        } else {
#line 2544
          address_to_bind = listen_host;
        }
      }
    }
#line 2546
    packet_start((unsigned char)80);
#line 2547
    packet_put_cstring("tcpip-forward");
#line 2548
    packet_put_char(1);
#line 2549
    packet_put_cstring(address_to_bind);
#line 2550
    packet_put_int((unsigned int )listen_port);
#line 2551
    packet_send();
#line 2552
    packet_write_wait();
#line 2554
    success = 1;
  } else {
#line 2556
    packet_start((unsigned char)28);
#line 2557
    packet_put_int((unsigned int )listen_port);
#line 2558
    packet_put_cstring(host_to_connect);
#line 2559
    packet_put_int((unsigned int )port_to_connect);
#line 2560
    packet_send();
#line 2561
    packet_write_wait();
#line 2564
    type = packet_read();
#line 2565
    switch (type) {
    case 14: 
#line 2567
    success = 1;
#line 2568
    break;
    case 15: 
#line 2570
    break;
    default: 
#line 2573
    packet_disconnect("Protocol error for port forward request:received packet type %d.",
                      type);
    }
  }
#line 2577
  if (success) {
#line 2578
    permitted_opens[num_permitted_opens].host_to_connect = xstrdup(host_to_connect);
#line 2579
    permitted_opens[num_permitted_opens].port_to_connect = port_to_connect;
#line 2580
    permitted_opens[num_permitted_opens].listen_port = listen_port;
#line 2581
    num_permitted_opens ++;
  }
#line 2583
  if (success) {
#line 2583
    tmp___9 = 0;
  } else {
#line 2583
    tmp___9 = -1;
  }
#line 2583
  return (tmp___9);
}
}
#line 2590 "channels.c"
void channel_request_rforward_cancel(char const   *host , u_short port___0 ) 
{ int i ;
  char const   *tmp ;

  {
#line 2595
  if (! compat20) {
#line 2596
    return;
  }
#line 2598
  i = 0;
#line 2598
  while (i < num_permitted_opens) {
#line 2599
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2599
      if ((int )permitted_opens[i].listen_port == (int )port___0) {
#line 2601
        break;
      }
    }
#line 2598
    i ++;
  }
#line 2603
  if (i >= num_permitted_opens) {
#line 2604
    debug("%s: requested forward not found", "channel_request_rforward_cancel");
#line 2605
    return;
  }
#line 2607
  packet_start((unsigned char)80);
#line 2608
  packet_put_cstring("cancel-tcpip-forward");
#line 2609
  packet_put_char(0);
#line 2610
  if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 2610
    tmp = "";
  } else {
#line 2610
    tmp = host;
  }
#line 2610
  packet_put_cstring(tmp);
#line 2611
  packet_put_int((unsigned int )port___0);
#line 2612
  packet_send();
#line 2614
  permitted_opens[i].listen_port = (unsigned short)0;
#line 2615
  permitted_opens[i].port_to_connect = (unsigned short)0;
#line 2616
  xfree((void *)permitted_opens[i].host_to_connect);
#line 2617
  permitted_opens[i].host_to_connect = (char *)((void *)0);
#line 2618
  return;
}
}
#line 2625 "channels.c"
int channel_input_port_forward_request(int is_root , int gateway_ports ) 
{ u_short port___0 ;
  u_short host_port ;
  int success ;
  char *hostname ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 2629
  success = 0;
#line 2633
  tmp = packet_get_int();
#line 2633
  port___0 = (unsigned short )tmp;
#line 2634
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 2634
  hostname = (char *)tmp___0;
#line 2635
  tmp___1 = packet_get_int();
#line 2635
  host_port = (unsigned short )tmp___1;
#line 2642
  if ((int )port___0 < 1024) {
#line 2642
    if (! is_root) {
#line 2643
      packet_disconnect("Requested forwarding of port %d but user is not root.", port___0);
    }
  }
#line 2646
  if ((int )host_port == 0) {
#line 2647
    packet_disconnect("Dynamic forwarding denied.");
  }
#line 2651
  success = channel_setup_local_fwd_listener((char const   *)((void *)0), port___0,
                                             (char const   *)hostname, host_port,
                                             gateway_ports);
#line 2655
  xfree((void *)hostname);
#line 2657
  if (success) {
#line 2657
    tmp___2 = 0;
  } else {
#line 2657
    tmp___2 = -1;
  }
#line 2657
  return (tmp___2);
}
}
#line 2665 "channels.c"
void channel_permit_all_opens(void) 
{ 

  {
#line 2668
  if (num_permitted_opens == 0) {
#line 2669
    all_opens_permitted = 1;
  }
#line 2670
  return;
}
}
#line 2672 "channels.c"
void channel_add_permitted_opens(char *host , int port___0 ) 
{ 

  {
#line 2675
  if (num_permitted_opens >= 100) {
#line 2676
    fatal("channel_add_permitted_opens: too many forwards");
  }
#line 2677
  debug("allow port forwarding to host %s port %d", host, port___0);
#line 2679
  permitted_opens[num_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2680
  permitted_opens[num_permitted_opens].port_to_connect = (unsigned short )port___0;
#line 2681
  num_permitted_opens ++;
#line 2683
  all_opens_permitted = 0;
#line 2684
  return;
}
}
#line 2686 "channels.c"
int channel_add_adm_permitted_opens(char *host , int port___0 ) 
{ 

  {
#line 2689
  if (num_adm_permitted_opens >= 100) {
#line 2690
    fatal("channel_add_adm_permitted_opens: too many forwards");
  }
#line 2691
  debug("config allows port forwarding to host %s port %d", host, port___0);
#line 2693
  permitted_adm_opens[num_adm_permitted_opens].host_to_connect = xstrdup((char const   *)host);
#line 2695
  permitted_adm_opens[num_adm_permitted_opens].port_to_connect = (unsigned short )port___0;
#line 2696
  num_adm_permitted_opens ++;
#line 2696
  return (num_adm_permitted_opens);
}
}
#line 2699 "channels.c"
void channel_clear_permitted_opens(void) 
{ int i ;

  {
#line 2704
  i = 0;
#line 2704
  while (i < num_permitted_opens) {
#line 2705
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2706
      xfree((void *)permitted_opens[i].host_to_connect);
    }
#line 2704
    i ++;
  }
#line 2707
  num_permitted_opens = 0;
#line 2708
  return;
}
}
#line 2710 "channels.c"
void channel_clear_adm_permitted_opens(void) 
{ int i ;

  {
#line 2715
  i = 0;
#line 2715
  while (i < num_adm_permitted_opens) {
#line 2716
    if ((unsigned int )permitted_adm_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2717
      xfree((void *)permitted_adm_opens[i].host_to_connect);
    }
#line 2715
    i ++;
  }
#line 2718
  num_adm_permitted_opens = 0;
#line 2719
  return;
}
}
#line 2722 "channels.c"
static int connect_to(char const   *host , u_short port___0 ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char ntop[1025] ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 2728
  sock = -1;
#line 2730
  memset((void *)(& hints), 0, sizeof(hints));
#line 2731
  hints.ai_family = IPv4or6;
#line 2732
  hints.ai_socktype = 1;
#line 2733
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
           port___0);
#line 2734
  gaierr = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2734
  if (gaierr != 0) {
#line 2735
    tmp = ssh_gai_strerror(gaierr);
#line 2735
    error("connect_to %.100s: unknown host (%s)", host, tmp);
#line 2737
    return (-1);
  }
#line 2739
  ai = aitop;
#line 2739
  while (ai) {
#line 2740
    if (ai->ai_family != 2) {
#line 2740
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 2742
    tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 2742
    if (tmp___0 != 0) {
#line 2744
      error("connect_to: getnameinfo failed");
      goto __Cont;
    }
#line 2747
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2748
    if (sock < 0) {
#line 2749
      if ((unsigned int )ai->ai_next == (unsigned int )((void *)0)) {
#line 2750
        tmp___1 = __errno_location();
#line 2750
        tmp___2 = strerror(*tmp___1);
#line 2750
        error("socket: %.100s", tmp___2);
      } else {
#line 2752
        tmp___3 = __errno_location();
#line 2752
        tmp___4 = strerror(*tmp___3);
#line 2752
        verbose("socket: %.100s", tmp___4);
      }
      goto __Cont;
    }
#line 2755
    tmp___5 = set_nonblock(sock);
#line 2755
    if (tmp___5 == -1) {
#line 2756
      fatal("%s: set_nonblock(%d)", "connect_to", sock);
    }
#line 2757
    tmp___8 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2757
    if (tmp___8 < 0) {
#line 2757
      tmp___9 = __errno_location();
#line 2757
      if (*tmp___9 != 115) {
#line 2759
        tmp___6 = __errno_location();
#line 2759
        tmp___7 = strerror(*tmp___6);
#line 2759
        error("connect_to %.100s port %s: %.100s", ntop, strport, tmp___7);
#line 2761
        close(sock);
        goto __Cont;
      }
    }
#line 2764
    break;
    __Cont: /* CIL Label */ 
#line 2739
    ai = ai->ai_next;
  }
#line 2767
  freeaddrinfo(aitop);
#line 2768
  if (! ai) {
#line 2769
    error("connect_to %.100s port %d: failed.", host, port___0);
#line 2770
    return (-1);
  }
#line 2773
  set_nodelay(sock);
#line 2774
  return (sock);
}
}
#line 2777 "channels.c"
int channel_connect_by_listen_address(u_short listen_port ) 
{ int i ;
  int tmp ;

  {
#line 2782
  i = 0;
#line 2782
  while (i < num_permitted_opens) {
#line 2783
    if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2783
      if ((int )permitted_opens[i].listen_port == (int )listen_port) {
#line 2785
        tmp = connect_to((char const   *)permitted_opens[i].host_to_connect, permitted_opens[i].port_to_connect);
#line 2785
        return (tmp);
      }
    }
#line 2782
    i ++;
  }
#line 2788
  error("WARNING: Server requests forwarding for unknown listen_port %d", listen_port);
#line 2790
  return (-1);
}
}
#line 2794 "channels.c"
int channel_connect_to(char const   *host , u_short port___0 ) 
{ int i ;
  int permit ;
  int permit_adm ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 2797
  permit_adm = 1;
#line 2799
  permit = all_opens_permitted;
#line 2800
  if (! permit) {
#line 2801
    i = 0;
#line 2801
    while (i < num_permitted_opens) {
#line 2804
      if ((unsigned int )permitted_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2804
        if ((int )permitted_opens[i].port_to_connect == (int )port___0) {
#line 2804
          if (0) {
#line 2804
            __s1_len = strlen((char const   *)permitted_opens[i].host_to_connect);
#line 2804
            __s2_len = strlen(host);
#line 2804
            if (! ((unsigned int )((void const   *)(permitted_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_opens[i].host_to_connect) == 1U)) {
              goto _L___0;
            } else {
#line 2804
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 2804
                if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2804
                  tmp___8 = 1;
                } else {
#line 2804
                  if (__s2_len >= 4U) {
#line 2804
                    tmp___8 = 1;
                  } else {
#line 2804
                    tmp___8 = 0;
                  }
                }
              } else {
#line 2804
                tmp___8 = 0;
              }
            }
#line 2804
            if (tmp___8) {
#line 2804
              tmp___4 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                         host);
            } else {
#line 2804
              tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                         host);
#line 2804
              tmp___4 = tmp___7;
            }
          } else {
#line 2804
            tmp___7 = __builtin_strcmp((char const   *)permitted_opens[i].host_to_connect,
                                       host);
#line 2804
            tmp___4 = tmp___7;
          }
#line 2804
          if (tmp___4 == 0) {
#line 2805
            permit = 1;
          }
        }
      }
#line 2801
      i ++;
    }
  }
#line 2808
  if (num_adm_permitted_opens > 0) {
#line 2809
    permit_adm = 0;
#line 2810
    i = 0;
#line 2810
    while (i < num_adm_permitted_opens) {
#line 2813
      if ((unsigned int )permitted_adm_opens[i].host_to_connect != (unsigned int )((void *)0)) {
#line 2813
        if ((int )permitted_adm_opens[i].port_to_connect == (int )port___0) {
#line 2813
          if (0) {
#line 2813
            __s1_len___0 = strlen((char const   *)permitted_adm_opens[i].host_to_connect);
#line 2813
            __s2_len___0 = strlen(host);
#line 2813
            if (! ((unsigned int )((void const   *)(permitted_adm_opens[i].host_to_connect + 1)) - (unsigned int )((void const   *)permitted_adm_opens[i].host_to_connect) == 1U)) {
              goto _L___2;
            } else {
#line 2813
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2813
                if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
#line 2813
                  tmp___18 = 1;
                } else {
#line 2813
                  if (__s2_len___0 >= 4U) {
#line 2813
                    tmp___18 = 1;
                  } else {
#line 2813
                    tmp___18 = 0;
                  }
                }
              } else {
#line 2813
                tmp___18 = 0;
              }
            }
#line 2813
            if (tmp___18) {
#line 2813
              tmp___14 = __builtin_strcmp((char const   *)permitted_adm_opens[i].host_to_connect,
                                          host);
            } else {
#line 2813
              tmp___17 = __builtin_strcmp((char const   *)permitted_adm_opens[i].host_to_connect,
                                          host);
#line 2813
              tmp___14 = tmp___17;
            }
          } else {
#line 2813
            tmp___17 = __builtin_strcmp((char const   *)permitted_adm_opens[i].host_to_connect,
                                        host);
#line 2813
            tmp___14 = tmp___17;
          }
#line 2813
          if (tmp___14 == 0) {
#line 2815
            permit_adm = 1;
          }
        }
      }
#line 2810
      i ++;
    }
  }
#line 2818
  if (! permit) {
#line 2819
    logit("Received request to connect to host %.100s port %d, but the request was denied.",
          host, port___0);
#line 2821
    return (-1);
  } else {
#line 2818
    if (! permit_adm) {
#line 2819
      logit("Received request to connect to host %.100s port %d, but the request was denied.",
            host, port___0);
#line 2821
      return (-1);
    }
  }
#line 2823
  tmp___19 = connect_to(host, port___0);
#line 2823
  return (tmp___19);
}
}
#line 2826 "channels.c"
void channel_send_window_changes(void) 
{ u_int i ;
  struct winsize ws ;
  int tmp ;

  {
#line 2832
  i = 0U;
#line 2832
  while (i < channels_alloc) {
#line 2833
    if ((unsigned int )*(channels + i) == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 2833
      if (! (*(channels + i))->client_tty) {
        goto __Cont;
      } else {
#line 2833
        if ((*(channels + i))->type != 4) {
          goto __Cont;
        }
      }
    }
#line 2836
    tmp = ioctl((*(channels + i))->rfd, 21523UL, & ws);
#line 2836
    if (tmp < 0) {
      goto __Cont;
    }
#line 2838
    channel_request_start((int )i, (char *)"window-change", 0);
#line 2839
    packet_put_int((unsigned int )ws.ws_col);
#line 2840
    packet_put_int((unsigned int )ws.ws_row);
#line 2841
    packet_put_int((unsigned int )ws.ws_xpixel);
#line 2842
    packet_put_int((unsigned int )ws.ws_ypixel);
#line 2843
    packet_send();
    __Cont: /* CIL Label */ 
#line 2832
    i ++;
  }
#line 2845
  return;
}
}
#line 2854 "channels.c"
int x11_create_display_inet(int x11_display_offset , int x11_use_localhost , int single_connection ,
                            u_int *display_numberp , int **chanids ) 
{ Channel *nc ;
  int display_number ;
  int sock ;
  u_short port___0 ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int n___0 ;
  int num_socks ;
  int socks[10] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int on ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;

  {
#line 2858
  nc = (Channel *)((void *)0);
#line 2863
  num_socks = 0;
#line 2865
  if ((unsigned int )chanids == (unsigned int )((void *)0)) {
#line 2866
    return (-1);
  }
#line 2868
  display_number = x11_display_offset;
#line 2868
  while (display_number < 1000) {
#line 2871
    port___0 = (unsigned short )(6000 + display_number);
#line 2872
    memset((void *)(& hints), 0, sizeof(hints));
#line 2873
    hints.ai_family = IPv4or6;
#line 2874
    if (x11_use_localhost) {
#line 2874
      hints.ai_flags = 0;
    } else {
#line 2874
      hints.ai_flags = 1;
    }
#line 2875
    hints.ai_socktype = 1;
#line 2876
    snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%d",
             port___0);
#line 2877
    gaierr = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )(strport),
                         (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 2877
    if (gaierr != 0) {
#line 2878
      tmp = ssh_gai_strerror(gaierr);
#line 2878
      error("getaddrinfo: %.100s", tmp);
#line 2879
      return (-1);
    }
#line 2881
    ai = aitop;
#line 2881
    while (ai) {
#line 2882
      if (ai->ai_family != 2) {
#line 2882
        if (ai->ai_family != 10) {
          goto __Cont;
        }
      }
#line 2884
      sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 2886
      if (sock < 0) {
#line 2887
        tmp___2 = __errno_location();
#line 2887
        if (*tmp___2 != 22) {
#line 2887
          tmp___3 = __errno_location();
#line 2887
          if (*tmp___3 != 97) {
#line 2888
            tmp___0 = __errno_location();
#line 2888
            tmp___1 = strerror(*tmp___0);
#line 2888
            error("socket: %.100s", tmp___1);
#line 2889
            freeaddrinfo(aitop);
#line 2890
            return (-1);
          } else {
#line 2892
            debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
            goto __Cont;
          }
        } else {
#line 2892
          debug("x11_create_display_inet: Socket family %d not supported", ai->ai_family);
          goto __Cont;
        }
      }
#line 2898
      if (ai->ai_family == 10) {
#line 2899
        on = 1;
#line 2900
        tmp___6 = setsockopt(sock, 41, 26, (void const   *)(& on), sizeof(on));
#line 2900
        if (tmp___6 < 0) {
#line 2901
          tmp___4 = __errno_location();
#line 2901
          tmp___5 = strerror(*tmp___4);
#line 2901
          error("setsockopt IPV6_V6ONLY: %.100s", tmp___5);
        }
      }
#line 2904
      channel_set_reuseaddr(sock);
#line 2905
      tmp___9 = bind(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
#line 2905
      if (tmp___9 < 0) {
#line 2906
        tmp___7 = __errno_location();
#line 2906
        tmp___8 = strerror(*tmp___7);
#line 2906
        debug2("bind port %d: %.100s", port___0, tmp___8);
#line 2907
        close(sock);
#line 2909
        n___0 = 0;
#line 2909
        while (n___0 < num_socks) {
#line 2910
          close(socks[n___0]);
#line 2909
          n___0 ++;
        }
#line 2912
        num_socks = 0;
#line 2913
        break;
      }
#line 2915
      tmp___10 = num_socks;
#line 2915
      num_socks ++;
#line 2915
      socks[tmp___10] = sock;
#line 2920
      if (x11_use_localhost) {
#line 2921
        if (num_socks == 10) {
#line 2922
          break;
        }
      } else {
#line 2924
        break;
      }
      __Cont: /* CIL Label */ 
#line 2881
      ai = ai->ai_next;
    }
#line 2928
    freeaddrinfo(aitop);
#line 2929
    if (num_socks > 0) {
#line 2930
      break;
    }
#line 2868
    display_number ++;
  }
#line 2932
  if (display_number >= 1000) {
#line 2933
    error("Failed to allocate internet-domain X11 display socket.");
#line 2934
    return (-1);
  }
#line 2937
  n___0 = 0;
#line 2937
  while (n___0 < num_socks) {
#line 2938
    sock = socks[n___0];
#line 2939
    tmp___13 = listen(sock, 128);
#line 2939
    if (tmp___13 < 0) {
#line 2940
      tmp___11 = __errno_location();
#line 2940
      tmp___12 = strerror(*tmp___11);
#line 2940
      error("listen: %.100s", tmp___12);
#line 2941
      close(sock);
#line 2942
      return (-1);
    }
#line 2937
    n___0 ++;
  }
#line 2947
  tmp___14 = xcalloc((unsigned int )(num_socks + 1), sizeof(*(*chanids)));
#line 2947
  *chanids = (int *)tmp___14;
#line 2948
  n___0 = 0;
#line 2948
  while (n___0 < num_socks) {
#line 2949
    sock = socks[n___0];
#line 2950
    nc = channel_new((char *)"x11 listener", 1, sock, sock, -1, 65536U, 16384U, 0,
                     (char *)"X11 inet listener", 1);
#line 2954
    nc->single_connection = single_connection;
#line 2955
    *(*chanids + n___0) = nc->self;
#line 2948
    n___0 ++;
  }
#line 2957
  *(*chanids + n___0) = -1;
#line 2960
  *display_numberp = (unsigned int )display_number;
#line 2961
  return (0);
}
}
#line 2964 "channels.c"
static int connect_local_xsocket(u_int dnr ) 
{ int sock ;
  struct sockaddr_un addr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2970
  sock = socket(1, 1, 0);
#line 2971
  if (sock < 0) {
#line 2972
    tmp = __errno_location();
#line 2972
    tmp___0 = strerror(*tmp);
#line 2972
    error("socket: %.100s", tmp___0);
  }
#line 2973
  memset((void *)(& addr), 0, sizeof(addr));
#line 2974
  addr.sun_family = (unsigned short)1;
#line 2975
  snprintf((char * __restrict  )(addr.sun_path), sizeof(addr.sun_path), (char const   * __restrict  )"/tmp/.X11-unix/X%u",
           dnr);
#line 2976
  tmp___1 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                    sizeof(addr));
#line 2976
  if (tmp___1 == 0) {
#line 2977
    return (sock);
  }
#line 2978
  close(sock);
#line 2979
  tmp___2 = __errno_location();
#line 2979
  tmp___3 = strerror(*tmp___2);
#line 2979
  error("connect %.100s: %.100s", addr.sun_path, tmp___3);
#line 2980
  return (-1);
}
}
#line 2983 "channels.c"
int x11_connect_display(void) 
{ u_int display_number ;
  char const   *display ;
  char buf___1[1024] ;
  char *cp ;
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  int sock ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;

  {
#line 2991
  sock = 0;
#line 2994
  tmp = getenv("DISPLAY");
#line 2994
  display = (char const   *)tmp;
#line 2995
  if (! display) {
#line 2996
    error("DISPLAY not set.");
#line 2997
    return (-1);
  }
#line 3008
  if (0) {
#line 3008
    if (0) {
#line 3008
      __s1_len___0 = strlen(display);
#line 3008
      __s2_len___0 = strlen("unix:");
#line 3008
      if (! ((unsigned int )((void const   *)(display + 1)) - (unsigned int )((void const   *)display) == 1U)) {
        goto _L___2;
      } else {
#line 3008
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 3008
          if (! ((unsigned int )((void const   *)("unix:" + 1)) - (unsigned int )((void const   *)"unix:") == 1U)) {
#line 3008
            tmp___25 = 1;
          } else {
#line 3008
            if (__s2_len___0 >= 4U) {
#line 3008
              tmp___25 = 1;
            } else {
#line 3008
              tmp___25 = 0;
            }
          }
        } else {
#line 3008
          tmp___25 = 0;
        }
      }
#line 3008
      if (tmp___25) {
#line 3008
        tmp___21 = __builtin_strcmp(display, "unix:");
      } else {
#line 3008
        tmp___24 = __builtin_strcmp(display, "unix:");
#line 3008
        tmp___21 = tmp___24;
      }
    } else {
#line 3008
      tmp___24 = __builtin_strcmp(display, "unix:");
#line 3008
      tmp___21 = tmp___24;
    }
#line 3008
    tmp___15 = tmp___21;
  } else {
#line 3008
    tmp___15 = strncmp(display, "unix:", 5U);
  }
#line 3008
  if (tmp___15 == 0) {
    goto _L___3;
  } else {
#line 3008
    if ((int const   )*(display + 0) == 58) {
      _L___3: /* CIL Label */ 
#line 3011
      tmp___0 = strrchr(display, ':');
#line 3011
      tmp___1 = sscanf((char const   * __restrict  )(tmp___0 + 1), (char const   * __restrict  )"%u",
                       & display_number);
#line 3011
      if (tmp___1 != 1) {
#line 3012
        error("Could not parse display number from DISPLAY: %.100s", display);
#line 3014
        return (-1);
      }
#line 3017
      sock = connect_local_xsocket(display_number);
#line 3018
      if (sock < 0) {
#line 3019
        return (-1);
      }
#line 3022
      return (sock);
    }
  }
#line 3028
  strlcpy(buf___1, display, sizeof(buf___1));
#line 3029
  tmp___29 = __builtin_strchr(buf___1, ':');
#line 3029
  cp = tmp___29;
#line 3030
  if (! cp) {
#line 3031
    error("Could not find \':\' in DISPLAY: %.100s", display);
#line 3032
    return (-1);
  }
#line 3034
  *cp = (char)0;
#line 3036
  tmp___30 = sscanf((char const   * __restrict  )(cp + 1), (char const   * __restrict  )"%u",
                    & display_number);
#line 3036
  if (tmp___30 != 1) {
#line 3037
    error("Could not parse display number from DISPLAY: %.100s", display);
#line 3039
    return (-1);
  }
#line 3043
  memset((void *)(& hints), 0, sizeof(hints));
#line 3044
  hints.ai_family = IPv4or6;
#line 3045
  hints.ai_socktype = 1;
#line 3046
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%u",
           6000U + display_number);
#line 3047
  gaierr = getaddrinfo((char const   * __restrict  )(buf___1), (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 3047
  if (gaierr != 0) {
#line 3048
    tmp___31 = ssh_gai_strerror(gaierr);
#line 3048
    error("%.100s: unknown host. (%s)", buf___1, tmp___31);
#line 3050
    return (-1);
  }
#line 3052
  ai = aitop;
#line 3052
  while (ai) {
#line 3054
    sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 3055
    if (sock < 0) {
#line 3056
      tmp___32 = __errno_location();
#line 3056
      tmp___33 = strerror(*tmp___32);
#line 3056
      debug2("socket: %.100s", tmp___33);
      goto __Cont;
    }
#line 3060
    tmp___36 = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                       ai->ai_addrlen);
#line 3060
    if (tmp___36 < 0) {
#line 3061
      tmp___34 = __errno_location();
#line 3061
      tmp___35 = strerror(*tmp___34);
#line 3061
      debug2("connect %.100s port %u: %.100s", buf___1, 6000U + display_number, tmp___35);
#line 3063
      close(sock);
      goto __Cont;
    }
#line 3067
    break;
    __Cont: /* CIL Label */ 
#line 3052
    ai = ai->ai_next;
  }
#line 3069
  freeaddrinfo(aitop);
#line 3070
  if (! ai) {
#line 3071
    tmp___37 = __errno_location();
#line 3071
    tmp___38 = strerror(*tmp___37);
#line 3071
    error("connect %.100s port %u: %.100s", buf___1, 6000U + display_number, tmp___38);
#line 3073
    return (-1);
  }
#line 3075
  set_nodelay(sock);
#line 3076
  return (sock);
}
}
#line 3086 "channels.c"
void x11_input_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int remote_id ;
  int sock ;
  char *remote_host ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 3089
  c = (Channel *)((void *)0);
#line 3090
  sock = 0;
#line 3093
  debug("Received X11 open request.");
#line 3095
  tmp = packet_get_int();
#line 3095
  remote_id = (int )tmp;
#line 3097
  tmp___1 = packet_get_protocol_flags();
#line 3097
  if (tmp___1 & 2U) {
#line 3098
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 3098
    remote_host = (char *)tmp___0;
  } else {
#line 3100
    remote_host = xstrdup("unknown (remote did not supply name)");
  }
#line 3102
  while (1) {
#line 3102
    tmp___2 = packet_remaining();
#line 3102
    _len = tmp___2;
#line 3102
    if (_len > 0) {
#line 3102
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "channels.c",
            3102);
#line 3102
      packet_disconnect("Packet integrity error.");
    }
#line 3102
    break;
  }
#line 3105
  sock = x11_connect_display();
#line 3106
  if (sock != -1) {
#line 3108
    c = channel_new((char *)"connected x11 socket", 7, sock, sock, -1, 0U, 0U, 0,
                    remote_host, 1);
#line 3111
    c->remote_id = remote_id;
#line 3112
    c->force_drain = 1;
  }
#line 3114
  xfree((void *)remote_host);
#line 3115
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 3117
    packet_start((unsigned char)22);
#line 3118
    packet_put_int((unsigned int )remote_id);
  } else {
#line 3121
    packet_start((unsigned char)21);
#line 3122
    packet_put_int((unsigned int )remote_id);
#line 3123
    packet_put_int((unsigned int )c->self);
  }
#line 3125
  packet_send();
#line 3126
  return;
}
}
#line 3130 "channels.c"
void deny_input_open(int type , u_int32_t seq , void *ctxt ) 
{ int rchan ;
  u_int tmp ;

  {
#line 3133
  tmp = packet_get_int();
#line 3133
  rchan = (int )tmp;
#line 3135
  switch (type) {
  case 31: 
#line 3137
  error("Warning: ssh server tried agent forwarding.");
#line 3138
  break;
  case 27: 
#line 3140
  error("Warning: ssh server tried X11 forwarding.");
#line 3141
  break;
  default: 
#line 3143
  error("deny_input_open: type %d", type);
#line 3144
  break;
  }
#line 3146
  error("Warning: this is probably a break-in attempt by a malicious server.");
#line 3147
  packet_start((unsigned char)22);
#line 3148
  packet_put_int((unsigned int )rchan);
#line 3149
  packet_send();
#line 3150
  return;
}
}
#line 3157 "channels.c"
void x11_request_forwarding_with_spoofing(int client_session_id , char const   *disp ,
                                          char const   *proto , char const   *data ) 
{ u_int data_len ;
  size_t tmp ;
  u_int i ;
  u_int value ;
  char *new_data ;
  int screen_number ;
  char const   *cp ;
  u_int32_t rnd ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  long long tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;

  {
#line 3161
  tmp = strlen(data);
#line 3161
  data_len = tmp / 2U;
#line 3166
  rnd = (u_int32_t )0;
#line 3168
  if ((unsigned int )x11_saved_display == (unsigned int )((void *)0)) {
#line 3169
    x11_saved_display = xstrdup(disp);
  } else {
#line 3170
    if (0) {
#line 3170
      __s1_len = strlen(disp);
#line 3170
      __s2_len = strlen((char const   *)x11_saved_display);
#line 3170
      if (! ((unsigned int )((void const   *)(disp + 1)) - (unsigned int )((void const   *)disp) == 1U)) {
        goto _L___0;
      } else {
#line 3170
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 3170
          if (! ((unsigned int )((void const   *)(x11_saved_display + 1)) - (unsigned int )((void const   *)x11_saved_display) == 1U)) {
#line 3170
            tmp___9 = 1;
          } else {
#line 3170
            if (__s2_len >= 4U) {
#line 3170
              tmp___9 = 1;
            } else {
#line 3170
              tmp___9 = 0;
            }
          }
        } else {
#line 3170
          tmp___9 = 0;
        }
      }
#line 3170
      if (tmp___9) {
#line 3170
        tmp___5 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
      } else {
#line 3170
        tmp___8 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
#line 3170
        tmp___5 = tmp___8;
      }
    } else {
#line 3170
      tmp___8 = __builtin_strcmp(disp, (char const   *)x11_saved_display);
#line 3170
      tmp___5 = tmp___8;
    }
#line 3170
    if (tmp___5 != 0) {
#line 3171
      error("x11_request_forwarding_with_spoofing: different $DISPLAY already forwarded");
#line 3173
      return;
    }
  }
#line 3176
  tmp___11 = __builtin_strchr((char *)disp, ':');
#line 3176
  cp = (char const   *)tmp___11;
#line 3177
  if (cp) {
#line 3178
    tmp___13 = __builtin_strchr((char *)cp, '.');
#line 3178
    cp = (char const   *)tmp___13;
  }
#line 3179
  if (cp) {
#line 3180
    tmp___14 = strtonum(cp + 1, 0LL, 400LL, (char const   **)((void *)0));
#line 3180
    screen_number = (int )((unsigned int )tmp___14);
  } else {
#line 3182
    screen_number = 0;
  }
#line 3184
  if ((unsigned int )x11_saved_proto == (unsigned int )((void *)0)) {
#line 3186
    x11_saved_proto = xstrdup(proto);
#line 3191
    tmp___15 = xmalloc(data_len);
#line 3191
    x11_saved_data = (char *)tmp___15;
#line 3192
    tmp___16 = xmalloc(data_len);
#line 3192
    x11_fake_data = (u_char *)tmp___16;
#line 3193
    i = 0U;
#line 3193
    while (i < data_len) {
#line 3194
      tmp___17 = sscanf((char const   * __restrict  )(data + 2U * i), (char const   * __restrict  )"%2x",
                        & value);
#line 3194
      if (tmp___17 != 1) {
#line 3195
        fatal("x11_request_forwarding: bad authentication data: %.100s", data);
      }
#line 3197
      if (i % 4U == 0U) {
#line 3198
        rnd = arc4random();
      }
#line 3199
      *(x11_saved_data + i) = (char )value;
#line 3200
      *(x11_fake_data + i) = (unsigned char )(rnd & 255U);
#line 3201
      rnd >>= 8;
#line 3193
      i ++;
    }
#line 3203
    x11_saved_data_len = data_len;
#line 3204
    x11_fake_data_len = data_len;
  }
#line 3208
  new_data = tohex((void const   *)x11_fake_data, data_len);
#line 3211
  if (compat20) {
#line 3212
    channel_request_start(client_session_id, (char *)"x11-req", 0);
#line 3213
    packet_put_char(0);
  } else {
#line 3215
    packet_start((unsigned char)34);
  }
#line 3217
  packet_put_cstring(proto);
#line 3218
  packet_put_cstring((char const   *)new_data);
#line 3219
  packet_put_int((unsigned int )screen_number);
#line 3220
  packet_send();
#line 3221
  packet_write_wait();
#line 3222
  xfree((void *)new_data);
#line 3223
  return;
}
}
#line 3230 "channels.c"
void auth_request_forwarding(void) 
{ 

  {
#line 3233
  packet_start((unsigned char)30);
#line 3234
  packet_send();
#line 3235
  packet_write_wait();
#line 3236
  return;
}
}
#line 1 "cipher.o"
#line 54 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 1205 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 527 "/usr/include/openssl/evp.h"
extern int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER const   *cipher , unsigned char const   *key ,
                          unsigned char const   *iv , int enc ) ;
#line 567
extern void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a ) ;
#line 568
extern int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a ) ;
#line 571
extern int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x , int keylen ) ;
#line 613
extern EVP_CIPHER const   *EVP_enc_null(void) ;
#line 637
extern EVP_CIPHER const   *EVP_des_cbc(void) ;
#line 652
extern EVP_CIPHER const   *EVP_rc4(void) ;
#line 666
extern EVP_CIPHER const   *EVP_bf_cbc(void) ;
#line 673
extern EVP_CIPHER const   *EVP_cast5_cbc(void) ;
#line 680
extern EVP_CIPHER const   *EVP_aes_128_cbc(void) ;
#line 690
extern EVP_CIPHER const   *EVP_aes_192_cbc(void) ;
#line 700
extern EVP_CIPHER const   *EVP_aes_256_cbc(void) ;
#line 71 "cipher.h"
u_int cipher_mask_ssh1(int client ) ;
#line 72
Cipher *cipher_by_name(char const   *name ) ;
#line 74
int cipher_number(char const   *name ) ;
#line 75
char *cipher_name(int id ) ;
#line 76
int ciphers_valid(char const   *names ) ;
#line 77
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int do_encrypt ) ;
#line 82
u_int cipher_blocksize(Cipher const   *c ) ;
#line 83
u_int cipher_keylen(Cipher const   *c ) ;
#line 85
u_int cipher_get_number(Cipher const   *c ) ;
#line 86
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) ;
#line 87
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) ;
#line 88
int cipher_get_keyiv_len(CipherContext const   *cc ) ;
#line 89
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) ;
#line 90
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) ;
#line 52 "openbsd-compat/openssl-compat.h"
EVP_CIPHER const   *evp_acss(void) ;
#line 54 "cipher.c"
EVP_CIPHER const   *evp_ssh1_bf(void) ;
#line 55
EVP_CIPHER const   *evp_ssh1_3des(void) ;
#line 56
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) ;
#line 57
EVP_CIPHER const   *evp_aes_128_ctr(void) ;
#line 58
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) ;
#line 60 "cipher.c"
struct Cipher ciphers[19]  = 
#line 60
  {      {(char *)"none", 0, (u_int )8, (u_int )0, (u_int )0, & EVP_enc_null}, 
        {(char *)"des", 2, (u_int )8, (u_int )8, (u_int )0, & EVP_des_cbc}, 
        {(char *)"3des", 3, (u_int )8, (u_int )16, (u_int )0, & evp_ssh1_3des}, 
        {(char *)"blowfish", 6, (u_int )8, (u_int )32, (u_int )0, & evp_ssh1_bf}, 
        {(char *)"3des-cbc", -3, (u_int )8, (u_int )24, (u_int )0, & EVP_des_ede3_cbc}, 
        {(char *)"blowfish-cbc",
      -3, (u_int )8, (u_int )16, (u_int )0, & EVP_bf_cbc}, 
        {(char *)"cast128-cbc", -3, (u_int )8, (u_int )16, (u_int )0, & EVP_cast5_cbc}, 
        {(char *)"arcfour",
      -3, (u_int )8, (u_int )16, (u_int )0, & EVP_rc4}, 
        {(char *)"arcfour128", -3, (u_int )8, (u_int )16, (u_int )1536, & EVP_rc4}, 
        {(char *)"arcfour256", -3, (u_int )8, (u_int )32, (u_int )1536, & EVP_rc4}, 
        {(char *)"aes128-cbc", -3, (u_int )16, (u_int )16, (u_int )0, & EVP_aes_128_cbc}, 
        {(char *)"aes192-cbc",
      -3, (u_int )16, (u_int )24, (u_int )0, & EVP_aes_192_cbc}, 
        {(char *)"aes256-cbc", -3, (u_int )16, (u_int )32, (u_int )0, & EVP_aes_256_cbc}, 
        {(char *)"rijndael-cbc@lysator.liu.se",
      -3, (u_int )16, (u_int )32, (u_int )0, & EVP_aes_256_cbc}, 
        {(char *)"aes128-ctr", -3, (u_int )16, (u_int )16, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"aes192-ctr",
      -3, (u_int )16, (u_int )24, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"aes256-ctr", -3, (u_int )16, (u_int )32, (u_int )0, & evp_aes_128_ctr}, 
        {(char *)"acss@openssh.org",
      -3, (u_int )16, (u_int )5, (u_int )0, & evp_acss}, 
        {(char *)((void *)0), -2, (u_int )0, (u_int )0, (u_int )0, (EVP_CIPHER const   *(*)(void))((void *)0)}};
#line 95 "cipher.c"
u_int cipher_blocksize(Cipher const   *c ) 
{ 

  {
#line 98
  return ((unsigned int )c->block_size);
}
}
#line 101 "cipher.c"
u_int cipher_keylen(Cipher const   *c ) 
{ 

  {
#line 104
  return ((unsigned int )c->key_len);
}
}
#line 107 "cipher.c"
u_int cipher_get_number(Cipher const   *c ) 
{ 

  {
#line 110
  return ((unsigned int )c->number);
}
}
#line 113 "cipher.c"
u_int cipher_mask_ssh1(int client ) 
{ u_int mask ;

  {
#line 116
  mask = (u_int )0;
#line 117
  mask |= (unsigned int )(1 << 3);
#line 118
  mask |= (unsigned int )(1 << 6);
#line 119
  if (client) {
#line 120
    mask |= (unsigned int )(1 << 2);
  }
#line 122
  return (mask);
}
}
#line 125 "cipher.c"
Cipher *cipher_by_name(char const   *name ) 
{ Cipher *c ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 129
  c = ciphers;
#line 129
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 130
    if (0) {
#line 130
      __s1_len = strlen((char const   *)c->name);
#line 130
      __s2_len = strlen(name);
#line 130
      if (! ((unsigned int )((void const   *)(c->name + 1)) - (unsigned int )((void const   *)c->name) == 1U)) {
        goto _L___0;
      } else {
#line 130
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 130
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 130
            tmp___8 = 1;
          } else {
#line 130
            if (__s2_len >= 4U) {
#line 130
              tmp___8 = 1;
            } else {
#line 130
              tmp___8 = 0;
            }
          }
        } else {
#line 130
          tmp___8 = 0;
        }
      }
#line 130
      if (tmp___8) {
#line 130
        tmp___4 = __builtin_strcmp((char const   *)c->name, name);
      } else {
#line 130
        tmp___7 = __builtin_strcmp((char const   *)c->name, name);
#line 130
        tmp___4 = tmp___7;
      }
    } else {
#line 130
      tmp___7 = __builtin_strcmp((char const   *)c->name, name);
#line 130
      tmp___4 = tmp___7;
    }
#line 130
    if (tmp___4 == 0) {
#line 131
      return (c);
    }
#line 129
    c ++;
  }
#line 132
  return ((Cipher *)((void *)0));
}
}
#line 135 "cipher.c"
Cipher *cipher_by_number(int id ) 
{ Cipher *c ;

  {
#line 139
  c = ciphers;
#line 139
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 140
    if (c->number == id) {
#line 141
      return (c);
    }
#line 139
    c ++;
  }
#line 142
  return ((Cipher *)((void *)0));
}
}
#line 146 "cipher.c"
int ciphers_valid(char const   *names ) 
{ Cipher *c ;
  char *cipher_list ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;

  {
#line 153
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 154
    return (0);
  } else {
#line 153
    if (0) {
#line 153
      __s1_len = strlen(names);
#line 153
      __s2_len = strlen("");
#line 153
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 153
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 153
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 153
            tmp___8 = 1;
          } else {
#line 153
            if (__s2_len >= 4U) {
#line 153
              tmp___8 = 1;
            } else {
#line 153
              tmp___8 = 0;
            }
          }
        } else {
#line 153
          tmp___8 = 0;
        }
      }
#line 153
      if (tmp___8) {
#line 153
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 153
        tmp___7 = __builtin_strcmp(names, "");
#line 153
        tmp___4 = tmp___7;
      }
    } else {
#line 153
      tmp___7 = __builtin_strcmp(names, "");
#line 153
      tmp___4 = tmp___7;
    }
#line 153
    if (tmp___4 == 0) {
#line 154
      return (0);
    }
  }
#line 155
  cp = xstrdup(names);
#line 155
  cipher_list = cp;
#line 156
  tmp___24 = __strsep_g(& cp, ",");
#line 156
  p = tmp___24;
#line 156
  while (1) {
#line 156
    if (p) {
#line 156
      if (! ((int )*p != 0)) {
#line 156
        break;
      }
    } else {
#line 156
      break;
    }
#line 158
    c = cipher_by_name((char const   *)p);
#line 159
    if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 160
      debug("bad cipher %s [%s]", p, names);
#line 161
      xfree((void *)cipher_list);
#line 162
      return (0);
    } else {
#line 159
      if (c->number != -3) {
#line 160
        debug("bad cipher %s [%s]", p, names);
#line 161
        xfree((void *)cipher_list);
#line 162
        return (0);
      } else {
#line 164
        debug3("cipher ok: %s [%s]", p, names);
      }
    }
#line 157
    tmp___40 = __strsep_g(& cp, ",");
#line 157
    p = tmp___40;
  }
#line 167
  debug3("ciphers ok: [%s]", names);
#line 168
  xfree((void *)cipher_list);
#line 169
  return (1);
}
}
#line 177 "cipher.c"
int cipher_number(char const   *name ) 
{ Cipher *c ;
  int tmp ;

  {
#line 181
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 182
    return (-1);
  }
#line 183
  c = ciphers;
#line 183
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
#line 184
    tmp = strcasecmp((char const   *)c->name, name);
#line 184
    if (tmp == 0) {
#line 185
      return (c->number);
    }
#line 183
    c ++;
  }
#line 186
  return (-1);
}
}
#line 189 "cipher.c"
char *cipher_name(int id ) 
{ Cipher *c ;
  Cipher *tmp ;
  char const   *tmp___0 ;

  {
#line 192
  tmp = cipher_by_number(id);
#line 192
  c = tmp;
#line 193
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 193
    tmp___0 = "<unknown>";
  } else {
#line 193
    tmp___0 = (char const   *)c->name;
  }
#line 193
  return ((char *)tmp___0);
}
}
#line 201 "cipher.c"
static int dowarn  =    1;
#line 196 "cipher.c"
void cipher_init(CipherContext *cc , Cipher *cipher , u_char const   *key , u_int keylen ,
                 u_char const   *iv , u_int ivlen , int do_encrypt ) 
{ EVP_CIPHER const   *type ;
  int klen ;
  u_char *junk ;
  u_char *discard ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 210
  if (cipher->number == 2) {
#line 211
    if (dowarn) {
#line 212
      error("Warning: use of DES is strongly discouraged due to cryptographic weaknesses");
#line 214
      dowarn = 0;
    }
#line 216
    if (keylen > 8U) {
#line 217
      keylen = 8U;
    }
  }
#line 219
  cc->plaintext = cipher->number == 0;
#line 221
  if (keylen < cipher->key_len) {
#line 222
    fatal("cipher_init: key length %d is insufficient for %s.", keylen, cipher->name);
  }
#line 224
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 224
    if (ivlen < cipher->block_size) {
#line 225
      fatal("cipher_init: iv length %d is insufficient for %s.", ivlen, cipher->name);
    }
  }
#line 227
  cc->cipher = cipher;
#line 229
  type = (*(cipher->evptype))();
#line 231
  EVP_CIPHER_CTX_init(& cc->evp);
#line 241
  tmp = EVP_CipherInit(& cc->evp, type, (unsigned char const   *)((void *)0), (unsigned char const   *)((u_char *)iv),
                       do_encrypt == 1);
#line 241
  if (tmp == 0) {
#line 243
    fatal("cipher_init: EVP_CipherInit failed for %s", cipher->name);
  }
#line 245
  klen = cc->evp.key_len;
#line 246
  if (klen > 0) {
#line 246
    if (keylen != (unsigned int )klen) {
#line 247
      debug2("cipher_init: set keylen (%d -> %d)", klen, keylen);
#line 248
      tmp___0 = EVP_CIPHER_CTX_set_key_length(& cc->evp, (int )keylen);
#line 248
      if (tmp___0 == 0) {
#line 249
        fatal("cipher_init: set keylen failed (%d -> %d)", klen, keylen);
      }
    }
  }
#line 252
  tmp___1 = EVP_CipherInit(& cc->evp, (EVP_CIPHER const   *)((void *)0), (unsigned char const   *)((u_char *)key),
                           (unsigned char const   *)((void *)0), -1);
#line 252
  if (tmp___1 == 0) {
#line 253
    fatal("cipher_init: EVP_CipherInit: set key failed for %s", cipher->name);
  }
#line 257
  if (cipher->discard_len > 0U) {
#line 258
    tmp___2 = xmalloc(cipher->discard_len);
#line 258
    junk = (u_char *)tmp___2;
#line 259
    tmp___3 = xmalloc(cipher->discard_len);
#line 259
    discard = (u_char *)tmp___3;
#line 260
    tmp___4 = (*((cc->evp.cipher)->do_cipher))(& cc->evp, discard, (unsigned char const   *)junk,
                                               cipher->discard_len);
#line 260
    if (tmp___4 == 0) {
#line 262
      fatal("evp_crypt: EVP_Cipher failed during discard");
    }
#line 263
    memset((void *)discard, 0, cipher->discard_len);
#line 264
    xfree((void *)junk);
#line 265
    xfree((void *)discard);
  }
#line 267
  return;
}
}
#line 269 "cipher.c"
void cipher_crypt(CipherContext *cc , u_char *dest , u_char const   *src , u_int len ) 
{ int tmp ;

  {
#line 272
  if (len % (cc->cipher)->block_size) {
#line 273
    fatal("cipher_encrypt: bad plaintext length %d", len);
  }
#line 274
  tmp = (*((cc->evp.cipher)->do_cipher))(& cc->evp, dest, (unsigned char const   *)((u_char *)src),
                                         len);
#line 274
  if (tmp == 0) {
#line 275
    fatal("evp_crypt: EVP_Cipher failed");
  }
#line 276
  return;
}
}
#line 278 "cipher.c"
void cipher_cleanup(CipherContext *cc ) 
{ int tmp ;

  {
#line 281
  tmp = EVP_CIPHER_CTX_cleanup(& cc->evp);
#line 281
  if (tmp == 0) {
#line 282
    error("cipher_cleanup: EVP_CIPHER_CTX_cleanup failed");
  }
#line 283
  return;
}
}
#line 290 "cipher.c"
void cipher_set_key_string(CipherContext *cc , Cipher *cipher , char const   *passphrase ,
                           int do_encrypt ) 
{ MD5_CTX md ;
  u_char digest___1[16] ;
  size_t tmp ;

  {
#line 297
  MD5_Init(& md);
#line 298
  tmp = strlen(passphrase);
#line 298
  MD5_Update(& md, (void const   *)((u_char const   *)passphrase), tmp);
#line 299
  MD5_Final(digest___1, & md);
#line 301
  cipher_init(cc, cipher, (u_char const   *)(digest___1), 16U, (u_char const   *)((void *)0),
              0U, do_encrypt);
#line 303
  memset((void *)(digest___1), 0, sizeof(digest___1));
#line 304
  memset((void *)(& md), 0, sizeof(md));
#line 305
  return;
}
}
#line 313 "cipher.c"
int cipher_get_keyiv_len(CipherContext const   *cc ) 
{ Cipher *c ;
  int ivlen ;

  {
#line 316
  c = (Cipher *)cc->cipher;
#line 319
  if (c->number == 3) {
#line 320
    ivlen = 24;
  } else {
#line 322
    ivlen = (int )(cc->evp.cipher)->iv_len;
  }
#line 323
  return (ivlen);
}
}
#line 326 "cipher.c"
void cipher_get_keyiv(CipherContext *cc , u_char *iv , u_int len ) 
{ Cipher *c ;
  int evplen ;

  {
#line 329
  c = cc->cipher;
#line 332
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 336
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 337
  if (evplen <= 0) {
#line 338
    return;
  }
#line 339
  if ((unsigned int )evplen != len) {
#line 340
    fatal("%s: wrong iv length %d != %d", "cipher_get_keyiv", evplen, len);
  }
#line 347
  if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 348
    ssh_aes_ctr_iv(& cc->evp, 0, iv, len);
  } else {
#line 350
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(cc->evp.iv), len);
  }
#line 351
  break;
  case 3: 
#line 353
  ssh1_3des_iv(& cc->evp, 0, iv, 24);
#line 354
  break;
  default: 
#line 356
  fatal("%s: bad cipher %d", "cipher_get_keyiv", c->number);
  }
#line 358
  return;
}
}
#line 360 "cipher.c"
void cipher_set_keyiv(CipherContext *cc , u_char *iv ) 
{ Cipher *c ;
  int evplen ;

  {
#line 363
  c = cc->cipher;
#line 364
  evplen = 0;
#line 366
  switch (c->number) {
  case -3: 
  case 2: 
  case 6: 
#line 370
  evplen = (int )(cc->evp.cipher)->iv_len;
#line 371
  if (evplen == 0) {
#line 372
    return;
  }
#line 378
  if ((unsigned int )c->evptype == (unsigned int )(& evp_aes_128_ctr)) {
#line 379
    ssh_aes_ctr_iv(& cc->evp, 1, iv, (unsigned int )evplen);
  } else {
#line 381
    memcpy((void * __restrict  )(cc->evp.iv), (void const   * __restrict  )iv, (unsigned int )evplen);
  }
#line 382
  break;
  case 3: 
#line 384
  ssh1_3des_iv(& cc->evp, 1, iv, 24);
#line 385
  break;
  default: 
#line 387
  fatal("%s: bad cipher %d", "cipher_set_keyiv", c->number);
  }
#line 389
  return;
}
}
#line 399 "cipher.c"
int cipher_get_keycontext(CipherContext const   *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 402
  c = (Cipher *)cc->cipher;
#line 403
  plen = 0;
#line 405
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
    goto _L;
  } else {
#line 405
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
      _L: /* CIL Label */ 
#line 406
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 407
      if ((unsigned int )dat == (unsigned int )((void *)0)) {
#line 408
        return (plen);
      }
#line 409
      memcpy((void * __restrict  )dat, (void const   * __restrict  )cc->evp.cipher_data,
             (unsigned int )plen);
    }
  }
#line 411
  return (plen);
}
}
#line 414 "cipher.c"
void cipher_set_keycontext(CipherContext *cc , u_char *dat ) 
{ Cipher *c ;
  int plen ;

  {
#line 417
  c = cc->cipher;
#line 420
  if ((unsigned int )c->evptype == (unsigned int )(& EVP_rc4)) {
#line 421
    plen = (int )(cc->evp.cipher)->ctx_size;
#line 422
    memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
           (unsigned int )plen);
  } else {
#line 420
    if ((unsigned int )c->evptype == (unsigned int )(& evp_acss)) {
#line 421
      plen = (int )(cc->evp.cipher)->ctx_size;
#line 422
      memcpy((void * __restrict  )cc->evp.cipher_data, (void const   * __restrict  )dat,
             (unsigned int )plen);
    }
  }
#line 424
  return;
}
}
#line 1 "cipher-acss.o"
#line 36 "cipher-acss.c"
static int acss_init_key(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
                         int enc ) 
{ 

  {
#line 40
  acss_setkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, key, enc, 3);
#line 41
  return (1);
}
}
#line 44 "cipher-acss.c"
static int acss_ciph(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                     unsigned int inl ) 
{ 

  {
#line 48
  acss(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned long )inl, in, out);
#line 49
  return (1);
}
}
#line 52 "cipher-acss.c"
static int acss_ctrl(EVP_CIPHER_CTX *ctx , int type , int arg , void *ptr ) 
{ 

  {
#line 55
  switch (type) {
  case 65286: 
#line 57
  ((EVP_ACSS_KEY *)ctx->cipher_data)->ks.mode = arg;
#line 58
  return (1);
  case 65287: 
#line 60
  acss_setsubkey(& ((EVP_ACSS_KEY *)ctx->cipher_data)->ks, (unsigned char const   *)((unsigned char *)ptr));
#line 61
  return (1);
  default: ;
#line 63
  return (-1);
  }
}
}
#line 70 "cipher-acss.c"
static EVP_CIPHER acss_cipher  ;
#line 67 "cipher-acss.c"
EVP_CIPHER const   *evp_acss(void) 
{ 

  {
#line 72
  memset((void *)(& acss_cipher), 0, sizeof(EVP_CIPHER ));
#line 74
  acss_cipher.nid = 0;
#line 75
  acss_cipher.block_size = 1;
#line 76
  acss_cipher.key_len = 5;
#line 77
  acss_cipher.init = & acss_init_key;
#line 78
  acss_cipher.do_cipher = & acss_ciph;
#line 79
  acss_cipher.ctx_size = (int )sizeof(EVP_ACSS_KEY );
#line 80
  acss_cipher.ctrl = & acss_ctrl;
#line 82
  return ((EVP_CIPHER const   *)(& acss_cipher));
}
}
#line 1 "cipher-aes.o"
#line 1 "cipher-bf1.o"
#line 47 "cipher-bf1.c"
static void swap_bytes(u_char const   *src , u_char *dst , int n___0 ) 
{ u_char c[4] ;
  u_char const   *tmp ;
  u_char const   *tmp___0 ;
  u_char const   *tmp___1 ;
  u_char const   *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 53
  n___0 /= 4;
#line 53
  while (n___0 > 0) {
#line 54
    tmp = src;
#line 54
    src ++;
#line 54
    c[3] = (unsigned char )*tmp;
#line 55
    tmp___0 = src;
#line 55
    src ++;
#line 55
    c[2] = (unsigned char )*tmp___0;
#line 56
    tmp___1 = src;
#line 56
    src ++;
#line 56
    c[1] = (unsigned char )*tmp___1;
#line 57
    tmp___2 = src;
#line 57
    src ++;
#line 57
    c[0] = (unsigned char )*tmp___2;
#line 59
    tmp___3 = dst;
#line 59
    dst ++;
#line 59
    *tmp___3 = c[0];
#line 60
    tmp___4 = dst;
#line 60
    dst ++;
#line 60
    *tmp___4 = c[1];
#line 61
    tmp___5 = dst;
#line 61
    dst ++;
#line 61
    *tmp___5 = c[2];
#line 62
    tmp___6 = dst;
#line 62
    dst ++;
#line 62
    *tmp___6 = c[3];
#line 53
    n___0 --;
  }
#line 64
  return;
}
}
#line 79 "cipher-bf1.c"
static int (*orig_bf)(EVP_CIPHER_CTX * , u_char * , u_char const   * , u_int  )  =    (int (*)(EVP_CIPHER_CTX * ,
            u_char * , u_char const   * , u_int  ))((void *)0);
#line 81 "cipher-bf1.c"
static int bf_ssh1_cipher(EVP_CIPHER_CTX *ctx , u_char *out , u_char const   *in ,
                          u_int len ) 
{ int ret___0 ;

  {
#line 86
  swap_bytes(in, out, (int )len);
#line 87
  ret___0 = (*orig_bf)(ctx, out, (u_char const   *)out, len);
#line 88
  swap_bytes((u_char const   *)out, out, (int )len);
#line 89
  return (ret___0);
}
}
#line 95 "cipher-bf1.c"
static EVP_CIPHER ssh1_bf  ;
#line 92 "cipher-bf1.c"
EVP_CIPHER const   *evp_ssh1_bf(void) 
{ EVP_CIPHER const   *tmp ;

  {
#line 97
  tmp = EVP_bf_cbc();
#line 97
  memcpy((void * __restrict  )(& ssh1_bf), (void const   * __restrict  )tmp, sizeof(EVP_CIPHER ));
#line 98
  orig_bf = ssh1_bf.do_cipher;
#line 99
  ssh1_bf.nid = 0;
#line 103
  ssh1_bf.do_cipher = & bf_ssh1_cipher;
#line 104
  ssh1_bf.key_len = 32;
#line 105
  return ((EVP_CIPHER const   *)(& ssh1_bf));
}
}
#line 1 "cipher-ctr.o"
#line 86 "/usr/include/openssl/aes.h"
extern int AES_set_encrypt_key(unsigned char const   *userKey , int bits , AES_KEY *key ) ;
#line 91
extern void AES_encrypt(unsigned char const   *in , unsigned char *out , AES_KEY const   *key ) ;
#line 50 "cipher-ctr.c"
static void ssh_ctr_inc(u_char *ctr , u_int len ) 
{ int i ;

  {
#line 55
  i = (int )(len - 1U);
#line 55
  while (i >= 0) {
#line 56
    *(ctr + i) = (u_char )((int )*(ctr + i) + 1);
#line 56
    if (*(ctr + i)) {
#line 57
      return;
    }
#line 55
    i --;
  }
#line 58
  return;
}
}
#line 60 "cipher-ctr.c"
static int ssh_aes_ctr(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                       u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;
  u_int n___0 ;
  u_char buf___1[16] ;
  u_char *tmp ;
  u_char const   *tmp___0 ;
  u_int tmp___1 ;

  {
#line 65
  n___0 = (u_int )0;
#line 68
  if (len == 0U) {
#line 69
    return (1);
  }
#line 70
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 70
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 71
    return (0);
  }
#line 73
  while (1) {
#line 73
    tmp___1 = len;
#line 73
    len --;
#line 73
    if (! (tmp___1 > 0U)) {
#line 73
      break;
    }
#line 74
    if (n___0 == 0U) {
#line 75
      AES_encrypt((unsigned char const   *)(c->aes_counter), buf___1, (AES_KEY const   *)(& c->aes_ctx));
#line 76
      ssh_ctr_inc(c->aes_counter, 16U);
    }
#line 78
    tmp = dest;
#line 78
    dest ++;
#line 78
    tmp___0 = src;
#line 78
    src ++;
#line 78
    *tmp = (unsigned char )((int const   )*tmp___0 ^ (int const   )buf___1[n___0]);
#line 79
    n___0 = (n___0 + 1U) % 16U;
  }
#line 81
  return (1);
}
}
#line 84 "cipher-ctr.c"
static int ssh_aes_ctr_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                            int enc ) 
{ struct ssh_aes_ctr_ctx *c ;
  void *tmp ;

  {
#line 90
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 90
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 91
    tmp = xmalloc(sizeof(*c));
#line 91
    c = (struct ssh_aes_ctr_ctx *)tmp;
#line 92
    ctx->app_data = (void *)((char *)c);
  }
#line 94
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 95
    AES_set_encrypt_key(key, ctx->key_len * 8, & c->aes_ctx);
  }
#line 97
  if ((unsigned int )iv != (unsigned int )((void *)0)) {
#line 98
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           16U);
  }
#line 99
  return (1);
}
}
#line 102 "cipher-ctr.c"
static int ssh_aes_ctr_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 107
  c = (struct ssh_aes_ctr_ctx *)ctx->app_data;
#line 107
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 108
    memset((void *)c, 0, sizeof(*c));
#line 109
    xfree((void *)c);
#line 110
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 112
  return (1);
}
}
#line 115 "cipher-ctr.c"
void ssh_aes_ctr_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , u_int len ) 
{ struct ssh_aes_ctr_ctx *c ;

  {
#line 120
  c = (struct ssh_aes_ctr_ctx *)evp->app_data;
#line 120
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 121
    fatal("ssh_aes_ctr_iv: no context");
  }
#line 122
  if (doset) {
#line 123
    memcpy((void * __restrict  )(c->aes_counter), (void const   * __restrict  )iv,
           len);
  } else {
#line 125
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->aes_counter),
           len);
  }
#line 126
  return;
}
}
#line 131 "cipher-ctr.c"
static EVP_CIPHER aes_ctr  ;
#line 128 "cipher-ctr.c"
EVP_CIPHER const   *evp_aes_128_ctr(void) 
{ 

  {
#line 133
  memset((void *)(& aes_ctr), 0, sizeof(EVP_CIPHER ));
#line 134
  aes_ctr.nid = 0;
#line 135
  aes_ctr.block_size = 16;
#line 136
  aes_ctr.iv_len = 16;
#line 137
  aes_ctr.key_len = 16;
#line 138
  aes_ctr.init = & ssh_aes_ctr_init;
#line 139
  aes_ctr.cleanup = & ssh_aes_ctr_cleanup;
#line 140
  aes_ctr.do_cipher = & ssh_aes_ctr;
#line 142
  aes_ctr.flags = 58UL;
#line 145
  return ((EVP_CIPHER const   *)(& aes_ctr));
}
}
#line 1 "cipher-3des1.o"
#line 62 "cipher-3des1.c"
static int ssh1_3des_init(EVP_CIPHER_CTX *ctx , u_char const   *key , u_char const   *iv ,
                          int enc ) 
{ struct ssh1_3des_ctx *c ;
  u_char *k1 ;
  u_char *k2 ;
  u_char *k3 ;
  void *tmp ;
  EVP_CIPHER const   *tmp___0 ;
  int tmp___1 ;
  EVP_CIPHER const   *tmp___2 ;
  int tmp___3 ;
  EVP_CIPHER const   *tmp___4 ;
  int tmp___5 ;

  {
#line 69
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 69
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 70
    tmp = xmalloc(sizeof(*c));
#line 70
    c = (struct ssh1_3des_ctx *)tmp;
#line 71
    ctx->app_data = (void *)((char *)c);
  }
#line 73
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 74
    return (1);
  }
#line 75
  if (enc == -1) {
#line 76
    enc = ctx->encrypt;
  }
#line 77
  k3 = (u_char *)key;
#line 77
  k2 = k3;
#line 77
  k1 = k2;
#line 78
  k2 += 8;
#line 79
  if (ctx->key_len >= 24) {
#line 80
    if (enc) {
#line 81
      k3 += 16;
    } else {
#line 83
      k1 += 16;
    }
  }
#line 85
  EVP_CIPHER_CTX_init(& c->k1);
#line 86
  EVP_CIPHER_CTX_init(& c->k2);
#line 87
  EVP_CIPHER_CTX_init(& c->k3);
#line 93
  tmp___0 = EVP_des_cbc();
#line 93
  tmp___1 = EVP_CipherInit(& c->k1, tmp___0, (unsigned char const   *)k1, (unsigned char const   *)((void *)0),
                           enc);
#line 93
  if (tmp___1 == 0) {
#line 96
    memset((void *)c, 0, sizeof(*c));
#line 97
    xfree((void *)c);
#line 98
    ctx->app_data = (void *)((char *)((void *)0));
#line 99
    return (0);
  } else {
#line 93
    tmp___2 = EVP_des_cbc();
#line 93
    tmp___3 = EVP_CipherInit(& c->k2, tmp___2, (unsigned char const   *)k2, (unsigned char const   *)((void *)0),
                             ! enc);
#line 93
    if (tmp___3 == 0) {
#line 96
      memset((void *)c, 0, sizeof(*c));
#line 97
      xfree((void *)c);
#line 98
      ctx->app_data = (void *)((char *)((void *)0));
#line 99
      return (0);
    } else {
#line 93
      tmp___4 = EVP_des_cbc();
#line 93
      tmp___5 = EVP_CipherInit(& c->k3, tmp___4, (unsigned char const   *)k3, (unsigned char const   *)((void *)0),
                               enc);
#line 93
      if (tmp___5 == 0) {
#line 96
        memset((void *)c, 0, sizeof(*c));
#line 97
        xfree((void *)c);
#line 98
        ctx->app_data = (void *)((char *)((void *)0));
#line 99
        return (0);
      }
    }
  }
#line 102
  return (1);
}
}
#line 105 "cipher-3des1.c"
static int ssh1_3des_cbc(EVP_CIPHER_CTX *ctx , u_char *dest , u_char const   *src ,
                         u_int len ) 
{ struct ssh1_3des_ctx *c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 110
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 110
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 111
    error("ssh1_3des_cbc: no context");
#line 112
    return (0);
  }
#line 119
  tmp = (*((c->k1.cipher)->do_cipher))(& c->k1, dest, (unsigned char const   *)((u_char *)src),
                                       len);
#line 119
  if (tmp == 0) {
#line 122
    return (0);
  } else {
#line 119
    tmp___0 = (*((c->k2.cipher)->do_cipher))(& c->k2, dest, (unsigned char const   *)dest,
                                             len);
#line 119
    if (tmp___0 == 0) {
#line 122
      return (0);
    } else {
#line 119
      tmp___1 = (*((c->k3.cipher)->do_cipher))(& c->k3, dest, (unsigned char const   *)dest,
                                               len);
#line 119
      if (tmp___1 == 0) {
#line 122
        return (0);
      }
    }
  }
#line 124
  return (1);
}
}
#line 127 "cipher-3des1.c"
static int ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 132
  c = (struct ssh1_3des_ctx *)ctx->app_data;
#line 132
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 133
    EVP_CIPHER_CTX_cleanup(& c->k1);
#line 134
    EVP_CIPHER_CTX_cleanup(& c->k2);
#line 135
    EVP_CIPHER_CTX_cleanup(& c->k3);
#line 136
    memset((void *)c, 0, sizeof(*c));
#line 137
    xfree((void *)c);
#line 138
    ctx->app_data = (void *)((char *)((void *)0));
  }
#line 140
  return (1);
}
}
#line 143 "cipher-3des1.c"
void ssh1_3des_iv(EVP_CIPHER_CTX *evp , int doset , u_char *iv , int len ) 
{ struct ssh1_3des_ctx *c ;

  {
#line 148
  if (len != 24) {
#line 149
    fatal("%s: bad 3des iv length: %d", "ssh1_3des_iv", len);
  }
#line 150
  c = (struct ssh1_3des_ctx *)evp->app_data;
#line 150
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 151
    fatal("%s: no 3des context", "ssh1_3des_iv");
  }
#line 152
  if (doset) {
#line 153
    debug3("%s: Installed 3DES IV", "ssh1_3des_iv");
#line 154
    memcpy((void * __restrict  )(c->k1.iv), (void const   * __restrict  )iv, 8U);
#line 155
    memcpy((void * __restrict  )(c->k2.iv), (void const   * __restrict  )(iv + 8),
           8U);
#line 156
    memcpy((void * __restrict  )(c->k3.iv), (void const   * __restrict  )(iv + 16),
           8U);
  } else {
#line 158
    debug3("%s: Copying 3DES IV", "ssh1_3des_iv");
#line 159
    memcpy((void * __restrict  )iv, (void const   * __restrict  )(c->k1.iv), 8U);
#line 160
    memcpy((void * __restrict  )(iv + 8), (void const   * __restrict  )(c->k2.iv),
           8U);
#line 161
    memcpy((void * __restrict  )(iv + 16), (void const   * __restrict  )(c->k3.iv),
           8U);
  }
#line 163
  return;
}
}
#line 168 "cipher-3des1.c"
static EVP_CIPHER ssh1_3des  ;
#line 165 "cipher-3des1.c"
EVP_CIPHER const   *evp_ssh1_3des(void) 
{ 

  {
#line 170
  memset((void *)(& ssh1_3des), 0, sizeof(EVP_CIPHER ));
#line 171
  ssh1_3des.nid = 0;
#line 172
  ssh1_3des.block_size = 8;
#line 173
  ssh1_3des.iv_len = 0;
#line 174
  ssh1_3des.key_len = 16;
#line 175
  ssh1_3des.init = & ssh1_3des_init;
#line 176
  ssh1_3des.cleanup = & ssh1_3des_cleanup;
#line 177
  ssh1_3des.do_cipher = & ssh1_3des_cbc;
#line 179
  ssh1_3des.flags = 10UL;
#line 181
  return ((EVP_CIPHER const   *)(& ssh1_3des));
}
}
#line 1 "cleanup.o"
#line 548 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 28 "cleanup.c"
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 28 "cleanup.c"
void cleanup_exit(int i ) 
{ 

  {
#line 31
  _exit(i);
}
}
#line 1 "compat.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 61 "compat.h"
void enable_compat13(void) ;
#line 62
void enable_compat20(void) ;
#line 63
void compat_datafellows(char const   *version___0 ) ;
#line 64
int proto_spec(char const   *spec ) ;
#line 65
char *compat_cipher_proposal(char *cipher_prop ) ;
#line 18 "match.h"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) ;
#line 41 "compat.c"
int compat13  =    0;
#line 42 "compat.c"
int compat20  =    0;
#line 43 "compat.c"
int datafellows  =    0;
#line 45 "compat.c"
void enable_compat20(void) 
{ 

  {
#line 48
  debug("Enabling compatibility mode for protocol 2.0");
#line 49
  compat20 = 1;
#line 50
  return;
}
}
#line 51 "compat.c"
void enable_compat13(void) 
{ 

  {
#line 54
  debug("Enabling compatibility mode for protocol 1.3");
#line 55
  compat13 = 1;
#line 56
  return;
}
}
#line 62 "compat.c"
static struct __anonstruct_check_52 check[30]  = 
#line 62
  {      {(char *)"OpenSSH-2.0*,OpenSSH-2.1*,OpenSSH_2.1*,OpenSSH_2.2*", 18923664}, 
        {(char *)"OpenSSH_2.3.0*", 18927744}, 
        {(char *)"OpenSSH_2.3.*", 18927616}, 
        {(char *)"OpenSSH_2.5.0p1*,OpenSSH_2.5.1p1*", 18927616}, 
        {(char *)"OpenSSH_2.5.0*,OpenSSH_2.5.1*,OpenSSH_2.5.2*", 18923520}, 
        {(char *)"OpenSSH_2.5.3*", 18907136}, 
        {(char *)"OpenSSH_2.*,OpenSSH_3.0*,OpenSSH_3.1*", 18874368}, 
        {(char *)"OpenSSH_3.*", 16777216}, 
        {(char *)"Sun_SSH_1.0*", 2129920}, 
        {(char *)"OpenSSH*", 0}, 
        {(char *)"*MindTerm*", 0}, 
        {(char *)"2.1.0*", 8462421}, 
        {(char *)"2.1 *", 8462421}, 
        {(char *)"2.0.13*,2.0.14*,2.0.15*,2.0.16*,2.0.17*,2.0.18*,2.0.19*", 9642591}, 
        {(char *)"2.0.11*,2.0.12*",
      9577087}, 
        {(char *)"2.0.*", 9839231}, 
        {(char *)"2.2.0*,2.3.0*", 8396868}, 
        {(char *)"2.3.*", 8396864}, 
        {(char *)"2.4", 16}, 
        {(char *)"2.*", 41943104}, 
        {(char *)"3.0.*", 64}, 
        {(char *)"3.0 SecureCRT*", 16}, 
        {(char *)"1.7 SecureFX*", 16}, 
        {(char *)"1.2.18*,1.2.19*,1.2.20*,1.2.21*,1.2.22*", 256}, 
        {(char *)"1.3.2*", 256}, 
        {(char *)"*SSH Compatible Server*", 1024}, 
        {(char *)"*OSU_0*,OSU_1.0*,OSU_1.1*,OSU_1.2*,OSU_1.3*,OSU_1.4*,OSU_1.5alpha1*,OSU_1.5alpha2*,OSU_1.5alpha3*",
      1024}, 
        {(char *)"*SSH_Version_Mapper*", 2048}, 
        {(char *)"Probe-*", 4194304}, 
        {(char *)((void *)0), 0}};
#line 58 "compat.c"
void compat_datafellows(char const   *version___0 ) 
{ int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 167
  i = 0;
#line 167
  while (check[i].pat) {
#line 168
    tmp = strlen((char const   *)check[i].pat);
#line 168
    tmp___0 = match_pattern_list(version___0, (char const   *)check[i].pat, tmp, 0);
#line 168
    if (tmp___0 == 1) {
#line 170
      debug("match: %s pat %s", version___0, check[i].pat);
#line 171
      datafellows = check[i].bugs;
#line 172
      return;
    }
#line 167
    i ++;
  }
#line 175
  debug("no match: %s", version___0);
#line 176
  return;
}
}
#line 179 "compat.c"
int proto_spec(char const   *spec ) 
{ char *s ;
  char *p ;
  char *q ;
  int ret___0 ;
  char *tmp___14 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 183
  ret___0 = 0;
#line 185
  if ((unsigned int )spec == (unsigned int )((void *)0)) {
#line 186
    return (ret___0);
  }
#line 187
  s = xstrdup(spec);
#line 187
  q = s;
#line 188
  tmp___14 = __strsep_g(& q, ",");
#line 188
  p = tmp___14;
#line 188
  while (1) {
#line 188
    if (p) {
#line 188
      if (! ((int )*p != 0)) {
#line 188
        break;
      }
    } else {
#line 188
      break;
    }
#line 189
    tmp___31 = atoi((char const   *)p);
#line 189
    switch (tmp___31) {
    case 1: 
#line 191
    if (ret___0 == 0) {
#line 192
      ret___0 |= 2;
    }
#line 193
    ret___0 |= 1;
#line 194
    break;
    case 2: 
#line 196
    ret___0 |= 4;
#line 197
    break;
    default: 
#line 199
    logit("ignoring bad proto spec: \'%s\'.", p);
#line 200
    break;
    }
#line 188
    tmp___30 = __strsep_g(& q, ",");
#line 188
    p = tmp___30;
  }
#line 203
  xfree((void *)s);
#line 204
  return (ret___0);
}
}
#line 207 "compat.c"
char *compat_cipher_proposal(char *cipher_prop ) 
{ Buffer b ;
  char *orig_prop ;
  char *fix_ciphers ;
  char *cp ;
  char *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___43 ;
  void *tmp___44 ;

  {
#line 214
  if (! (datafellows & 4096)) {
#line 215
    return (cipher_prop);
  }
#line 217
  buffer_init(& b);
#line 218
  orig_prop = xstrdup((char const   *)cipher_prop);
#line 218
  tmp = orig_prop;
#line 219
  while (1) {
#line 219
    tmp___43 = __strsep_g(& tmp, ",");
#line 219
    cp = tmp___43;
#line 219
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 219
      break;
    }
#line 220
    if (0) {
#line 220
      if (0) {
#line 220
        __s1_len___0 = strlen((char const   *)cp);
#line 220
        __s2_len___0 = strlen("aes");
#line 220
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 220
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 220
            if (! ((unsigned int )((void const   *)("aes" + 1)) - (unsigned int )((void const   *)"aes") == 1U)) {
#line 220
              tmp___25 = 1;
            } else {
#line 220
              if (__s2_len___0 >= 4U) {
#line 220
                tmp___25 = 1;
              } else {
#line 220
                tmp___25 = 0;
              }
            }
          } else {
#line 220
            tmp___25 = 0;
          }
        }
#line 220
        if (tmp___25) {
#line 220
          tmp___21 = __builtin_strcmp((char const   *)cp, "aes");
        } else {
#line 220
          tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 220
          tmp___21 = tmp___24;
        }
      } else {
#line 220
        tmp___24 = __builtin_strcmp((char const   *)cp, "aes");
#line 220
        tmp___21 = tmp___24;
      }
#line 220
      tmp___15 = tmp___21;
    } else {
#line 220
      tmp___15 = strncmp((char const   *)cp, "aes", 3U);
    }
#line 220
    if (tmp___15 != 0) {
#line 221
      tmp___0 = buffer_len(& b);
#line 221
      if (tmp___0 > 0U) {
#line 222
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 223
      tmp___1 = strlen((char const   *)cp);
#line 223
      buffer_append(& b, (void const   *)cp, tmp___1);
    }
  }
#line 226
  buffer_append(& b, (void const   *)"\000", 1U);
#line 227
  tmp___44 = buffer_ptr(& b);
#line 227
  fix_ciphers = xstrdup((char const   *)tmp___44);
#line 228
  buffer_free(& b);
#line 229
  xfree((void *)orig_prop);
#line 230
  debug2("Original cipher proposal: %s", cipher_prop);
#line 231
  debug2("Compat cipher proposal: %s", fix_ciphers);
#line 232
  if (! *fix_ciphers) {
#line 233
    fatal("No available ciphers found.");
  }
#line 235
  return (fix_ciphers);
}
}
#line 1 "compress.o"
#line 242 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 328
extern int deflateEnd(z_streamp strm ) ;
#line 363
extern int inflate(z_streamp strm , int flush ) ;
#line 462
extern int inflateEnd(z_streamp strm ) ;
#line 1317
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1319
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 19 "compress.h"
void buffer_compress_init_send(int level ) ;
#line 20
void buffer_compress_init_recv(void) ;
#line 21
void buffer_compress_uninit(void) ;
#line 22
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 23
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) ;
#line 26 "compress.c"
z_stream incoming_stream  ;
#line 27 "compress.c"
z_stream outgoing_stream  ;
#line 28 "compress.c"
static int compress_init_send_called  =    0;
#line 29 "compress.c"
static int compress_init_recv_called  =    0;
#line 30 "compress.c"
static int inflate_failed  =    0;
#line 31 "compress.c"
static int deflate_failed  =    0;
#line 38 "compress.c"
void buffer_compress_init_send(int level ) 
{ 

  {
#line 41
  if (compress_init_send_called == 1) {
#line 42
    deflateEnd(& outgoing_stream);
  }
#line 43
  compress_init_send_called = 1;
#line 44
  debug("Enabling compression at level %d.", level);
#line 45
  if (level < 1) {
#line 46
    fatal("Bad compression level %d.", level);
  } else {
#line 45
    if (level > 9) {
#line 46
      fatal("Bad compression level %d.", level);
    }
  }
#line 47
  deflateInit_(& outgoing_stream, level, "1.2.3", (int )sizeof(z_stream ));
#line 48
  return;
}
}
#line 49 "compress.c"
void buffer_compress_init_recv(void) 
{ 

  {
#line 52
  if (compress_init_recv_called == 1) {
#line 53
    inflateEnd(& incoming_stream);
  }
#line 54
  compress_init_recv_called = 1;
#line 55
  inflateInit_(& incoming_stream, "1.2.3", (int )sizeof(z_stream ));
#line 56
  return;
}
}
#line 60 "compress.c"
void buffer_compress_uninit(void) 
{ double tmp ;
  double tmp___0 ;

  {
#line 63
  if (outgoing_stream.total_in == 0UL) {
#line 63
    tmp = 0.0;
  } else {
#line 63
    tmp = (double )outgoing_stream.total_out / (double )outgoing_stream.total_in;
  }
#line 63
  debug("compress outgoing: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )outgoing_stream.total_in,
        (unsigned long long )outgoing_stream.total_out, tmp);
#line 68
  if (incoming_stream.total_out == 0UL) {
#line 68
    tmp___0 = 0.0;
  } else {
#line 68
    tmp___0 = (double )incoming_stream.total_in / (double )incoming_stream.total_out;
  }
#line 68
  debug("compress incoming: raw data %llu, compressed %llu, factor %.2f", (unsigned long long )incoming_stream.total_out,
        (unsigned long long )incoming_stream.total_in, tmp___0);
#line 73
  if (compress_init_recv_called == 1) {
#line 73
    if (inflate_failed == 0) {
#line 74
      inflateEnd(& incoming_stream);
    }
  }
#line 75
  if (compress_init_send_called == 1) {
#line 75
    if (deflate_failed == 0) {
#line 76
      deflateEnd(& outgoing_stream);
    }
  }
#line 77
  return;
}
}
#line 88 "compress.c"
void buffer_compress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 95
  tmp = buffer_len(input_buffer);
#line 95
  if (tmp == 0U) {
#line 96
    return;
  }
#line 99
  tmp___0 = buffer_ptr(input_buffer);
#line 99
  outgoing_stream.next_in = (Bytef *)tmp___0;
#line 100
  outgoing_stream.avail_in = buffer_len(input_buffer);
#line 103
  while (1) {
#line 105
    outgoing_stream.next_out = buf___1;
#line 106
    outgoing_stream.avail_out = sizeof(buf___1);
#line 109
    status = deflate(& outgoing_stream, 1);
#line 110
    switch (status) {
    case 0: 
#line 113
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - outgoing_stream.avail_out);
#line 115
    break;
    default: 
#line 117
    deflate_failed = 1;
#line 118
    fatal("buffer_compress: deflate returned %d", status);
    }
#line 103
    if (! (outgoing_stream.avail_out == 0U)) {
#line 103
      break;
    }
  }
#line 122
  return;
}
}
#line 133 "compress.c"
void buffer_uncompress(Buffer *input_buffer , Buffer *output_buffer ) 
{ u_char buf___1[4096] ;
  int status ;
  void *tmp ;

  {
#line 139
  tmp = buffer_ptr(input_buffer);
#line 139
  incoming_stream.next_in = (Bytef *)tmp;
#line 140
  incoming_stream.avail_in = buffer_len(input_buffer);
#line 142
  while (1) {
#line 144
    incoming_stream.next_out = buf___1;
#line 145
    incoming_stream.avail_out = sizeof(buf___1);
#line 147
    status = inflate(& incoming_stream, 1);
#line 148
    switch (status) {
    case 0: 
#line 150
    buffer_append(output_buffer, (void const   *)(buf___1), sizeof(buf___1) - incoming_stream.avail_out);
#line 152
    break;
    case -5: 
#line 159
    return;
    default: 
#line 161
    inflate_failed = 1;
#line 162
    fatal("buffer_uncompress: inflate returned %d", status);
    }
  }
}
}
#line 1 "crc32.o"
#line 29 "crc32.h"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) ;
#line 29 "crc32.c"
static u_int32_t const   crc32tab[256]  = 
#line 29 "crc32.c"
  {      (u_int32_t const   )0L,      (u_int32_t const   )1996959894L,      (u_int32_t const   )3993919788UL,      (u_int32_t const   )2567524794UL, 
        (u_int32_t const   )124634137L,      (u_int32_t const   )1886057615L,      (u_int32_t const   )3915621685UL,      (u_int32_t const   )2657392035UL, 
        (u_int32_t const   )249268274L,      (u_int32_t const   )2044508324L,      (u_int32_t const   )3772115230UL,      (u_int32_t const   )2547177864UL, 
        (u_int32_t const   )162941995L,      (u_int32_t const   )2125561021L,      (u_int32_t const   )3887607047UL,      (u_int32_t const   )2428444049UL, 
        (u_int32_t const   )498536548L,      (u_int32_t const   )1789927666L,      (u_int32_t const   )4089016648UL,      (u_int32_t const   )2227061214UL, 
        (u_int32_t const   )450548861L,      (u_int32_t const   )1843258603L,      (u_int32_t const   )4107580753UL,      (u_int32_t const   )2211677639UL, 
        (u_int32_t const   )325883990L,      (u_int32_t const   )1684777152L,      (u_int32_t const   )4251122042UL,      (u_int32_t const   )2321926636UL, 
        (u_int32_t const   )335633487L,      (u_int32_t const   )1661365465L,      (u_int32_t const   )4195302755UL,      (u_int32_t const   )2366115317UL, 
        (u_int32_t const   )997073096L,      (u_int32_t const   )1281953886L,      (u_int32_t const   )3579855332UL,      (u_int32_t const   )2724688242UL, 
        (u_int32_t const   )1006888145L,      (u_int32_t const   )1258607687L,      (u_int32_t const   )3524101629UL,      (u_int32_t const   )2768942443UL, 
        (u_int32_t const   )901097722L,      (u_int32_t const   )1119000684L,      (u_int32_t const   )3686517206UL,      (u_int32_t const   )2898065728UL, 
        (u_int32_t const   )853044451L,      (u_int32_t const   )1172266101L,      (u_int32_t const   )3705015759UL,      (u_int32_t const   )2882616665UL, 
        (u_int32_t const   )651767980L,      (u_int32_t const   )1373503546L,      (u_int32_t const   )3369554304UL,      (u_int32_t const   )3218104598UL, 
        (u_int32_t const   )565507253L,      (u_int32_t const   )1454621731L,      (u_int32_t const   )3485111705UL,      (u_int32_t const   )3099436303UL, 
        (u_int32_t const   )671266974L,      (u_int32_t const   )1594198024L,      (u_int32_t const   )3322730930UL,      (u_int32_t const   )2970347812UL, 
        (u_int32_t const   )795835527L,      (u_int32_t const   )1483230225L,      (u_int32_t const   )3244367275UL,      (u_int32_t const   )3060149565UL, 
        (u_int32_t const   )1994146192L,      (u_int32_t const   )31158534L,      (u_int32_t const   )2563907772UL,      (u_int32_t const   )4023717930UL, 
        (u_int32_t const   )1907459465L,      (u_int32_t const   )112637215L,      (u_int32_t const   )2680153253UL,      (u_int32_t const   )3904427059UL, 
        (u_int32_t const   )2013776290L,      (u_int32_t const   )251722036L,      (u_int32_t const   )2517215374UL,      (u_int32_t const   )3775830040UL, 
        (u_int32_t const   )2137656763L,      (u_int32_t const   )141376813L,      (u_int32_t const   )2439277719UL,      (u_int32_t const   )3865271297UL, 
        (u_int32_t const   )1802195444L,      (u_int32_t const   )476864866L,      (u_int32_t const   )2238001368UL,      (u_int32_t const   )4066508878UL, 
        (u_int32_t const   )1812370925L,      (u_int32_t const   )453092731L,      (u_int32_t const   )2181625025UL,      (u_int32_t const   )4111451223UL, 
        (u_int32_t const   )1706088902L,      (u_int32_t const   )314042704L,      (u_int32_t const   )2344532202UL,      (u_int32_t const   )4240017532UL, 
        (u_int32_t const   )1658658271L,      (u_int32_t const   )366619977L,      (u_int32_t const   )2362670323UL,      (u_int32_t const   )4224994405UL, 
        (u_int32_t const   )1303535960L,      (u_int32_t const   )984961486L,      (u_int32_t const   )2747007092UL,      (u_int32_t const   )3569037538UL, 
        (u_int32_t const   )1256170817L,      (u_int32_t const   )1037604311L,      (u_int32_t const   )2765210733UL,      (u_int32_t const   )3554079995UL, 
        (u_int32_t const   )1131014506L,      (u_int32_t const   )879679996L,      (u_int32_t const   )2909243462UL,      (u_int32_t const   )3663771856UL, 
        (u_int32_t const   )1141124467L,      (u_int32_t const   )855842277L,      (u_int32_t const   )2852801631UL,      (u_int32_t const   )3708648649UL, 
        (u_int32_t const   )1342533948L,      (u_int32_t const   )654459306L,      (u_int32_t const   )3188396048UL,      (u_int32_t const   )3373015174UL, 
        (u_int32_t const   )1466479909L,      (u_int32_t const   )544179635L,      (u_int32_t const   )3110523913UL,      (u_int32_t const   )3462522015UL, 
        (u_int32_t const   )1591671054L,      (u_int32_t const   )702138776L,      (u_int32_t const   )2966460450UL,      (u_int32_t const   )3352799412UL, 
        (u_int32_t const   )1504918807L,      (u_int32_t const   )783551873L,      (u_int32_t const   )3082640443UL,      (u_int32_t const   )3233442989UL, 
        (u_int32_t const   )3988292384UL,      (u_int32_t const   )2596254646UL,      (u_int32_t const   )62317068L,      (u_int32_t const   )1957810842L, 
        (u_int32_t const   )3939845945UL,      (u_int32_t const   )2647816111UL,      (u_int32_t const   )81470997L,      (u_int32_t const   )1943803523L, 
        (u_int32_t const   )3814918930UL,      (u_int32_t const   )2489596804UL,      (u_int32_t const   )225274430L,      (u_int32_t const   )2053790376L, 
        (u_int32_t const   )3826175755UL,      (u_int32_t const   )2466906013UL,      (u_int32_t const   )167816743L,      (u_int32_t const   )2097651377L, 
        (u_int32_t const   )4027552580UL,      (u_int32_t const   )2265490386UL,      (u_int32_t const   )503444072L,      (u_int32_t const   )1762050814L, 
        (u_int32_t const   )4150417245UL,      (u_int32_t const   )2154129355UL,      (u_int32_t const   )426522225L,      (u_int32_t const   )1852507879L, 
        (u_int32_t const   )4275313526UL,      (u_int32_t const   )2312317920UL,      (u_int32_t const   )282753626L,      (u_int32_t const   )1742555852L, 
        (u_int32_t const   )4189708143UL,      (u_int32_t const   )2394877945UL,      (u_int32_t const   )397917763L,      (u_int32_t const   )1622183637L, 
        (u_int32_t const   )3604390888UL,      (u_int32_t const   )2714866558UL,      (u_int32_t const   )953729732L,      (u_int32_t const   )1340076626L, 
        (u_int32_t const   )3518719985UL,      (u_int32_t const   )2797360999UL,      (u_int32_t const   )1068828381L,      (u_int32_t const   )1219638859L, 
        (u_int32_t const   )3624741850UL,      (u_int32_t const   )2936675148UL,      (u_int32_t const   )906185462L,      (u_int32_t const   )1090812512L, 
        (u_int32_t const   )3747672003UL,      (u_int32_t const   )2825379669UL,      (u_int32_t const   )829329135L,      (u_int32_t const   )1181335161L, 
        (u_int32_t const   )3412177804UL,      (u_int32_t const   )3160834842UL,      (u_int32_t const   )628085408L,      (u_int32_t const   )1382605366L, 
        (u_int32_t const   )3423369109UL,      (u_int32_t const   )3138078467UL,      (u_int32_t const   )570562233L,      (u_int32_t const   )1426400815L, 
        (u_int32_t const   )3317316542UL,      (u_int32_t const   )2998733608UL,      (u_int32_t const   )733239954L,      (u_int32_t const   )1555261956L, 
        (u_int32_t const   )3268935591UL,      (u_int32_t const   )3050360625UL,      (u_int32_t const   )752459403L,      (u_int32_t const   )1541320221L, 
        (u_int32_t const   )2607071920UL,      (u_int32_t const   )3965973030UL,      (u_int32_t const   )1969922972L,      (u_int32_t const   )40735498L, 
        (u_int32_t const   )2617837225UL,      (u_int32_t const   )3943577151UL,      (u_int32_t const   )1913087877L,      (u_int32_t const   )83908371L, 
        (u_int32_t const   )2512341634UL,      (u_int32_t const   )3803740692UL,      (u_int32_t const   )2075208622L,      (u_int32_t const   )213261112L, 
        (u_int32_t const   )2463272603UL,      (u_int32_t const   )3855990285UL,      (u_int32_t const   )2094854071L,      (u_int32_t const   )198958881L, 
        (u_int32_t const   )2262029012UL,      (u_int32_t const   )4057260610UL,      (u_int32_t const   )1759359992L,      (u_int32_t const   )534414190L, 
        (u_int32_t const   )2176718541UL,      (u_int32_t const   )4139329115UL,      (u_int32_t const   )1873836001L,      (u_int32_t const   )414664567L, 
        (u_int32_t const   )2282248934UL,      (u_int32_t const   )4279200368UL,      (u_int32_t const   )1711684554L,      (u_int32_t const   )285281116L, 
        (u_int32_t const   )2405801727UL,      (u_int32_t const   )4167216745UL,      (u_int32_t const   )1634467795L,      (u_int32_t const   )376229701L, 
        (u_int32_t const   )2685067896UL,      (u_int32_t const   )3608007406UL,      (u_int32_t const   )1308918612L,      (u_int32_t const   )956543938L, 
        (u_int32_t const   )2808555105UL,      (u_int32_t const   )3495958263UL,      (u_int32_t const   )1231636301L,      (u_int32_t const   )1047427035L, 
        (u_int32_t const   )2932959818UL,      (u_int32_t const   )3654703836UL,      (u_int32_t const   )1088359270L,      (u_int32_t const   )936918000L, 
        (u_int32_t const   )2847714899UL,      (u_int32_t const   )3736837829UL,      (u_int32_t const   )1202900863L,      (u_int32_t const   )817233897L, 
        (u_int32_t const   )3183342108UL,      (u_int32_t const   )3401237130UL,      (u_int32_t const   )1404277552L,      (u_int32_t const   )615818150L, 
        (u_int32_t const   )3134207493UL,      (u_int32_t const   )3453421203UL,      (u_int32_t const   )1423857449L,      (u_int32_t const   )601450431L, 
        (u_int32_t const   )3009837614UL,      (u_int32_t const   )3294710456UL,      (u_int32_t const   )1567103746L,      (u_int32_t const   )711928724L, 
        (u_int32_t const   )3020668471UL,      (u_int32_t const   )3272380065UL,      (u_int32_t const   )1510334235L,      (u_int32_t const   )755167117L};
#line 96 "crc32.c"
u_int32_t ssh_crc32(u_char const   *buf___1 , u_int32_t size ) 
{ u_int32_t i ;
  u_int32_t crc ;

  {
#line 101
  crc = 0U;
#line 102
  i = 0U;
#line 102
  while (i < size) {
#line 103
    crc = (unsigned int )(crc32tab[(crc ^ (unsigned int )*(buf___1 + i)) & 255U] ^ (unsigned int const   )(crc >> 8));
#line 102
    i ++;
  }
#line 104
  return (crc);
}
}
#line 1 "deattack.o"
#line 30 "deattack.h"
int detect_attack(u_char *buf___1 , u_int32_t len ) ;
#line 73 "deattack.c"
static void crc_update(u_int32_t *a___0 , u_int32_t b ) 
{ 

  {
#line 76
  b ^= *a___0;
#line 77
  *a___0 = ssh_crc32((u_char const   *)((u_char *)(& b)), sizeof(b));
#line 78
  return;
}
}
#line 81 "deattack.c"
static int check_crc(u_char *S , u_char *buf___1 , u_int32_t len ) 
{ u_int32_t crc ;
  u_char *c ;
  int tmp ;

  {
#line 87
  crc = 0U;
#line 88
  c = buf___1;
#line 88
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 89
    tmp = memcmp((void const   *)S, (void const   *)c, 8U);
#line 89
    if (tmp) {
#line 93
      crc_update(& crc, 0U);
#line 94
      crc_update(& crc, 0U);
    } else {
#line 90
      crc_update(& crc, 1U);
#line 91
      crc_update(& crc, 0U);
    }
#line 88
    c += 8;
  }
#line 97
  return (crc == 0U);
}
}
#line 105 "deattack.c"
static u_int16_t *h  =    (u_int16_t *)((void *)0);
#line 106 "deattack.c"
static u_int32_t n  =    (u_int32_t )4096;
#line 102 "deattack.c"
int detect_attack(u_char *buf___1 , u_int32_t len ) 
{ u_int32_t i ;
  u_int32_t j ;
  u_int32_t l ;
  u_int32_t same ;
  u_char *c ;
  u_char *d ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u_int32_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 112
  if (len > 262144U) {
#line 114
    fatal("detect_attack: bad length %d", len);
  } else {
#line 112
    if (len % 8U != 0U) {
#line 114
      fatal("detect_attack: bad length %d", len);
    }
  }
#line 116
  l = n;
#line 116
  while (l < ((len / 8U) * 3U) / 2U) {
#line 116
    l <<= 2;
  }
#line 119
  if ((unsigned int )h == (unsigned int )((void *)0)) {
#line 120
    debug("Installing crc compensation attack detector.");
#line 121
    tmp = xcalloc(l, 2U);
#line 121
    h = (u_int16_t *)tmp;
#line 122
    n = l;
  } else {
#line 124
    if (l > n) {
#line 125
      tmp___0 = xrealloc((void *)h, l, 2U);
#line 125
      h = (u_int16_t *)tmp___0;
#line 126
      n = l;
    }
  }
#line 130
  if (len <= 56U) {
#line 131
    c = buf___1;
#line 131
    while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 132
      d = buf___1;
#line 132
      while ((unsigned int )d < (unsigned int )c) {
#line 133
        tmp___2 = memcmp((void const   *)c, (void const   *)d, 8U);
#line 133
        if (! tmp___2) {
#line 134
          tmp___1 = check_crc(c, buf___1, len);
#line 134
          if (tmp___1) {
#line 135
            return (1);
          } else {
#line 137
            break;
          }
        }
#line 132
        d += 8;
      }
#line 131
      c += 8;
    }
#line 141
    return (0);
  }
#line 143
  memset((void *)h, 255, n * 2U);
#line 145
  c = buf___1;
#line 145
  j = 0U;
#line 145
  same = j;
#line 145
  while ((unsigned int )c < (unsigned int )(buf___1 + len)) {
#line 146
    tmp___3 = get_u32((void const   *)c);
#line 146
    i = tmp___3 & (n - 1U);
#line 146
    while ((int )*(h + i) != 65535) {
#line 148
      tmp___5 = memcmp((void const   *)c, (void const   *)(buf___1 + (int )*(h + i) * 8),
                       8U);
#line 148
      if (! tmp___5) {
#line 149
        same ++;
#line 149
        if (same > 32U) {
#line 150
          return (2);
        }
#line 151
        tmp___4 = check_crc(c, buf___1, len);
#line 151
        if (tmp___4) {
#line 152
          return (1);
        } else {
#line 154
          break;
        }
      }
#line 146
      i = (i + 1U) & (n - 1U);
    }
#line 157
    *(h + i) = (unsigned short )j;
#line 145
    c += 8;
#line 145
    j ++;
  }
#line 159
  return (0);
}
}
#line 1 "fatal.o"
#line 63 "log.h"
void do_log(LogLevel level , char const   *fmt , va_list args ) ;
#line 36 "fatal.c"
 __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   *fmt 
                                                                     , ...) ;
#line 36 "fatal.c"
void ( /* format attribute */  fatal)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 41
  __builtin_va_start(args, fmt);
#line 42
  do_log(1, fmt, args);
#line 43
  __builtin_va_end(args);
#line 44
  cleanup_exit(255);
}
}
#line 1 "hostfile.o"
#line 532 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 597 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_sha1(void) ;
#line 89 "/usr/include/openssl/hmac.h"
extern void HMAC_CTX_cleanup(HMAC_CTX *ctx ) ;
#line 93
extern void HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD const   *md ) ;
#line 97
extern void HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 98
extern void HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 19 "match.h"
int match_hostname(char const   *host , char const   *pattern , u_int len ) ;
#line 62 "key.h"
int key_equal(Key const   *a___0 , Key const   *b ) ;
#line 66
int key_write(Key const   *key , FILE *f ) ;
#line 68
u_int key_size(Key const   *k ) ;
#line 21 "hostfile.h"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret___0 ) ;
#line 22
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) ;
#line 24
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ,
                         int store_hash ) ;
#line 25
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) ;
#line 31
char *host_hash(char const   *host , char const   *name_from_hostfile , u_int src_len ) ;
#line 60 "hostfile.c"
static int extract_salt(char const   *s , u_int l , char *salt , size_t salt_len ) 
{ char *p ;
  char *b64salt ;
  u_int b64len ;
  int ret___0 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  void *tmp___26 ;

  {
#line 67
  if (l < sizeof("|1|") - 1U) {
#line 68
    debug2("extract_salt: string too short");
#line 69
    return (-1);
  }
#line 71
  if (0) {
#line 71
    if (0) {
#line 71
      __s1_len___0 = strlen(s);
#line 71
      __s2_len___0 = strlen("|1|");
#line 71
      if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
        goto _L___2;
      } else {
#line 71
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 71
          if (! ((unsigned int )((void const   *)("|1|" + 1)) - (unsigned int )((void const   *)"|1|") == 1U)) {
#line 71
            tmp___22 = 1;
          } else {
#line 71
            if (__s2_len___0 >= 4U) {
#line 71
              tmp___22 = 1;
            } else {
#line 71
              tmp___22 = 0;
            }
          }
        } else {
#line 71
          tmp___22 = 0;
        }
      }
#line 71
      if (tmp___22) {
#line 71
        tmp___18 = __builtin_strcmp(s, "|1|");
      } else {
#line 71
        tmp___21 = __builtin_strcmp(s, "|1|");
#line 71
        tmp___18 = tmp___21;
      }
    } else {
#line 71
      tmp___21 = __builtin_strcmp(s, "|1|");
#line 71
      tmp___18 = tmp___21;
    }
#line 71
    tmp___12 = tmp___18;
  } else {
#line 71
    tmp___12 = strncmp(s, "|1|", sizeof("|1|") - 1U);
  }
#line 71
  if (tmp___12 != 0) {
#line 72
    debug2("extract_salt: invalid magic identifier");
#line 73
    return (-1);
  }
#line 75
  s += sizeof("|1|") - 1U;
#line 76
  l -= sizeof("|1|") - 1U;
#line 77
  tmp___25 = memchr((void const   *)s, '|', l);
#line 77
  p = (char *)tmp___25;
#line 77
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 78
    debug2("extract_salt: missing salt termination character");
#line 79
    return (-1);
  }
#line 82
  b64len = (unsigned int )(p - (char *)s);
#line 84
  if (b64len == 0U) {
#line 85
    debug2("extract_salt: bad encoded salt length %u", b64len);
#line 86
    return (-1);
  } else {
#line 84
    if (b64len > 1024U) {
#line 85
      debug2("extract_salt: bad encoded salt length %u", b64len);
#line 86
      return (-1);
    }
  }
#line 88
  tmp___26 = xmalloc(1U + b64len);
#line 88
  b64salt = (char *)tmp___26;
#line 89
  memcpy((void * __restrict  )b64salt, (void const   * __restrict  )s, b64len);
#line 90
  *(b64salt + b64len) = (char )'\000';
#line 92
  ret___0 = __b64_pton((char const   *)b64salt, (u_char *)salt, salt_len);
#line 93
  xfree((void *)b64salt);
#line 94
  if (ret___0 == -1) {
#line 95
    debug2("extract_salt: salt decode error");
#line 96
    return (-1);
  }
#line 98
  if (ret___0 != 20) {
#line 99
    debug2("extract_salt: expected salt len %d, got %d", 20, ret___0);
#line 101
    return (-1);
  }
#line 104
  return (0);
}
}
#line 113 "hostfile.c"
static char encoded[1024]  ;
#line 107 "hostfile.c"
char *host_hash(char const   *host , char const   *name_from_hostfile , u_int src_len ) 
{ EVP_MD const   *md ;
  EVP_MD const   *tmp ;
  HMAC_CTX mac_ctx ;
  char salt[256] ;
  char result[256] ;
  char uu_salt[512] ;
  char uu_result[512] ;
  u_int i ;
  u_int len ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 110
  tmp = EVP_sha1();
#line 110
  md = tmp;
#line 116
  len = (unsigned int )md->md_size;
#line 118
  if ((unsigned int )name_from_hostfile == (unsigned int )((void *)0)) {
#line 120
    i = 0U;
#line 120
    while (i < len) {
#line 121
      tmp___0 = arc4random();
#line 121
      salt[i] = (char )tmp___0;
#line 120
      i ++;
    }
  } else {
#line 124
    tmp___1 = extract_salt(name_from_hostfile, src_len, salt, sizeof(salt));
#line 124
    if (tmp___1 == -1) {
#line 126
      return ((char *)((void *)0));
    }
  }
#line 129
  HMAC_Init(& mac_ctx, (void const   *)(salt), (int )len, md);
#line 130
  tmp___2 = strlen(host);
#line 130
  HMAC_Update(& mac_ctx, (unsigned char const   *)host, tmp___2);
#line 131
  HMAC_Final(& mac_ctx, (unsigned char *)(result), (unsigned int *)((void *)0));
#line 132
  HMAC_CTX_cleanup(& mac_ctx);
#line 134
  tmp___3 = __b64_ntop((u_char const   *)(salt), len, uu_salt, sizeof(uu_salt));
#line 134
  if (tmp___3 == -1) {
#line 136
    fatal("host_hash: __b64_ntop failed");
  } else {
#line 134
    tmp___4 = __b64_ntop((u_char const   *)(result), len, uu_result, sizeof(uu_result));
#line 134
    if (tmp___4 == -1) {
#line 136
      fatal("host_hash: __b64_ntop failed");
    }
  }
#line 138
  snprintf((char * __restrict  )(encoded), sizeof(encoded), (char const   * __restrict  )"%s%s%c%s",
           "|1|", uu_salt, '|', uu_result);
#line 141
  return (encoded);
}
}
#line 149 "hostfile.c"
int hostfile_read_key(char **cpp , u_int *bitsp , Key *ret___0 ) 
{ char *cp ;
  int tmp ;

  {
#line 155
  cp = *cpp;
#line 155
  while (1) {
#line 155
    if (! ((int )*cp == 32)) {
#line 155
      if (! ((int )*cp == 9)) {
#line 155
        break;
      }
    }
#line 155
    cp ++;
  }
#line 158
  tmp = key_read(ret___0, & cp);
#line 158
  if (tmp != 1) {
#line 159
    return (0);
  }
#line 162
  while (1) {
#line 162
    if (! ((int )*cp == 32)) {
#line 162
      if (! ((int )*cp == 9)) {
#line 162
        break;
      }
    }
#line 162
    cp ++;
  }
#line 166
  *cpp = cp;
#line 167
  *bitsp = key_size((Key const   *)ret___0);
#line 168
  return (1);
}
}
#line 171 "hostfile.c"
static int hostfile_check_key(int bits , Key const   *key , char const   *host , char const   *filename ,
                              int linenum ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 174
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 175
    return (1);
  } else {
#line 174
    if (key->type != 0) {
#line 175
      return (1);
    } else {
#line 174
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 175
        return (1);
      }
    }
  }
#line 176
  tmp___1 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 176
  if (bits != tmp___1) {
#line 177
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 177
    logit("Warning: %s, line %d: keysize mismatch for host %s: actual %d vs. announced %d.",
          filename, linenum, host, tmp, bits);
#line 180
    tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 180
    logit("Warning: replace %d with %d in %s, line %d.", bits, tmp___0, filename,
          linenum);
  }
#line 183
  return (1);
}
}
#line 196 "hostfile.c"
static HostStatus check_host_in_hostfile_by_key_or_type(char const   *filename , char const   *host ,
                                                        Key const   *key , int keytype ,
                                                        Key *found , int *numret ) 
{ FILE *f ;
  char line[8192] ;
  int linenum ;
  u_int kbits ;
  char *cp ;
  char *cp2 ;
  char *hashed_host ;
  HostStatus end_return ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;

  {
#line 202
  linenum = 0;
#line 207
  debug3("check_host_in_hostfile: filename %s", filename);
#line 210
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 211
  if (! f) {
#line 212
    return (1);
  }
#line 219
  end_return = 1;
#line 222
  while (1) {
#line 222
    tmp___29 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 222
    if (! tmp___29) {
#line 222
      break;
    }
#line 223
    cp = line;
#line 224
    linenum ++;
#line 227
    while (1) {
#line 227
      if (! ((int )*cp == 32)) {
#line 227
        if (! ((int )*cp == 9)) {
#line 227
          break;
        }
      }
#line 227
      cp ++;
    }
#line 229
    if (! *cp) {
#line 230
      continue;
    } else {
#line 229
      if ((int )*cp == 35) {
#line 230
        continue;
      } else {
#line 229
        if ((int )*cp == 10) {
#line 230
          continue;
        }
      }
    }
#line 233
    cp2 = cp;
#line 233
    while (1) {
#line 233
      if (*cp2) {
#line 233
        if ((int )*cp2 != 32) {
#line 233
          if (! ((int )*cp2 != 9)) {
#line 233
            break;
          }
        } else {
#line 233
          break;
        }
      } else {
#line 233
        break;
      }
#line 233
      cp2 ++;
    }
#line 237
    tmp___25 = match_hostname(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 237
    if (tmp___25 != 1) {
#line 238
      if ((int )*cp != 124) {
#line 239
        continue;
      }
#line 240
      hashed_host = host_hash(host, (char const   *)cp, (unsigned int )(cp2 - cp));
#line 241
      if ((unsigned int )hashed_host == (unsigned int )((void *)0)) {
#line 242
        debug("Invalid hashed host line %d of %s", linenum, filename);
#line 244
        continue;
      }
#line 246
      if (0) {
#line 246
        if (0) {
#line 246
          __s1_len___0 = strlen((char const   *)hashed_host);
#line 246
          __s2_len___0 = strlen((char const   *)cp);
#line 246
          if (! ((unsigned int )((void const   *)(hashed_host + 1)) - (unsigned int )((void const   *)hashed_host) == 1U)) {
            goto _L___2;
          } else {
#line 246
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 246
              if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
#line 246
                tmp___22 = 1;
              } else {
#line 246
                if (__s2_len___0 >= 4U) {
#line 246
                  tmp___22 = 1;
                } else {
#line 246
                  tmp___22 = 0;
                }
              }
            } else {
#line 246
              tmp___22 = 0;
            }
          }
#line 246
          if (tmp___22) {
#line 246
            tmp___18 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
          } else {
#line 246
            tmp___21 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
#line 246
            tmp___18 = tmp___21;
          }
        } else {
#line 246
          tmp___21 = __builtin_strcmp((char const   *)hashed_host, (char const   *)cp);
#line 246
          tmp___18 = tmp___21;
        }
#line 246
        tmp___12 = tmp___18;
      } else {
#line 246
        tmp___12 = strncmp((char const   *)hashed_host, (char const   *)cp, (unsigned int )(cp2 - cp));
      }
#line 246
      if (tmp___12 != 0) {
#line 247
        continue;
      }
    }
#line 251
    cp = cp2;
#line 257
    tmp___26 = hostfile_read_key(& cp, & kbits, found);
#line 257
    if (! tmp___26) {
#line 258
      continue;
    }
#line 260
    if ((unsigned int )numret != (unsigned int )((void *)0)) {
#line 261
      *numret = linenum;
    }
#line 263
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 265
      if (found->type == keytype) {
#line 266
        fclose(f);
#line 267
        return (3);
      }
#line 269
      continue;
    }
#line 272
    tmp___27 = hostfile_check_key((int )kbits, (Key const   *)found, host, filename,
                                  linenum);
#line 272
    if (! tmp___27) {
#line 273
      continue;
    }
#line 276
    tmp___28 = key_equal(key, (Key const   *)found);
#line 276
    if (tmp___28) {
#line 278
      debug3("check_host_in_hostfile: match line %d", linenum);
#line 279
      fclose(f);
#line 280
      return (0);
    }
#line 287
    end_return = 2;
  }
#line 290
  fclose(f);
#line 296
  return (end_return);
}
}
#line 299 "hostfile.c"
HostStatus check_host_in_hostfile(char const   *filename , char const   *host , Key const   *key ,
                                  Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 303
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 304
    fatal("no key to look up");
  }
#line 305
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, key, 0, found, numret);
#line 305
  return (tmp);
}
}
#line 309 "hostfile.c"
int lookup_key_in_hostfile_by_type(char const   *filename , char const   *host , int keytype ,
                                   Key *found , int *numret ) 
{ HostStatus tmp ;

  {
#line 313
  tmp = check_host_in_hostfile_by_key_or_type(filename, host, (Key const   *)((void *)0),
                                              keytype, found, numret);
#line 313
  return ((int )tmp == 3);
}
}
#line 322 "hostfile.c"
int add_host_to_hostfile(char const   *filename , char const   *host , Key const   *key ,
                         int store_hash ) 
{ FILE *f ;
  int success ;
  char *hashed_host ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 327
  success = 0;
#line 328
  hashed_host = (char *)((void *)0);
#line 330
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 331
    return (1);
  }
#line 332
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"a");
#line 333
  if (! f) {
#line 334
    return (0);
  }
#line 336
  if (store_hash) {
#line 337
    hashed_host = host_hash(host, (char const   *)((void *)0), 0U);
#line 337
    if ((unsigned int )hashed_host == (unsigned int )((void *)0)) {
#line 338
      error("add_host_to_hostfile: host_hash failed");
#line 339
      fclose(f);
#line 340
      return (0);
    }
  }
#line 343
  if (store_hash) {
#line 343
    tmp = (char const   *)hashed_host;
  } else {
#line 343
    tmp = host;
  }
#line 343
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s ", tmp);
#line 345
  tmp___0 = key_write(key, f);
#line 345
  if (tmp___0) {
#line 346
    success = 1;
  } else {
#line 348
    error("add_host_to_hostfile: saving key in %s failed", filename);
  }
#line 350
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 351
  fclose(f);
#line 352
  return (success);
}
}
#line 1 "log.o"
#line 646 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 49 "log.h"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) ;
#line 51
SyslogFacility log_facility_number(char *name ) ;
#line 52
LogLevel log_level_number(char *name ) ;
#line 56
void ( /* format attribute */  sigdie)(char const   *fmt  , ...) ;
#line 55 "log.c"
static LogLevel log_level___0  =    3;
#line 56 "log.c"
static int log_on_stderr  =    1;
#line 57 "log.c"
static int log_facility  =    4 << 3;
#line 58 "log.c"
static char *argv0  ;
#line 67 "log.c"
static struct __anonstruct_log_facilities_55 log_facilities[13]  = 
#line 67
  {      {"DAEMON", 0}, 
        {"USER", 1}, 
        {"AUTH", 2}, 
        {"AUTHPRIV", 3}, 
        {"LOCAL0", 4}, 
        {"LOCAL1", 5}, 
        {"LOCAL2", 6}, 
        {"LOCAL3", 7}, 
        {"LOCAL4", 8}, 
        {"LOCAL5", 9}, 
        {"LOCAL6", 10}, 
        {"LOCAL7", 11}, 
        {(char const   *)((void *)0), -1}};
#line 88 "log.c"
static struct __anonstruct_log_levels_56 log_levels[10]  = 
#line 88
  {      {"QUIET", 0}, 
        {"FATAL", 1}, 
        {"ERROR", 2}, 
        {"INFO", 3}, 
        {"VERBOSE", 4}, 
        {"DEBUG", 5}, 
        {"DEBUG1", 5}, 
        {"DEBUG2", 6}, 
        {"DEBUG3", 7}, 
        {(char const   *)((void *)0), -1}};
#line 105 "log.c"
SyslogFacility log_facility_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 110
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 111
    i = 0;
#line 111
    while (log_facilities[i].name) {
#line 112
      tmp = strcasecmp(log_facilities[i].name, (char const   *)name);
#line 112
      if (tmp == 0) {
#line 113
        return (log_facilities[i].val);
      }
#line 111
      i ++;
    }
  }
#line 114
  return (-1);
}
}
#line 117 "log.c"
LogLevel log_level_number(char *name ) 
{ int i ;
  int tmp ;

  {
#line 122
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 123
    i = 0;
#line 123
    while (log_levels[i].name) {
#line 124
      tmp = strcasecmp(log_levels[i].name, (char const   *)name);
#line 124
      if (tmp == 0) {
#line 125
        return (log_levels[i].val);
      }
#line 123
      i ++;
    }
  }
#line 126
  return (-1);
}
}
#line 131 "log.c"
void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 136
  __builtin_va_start(args, fmt);
#line 137
  do_log(2, fmt, args);
#line 138
  __builtin_va_end(args);
#line 139
  return;
}
}
#line 141 "log.c"
void ( /* format attribute */  sigdie)(char const   *fmt  , ...) 
{ 

  {
#line 151
  _exit(1);
}
}
#line 157 "log.c"
void ( /* format attribute */  logit)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 162
  __builtin_va_start(args, fmt);
#line 163
  do_log(3, fmt, args);
#line 164
  __builtin_va_end(args);
#line 165
  return;
}
}
#line 169 "log.c"
void ( /* format attribute */  verbose)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 174
  __builtin_va_start(args, fmt);
#line 175
  do_log(4, fmt, args);
#line 176
  __builtin_va_end(args);
#line 177
  return;
}
}
#line 181 "log.c"
void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 186
  __builtin_va_start(args, fmt);
#line 187
  do_log(5, fmt, args);
#line 188
  __builtin_va_end(args);
#line 189
  return;
}
}
#line 191 "log.c"
void ( /* format attribute */  debug2)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 196
  __builtin_va_start(args, fmt);
#line 197
  do_log(6, fmt, args);
#line 198
  __builtin_va_end(args);
#line 199
  return;
}
}
#line 201 "log.c"
void ( /* format attribute */  debug3)(char const   *fmt  , ...) 
{ va_list args ;

  {
#line 206
  __builtin_va_start(args, fmt);
#line 207
  do_log(7, fmt, args);
#line 208
  __builtin_va_end(args);
#line 209
  return;
}
}
#line 215 "log.c"
void log_init(char *av0 , LogLevel level , SyslogFacility facility , int on_stderr ) 
{ char *tmp ;

  {
#line 222
  argv0 = av0;
#line 224
  switch ((int )level) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
#line 233
  log_level___0 = level;
#line 234
  break;
  default: 
#line 236
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog level code %d\n",
          (int )level);
#line 238
  exit(1);
  }
#line 241
  log_on_stderr = on_stderr;
#line 242
  if (on_stderr) {
#line 243
    return;
  }
#line 245
  switch ((int )facility) {
  case 0: 
#line 247
  log_facility = 3 << 3;
#line 248
  break;
  case 1: 
#line 250
  log_facility = 1 << 3;
#line 251
  break;
  case 2: 
#line 253
  log_facility = 4 << 3;
#line 254
  break;
  case 3: 
#line 257
  log_facility = 10 << 3;
#line 258
  break;
  case 4: 
#line 261
  log_facility = 16 << 3;
#line 262
  break;
  case 5: 
#line 264
  log_facility = 17 << 3;
#line 265
  break;
  case 6: 
#line 267
  log_facility = 18 << 3;
#line 268
  break;
  case 7: 
#line 270
  log_facility = 19 << 3;
#line 271
  break;
  case 8: 
#line 273
  log_facility = 20 << 3;
#line 274
  break;
  case 9: 
#line 276
  log_facility = 21 << 3;
#line 277
  break;
  case 10: 
#line 279
  log_facility = 22 << 3;
#line 280
  break;
  case 11: 
#line 282
  log_facility = 23 << 3;
#line 283
  break;
  default: 
#line 285
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unrecognized internal syslog facility code %d\n",
          (int )facility);
#line 288
  exit(1);
  }
#line 300
  if (argv0) {
#line 300
    tmp = argv0;
  } else {
#line 300
    tmp = __progname;
  }
#line 300
  openlog((char const   *)tmp, 1, log_facility);
#line 301
  closelog();
#line 303
  return;
}
}
#line 307 "log.c"
void do_log(LogLevel level , char const   *fmt , va_list args ) 
{ char msgbuf[1024] ;
  char fmtbuf[1024] ;
  char *txt ;
  int pri ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 315
  txt = (char *)((void *)0);
#line 316
  pri = 6;
#line 317
  tmp = __errno_location();
#line 317
  saved_errno = *tmp;
#line 319
  if ((int )level > (int )log_level___0) {
#line 320
    return;
  }
#line 322
  switch ((int )level) {
  case 1: 
#line 324
  if (! log_on_stderr) {
#line 325
    txt = (char *)"fatal";
  }
#line 326
  pri = 2;
#line 327
  break;
  case 2: 
#line 329
  if (! log_on_stderr) {
#line 330
    txt = (char *)"error";
  }
#line 331
  pri = 3;
#line 332
  break;
  case 3: 
#line 334
  pri = 6;
#line 335
  break;
  case 4: 
#line 337
  pri = 6;
#line 338
  break;
  case 5: 
#line 340
  txt = (char *)"debug1";
#line 341
  pri = 7;
#line 342
  break;
  case 6: 
#line 344
  txt = (char *)"debug2";
#line 345
  pri = 7;
#line 346
  break;
  case 7: 
#line 348
  txt = (char *)"debug3";
#line 349
  pri = 7;
#line 350
  break;
  default: 
#line 352
  txt = (char *)"internal error";
#line 353
  pri = 3;
#line 354
  break;
  }
#line 356
  if ((unsigned int )txt != (unsigned int )((void *)0)) {
#line 357
    snprintf((char * __restrict  )(fmtbuf), sizeof(fmtbuf), (char const   * __restrict  )"%s: %s",
             txt, fmt);
#line 358
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )(fmtbuf),
              args);
  } else {
#line 360
    vsnprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )fmt,
              args);
  }
#line 362
  if (log_on_stderr) {
#line 362
    tmp___0 = 33;
  } else {
#line 362
    tmp___0 = 27;
  }
#line 362
  strnvis(fmtbuf, (char const   *)(msgbuf), sizeof(fmtbuf), tmp___0);
#line 364
  if (log_on_stderr) {
#line 365
    snprintf((char * __restrict  )(msgbuf), sizeof(msgbuf), (char const   * __restrict  )"%s\r\n",
             fmtbuf);
#line 366
    tmp___1 = strlen((char const   *)(msgbuf));
#line 366
    write(2, (void const   *)(msgbuf), tmp___1);
  } else {
#line 373
    if (argv0) {
#line 373
      tmp___2 = argv0;
    } else {
#line 373
      tmp___2 = __progname;
    }
#line 373
    openlog((char const   *)tmp___2, 1, log_facility);
#line 374
    syslog(pri, "%.500s", fmtbuf);
#line 375
    closelog();
  }
#line 378
  tmp___3 = __errno_location();
#line 378
  *tmp___3 = saved_errno;
#line 379
  return;
}
}
#line 1 "match.o"
#line 116 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 17 "match.h"
int match_pattern(char const   *s , char const   *pattern ) ;
#line 20
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) ;
#line 21
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) ;
#line 22
char *match_list(char const   *client , char const   *server , u_int *next ) ;
#line 53 "match.c"
int match_pattern(char const   *s , char const   *pattern ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 56
  while (1) {
#line 58
    if (! *pattern) {
#line 59
      return (! *s);
    }
#line 61
    if ((int const   )*pattern == 42) {
#line 63
      pattern ++;
#line 66
      if (! *pattern) {
#line 67
        return (1);
      }
#line 70
      if ((int const   )*pattern != 63) {
#line 70
        if ((int const   )*pattern != 42) {
#line 76
          while (*s) {
#line 77
            if ((int const   )*s == (int const   )*pattern) {
#line 77
              tmp = match_pattern(s + 1, pattern + 1);
#line 77
              if (tmp) {
#line 79
                return (1);
              }
            }
#line 76
            s ++;
          }
#line 81
          return (0);
        }
      }
#line 87
      while (*s) {
#line 88
        tmp___0 = match_pattern(s, pattern);
#line 88
        if (tmp___0) {
#line 89
          return (1);
        }
#line 87
        s ++;
      }
#line 91
      return (0);
    }
#line 97
    if (! *s) {
#line 98
      return (0);
    }
#line 101
    if ((int const   )*pattern != 63) {
#line 101
      if ((int const   )*pattern != (int const   )*s) {
#line 102
        return (0);
      }
    }
#line 105
    s ++;
#line 106
    pattern ++;
  }
}
}
#line 118 "match.c"
int match_pattern_list(char const   *string , char const   *pattern , u_int len ,
                       int dolower ) 
{ char sub[1024] ;
  int negated ;
  int got_positive ;
  u_int i ;
  u_int subi ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;

  {
#line 127
  got_positive = 0;
#line 128
  i = 0U;
#line 128
  while (i < len) {
#line 130
    if ((int const   )*(pattern + i) == 33) {
#line 131
      negated = 1;
#line 132
      i ++;
    } else {
#line 134
      negated = 0;
    }
#line 140
    subi = 0U;
#line 140
    while (1) {
#line 140
      if (i < len) {
#line 140
        if (subi < sizeof(sub) - 1U) {
#line 140
          if (! ((int const   )*(pattern + i) != 44)) {
#line 140
            break;
          }
        } else {
#line 140
          break;
        }
      } else {
#line 140
        break;
      }
#line 144
      if (dolower) {
#line 144
        tmp___6 = __ctype_b_loc();
#line 144
        if ((int const   )*(*tmp___6 + (int )*(pattern + i)) & 256) {
#line 144
          if (sizeof(*(pattern + i)) > 1U) {
#line 144
            __res___0 = tolower((int )*(pattern + i));
          } else {
#line 144
            tmp___5 = __ctype_tolower_loc();
#line 144
            __res___0 = (int )*(*tmp___5 + (int )*(pattern + i));
          }
#line 144
          sub[subi] = (char )__res___0;
        } else {
#line 144
          sub[subi] = (char )*(pattern + i);
        }
      } else {
#line 144
        sub[subi] = (char )*(pattern + i);
      }
#line 140
      subi ++;
#line 140
      i ++;
    }
#line 146
    if (subi >= sizeof(sub) - 1U) {
#line 147
      return (0);
    }
#line 150
    if (i < len) {
#line 150
      if ((int const   )*(pattern + i) == 44) {
#line 151
        i ++;
      }
    }
#line 154
    sub[subi] = (char )'\000';
#line 157
    tmp___7 = match_pattern(string, (char const   *)(sub));
#line 157
    if (tmp___7) {
#line 158
      if (negated) {
#line 159
        return (-1);
      } else {
#line 161
        got_positive = 1;
      }
    }
  }
#line 169
  return (got_positive);
}
}
#line 178 "match.c"
int match_hostname(char const   *host , char const   *pattern , u_int len ) 
{ int tmp ;

  {
#line 181
  tmp = match_pattern_list(host, pattern, len, 1);
#line 181
  return (tmp);
}
}
#line 188 "match.c"
int match_host_and_ip(char const   *host , char const   *ipaddr , char const   *patterns ) 
{ int mhost ;
  int mip ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 195
  tmp = strlen(patterns);
#line 195
  mip = match_hostname(ipaddr, patterns, tmp);
#line 195
  if (mip == -1) {
#line 196
    return (0);
  }
#line 198
  tmp___0 = strlen(patterns);
#line 198
  mhost = match_hostname(host, patterns, tmp___0);
#line 198
  if (mhost == -1) {
#line 199
    return (0);
  }
#line 201
  if (mhost == 0) {
#line 201
    if (mip == 0) {
#line 202
      return (0);
    }
  }
#line 203
  return (1);
}
}
#line 209 "match.c"
int match_user(char const   *user , char const   *host , char const   *ipaddr , char const   *pattern ) 
{ char *p ;
  char *pat ;
  int ret___0 ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 216
  tmp___1 = __builtin_strchr((char *)pattern, '@');
#line 216
  p = tmp___1;
#line 216
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 217
    tmp = match_pattern(user, pattern);
#line 217
    return (tmp);
  }
#line 219
  pat = xstrdup(pattern);
#line 220
  tmp___3 = __builtin_strchr(pat, '@');
#line 220
  p = tmp___3;
#line 221
  tmp___4 = p;
#line 221
  p ++;
#line 221
  *tmp___4 = (char )'\000';
#line 223
  ret___0 = match_pattern(user, (char const   *)pat);
#line 223
  if (ret___0 == 1) {
#line 224
    ret___0 = match_host_and_ip(host, ipaddr, (char const   *)p);
  }
#line 225
  xfree((void *)pat);
#line 227
  return (ret___0);
}
}
#line 236 "match.c"
char *match_list(char const   *client , char const   *server , u_int *next ) 
{ char *sproposals[40] ;
  char *c ;
  char *s ;
  char *p ;
  char *ret___0 ;
  char *cp ;
  char *sp ;
  int i ;
  int j ;
  int nproposals ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;

  {
#line 243
  cp = xstrdup(client);
#line 243
  c = cp;
#line 244
  sp = xstrdup(server);
#line 244
  s = sp;
#line 246
  tmp___14 = __strsep_g(& sp, ",");
#line 246
  p = tmp___14;
#line 246
  i = 0;
#line 246
  while (1) {
#line 246
    if (p) {
#line 246
      if (! ((int )*p != 0)) {
#line 246
        break;
      }
    } else {
#line 246
      break;
    }
#line 248
    if (i < 40) {
#line 249
      sproposals[i] = p;
    } else {
#line 251
      break;
    }
#line 247
    tmp___30 = __strsep_g(& sp, ",");
#line 247
    p = tmp___30;
#line 247
    i ++;
  }
#line 253
  nproposals = i;
#line 255
  tmp___46 = __strsep_g(& cp, ",");
#line 255
  p = tmp___46;
#line 255
  i = 0;
#line 255
  while (1) {
#line 255
    if (p) {
#line 255
      if (! ((int )*p != 0)) {
#line 255
        break;
      }
    } else {
#line 255
      break;
    }
#line 257
    j = 0;
#line 257
    while (j < nproposals) {
#line 258
      if (0) {
#line 258
        __s1_len = strlen((char const   *)p);
#line 258
        __s2_len = strlen((char const   *)sproposals[j]);
#line 258
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 258
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 258
            if (! ((unsigned int )((void const   *)(sproposals[j] + 1)) - (unsigned int )((void const   *)sproposals[j]) == 1U)) {
#line 258
              tmp___73 = 1;
            } else {
#line 258
              if (__s2_len >= 4U) {
#line 258
                tmp___73 = 1;
              } else {
#line 258
                tmp___73 = 0;
              }
            }
          } else {
#line 258
            tmp___73 = 0;
          }
        }
#line 258
        if (tmp___73) {
#line 258
          tmp___69 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
        } else {
#line 258
          tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 258
          tmp___69 = tmp___72;
        }
      } else {
#line 258
        tmp___72 = __builtin_strcmp((char const   *)p, (char const   *)sproposals[j]);
#line 258
        tmp___69 = tmp___72;
      }
#line 258
      if (tmp___69 == 0) {
#line 259
        ret___0 = xstrdup((char const   *)p);
#line 260
        if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 261
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 261
            *next = strlen((char const   *)c);
          } else {
#line 261
            *next = (unsigned int )(cp - c);
          }
        }
#line 263
        xfree((void *)c);
#line 264
        xfree((void *)s);
#line 265
        return (ret___0);
      }
#line 257
      j ++;
    }
#line 256
    tmp___62 = __strsep_g(& cp, ",");
#line 256
    p = tmp___62;
#line 256
    i ++;
  }
#line 269
  if ((unsigned int )next != (unsigned int )((void *)0)) {
#line 270
    *next = strlen((char const   *)c);
  }
#line 271
  xfree((void *)c);
#line 272
  xfree((void *)s);
#line 273
  return ((char *)((void *)0));
}
}
#line 1 "md-sha256.o"
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
#line 1 "moduli.o"
#line 188 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
#line 338
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 338 "/usr/include/stdlib.h"
__inline static unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ unsigned long tmp ;

  {
#line 342
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
#line 342
  return (tmp);
}
}
#line 218 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 393 "/usr/include/openssl/bn.h"
extern BN_CTX *BN_CTX_new(void) ;
#line 397
extern void BN_CTX_free(BN_CTX *c ) ;
#line 401
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 407
extern BIGNUM *BN_new(void) ;
#line 410
extern BIGNUM *BN_copy(BIGNUM *a , BIGNUM const   *b ) ;
#line 419
extern int BN_add(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 449
extern unsigned long BN_mod_word(BIGNUM const   *a , unsigned long w ) ;
#line 452
extern int BN_add_word(BIGNUM *a , unsigned long w ) ;
#line 454
extern int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 458
extern void BN_free(BIGNUM *a ) ;
#line 460
extern int BN_lshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 480
extern int BN_print_fp(FILE *fp , BIGNUM const   *a ) ;
#line 488
extern int BN_rshift(BIGNUM *r , BIGNUM const   *a , int n ) ;
#line 493
extern int BN_set_bit(BIGNUM *a , int n ) ;
#line 495
extern char *BN_bn2hex(BIGNUM const   *a ) ;
#line 497
extern int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 511
extern int BN_is_prime(BIGNUM const   *p , int nchecks , void (*callback)(int  , int  ,
                                                                          void * ) ,
                       BN_CTX *ctx , void *cb_arg ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 232
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 257
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 146 "moduli.c"
static u_int32_t *TinySieve  ;
#line 146 "moduli.c"
static u_int32_t tinybits  ;
#line 149 "moduli.c"
static u_int32_t *SmallSieve  ;
#line 149 "moduli.c"
static u_int32_t smallbits  ;
#line 149 "moduli.c"
static u_int32_t smallbase  ;
#line 152 "moduli.c"
static u_int32_t *LargeSieve  ;
#line 152 "moduli.c"
static u_int32_t largewords  ;
#line 152 "moduli.c"
static u_int32_t largetries  ;
#line 152 "moduli.c"
static u_int32_t largenumbers  ;
#line 153 "moduli.c"
static u_int32_t largebits  ;
#line 153 "moduli.c"
static u_int32_t largememory  ;
#line 154 "moduli.c"
static BIGNUM *largebase  ;
#line 156
int gen_candidates(FILE *out , u_int32_t memory , u_int32_t power , BIGNUM *start___0 ) ;
#line 157
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) ;
#line 162 "moduli.c"
static int qfileout(FILE *ofile , u_int32_t otype , u_int32_t otests , u_int32_t otries ,
                    u_int32_t osize , u_int32_t ogenerator , BIGNUM *omodulus ) 
{ struct tm *gtm ;
  time_t time_now ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
#line 170
  time(& time_now);
#line 171
  gtm = gmtime((time_t const   *)(& time_now));
#line 173
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"%04d%02d%02d%02d%02d%02d %u %u %u %u %x ",
                gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday, gtm->tm_hour,
                gtm->tm_min, gtm->tm_sec, otype, otests, otries, osize, ogenerator);
#line 178
  if (res < 0) {
#line 179
    return (-1);
  }
#line 181
  tmp = BN_print_fp(ofile, (BIGNUM const   *)omodulus);
#line 181
  if (tmp < 1) {
#line 182
    return (-1);
  }
#line 184
  res = fprintf((FILE * __restrict  )ofile, (char const   * __restrict  )"\n");
#line 185
  fflush(ofile);
#line 187
  if (res > 0) {
#line 187
    tmp___0 = 0;
  } else {
#line 187
    tmp___0 = -1;
  }
#line 187
  return (tmp___0);
}
}
#line 194 "moduli.c"
static void sieve_large(u_int32_t s ) 
{ u_int32_t r ;
  u_int32_t u ;
  unsigned long tmp ;

  {
#line 199
  debug3("sieve_large %u", s);
#line 200
  largetries ++;
#line 202
  tmp = BN_mod_word((BIGNUM const   *)largebase, (unsigned long )s);
#line 202
  r = (unsigned int )tmp;
#line 203
  if (r == 0U) {
#line 204
    u = 0U;
  } else {
#line 206
    u = s - r;
  }
#line 208
  if (u < largebits * 2U) {
#line 214
    if (u & 1U) {
#line 215
      u += s;
    }
#line 218
    u /= 2U;
#line 218
    while (u < largebits) {
#line 219
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 218
      u += s;
    }
  }
#line 223
  r = (2U * r + 1U) % s;
#line 224
  if (r == 0U) {
#line 225
    u = 0U;
  } else {
#line 227
    u = s - r;
  }
#line 229
  if (u < largebits * 4U) {
#line 235
    while (u & 3U) {
#line 236
      if (4294967295UL - (unsigned long )u < (unsigned long )s) {
#line 237
        return;
      }
#line 238
      u += s;
    }
#line 242
    u /= 4U;
#line 242
    while (u < largebits) {
#line 243
      *(LargeSieve + (u >> 5)) = (unsigned int )((unsigned long )*(LargeSieve + (u >> 5)) | (unsigned long )(1L << (u & 31U)));
#line 242
      u += s;
    }
  }
#line 245
  return;
}
}
#line 252 "moduli.c"
int gen_candidates(FILE *out , u_int32_t memory , u_int32_t power , BIGNUM *start___0 ) 
{ BIGNUM *q ;
  u_int32_t j ;
  u_int32_t r ;
  u_int32_t s ;
  u_int32_t t ;
  u_int32_t smallwords ;
  u_int32_t tinywords ;
  time_t time_start ;
  time_t time_stop ;
  u_int32_t i ;
  int ret___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  BIGNUM *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 257
  smallwords = (u_int32_t )((1UL << 16) >> 6);
#line 258
  tinywords = (u_int32_t )((1UL << 16) >> 6);
#line 261
  ret___0 = 0;
#line 263
  largememory = memory;
#line 265
  if (memory != 0U) {
#line 265
    if ((unsigned long )memory < 8UL) {
#line 267
      error("Invalid memory amount (min %ld, max %ld)", 8UL, 127UL);
#line 269
      return (-1);
    } else {
#line 265
      if ((unsigned long )memory > 127UL) {
#line 267
        error("Invalid memory amount (min %ld, max %ld)", 8UL, 127UL);
#line 269
        return (-1);
      }
    }
  }
#line 276
  if ((unsigned long )power > 1UL << 16) {
#line 277
    error("Too many bits: %u > %lu", power, 1UL << 16);
#line 278
    return (-1);
  } else {
#line 279
    if (power < 512U) {
#line 280
      error("Too few bits: %u < %u", power, 512);
#line 281
      return (-1);
    }
  }
#line 283
  power --;
#line 291
  largewords = power * power >> 2;
#line 297
  if ((unsigned long )largememory > 127UL) {
#line 298
    logit("Limited memory: %u MB; limit %lu MB", largememory, 127UL);
#line 300
    largememory = 127U;
  }
#line 303
  if (largewords <= largememory << 18) {
#line 304
    logit("Increased memory: %u MB; need %u bytes", largememory, largewords << 2);
#line 306
    largewords = largememory << 18;
  } else {
#line 307
    if (largememory > 0U) {
#line 308
      logit("Decreased memory: %u MB; want %u bytes", largememory, largewords << 2);
#line 310
      largewords = largememory << 18;
    }
  }
#line 313
  tmp = xcalloc(tinywords, sizeof(u_int32_t ));
#line 313
  TinySieve = (u_int32_t *)tmp;
#line 314
  tinybits = tinywords << 5;
#line 316
  tmp___0 = xcalloc(smallwords, sizeof(u_int32_t ));
#line 316
  SmallSieve = (u_int32_t *)tmp___0;
#line 317
  smallbits = smallwords << 5;
#line 322
  while (1) {
#line 322
    tmp___1 = calloc(largewords, sizeof(u_int32_t ));
#line 322
    LargeSieve = (u_int32_t *)tmp___1;
#line 322
    if (! ((unsigned int )LargeSieve == (unsigned int )((void *)0))) {
#line 322
      break;
    }
#line 323
    largewords = (unsigned int )((unsigned long )largewords - (unsigned long )(1L << 16));
  }
#line 325
  largebits = largewords << 5;
#line 326
  largenumbers = largebits * 2U;
#line 329
  largetries = 0U;
#line 330
  q = BN_new();
#line 330
  if ((unsigned int )q == (unsigned int )((void *)0)) {
#line 331
    fatal("BN_new failed");
  }
#line 337
  largebase = BN_new();
#line 337
  if ((unsigned int )largebase == (unsigned int )((void *)0)) {
#line 338
    fatal("BN_new failed");
  }
#line 339
  if ((unsigned int )start___0 == (unsigned int )((void *)0)) {
#line 340
    tmp___2 = BN_rand(largebase, (int )power, 1, 1);
#line 340
    if (tmp___2 == 0) {
#line 341
      fatal("BN_rand failed");
    }
  } else {
#line 343
    tmp___3 = BN_copy(largebase, (BIGNUM const   *)start___0);
#line 343
    if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 344
      fatal("BN_copy: failed");
    }
  }
#line 348
  tmp___4 = BN_set_bit(largebase, 0);
#line 348
  if (tmp___4 == 0) {
#line 349
    fatal("BN_set_bit: failed");
  }
#line 351
  time(& time_start);
#line 353
  tmp___5 = ctime((time_t const   *)(& time_start));
#line 353
  logit("%.24s Sieve next %u plus %u-bit", tmp___5, largenumbers, power);
#line 355
  tmp___6 = BN_bn2hex((BIGNUM const   *)largebase);
#line 355
  debug2("start point: 0x%s", tmp___6);
#line 360
  i = 0U;
#line 360
  while (i < tinybits) {
#line 361
    if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
      goto __Cont;
    }
#line 365
    t = 2U * i + 3U;
#line 368
    j = i + t;
#line 368
    while (j < tinybits) {
#line 369
      *(TinySieve + (j >> 5)) = (unsigned int )((unsigned long )*(TinySieve + (j >> 5)) | (unsigned long )(1L << (j & 31U)));
#line 368
      j += t;
    }
#line 371
    sieve_large(t);
    __Cont: /* CIL Label */ 
#line 360
    i ++;
  }
#line 378
  smallbase = (unsigned int )((1UL << 16) + 3UL);
#line 378
  while ((unsigned long )smallbase < 4294967295UL - (1UL << 16)) {
#line 381
    i = 0U;
#line 381
    while (i < tinybits) {
#line 382
      if ((unsigned long )*(TinySieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
        goto __Cont___0;
      }
#line 386
      t = 2U * i + 3U;
#line 387
      r = smallbase % t;
#line 389
      if (r == 0U) {
#line 390
        s = 0U;
      } else {
#line 393
        s = t - r;
      }
#line 401
      if (s & 1U) {
#line 402
        s += t;
      }
#line 405
      s /= 2U;
#line 405
      while (s < smallbits) {
#line 406
        *(SmallSieve + (s >> 5)) = (unsigned int )((unsigned long )*(SmallSieve + (s >> 5)) | (unsigned long )(1L << (s & 31U)));
#line 405
        s += t;
      }
      __Cont___0: /* CIL Label */ 
#line 381
      i ++;
    }
#line 412
    i = 0U;
#line 412
    while (i < smallbits) {
#line 413
      if ((unsigned long )*(SmallSieve + (i >> 5)) & (unsigned long )(1L << (i & 31U))) {
        goto __Cont___1;
      }
#line 417
      sieve_large(2U * i + smallbase);
      __Cont___1: /* CIL Label */ 
#line 412
      i ++;
    }
#line 420
    memset((void *)SmallSieve, 0, smallwords << 2);
#line 378
    smallbase = (unsigned int )((unsigned long )smallbase + (1UL << 16));
  }
#line 423
  time(& time_stop);
#line 425
  tmp___7 = ctime((time_t const   *)(& time_stop));
#line 425
  logit("%.24s Sieved with %u small primes in %ld seconds", tmp___7, largetries, time_stop - time_start);
#line 428
  r = 0U;
#line 428
  j = r;
#line 428
  while (j < largebits) {
#line 429
    if ((unsigned long )*(LargeSieve + (j >> 5)) & (unsigned long )(1L << (j & 31U))) {
      goto __Cont___2;
    }
#line 432
    debug2("test q = largebase+%u", 2U * j);
#line 433
    tmp___8 = BN_set_word(q, (unsigned long )(2U * j));
#line 433
    if (tmp___8 == 0) {
#line 434
      fatal("BN_set_word failed");
    }
#line 435
    tmp___9 = BN_add(q, (BIGNUM const   *)q, (BIGNUM const   *)largebase);
#line 435
    if (tmp___9 == 0) {
#line 436
      fatal("BN_add failed");
    }
#line 437
    tmp___10 = qfileout(out, 4U, 2U, largetries, power - 1U, 0U, q);
#line 437
    if (tmp___10 == -1) {
#line 439
      ret___0 = -1;
#line 440
      break;
    }
#line 443
    r ++;
    __Cont___2: /* CIL Label */ 
#line 428
    j ++;
  }
#line 446
  time(& time_stop);
#line 448
  xfree((void *)LargeSieve);
#line 449
  xfree((void *)SmallSieve);
#line 450
  xfree((void *)TinySieve);
#line 452
  tmp___11 = ctime((time_t const   *)(& time_stop));
#line 452
  logit("%.24s Found %u candidates", tmp___11, r);
#line 454
  return (ret___0);
}
}
#line 463 "moduli.c"
int prime_test(FILE *in , FILE *out , u_int32_t trials , u_int32_t generator_wanted ) 
{ BIGNUM *q ;
  BIGNUM *p ;
  BIGNUM *a___0 ;
  BN_CTX *ctx ;
  char *cp ;
  char *lp ;
  u_int32_t count_in ;
  u_int32_t count_out ;
  u_int32_t count_possible ;
  u_int32_t generator_known ;
  u_int32_t in_tests ;
  u_int32_t in_tries ;
  u_int32_t in_type ;
  u_int32_t in_size ;
  time_t time_start ;
  time_t time_stop ;
  int res ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  u_int32_t r ;
  unsigned long tmp___45 ;
  unsigned long tmp___46 ;
  unsigned long tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;

  {
#line 469
  count_in = (u_int32_t )0;
#line 469
  count_out = (u_int32_t )0;
#line 469
  count_possible = (u_int32_t )0;
#line 474
  if (trials < 4U) {
#line 475
    error("Minimum primality trials is %d", 4);
#line 476
    return (-1);
  }
#line 479
  time(& time_start);
#line 481
  p = BN_new();
#line 481
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 482
    fatal("BN_new failed");
  }
#line 483
  q = BN_new();
#line 483
  if ((unsigned int )q == (unsigned int )((void *)0)) {
#line 484
    fatal("BN_new failed");
  }
#line 485
  ctx = BN_CTX_new();
#line 485
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 486
    fatal("BN_CTX_new failed");
  }
#line 488
  tmp = ctime((time_t const   *)(& time_start));
#line 488
  debug2("%.24s Final %u Miller-Rabin trials (%x generator)", tmp, trials, generator_wanted);
#line 491
  res = 0;
#line 492
  tmp___0 = xmalloc(8293U);
#line 492
  lp = (char *)tmp___0;
#line 493
  while (1) {
#line 493
    tmp___52 = fgets((char * __restrict  )lp, 8293, (FILE * __restrict  )in);
#line 493
    if (! ((unsigned int )tmp___52 != (unsigned int )((void *)0))) {
#line 493
      break;
    }
#line 494
    count_in ++;
#line 495
    tmp___1 = strlen((char const   *)lp);
#line 495
    if (tmp___1 < 14U) {
#line 496
      debug2("%10u: comment or short line", count_in);
#line 497
      continue;
    } else {
#line 495
      if ((int )*lp == 33) {
#line 496
        debug2("%10u: comment or short line", count_in);
#line 497
        continue;
      } else {
#line 495
        if ((int )*lp == 35) {
#line 496
          debug2("%10u: comment or short line", count_in);
#line 497
          continue;
        }
      }
    }
#line 502
    cp = lp + 14;
#line 505
    tmp___2 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 505
    in_type = (unsigned int )tmp___2;
#line 508
    tmp___3 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 508
    in_tests = (unsigned int )tmp___3;
#line 510
    if (in_tests & 1U) {
#line 511
      debug2("%10u: known composite", count_in);
#line 512
      continue;
    }
#line 516
    tmp___4 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 516
    in_tries = (unsigned int )tmp___4;
#line 519
    tmp___5 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      10);
#line 519
    in_size = (unsigned int )tmp___5;
#line 522
    tmp___6 = strtoul((char const   * __restrict  )cp, (char ** __restrict  )(& cp),
                      16);
#line 522
    generator_known = (unsigned int )tmp___6;
#line 525
    tmp___38 = __builtin_strspn((char const   *)cp, " ");
#line 525
    cp += tmp___38;
#line 528
    switch ((int )in_type) {
    case 4: 
#line 530
    debug2("%10u: (%u) Sophie-Germain", count_in, in_type);
#line 531
    a___0 = q;
#line 532
    tmp___39 = BN_hex2bn(& a___0, (char const   *)cp);
#line 532
    if (tmp___39 == 0) {
#line 533
      fatal("BN_hex2bn failed");
    }
#line 535
    tmp___40 = BN_lshift(p, (BIGNUM const   *)q, 1);
#line 535
    if (tmp___40 == 0) {
#line 536
      fatal("BN_lshift failed");
    }
#line 537
    tmp___41 = BN_add_word(p, 1UL);
#line 537
    if (tmp___41 == 0) {
#line 538
      fatal("BN_add_word failed");
    }
#line 539
    in_size ++;
#line 540
    generator_known = 0U;
#line 541
    break;
    case 1: 
    case 2: 
    case 3: 
    case 5: 
    case 0: 
#line 547
    debug2("%10u: (%u)", count_in, in_type);
#line 548
    a___0 = p;
#line 549
    tmp___42 = BN_hex2bn(& a___0, (char const   *)cp);
#line 549
    if (tmp___42 == 0) {
#line 550
      fatal("BN_hex2bn failed");
    }
#line 552
    tmp___43 = BN_rshift(q, (BIGNUM const   *)p, 1);
#line 552
    if (tmp___43 == 0) {
#line 553
      fatal("BN_rshift failed");
    }
#line 554
    break;
    default: 
#line 556
    debug2("Unknown prime type");
#line 557
    break;
    }
#line 564
    tmp___44 = BN_num_bits((BIGNUM const   *)p);
#line 564
    if ((unsigned int )tmp___44 != in_size + 1U) {
#line 565
      debug2("%10u: bit size %u mismatch", count_in, in_size);
#line 566
      continue;
    }
#line 568
    if (in_size < 511U) {
#line 569
      debug2("%10u: bit size %u too short", count_in, in_size);
#line 570
      continue;
    }
#line 573
    if (in_tests & 4U) {
#line 574
      in_tries += trials;
    } else {
#line 576
      in_tries = trials;
    }
#line 581
    if (generator_known == 0U) {
#line 582
      tmp___47 = BN_mod_word((BIGNUM const   *)p, 24UL);
#line 582
      if (tmp___47 == 11UL) {
#line 583
        generator_known = 2U;
      } else {
#line 584
        tmp___46 = BN_mod_word((BIGNUM const   *)p, 12UL);
#line 584
        if (tmp___46 == 5UL) {
#line 585
          generator_known = 3U;
        } else {
#line 587
          tmp___45 = BN_mod_word((BIGNUM const   *)p, 10UL);
#line 587
          r = (u_int32_t )tmp___45;
#line 589
          if (r == 3U) {
#line 590
            generator_known = 5U;
          } else {
#line 589
            if (r == 7U) {
#line 590
              generator_known = 5U;
            }
          }
        }
      }
    }
#line 596
    if (generator_wanted > 0U) {
#line 596
      if (generator_wanted != generator_known) {
#line 598
        debug2("%10u: generator %d != %d", count_in, generator_known, generator_wanted);
#line 600
        continue;
      }
    }
#line 607
    if (generator_known == 0U) {
#line 608
      debug2("%10u: no known generator", count_in);
#line 609
      continue;
    }
#line 612
    count_possible ++;
#line 621
    tmp___48 = BN_is_prime((BIGNUM const   *)q, 1, (void (*)(int  , int  , void * ))((void *)0),
                           ctx, (void *)0);
#line 621
    if (tmp___48 <= 0) {
#line 622
      debug("%10u: q failed first possible prime test", count_in);
#line 624
      continue;
    }
#line 634
    tmp___49 = BN_is_prime((BIGNUM const   *)p, (int )trials, (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                           ctx, (void *)0);
#line 634
    if (! tmp___49) {
#line 635
      debug("%10u: p is not prime", count_in);
#line 636
      continue;
    }
#line 638
    debug("%10u: p is almost certainly prime", count_in);
#line 641
    tmp___50 = BN_is_prime((BIGNUM const   *)q, (int )(trials - 1U), (void (*)(int  ,
                                                                               int  ,
                                                                               void * ))((void *)0),
                           ctx, (void *)0);
#line 641
    if (! tmp___50) {
#line 642
      debug("%10u: q is not prime", count_in);
#line 643
      continue;
    }
#line 645
    debug("%10u: q is almost certainly prime", count_in);
#line 647
    tmp___51 = qfileout(out, 2U, in_tests | 4U, in_tries, in_size, generator_known,
                        p);
#line 647
    if (tmp___51) {
#line 649
      res = -1;
#line 650
      break;
    }
#line 653
    count_out ++;
  }
#line 656
  time(& time_stop);
#line 657
  xfree((void *)lp);
#line 658
  BN_free(p);
#line 659
  BN_free(q);
#line 660
  BN_CTX_free(ctx);
#line 662
  tmp___53 = ctime((time_t const   *)(& time_stop));
#line 662
  logit("%.24s Found %u safe primes of %u candidates in %ld seconds", tmp___53, count_out,
        count_possible, time_stop - time_start);
#line 666
  return (res);
}
}
#line 1 "nchan.o"
#line 76 "nchan.c"
static void chan_send_ieof1(Channel *c ) ;
#line 77
static void chan_send_oclose1(Channel *c ) ;
#line 78
static void chan_send_close2(Channel *c ) ;
#line 79
static void chan_send_eof2(Channel *c ) ;
#line 82
static void chan_shutdown_write(Channel *c ) ;
#line 83
static void chan_shutdown_read(Channel *c ) ;
#line 85 "nchan.c"
static char *ostates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_ieof",      (char *)"closed"};
#line 86 "nchan.c"
static char *istates[4]  = {      (char *)"open",      (char *)"drain",      (char *)"wait_oclose",      (char *)"closed"};
#line 88 "nchan.c"
static void chan_set_istate(Channel *c , u_int next ) 
{ 

  {
#line 91
  if (c->istate > 3U) {
#line 92
    fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
  } else {
#line 91
    if (next > 3U) {
#line 92
      fatal("chan_set_istate: bad state %d -> %d", c->istate, next);
    }
  }
#line 93
  debug2("channel %d: input %s -> %s", c->self, istates[c->istate], istates[next]);
#line 95
  c->istate = next;
#line 96
  return;
}
}
#line 97 "nchan.c"
static void chan_set_ostate(Channel *c , u_int next ) 
{ 

  {
#line 100
  if (c->ostate > 3U) {
#line 101
    fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
  } else {
#line 100
    if (next > 3U) {
#line 101
      fatal("chan_set_ostate: bad state %d -> %d", c->ostate, next);
    }
  }
#line 102
  debug2("channel %d: output %s -> %s", c->self, ostates[c->ostate], ostates[next]);
#line 104
  c->ostate = next;
#line 105
  return;
}
}
#line 111 "nchan.c"
static void chan_rcvd_oclose1(Channel *c ) 
{ 

  {
#line 114
  debug2("channel %d: rcvd oclose", c->self);
#line 115
  switch ((int )c->istate) {
  case 2: 
#line 117
  chan_set_istate(c, 3U);
#line 118
  break;
  case 0: 
#line 120
  chan_shutdown_read(c);
#line 121
  chan_send_ieof1(c);
#line 122
  chan_set_istate(c, 3U);
#line 123
  break;
  case 1: 
#line 126
  chan_send_ieof1(c);
#line 127
  chan_set_istate(c, 3U);
#line 128
  break;
  default: 
#line 130
  error("channel %d: protocol error: rcvd_oclose for istate %d", c->self, c->istate);
#line 132
  return;
  }
#line 134
  return;
}
}
#line 135 "nchan.c"
void chan_read_failed(Channel *c ) 
{ 

  {
#line 138
  debug2("channel %d: read failed", c->self);
#line 139
  switch ((int )c->istate) {
  case 0: 
#line 141
  chan_shutdown_read(c);
#line 142
  chan_set_istate(c, 1U);
#line 143
  break;
  default: 
#line 145
  error("channel %d: chan_read_failed for istate %d", c->self, c->istate);
#line 147
  break;
  }
#line 149
  return;
}
}
#line 150 "nchan.c"
void chan_ibuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 153
  debug2("channel %d: ibuf empty", c->self);
#line 154
  tmp = buffer_len(& c->input);
#line 154
  if (tmp) {
#line 155
    error("channel %d: chan_ibuf_empty for non empty buffer", c->self);
#line 157
    return;
  }
#line 159
  switch ((int )c->istate) {
  case 1: 
#line 161
  if (compat20) {
#line 162
    if (! (c->flags & 1)) {
#line 163
      chan_send_eof2(c);
    }
#line 164
    chan_set_istate(c, 3U);
  } else {
#line 166
    chan_send_ieof1(c);
#line 167
    chan_set_istate(c, 2U);
  }
#line 169
  break;
  default: 
#line 171
  error("channel %d: chan_ibuf_empty for istate %d", c->self, c->istate);
#line 173
  break;
  }
#line 175
  return;
}
}
#line 176 "nchan.c"
static void chan_rcvd_ieof1(Channel *c ) 
{ 

  {
#line 179
  debug2("channel %d: rcvd ieof", c->self);
#line 180
  switch ((int )c->ostate) {
  case 0: 
#line 182
  chan_set_ostate(c, 1U);
#line 183
  break;
  case 2: 
#line 185
  chan_set_ostate(c, 3U);
#line 186
  break;
  default: 
#line 188
  error("channel %d: protocol error: rcvd_ieof for ostate %d", c->self, c->ostate);
#line 190
  break;
  }
#line 192
  return;
}
}
#line 193 "nchan.c"
static void chan_write_failed1(Channel *c ) 
{ 

  {
#line 196
  debug2("channel %d: write failed", c->self);
#line 197
  switch ((int )c->ostate) {
  case 0: 
#line 199
  chan_shutdown_write(c);
#line 200
  chan_send_oclose1(c);
#line 201
  chan_set_ostate(c, 2U);
#line 202
  break;
  case 1: 
#line 204
  chan_shutdown_write(c);
#line 205
  chan_send_oclose1(c);
#line 206
  chan_set_ostate(c, 3U);
#line 207
  break;
  default: 
#line 209
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 211
  break;
  }
#line 213
  return;
}
}
#line 214 "nchan.c"
void chan_obuf_empty(Channel *c ) 
{ u_int tmp ;

  {
#line 217
  debug2("channel %d: obuf empty", c->self);
#line 218
  tmp = buffer_len(& c->output);
#line 218
  if (tmp) {
#line 219
    error("channel %d: chan_obuf_empty for non empty buffer", c->self);
#line 221
    return;
  }
#line 223
  switch ((int )c->ostate) {
  case 1: 
#line 225
  chan_shutdown_write(c);
#line 226
  if (! compat20) {
#line 227
    chan_send_oclose1(c);
  }
#line 228
  chan_set_ostate(c, 3U);
#line 229
  break;
  default: 
#line 231
  error("channel %d: internal error: obuf_empty for ostate %d", c->self, c->ostate);
#line 233
  break;
  }
#line 235
  return;
}
}
#line 236 "nchan.c"
static void chan_send_ieof1(Channel *c ) 
{ 

  {
#line 239
  debug2("channel %d: send ieof", c->self);
#line 240
  switch ((int )c->istate) {
  case 0: 
  case 1: 
#line 243
  packet_start((unsigned char)24);
#line 244
  packet_put_int((unsigned int )c->remote_id);
#line 245
  packet_send();
#line 246
  break;
  default: 
#line 248
  error("channel %d: cannot send ieof for istate %d", c->self, c->istate);
#line 250
  break;
  }
#line 252
  return;
}
}
#line 253 "nchan.c"
static void chan_send_oclose1(Channel *c ) 
{ 

  {
#line 256
  debug2("channel %d: send oclose", c->self);
#line 257
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 260
  buffer_clear(& c->output);
#line 261
  packet_start((unsigned char)25);
#line 262
  packet_put_int((unsigned int )c->remote_id);
#line 263
  packet_send();
#line 264
  break;
  default: 
#line 266
  error("channel %d: cannot send oclose for ostate %d", c->self, c->ostate);
#line 268
  break;
  }
#line 270
  return;
}
}
#line 275 "nchan.c"
static void chan_rcvd_close2(Channel *c ) 
{ 

  {
#line 278
  debug2("channel %d: rcvd close", c->self);
#line 279
  if (c->flags & 2) {
#line 280
    error("channel %d: protocol error: close rcvd twice", c->self);
  }
#line 281
  c->flags |= 2;
#line 282
  if (c->type == 10) {
#line 284
    chan_set_ostate(c, 3U);
#line 285
    chan_set_istate(c, 3U);
#line 286
    return;
  }
#line 288
  switch ((int )c->ostate) {
  case 0: 
#line 294
  chan_set_ostate(c, 1U);
#line 295
  break;
  }
#line 297
  switch ((int )c->istate) {
  case 0: 
#line 299
  chan_shutdown_read(c);
#line 300
  chan_set_istate(c, 3U);
#line 301
  break;
  case 1: 
#line 303
  chan_send_eof2(c);
#line 304
  chan_set_istate(c, 3U);
#line 305
  break;
  }
#line 307
  return;
}
}
#line 308 "nchan.c"
static void chan_rcvd_eof2(Channel *c ) 
{ 

  {
#line 311
  debug2("channel %d: rcvd eof", c->self);
#line 312
  c->flags |= 8;
#line 313
  if (c->ostate == 0U) {
#line 314
    chan_set_ostate(c, 1U);
  }
#line 315
  return;
}
}
#line 316 "nchan.c"
static void chan_write_failed2(Channel *c ) 
{ 

  {
#line 319
  debug2("channel %d: write failed", c->self);
#line 320
  switch ((int )c->ostate) {
  case 0: 
  case 1: 
#line 323
  chan_shutdown_write(c);
#line 324
  chan_set_ostate(c, 3U);
#line 325
  break;
  default: 
#line 327
  error("channel %d: chan_write_failed for ostate %d", c->self, c->ostate);
#line 329
  break;
  }
#line 331
  return;
}
}
#line 332 "nchan.c"
static void chan_send_eof2(Channel *c ) 
{ 

  {
#line 335
  debug2("channel %d: send eof", c->self);
#line 336
  switch ((int )c->istate) {
  case 1: 
#line 338
  packet_start((unsigned char)96);
#line 339
  packet_put_int((unsigned int )c->remote_id);
#line 340
  packet_send();
#line 341
  c->flags |= 4;
#line 342
  break;
  default: 
#line 344
  error("channel %d: cannot send eof for istate %d", c->self, c->istate);
#line 346
  break;
  }
#line 348
  return;
}
}
#line 349 "nchan.c"
static void chan_send_close2(Channel *c ) 
{ 

  {
#line 352
  debug2("channel %d: send close", c->self);
#line 353
  if (c->ostate != 3U) {
#line 355
    error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
          c->ostate);
  } else {
#line 353
    if (c->istate != 3U) {
#line 355
      error("channel %d: cannot send close for istate/ostate %d/%d", c->self, c->istate,
            c->ostate);
    } else {
#line 357
      if (c->flags & 1) {
#line 358
        error("channel %d: already sent close", c->self);
      } else {
#line 360
        packet_start((unsigned char)97);
#line 361
        packet_put_int((unsigned int )c->remote_id);
#line 362
        packet_send();
#line 363
        c->flags |= 1;
      }
    }
  }
#line 365
  return;
}
}
#line 369 "nchan.c"
void chan_rcvd_ieof(Channel *c ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 372
  if (compat20) {
#line 373
    chan_rcvd_eof2(c);
  } else {
#line 375
    chan_rcvd_ieof1(c);
  }
#line 376
  if (c->ostate == 1U) {
#line 376
    tmp = buffer_len(& c->output);
#line 376
    if (tmp == 0U) {
#line 376
      if (compat20) {
#line 376
        if (c->extended_usage == 2) {
#line 376
          if (c->efd != -1) {
#line 376
            if (! (! (c->flags & 10))) {
#line 376
              tmp___0 = buffer_len(& c->extended);
#line 376
              if (! (tmp___0 > 0U)) {
#line 379
                chan_obuf_empty(c);
              }
            }
          } else {
#line 379
            chan_obuf_empty(c);
          }
        } else {
#line 379
          chan_obuf_empty(c);
        }
      } else {
#line 379
        chan_obuf_empty(c);
      }
    }
  }
#line 380
  return;
}
}
#line 381 "nchan.c"
void chan_rcvd_oclose(Channel *c ) 
{ 

  {
#line 384
  if (compat20) {
#line 385
    chan_rcvd_close2(c);
  } else {
#line 387
    chan_rcvd_oclose1(c);
  }
#line 388
  return;
}
}
#line 389 "nchan.c"
void chan_write_failed(Channel *c ) 
{ 

  {
#line 392
  if (compat20) {
#line 393
    chan_write_failed2(c);
  } else {
#line 395
    chan_write_failed1(c);
  }
#line 396
  return;
}
}
#line 398 "nchan.c"
void chan_mark_dead(Channel *c ) 
{ 

  {
#line 401
  c->type = 14;
#line 402
  return;
}
}
#line 404 "nchan.c"
int chan_is_dead(Channel *c , int do_send ) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 407
  if (c->type == 14) {
#line 408
    debug2("channel %d: zombie", c->self);
#line 409
    return (1);
  }
#line 411
  if (c->istate != 3U) {
#line 412
    return (0);
  } else {
#line 411
    if (c->ostate != 3U) {
#line 412
      return (0);
    }
  }
#line 413
  if (! compat20) {
#line 414
    debug2("channel %d: is dead", c->self);
#line 415
    return (1);
  }
#line 417
  if (datafellows & 2097152) {
#line 417
    if (c->extended_usage == 2) {
#line 417
      if (c->efd != -1) {
#line 417
        tmp___0 = buffer_len(& c->extended);
#line 417
        if (tmp___0 > 0U) {
#line 421
          tmp = buffer_len(& c->extended);
#line 421
          debug2("channel %d: active efd: %d len %d", c->self, c->efd, tmp);
#line 423
          return (0);
        }
      }
    }
  }
#line 425
  if (! (c->flags & 1)) {
#line 426
    if (do_send) {
#line 427
      chan_send_close2(c);
    } else {
#line 430
      if (c->flags & 2) {
#line 431
        debug2("channel %d: almost dead", c->self);
#line 433
        return (1);
      }
    }
  }
#line 437
  if (c->flags & 1) {
#line 437
    if (c->flags & 2) {
#line 439
      debug2("channel %d: is dead", c->self);
#line 440
      return (1);
    }
  }
#line 442
  return (0);
}
}
#line 446 "nchan.c"
static void chan_shutdown_write(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 449
  buffer_clear(& c->output);
#line 450
  if (compat20) {
#line 450
    if (c->type == 10) {
#line 451
      return;
    }
  }
#line 453
  debug2("channel %d: close_write", c->self);
#line 454
  if (c->sock != -1) {
#line 455
    tmp___1 = shutdown(c->sock, 1);
#line 455
    if (tmp___1 < 0) {
#line 456
      tmp = __errno_location();
#line 456
      tmp___0 = strerror(*tmp);
#line 456
      debug2("channel %d: chan_shutdown_write: shutdown() failed for fd%d: %.100s",
             c->self, c->sock, tmp___0);
    }
  } else {
#line 460
    tmp___4 = channel_close_fd(& c->wfd);
#line 460
    if (tmp___4 < 0) {
#line 461
      tmp___2 = __errno_location();
#line 461
      tmp___3 = strerror(*tmp___2);
#line 461
      logit("channel %d: chan_shutdown_write: close() failed for fd%d: %.100s", c->self,
            c->wfd, tmp___3);
    }
  }
#line 465
  return;
}
}
#line 466 "nchan.c"
static void chan_shutdown_read(Channel *c ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 469
  if (compat20) {
#line 469
    if (c->type == 10) {
#line 470
      return;
    }
  }
#line 471
  debug2("channel %d: close_read", c->self);
#line 472
  if (c->sock != -1) {
#line 478
    tmp___1 = shutdown(c->sock, 0);
#line 478
    if (tmp___1 < 0) {
#line 478
      tmp___2 = __errno_location();
#line 478
      if (*tmp___2 != 107) {
#line 480
        tmp = __errno_location();
#line 480
        tmp___0 = strerror(*tmp);
#line 480
        error("channel %d: chan_shutdown_read: shutdown() failed for fd%d [i%d o%d]: %.100s",
              c->self, c->sock, c->istate, c->ostate, tmp___0);
      }
    }
  } else {
#line 485
    tmp___5 = channel_close_fd(& c->rfd);
#line 485
    if (tmp___5 < 0) {
#line 486
      tmp___3 = __errno_location();
#line 486
      tmp___4 = strerror(*tmp___3);
#line 486
      logit("channel %d: chan_shutdown_read: close() failed for fd%d: %.100s", c->self,
            c->rfd, tmp___4);
    }
  }
#line 490
  return;
}
}
#line 1 "packet.o"
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 23 "packet.h"
void packet_set_connection(int fd_in , int fd_out ) ;
#line 24
void packet_set_nonblocking(void) ;
#line 26
int packet_get_connection_out(void) ;
#line 27
void packet_close(void) ;
#line 28
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) ;
#line 29
u_int packet_get_encryption_key(u_char *key ) ;
#line 30
void packet_set_protocol_flags(u_int protocol_flags ) ;
#line 32
void packet_start_compression(int level ) ;
#line 33
void packet_set_interactive(int interactive ) ;
#line 35
void packet_set_server(void) ;
#line 36
void packet_set_authenticated(void) ;
#line 41
void packet_put_bignum(BIGNUM *value ) ;
#line 42
void packet_put_bignum2(BIGNUM *value ) ;
#line 45
void packet_put_raw(void const   *buf___1 , u_int len ) ;
#line 49
void packet_read_expect(int expected_type ) ;
#line 50
int packet_read_poll(void) ;
#line 51
void packet_process_incoming(char const   *buf___1 , u_int len ) ;
#line 52
int packet_read_seqnr(u_int32_t *seqnr_p ) ;
#line 53
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) ;
#line 55
u_int packet_get_char(void) ;
#line 57
void packet_get_bignum(BIGNUM *value ) ;
#line 58
void packet_get_bignum2(BIGNUM *value ) ;
#line 59
void *packet_get_raw(u_int *length_ptr ) ;
#line 62
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 64
void set_newkeys(int mode ) ;
#line 65
int packet_get_keyiv_len(int mode ) ;
#line 66
void packet_get_keyiv(int mode , u_char *iv , u_int len ) ;
#line 67
int packet_get_keycontext(int mode , u_char *dat ) ;
#line 68
void packet_set_keycontext(int mode , u_char *dat ) ;
#line 69
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ) ;
#line 70
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ) ;
#line 71
int packet_get_ssh1_cipher(void) ;
#line 72
void packet_set_iv(int mode , u_char *dat ) ;
#line 74
void packet_write_poll(void) ;
#line 76
int packet_have_data_to_write(void) ;
#line 77
int packet_not_very_much_data_to_write(void) ;
#line 80
int packet_connection_is_ipv4(void) ;
#line 83
void packet_add_padding(u_char pad ) ;
#line 89
int keep_alive_timeouts ;
#line 90
int packet_set_maxsize(u_int s ) ;
#line 104
int packet_need_rekeying(void) ;
#line 105
void packet_set_rekey_limit(u_int32_t bytes ) ;
#line 137 "kex.h"
Newkeys *kex_get_newkeys(int mode ) ;
#line 28 "mac.h"
int mac_init(Mac *mac ) ;
#line 29
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) ;
#line 30
void mac_clear(Mac *mac ) ;
#line 93 "packet.c"
static int connection_in  =    -1;
#line 94 "packet.c"
static int connection_out  =    -1;
#line 97 "packet.c"
static u_int remote_protocol_flags  =    (u_int )0;
#line 100 "packet.c"
static CipherContext receive_context  ;
#line 103 "packet.c"
static CipherContext send_context  ;
#line 106 "packet.c"
Buffer input  ;
#line 109 "packet.c"
Buffer output  ;
#line 112 "packet.c"
static Buffer outgoing_packet  ;
#line 115 "packet.c"
static Buffer incoming_packet  ;
#line 118 "packet.c"
static Buffer compression_buffer  ;
#line 119 "packet.c"
static int compression_buffer_ready  =    0;
#line 122 "packet.c"
static int packet_compression  =    0;
#line 125 "packet.c"
u_int max_packet_size  =    (u_int )32768;
#line 128 "packet.c"
static int initialized  =    0;
#line 131 "packet.c"
static int interactive_mode  =    0;
#line 134 "packet.c"
static int server_side  =    0;
#line 137 "packet.c"
static int after_authentication  =    0;
#line 139 "packet.c"
int keep_alive_timeouts  =    0;
#line 142 "packet.c"
Newkeys *newkeys[2]  ;
#line 143 "packet.c"
static struct packet_state p_read  ;
#line 143 "packet.c"
static struct packet_state p_send  ;
#line 149 "packet.c"
static u_int64_t max_blocks_in  ;
#line 149 "packet.c"
static u_int64_t max_blocks_out  ;
#line 150 "packet.c"
static u_int32_t rekey_limit  ;
#line 153 "packet.c"
static u_char ssh1_key[32]  ;
#line 154 "packet.c"
static u_int ssh1_keylen  ;
#line 157 "packet.c"
static u_char extra_pad  =    (u_char )0;
#line 164 "packet.c"
struct __anonstruct_outgoing_78 outgoing  ;
#line 170 "packet.c"
void packet_set_connection(int fd_in , int fd_out ) 
{ Cipher *none ;
  Cipher *tmp ;

  {
#line 173
  tmp = cipher_by_name("none");
#line 173
  none = tmp;
#line 175
  if ((unsigned int )none == (unsigned int )((void *)0)) {
#line 176
    fatal("packet_set_connection: cannot load cipher \'none\'");
  }
#line 177
  connection_in = fd_in;
#line 178
  connection_out = fd_out;
#line 179
  cipher_init(& send_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 1);
#line 181
  cipher_init(& receive_context, none, (u_char const   *)"", 0U, (u_char const   *)((void *)0),
              0U, 0);
#line 183
  newkeys[1] = (Newkeys *)((void *)0);
#line 183
  newkeys[0] = newkeys[1];
#line 184
  if (! initialized) {
#line 185
    initialized = 1;
#line 186
    buffer_init(& input);
#line 187
    buffer_init(& output);
#line 188
    buffer_init(& outgoing_packet);
#line 189
    buffer_init(& incoming_packet);
#line 190
    while (1) {
#line 190
      outgoing.tqh_first = (struct packet *)((void *)0);
#line 190
      outgoing.tqh_last = & outgoing.tqh_first;
#line 190
      break;
    }
  }
#line 192
  return;
}
}
#line 196 "packet.c"
int packet_connection_is_on_socket(void) 
{ struct sockaddr_storage from ;
  struct sockaddr_storage to ;
  socklen_t fromlen ;
  socklen_t tolen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 203
  if (connection_in == connection_out) {
#line 204
    return (1);
  }
#line 205
  fromlen = sizeof(from);
#line 206
  memset((void *)(& from), 0, sizeof(from));
#line 207
  tmp = getpeername(connection_in, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                    (socklen_t * __restrict  )(& fromlen));
#line 207
  if (tmp < 0) {
#line 208
    return (0);
  }
#line 209
  tolen = sizeof(to);
#line 210
  memset((void *)(& to), 0, sizeof(to));
#line 211
  tmp___0 = getpeername(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                        (socklen_t * __restrict  )(& tolen));
#line 211
  if (tmp___0 < 0) {
#line 212
    return (0);
  }
#line 213
  if (fromlen != tolen) {
#line 214
    return (0);
  } else {
#line 213
    tmp___1 = memcmp((void const   *)(& from), (void const   *)(& to), fromlen);
#line 213
    if (tmp___1 != 0) {
#line 214
      return (0);
    }
  }
#line 215
  if ((int )from.ss_family != 2) {
#line 215
    if ((int )from.ss_family != 10) {
#line 216
      return (0);
    }
  }
#line 217
  return (1);
}
}
#line 226 "packet.c"
void packet_get_keyiv(int mode , u_char *iv , u_int len ) 
{ CipherContext *cc ;

  {
#line 231
  if (mode == 1) {
#line 232
    cc = & send_context;
  } else {
#line 234
    cc = & receive_context;
  }
#line 236
  cipher_get_keyiv(cc, iv, len);
#line 237
  return;
}
}
#line 239 "packet.c"
int packet_get_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 244
  if (mode == 1) {
#line 245
    cc = & send_context;
  } else {
#line 247
    cc = & receive_context;
  }
#line 249
  tmp = cipher_get_keycontext((CipherContext const   *)cc, dat);
#line 249
  return (tmp);
}
}
#line 252 "packet.c"
void packet_set_keycontext(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 257
  if (mode == 1) {
#line 258
    cc = & send_context;
  } else {
#line 260
    cc = & receive_context;
  }
#line 262
  cipher_set_keycontext(cc, dat);
#line 263
  return;
}
}
#line 265 "packet.c"
int packet_get_keyiv_len(int mode ) 
{ CipherContext *cc ;
  int tmp ;

  {
#line 270
  if (mode == 1) {
#line 271
    cc = & send_context;
  } else {
#line 273
    cc = & receive_context;
  }
#line 275
  tmp = cipher_get_keyiv_len((CipherContext const   *)cc);
#line 275
  return (tmp);
}
}
#line 278 "packet.c"
void packet_set_iv(int mode , u_char *dat ) 
{ CipherContext *cc ;

  {
#line 283
  if (mode == 1) {
#line 284
    cc = & send_context;
  } else {
#line 286
    cc = & receive_context;
  }
#line 288
  cipher_set_keyiv(cc, dat);
#line 289
  return;
}
}
#line 291 "packet.c"
int packet_get_ssh1_cipher(void) 
{ u_int tmp ;

  {
#line 294
  tmp = cipher_get_number((Cipher const   *)receive_context.cipher);
#line 294
  return ((int )tmp);
}
}
#line 297 "packet.c"
void packet_get_state(int mode , u_int32_t *seqnr , u_int64_t *blocks , u_int32_t *packets ) 
{ struct packet_state *state ;

  {
#line 302
  if (mode == 0) {
#line 302
    state = & p_read;
  } else {
#line 302
    state = & p_send;
  }
#line 303
  *seqnr = state->seqnr;
#line 304
  *blocks = state->blocks;
#line 305
  *packets = state->packets;
#line 306
  return;
}
}
#line 308 "packet.c"
void packet_set_state(int mode , u_int32_t seqnr , u_int64_t blocks , u_int32_t packets ) 
{ struct packet_state *state ;

  {
#line 313
  if (mode == 0) {
#line 313
    state = & p_read;
  } else {
#line 313
    state = & p_send;
  }
#line 314
  state->seqnr = seqnr;
#line 315
  state->blocks = blocks;
#line 316
  state->packets = packets;
#line 317
  return;
}
}
#line 321 "packet.c"
int packet_connection_is_ipv4(void) 
{ struct sockaddr_storage to ;
  socklen_t tolen ;
  int tmp ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 325
  tolen = sizeof(to);
#line 327
  memset((void *)(& to), 0, sizeof(to));
#line 328
  tmp = getsockname(connection_out, (struct sockaddr * __restrict  )((struct sockaddr *)(& to)),
                    (socklen_t * __restrict  )(& tolen));
#line 328
  if (tmp < 0) {
#line 329
    return (0);
  }
#line 330
  if ((int )to.ss_family == 2) {
#line 331
    return (1);
  }
#line 334
  if ((int )to.ss_family == 10) {
#line 334
    if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 0) == 0U) {
#line 334
      if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 1) == 0U) {
#line 334
        __x = 65535U;
#line 334
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 334
        if (*((uint32_t const   *)(& ((struct sockaddr_in6 *)(& to))->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 335
          return (1);
        }
      }
    }
  }
#line 337
  return (0);
}
}
#line 342 "packet.c"
void packet_set_nonblocking(void) 
{ 

  {
#line 346
  set_nonblock(connection_in);
#line 348
  if (connection_out != connection_in) {
#line 349
    set_nonblock(connection_out);
  }
#line 350
  return;
}
}
#line 354 "packet.c"
int packet_get_connection_in(void) 
{ 

  {
#line 357
  return (connection_in);
}
}
#line 362 "packet.c"
int packet_get_connection_out(void) 
{ 

  {
#line 365
  return (connection_out);
}
}
#line 370 "packet.c"
void packet_close(void) 
{ 

  {
#line 373
  if (! initialized) {
#line 374
    return;
  }
#line 375
  initialized = 0;
#line 376
  if (connection_in == connection_out) {
#line 377
    shutdown(connection_out, 2);
#line 378
    close(connection_out);
  } else {
#line 380
    close(connection_in);
#line 381
    close(connection_out);
  }
#line 383
  buffer_free(& input);
#line 384
  buffer_free(& output);
#line 385
  buffer_free(& outgoing_packet);
#line 386
  buffer_free(& incoming_packet);
#line 387
  if (compression_buffer_ready) {
#line 388
    buffer_free(& compression_buffer);
#line 389
    buffer_compress_uninit();
  }
#line 391
  cipher_cleanup(& send_context);
#line 392
  cipher_cleanup(& receive_context);
#line 393
  return;
}
}
#line 397 "packet.c"
void packet_set_protocol_flags(u_int protocol_flags ) 
{ 

  {
#line 400
  remote_protocol_flags = protocol_flags;
#line 401
  return;
}
}
#line 405 "packet.c"
u_int packet_get_protocol_flags(void) 
{ 

  {
#line 408
  return (remote_protocol_flags);
}
}
#line 416 "packet.c"
static void packet_init_compression(void) 
{ 

  {
#line 419
  if (compression_buffer_ready == 1) {
#line 420
    return;
  }
#line 421
  compression_buffer_ready = 1;
#line 422
  buffer_init(& compression_buffer);
#line 423
  return;
}
}
#line 425 "packet.c"
void packet_start_compression(int level ) 
{ 

  {
#line 428
  if (packet_compression) {
#line 428
    if (! compat20) {
#line 429
      fatal("Compression already enabled.");
    }
  }
#line 430
  packet_compression = 1;
#line 431
  packet_init_compression();
#line 432
  buffer_compress_init_send(level);
#line 433
  buffer_compress_init_recv();
#line 434
  return;
}
}
#line 442 "packet.c"
void packet_set_encryption_key(u_char const   *key , u_int keylen , int number ) 
{ Cipher *cipher ;
  Cipher *tmp ;

  {
#line 446
  tmp = cipher_by_number(number);
#line 446
  cipher = tmp;
#line 448
  if ((unsigned int )cipher == (unsigned int )((void *)0)) {
#line 449
    fatal("packet_set_encryption_key: unknown cipher number %d", number);
  }
#line 450
  if (keylen < 20U) {
#line 451
    fatal("packet_set_encryption_key: keylen too small: %d", keylen);
  }
#line 452
  if (keylen > 32U) {
#line 453
    fatal("packet_set_encryption_key: keylen too big: %d", keylen);
  }
#line 454
  memcpy((void * __restrict  )(ssh1_key), (void const   * __restrict  )key, keylen);
#line 455
  ssh1_keylen = keylen;
#line 456
  cipher_init(& send_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 1);
#line 457
  cipher_init(& receive_context, cipher, key, keylen, (u_char const   *)((void *)0),
              0U, 0);
#line 458
  return;
}
}
#line 460 "packet.c"
u_int packet_get_encryption_key(u_char *key ) 
{ 

  {
#line 463
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 464
    return (ssh1_keylen);
  }
#line 465
  memcpy((void * __restrict  )key, (void const   * __restrict  )(ssh1_key), ssh1_keylen);
#line 466
  return (ssh1_keylen);
}
}
#line 470 "packet.c"
void packet_start(u_char type ) 
{ u_char buf___1[9] ;
  int len ;

  {
#line 477
  if (compat20) {
#line 477
    len = 6;
  } else {
#line 477
    len = 9;
  }
#line 478
  memset((void *)(buf___1), 0, (unsigned int )(len - 1));
#line 479
  buf___1[len - 1] = type;
#line 480
  buffer_clear(& outgoing_packet);
#line 481
  buffer_append(& outgoing_packet, (void const   *)(buf___1), (unsigned int )len);
#line 482
  return;
}
}
#line 485 "packet.c"
void packet_put_char(int value ) 
{ char ch ;

  {
#line 488
  ch = (char )value;
#line 490
  buffer_append(& outgoing_packet, (void const   *)(& ch), 1U);
#line 491
  return;
}
}
#line 493 "packet.c"
void packet_put_int(u_int value ) 
{ 

  {
#line 496
  buffer_put_int(& outgoing_packet, value);
#line 497
  return;
}
}
#line 499 "packet.c"
void packet_put_string(void const   *buf___1 , u_int len ) 
{ 

  {
#line 502
  buffer_put_string(& outgoing_packet, buf___1, len);
#line 503
  return;
}
}
#line 505 "packet.c"
void packet_put_cstring(char const   *str ) 
{ 

  {
#line 508
  buffer_put_cstring(& outgoing_packet, str);
#line 509
  return;
}
}
#line 511 "packet.c"
void packet_put_raw(void const   *buf___1 , u_int len ) 
{ 

  {
#line 514
  buffer_append(& outgoing_packet, buf___1, len);
#line 515
  return;
}
}
#line 517 "packet.c"
void packet_put_bignum(BIGNUM *value ) 
{ 

  {
#line 520
  buffer_put_bignum(& outgoing_packet, (BIGNUM const   *)value);
#line 521
  return;
}
}
#line 523 "packet.c"
void packet_put_bignum2(BIGNUM *value ) 
{ 

  {
#line 526
  buffer_put_bignum2(& outgoing_packet, (BIGNUM const   *)value);
#line 527
  return;
}
}
#line 534 "packet.c"
static void packet_send1(void) 
{ u_char buf___1[8] ;
  u_char *cp ;
  int i ;
  int padding ;
  int len ;
  u_int checksum ;
  u_int32_t rnd ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;

  {
#line 540
  rnd = (u_int32_t )0;
#line 546
  if (packet_compression) {
#line 547
    buffer_clear(& compression_buffer);
#line 549
    buffer_consume(& outgoing_packet, 8U);
#line 551
    buffer_append(& compression_buffer, (void const   *)"\000\000\000\000\000\000\000\000",
                  8U);
#line 552
    buffer_compress(& outgoing_packet, & compression_buffer);
#line 553
    buffer_clear(& outgoing_packet);
#line 554
    tmp = buffer_len(& compression_buffer);
#line 554
    tmp___0 = buffer_ptr(& compression_buffer);
#line 554
    buffer_append(& outgoing_packet, (void const   *)tmp___0, tmp);
  }
#line 558
  tmp___1 = buffer_len(& outgoing_packet);
#line 558
  len = (int )((tmp___1 + 4U) - 8U);
#line 561
  padding = 8 - len % 8;
#line 562
  if (! send_context.plaintext) {
#line 563
    tmp___2 = buffer_ptr(& outgoing_packet);
#line 563
    cp = (u_char *)tmp___2;
#line 564
    i = 0;
#line 564
    while (i < padding) {
#line 565
      if (i % 4 == 0) {
#line 566
        rnd = arc4random();
      }
#line 567
      *(cp + (7 - i)) = (unsigned char )(rnd & 255U);
#line 568
      rnd >>= 8;
#line 564
      i ++;
    }
  }
#line 571
  buffer_consume(& outgoing_packet, (unsigned int )(8 - padding));
#line 574
  tmp___3 = buffer_len(& outgoing_packet);
#line 574
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 574
  checksum = ssh_crc32((u_char const   *)tmp___4, tmp___3);
#line 576
  put_u32((void *)(buf___1), checksum);
#line 577
  buffer_append(& outgoing_packet, (void const   *)(buf___1), 4U);
#line 585
  put_u32((void *)(buf___1), (unsigned int )len);
#line 586
  buffer_append(& output, (void const   *)(buf___1), 4U);
#line 587
  tmp___5 = buffer_len(& outgoing_packet);
#line 587
  tmp___6 = buffer_append_space(& output, tmp___5);
#line 587
  cp = (u_char *)tmp___6;
#line 588
  tmp___7 = buffer_len(& outgoing_packet);
#line 588
  tmp___8 = buffer_ptr(& outgoing_packet);
#line 588
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___8, tmp___7);
#line 596
  buffer_clear(& outgoing_packet);
#line 603
  return;
}
}
#line 605 "packet.c"
void set_newkeys(int mode ) 
{ Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  CipherContext *cc ;
  u_int64_t *max_blocks ;
  int crypt_type ;
  int tmp ;

  {
#line 615
  debug2("set_newkeys: mode %d", mode);
#line 617
  if (mode == 1) {
#line 618
    cc = & send_context;
#line 619
    crypt_type = 1;
#line 620
    p_send.blocks = 0ULL;
#line 620
    p_send.packets = (unsigned int )p_send.blocks;
#line 621
    max_blocks = & max_blocks_out;
  } else {
#line 623
    cc = & receive_context;
#line 624
    crypt_type = 0;
#line 625
    p_read.blocks = 0ULL;
#line 625
    p_read.packets = (unsigned int )p_read.blocks;
#line 626
    max_blocks = & max_blocks_in;
  }
#line 628
  if ((unsigned int )newkeys[mode] != (unsigned int )((void *)0)) {
#line 629
    debug("set_newkeys: rekeying");
#line 630
    cipher_cleanup(cc);
#line 631
    enc = & (newkeys[mode])->enc;
#line 632
    mac = & (newkeys[mode])->mac;
#line 633
    comp = & (newkeys[mode])->comp;
#line 634
    mac_clear(mac);
#line 635
    xfree((void *)enc->name);
#line 636
    xfree((void *)enc->iv);
#line 637
    xfree((void *)enc->key);
#line 638
    xfree((void *)mac->name);
#line 639
    xfree((void *)mac->key);
#line 640
    xfree((void *)comp->name);
#line 641
    xfree((void *)newkeys[mode]);
  }
#line 643
  newkeys[mode] = kex_get_newkeys(mode);
#line 644
  if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
#line 645
    fatal("newkeys: no keys for mode %d", mode);
  }
#line 646
  enc = & (newkeys[mode])->enc;
#line 647
  mac = & (newkeys[mode])->mac;
#line 648
  comp = & (newkeys[mode])->comp;
#line 649
  tmp = mac_init(mac);
#line 649
  if (tmp == 0) {
#line 650
    mac->enabled = 1;
  }
#line 652
  cipher_init(cc, enc->cipher, (u_char const   *)enc->key, enc->key_len, (u_char const   *)enc->iv,
              enc->block_size, crypt_type);
#line 658
  if (comp->type == 1) {
    goto _L;
  } else {
#line 658
    if (comp->type == 2) {
#line 658
      if (after_authentication) {
        _L: /* CIL Label */ 
#line 658
        if (comp->enabled == 0) {
#line 661
          packet_init_compression();
#line 662
          if (mode == 1) {
#line 663
            buffer_compress_init_send(6);
          } else {
#line 665
            buffer_compress_init_recv();
          }
#line 666
          comp->enabled = 1;
        }
      }
    }
  }
#line 672
  if (enc->block_size >= 16U) {
#line 673
    *max_blocks = 1ULL << enc->block_size * 2U;
  } else {
#line 675
    *max_blocks = (1ULL << 30) / (unsigned long long )enc->block_size;
  }
#line 676
  if (rekey_limit) {
#line 677
    if (*max_blocks < (u_int64_t )(rekey_limit / enc->block_size)) {
#line 677
      *max_blocks = *max_blocks;
    } else {
#line 677
      *max_blocks = (unsigned long long )(rekey_limit / enc->block_size);
    }
  }
#line 678
  return;
}
}
#line 685 "packet.c"
static void packet_enable_delayed_compress(void) 
{ Comp *comp ;
  int mode ;

  {
#line 688
  comp = (Comp *)((void *)0);
#line 695
  after_authentication = 1;
#line 696
  mode = 0;
#line 696
  while (mode < 2) {
#line 698
    if ((unsigned int )newkeys[mode] == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 700
    comp = & (newkeys[mode])->comp;
#line 701
    if (comp) {
#line 701
      if (! comp->enabled) {
#line 701
        if (comp->type == 2) {
#line 702
          packet_init_compression();
#line 703
          if (mode == 1) {
#line 704
            buffer_compress_init_send(6);
          } else {
#line 706
            buffer_compress_init_recv();
          }
#line 707
          comp->enabled = 1;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 696
    mode ++;
  }
#line 710
  return;
}
}
#line 715 "packet.c"
static void packet_send2_wrapped(void) 
{ u_char type ;
  u_char *cp ;
  u_char *macbuf ;
  u_char padlen ;
  u_char pad ;
  u_int packet_length___0 ;
  u_int i ;
  u_int len ;
  u_int32_t rnd ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  int block_size ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  void *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;

  {
#line 718
  macbuf = (u_char *)((void *)0);
#line 720
  packet_length___0 = (u_int )0;
#line 722
  rnd = (u_int32_t )0;
#line 723
  enc = (Enc *)((void *)0);
#line 724
  mac = (Mac *)((void *)0);
#line 725
  comp = (Comp *)((void *)0);
#line 728
  if ((unsigned int )newkeys[1] != (unsigned int )((void *)0)) {
#line 729
    enc = & (newkeys[1])->enc;
#line 730
    mac = & (newkeys[1])->mac;
#line 731
    comp = & (newkeys[1])->comp;
  }
#line 733
  if (enc) {
#line 733
    block_size = (int )enc->block_size;
  } else {
#line 733
    block_size = 8;
  }
#line 735
  tmp = buffer_ptr(& outgoing_packet);
#line 735
  cp = (u_char *)tmp;
#line 736
  type = *(cp + 5);
#line 743
  if (comp) {
#line 743
    if (comp->enabled) {
#line 744
      len = buffer_len(& outgoing_packet);
#line 746
      buffer_consume(& outgoing_packet, 5U);
#line 747
      buffer_clear(& compression_buffer);
#line 748
      buffer_compress(& outgoing_packet, & compression_buffer);
#line 749
      buffer_clear(& outgoing_packet);
#line 750
      buffer_append(& outgoing_packet, (void const   *)"\000\000\000\000\000", 5U);
#line 751
      tmp___0 = buffer_len(& compression_buffer);
#line 751
      tmp___1 = buffer_ptr(& compression_buffer);
#line 751
      buffer_append(& outgoing_packet, (void const   *)tmp___1, tmp___0);
    }
  }
#line 758
  len = buffer_len(& outgoing_packet);
#line 764
  padlen = (unsigned char )((unsigned int )block_size - len % (unsigned int )block_size);
#line 765
  if ((int )padlen < 4) {
#line 766
    padlen = (unsigned char )((int )padlen + block_size);
  }
#line 767
  if (extra_pad) {
#line 769
    extra_pad = (unsigned char )((((int )extra_pad + (block_size - 1)) / block_size) * block_size);
#line 770
    pad = (unsigned char )((unsigned int )extra_pad - (len + (u_int )padlen) % (unsigned int )extra_pad);
#line 771
    debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)", pad, len, padlen,
           extra_pad);
#line 773
    padlen = (unsigned char )((int )padlen + (int )pad);
#line 774
    extra_pad = (unsigned char)0;
  }
#line 776
  tmp___2 = buffer_append_space(& outgoing_packet, (unsigned int )padlen);
#line 776
  cp = (u_char *)tmp___2;
#line 777
  if (enc) {
#line 777
    if (! send_context.plaintext) {
#line 779
      i = 0U;
#line 779
      while (i < (u_int )padlen) {
#line 780
        if (i % 4U == 0U) {
#line 781
          rnd = arc4random();
        }
#line 782
        *(cp + i) = (unsigned char )(rnd & 255U);
#line 783
        rnd >>= 8;
#line 779
        i ++;
      }
    } else {
#line 787
      memset((void *)cp, 0, (unsigned int )padlen);
    }
  } else {
#line 787
    memset((void *)cp, 0, (unsigned int )padlen);
  }
#line 790
  tmp___3 = buffer_len(& outgoing_packet);
#line 790
  packet_length___0 = tmp___3 - 4U;
#line 791
  tmp___4 = buffer_ptr(& outgoing_packet);
#line 791
  cp = (u_char *)tmp___4;
#line 792
  put_u32((void *)cp, packet_length___0);
#line 793
  *(cp + 4) = padlen;
#line 797
  if (mac) {
#line 797
    if (mac->enabled) {
#line 798
      tmp___5 = buffer_len(& outgoing_packet);
#line 798
      tmp___6 = buffer_ptr(& outgoing_packet);
#line 798
      macbuf = mac_compute(mac, p_send.seqnr, (u_char *)tmp___6, (int )tmp___5);
    }
  }
#line 804
  tmp___7 = buffer_len(& outgoing_packet);
#line 804
  tmp___8 = buffer_append_space(& output, tmp___7);
#line 804
  cp = (u_char *)tmp___8;
#line 805
  tmp___9 = buffer_len(& outgoing_packet);
#line 805
  tmp___10 = buffer_ptr(& outgoing_packet);
#line 805
  cipher_crypt(& send_context, cp, (u_char const   *)tmp___10, tmp___9);
#line 808
  if (mac) {
#line 808
    if (mac->enabled) {
#line 809
      buffer_append(& output, (void const   *)macbuf, mac->mac_len);
    }
  }
#line 815
  (p_send.seqnr) ++;
#line 815
  if (p_send.seqnr == 0U) {
#line 816
    logit("outgoing seqnr wraps around");
  }
#line 817
  (p_send.packets) ++;
#line 817
  if (p_send.packets == 0U) {
#line 818
    if (! (datafellows & 32768)) {
#line 819
      fatal("XXX too many packets with same key");
    }
  }
#line 820
  p_send.blocks += (u_int64_t )((packet_length___0 + 4U) / (u_int )block_size);
#line 821
  buffer_clear(& outgoing_packet);
#line 823
  if ((int )type == 21) {
#line 824
    set_newkeys(1);
  } else {
#line 825
    if ((int )type == 52) {
#line 825
      if (server_side) {
#line 826
        packet_enable_delayed_compress();
      }
    }
  }
#line 827
  return;
}
}
#line 832
static void packet_send2(void) ;
#line 832 "packet.c"
static int rekeying  =    0;
#line 829 "packet.c"
static void packet_send2(void) 
{ struct packet *p ;
  u_char type ;
  u_char *cp ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 836
  tmp = buffer_ptr(& outgoing_packet);
#line 836
  cp = (u_char *)tmp;
#line 837
  type = *(cp + 5);
#line 840
  if (rekeying) {
#line 841
    if ((int )type >= 1) {
#line 841
      if (! ((int )type <= 49)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 843
      debug("enqueue packet: %u", type);
#line 844
      tmp___0 = xmalloc(sizeof(*p));
#line 844
      p = (struct packet *)tmp___0;
#line 845
      p->type = type;
#line 846
      memcpy((void * __restrict  )(& p->payload), (void const   * __restrict  )(& outgoing_packet),
             sizeof(Buffer ));
#line 847
      buffer_init(& outgoing_packet);
#line 848
      while (1) {
#line 848
        p->next.tqe_next = (struct packet *)((void *)0);
#line 848
        p->next.tqe_prev = outgoing.tqh_last;
#line 848
        *(outgoing.tqh_last) = p;
#line 848
        outgoing.tqh_last = & p->next.tqe_next;
#line 848
        break;
      }
#line 849
      return;
    }
  }
#line 854
  if ((int )type == 20) {
#line 855
    rekeying = 1;
  }
#line 857
  packet_send2_wrapped();
#line 860
  if ((int )type == 21) {
#line 861
    rekeying = 0;
#line 862
    while (1) {
#line 862
      p = outgoing.tqh_first;
#line 862
      if (! p) {
#line 862
        break;
      }
#line 863
      type = p->type;
#line 864
      debug("dequeue packet: %u", type);
#line 865
      buffer_free(& outgoing_packet);
#line 866
      memcpy((void * __restrict  )(& outgoing_packet), (void const   * __restrict  )(& p->payload),
             sizeof(Buffer ));
#line 868
      while (1) {
#line 868
        if ((unsigned int )p->next.tqe_next != (unsigned int )((void *)0)) {
#line 868
          (p->next.tqe_next)->next.tqe_prev = p->next.tqe_prev;
        } else {
#line 868
          outgoing.tqh_last = p->next.tqe_prev;
        }
#line 868
        *(p->next.tqe_prev) = p->next.tqe_next;
#line 868
        break;
      }
#line 869
      xfree((void *)p);
#line 870
      packet_send2_wrapped();
    }
  }
#line 873
  return;
}
}
#line 875 "packet.c"
void packet_send(void) 
{ 

  {
#line 878
  if (compat20) {
#line 879
    packet_send2();
  } else {
#line 881
    packet_send1();
  }
#line 883
  return;
}
}
#line 891 "packet.c"
int packet_read_seqnr(u_int32_t *seqnr_p ) 
{ int type ;
  int len ;
  fd_set *setp ;
  char buf___1[8192] ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 899
  tmp = xcalloc(((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask )),
                sizeof(fd_mask ));
#line 899
  setp = (fd_set *)tmp;
#line 903
  packet_write_wait();
#line 906
  while (1) {
#line 908
    type = packet_read_poll_seqnr(seqnr_p);
#line 909
    if (! compat20) {
#line 909
      if (type == 14) {
        goto _L;
      } else {
#line 909
        if (type == 15) {
          goto _L;
        } else {
#line 909
          if (type == 19) {
            goto _L;
          } else {
#line 909
            if (type == 33) {
              _L: /* CIL Label */ 
#line 914
              while (1) {
#line 914
                tmp___0 = packet_remaining();
#line 914
                _len = tmp___0;
#line 914
                if (_len > 0) {
#line 914
                  logit("Packet integrity error (%d bytes remaining) at %s:%d", _len,
                        "packet.c", 914);
#line 914
                  packet_disconnect("Packet integrity error.");
                }
#line 914
                break;
              }
            }
          }
        }
      }
    }
#line 916
    if (type != 0) {
#line 917
      xfree((void *)setp);
#line 918
      return (type);
    }
#line 924
    memset((void *)setp, 0, (((unsigned int )(connection_in + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 926
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->fds_bits[(unsigned int )connection_in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 929
    while (1) {
#line 929
      tmp___1 = select(connection_in + 1, (fd_set * __restrict  )setp, (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 929
      if (tmp___1 == -1) {
#line 929
        tmp___2 = __errno_location();
#line 929
        if (! (*tmp___2 == 11)) {
#line 929
          tmp___3 = __errno_location();
#line 929
          if (! (*tmp___3 == 4)) {
#line 929
            break;
          }
        }
      } else {
#line 929
        break;
      }
    }
#line 934
    len = read(connection_in, (void *)(buf___1), sizeof(buf___1));
#line 935
    if (len == 0) {
#line 936
      tmp___4 = get_remote_ipaddr();
#line 936
      logit("Connection closed by %.200s", tmp___4);
#line 937
      cleanup_exit(255);
    }
#line 939
    if (len < 0) {
#line 940
      tmp___5 = __errno_location();
#line 940
      tmp___6 = strerror(*tmp___5);
#line 940
      fatal("Read from socket failed: %.100s", tmp___6);
    }
#line 942
    packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
  }
}
}
#line 947 "packet.c"
int packet_read(void) 
{ int tmp ;

  {
#line 950
  tmp = packet_read_seqnr((u_int32_t *)((void *)0));
#line 950
  return (tmp);
}
}
#line 958 "packet.c"
void packet_read_expect(int expected_type ) 
{ int type ;

  {
#line 963
  type = packet_read();
#line 964
  if (type != expected_type) {
#line 965
    packet_disconnect("Protocol error: expected packet type %d, got %d", expected_type,
                      type);
  }
#line 967
  return;
}
}
#line 978 "packet.c"
static int packet_read_poll1(void) 
{ u_int len ;
  u_int padded_len ;
  u_char *cp ;
  u_char type ;
  u_int checksum ;
  u_int stored_checksum ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 986
  tmp = buffer_len(& input);
#line 986
  if (tmp < 12U) {
#line 987
    return (0);
  }
#line 989
  tmp___0 = buffer_ptr(& input);
#line 989
  cp = (u_char *)tmp___0;
#line 990
  len = get_u32((void const   *)cp);
#line 991
  if (len < 5U) {
#line 992
    packet_disconnect("Bad packet length %u.", len);
  } else {
#line 991
    if (len > 262144U) {
#line 992
      packet_disconnect("Bad packet length %u.", len);
    }
  }
#line 993
  padded_len = (len + 8U) & 4294967288U;
#line 996
  tmp___1 = buffer_len(& input);
#line 996
  if (tmp___1 < 4U + padded_len) {
#line 997
    return (0);
  }
#line 1002
  buffer_consume(& input, 4U);
#line 1009
  if (! receive_context.plaintext) {
#line 1010
    tmp___2 = buffer_ptr(& input);
#line 1010
    tmp___3 = detect_attack((u_char *)tmp___2, padded_len);
#line 1010
    switch (tmp___3) {
    case 1: 
#line 1012
    packet_disconnect("crc32 compensation attack: network attack detected");
    case 2: 
#line 1015
    packet_disconnect("deattack denial of service detected");
    }
  }
#line 1021
  buffer_clear(& incoming_packet);
#line 1022
  tmp___4 = buffer_append_space(& incoming_packet, padded_len);
#line 1022
  cp = (u_char *)tmp___4;
#line 1023
  tmp___5 = buffer_ptr(& input);
#line 1023
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, padded_len);
#line 1025
  buffer_consume(& input, padded_len);
#line 1033
  tmp___6 = buffer_len(& incoming_packet);
#line 1033
  tmp___7 = buffer_ptr(& incoming_packet);
#line 1033
  checksum = ssh_crc32((u_char const   *)tmp___7, tmp___6 - 4U);
#line 1037
  buffer_consume(& incoming_packet, 8U - len % 8U);
#line 1040
  tmp___9 = buffer_len(& incoming_packet);
#line 1040
  if (len != tmp___9) {
#line 1041
    tmp___8 = buffer_len(& incoming_packet);
#line 1041
    packet_disconnect("packet_read_poll1: len %d != buffer_len %d.", len, tmp___8);
  }
#line 1044
  tmp___10 = buffer_ptr(& incoming_packet);
#line 1044
  cp = ((u_char *)tmp___10 + len) - 4;
#line 1045
  stored_checksum = get_u32((void const   *)cp);
#line 1046
  if (checksum != stored_checksum) {
#line 1047
    packet_disconnect("Corrupted check bytes on input.");
  }
#line 1048
  buffer_consume_end(& incoming_packet, 4U);
#line 1050
  if (packet_compression) {
#line 1051
    buffer_clear(& compression_buffer);
#line 1052
    buffer_uncompress(& incoming_packet, & compression_buffer);
#line 1053
    buffer_clear(& incoming_packet);
#line 1054
    tmp___11 = buffer_len(& compression_buffer);
#line 1054
    tmp___12 = buffer_ptr(& compression_buffer);
#line 1054
    buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
  }
#line 1057
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1057
  type = (unsigned char )tmp___13;
#line 1058
  if ((int )type < 1) {
#line 1059
    packet_disconnect("Invalid ssh1 packet type: %d", type);
  } else {
#line 1058
    if ((int )type > 254) {
#line 1059
      packet_disconnect("Invalid ssh1 packet type: %d", type);
    }
  }
#line 1060
  return ((int )type);
}
}
#line 1066
static int packet_read_poll2(u_int32_t *seqnr_p ) ;
#line 1066 "packet.c"
static u_int packet_length  =    (u_int )0;
#line 1063 "packet.c"
static int packet_read_poll2(u_int32_t *seqnr_p ) 
{ u_int padlen ;
  u_int need ;
  u_char *macbuf ;
  u_char *cp ;
  u_char type ;
  u_int maclen ;
  u_int block_size ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 1070
  enc = (Enc *)((void *)0);
#line 1071
  mac = (Mac *)((void *)0);
#line 1072
  comp = (Comp *)((void *)0);
#line 1074
  if ((unsigned int )newkeys[0] != (unsigned int )((void *)0)) {
#line 1075
    enc = & (newkeys[0])->enc;
#line 1076
    mac = & (newkeys[0])->mac;
#line 1077
    comp = & (newkeys[0])->comp;
  }
#line 1079
  if (mac) {
#line 1079
    if (mac->enabled) {
#line 1079
      maclen = mac->mac_len;
    } else {
#line 1079
      maclen = 0U;
    }
  } else {
#line 1079
    maclen = 0U;
  }
#line 1080
  if (enc) {
#line 1080
    block_size = enc->block_size;
  } else {
#line 1080
    block_size = 8U;
  }
#line 1082
  if (packet_length == 0U) {
#line 1087
    tmp = buffer_len(& input);
#line 1087
    if (tmp < block_size) {
#line 1088
      return (0);
    }
#line 1089
    buffer_clear(& incoming_packet);
#line 1090
    tmp___0 = buffer_append_space(& incoming_packet, block_size);
#line 1090
    cp = (u_char *)tmp___0;
#line 1091
    tmp___1 = buffer_ptr(& input);
#line 1091
    cipher_crypt(& receive_context, cp, (u_char const   *)tmp___1, block_size);
#line 1093
    tmp___2 = buffer_ptr(& incoming_packet);
#line 1093
    cp = (u_char *)tmp___2;
#line 1094
    packet_length = get_u32((void const   *)cp);
#line 1095
    if (packet_length < 5U) {
#line 1099
      packet_disconnect("Bad packet length %u.", packet_length);
    } else {
#line 1095
      if (packet_length > 262144U) {
#line 1099
        packet_disconnect("Bad packet length %u.", packet_length);
      }
    }
#line 1102
    buffer_consume(& input, block_size);
  }
#line 1105
  need = (4U + packet_length) - block_size;
#line 1108
  if (need % block_size != 0U) {
#line 1109
    fatal("padding error: need %d block %d mod %d", need, block_size, need % block_size);
  }
#line 1115
  tmp___3 = buffer_len(& input);
#line 1115
  if (tmp___3 < need + maclen) {
#line 1116
    return (0);
  }
#line 1121
  tmp___4 = buffer_append_space(& incoming_packet, need);
#line 1121
  cp = (u_char *)tmp___4;
#line 1122
  tmp___5 = buffer_ptr(& input);
#line 1122
  cipher_crypt(& receive_context, cp, (u_char const   *)tmp___5, need);
#line 1123
  buffer_consume(& input, need);
#line 1128
  if (mac) {
#line 1128
    if (mac->enabled) {
#line 1129
      tmp___6 = buffer_len(& incoming_packet);
#line 1129
      tmp___7 = buffer_ptr(& incoming_packet);
#line 1129
      macbuf = mac_compute(mac, p_read.seqnr, (u_char *)tmp___7, (int )tmp___6);
#line 1132
      tmp___8 = buffer_ptr(& input);
#line 1132
      tmp___9 = memcmp((void const   *)macbuf, (void const   *)tmp___8, mac->mac_len);
#line 1132
      if (tmp___9 != 0) {
#line 1133
        packet_disconnect("Corrupted MAC on input.");
      }
#line 1135
      buffer_consume(& input, mac->mac_len);
    }
  }
#line 1137
  if ((unsigned int )seqnr_p != (unsigned int )((void *)0)) {
#line 1138
    *seqnr_p = p_read.seqnr;
  }
#line 1139
  (p_read.seqnr) ++;
#line 1139
  if (p_read.seqnr == 0U) {
#line 1140
    logit("incoming seqnr wraps around");
  }
#line 1141
  (p_read.packets) ++;
#line 1141
  if (p_read.packets == 0U) {
#line 1142
    if (! (datafellows & 32768)) {
#line 1143
      fatal("XXX too many packets with same key");
    }
  }
#line 1144
  p_read.blocks += (u_int64_t )((packet_length + 4U) / block_size);
#line 1147
  tmp___10 = buffer_ptr(& incoming_packet);
#line 1147
  cp = (u_char *)tmp___10;
#line 1148
  padlen = (unsigned int )*(cp + 4);
#line 1150
  if (padlen < 4U) {
#line 1151
    packet_disconnect("Corrupted padlen %d on input.", padlen);
  }
#line 1154
  buffer_consume(& incoming_packet, 5U);
#line 1155
  buffer_consume_end(& incoming_packet, padlen);
#line 1158
  if (comp) {
#line 1158
    if (comp->enabled) {
#line 1159
      buffer_clear(& compression_buffer);
#line 1160
      buffer_uncompress(& incoming_packet, & compression_buffer);
#line 1161
      buffer_clear(& incoming_packet);
#line 1162
      tmp___11 = buffer_len(& compression_buffer);
#line 1162
      tmp___12 = buffer_ptr(& compression_buffer);
#line 1162
      buffer_append(& incoming_packet, (void const   *)tmp___12, tmp___11);
    }
  }
#line 1171
  tmp___13 = buffer_get_char(& incoming_packet);
#line 1171
  type = (unsigned char )tmp___13;
#line 1172
  if ((int )type < 1) {
#line 1173
    packet_disconnect("Invalid ssh2 packet type: %d", type);
  } else {
#line 1172
    if ((int )type >= 192) {
#line 1173
      packet_disconnect("Invalid ssh2 packet type: %d", type);
    }
  }
#line 1174
  if ((int )type == 21) {
#line 1175
    set_newkeys(0);
  } else {
#line 1176
    if ((int )type == 52) {
#line 1176
      if (! server_side) {
#line 1177
        packet_enable_delayed_compress();
      }
    }
  }
#line 1183
  packet_length = 0U;
#line 1184
  return ((int )type);
}
}
#line 1187 "packet.c"
int packet_read_poll_seqnr(u_int32_t *seqnr_p ) 
{ u_int reason ;
  u_int seqnr ;
  u_char type ;
  char *msg ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 1194
  while (1) {
#line 1195
    if (compat20) {
#line 1196
      tmp = packet_read_poll2(seqnr_p);
#line 1196
      type = (unsigned char )tmp;
#line 1197
      keep_alive_timeouts = 0;
#line 1198
      if (type) {

      }
#line 1200
      switch ((int )type) {
      case 2: 
#line 1202
      debug3("Received SSH2_MSG_IGNORE");
#line 1203
      break;
      case 4: 
#line 1205
      packet_get_char();
#line 1206
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1206
      msg = (char *)tmp___0;
#line 1207
      debug("Remote: %.900s", msg);
#line 1208
      xfree((void *)msg);
#line 1209
      tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1209
      msg = (char *)tmp___1;
#line 1210
      xfree((void *)msg);
#line 1211
      break;
      case 1: 
#line 1213
      reason = packet_get_int();
#line 1214
      tmp___2 = packet_get_string((u_int *)((void *)0));
#line 1214
      msg = (char *)tmp___2;
#line 1215
      tmp___3 = get_remote_ipaddr();
#line 1215
      logit("Received disconnect from %s: %u: %.400s", tmp___3, reason, msg);
#line 1217
      xfree((void *)msg);
#line 1218
      cleanup_exit(255);
#line 1219
      break;
      case 3: 
#line 1221
      seqnr = packet_get_int();
#line 1222
      debug("Received SSH2_MSG_UNIMPLEMENTED for %u", seqnr);
#line 1224
      break;
      default: ;
#line 1226
      return ((int )type);
      }
    } else {
#line 1229
      tmp___4 = packet_read_poll1();
#line 1229
      type = (unsigned char )tmp___4;
#line 1230
      switch ((int )type) {
      case 32: 
#line 1232
      break;
      case 36: 
#line 1234
      tmp___5 = packet_get_string((u_int *)((void *)0));
#line 1234
      msg = (char *)tmp___5;
#line 1235
      debug("Remote: %.900s", msg);
#line 1236
      xfree((void *)msg);
#line 1237
      break;
      case 1: 
#line 1239
      tmp___6 = packet_get_string((u_int *)((void *)0));
#line 1239
      msg = (char *)tmp___6;
#line 1240
      tmp___7 = get_remote_ipaddr();
#line 1240
      logit("Received disconnect from %s: %.400s", tmp___7, msg);
#line 1242
      cleanup_exit(255);
#line 1243
      break;
      default: ;
#line 1245
      if (type) {

      }
#line 1247
      return ((int )type);
      }
    }
  }
}
}
#line 1253 "packet.c"
int packet_read_poll(void) 
{ int tmp ;

  {
#line 1256
  tmp = packet_read_poll_seqnr((u_int32_t *)((void *)0));
#line 1256
  return (tmp);
}
}
#line 1264 "packet.c"
void packet_process_incoming(char const   *buf___1 , u_int len ) 
{ 

  {
#line 1267
  buffer_append(& input, (void const   *)buf___1, len);
#line 1268
  return;
}
}
#line 1272 "packet.c"
u_int packet_get_char(void) 
{ char ch ;

  {
#line 1277
  buffer_get(& incoming_packet, (void *)(& ch), 1U);
#line 1278
  return ((unsigned int )((unsigned char )ch));
}
}
#line 1283 "packet.c"
u_int packet_get_int(void) 
{ u_int tmp ;

  {
#line 1286
  tmp = buffer_get_int(& incoming_packet);
#line 1286
  return (tmp);
}
}
#line 1294 "packet.c"
void packet_get_bignum(BIGNUM *value ) 
{ 

  {
#line 1297
  buffer_get_bignum(& incoming_packet, value);
#line 1298
  return;
}
}
#line 1300 "packet.c"
void packet_get_bignum2(BIGNUM *value ) 
{ 

  {
#line 1303
  buffer_get_bignum2(& incoming_packet, value);
#line 1304
  return;
}
}
#line 1306 "packet.c"
void *packet_get_raw(u_int *length_ptr ) 
{ u_int bytes ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 1309
  tmp = buffer_len(& incoming_packet);
#line 1309
  bytes = tmp;
#line 1311
  if ((unsigned int )length_ptr != (unsigned int )((void *)0)) {
#line 1312
    *length_ptr = bytes;
  }
#line 1313
  tmp___0 = buffer_ptr(& incoming_packet);
#line 1313
  return (tmp___0);
}
}
#line 1316 "packet.c"
int packet_remaining(void) 
{ u_int tmp ;

  {
#line 1319
  tmp = buffer_len(& incoming_packet);
#line 1319
  return ((int )tmp);
}
}
#line 1329 "packet.c"
void *packet_get_string(u_int *length_ptr ) 
{ void *tmp ;

  {
#line 1332
  tmp = buffer_get_string(& incoming_packet, length_ptr);
#line 1332
  return (tmp);
}
}
#line 1344 "packet.c"
void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1350
  if (compat20) {
#line 1350
    if (datafellows & 64) {
#line 1351
      return;
    }
  }
#line 1353
  __builtin_va_start(args, fmt);
#line 1354
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1355
  __builtin_va_end(args);
#line 1357
  if (compat20) {
#line 1358
    packet_start((unsigned char)4);
#line 1359
    packet_put_char(0);
#line 1360
    packet_put_cstring((char const   *)(buf___1));
#line 1361
    packet_put_cstring("");
  } else {
#line 1363
    packet_start((unsigned char)36);
#line 1364
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1366
  packet_send();
#line 1367
  packet_write_wait();
#line 1368
  return;
}
}
#line 1382 "packet.c"
static int disconnecting  =    0;
#line 1377 "packet.c"
void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 1384
  if (disconnecting) {
#line 1385
    fatal("packet_disconnect called recursively.");
  }
#line 1386
  disconnecting = 1;
#line 1392
  __builtin_va_start(args, fmt);
#line 1393
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 1394
  __builtin_va_end(args);
#line 1397
  logit("Disconnecting: %.100s", buf___1);
#line 1400
  if (compat20) {
#line 1401
    packet_start((unsigned char)1);
#line 1402
    packet_put_int(2U);
#line 1403
    packet_put_cstring((char const   *)(buf___1));
#line 1404
    packet_put_cstring("");
  } else {
#line 1406
    packet_start((unsigned char)1);
#line 1407
    packet_put_cstring((char const   *)(buf___1));
  }
#line 1409
  packet_send();
#line 1410
  packet_write_wait();
#line 1413
  channel_close_all();
#line 1416
  packet_close();
#line 1417
  cleanup_exit(255);
}
}
#line 1422 "packet.c"
void packet_write_poll(void) 
{ int len ;
  u_int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 1425
  tmp = buffer_len(& output);
#line 1425
  len = (int )tmp;
#line 1427
  if (len > 0) {
#line 1428
    tmp___0 = buffer_ptr(& output);
#line 1428
    len = write(connection_out, (void const   *)tmp___0, (unsigned int )len);
#line 1429
    if (len <= 0) {
#line 1430
      tmp___3 = __errno_location();
#line 1430
      if (*tmp___3 == 11) {
#line 1431
        return;
      } else {
#line 1433
        tmp___1 = __errno_location();
#line 1433
        tmp___2 = strerror(*tmp___1);
#line 1433
        fatal("Write failed: %.100s", tmp___2);
      }
    }
#line 1435
    buffer_consume(& output, (unsigned int )len);
  }
#line 1437
  return;
}
}
#line 1444 "packet.c"
void packet_write_wait(void) 
{ fd_set *setp ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1449
  tmp = xcalloc(((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask )),
                sizeof(fd_mask ));
#line 1449
  setp = (fd_set *)tmp;
#line 1451
  packet_write_poll();
#line 1452
  while (1) {
#line 1452
    tmp___3 = packet_have_data_to_write();
#line 1452
    if (! tmp___3) {
#line 1452
      break;
    }
#line 1453
    memset((void *)setp, 0, (((unsigned int )(connection_out + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1455
    __asm__  volatile   ("btsl %1,%0": "=m" (setp->fds_bits[(unsigned int )connection_out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1456
    while (1) {
#line 1456
      tmp___0 = select(connection_out + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )setp,
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1456
      if (tmp___0 == -1) {
#line 1456
        tmp___1 = __errno_location();
#line 1456
        if (! (*tmp___1 == 11)) {
#line 1456
          tmp___2 = __errno_location();
#line 1456
          if (! (*tmp___2 == 4)) {
#line 1456
            break;
          }
        }
      } else {
#line 1456
        break;
      }
    }
#line 1459
    packet_write_poll();
  }
#line 1461
  xfree((void *)setp);
#line 1462
  return;
}
}
#line 1466 "packet.c"
int packet_have_data_to_write(void) 
{ u_int tmp ;

  {
#line 1469
  tmp = buffer_len(& output);
#line 1469
  return (tmp != 0U);
}
}
#line 1474 "packet.c"
int packet_not_very_much_data_to_write(void) 
{ u_int tmp ;
  u_int tmp___0 ;

  {
#line 1477
  if (interactive_mode) {
#line 1478
    tmp = buffer_len(& output);
#line 1478
    return (tmp < 16384U);
  } else {
#line 1480
    tmp___0 = buffer_len(& output);
#line 1480
    return (tmp___0 < 131072U);
  }
}
}
#line 1484 "packet.c"
static void packet_set_tos(int interactive ) 
{ int tos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1488
  if (interactive) {
#line 1488
    tmp = 16;
  } else {
#line 1488
    tmp = 8;
  }
#line 1488
  tos = tmp;
#line 1490
  tmp___0 = packet_connection_is_on_socket();
#line 1490
  if (tmp___0) {
#line 1490
    tmp___1 = packet_connection_is_ipv4();
#line 1490
    if (! tmp___1) {
#line 1492
      return;
    }
  } else {
#line 1492
    return;
  }
#line 1493
  tmp___4 = setsockopt(connection_in, 0, 1, (void const   *)(& tos), sizeof(tos));
#line 1493
  if (tmp___4 < 0) {
#line 1495
    tmp___2 = __errno_location();
#line 1495
    tmp___3 = strerror(*tmp___2);
#line 1495
    error("setsockopt IP_TOS %d: %.100s:", tos, tmp___3);
  }
#line 1498
  return;
}
}
#line 1505 "packet.c"
static int called  =    0;
#line 1502 "packet.c"
void packet_set_interactive(int interactive ) 
{ int tmp ;

  {
#line 1507
  if (called) {
#line 1508
    return;
  }
#line 1509
  called = 1;
#line 1512
  interactive_mode = interactive;
#line 1515
  tmp = packet_connection_is_on_socket();
#line 1515
  if (! tmp) {
#line 1516
    return;
  }
#line 1517
  set_nodelay(connection_in);
#line 1518
  packet_set_tos(interactive);
#line 1519
  return;
}
}
#line 1523 "packet.c"
int packet_is_interactive(void) 
{ 

  {
#line 1526
  return (interactive_mode);
}
}
#line 1532 "packet.c"
static int called___0  =    0;
#line 1529 "packet.c"
int packet_set_maxsize(u_int s ) 
{ 

  {
#line 1534
  if (called___0) {
#line 1535
    logit("packet_set_maxsize: called twice: old %d new %d", max_packet_size, s);
#line 1537
    return (-1);
  }
#line 1539
  if (s < 4096U) {
#line 1540
    logit("packet_set_maxsize: bad size %d", s);
#line 1541
    return (-1);
  } else {
#line 1539
    if (s > 1048576U) {
#line 1540
      logit("packet_set_maxsize: bad size %d", s);
#line 1541
      return (-1);
    }
  }
#line 1543
  called___0 = 1;
#line 1544
  debug("packet_set_maxsize: setting to %d", s);
#line 1545
  max_packet_size = s;
#line 1546
  return ((int )s);
}
}
#line 1550 "packet.c"
void packet_add_padding(u_char pad ) 
{ 

  {
#line 1553
  extra_pad = pad;
#line 1554
  return;
}
}
#line 1567 "packet.c"
void packet_send_ignore(int nbytes ) 
{ u_int32_t rnd ;
  int i ;
  int tmp ;

  {
#line 1570
  rnd = (u_int32_t )0;
#line 1573
  if (compat20) {
#line 1573
    tmp = 2;
  } else {
#line 1573
    tmp = 32;
  }
#line 1573
  packet_start((unsigned char )tmp);
#line 1574
  packet_put_int((unsigned int )nbytes);
#line 1575
  i = 0;
#line 1575
  while (i < nbytes) {
#line 1576
    if (i % 4 == 0) {
#line 1577
      rnd = arc4random();
    }
#line 1578
    packet_put_char((int )((unsigned char )rnd) & 255);
#line 1579
    rnd >>= 8;
#line 1575
    i ++;
  }
#line 1581
  return;
}
}
#line 1584 "packet.c"
int packet_need_rekeying(void) 
{ int tmp ;

  {
#line 1587
  if (datafellows & 32768) {
#line 1588
    return (0);
  }
#line 1589
  if (p_send.packets > 1U << 31) {
#line 1589
    tmp = 1;
  } else {
#line 1589
    if (p_read.packets > 1U << 31) {
#line 1589
      tmp = 1;
    } else {
#line 1589
      if (max_blocks_out) {
#line 1589
        if (p_send.blocks > max_blocks_out) {
#line 1589
          tmp = 1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1589
        if (max_blocks_in) {
#line 1589
          if (p_read.blocks > max_blocks_in) {
#line 1589
            tmp = 1;
          } else {
#line 1589
            tmp = 0;
          }
        } else {
#line 1589
          tmp = 0;
        }
      }
    }
  }
#line 1589
  return (tmp);
}
}
#line 1596 "packet.c"
void packet_set_rekey_limit(u_int32_t bytes ) 
{ 

  {
#line 1599
  rekey_limit = bytes;
#line 1600
  return;
}
}
#line 1602 "packet.c"
void packet_set_server(void) 
{ 

  {
#line 1605
  server_side = 1;
#line 1606
  return;
}
}
#line 1608 "packet.c"
void packet_set_authenticated(void) 
{ 

  {
#line 1611
  after_authentication = 1;
#line 1612
  return;
}
}
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
#line 1 "readpass.o"
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 87 "misc.h"
char *read_passphrase(char const   *prompt , int flags ) ;
#line 88
int ( /* format attribute */  ask_permission)(char const   *fmt  , ...) ;
#line 18 "uidswap.h"
void permanently_drop_suid(uid_t uid ) ;
#line 49 "readpass.c"
static char *ssh_askpass(char *askpass , char const   *msg ) 
{ pid_t pid ;
  size_t len ;
  char *pass ;
  int p[2] ;
  int status ;
  int ret___0 ;
  char buf___1[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  __pid_t tmp___15 ;
  union __anonunion___u_75 __u ;
  union __anonunion___u_76 __u___0 ;
  unsigned int tmp___48 ;

  {
#line 58
  tmp___1 = fflush(stdout);
#line 58
  if (tmp___1 != 0) {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    error("ssh_askpass: fflush: %s", tmp___0);
  }
#line 60
  if ((unsigned int )askpass == (unsigned int )((void *)0)) {
#line 61
    fatal("internal error: askpass undefined");
  }
#line 62
  tmp___4 = pipe((int *)(p));
#line 62
  if (tmp___4 < 0) {
#line 63
    tmp___2 = __errno_location();
#line 63
    tmp___3 = strerror(*tmp___2);
#line 63
    error("ssh_askpass: pipe: %s", tmp___3);
#line 64
    return ((char *)((void *)0));
  }
#line 66
  pid = fork();
#line 66
  if (pid < 0) {
#line 67
    tmp___5 = __errno_location();
#line 67
    tmp___6 = strerror(*tmp___5);
#line 67
    error("ssh_askpass: fork: %s", tmp___6);
#line 68
    return ((char *)((void *)0));
  }
#line 70
  if (pid == 0) {
#line 71
    tmp___7 = getuid();
#line 71
    permanently_drop_suid(tmp___7);
#line 72
    close(p[0]);
#line 73
    tmp___10 = dup2(p[1], 1);
#line 73
    if (tmp___10 < 0) {
#line 74
      tmp___8 = __errno_location();
#line 74
      tmp___9 = strerror(*tmp___8);
#line 74
      fatal("ssh_askpass: dup2: %s", tmp___9);
    }
#line 75
    execlp((char const   *)askpass, (char const   *)askpass, msg, (char *)0);
#line 76
    tmp___11 = __errno_location();
#line 76
    tmp___12 = strerror(*tmp___11);
#line 76
    fatal("ssh_askpass: exec(%s): %s", askpass, tmp___12);
  }
#line 78
  close(p[1]);
#line 80
  ret___0 = 0;
#line 80
  len = (unsigned int )ret___0;
#line 81
  while (1) {
#line 82
    ret___0 = read(p[0], (void *)(buf___1 + len), (sizeof(buf___1) - 1U) - len);
#line 83
    if (ret___0 == -1) {
#line 83
      tmp___13 = __errno_location();
#line 83
      if (*tmp___13 == 4) {
        goto __Cont;
      }
    }
#line 85
    if (ret___0 <= 0) {
#line 86
      break;
    }
#line 87
    len += (size_t )ret___0;
    __Cont: /* CIL Label */ 
#line 81
    if (! ((sizeof(buf___1) - 1U) - len > 0U)) {
#line 81
      break;
    }
  }
#line 89
  buf___1[len] = (char )'\000';
#line 91
  close(p[0]);
#line 92
  while (1) {
#line 92
    tmp___15 = waitpid(pid, & status, 0);
#line 92
    if (! (tmp___15 < 0)) {
#line 92
      break;
    }
#line 93
    tmp___14 = __errno_location();
#line 93
    if (*tmp___14 != 4) {
#line 94
      break;
    }
  }
#line 96
  __u.__in = status;
#line 96
  if ((__u.__i & 127) == 0) {
#line 96
    __u___0.__in = status;
#line 96
    if ((__u___0.__i & 65280) >> 8 != 0) {
#line 97
      memset((void *)(buf___1), 0, sizeof(buf___1));
#line 98
      return ((char *)((void *)0));
    }
  } else {
#line 97
    memset((void *)(buf___1), 0, sizeof(buf___1));
#line 98
    return ((char *)((void *)0));
  }
#line 101
  tmp___48 = __builtin_strcspn((char const   *)(buf___1), "\r\n");
#line 101
  buf___1[tmp___48] = (char )'\000';
#line 102
  pass = xstrdup((char const   *)(buf___1));
#line 103
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 104
  return (pass);
}
}
#line 113 "readpass.c"
char *read_passphrase(char const   *prompt , int flags ) 
{ char *askpass ;
  char *ret___0 ;
  char buf___1[1024] ;
  int rppflags ;
  int use_askpass ;
  int ttyfd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 116
  askpass = (char *)((void *)0);
#line 117
  use_askpass = 0;
#line 119
  if (flags & 1) {
#line 119
    rppflags = 1;
  } else {
#line 119
    rppflags = 0;
  }
#line 120
  if (flags & 8) {
#line 121
    use_askpass = 1;
  } else {
#line 122
    if (flags & 2) {
#line 123
      tmp = isatty(0);
#line 123
      if (! tmp) {
#line 124
        debug("read_passphrase: stdin is not a tty");
#line 125
        use_askpass = 1;
      }
    } else {
#line 128
      rppflags |= 2;
#line 129
      ttyfd = open("/dev/tty", 2);
#line 130
      if (ttyfd >= 0) {
#line 131
        close(ttyfd);
      } else {
#line 133
        tmp___0 = __errno_location();
#line 133
        tmp___1 = strerror(*tmp___0);
#line 133
        debug("read_passphrase: can\'t open %s: %s", "/dev/tty", tmp___1);
#line 135
        use_askpass = 1;
      }
    }
  }
#line 139
  if (flags & 8) {
#line 139
    tmp___4 = getenv("DISPLAY");
#line 139
    if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 140
      if (flags & 4) {
#line 140
        tmp___3 = (char *)((void *)0);
      } else {
#line 140
        tmp___3 = xstrdup("");
      }
#line 140
      return (tmp___3);
    }
  }
#line 142
  if (use_askpass) {
#line 142
    tmp___7 = getenv("DISPLAY");
#line 142
    if (tmp___7) {
#line 143
      tmp___5 = getenv("SSH_ASKPASS");
#line 143
      if (tmp___5) {
#line 144
        askpass = getenv("SSH_ASKPASS");
      } else {
#line 146
        askpass = (char *)"/usr/local/libexec/ssh-askpass";
      }
#line 147
      ret___0 = ssh_askpass(askpass, prompt);
#line 147
      if ((unsigned int )ret___0 == (unsigned int )((void *)0)) {
#line 148
        if (! (flags & 4)) {
#line 149
          tmp___6 = xstrdup("");
#line 149
          return (tmp___6);
        }
      }
#line 150
      return (ret___0);
    }
  }
#line 153
  tmp___9 = readpassphrase(prompt, buf___1, sizeof(buf___1), rppflags);
#line 153
  if ((unsigned int )tmp___9 == (unsigned int )((void *)0)) {
#line 154
    if (flags & 4) {
#line 155
      return ((char *)((void *)0));
    }
#line 156
    tmp___8 = xstrdup("");
#line 156
    return (tmp___8);
  }
#line 159
  ret___0 = xstrdup((char const   *)(buf___1));
#line 160
  memset((void *)(buf___1), 'x', sizeof(buf___1));
#line 161
  return (ret___0);
}
}
#line 164 "readpass.c"
int ( /* format attribute */  ask_permission)(char const   *fmt  , ...) 
{ va_list args ;
  char *p ;
  char prompt[1024] ;
  int allowed ;
  int tmp ;

  {
#line 169
  allowed = 0;
#line 171
  __builtin_va_start(args, fmt);
#line 172
  vsnprintf((char * __restrict  )(prompt), sizeof(prompt), (char const   * __restrict  )fmt,
            args);
#line 173
  __builtin_va_end(args);
#line 175
  p = read_passphrase((char const   *)(prompt), 12);
#line 176
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 181
    if ((int )*p == 0) {
#line 183
      allowed = 1;
    } else {
#line 181
      if ((int )*p == 10) {
#line 183
        allowed = 1;
      } else {
#line 181
        tmp = strcasecmp((char const   *)p, "yes");
#line 181
        if (tmp == 0) {
#line 183
          allowed = 1;
        }
      }
    }
#line 184
    xfree((void *)p);
  }
#line 187
  return (allowed);
}
}
#line 1 "rsa.o"
#line 391 "/usr/include/openssl/bn.h"
extern BIGNUM const   *BN_value_one(void) ;
#line 409
extern void BN_clear_free(BIGNUM *a ) ;
#line 416
extern int BN_sub(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *b ) ;
#line 433
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 230 "/usr/include/openssl/rsa.h"
extern int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 236
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
#line 22 "rsa.h"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 23
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) ;
#line 74 "rsa.c"
void rsa_public_encrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  BIGNUM *tmp___4 ;

  {
#line 80
  tmp = BN_num_bits((BIGNUM const   *)key->e);
#line 80
  if (tmp < 2) {
#line 81
    fatal("rsa_public_encrypt() exponent too small or not odd");
  } else {
#line 80
    if ((key->e)->top > 0) {
#line 80
      if (! (*((key->e)->d + 0) & 1UL)) {
#line 81
        fatal("rsa_public_encrypt() exponent too small or not odd");
      }
    } else {
#line 81
      fatal("rsa_public_encrypt() exponent too small or not odd");
    }
  }
#line 83
  tmp___0 = BN_num_bits((BIGNUM const   *)key->n);
#line 83
  olen = (tmp___0 + 7) / 8;
#line 84
  tmp___1 = xmalloc((unsigned int )olen);
#line 84
  outbuf = (u_char *)tmp___1;
#line 86
  tmp___2 = BN_num_bits((BIGNUM const   *)in);
#line 86
  ilen = (tmp___2 + 7) / 8;
#line 87
  tmp___3 = xmalloc((unsigned int )ilen);
#line 87
  inbuf = (u_char *)tmp___3;
#line 88
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 90
  len = RSA_public_encrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 90
  if (len <= 0) {
#line 92
    fatal("rsa_public_encrypt() failed");
  }
#line 94
  tmp___4 = BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 94
  if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 95
    fatal("rsa_public_encrypt: BN_bin2bn failed");
  }
#line 97
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 98
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 99
  xfree((void *)outbuf);
#line 100
  xfree((void *)inbuf);
#line 101
  return;
}
}
#line 103 "rsa.c"
int rsa_private_decrypt(BIGNUM *out , BIGNUM *in , RSA *key ) 
{ u_char *inbuf ;
  u_char *outbuf ;
  int len ;
  int ilen ;
  int olen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  BIGNUM *tmp___3 ;

  {
#line 109
  tmp = BN_num_bits((BIGNUM const   *)key->n);
#line 109
  olen = (tmp + 7) / 8;
#line 110
  tmp___0 = xmalloc((unsigned int )olen);
#line 110
  outbuf = (u_char *)tmp___0;
#line 112
  tmp___1 = BN_num_bits((BIGNUM const   *)in);
#line 112
  ilen = (tmp___1 + 7) / 8;
#line 113
  tmp___2 = xmalloc((unsigned int )ilen);
#line 113
  inbuf = (u_char *)tmp___2;
#line 114
  BN_bn2bin((BIGNUM const   *)in, inbuf);
#line 116
  len = RSA_private_decrypt(ilen, (unsigned char const   *)inbuf, outbuf, key, 1);
#line 116
  if (len <= 0) {
#line 118
    error("rsa_private_decrypt() failed");
  } else {
#line 120
    tmp___3 = BN_bin2bn((unsigned char const   *)outbuf, len, out);
#line 120
    if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 121
      fatal("rsa_private_decrypt: BN_bin2bn failed");
    }
  }
#line 123
  memset((void *)outbuf, 0, (unsigned int )olen);
#line 124
  memset((void *)inbuf, 0, (unsigned int )ilen);
#line 125
  xfree((void *)outbuf);
#line 126
  xfree((void *)inbuf);
#line 127
  return (len);
}
}
#line 131 "rsa.c"
void rsa_generate_additional_parameters(RSA *rsa ) 
{ BIGNUM *aux ;
  BN_CTX *ctx ;
  BIGNUM const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  BIGNUM const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 137
  aux = BN_new();
#line 137
  if ((unsigned int )aux == (unsigned int )((void *)0)) {
#line 138
    fatal("rsa_generate_additional_parameters: BN_new failed");
  }
#line 139
  ctx = BN_CTX_new();
#line 139
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 140
    fatal("rsa_generate_additional_parameters: BN_CTX_new failed");
  }
#line 142
  tmp = BN_value_one();
#line 142
  tmp___0 = BN_sub(aux, (BIGNUM const   *)rsa->q, tmp);
#line 142
  if (tmp___0 == 0) {
#line 146
    fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
  } else {
#line 142
    tmp___1 = BN_div((BIGNUM *)((void *)0), rsa->dmq1, (BIGNUM const   *)rsa->d, (BIGNUM const   *)aux,
                     ctx);
#line 142
    if (tmp___1 == 0) {
#line 146
      fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
    } else {
#line 142
      tmp___2 = BN_value_one();
#line 142
      tmp___3 = BN_sub(aux, (BIGNUM const   *)rsa->p, tmp___2);
#line 142
      if (tmp___3 == 0) {
#line 146
        fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
      } else {
#line 142
        tmp___4 = BN_div((BIGNUM *)((void *)0), rsa->dmp1, (BIGNUM const   *)rsa->d,
                         (BIGNUM const   *)aux, ctx);
#line 142
        if (tmp___4 == 0) {
#line 146
          fatal("rsa_generate_additional_parameters: BN_sub/mod failed");
        }
      }
    }
  }
#line 148
  BN_clear_free(aux);
#line 149
  BN_CTX_free(ctx);
#line 150
  return;
}
}
#line 1 "ttymodes.o"
#line 49 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios  const  *__termios_p ) ;
#line 52
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios  const  *__termios_p ) ;
#line 55
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 58
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 85 "packet.h"
void tty_make_modes(int fd , struct termios *tiop ) ;
#line 86
void tty_parse_modes(int fd , int *n_bytes_ptr ) ;
#line 74 "ttymodes.c"
static int speed_to_baud(speed_t speed ) 
{ 

  {
#line 77
  switch ((int )speed) {
  case 0: 
#line 79
  return (0);
  case 1: 
#line 81
  return (50);
  case 2: 
#line 83
  return (75);
  case 3: 
#line 85
  return (110);
  case 4: 
#line 87
  return (134);
  case 5: 
#line 89
  return (150);
  case 6: 
#line 91
  return (200);
  case 7: 
#line 93
  return (300);
  case 8: 
#line 95
  return (600);
  case 9: 
#line 97
  return (1200);
  case 10: 
#line 99
  return (1800);
  case 11: 
#line 101
  return (2400);
  case 12: 
#line 103
  return (4800);
  case 13: 
#line 105
  return (9600);
  case 14: 
#line 109
  return (19200);
  case 15: 
#line 119
  return (38400);
  case 4097: 
#line 141
  return (57600);
  case 4098: 
#line 149
  return (115200);
  case 4099: 
#line 153
  return (230400);
  default: ;
#line 156
  return (9600);
  }
}
}
#line 163 "ttymodes.c"
static speed_t baud_to_speed(int baud ) 
{ 

  {
#line 166
  switch (baud) {
  case 0: 
#line 168
  return (0U);
  case 50: 
#line 170
  return (1U);
  case 75: 
#line 172
  return (2U);
  case 110: 
#line 174
  return (3U);
  case 134: 
#line 176
  return (4U);
  case 150: 
#line 178
  return (5U);
  case 200: 
#line 180
  return (6U);
  case 300: 
#line 182
  return (7U);
  case 600: 
#line 184
  return (8U);
  case 1200: 
#line 186
  return (9U);
  case 1800: 
#line 188
  return (10U);
  case 2400: 
#line 190
  return (11U);
  case 4800: 
#line 192
  return (12U);
  case 9600: 
#line 194
  return (13U);
  case 19200: 
#line 198
  return (14U);
  case 38400: 
#line 208
  return (15U);
  case 57600: 
#line 230
  return (4097U);
  case 115200: 
#line 238
  return (4098U);
  case 230400: 
#line 242
  return (4099U);
  default: ;
#line 245
  return (13U);
  }
}
}
#line 252 "ttymodes.c"
static u_int special_char_encode(cc_t c ) 
{ 

  {
#line 259
  return ((unsigned int )c);
}
}
#line 265 "ttymodes.c"
static cc_t special_char_decode(u_int c ) 
{ 

  {
#line 272
  return ((unsigned char )c);
}
}
#line 280 "ttymodes.c"
void tty_make_modes(int fd , struct termios *tiop ) 
{ struct termios tio ;
  int baud ;
  Buffer buf___1 ;
  int tty_op_ospeed ;
  int tty_op_ispeed ;
  void (*put_arg)(Buffer * , u_int  ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  speed_t tmp___2 ;
  speed_t tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  void *tmp___19 ;
  u_int tmp___20 ;
  void *tmp___21 ;

  {
#line 289
  buffer_init(& buf___1);
#line 290
  if (compat20) {
#line 291
    tty_op_ospeed = 129;
#line 292
    tty_op_ispeed = 128;
#line 293
    put_arg = & buffer_put_int;
  } else {
#line 295
    tty_op_ospeed = 193;
#line 296
    tty_op_ispeed = 192;
#line 297
    put_arg = (void (*)(Buffer * , u_int  ))(& buffer_put_char);
  }
#line 300
  if ((unsigned int )tiop == (unsigned int )((void *)0)) {
#line 301
    tmp___1 = tcgetattr(fd, & tio);
#line 301
    if (tmp___1 == -1) {
#line 302
      tmp = __errno_location();
#line 302
      tmp___0 = strerror(*tmp);
#line 302
      logit("tcgetattr: %.100s", tmp___0);
      goto end;
    }
  } else {
#line 306
    tio = *tiop;
  }
#line 309
  tmp___2 = cfgetospeed((struct termios  const  *)(& tio));
#line 309
  baud = speed_to_baud(tmp___2);
#line 310
  debug3("tty_make_modes: ospeed %d", baud);
#line 311
  buffer_put_char(& buf___1, tty_op_ospeed);
#line 312
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 313
  tmp___3 = cfgetispeed((struct termios  const  *)(& tio));
#line 313
  baud = speed_to_baud(tmp___3);
#line 314
  debug3("tty_make_modes: ispeed %d", baud);
#line 315
  buffer_put_char(& buf___1, tty_op_ispeed);
#line 316
  buffer_put_int(& buf___1, (unsigned int )baud);
#line 70 "ttymodes.h"
  debug3("tty_make_modes: %d %d", 1, tio.c_cc[0]);
#line 70
  buffer_put_char(& buf___1, 1);
#line 70
  tmp___4 = special_char_encode(tio.c_cc[0]);
#line 70
  (*put_arg)(& buf___1, tmp___4);
#line 71
  debug3("tty_make_modes: %d %d", 2, tio.c_cc[1]);
#line 71
  buffer_put_char(& buf___1, 2);
#line 71
  tmp___5 = special_char_encode(tio.c_cc[1]);
#line 71
  (*put_arg)(& buf___1, tmp___5);
#line 72
  debug3("tty_make_modes: %d %d", 3, tio.c_cc[2]);
#line 72
  buffer_put_char(& buf___1, 3);
#line 72
  tmp___6 = special_char_encode(tio.c_cc[2]);
#line 72
  (*put_arg)(& buf___1, tmp___6);
#line 74
  debug3("tty_make_modes: %d %d", 4, tio.c_cc[3]);
#line 74
  buffer_put_char(& buf___1, 4);
#line 74
  tmp___7 = special_char_encode(tio.c_cc[3]);
#line 74
  (*put_arg)(& buf___1, tmp___7);
#line 76
  debug3("tty_make_modes: %d %d", 5, tio.c_cc[4]);
#line 76
  buffer_put_char(& buf___1, 5);
#line 76
  tmp___8 = special_char_encode(tio.c_cc[4]);
#line 76
  (*put_arg)(& buf___1, tmp___8);
#line 78
  debug3("tty_make_modes: %d %d", 6, tio.c_cc[11]);
#line 78
  buffer_put_char(& buf___1, 6);
#line 78
  tmp___9 = special_char_encode(tio.c_cc[11]);
#line 78
  (*put_arg)(& buf___1, tmp___9);
#line 81
  debug3("tty_make_modes: %d %d", 7, tio.c_cc[16]);
#line 81
  buffer_put_char(& buf___1, 7);
#line 81
  tmp___10 = special_char_encode(tio.c_cc[16]);
#line 81
  (*put_arg)(& buf___1, tmp___10);
#line 83
  debug3("tty_make_modes: %d %d", 8, tio.c_cc[8]);
#line 83
  buffer_put_char(& buf___1, 8);
#line 83
  tmp___11 = special_char_encode(tio.c_cc[8]);
#line 83
  (*put_arg)(& buf___1, tmp___11);
#line 84
  debug3("tty_make_modes: %d %d", 9, tio.c_cc[9]);
#line 84
  buffer_put_char(& buf___1, 9);
#line 84
  tmp___12 = special_char_encode(tio.c_cc[9]);
#line 84
  (*put_arg)(& buf___1, tmp___12);
#line 86
  debug3("tty_make_modes: %d %d", 10, tio.c_cc[10]);
#line 86
  buffer_put_char(& buf___1, 10);
#line 86
  tmp___13 = special_char_encode(tio.c_cc[10]);
#line 86
  (*put_arg)(& buf___1, tmp___13);
#line 92
  debug3("tty_make_modes: %d %d", 12, tio.c_cc[12]);
#line 92
  buffer_put_char(& buf___1, 12);
#line 92
  tmp___14 = special_char_encode(tio.c_cc[12]);
#line 92
  (*put_arg)(& buf___1, tmp___14);
#line 95
  debug3("tty_make_modes: %d %d", 13, tio.c_cc[14]);
#line 95
  buffer_put_char(& buf___1, 13);
#line 95
  tmp___15 = special_char_encode(tio.c_cc[14]);
#line 95
  (*put_arg)(& buf___1, tmp___15);
#line 98
  debug3("tty_make_modes: %d %d", 14, tio.c_cc[15]);
#line 98
  buffer_put_char(& buf___1, 14);
#line 98
  tmp___16 = special_char_encode(tio.c_cc[15]);
#line 98
  (*put_arg)(& buf___1, tmp___16);
#line 110
  debug3("tty_make_modes: %d %d", 18, tio.c_cc[13]);
#line 110
  buffer_put_char(& buf___1, 18);
#line 110
  tmp___17 = special_char_encode(tio.c_cc[13]);
#line 110
  (*put_arg)(& buf___1, tmp___17);
#line 114
  debug3("tty_make_modes: %d %d", 30, (tio.c_iflag & 4U) != 0U);
#line 114
  buffer_put_char(& buf___1, 30);
#line 114
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4U) != 0U));
#line 115
  debug3("tty_make_modes: %d %d", 31, (tio.c_iflag & 8U) != 0U);
#line 115
  buffer_put_char(& buf___1, 31);
#line 115
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8U) != 0U));
#line 116
  debug3("tty_make_modes: %d %d", 32, (tio.c_iflag & 16U) != 0U);
#line 116
  buffer_put_char(& buf___1, 32);
#line 116
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 16U) != 0U));
#line 117
  debug3("tty_make_modes: %d %d", 33, (tio.c_iflag & 32U) != 0U);
#line 117
  buffer_put_char(& buf___1, 33);
#line 117
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 32U) != 0U));
#line 118
  debug3("tty_make_modes: %d %d", 34, (tio.c_iflag & 64U) != 0U);
#line 118
  buffer_put_char(& buf___1, 34);
#line 118
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 64U) != 0U));
#line 119
  debug3("tty_make_modes: %d %d", 35, (tio.c_iflag & 128U) != 0U);
#line 119
  buffer_put_char(& buf___1, 35);
#line 119
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 128U) != 0U));
#line 120
  debug3("tty_make_modes: %d %d", 36, (tio.c_iflag & 256U) != 0U);
#line 120
  buffer_put_char(& buf___1, 36);
#line 120
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 256U) != 0U));
#line 122
  debug3("tty_make_modes: %d %d", 37, (tio.c_iflag & 512U) != 0U);
#line 122
  buffer_put_char(& buf___1, 37);
#line 122
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 512U) != 0U));
#line 124
  debug3("tty_make_modes: %d %d", 38, (tio.c_iflag & 1024U) != 0U);
#line 124
  buffer_put_char(& buf___1, 38);
#line 124
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 1024U) != 0U));
#line 125
  debug3("tty_make_modes: %d %d", 39, (tio.c_iflag & 2048U) != 0U);
#line 125
  buffer_put_char(& buf___1, 39);
#line 125
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 2048U) != 0U));
#line 126
  debug3("tty_make_modes: %d %d", 40, (tio.c_iflag & 4096U) != 0U);
#line 126
  buffer_put_char(& buf___1, 40);
#line 126
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 4096U) != 0U));
#line 128
  debug3("tty_make_modes: %d %d", 41, (tio.c_iflag & 8192U) != 0U);
#line 128
  buffer_put_char(& buf___1, 41);
#line 128
  (*put_arg)(& buf___1, (unsigned int )((tio.c_iflag & 8192U) != 0U));
#line 131
  debug3("tty_make_modes: %d %d", 50, (tio.c_lflag & 1U) != 0U);
#line 131
  buffer_put_char(& buf___1, 50);
#line 131
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 1U) != 0U));
#line 132
  debug3("tty_make_modes: %d %d", 51, (tio.c_lflag & 2U) != 0U);
#line 132
  buffer_put_char(& buf___1, 51);
#line 132
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2U) != 0U));
#line 134
  debug3("tty_make_modes: %d %d", 52, (tio.c_lflag & 4U) != 0U);
#line 134
  buffer_put_char(& buf___1, 52);
#line 134
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 4U) != 0U));
#line 136
  debug3("tty_make_modes: %d %d", 53, (tio.c_lflag & 8U) != 0U);
#line 136
  buffer_put_char(& buf___1, 53);
#line 136
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 8U) != 0U));
#line 137
  debug3("tty_make_modes: %d %d", 54, (tio.c_lflag & 16U) != 0U);
#line 137
  buffer_put_char(& buf___1, 54);
#line 137
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16U) != 0U));
#line 138
  debug3("tty_make_modes: %d %d", 55, (tio.c_lflag & 32U) != 0U);
#line 138
  buffer_put_char(& buf___1, 55);
#line 138
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32U) != 0U));
#line 139
  debug3("tty_make_modes: %d %d", 56, (tio.c_lflag & 64U) != 0U);
#line 139
  buffer_put_char(& buf___1, 56);
#line 139
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 64U) != 0U));
#line 140
  debug3("tty_make_modes: %d %d", 57, (tio.c_lflag & 128U) != 0U);
#line 140
  buffer_put_char(& buf___1, 57);
#line 140
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 128U) != 0U));
#line 141
  debug3("tty_make_modes: %d %d", 58, (tio.c_lflag & 256U) != 0U);
#line 141
  buffer_put_char(& buf___1, 58);
#line 141
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 256U) != 0U));
#line 143
  debug3("tty_make_modes: %d %d", 59, (tio.c_lflag & 32768U) != 0U);
#line 143
  buffer_put_char(& buf___1, 59);
#line 143
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 32768U) != 0U));
#line 146
  debug3("tty_make_modes: %d %d", 60, (tio.c_lflag & 512U) != 0U);
#line 146
  buffer_put_char(& buf___1, 60);
#line 146
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 512U) != 0U));
#line 149
  debug3("tty_make_modes: %d %d", 61, (tio.c_lflag & 2048U) != 0U);
#line 149
  buffer_put_char(& buf___1, 61);
#line 149
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 2048U) != 0U));
#line 152
  debug3("tty_make_modes: %d %d", 62, (tio.c_lflag & 16384U) != 0U);
#line 152
  buffer_put_char(& buf___1, 62);
#line 152
  (*put_arg)(& buf___1, (unsigned int )((tio.c_lflag & 16384U) != 0U));
#line 155
  debug3("tty_make_modes: %d %d", 70, (tio.c_oflag & 1U) != 0U);
#line 155
  buffer_put_char(& buf___1, 70);
#line 155
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 1U) != 0U));
#line 157
  debug3("tty_make_modes: %d %d", 71, (tio.c_oflag & 2U) != 0U);
#line 157
  buffer_put_char(& buf___1, 71);
#line 157
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 2U) != 0U));
#line 160
  debug3("tty_make_modes: %d %d", 72, (tio.c_oflag & 4U) != 0U);
#line 160
  buffer_put_char(& buf___1, 72);
#line 160
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 4U) != 0U));
#line 163
  debug3("tty_make_modes: %d %d", 73, (tio.c_oflag & 8U) != 0U);
#line 163
  buffer_put_char(& buf___1, 73);
#line 163
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 8U) != 0U));
#line 166
  debug3("tty_make_modes: %d %d", 74, (tio.c_oflag & 16U) != 0U);
#line 166
  buffer_put_char(& buf___1, 74);
#line 166
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 16U) != 0U));
#line 169
  debug3("tty_make_modes: %d %d", 75, (tio.c_oflag & 32U) != 0U);
#line 169
  buffer_put_char(& buf___1, 75);
#line 169
  (*put_arg)(& buf___1, (unsigned int )((tio.c_oflag & 32U) != 0U));
#line 172
  debug3("tty_make_modes: %d %d", 90, (tio.c_cflag & 32U) != 0U);
#line 172
  buffer_put_char(& buf___1, 90);
#line 172
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 32U) != 0U));
#line 173
  debug3("tty_make_modes: %d %d", 91, (tio.c_cflag & 48U) != 0U);
#line 173
  buffer_put_char(& buf___1, 91);
#line 173
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 48U) != 0U));
#line 174
  debug3("tty_make_modes: %d %d", 92, (tio.c_cflag & 256U) != 0U);
#line 174
  buffer_put_char(& buf___1, 92);
#line 174
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 256U) != 0U));
#line 175
  debug3("tty_make_modes: %d %d", 93, (tio.c_cflag & 512U) != 0U);
#line 175
  buffer_put_char(& buf___1, 93);
#line 175
  (*put_arg)(& buf___1, (unsigned int )((tio.c_cflag & 512U) != 0U));
  end: 
#line 336 "ttymodes.c"
  buffer_put_char(& buf___1, 0);
#line 337
  if (compat20) {
#line 338
    tmp___18 = buffer_len(& buf___1);
#line 338
    tmp___19 = buffer_ptr(& buf___1);
#line 338
    packet_put_string((void const   *)tmp___19, tmp___18);
  } else {
#line 340
    tmp___20 = buffer_len(& buf___1);
#line 340
    tmp___21 = buffer_ptr(& buf___1);
#line 340
    packet_put_raw((void const   *)tmp___21, tmp___20);
  }
#line 341
  buffer_free(& buf___1);
#line 342
  return;
}
}
#line 348 "ttymodes.c"
void tty_parse_modes(int fd , int *n_bytes_ptr ) 
{ struct termios tio ;
  int opcode ;
  int baud ;
  int n_bytes ;
  int failure ;
  u_int (*get_arg)(void) ;
  int arg ;
  int arg_size ;
  u_int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  speed_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  speed_t tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  u_int tmp___14 ;
  u_int tmp___15 ;
  u_int tmp___16 ;
  u_int tmp___17 ;
  u_int tmp___18 ;
  u_int tmp___19 ;
  u_int tmp___20 ;
  u_int tmp___21 ;
  u_int tmp___22 ;
  u_int tmp___23 ;
  u_int tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  u_int tmp___29 ;
  u_int tmp___30 ;
  u_int tmp___31 ;
  u_int tmp___32 ;
  u_int tmp___33 ;
  u_int tmp___34 ;
  u_int tmp___35 ;
  u_int tmp___36 ;
  u_int tmp___37 ;
  u_int tmp___38 ;
  u_int tmp___39 ;
  u_int tmp___40 ;
  u_int tmp___41 ;
  u_int tmp___42 ;
  u_int tmp___43 ;
  u_int tmp___44 ;
  u_int tmp___45 ;
  u_int tmp___46 ;
  u_int tmp___47 ;
  u_int tmp___48 ;
  u_int tmp___49 ;
  u_int tmp___50 ;
  u_int tmp___51 ;
  u_int tmp___52 ;
  u_int tmp___53 ;
  u_int tmp___54 ;
  u_int tmp___55 ;
  u_int tmp___56 ;
  u_int tmp___57 ;
  u_int tmp___58 ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;

  {
#line 353
  n_bytes = 0;
#line 354
  failure = 0;
#line 358
  if (compat20) {
#line 359
    tmp = packet_get_int();
#line 359
    *n_bytes_ptr = (int )tmp;
#line 360
    debug3("tty_parse_modes: SSH2 n_bytes %d", *n_bytes_ptr);
#line 361
    if (*n_bytes_ptr == 0) {
#line 362
      return;
    }
#line 363
    get_arg = & packet_get_int;
#line 364
    arg_size = 4;
  } else {
#line 366
    get_arg = & packet_get_char;
#line 367
    arg_size = 1;
  }
#line 375
  tmp___2 = tcgetattr(fd, & tio);
#line 375
  if (tmp___2 == -1) {
#line 376
    tmp___0 = __errno_location();
#line 376
    tmp___1 = strerror(*tmp___0);
#line 376
    logit("tcgetattr: %.100s", tmp___1);
#line 377
    failure = -1;
  }
#line 380
  while (1) {
#line 381
    n_bytes ++;
#line 382
    tmp___3 = packet_get_char();
#line 382
    opcode = (int )tmp___3;
#line 383
    switch (opcode) {
    case 0: 
    goto set;
    case 192: 
    case 128: 
#line 390
    n_bytes += 4;
#line 391
    tmp___4 = packet_get_int();
#line 391
    baud = (int )tmp___4;
#line 392
    debug3("tty_parse_modes: ispeed %d", baud);
#line 393
    if (failure != -1) {
#line 393
      tmp___5 = baud_to_speed(baud);
#line 393
      tmp___6 = cfsetispeed(& tio, tmp___5);
#line 393
      if (tmp___6 == -1) {
#line 395
        error("cfsetispeed failed for %d", baud);
      }
    }
#line 396
    break;
    case 193: 
    case 129: 
#line 401
    n_bytes += 4;
#line 402
    tmp___7 = packet_get_int();
#line 402
    baud = (int )tmp___7;
#line 403
    debug3("tty_parse_modes: ospeed %d", baud);
#line 404
    if (failure != -1) {
#line 404
      tmp___8 = baud_to_speed(baud);
#line 404
      tmp___9 = cfsetospeed(& tio, tmp___8);
#line 404
      if (tmp___9 == -1) {
#line 406
        error("cfsetospeed failed for %d", baud);
      }
    }
#line 407
    break;
    case 1: 
#line 70 "ttymodes.h"
    n_bytes += arg_size;
#line 70
    tmp___10 = (*get_arg)();
#line 70
    tio.c_cc[0] = special_char_decode(tmp___10);
#line 70
    debug3("tty_parse_modes: %d %d", 1, tio.c_cc[0]);
#line 70
    break;
    case 2: 
#line 71
    n_bytes += arg_size;
#line 71
    tmp___11 = (*get_arg)();
#line 71
    tio.c_cc[1] = special_char_decode(tmp___11);
#line 71
    debug3("tty_parse_modes: %d %d", 2, tio.c_cc[1]);
#line 71
    break;
    case 3: 
#line 72
    n_bytes += arg_size;
#line 72
    tmp___12 = (*get_arg)();
#line 72
    tio.c_cc[2] = special_char_decode(tmp___12);
#line 72
    debug3("tty_parse_modes: %d %d", 3, tio.c_cc[2]);
#line 72
    break;
    case 4: 
#line 74
    n_bytes += arg_size;
#line 74
    tmp___13 = (*get_arg)();
#line 74
    tio.c_cc[3] = special_char_decode(tmp___13);
#line 74
    debug3("tty_parse_modes: %d %d", 4, tio.c_cc[3]);
#line 74
    break;
    case 5: 
#line 76
    n_bytes += arg_size;
#line 76
    tmp___14 = (*get_arg)();
#line 76
    tio.c_cc[4] = special_char_decode(tmp___14);
#line 76
    debug3("tty_parse_modes: %d %d", 5, tio.c_cc[4]);
#line 76
    break;
    case 6: 
#line 78
    n_bytes += arg_size;
#line 78
    tmp___15 = (*get_arg)();
#line 78
    tio.c_cc[11] = special_char_decode(tmp___15);
#line 78
    debug3("tty_parse_modes: %d %d", 6, tio.c_cc[11]);
#line 78
    break;
    case 7: 
#line 81
    n_bytes += arg_size;
#line 81
    tmp___16 = (*get_arg)();
#line 81
    tio.c_cc[16] = special_char_decode(tmp___16);
#line 81
    debug3("tty_parse_modes: %d %d", 7, tio.c_cc[16]);
#line 81
    break;
    case 8: 
#line 83
    n_bytes += arg_size;
#line 83
    tmp___17 = (*get_arg)();
#line 83
    tio.c_cc[8] = special_char_decode(tmp___17);
#line 83
    debug3("tty_parse_modes: %d %d", 8, tio.c_cc[8]);
#line 83
    break;
    case 9: 
#line 84
    n_bytes += arg_size;
#line 84
    tmp___18 = (*get_arg)();
#line 84
    tio.c_cc[9] = special_char_decode(tmp___18);
#line 84
    debug3("tty_parse_modes: %d %d", 9, tio.c_cc[9]);
#line 84
    break;
    case 10: 
#line 86
    n_bytes += arg_size;
#line 86
    tmp___19 = (*get_arg)();
#line 86
    tio.c_cc[10] = special_char_decode(tmp___19);
#line 86
    debug3("tty_parse_modes: %d %d", 10, tio.c_cc[10]);
#line 86
    break;
    case 12: 
#line 92
    n_bytes += arg_size;
#line 92
    tmp___20 = (*get_arg)();
#line 92
    tio.c_cc[12] = special_char_decode(tmp___20);
#line 92
    debug3("tty_parse_modes: %d %d", 12, tio.c_cc[12]);
#line 92
    break;
    case 13: 
#line 95
    n_bytes += arg_size;
#line 95
    tmp___21 = (*get_arg)();
#line 95
    tio.c_cc[14] = special_char_decode(tmp___21);
#line 95
    debug3("tty_parse_modes: %d %d", 13, tio.c_cc[14]);
#line 95
    break;
    case 14: 
#line 98
    n_bytes += arg_size;
#line 98
    tmp___22 = (*get_arg)();
#line 98
    tio.c_cc[15] = special_char_decode(tmp___22);
#line 98
    debug3("tty_parse_modes: %d %d", 14, tio.c_cc[15]);
#line 98
    break;
    case 18: 
#line 110
    n_bytes += arg_size;
#line 110
    tmp___23 = (*get_arg)();
#line 110
    tio.c_cc[13] = special_char_decode(tmp___23);
#line 110
    debug3("tty_parse_modes: %d %d", 18, tio.c_cc[13]);
#line 110
    break;
    case 30: 
#line 114
    n_bytes += arg_size;
#line 114
    tmp___24 = (*get_arg)();
#line 114
    arg = (int )tmp___24;
#line 114
    if (arg) {
#line 114
      tio.c_iflag |= 4U;
    } else {
#line 114
      tio.c_iflag &= 4294967291U;
    }
#line 114
    debug3("tty_parse_modes: %d %d", 30, arg);
#line 114
    break;
    case 31: 
#line 115
    n_bytes += arg_size;
#line 115
    tmp___25 = (*get_arg)();
#line 115
    arg = (int )tmp___25;
#line 115
    if (arg) {
#line 115
      tio.c_iflag |= 8U;
    } else {
#line 115
      tio.c_iflag &= 4294967287U;
    }
#line 115
    debug3("tty_parse_modes: %d %d", 31, arg);
#line 115
    break;
    case 32: 
#line 116
    n_bytes += arg_size;
#line 116
    tmp___26 = (*get_arg)();
#line 116
    arg = (int )tmp___26;
#line 116
    if (arg) {
#line 116
      tio.c_iflag |= 16U;
    } else {
#line 116
      tio.c_iflag &= 4294967279U;
    }
#line 116
    debug3("tty_parse_modes: %d %d", 32, arg);
#line 116
    break;
    case 33: 
#line 117
    n_bytes += arg_size;
#line 117
    tmp___27 = (*get_arg)();
#line 117
    arg = (int )tmp___27;
#line 117
    if (arg) {
#line 117
      tio.c_iflag |= 32U;
    } else {
#line 117
      tio.c_iflag &= 4294967263U;
    }
#line 117
    debug3("tty_parse_modes: %d %d", 33, arg);
#line 117
    break;
    case 34: 
#line 118
    n_bytes += arg_size;
#line 118
    tmp___28 = (*get_arg)();
#line 118
    arg = (int )tmp___28;
#line 118
    if (arg) {
#line 118
      tio.c_iflag |= 64U;
    } else {
#line 118
      tio.c_iflag &= 4294967231U;
    }
#line 118
    debug3("tty_parse_modes: %d %d", 34, arg);
#line 118
    break;
    case 35: 
#line 119
    n_bytes += arg_size;
#line 119
    tmp___29 = (*get_arg)();
#line 119
    arg = (int )tmp___29;
#line 119
    if (arg) {
#line 119
      tio.c_iflag |= 128U;
    } else {
#line 119
      tio.c_iflag &= 4294967167U;
    }
#line 119
    debug3("tty_parse_modes: %d %d", 35, arg);
#line 119
    break;
    case 36: 
#line 120
    n_bytes += arg_size;
#line 120
    tmp___30 = (*get_arg)();
#line 120
    arg = (int )tmp___30;
#line 120
    if (arg) {
#line 120
      tio.c_iflag |= 256U;
    } else {
#line 120
      tio.c_iflag &= 4294967039U;
    }
#line 120
    debug3("tty_parse_modes: %d %d", 36, arg);
#line 120
    break;
    case 37: 
#line 122
    n_bytes += arg_size;
#line 122
    tmp___31 = (*get_arg)();
#line 122
    arg = (int )tmp___31;
#line 122
    if (arg) {
#line 122
      tio.c_iflag |= 512U;
    } else {
#line 122
      tio.c_iflag &= 4294966783U;
    }
#line 122
    debug3("tty_parse_modes: %d %d", 37, arg);
#line 122
    break;
    case 38: 
#line 124
    n_bytes += arg_size;
#line 124
    tmp___32 = (*get_arg)();
#line 124
    arg = (int )tmp___32;
#line 124
    if (arg) {
#line 124
      tio.c_iflag |= 1024U;
    } else {
#line 124
      tio.c_iflag &= 4294966271U;
    }
#line 124
    debug3("tty_parse_modes: %d %d", 38, arg);
#line 124
    break;
    case 39: 
#line 125
    n_bytes += arg_size;
#line 125
    tmp___33 = (*get_arg)();
#line 125
    arg = (int )tmp___33;
#line 125
    if (arg) {
#line 125
      tio.c_iflag |= 2048U;
    } else {
#line 125
      tio.c_iflag &= 4294965247U;
    }
#line 125
    debug3("tty_parse_modes: %d %d", 39, arg);
#line 125
    break;
    case 40: 
#line 126
    n_bytes += arg_size;
#line 126
    tmp___34 = (*get_arg)();
#line 126
    arg = (int )tmp___34;
#line 126
    if (arg) {
#line 126
      tio.c_iflag |= 4096U;
    } else {
#line 126
      tio.c_iflag &= 4294963199U;
    }
#line 126
    debug3("tty_parse_modes: %d %d", 40, arg);
#line 126
    break;
    case 41: 
#line 128
    n_bytes += arg_size;
#line 128
    tmp___35 = (*get_arg)();
#line 128
    arg = (int )tmp___35;
#line 128
    if (arg) {
#line 128
      tio.c_iflag |= 8192U;
    } else {
#line 128
      tio.c_iflag &= 4294959103U;
    }
#line 128
    debug3("tty_parse_modes: %d %d", 41, arg);
#line 128
    break;
    case 50: 
#line 131
    n_bytes += arg_size;
#line 131
    tmp___36 = (*get_arg)();
#line 131
    arg = (int )tmp___36;
#line 131
    if (arg) {
#line 131
      tio.c_lflag |= 1U;
    } else {
#line 131
      tio.c_lflag &= 4294967294U;
    }
#line 131
    debug3("tty_parse_modes: %d %d", 50, arg);
#line 131
    break;
    case 51: 
#line 132
    n_bytes += arg_size;
#line 132
    tmp___37 = (*get_arg)();
#line 132
    arg = (int )tmp___37;
#line 132
    if (arg) {
#line 132
      tio.c_lflag |= 2U;
    } else {
#line 132
      tio.c_lflag &= 4294967293U;
    }
#line 132
    debug3("tty_parse_modes: %d %d", 51, arg);
#line 132
    break;
    case 52: 
#line 134
    n_bytes += arg_size;
#line 134
    tmp___38 = (*get_arg)();
#line 134
    arg = (int )tmp___38;
#line 134
    if (arg) {
#line 134
      tio.c_lflag |= 4U;
    } else {
#line 134
      tio.c_lflag &= 4294967291U;
    }
#line 134
    debug3("tty_parse_modes: %d %d", 52, arg);
#line 134
    break;
    case 53: 
#line 136
    n_bytes += arg_size;
#line 136
    tmp___39 = (*get_arg)();
#line 136
    arg = (int )tmp___39;
#line 136
    if (arg) {
#line 136
      tio.c_lflag |= 8U;
    } else {
#line 136
      tio.c_lflag &= 4294967287U;
    }
#line 136
    debug3("tty_parse_modes: %d %d", 53, arg);
#line 136
    break;
    case 54: 
#line 137
    n_bytes += arg_size;
#line 137
    tmp___40 = (*get_arg)();
#line 137
    arg = (int )tmp___40;
#line 137
    if (arg) {
#line 137
      tio.c_lflag |= 16U;
    } else {
#line 137
      tio.c_lflag &= 4294967279U;
    }
#line 137
    debug3("tty_parse_modes: %d %d", 54, arg);
#line 137
    break;
    case 55: 
#line 138
    n_bytes += arg_size;
#line 138
    tmp___41 = (*get_arg)();
#line 138
    arg = (int )tmp___41;
#line 138
    if (arg) {
#line 138
      tio.c_lflag |= 32U;
    } else {
#line 138
      tio.c_lflag &= 4294967263U;
    }
#line 138
    debug3("tty_parse_modes: %d %d", 55, arg);
#line 138
    break;
    case 56: 
#line 139
    n_bytes += arg_size;
#line 139
    tmp___42 = (*get_arg)();
#line 139
    arg = (int )tmp___42;
#line 139
    if (arg) {
#line 139
      tio.c_lflag |= 64U;
    } else {
#line 139
      tio.c_lflag &= 4294967231U;
    }
#line 139
    debug3("tty_parse_modes: %d %d", 56, arg);
#line 139
    break;
    case 57: 
#line 140
    n_bytes += arg_size;
#line 140
    tmp___43 = (*get_arg)();
#line 140
    arg = (int )tmp___43;
#line 140
    if (arg) {
#line 140
      tio.c_lflag |= 128U;
    } else {
#line 140
      tio.c_lflag &= 4294967167U;
    }
#line 140
    debug3("tty_parse_modes: %d %d", 57, arg);
#line 140
    break;
    case 58: 
#line 141
    n_bytes += arg_size;
#line 141
    tmp___44 = (*get_arg)();
#line 141
    arg = (int )tmp___44;
#line 141
    if (arg) {
#line 141
      tio.c_lflag |= 256U;
    } else {
#line 141
      tio.c_lflag &= 4294967039U;
    }
#line 141
    debug3("tty_parse_modes: %d %d", 58, arg);
#line 141
    break;
    case 59: 
#line 143
    n_bytes += arg_size;
#line 143
    tmp___45 = (*get_arg)();
#line 143
    arg = (int )tmp___45;
#line 143
    if (arg) {
#line 143
      tio.c_lflag |= 32768U;
    } else {
#line 143
      tio.c_lflag &= 4294934527U;
    }
#line 143
    debug3("tty_parse_modes: %d %d", 59, arg);
#line 143
    break;
    case 60: 
#line 146
    n_bytes += arg_size;
#line 146
    tmp___46 = (*get_arg)();
#line 146
    arg = (int )tmp___46;
#line 146
    if (arg) {
#line 146
      tio.c_lflag |= 512U;
    } else {
#line 146
      tio.c_lflag &= 4294966783U;
    }
#line 146
    debug3("tty_parse_modes: %d %d", 60, arg);
#line 146
    break;
    case 61: 
#line 149
    n_bytes += arg_size;
#line 149
    tmp___47 = (*get_arg)();
#line 149
    arg = (int )tmp___47;
#line 149
    if (arg) {
#line 149
      tio.c_lflag |= 2048U;
    } else {
#line 149
      tio.c_lflag &= 4294965247U;
    }
#line 149
    debug3("tty_parse_modes: %d %d", 61, arg);
#line 149
    break;
    case 62: 
#line 152
    n_bytes += arg_size;
#line 152
    tmp___48 = (*get_arg)();
#line 152
    arg = (int )tmp___48;
#line 152
    if (arg) {
#line 152
      tio.c_lflag |= 16384U;
    } else {
#line 152
      tio.c_lflag &= 4294950911U;
    }
#line 152
    debug3("tty_parse_modes: %d %d", 62, arg);
#line 152
    break;
    case 70: 
#line 155
    n_bytes += arg_size;
#line 155
    tmp___49 = (*get_arg)();
#line 155
    arg = (int )tmp___49;
#line 155
    if (arg) {
#line 155
      tio.c_oflag |= 1U;
    } else {
#line 155
      tio.c_oflag &= 4294967294U;
    }
#line 155
    debug3("tty_parse_modes: %d %d", 70, arg);
#line 155
    break;
    case 71: 
#line 157
    n_bytes += arg_size;
#line 157
    tmp___50 = (*get_arg)();
#line 157
    arg = (int )tmp___50;
#line 157
    if (arg) {
#line 157
      tio.c_oflag |= 2U;
    } else {
#line 157
      tio.c_oflag &= 4294967293U;
    }
#line 157
    debug3("tty_parse_modes: %d %d", 71, arg);
#line 157
    break;
    case 72: 
#line 160
    n_bytes += arg_size;
#line 160
    tmp___51 = (*get_arg)();
#line 160
    arg = (int )tmp___51;
#line 160
    if (arg) {
#line 160
      tio.c_oflag |= 4U;
    } else {
#line 160
      tio.c_oflag &= 4294967291U;
    }
#line 160
    debug3("tty_parse_modes: %d %d", 72, arg);
#line 160
    break;
    case 73: 
#line 163
    n_bytes += arg_size;
#line 163
    tmp___52 = (*get_arg)();
#line 163
    arg = (int )tmp___52;
#line 163
    if (arg) {
#line 163
      tio.c_oflag |= 8U;
    } else {
#line 163
      tio.c_oflag &= 4294967287U;
    }
#line 163
    debug3("tty_parse_modes: %d %d", 73, arg);
#line 163
    break;
    case 74: 
#line 166
    n_bytes += arg_size;
#line 166
    tmp___53 = (*get_arg)();
#line 166
    arg = (int )tmp___53;
#line 166
    if (arg) {
#line 166
      tio.c_oflag |= 16U;
    } else {
#line 166
      tio.c_oflag &= 4294967279U;
    }
#line 166
    debug3("tty_parse_modes: %d %d", 74, arg);
#line 166
    break;
    case 75: 
#line 169
    n_bytes += arg_size;
#line 169
    tmp___54 = (*get_arg)();
#line 169
    arg = (int )tmp___54;
#line 169
    if (arg) {
#line 169
      tio.c_oflag |= 32U;
    } else {
#line 169
      tio.c_oflag &= 4294967263U;
    }
#line 169
    debug3("tty_parse_modes: %d %d", 75, arg);
#line 169
    break;
    case 90: 
#line 172
    n_bytes += arg_size;
#line 172
    tmp___55 = (*get_arg)();
#line 172
    arg = (int )tmp___55;
#line 172
    if (arg) {
#line 172
      tio.c_cflag |= 32U;
    } else {
#line 172
      tio.c_cflag &= 4294967263U;
    }
#line 172
    debug3("tty_parse_modes: %d %d", 90, arg);
#line 172
    break;
    case 91: 
#line 173
    n_bytes += arg_size;
#line 173
    tmp___56 = (*get_arg)();
#line 173
    arg = (int )tmp___56;
#line 173
    if (arg) {
#line 173
      tio.c_cflag |= 48U;
    } else {
#line 173
      tio.c_cflag &= 4294967247U;
    }
#line 173
    debug3("tty_parse_modes: %d %d", 91, arg);
#line 173
    break;
    case 92: 
#line 174
    n_bytes += arg_size;
#line 174
    tmp___57 = (*get_arg)();
#line 174
    arg = (int )tmp___57;
#line 174
    if (arg) {
#line 174
      tio.c_cflag |= 256U;
    } else {
#line 174
      tio.c_cflag &= 4294967039U;
    }
#line 174
    debug3("tty_parse_modes: %d %d", 92, arg);
#line 174
    break;
    case 93: 
#line 175
    n_bytes += arg_size;
#line 175
    tmp___58 = (*get_arg)();
#line 175
    arg = (int )tmp___58;
#line 175
    if (arg) {
#line 175
      tio.c_cflag |= 512U;
    } else {
#line 175
      tio.c_cflag &= 4294966783U;
    }
#line 175
    debug3("tty_parse_modes: %d %d", 93, arg);
#line 175
    break;
    default: 
#line 431 "ttymodes.c"
    debug("Ignoring unsupported tty mode opcode %d (0x%x)", opcode, opcode);
#line 433
    if (! compat20) {
#line 441
      if (opcode > 0) {
#line 441
        if (opcode < 128) {
#line 442
          n_bytes ++;
#line 443
          packet_get_char();
#line 444
          break;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 445
        if (opcode >= 128) {
#line 445
          if (opcode < 160) {
#line 446
            n_bytes += 4;
#line 447
            packet_get_int();
#line 448
            break;
          } else {
#line 457
            logit("parse_tty_modes: unknown opcode %d", opcode);
            goto set;
          }
        } else {
#line 457
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      }
    } else {
#line 469
      if (opcode > 0) {
#line 469
        if (opcode < 160) {
#line 470
          n_bytes += 4;
#line 471
          packet_get_int();
#line 472
          break;
        } else {
#line 474
          logit("parse_tty_modes: unknown opcode %d", opcode);
          goto set;
        }
      } else {
#line 474
        logit("parse_tty_modes: unknown opcode %d", opcode);
        goto set;
      }
    }
    }
  }
  set: 
#line 483
  if (*n_bytes_ptr != n_bytes) {
#line 484
    *n_bytes_ptr = n_bytes;
#line 485
    logit("parse_tty_modes: n_bytes_ptr != n_bytes: %d %d", *n_bytes_ptr, n_bytes);
#line 487
    return;
  }
#line 489
  if (failure == -1) {
#line 490
    return;
  }
#line 493
  tmp___61 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
#line 493
  if (tmp___61 == -1) {
#line 494
    tmp___59 = __errno_location();
#line 494
    tmp___60 = strerror(*tmp___59);
#line 494
    logit("Setting tty modes failed: %.100s", tmp___60);
  }
#line 495
  return;
}
}
#line 1 "xmalloc.o"
#line 370 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 24 "xmalloc.h"
int ( /* format attribute */  xasprintf)(char **ret___0 , char const   *fmt  , ...)  __attribute__((__nonnull__(2))) ;
#line 27 "xmalloc.c"
void *xmalloc(size_t size ) 
{ void *ptr ;

  {
#line 32
  if (size == 0U) {
#line 33
    fatal("xmalloc: zero size");
  }
#line 34
  ptr = malloc(size);
#line 35
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 36
    fatal("xmalloc: out of memory (allocating %lu bytes)", (unsigned long )size);
  }
#line 37
  return (ptr);
}
}
#line 40 "xmalloc.c"
void *xcalloc(size_t nmemb , size_t size ) 
{ void *ptr ;

  {
#line 45
  if (size == 0U) {
#line 46
    fatal("xcalloc: zero size");
  } else {
#line 45
    if (nmemb == 0U) {
#line 46
      fatal("xcalloc: zero size");
    }
  }
#line 47
  if (4294967295UL / (unsigned long )nmemb < (unsigned long )size) {
#line 48
    fatal("xcalloc: nmemb * size > SIZE_T_MAX");
  }
#line 49
  ptr = calloc(nmemb, size);
#line 50
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 51
    fatal("xcalloc: out of memory (allocating %lu bytes)", (unsigned long )(size * nmemb));
  }
#line 53
  return (ptr);
}
}
#line 56 "xmalloc.c"
void *xrealloc(void *ptr , size_t nmemb , size_t size ) 
{ void *new_ptr ;
  size_t new_size ;

  {
#line 60
  new_size = nmemb * size;
#line 62
  if (new_size == 0U) {
#line 63
    fatal("xrealloc: zero size");
  }
#line 64
  if (4294967295UL / (unsigned long )nmemb < (unsigned long )size) {
#line 65
    fatal("xrealloc: nmemb * size > SIZE_T_MAX");
  }
#line 66
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 67
    new_ptr = malloc(new_size);
  } else {
#line 69
    new_ptr = realloc(ptr, new_size);
  }
#line 70
  if ((unsigned int )new_ptr == (unsigned int )((void *)0)) {
#line 71
    fatal("xrealloc: out of memory (new_size %lu bytes)", (unsigned long )new_size);
  }
#line 73
  return (new_ptr);
}
}
#line 76 "xmalloc.c"
void xfree(void *ptr ) 
{ 

  {
#line 79
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 80
    fatal("xfree: NULL pointer given as argument");
  }
#line 81
  free(ptr);
#line 82
  return;
}
}
#line 84 "xmalloc.c"
char *xstrdup(char const   *str ) 
{ size_t len ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 90
  tmp = strlen(str);
#line 90
  len = tmp + 1U;
#line 91
  tmp___0 = xmalloc(len);
#line 91
  cp = (char *)tmp___0;
#line 92
  strlcpy(cp, str, len);
#line 93
  return (cp);
}
}
#line 96
int ( /* format attribute */  xasprintf)(char **ret___0 , char const   *fmt  , ...)  __attribute__((__nonnull__(2))) ;
#line 96 "xmalloc.c"
int ( /* format attribute */  xasprintf)(char **ret___0 , char const   *fmt  , ...) 
{ va_list ap ;
  int i ;

  {
#line 102
  __builtin_va_start(ap, fmt);
#line 103
  i = vasprintf((char ** __restrict  )ret___0, (char const   * __restrict  )fmt, ap);
#line 104
  __builtin_va_end(ap);
#line 106
  if (i < 0) {
#line 107
    fatal("xasprintf: could not allocate memory");
  } else {
#line 106
    if ((unsigned int )*ret___0 == (unsigned int )((void *)0)) {
#line 107
      fatal("xasprintf: could not allocate memory");
    }
  }
#line 109
  return (i);
}
}
#line 1 "atomicio.o"
#line 40 "/usr/include/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 58 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 42 "atomicio.h"
size_t atomiciov(ssize_t (*f)(int  , struct iovec  const  * , int  ) , int fd , struct iovec  const  *_iov ,
                 int iovcnt ) ;
#line 50 "atomicio.c"
size_t atomicio(ssize_t (*f)(int  , void * , size_t  ) , int fd , void *_s , size_t n___0 ) 
{ char *s ;
  size_t pos ;
  ssize_t res ;
  struct pollfd pfd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 53
  s = (char *)_s;
#line 54
  pos = (size_t )0;
#line 58
  pfd.fd = fd;
#line 59
  if ((unsigned int )f == (unsigned int )(& read)) {
#line 59
    pfd.events = (short)1;
  } else {
#line 59
    pfd.events = (short)4;
  }
#line 60
  while (n___0 > pos) {
#line 61
    res = (*f)(fd, (void *)(s + pos), n___0 - pos);
#line 62
    switch (res) {
    case -1: 
#line 64
    tmp = __errno_location();
#line 64
    if (*tmp == 4) {
#line 65
      continue;
    }
#line 67
    tmp___0 = __errno_location();
#line 67
    if (*tmp___0 == 11) {
#line 71
      poll(& pfd, 1UL, -1);
#line 72
      continue;
    } else {
#line 67
      tmp___1 = __errno_location();
#line 67
      if (*tmp___1 == 11) {
#line 71
        poll(& pfd, 1UL, -1);
#line 72
        continue;
      }
    }
#line 74
    return (0U);
    case 0: 
#line 76
    tmp___2 = __errno_location();
#line 76
    *tmp___2 = 32;
#line 77
    return (pos);
    default: 
#line 79
    pos += (unsigned int )res;
    }
  }
#line 82
  return (pos);
}
}
#line 88 "atomicio.c"
size_t atomiciov(ssize_t (*f)(int  , struct iovec  const  * , int  ) , int fd , struct iovec  const  *_iov ,
                 int iovcnt ) 
{ size_t pos ;
  size_t rem ;
  ssize_t res ;
  struct iovec iov_array[1024] ;
  struct iovec *iov ;
  struct pollfd pfd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 92
  pos = (size_t )0;
#line 94
  iov = iov_array;
#line 97
  if (iovcnt > 1024) {
#line 98
    tmp = __errno_location();
#line 98
    *tmp = 22;
#line 99
    return (0U);
  }
#line 102
  memcpy((void * __restrict  )iov, (void const   * __restrict  )_iov, (unsigned int )iovcnt * sizeof(*_iov));
#line 104
  pfd.fd = fd;
#line 105
  if ((unsigned int )f == (unsigned int )(& readv)) {
#line 105
    pfd.events = (short)1;
  } else {
#line 105
    pfd.events = (short)4;
  }
#line 106
  while (1) {
#line 106
    if (iovcnt > 0) {
#line 106
      if (! ((iov + 0)->iov_len > 0U)) {
#line 106
        break;
      }
    } else {
#line 106
      break;
    }
#line 107
    res = (*f)(fd, (struct iovec  const  *)iov, iovcnt);
#line 108
    switch (res) {
    case -1: 
#line 110
    tmp___0 = __errno_location();
#line 110
    if (*tmp___0 == 4) {
      goto __Cont;
    }
#line 113
    tmp___1 = __errno_location();
#line 113
    if (*tmp___1 == 11) {
#line 117
      poll(& pfd, 1UL, -1);
      goto __Cont;
    } else {
#line 113
      tmp___2 = __errno_location();
#line 113
      if (*tmp___2 == 11) {
#line 117
        poll(& pfd, 1UL, -1);
        goto __Cont;
      }
    }
#line 120
    return (0U);
    case 0: 
#line 122
    tmp___3 = __errno_location();
#line 122
    *tmp___3 = 32;
#line 123
    return (pos);
    default: 
#line 125
    rem = (unsigned int )res;
#line 126
    pos += rem;
#line 128
    while (1) {
#line 128
      if (iovcnt > 0) {
#line 128
        if (! (rem >= (iov + 0)->iov_len)) {
#line 128
          break;
        }
      } else {
#line 128
        break;
      }
#line 129
      rem -= (iov + 0)->iov_len;
#line 130
      iov ++;
#line 131
      iovcnt --;
    }
#line 134
    if (rem > 0U) {
#line 134
      if (iovcnt <= 0) {
#line 135
        tmp___4 = __errno_location();
#line 135
        *tmp___4 = 14;
#line 136
        return (0U);
      } else {
#line 134
        if (rem > (iov + 0)->iov_len) {
#line 135
          tmp___4 = __errno_location();
#line 135
          *tmp___4 = 14;
#line 136
          return (0U);
        }
      }
    }
#line 138
    if (iovcnt == 0) {
#line 139
      break;
    }
#line 141
    (iov + 0)->iov_base = (void *)((char *)(iov + 0)->iov_base + rem);
#line 142
    (iov + 0)->iov_len -= rem;
    }
    __Cont: /* CIL Label */ ;
  }
#line 145
  return (pos);
}
}
#line 1 "key.o"
#line 457 "/usr/include/openssl/bn.h"
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 491
extern BIGNUM *BN_dup(BIGNUM const   *a ) ;
#line 496
extern char *BN_bn2dec(BIGNUM const   *a ) ;
#line 498
extern int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 470 "/usr/include/openssl/crypto.h"
extern void CRYPTO_free(void * ) ;
#line 491 "/usr/include/openssl/evp.h"
extern int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 498
extern int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD const   *type ) ;
#line 499
extern int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 593
extern EVP_MD const   *EVP_md5(void) ;
#line 215 "/usr/include/openssl/rsa.h"
extern RSA *RSA_new(void) ;
#line 221
extern RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  ,
                                                                           int  ,
                                                                           void * ) ,
                             void *cb_arg ) ;
#line 238
extern void RSA_free(RSA *r ) ;
#line 190 "/usr/include/openssl/dsa.h"
extern DSA *DSA_new(void) ;
#line 192
extern void DSA_free(DSA *r ) ;
#line 213
extern DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len ,
                                    int *counter_ret , unsigned long *h_ret , void (*callback)(int  ,
                                                                                               int  ,
                                                                                               void * ) ,
                                    void *cb_arg ) ;
#line 224
extern int DSA_generate_key(DSA *a ) ;
#line 61 "key.h"
Key *key_demote(Key const   *k ) ;
#line 63
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) ;
#line 64
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) ;
#line 70
Key *key_generate(int type , u_int bits ) ;
#line 71
Key *key_from_private(Key const   *k ) ;
#line 72
int key_type_from_name(char *name ) ;
#line 77
int key_names_valid2(char const   *names ) ;
#line 79
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) ;
#line 80
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) ;
#line 82
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 83
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 84
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) ;
#line 85
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) ;
#line 27 "uuencode.h"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) ;
#line 28
int uudecode(char const   *src , u_char *target , size_t targsize ) ;
#line 54 "key.c"
Key *key_new(int type ) 
{ Key *k ;
  RSA *rsa ;
  DSA *dsa ;
  void *tmp ;

  {
#line 60
  tmp = xcalloc(1U, sizeof(*k));
#line 60
  k = (Key *)tmp;
#line 61
  k->type = type;
#line 62
  k->dsa = (DSA *)((void *)0);
#line 63
  k->rsa = (RSA *)((void *)0);
#line 64
  switch (k->type) {
  case 0: 
  case 1: 
#line 67
  rsa = RSA_new();
#line 67
  if ((unsigned int )rsa == (unsigned int )((void *)0)) {
#line 68
    fatal("key_new: RSA_new failed");
  }
#line 69
  rsa->n = BN_new();
#line 69
  if ((unsigned int )rsa->n == (unsigned int )((void *)0)) {
#line 70
    fatal("key_new: BN_new failed");
  }
#line 71
  rsa->e = BN_new();
#line 71
  if ((unsigned int )rsa->e == (unsigned int )((void *)0)) {
#line 72
    fatal("key_new: BN_new failed");
  }
#line 73
  k->rsa = rsa;
#line 74
  break;
  case 2: 
#line 76
  dsa = DSA_new();
#line 76
  if ((unsigned int )dsa == (unsigned int )((void *)0)) {
#line 77
    fatal("key_new: DSA_new failed");
  }
#line 78
  dsa->p = BN_new();
#line 78
  if ((unsigned int )dsa->p == (unsigned int )((void *)0)) {
#line 79
    fatal("key_new: BN_new failed");
  }
#line 80
  dsa->q = BN_new();
#line 80
  if ((unsigned int )dsa->q == (unsigned int )((void *)0)) {
#line 81
    fatal("key_new: BN_new failed");
  }
#line 82
  dsa->g = BN_new();
#line 82
  if ((unsigned int )dsa->g == (unsigned int )((void *)0)) {
#line 83
    fatal("key_new: BN_new failed");
  }
#line 84
  dsa->pub_key = BN_new();
#line 84
  if ((unsigned int )dsa->pub_key == (unsigned int )((void *)0)) {
#line 85
    fatal("key_new: BN_new failed");
  }
#line 86
  k->dsa = dsa;
#line 87
  break;
  case 3: 
#line 89
  break;
  default: 
#line 91
  fatal("key_new: bad key type %d", k->type);
#line 92
  break;
  }
#line 94
  return (k);
}
}
#line 97 "key.c"
Key *key_new_private(int type ) 
{ Key *k ;
  Key *tmp ;

  {
#line 100
  tmp = key_new(type);
#line 100
  k = tmp;
#line 101
  switch (k->type) {
  case 0: 
  case 1: 
#line 104
  (k->rsa)->d = BN_new();
#line 104
  if ((unsigned int )(k->rsa)->d == (unsigned int )((void *)0)) {
#line 105
    fatal("key_new_private: BN_new failed");
  }
#line 106
  (k->rsa)->iqmp = BN_new();
#line 106
  if ((unsigned int )(k->rsa)->iqmp == (unsigned int )((void *)0)) {
#line 107
    fatal("key_new_private: BN_new failed");
  }
#line 108
  (k->rsa)->q = BN_new();
#line 108
  if ((unsigned int )(k->rsa)->q == (unsigned int )((void *)0)) {
#line 109
    fatal("key_new_private: BN_new failed");
  }
#line 110
  (k->rsa)->p = BN_new();
#line 110
  if ((unsigned int )(k->rsa)->p == (unsigned int )((void *)0)) {
#line 111
    fatal("key_new_private: BN_new failed");
  }
#line 112
  (k->rsa)->dmq1 = BN_new();
#line 112
  if ((unsigned int )(k->rsa)->dmq1 == (unsigned int )((void *)0)) {
#line 113
    fatal("key_new_private: BN_new failed");
  }
#line 114
  (k->rsa)->dmp1 = BN_new();
#line 114
  if ((unsigned int )(k->rsa)->dmp1 == (unsigned int )((void *)0)) {
#line 115
    fatal("key_new_private: BN_new failed");
  }
#line 116
  break;
  case 2: 
#line 118
  (k->dsa)->priv_key = BN_new();
#line 118
  if ((unsigned int )(k->dsa)->priv_key == (unsigned int )((void *)0)) {
#line 119
    fatal("key_new_private: BN_new failed");
  }
#line 120
  break;
  case 3: 
#line 122
  break;
  default: ;
#line 124
  break;
  }
#line 126
  return (k);
}
}
#line 129 "key.c"
void key_free(Key *k ) 
{ 

  {
#line 132
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 133
    fatal("key_free: key is NULL");
  }
#line 134
  switch (k->type) {
  case 0: 
  case 1: 
#line 137
  if ((unsigned int )k->rsa != (unsigned int )((void *)0)) {
#line 138
    RSA_free(k->rsa);
  }
#line 139
  k->rsa = (RSA *)((void *)0);
#line 140
  break;
  case 2: 
#line 142
  if ((unsigned int )k->dsa != (unsigned int )((void *)0)) {
#line 143
    DSA_free(k->dsa);
  }
#line 144
  k->dsa = (DSA *)((void *)0);
#line 145
  break;
  case 3: 
#line 147
  break;
  default: 
#line 149
  fatal("key_free: bad key type %d", k->type);
#line 150
  break;
  }
#line 152
  xfree((void *)k);
#line 153
  return;
}
}
#line 155 "key.c"
int key_equal(Key const   *a___0 , Key const   *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 158
  if ((unsigned int )a___0 == (unsigned int )((void *)0)) {
#line 159
    return (0);
  } else {
#line 158
    if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 159
      return (0);
    } else {
#line 158
      if (a___0->type != b->type) {
#line 159
        return (0);
      }
    }
  }
#line 160
  switch ((int )a___0->type) {
  case 0: 
  case 1: 
#line 163
  if ((unsigned int )a___0->rsa != (unsigned int )((void *)0)) {
#line 163
    if ((unsigned int )b->rsa != (unsigned int )((void *)0)) {
#line 163
      tmp = BN_cmp((BIGNUM const   *)(a___0->rsa)->e, (BIGNUM const   *)(b->rsa)->e);
#line 163
      if (tmp == 0) {
#line 163
        tmp___0 = BN_cmp((BIGNUM const   *)(a___0->rsa)->n, (BIGNUM const   *)(b->rsa)->n);
#line 163
        if (tmp___0 == 0) {
#line 163
          tmp___1 = 1;
        } else {
#line 163
          tmp___1 = 0;
        }
      } else {
#line 163
        tmp___1 = 0;
      }
    } else {
#line 163
      tmp___1 = 0;
    }
  } else {
#line 163
    tmp___1 = 0;
  }
#line 163
  return (tmp___1);
  case 2: 
#line 167
  if ((unsigned int )a___0->dsa != (unsigned int )((void *)0)) {
#line 167
    if ((unsigned int )b->dsa != (unsigned int )((void *)0)) {
#line 167
      tmp___2 = BN_cmp((BIGNUM const   *)(a___0->dsa)->p, (BIGNUM const   *)(b->dsa)->p);
#line 167
      if (tmp___2 == 0) {
#line 167
        tmp___3 = BN_cmp((BIGNUM const   *)(a___0->dsa)->q, (BIGNUM const   *)(b->dsa)->q);
#line 167
        if (tmp___3 == 0) {
#line 167
          tmp___4 = BN_cmp((BIGNUM const   *)(a___0->dsa)->g, (BIGNUM const   *)(b->dsa)->g);
#line 167
          if (tmp___4 == 0) {
#line 167
            tmp___5 = BN_cmp((BIGNUM const   *)(a___0->dsa)->pub_key, (BIGNUM const   *)(b->dsa)->pub_key);
#line 167
            if (tmp___5 == 0) {
#line 167
              tmp___6 = 1;
            } else {
#line 167
              tmp___6 = 0;
            }
          } else {
#line 167
            tmp___6 = 0;
          }
        } else {
#line 167
          tmp___6 = 0;
        }
      } else {
#line 167
        tmp___6 = 0;
      }
    } else {
#line 167
      tmp___6 = 0;
    }
  } else {
#line 167
    tmp___6 = 0;
  }
#line 167
  return (tmp___6);
  default: 
#line 173
  fatal("key_equal: bad key type %d", a___0->type);
  }
}
}
#line 177 "key.c"
u_char *key_fingerprint_raw(Key const   *k , enum fp_type dgst_type , u_int *dgst_raw_length ) 
{ EVP_MD const   *md ;
  EVP_MD_CTX ctx ;
  u_char *blob ;
  u_char *retval ;
  u_int len ;
  int nlen ;
  int elen ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 181
  md = (EVP_MD const   *)((void *)0);
#line 183
  blob = (u_char *)((void *)0);
#line 184
  retval = (u_char *)((void *)0);
#line 185
  len = (u_int )0;
#line 188
  *dgst_raw_length = 0U;
#line 190
  switch ((int )dgst_type) {
  case 1: 
#line 192
  md = EVP_md5();
#line 193
  break;
  case 0: 
#line 195
  md = EVP_sha1();
#line 196
  break;
  default: 
#line 198
  fatal("key_fingerprint_raw: bad digest type %d", dgst_type);
  }
#line 201
  switch ((int )k->type) {
  case 0: 
#line 203
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 203
  nlen = (tmp + 7) / 8;
#line 204
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->rsa)->e);
#line 204
  elen = (tmp___0 + 7) / 8;
#line 205
  len = (unsigned int )(nlen + elen);
#line 206
  tmp___1 = xmalloc(len);
#line 206
  blob = (u_char *)tmp___1;
#line 207
  BN_bn2bin((BIGNUM const   *)(k->rsa)->n, blob);
#line 208
  BN_bn2bin((BIGNUM const   *)(k->rsa)->e, blob + nlen);
#line 209
  break;
  case 2: 
  case 1: 
#line 212
  key_to_blob(k, & blob, & len);
#line 213
  break;
  case 3: 
#line 215
  return (retval);
  default: 
#line 217
  fatal("key_fingerprint_raw: bad key type %d", k->type);
#line 218
  break;
  }
#line 220
  if ((unsigned int )blob != (unsigned int )((void *)0)) {
#line 221
    tmp___2 = xmalloc(64U);
#line 221
    retval = (u_char *)tmp___2;
#line 222
    EVP_DigestInit(& ctx, md);
#line 223
    EVP_DigestUpdate(& ctx, (void const   *)blob, len);
#line 224
    EVP_DigestFinal(& ctx, retval, dgst_raw_length);
#line 225
    memset((void *)blob, 0, len);
#line 226
    xfree((void *)blob);
  } else {
#line 228
    fatal("key_fingerprint_raw: blob is null");
  }
#line 230
  return (retval);
}
}
#line 233 "key.c"
static char *key_fingerprint_hex(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char *retval ;
  u_int i ;
  void *tmp ;
  char hex[4] ;

  {
#line 239
  tmp = xcalloc(1U, dgst_raw_len * 3U + 1U);
#line 239
  retval = (char *)tmp;
#line 240
  i = 0U;
#line 240
  while (i < dgst_raw_len) {
#line 242
    snprintf((char * __restrict  )(hex), sizeof(hex), (char const   * __restrict  )"%02x:",
             *(dgst_raw + i));
#line 243
    strlcat(retval, (char const   *)(hex), dgst_raw_len * 3U + 1U);
#line 240
    i ++;
  }
#line 247
  *(retval + (dgst_raw_len * 3U - 1U)) = (char )'\000';
#line 248
  return (retval);
}
}
#line 251 "key.c"
static char *key_fingerprint_bubblebabble(u_char *dgst_raw , u_int dgst_raw_len ) 
{ char vowels[6] ;
  char consonants[17] ;
  u_int i ;
  u_int j ;
  u_int rounds ;
  u_int seed ;
  char *retval ;
  void *tmp ;
  u_int tmp___0 ;
  u_int idx0 ;
  u_int idx1 ;
  u_int idx2 ;
  u_int idx3 ;
  u_int idx4 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  u_int tmp___11 ;

  {
#line 254
  vowels[0] = (char )'a';
#line 254
  vowels[1] = (char )'e';
#line 254
  vowels[2] = (char )'i';
#line 254
  vowels[3] = (char )'o';
#line 254
  vowels[4] = (char )'u';
#line 254
  vowels[5] = (char )'y';
#line 255
  consonants[0] = (char )'b';
#line 255
  consonants[1] = (char )'c';
#line 255
  consonants[2] = (char )'d';
#line 255
  consonants[3] = (char )'f';
#line 255
  consonants[4] = (char )'g';
#line 255
  consonants[5] = (char )'h';
#line 255
  consonants[6] = (char )'k';
#line 255
  consonants[7] = (char )'l';
#line 255
  consonants[8] = (char )'m';
#line 255
  consonants[9] = (char )'n';
#line 255
  consonants[10] = (char )'p';
#line 255
  consonants[11] = (char )'r';
#line 255
  consonants[12] = (char )'s';
#line 255
  consonants[13] = (char )'t';
#line 255
  consonants[14] = (char )'v';
#line 255
  consonants[15] = (char )'z';
#line 255
  consonants[16] = (char )'x';
#line 257
  j = (u_int )0;
#line 257
  seed = (u_int )1;
#line 260
  rounds = dgst_raw_len / 2U + 1U;
#line 261
  tmp = xcalloc(rounds * 6U, sizeof(char ));
#line 261
  retval = (char *)tmp;
#line 262
  tmp___0 = j;
#line 262
  j ++;
#line 262
  *(retval + tmp___0) = (char )'x';
#line 263
  i = 0U;
#line 263
  while (i < rounds) {
#line 265
    if (i + 1U < rounds) {
      goto _L;
    } else {
#line 265
      if (dgst_raw_len % 2U != 0U) {
        _L: /* CIL Label */ 
#line 266
        idx0 = ((((unsigned int )*(dgst_raw + 2U * i) >> 6) & 3U) + seed) % 6U;
#line 268
        idx1 = ((unsigned int )*(dgst_raw + 2U * i) >> 2) & 15U;
#line 269
        idx2 = (((unsigned int )*(dgst_raw + 2U * i) & 3U) + seed / 6U) % 6U;
#line 271
        tmp___1 = j;
#line 271
        j ++;
#line 271
        *(retval + tmp___1) = vowels[idx0];
#line 272
        tmp___2 = j;
#line 272
        j ++;
#line 272
        *(retval + tmp___2) = consonants[idx1];
#line 273
        tmp___3 = j;
#line 273
        j ++;
#line 273
        *(retval + tmp___3) = vowels[idx2];
#line 274
        if (i + 1U < rounds) {
#line 275
          idx3 = ((unsigned int )*(dgst_raw + (2U * i + 1U)) >> 4) & 15U;
#line 276
          idx4 = (unsigned int )*(dgst_raw + (2U * i + 1U)) & 15U;
#line 277
          tmp___4 = j;
#line 277
          j ++;
#line 277
          *(retval + tmp___4) = consonants[idx3];
#line 278
          tmp___5 = j;
#line 278
          j ++;
#line 278
          *(retval + tmp___5) = (char )'-';
#line 279
          tmp___6 = j;
#line 279
          j ++;
#line 279
          *(retval + tmp___6) = consonants[idx4];
#line 280
          seed = (seed * 5U + ((unsigned int )*(dgst_raw + 2U * i) * 7U + (unsigned int )*(dgst_raw + (2U * i + 1U)))) % 36U;
        }
      } else {
#line 285
        idx0 = seed % 6U;
#line 286
        idx1 = 16U;
#line 287
        idx2 = seed / 6U;
#line 288
        tmp___7 = j;
#line 288
        j ++;
#line 288
        *(retval + tmp___7) = vowels[idx0];
#line 289
        tmp___8 = j;
#line 289
        j ++;
#line 289
        *(retval + tmp___8) = consonants[idx1];
#line 290
        tmp___9 = j;
#line 290
        j ++;
#line 290
        *(retval + tmp___9) = vowels[idx2];
      }
    }
#line 263
    i ++;
  }
#line 293
  tmp___10 = j;
#line 293
  j ++;
#line 293
  *(retval + tmp___10) = (char )'x';
#line 294
  tmp___11 = j;
#line 294
  j ++;
#line 294
  *(retval + tmp___11) = (char )'\000';
#line 295
  return (retval);
}
}
#line 298 "key.c"
char *key_fingerprint(Key const   *k , enum fp_type dgst_type , enum fp_rep dgst_rep ) 
{ char *retval ;
  u_char *dgst_raw ;
  u_int dgst_raw_len ;

  {
#line 301
  retval = (char *)((void *)0);
#line 305
  dgst_raw = key_fingerprint_raw(k, dgst_type, & dgst_raw_len);
#line 306
  if (! dgst_raw) {
#line 307
    fatal("key_fingerprint: null from key_fingerprint_raw()");
  }
#line 308
  switch ((int )dgst_rep) {
  case 0: 
#line 310
  retval = key_fingerprint_hex(dgst_raw, dgst_raw_len);
#line 311
  break;
  case 1: 
#line 313
  retval = key_fingerprint_bubblebabble(dgst_raw, dgst_raw_len);
#line 314
  break;
  default: 
#line 316
  fatal("key_fingerprint_ex: bad digest representation %d", dgst_rep);
#line 318
  break;
  }
#line 320
  memset((void *)dgst_raw, 0, dgst_raw_len);
#line 321
  xfree((void *)dgst_raw);
#line 322
  return (retval);
}
}
#line 332 "key.c"
static int read_bignum(char **cpp , BIGNUM *value ) 
{ char *cp ;
  int old ;
  int tmp ;

  {
#line 335
  cp = *cpp;
#line 339
  while (1) {
#line 339
    if (! ((int )*cp == 32)) {
#line 339
      if (! ((int )*cp == 9)) {
#line 339
        break;
      }
    }
#line 339
    cp ++;
  }
#line 343
  if ((int )*cp < 48) {
#line 344
    return (0);
  } else {
#line 343
    if ((int )*cp > 57) {
#line 344
      return (0);
    }
  }
#line 347
  *cpp = cp;
#line 350
  while (1) {
#line 350
    if ((int )*cp >= 48) {
#line 350
      if (! ((int )*cp <= 57)) {
#line 350
        break;
      }
    } else {
#line 350
      break;
    }
#line 350
    cp ++;
  }
#line 354
  old = (int )*cp;
#line 355
  *cp = (char)0;
#line 358
  tmp = BN_dec2bn(& value, (char const   *)*cpp);
#line 358
  if (tmp == 0) {
#line 359
    return (0);
  }
#line 362
  *cp = (char )old;
#line 365
  *cpp = cp;
#line 366
  return (1);
}
}
#line 369 "key.c"
static int write_bignum(FILE *f , BIGNUM *num ) 
{ char *buf___1 ;
  char *tmp ;

  {
#line 372
  tmp = BN_bn2dec((BIGNUM const   *)num);
#line 372
  buf___1 = tmp;
#line 373
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
#line 374
    error("write_bignum: BN_bn2dec() failed");
#line 375
    return (0);
  }
#line 377
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )" %s", buf___1);
#line 378
  CRYPTO_free((void *)buf___1);
#line 379
  return (1);
}
}
#line 383 "key.c"
int key_read(Key *ret___0 , char **cpp ) 
{ Key *k ;
  int success ;
  char *cp ;
  char *space ;
  int len ;
  int n___0 ;
  int type ;
  u_int bits ;
  u_char *blob ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 387
  success = -1;
#line 393
  cp = *cpp;
#line 395
  switch (ret___0->type) {
  case 0: 
#line 398
  if ((int )*cp < 48) {
#line 399
    return (-1);
  } else {
#line 398
    if ((int )*cp > 57) {
#line 399
      return (-1);
    }
  }
#line 400
  bits = 0U;
#line 400
  while (1) {
#line 400
    if ((int )*cp >= 48) {
#line 400
      if (! ((int )*cp <= 57)) {
#line 400
        break;
      }
    } else {
#line 400
      break;
    }
#line 401
    bits = (10U * bits + (u_int )*cp) - 48U;
#line 400
    cp ++;
  }
#line 402
  if (bits == 0U) {
#line 403
    return (-1);
  }
#line 404
  *cpp = cp;
#line 406
  tmp = read_bignum(cpp, (ret___0->rsa)->e);
#line 406
  if (! tmp) {
#line 407
    return (-1);
  }
#line 408
  tmp___0 = read_bignum(cpp, (ret___0->rsa)->n);
#line 408
  if (! tmp___0) {
#line 409
    return (-1);
  }
#line 410
  success = 1;
#line 411
  break;
  case 3: 
  case 1: 
  case 2: 
#line 415
  tmp___2 = __builtin_strchr(cp, ' ');
#line 415
  space = tmp___2;
#line 416
  if ((unsigned int )space == (unsigned int )((void *)0)) {
#line 417
    debug3("key_read: missing whitespace");
#line 418
    return (-1);
  }
#line 420
  *space = (char )'\000';
#line 421
  type = key_type_from_name(cp);
#line 422
  *space = (char )' ';
#line 423
  if (type == 3) {
#line 424
    debug3("key_read: missing keytype");
#line 425
    return (-1);
  }
#line 427
  cp = space + 1;
#line 428
  if ((int )*cp == 0) {
#line 429
    debug3("key_read: short string");
#line 430
    return (-1);
  }
#line 432
  if (ret___0->type == 3) {
#line 433
    ret___0->type = type;
  } else {
#line 434
    if (ret___0->type != type) {
#line 436
      debug3("key_read: type mismatch");
#line 437
      return (-1);
    }
  }
#line 439
  tmp___3 = strlen((char const   *)cp);
#line 439
  len = (int )(2U * tmp___3);
#line 440
  tmp___4 = xmalloc((unsigned int )len);
#line 440
  blob = (u_char *)tmp___4;
#line 441
  n___0 = uudecode((char const   *)cp, blob, (unsigned int )len);
#line 442
  if (n___0 < 0) {
#line 443
    error("key_read: uudecode %s failed", cp);
#line 444
    xfree((void *)blob);
#line 445
    return (-1);
  }
#line 447
  k = key_from_blob((u_char const   *)blob, (unsigned int )n___0);
#line 448
  xfree((void *)blob);
#line 449
  if ((unsigned int )k == (unsigned int )((void *)0)) {
#line 450
    error("key_read: key_from_blob %s failed", cp);
#line 451
    return (-1);
  }
#line 453
  if (k->type != type) {
#line 454
    error("key_read: type mismatch: encoding error");
#line 455
    key_free(k);
#line 456
    return (-1);
  }
#line 459
  if (ret___0->type == 1) {
#line 460
    if ((unsigned int )ret___0->rsa != (unsigned int )((void *)0)) {
#line 461
      RSA_free(ret___0->rsa);
    }
#line 462
    ret___0->rsa = k->rsa;
#line 463
    k->rsa = (RSA *)((void *)0);
#line 464
    success = 1;
  } else {
#line 469
    if ((unsigned int )ret___0->dsa != (unsigned int )((void *)0)) {
#line 470
      DSA_free(ret___0->dsa);
    }
#line 471
    ret___0->dsa = k->dsa;
#line 472
    k->dsa = (DSA *)((void *)0);
#line 473
    success = 1;
  }
#line 479
  key_free(k);
#line 480
  if (success != 1) {
#line 481
    break;
  }
#line 483
  while (1) {
#line 483
    if (! ((int )*cp == 32)) {
#line 483
      if (! ((int )*cp == 9)) {
#line 483
        break;
      }
    }
#line 484
    cp ++;
  }
#line 485
  while (1) {
#line 485
    if ((int )*cp != 0) {
#line 485
      if ((int )*cp != 32) {
#line 485
        if (! ((int )*cp != 9)) {
#line 485
          break;
        }
      } else {
#line 485
        break;
      }
    } else {
#line 485
      break;
    }
#line 486
    cp ++;
  }
#line 487
  *cpp = cp;
#line 488
  break;
  default: 
#line 490
  fatal("key_read: bad key type: %d", ret___0->type);
#line 491
  break;
  }
#line 493
  return (success);
}
}
#line 496 "key.c"
int key_write(Key const   *key , FILE *f ) 
{ int n___0 ;
  int success ;
  u_int len ;
  u_int bits ;
  u_char *blob ;
  char *uu ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 499
  success = 0;
#line 500
  bits = (u_int )0;
#line 504
  if (key->type == 0) {
#line 504
    if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
#line 506
      tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 506
      bits = (unsigned int )tmp;
#line 507
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%u", bits);
#line 508
      tmp___0 = write_bignum(f, (key->rsa)->e);
#line 508
      if (tmp___0) {
#line 508
        tmp___1 = write_bignum(f, (key->rsa)->n);
#line 508
        if (tmp___1) {
#line 510
          success = 1;
        } else {
#line 512
          error("key_write: failed for RSA key");
        }
      } else {
#line 512
        error("key_write: failed for RSA key");
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 514
    if (key->type == 2) {
#line 514
      if ((unsigned int )key->dsa != (unsigned int )((void *)0)) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 514
      if (key->type == 1) {
#line 514
        if ((unsigned int )key->rsa != (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
#line 516
          key_to_blob(key, & blob, & len);
#line 517
          tmp___2 = xmalloc(2U * len);
#line 517
          uu = (char *)tmp___2;
#line 518
          n___0 = uuencode((u_char const   *)blob, len, uu, 2U * len);
#line 519
          if (n___0 > 0) {
#line 520
            tmp___3 = key_ssh_name(key);
#line 520
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s",
                    tmp___3, uu);
#line 521
            success = 1;
          }
#line 523
          xfree((void *)blob);
#line 524
          xfree((void *)uu);
        }
      }
    }
  }
#line 526
  return (success);
}
}
#line 529 "key.c"
char const   *key_type(Key const   *k ) 
{ 

  {
#line 532
  switch ((int )k->type) {
  case 0: 
#line 534
  return ("RSA1");
  case 1: 
#line 536
  return ("RSA");
  case 2: 
#line 538
  return ("DSA");
  }
#line 540
  return ("unknown");
}
}
#line 543 "key.c"
char const   *key_ssh_name(Key const   *k ) 
{ 

  {
#line 546
  switch ((int )k->type) {
  case 1: 
#line 548
  return ("ssh-rsa");
  case 2: 
#line 550
  return ("ssh-dss");
  }
#line 552
  return ("ssh-unknown");
}
}
#line 555 "key.c"
u_int key_size(Key const   *k ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 558
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 561
  tmp = BN_num_bits((BIGNUM const   *)(k->rsa)->n);
#line 561
  return ((unsigned int )tmp);
  case 2: 
#line 563
  tmp___0 = BN_num_bits((BIGNUM const   *)(k->dsa)->p);
#line 563
  return ((unsigned int )tmp___0);
  }
#line 565
  return (0U);
}
}
#line 568 "key.c"
static RSA *rsa_generate_private_key(u_int bits ) 
{ RSA *private ;

  {
#line 573
  private = RSA_generate_key((int )bits, 35UL, (void (*)(int  , int  , void * ))((void *)0),
                             (void *)0);
#line 574
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 575
    fatal("rsa_generate_private_key: key generation failed.");
  }
#line 576
  return (private);
}
}
#line 579 "key.c"
static DSA *dsa_generate_private_key(u_int bits ) 
{ DSA *private ;
  DSA *tmp ;
  int tmp___0 ;

  {
#line 582
  tmp = DSA_generate_parameters((int )bits, (unsigned char *)((void *)0), 0, (int *)((void *)0),
                                (unsigned long *)((void *)0), (void (*)(int  , int  ,
                                                                        void * ))((void *)0),
                                (void *)0);
#line 582
  private = tmp;
#line 584
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 585
    fatal("dsa_generate_private_key: DSA_generate_parameters failed");
  }
#line 586
  tmp___0 = DSA_generate_key(private);
#line 586
  if (! tmp___0) {
#line 587
    fatal("dsa_generate_private_key: DSA_generate_key failed.");
  }
#line 588
  if ((unsigned int )private == (unsigned int )((void *)0)) {
#line 589
    fatal("dsa_generate_private_key: NULL.");
  }
#line 590
  return (private);
}
}
#line 593 "key.c"
Key *key_generate(int type , u_int bits ) 
{ Key *k ;
  Key *tmp ;

  {
#line 596
  tmp = key_new(3);
#line 596
  k = tmp;
#line 597
  switch (type) {
  case 2: 
#line 599
  k->dsa = dsa_generate_private_key(bits);
#line 600
  break;
  case 1: 
  case 0: 
#line 603
  k->rsa = rsa_generate_private_key(bits);
#line 604
  break;
  default: 
#line 606
  fatal("key_generate: unknown type %d", type);
  }
#line 608
  k->type = type;
#line 609
  return (k);
}
}
#line 612 "key.c"
Key *key_from_private(Key const   *k ) 
{ Key *n___0 ;
  BIGNUM *tmp ;
  BIGNUM *tmp___0 ;
  BIGNUM *tmp___1 ;
  BIGNUM *tmp___2 ;
  BIGNUM *tmp___3 ;
  BIGNUM *tmp___4 ;

  {
#line 615
  n___0 = (Key *)((void *)0);
#line 616
  switch ((int )k->type) {
  case 2: 
#line 618
  n___0 = key_new((int )k->type);
#line 619
  tmp = BN_copy((n___0->dsa)->p, (BIGNUM const   *)(k->dsa)->p);
#line 619
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 623
    fatal("key_from_private: BN_copy failed");
  } else {
#line 619
    tmp___0 = BN_copy((n___0->dsa)->q, (BIGNUM const   *)(k->dsa)->q);
#line 619
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 623
      fatal("key_from_private: BN_copy failed");
    } else {
#line 619
      tmp___1 = BN_copy((n___0->dsa)->g, (BIGNUM const   *)(k->dsa)->g);
#line 619
      if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 623
        fatal("key_from_private: BN_copy failed");
      } else {
#line 619
        tmp___2 = BN_copy((n___0->dsa)->pub_key, (BIGNUM const   *)(k->dsa)->pub_key);
#line 619
        if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 623
          fatal("key_from_private: BN_copy failed");
        }
      }
    }
  }
#line 624
  break;
  case 1: 
  case 0: 
#line 627
  n___0 = key_new((int )k->type);
#line 628
  tmp___3 = BN_copy((n___0->rsa)->n, (BIGNUM const   *)(k->rsa)->n);
#line 628
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 630
    fatal("key_from_private: BN_copy failed");
  } else {
#line 628
    tmp___4 = BN_copy((n___0->rsa)->e, (BIGNUM const   *)(k->rsa)->e);
#line 628
    if ((unsigned int )tmp___4 == (unsigned int )((void *)0)) {
#line 630
      fatal("key_from_private: BN_copy failed");
    }
  }
#line 631
  break;
  default: 
#line 633
  fatal("key_from_private: unknown type %d", k->type);
#line 634
  break;
  }
#line 636
  return (n___0);
}
}
#line 639 "key.c"
int key_type_from_name(char *name ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;

  {
#line 642
  if (0) {
#line 642
    __s1_len___3 = strlen((char const   *)name);
#line 642
    __s2_len___3 = strlen("rsa1");
#line 642
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___8;
    } else {
#line 642
      if (__s1_len___3 >= 4U) {
        _L___8: /* CIL Label */ 
#line 642
        if (! ((unsigned int )((void const   *)("rsa1" + 1)) - (unsigned int )((void const   *)"rsa1") == 1U)) {
#line 642
          tmp___48 = 1;
        } else {
#line 642
          if (__s2_len___3 >= 4U) {
#line 642
            tmp___48 = 1;
          } else {
#line 642
            tmp___48 = 0;
          }
        }
      } else {
#line 642
        tmp___48 = 0;
      }
    }
#line 642
    if (tmp___48) {
#line 642
      tmp___44 = __builtin_strcmp((char const   *)name, "rsa1");
    } else {
#line 642
      tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 642
      tmp___44 = tmp___47;
    }
  } else {
#line 642
    tmp___47 = __builtin_strcmp((char const   *)name, "rsa1");
#line 642
    tmp___44 = tmp___47;
  }
#line 642
  if (tmp___44 == 0) {
#line 643
    return (0);
  } else {
#line 644
    if (0) {
#line 644
      __s1_len___2 = strlen((char const   *)name);
#line 644
      __s2_len___2 = strlen("rsa");
#line 644
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___6;
      } else {
#line 644
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 644
          if (! ((unsigned int )((void const   *)("rsa" + 1)) - (unsigned int )((void const   *)"rsa") == 1U)) {
#line 644
            tmp___38 = 1;
          } else {
#line 644
            if (__s2_len___2 >= 4U) {
#line 644
              tmp___38 = 1;
            } else {
#line 644
              tmp___38 = 0;
            }
          }
        } else {
#line 644
          tmp___38 = 0;
        }
      }
#line 644
      if (tmp___38) {
#line 644
        tmp___34 = __builtin_strcmp((char const   *)name, "rsa");
      } else {
#line 644
        tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 644
        tmp___34 = tmp___37;
      }
    } else {
#line 644
      tmp___37 = __builtin_strcmp((char const   *)name, "rsa");
#line 644
      tmp___34 = tmp___37;
    }
#line 644
    if (tmp___34 == 0) {
#line 645
      return (1);
    } else {
#line 646
      if (0) {
#line 646
        __s1_len___1 = strlen((char const   *)name);
#line 646
        __s2_len___1 = strlen("dsa");
#line 646
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___4;
        } else {
#line 646
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 646
            if (! ((unsigned int )((void const   *)("dsa" + 1)) - (unsigned int )((void const   *)"dsa") == 1U)) {
#line 646
              tmp___28 = 1;
            } else {
#line 646
              if (__s2_len___1 >= 4U) {
#line 646
                tmp___28 = 1;
              } else {
#line 646
                tmp___28 = 0;
              }
            }
          } else {
#line 646
            tmp___28 = 0;
          }
        }
#line 646
        if (tmp___28) {
#line 646
          tmp___24 = __builtin_strcmp((char const   *)name, "dsa");
        } else {
#line 646
          tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 646
          tmp___24 = tmp___27;
        }
      } else {
#line 646
        tmp___27 = __builtin_strcmp((char const   *)name, "dsa");
#line 646
        tmp___24 = tmp___27;
      }
#line 646
      if (tmp___24 == 0) {
#line 647
        return (2);
      } else {
#line 648
        if (0) {
#line 648
          __s1_len___0 = strlen((char const   *)name);
#line 648
          __s2_len___0 = strlen("ssh-rsa");
#line 648
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___2;
          } else {
#line 648
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 648
              if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
#line 648
                tmp___18 = 1;
              } else {
#line 648
                if (__s2_len___0 >= 4U) {
#line 648
                  tmp___18 = 1;
                } else {
#line 648
                  tmp___18 = 0;
                }
              }
            } else {
#line 648
              tmp___18 = 0;
            }
          }
#line 648
          if (tmp___18) {
#line 648
            tmp___14 = __builtin_strcmp((char const   *)name, "ssh-rsa");
          } else {
#line 648
            tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 648
            tmp___14 = tmp___17;
          }
        } else {
#line 648
          tmp___17 = __builtin_strcmp((char const   *)name, "ssh-rsa");
#line 648
          tmp___14 = tmp___17;
        }
#line 648
        if (tmp___14 == 0) {
#line 649
          return (1);
        } else {
#line 650
          if (0) {
#line 650
            __s1_len = strlen((char const   *)name);
#line 650
            __s2_len = strlen("ssh-dss");
#line 650
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 650
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 650
                if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
#line 650
                  tmp___8 = 1;
                } else {
#line 650
                  if (__s2_len >= 4U) {
#line 650
                    tmp___8 = 1;
                  } else {
#line 650
                    tmp___8 = 0;
                  }
                }
              } else {
#line 650
                tmp___8 = 0;
              }
            }
#line 650
            if (tmp___8) {
#line 650
              tmp___4 = __builtin_strcmp((char const   *)name, "ssh-dss");
            } else {
#line 650
              tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 650
              tmp___4 = tmp___7;
            }
          } else {
#line 650
            tmp___7 = __builtin_strcmp((char const   *)name, "ssh-dss");
#line 650
            tmp___4 = tmp___7;
          }
#line 650
          if (tmp___4 == 0) {
#line 651
            return (2);
          }
        }
      }
    }
  }
#line 653
  debug2("key_type_from_name: unknown key type \'%s\'", name);
#line 654
  return (3);
}
}
#line 657 "key.c"
int key_names_valid2(char const   *names ) 
{ char *s ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 662
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 663
    return (0);
  } else {
#line 662
    if (0) {
#line 662
      __s1_len = strlen(names);
#line 662
      __s2_len = strlen("");
#line 662
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 662
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 662
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 662
            tmp___8 = 1;
          } else {
#line 662
            if (__s2_len >= 4U) {
#line 662
              tmp___8 = 1;
            } else {
#line 662
              tmp___8 = 0;
            }
          }
        } else {
#line 662
          tmp___8 = 0;
        }
      }
#line 662
      if (tmp___8) {
#line 662
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 662
        tmp___7 = __builtin_strcmp(names, "");
#line 662
        tmp___4 = tmp___7;
      }
    } else {
#line 662
      tmp___7 = __builtin_strcmp(names, "");
#line 662
      tmp___4 = tmp___7;
    }
#line 662
    if (tmp___4 == 0) {
#line 663
      return (0);
    }
  }
#line 664
  cp = xstrdup(names);
#line 664
  s = cp;
#line 665
  tmp___24 = __strsep_g(& cp, ",");
#line 665
  p = tmp___24;
#line 665
  while (1) {
#line 665
    if (p) {
#line 665
      if (! ((int )*p != 0)) {
#line 665
        break;
      }
    } else {
#line 665
      break;
    }
#line 667
    tmp___41 = key_type_from_name(p);
#line 667
    switch (tmp___41) {
    case 0: 
    case 3: 
#line 670
    xfree((void *)s);
#line 671
    return (0);
    }
#line 666
    tmp___40 = __strsep_g(& cp, ",");
#line 666
    p = tmp___40;
  }
#line 674
  debug3("key names ok: [%s]", names);
#line 675
  xfree((void *)s);
#line 676
  return (1);
}
}
#line 679 "key.c"
Key *key_from_blob(u_char const   *blob , u_int blen ) 
{ Buffer b ;
  int rlen ;
  int type ;
  char *ktype ;
  Key *key ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;

  {
#line 684
  ktype = (char *)((void *)0);
#line 685
  key = (Key *)((void *)0);
#line 690
  buffer_init(& b);
#line 691
  buffer_append(& b, (void const   *)blob, blen);
#line 692
  tmp = buffer_get_string_ret(& b, (u_int *)((void *)0));
#line 692
  ktype = (char *)tmp;
#line 692
  if ((unsigned int )ktype == (unsigned int )((void *)0)) {
#line 693
    error("key_from_blob: can\'t read key type");
    goto out;
  }
#line 697
  type = key_type_from_name(ktype);
#line 699
  switch (type) {
  case 1: 
#line 701
  key = key_new(type);
#line 702
  tmp___0 = buffer_get_bignum2_ret(& b, (key->rsa)->e);
#line 702
  if (tmp___0 == -1) {
#line 704
    error("key_from_blob: can\'t read rsa key");
#line 705
    key_free(key);
#line 706
    key = (Key *)((void *)0);
    goto out;
  } else {
#line 702
    tmp___1 = buffer_get_bignum2_ret(& b, (key->rsa)->n);
#line 702
    if (tmp___1 == -1) {
#line 704
      error("key_from_blob: can\'t read rsa key");
#line 705
      key_free(key);
#line 706
      key = (Key *)((void *)0);
      goto out;
    }
  }
#line 712
  break;
  case 2: 
#line 714
  key = key_new(type);
#line 715
  tmp___2 = buffer_get_bignum2_ret(& b, (key->dsa)->p);
#line 715
  if (tmp___2 == -1) {
#line 719
    error("key_from_blob: can\'t read dsa key");
#line 720
    key_free(key);
#line 721
    key = (Key *)((void *)0);
    goto out;
  } else {
#line 715
    tmp___3 = buffer_get_bignum2_ret(& b, (key->dsa)->q);
#line 715
    if (tmp___3 == -1) {
#line 719
      error("key_from_blob: can\'t read dsa key");
#line 720
      key_free(key);
#line 721
      key = (Key *)((void *)0);
      goto out;
    } else {
#line 715
      tmp___4 = buffer_get_bignum2_ret(& b, (key->dsa)->g);
#line 715
      if (tmp___4 == -1) {
#line 719
        error("key_from_blob: can\'t read dsa key");
#line 720
        key_free(key);
#line 721
        key = (Key *)((void *)0);
        goto out;
      } else {
#line 715
        tmp___5 = buffer_get_bignum2_ret(& b, (key->dsa)->pub_key);
#line 715
        if (tmp___5 == -1) {
#line 719
          error("key_from_blob: can\'t read dsa key");
#line 720
          key_free(key);
#line 721
          key = (Key *)((void *)0);
          goto out;
        }
      }
    }
  }
#line 727
  break;
  case 3: 
#line 729
  key = key_new(type);
#line 730
  break;
  default: 
#line 732
  error("key_from_blob: cannot handle type %s", ktype);
  goto out;
  }
#line 735
  tmp___6 = buffer_len(& b);
#line 735
  rlen = (int )tmp___6;
#line 736
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 736
    if (rlen != 0) {
#line 737
      error("key_from_blob: remaining bytes in key blob %d", rlen);
    }
  }
  out: 
#line 739
  if ((unsigned int )ktype != (unsigned int )((void *)0)) {
#line 740
    xfree((void *)ktype);
  }
#line 741
  buffer_free(& b);
#line 742
  return (key);
}
}
#line 745 "key.c"
int key_to_blob(Key const   *key , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 751
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 752
    error("key_to_blob: key == NULL");
#line 753
    return (0);
  }
#line 755
  buffer_init(& b);
#line 756
  switch ((int )key->type) {
  case 2: 
#line 758
  tmp = key_ssh_name(key);
#line 758
  buffer_put_cstring(& b, tmp);
#line 759
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->p);
#line 760
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->q);
#line 761
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->g);
#line 762
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->dsa)->pub_key);
#line 763
  break;
  case 1: 
#line 765
  tmp___0 = key_ssh_name(key);
#line 765
  buffer_put_cstring(& b, tmp___0);
#line 766
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->e);
#line 767
  buffer_put_bignum2(& b, (BIGNUM const   *)(key->rsa)->n);
#line 768
  break;
  default: 
#line 770
  error("key_to_blob: unsupported key type %d", key->type);
#line 771
  buffer_free(& b);
#line 772
  return (0);
  }
#line 774
  tmp___1 = buffer_len(& b);
#line 774
  len = (int )tmp___1;
#line 775
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 776
    *lenp = (unsigned int )len;
  }
#line 777
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 778
    tmp___2 = xmalloc((unsigned int )len);
#line 778
    *blobp = (u_char *)tmp___2;
#line 779
    tmp___3 = buffer_ptr(& b);
#line 779
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___3, (unsigned int )len);
  }
#line 781
  tmp___4 = buffer_ptr(& b);
#line 781
  memset(tmp___4, 0, (unsigned int )len);
#line 782
  buffer_free(& b);
#line 783
  return (len);
}
}
#line 786 "key.c"
int key_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
             u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 792
  switch ((int )key->type) {
  case 2: 
#line 794
  tmp = ssh_dss_sign(key, sigp, lenp, data, datalen);
#line 794
  return (tmp);
  case 1: 
#line 796
  tmp___0 = ssh_rsa_sign(key, sigp, lenp, data, datalen);
#line 796
  return (tmp___0);
  default: 
#line 798
  error("key_sign: invalid key type %d", key->type);
#line 799
  return (-1);
  }
}
}
#line 807 "key.c"
int key_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
               u_char const   *data , u_int datalen ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 813
  if (signaturelen == 0U) {
#line 814
    return (-1);
  }
#line 816
  switch ((int )key->type) {
  case 2: 
#line 818
  tmp = ssh_dss_verify(key, signature, signaturelen, data, datalen);
#line 818
  return (tmp);
  case 1: 
#line 820
  tmp___0 = ssh_rsa_verify(key, signature, signaturelen, data, datalen);
#line 820
  return (tmp___0);
  default: 
#line 822
  error("key_verify: invalid key type %d", key->type);
#line 823
  return (-1);
  }
}
}
#line 828 "key.c"
Key *key_demote(Key const   *k ) 
{ Key *pk ;
  void *tmp ;

  {
#line 833
  tmp = xcalloc(1U, sizeof(*pk));
#line 833
  pk = (Key *)tmp;
#line 834
  pk->type = (int )k->type;
#line 835
  pk->flags = (int )k->flags;
#line 836
  pk->dsa = (DSA *)((void *)0);
#line 837
  pk->rsa = (RSA *)((void *)0);
#line 839
  switch ((int )k->type) {
  case 0: 
  case 1: 
#line 842
  pk->rsa = RSA_new();
#line 842
  if ((unsigned int )pk->rsa == (unsigned int )((void *)0)) {
#line 843
    fatal("key_demote: RSA_new failed");
  }
#line 844
  (pk->rsa)->e = BN_dup((BIGNUM const   *)(k->rsa)->e);
#line 844
  if ((unsigned int )(pk->rsa)->e == (unsigned int )((void *)0)) {
#line 845
    fatal("key_demote: BN_dup failed");
  }
#line 846
  (pk->rsa)->n = BN_dup((BIGNUM const   *)(k->rsa)->n);
#line 846
  if ((unsigned int )(pk->rsa)->n == (unsigned int )((void *)0)) {
#line 847
    fatal("key_demote: BN_dup failed");
  }
#line 848
  break;
  case 2: 
#line 850
  pk->dsa = DSA_new();
#line 850
  if ((unsigned int )pk->dsa == (unsigned int )((void *)0)) {
#line 851
    fatal("key_demote: DSA_new failed");
  }
#line 852
  (pk->dsa)->p = BN_dup((BIGNUM const   *)(k->dsa)->p);
#line 852
  if ((unsigned int )(pk->dsa)->p == (unsigned int )((void *)0)) {
#line 853
    fatal("key_demote: BN_dup failed");
  }
#line 854
  (pk->dsa)->q = BN_dup((BIGNUM const   *)(k->dsa)->q);
#line 854
  if ((unsigned int )(pk->dsa)->q == (unsigned int )((void *)0)) {
#line 855
    fatal("key_demote: BN_dup failed");
  }
#line 856
  (pk->dsa)->g = BN_dup((BIGNUM const   *)(k->dsa)->g);
#line 856
  if ((unsigned int )(pk->dsa)->g == (unsigned int )((void *)0)) {
#line 857
    fatal("key_demote: BN_dup failed");
  }
#line 858
  (pk->dsa)->pub_key = BN_dup((BIGNUM const   *)(k->dsa)->pub_key);
#line 858
  if ((unsigned int )(pk->dsa)->pub_key == (unsigned int )((void *)0)) {
#line 859
    fatal("key_demote: BN_dup failed");
  }
#line 860
  break;
  default: 
#line 862
  fatal("key_free: bad key type %d", k->type);
#line 863
  break;
  }
#line 866
  return (pk);
}
}
#line 1 "dispatch.o"
#line 36 "dispatch.h"
void dispatch_init(dispatch_fn *dflt ) ;
#line 37
void dispatch_set(int type , dispatch_fn *fn ) ;
#line 38
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) ;
#line 39
void dispatch_run(int mode , sig_atomic_t volatile   *done , void *ctxt ) ;
#line 40
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) ;
#line 41
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) ;
#line 43 "dispatch.c"
dispatch_fn *dispatch[255]  ;
#line 45 "dispatch.c"
void dispatch_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 48
  logit("dispatch_protocol_error: type %d seq %u", type, seq);
#line 49
  if (! compat20) {
#line 50
    fatal("protocol error");
  }
#line 51
  packet_start((unsigned char)3);
#line 52
  packet_put_int(seq);
#line 53
  packet_send();
#line 54
  packet_write_wait();
#line 55
  return;
}
}
#line 56 "dispatch.c"
void dispatch_protocol_ignore(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 59
  logit("dispatch_protocol_ignore: type %d seq %u", type, seq);
#line 60
  return;
}
}
#line 61 "dispatch.c"
void dispatch_init(dispatch_fn *dflt ) 
{ u_int i ;

  {
#line 65
  i = 0U;
#line 65
  while (i < 255U) {
#line 66
    dispatch[i] = dflt;
#line 65
    i ++;
  }
#line 67
  return;
}
}
#line 68 "dispatch.c"
void dispatch_range(u_int from , u_int to , dispatch_fn *fn ) 
{ u_int i ;

  {
#line 73
  i = from;
#line 73
  while (i <= to) {
#line 74
    if (i >= 255U) {
#line 75
      break;
    }
#line 76
    dispatch[i] = fn;
#line 73
    i ++;
  }
#line 78
  return;
}
}
#line 79 "dispatch.c"
void dispatch_set(int type , dispatch_fn *fn ) 
{ 

  {
#line 82
  dispatch[type] = fn;
#line 83
  return;
}
}
#line 84 "dispatch.c"
void dispatch_run(int mode , sig_atomic_t volatile   *done , void *ctxt ) 
{ int type ;
  u_int32_t seqnr ;

  {
#line 87
  while (1) {
#line 91
    if (mode == 0) {
#line 92
      type = packet_read_seqnr(& seqnr);
    } else {
#line 94
      type = packet_read_poll_seqnr(& seqnr);
#line 95
      if (type == 0) {
#line 96
        return;
      }
    }
#line 98
    if (type > 0) {
#line 98
      if (type < 255) {
#line 98
        if ((unsigned int )dispatch[type] != (unsigned int )((void *)0)) {
#line 99
          (*(dispatch[type]))(type, seqnr, ctxt);
        } else {
#line 101
          packet_disconnect("protocol error: rcvd type %d", type);
        }
      } else {
#line 101
        packet_disconnect("protocol error: rcvd type %d", type);
      }
    } else {
#line 101
      packet_disconnect("protocol error: rcvd type %d", type);
    }
#line 102
    if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 102
      if (*done) {
#line 103
        return;
      }
    }
  }
}
}
#line 1 "kex.o"
#line 604 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_sha256(void) ;
#line 130 "kex.h"
Kex *kex_setup(char **proposal ) ;
#line 131
void kex_finish(Kex *kex ) ;
#line 133
void kex_send_kexinit(Kex *kex ) ;
#line 134
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) ;
#line 135
void kex_derive_keys(Kex *kex , u_char *hash , u_int hashlen , BIGNUM *shared_secret ) ;
#line 152
void derive_ssh1_session_id(BIGNUM *host_modulus , BIGNUM *server_modulus , u_int8_t *cookie ,
                            u_int8_t *id ) ;
#line 27 "mac.h"
int mac_setup(Mac *mac , char *name ) ;
#line 63 "kex.c"
static void kex_kexinit_finish(Kex *kex ) ;
#line 64
static void kex_choose_conf(Kex *kex ) ;
#line 67 "kex.c"
static void kex_prop2buf(Buffer *b , char **proposal ) 
{ u_int i ;

  {
#line 72
  buffer_clear(b);
#line 77
  i = 0U;
#line 77
  while (i < 16U) {
#line 78
    buffer_put_char(b, 0);
#line 77
    i ++;
  }
#line 79
  i = 0U;
#line 79
  while (i < 10U) {
#line 80
    buffer_put_cstring(b, (char const   *)*(proposal + i));
#line 79
    i ++;
  }
#line 81
  buffer_put_char(b, 0);
#line 82
  buffer_put_int(b, 0U);
#line 83
  return;
}
}
#line 86 "kex.c"
static char **kex_buf2prop(Buffer *raw , int *first_kex_follows ) 
{ Buffer b ;
  u_int i ;
  char **proposal ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 93
  tmp = xcalloc(10U, sizeof(char *));
#line 93
  proposal = (char **)tmp;
#line 95
  buffer_init(& b);
#line 96
  tmp___0 = buffer_len(raw);
#line 96
  tmp___1 = buffer_ptr(raw);
#line 96
  buffer_append(& b, (void const   *)tmp___1, tmp___0);
#line 98
  i = 0U;
#line 98
  while (i < 16U) {
#line 99
    buffer_get_char(& b);
#line 98
    i ++;
  }
#line 101
  i = 0U;
#line 101
  while (i < 10U) {
#line 102
    tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 102
    *(proposal + i) = (char *)tmp___2;
#line 103
    debug2("kex_parse_kexinit: %s", *(proposal + i));
#line 101
    i ++;
  }
#line 106
  tmp___3 = buffer_get_char(& b);
#line 106
  i = (unsigned int )tmp___3;
#line 107
  if ((unsigned int )first_kex_follows != (unsigned int )((void *)0)) {
#line 108
    *first_kex_follows = (int )i;
  }
#line 109
  debug2("kex_parse_kexinit: first_kex_follows %d ", i);
#line 110
  i = buffer_get_int(& b);
#line 111
  debug2("kex_parse_kexinit: reserved %u ", i);
#line 112
  buffer_free(& b);
#line 113
  return (proposal);
}
}
#line 116 "kex.c"
static void kex_prop_free(char **proposal ) 
{ u_int i ;

  {
#line 121
  i = 0U;
#line 121
  while (i < 10U) {
#line 122
    xfree((void *)*(proposal + i));
#line 121
    i ++;
  }
#line 123
  xfree((void *)proposal);
#line 124
  return;
}
}
#line 127 "kex.c"
static void kex_protocol_error(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 130
  error("Hm, kex protocol error: type %d seq %u", type, seq);
#line 131
  return;
}
}
#line 133 "kex.c"
static void kex_reset_dispatch(void) 
{ 

  {
#line 136
  dispatch_range(1U, 49U, & kex_protocol_error);
#line 138
  dispatch_set(20, & kex_input_kexinit);
#line 139
  return;
}
}
#line 141 "kex.c"
void kex_finish(Kex *kex ) 
{ int _len ;
  int tmp ;

  {
#line 144
  kex_reset_dispatch();
#line 146
  packet_start((unsigned char)21);
#line 147
  packet_send();
#line 149
  debug("SSH2_MSG_NEWKEYS sent");
#line 151
  debug("expecting SSH2_MSG_NEWKEYS");
#line 152
  packet_read_expect(21);
#line 153
  while (1) {
#line 153
    tmp = packet_remaining();
#line 153
    _len = tmp;
#line 153
    if (_len > 0) {
#line 153
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            153);
#line 153
      packet_disconnect("Packet integrity error.");
    }
#line 153
    break;
  }
#line 154
  debug("SSH2_MSG_NEWKEYS received");
#line 156
  kex->done = 1;
#line 157
  buffer_clear(& kex->peer);
#line 159
  kex->flags &= -2;
#line 160
  xfree((void *)kex->name);
#line 161
  kex->name = (char *)((void *)0);
#line 162
  return;
}
}
#line 164 "kex.c"
void kex_send_kexinit(Kex *kex ) 
{ u_int32_t rnd ;
  u_char *cookie ;
  u_int i ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 167
  rnd = (u_int32_t )0;
#line 171
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 172
    error("kex_send_kexinit: no kex, cannot rekey");
#line 173
    return;
  }
#line 175
  if (kex->flags & 1) {
#line 176
    debug("KEX_INIT_SENT");
#line 177
    return;
  }
#line 179
  kex->done = 0;
#line 182
  tmp = buffer_len(& kex->my);
#line 182
  if (tmp < 16U) {
#line 183
    fatal("kex_send_kexinit: kex proposal too short");
  }
#line 184
  tmp___0 = buffer_ptr(& kex->my);
#line 184
  cookie = (u_char *)tmp___0;
#line 185
  i = 0U;
#line 185
  while (i < 16U) {
#line 186
    if (i % 4U == 0U) {
#line 187
      rnd = arc4random();
    }
#line 188
    *(cookie + i) = (unsigned char )rnd;
#line 189
    rnd >>= 8;
#line 185
    i ++;
  }
#line 191
  packet_start((unsigned char)20);
#line 192
  tmp___1 = buffer_len(& kex->my);
#line 192
  tmp___2 = buffer_ptr(& kex->my);
#line 192
  packet_put_raw((void const   *)tmp___2, tmp___1);
#line 193
  packet_send();
#line 194
  debug("SSH2_MSG_KEXINIT sent");
#line 195
  kex->flags |= 1;
#line 196
  return;
}
}
#line 199 "kex.c"
void kex_input_kexinit(int type , u_int32_t seq , void *ctxt ) 
{ char *ptr ;
  u_int i ;
  u_int dlen ;
  Kex *kex ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 204
  kex = (Kex *)ctxt;
#line 206
  debug("SSH2_MSG_KEXINIT received");
#line 207
  if ((unsigned int )kex == (unsigned int )((void *)0)) {
#line 208
    fatal("kex_input_kexinit: no kex, cannot rekey");
  }
#line 210
  tmp = packet_get_raw(& dlen);
#line 210
  ptr = (char *)tmp;
#line 211
  buffer_append(& kex->peer, (void const   *)ptr, dlen);
#line 214
  i = 0U;
#line 214
  while (i < 16U) {
#line 215
    packet_get_char();
#line 214
    i ++;
  }
#line 216
  i = 0U;
#line 216
  while (i < 10U) {
#line 217
    tmp___0 = packet_get_string((u_int *)((void *)0));
#line 217
    xfree(tmp___0);
#line 216
    i ++;
  }
#line 218
  packet_get_char();
#line 219
  packet_get_int();
#line 220
  while (1) {
#line 220
    tmp___1 = packet_remaining();
#line 220
    _len = tmp___1;
#line 220
    if (_len > 0) {
#line 220
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kex.c",
            220);
#line 220
      packet_disconnect("Packet integrity error.");
    }
#line 220
    break;
  }
#line 222
  kex_kexinit_finish(kex);
#line 223
  return;
}
}
#line 225 "kex.c"
Kex *kex_setup(char **proposal ) 
{ Kex *kex ;
  void *tmp ;

  {
#line 230
  tmp = xcalloc(1U, sizeof(*kex));
#line 230
  kex = (Kex *)tmp;
#line 231
  buffer_init(& kex->peer);
#line 232
  buffer_init(& kex->my);
#line 233
  kex_prop2buf(& kex->my, proposal);
#line 234
  kex->done = 0;
#line 236
  kex_send_kexinit(kex);
#line 237
  kex_reset_dispatch();
#line 239
  return (kex);
}
}
#line 242 "kex.c"
static void kex_kexinit_finish(Kex *kex ) 
{ 

  {
#line 245
  if (! (kex->flags & 1)) {
#line 246
    kex_send_kexinit(kex);
  }
#line 248
  kex_choose_conf(kex);
#line 250
  if (kex->kex_type >= 0) {
#line 250
    if (kex->kex_type < 4) {
#line 250
      if ((unsigned int )kex->kex[kex->kex_type] != (unsigned int )((void *)0)) {
#line 252
        (*(kex->kex[kex->kex_type]))(kex);
      } else {
#line 254
        fatal("Unsupported key exchange %d", kex->kex_type);
      }
    } else {
#line 254
      fatal("Unsupported key exchange %d", kex->kex_type);
    }
  } else {
#line 254
    fatal("Unsupported key exchange %d", kex->kex_type);
  }
#line 256
  return;
}
}
#line 258 "kex.c"
static void choose_enc(Enc *enc , char *client , char *server ) 
{ char *name ;
  char *tmp ;

  {
#line 261
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 261
  name = tmp;
#line 262
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 263
    fatal("no matching cipher found: client %s server %s", client, server);
  }
#line 265
  enc->cipher = cipher_by_name((char const   *)name);
#line 265
  if ((unsigned int )enc->cipher == (unsigned int )((void *)0)) {
#line 266
    fatal("matching cipher is not supported: %s", name);
  }
#line 267
  enc->name = name;
#line 268
  enc->enabled = 0;
#line 269
  enc->iv = (u_char *)((void *)0);
#line 270
  enc->key = (u_char *)((void *)0);
#line 271
  enc->key_len = cipher_keylen((Cipher const   *)enc->cipher);
#line 272
  enc->block_size = cipher_blocksize((Cipher const   *)enc->cipher);
#line 273
  return;
}
}
#line 275 "kex.c"
static void choose_mac(Mac *mac , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  int tmp___0 ;

  {
#line 278
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 278
  name = tmp;
#line 279
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 280
    fatal("no matching mac found: client %s server %s", client, server);
  }
#line 282
  tmp___0 = mac_setup(mac, name);
#line 282
  if (tmp___0 < 0) {
#line 283
    fatal("unsupported mac %s", name);
  }
#line 285
  if (datafellows & 4) {
#line 286
    mac->key_len = 16U;
  }
#line 287
  mac->name = name;
#line 288
  mac->key = (u_char *)((void *)0);
#line 289
  mac->enabled = 0;
#line 290
  return;
}
}
#line 292 "kex.c"
static void choose_comp(Comp *comp , char *client , char *server ) 
{ char *name ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 295
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 295
  name = tmp;
#line 296
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 297
    fatal("no matching comp found: client %s server %s", client, server);
  }
#line 298
  if (0) {
#line 298
    __s1_len___1 = strlen((char const   *)name);
#line 298
    __s2_len___1 = strlen("zlib@openssh.com");
#line 298
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___4;
    } else {
#line 298
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 298
        if (! ((unsigned int )((void const   *)("zlib@openssh.com" + 1)) - (unsigned int )((void const   *)"zlib@openssh.com") == 1U)) {
#line 298
          tmp___29 = 1;
        } else {
#line 298
          if (__s2_len___1 >= 4U) {
#line 298
            tmp___29 = 1;
          } else {
#line 298
            tmp___29 = 0;
          }
        }
      } else {
#line 298
        tmp___29 = 0;
      }
    }
#line 298
    if (tmp___29) {
#line 298
      tmp___25 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
    } else {
#line 298
      tmp___28 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
#line 298
      tmp___25 = tmp___28;
    }
  } else {
#line 298
    tmp___28 = __builtin_strcmp((char const   *)name, "zlib@openssh.com");
#line 298
    tmp___25 = tmp___28;
  }
#line 298
  if (tmp___25 == 0) {
#line 299
    comp->type = 2;
  } else {
#line 300
    if (0) {
#line 300
      __s1_len___0 = strlen((char const   *)name);
#line 300
      __s2_len___0 = strlen("zlib");
#line 300
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___2;
      } else {
#line 300
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 300
          if (! ((unsigned int )((void const   *)("zlib" + 1)) - (unsigned int )((void const   *)"zlib") == 1U)) {
#line 300
            tmp___19 = 1;
          } else {
#line 300
            if (__s2_len___0 >= 4U) {
#line 300
              tmp___19 = 1;
            } else {
#line 300
              tmp___19 = 0;
            }
          }
        } else {
#line 300
          tmp___19 = 0;
        }
      }
#line 300
      if (tmp___19) {
#line 300
        tmp___15 = __builtin_strcmp((char const   *)name, "zlib");
      } else {
#line 300
        tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 300
        tmp___15 = tmp___18;
      }
    } else {
#line 300
      tmp___18 = __builtin_strcmp((char const   *)name, "zlib");
#line 300
      tmp___15 = tmp___18;
    }
#line 300
    if (tmp___15 == 0) {
#line 301
      comp->type = 1;
    } else {
#line 302
      if (0) {
#line 302
        __s1_len = strlen((char const   *)name);
#line 302
        __s2_len = strlen("none");
#line 302
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___0;
        } else {
#line 302
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 302
            if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 302
              tmp___9 = 1;
            } else {
#line 302
              if (__s2_len >= 4U) {
#line 302
                tmp___9 = 1;
              } else {
#line 302
                tmp___9 = 0;
              }
            }
          } else {
#line 302
            tmp___9 = 0;
          }
        }
#line 302
        if (tmp___9) {
#line 302
          tmp___5 = __builtin_strcmp((char const   *)name, "none");
        } else {
#line 302
          tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 302
          tmp___5 = tmp___8;
        }
      } else {
#line 302
        tmp___8 = __builtin_strcmp((char const   *)name, "none");
#line 302
        tmp___5 = tmp___8;
      }
#line 302
      if (tmp___5 == 0) {
#line 303
        comp->type = 0;
      } else {
#line 305
        fatal("unsupported comp %s", name);
      }
    }
  }
#line 307
  comp->name = name;
#line 308
  return;
}
}
#line 310 "kex.c"
static void choose_kex(Kex *k , char *client , char *server ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 313
  k->name = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 314
  if ((unsigned int )k->name == (unsigned int )((void *)0)) {
#line 315
    fatal("Unable to negotiate a key exchange method");
  }
#line 316
  if (0) {
#line 316
    __s1_len___2 = strlen((char const   *)k->name);
#line 316
    __s2_len___2 = strlen("diffie-hellman-group1-sha1");
#line 316
    if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
      goto _L___6;
    } else {
#line 316
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 316
        if (! ((unsigned int )((void const   *)("diffie-hellman-group1-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group1-sha1") == 1U)) {
#line 316
          tmp___38 = 1;
        } else {
#line 316
          if (__s2_len___2 >= 4U) {
#line 316
            tmp___38 = 1;
          } else {
#line 316
            tmp___38 = 0;
          }
        }
      } else {
#line 316
        tmp___38 = 0;
      }
    }
#line 316
    if (tmp___38) {
#line 316
      tmp___34 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
    } else {
#line 316
      tmp___37 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 316
      tmp___34 = tmp___37;
    }
  } else {
#line 316
    tmp___37 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group1-sha1");
#line 316
    tmp___34 = tmp___37;
  }
#line 316
  if (tmp___34 == 0) {
#line 317
    k->kex_type = 0;
#line 318
    k->evp_md = EVP_sha1();
  } else {
#line 319
    if (0) {
#line 319
      __s1_len___1 = strlen((char const   *)k->name);
#line 319
      __s2_len___1 = strlen("diffie-hellman-group14-sha1");
#line 319
      if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
        goto _L___4;
      } else {
#line 319
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 319
          if (! ((unsigned int )((void const   *)("diffie-hellman-group14-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group14-sha1") == 1U)) {
#line 319
            tmp___28 = 1;
          } else {
#line 319
            if (__s2_len___1 >= 4U) {
#line 319
              tmp___28 = 1;
            } else {
#line 319
              tmp___28 = 0;
            }
          }
        } else {
#line 319
          tmp___28 = 0;
        }
      }
#line 319
      if (tmp___28) {
#line 319
        tmp___24 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
      } else {
#line 319
        tmp___27 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
#line 319
        tmp___24 = tmp___27;
      }
    } else {
#line 319
      tmp___27 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group14-sha1");
#line 319
      tmp___24 = tmp___27;
    }
#line 319
    if (tmp___24 == 0) {
#line 320
      k->kex_type = 1;
#line 321
      k->evp_md = EVP_sha1();
    } else {
#line 322
      if (0) {
#line 322
        __s1_len___0 = strlen((char const   *)k->name);
#line 322
        __s2_len___0 = strlen("diffie-hellman-group-exchange-sha1");
#line 322
        if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
          goto _L___2;
        } else {
#line 322
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 322
            if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha1" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha1") == 1U)) {
#line 322
              tmp___18 = 1;
            } else {
#line 322
              if (__s2_len___0 >= 4U) {
#line 322
                tmp___18 = 1;
              } else {
#line 322
                tmp___18 = 0;
              }
            }
          } else {
#line 322
            tmp___18 = 0;
          }
        }
#line 322
        if (tmp___18) {
#line 322
          tmp___14 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
        } else {
#line 322
          tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 322
          tmp___14 = tmp___17;
        }
      } else {
#line 322
        tmp___17 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha1");
#line 322
        tmp___14 = tmp___17;
      }
#line 322
      if (tmp___14 == 0) {
#line 323
        k->kex_type = 2;
#line 324
        k->evp_md = EVP_sha1();
      } else {
#line 326
        if (0) {
#line 326
          __s1_len = strlen((char const   *)k->name);
#line 326
          __s2_len = strlen("diffie-hellman-group-exchange-sha256");
#line 326
          if (! ((unsigned int )((void const   *)(k->name + 1)) - (unsigned int )((void const   *)k->name) == 1U)) {
            goto _L___0;
          } else {
#line 326
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 326
              if (! ((unsigned int )((void const   *)("diffie-hellman-group-exchange-sha256" + 1)) - (unsigned int )((void const   *)"diffie-hellman-group-exchange-sha256") == 1U)) {
#line 326
                tmp___8 = 1;
              } else {
#line 326
                if (__s2_len >= 4U) {
#line 326
                  tmp___8 = 1;
                } else {
#line 326
                  tmp___8 = 0;
                }
              }
            } else {
#line 326
              tmp___8 = 0;
            }
          }
#line 326
          if (tmp___8) {
#line 326
            tmp___4 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha256");
          } else {
#line 326
            tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha256");
#line 326
            tmp___4 = tmp___7;
          }
        } else {
#line 326
          tmp___7 = __builtin_strcmp((char const   *)k->name, "diffie-hellman-group-exchange-sha256");
#line 326
          tmp___4 = tmp___7;
        }
#line 326
        if (tmp___4 == 0) {
#line 327
          k->kex_type = 3;
#line 328
          k->evp_md = EVP_sha256();
        } else {
#line 331
          fatal("bad kex alg %s", k->name);
        }
      }
    }
  }
#line 332
  return;
}
}
#line 334 "kex.c"
static void choose_hostkeyalg(Kex *k , char *client , char *server ) 
{ char *hostkeyalg ;
  char *tmp ;

  {
#line 337
  tmp = match_list((char const   *)client, (char const   *)server, (u_int *)((void *)0));
#line 337
  hostkeyalg = tmp;
#line 338
  if ((unsigned int )hostkeyalg == (unsigned int )((void *)0)) {
#line 339
    fatal("no hostkey alg");
  }
#line 340
  k->hostkey_type = key_type_from_name(hostkeyalg);
#line 341
  if (k->hostkey_type == 3) {
#line 342
    fatal("bad hostkey alg \'%s\'", hostkeyalg);
  }
#line 343
  xfree((void *)hostkeyalg);
#line 344
  return;
}
}
#line 349
static int proposals_match(char **my , char **peer ) ;
#line 349 "kex.c"
static int check___0[3]  = {      0,      1,      -1};
#line 346 "kex.c"
static int proposals_match(char **my , char **peer ) 
{ int *idx ;
  char *p ;
  char *tmp___0 ;
  char *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 355
  idx = check___0;
#line 355
  while (*idx != -1) {
#line 356
    tmp___0 = __builtin_strchr(*(my + *idx), ',');
#line 356
    p = tmp___0;
#line 356
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 357
      *p = (char )'\000';
    }
#line 358
    tmp___2 = __builtin_strchr(*(peer + *idx), ',');
#line 358
    p = tmp___2;
#line 358
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 359
      *p = (char )'\000';
    }
#line 360
    if (0) {
#line 360
      __s1_len = strlen((char const   *)*(my + *idx));
#line 360
      __s2_len = strlen((char const   *)*(peer + *idx));
#line 360
      if (! ((unsigned int )((void const   *)(*(my + *idx) + 1)) - (unsigned int )((void const   *)*(my + *idx)) == 1U)) {
        goto _L___0;
      } else {
#line 360
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 360
          if (! ((unsigned int )((void const   *)(*(peer + *idx) + 1)) - (unsigned int )((void const   *)*(peer + *idx)) == 1U)) {
#line 360
            tmp___12 = 1;
          } else {
#line 360
            if (__s2_len >= 4U) {
#line 360
              tmp___12 = 1;
            } else {
#line 360
              tmp___12 = 0;
            }
          }
        } else {
#line 360
          tmp___12 = 0;
        }
      }
#line 360
      if (tmp___12) {
#line 360
        tmp___8 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
      } else {
#line 360
        tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 360
        tmp___8 = tmp___11;
      }
    } else {
#line 360
      tmp___11 = __builtin_strcmp((char const   *)*(my + *idx), (char const   *)*(peer + *idx));
#line 360
      tmp___8 = tmp___11;
    }
#line 360
    if (tmp___8 != 0) {
#line 361
      debug2("proposal mismatch: my %s peer %s", *(my + *idx), *(peer + *idx));
#line 363
      return (0);
    }
#line 355
    idx ++;
  }
#line 366
  debug2("proposals match");
#line 367
  return (1);
}
}
#line 370 "kex.c"
static void kex_choose_conf(Kex *kex ) 
{ Newkeys *newkeys___0 ;
  char **my ;
  char **peer ;
  char **cprop ;
  char **sprop ;
  int nenc ;
  int nmac ;
  int ncomp ;
  u_int mode ;
  u_int ctos ;
  u_int need ;
  int first_kex_follows ;
  int type ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 380
  my = kex_buf2prop(& kex->my, (int *)((void *)0));
#line 381
  peer = kex_buf2prop(& kex->peer, & first_kex_follows);
#line 383
  if (kex->server) {
#line 384
    cprop = peer;
#line 385
    sprop = my;
  } else {
#line 387
    cprop = my;
#line 388
    sprop = peer;
  }
#line 392
  mode = 0U;
#line 392
  while (mode < 2U) {
#line 393
    tmp = xcalloc(1U, sizeof(*newkeys___0));
#line 393
    newkeys___0 = (Newkeys *)tmp;
#line 394
    kex->newkeys[mode] = newkeys___0;
#line 395
    if (! kex->server) {
#line 395
      if (mode == 1U) {
#line 395
        tmp___0 = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 395
      if (kex->server) {
#line 395
        if (mode == 0U) {
#line 395
          tmp___0 = 1;
        } else {
#line 395
          tmp___0 = 0;
        }
      } else {
#line 395
        tmp___0 = 0;
      }
    }
#line 395
    ctos = (unsigned int )tmp___0;
#line 397
    if (ctos) {
#line 397
      nenc = 2;
    } else {
#line 397
      nenc = 3;
    }
#line 398
    if (ctos) {
#line 398
      nmac = 4;
    } else {
#line 398
      nmac = 5;
    }
#line 399
    if (ctos) {
#line 399
      ncomp = 6;
    } else {
#line 399
      ncomp = 7;
    }
#line 400
    choose_enc(& newkeys___0->enc, *(cprop + nenc), *(sprop + nenc));
#line 401
    choose_mac(& newkeys___0->mac, *(cprop + nmac), *(sprop + nmac));
#line 402
    choose_comp(& newkeys___0->comp, *(cprop + ncomp), *(sprop + ncomp));
#line 403
    if (ctos) {
#line 403
      tmp___1 = "client->server";
    } else {
#line 403
      tmp___1 = "server->client";
    }
#line 403
    debug("kex: %s %s %s %s", tmp___1, newkeys___0->enc.name, newkeys___0->mac.name,
          newkeys___0->comp.name);
#line 392
    mode ++;
  }
#line 409
  choose_kex(kex, *(cprop + 0), *(sprop + 0));
#line 410
  choose_hostkeyalg(kex, *(cprop + 1), *(sprop + 1));
#line 412
  need = 0U;
#line 413
  mode = 0U;
#line 413
  while (mode < 2U) {
#line 414
    newkeys___0 = kex->newkeys[mode];
#line 415
    if (need < newkeys___0->enc.key_len) {
#line 416
      need = newkeys___0->enc.key_len;
    }
#line 417
    if (need < newkeys___0->enc.block_size) {
#line 418
      need = newkeys___0->enc.block_size;
    }
#line 419
    if (need < newkeys___0->mac.key_len) {
#line 420
      need = newkeys___0->mac.key_len;
    }
#line 413
    mode ++;
  }
#line 423
  kex->we_need = need;
#line 426
  if (first_kex_follows) {
#line 426
    tmp___2 = proposals_match((char **)my, (char **)peer);
#line 426
    if (! tmp___2) {
#line 426
      if (! (datafellows & 8388608)) {
#line 428
        type = packet_read();
#line 429
        debug2("skipping next packet (type %u)", type);
      }
    }
  }
#line 432
  kex_prop_free(my);
#line 433
  kex_prop_free(peer);
#line 434
  return;
}
}
#line 436 "kex.c"
static u_char *derive_key(Kex *kex , int id , u_int need , u_char *hash , u_int hashlen ,
                          BIGNUM *shared_secret ) 
{ Buffer b ;
  EVP_MD_CTX md ;
  char c ;
  u_int have ;
  int mdsz ;
  u_char *digest___1 ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  void *tmp___3 ;

  {
#line 442
  c = (char )id;
#line 447
  mdsz = (int )(kex->evp_md)->md_size;
#line 447
  if (mdsz <= 0) {
#line 448
    fatal("bad kex md size %d", mdsz);
  }
#line 449
  tmp = xmalloc(((need + (u_int )(mdsz - 1)) / (u_int )mdsz) * (u_int )mdsz);
#line 449
  digest___1 = (u_char *)tmp;
#line 451
  buffer_init(& b);
#line 452
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 455
  EVP_DigestInit(& md, kex->evp_md);
#line 456
  if (! (datafellows & 262144)) {
#line 457
    tmp___0 = buffer_len(& b);
#line 457
    tmp___1 = buffer_ptr(& b);
#line 457
    EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
  }
#line 458
  EVP_DigestUpdate(& md, (void const   *)hash, hashlen);
#line 459
  EVP_DigestUpdate(& md, (void const   *)(& c), 1U);
#line 460
  EVP_DigestUpdate(& md, (void const   *)kex->session_id, kex->session_id_len);
#line 461
  EVP_DigestFinal(& md, digest___1, (unsigned int *)((void *)0));
#line 468
  have = (unsigned int )mdsz;
#line 468
  while (need > have) {
#line 469
    EVP_DigestInit(& md, kex->evp_md);
#line 470
    if (! (datafellows & 262144)) {
#line 471
      tmp___2 = buffer_len(& b);
#line 471
      tmp___3 = buffer_ptr(& b);
#line 471
      EVP_DigestUpdate(& md, (void const   *)tmp___3, tmp___2);
    }
#line 472
    EVP_DigestUpdate(& md, (void const   *)hash, hashlen);
#line 473
    EVP_DigestUpdate(& md, (void const   *)digest___1, have);
#line 474
    EVP_DigestFinal(& md, digest___1 + have, (unsigned int *)((void *)0));
#line 468
    have += (u_int )mdsz;
  }
#line 476
  buffer_free(& b);
#line 481
  return (digest___1);
}
}
#line 484 "kex.c"
Newkeys *current_keys[2]  ;
#line 487 "kex.c"
void kex_derive_keys(Kex *kex , u_char *hash , u_int hashlen , BIGNUM *shared_secret ) 
{ u_char *keys[6] ;
  u_int i ;
  u_int mode ;
  u_int ctos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 493
  i = 0U;
#line 493
  while (i < 6U) {
#line 494
    keys[i] = derive_key(kex, (int )(65U + i), kex->we_need, hash, hashlen, shared_secret);
#line 493
    i ++;
  }
#line 498
  debug2("kex_derive_keys");
#line 499
  mode = 0U;
#line 499
  while (mode < 2U) {
#line 500
    current_keys[mode] = kex->newkeys[mode];
#line 501
    kex->newkeys[mode] = (Newkeys *)((void *)0);
#line 502
    if (! kex->server) {
#line 502
      if (mode == 1U) {
#line 502
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 502
      if (kex->server) {
#line 502
        if (mode == 0U) {
#line 502
          tmp = 1;
        } else {
#line 502
          tmp = 0;
        }
      } else {
#line 502
        tmp = 0;
      }
    }
#line 502
    ctos = (unsigned int )tmp;
#line 504
    if (ctos) {
#line 504
      tmp___0 = 0;
    } else {
#line 504
      tmp___0 = 1;
    }
#line 504
    (current_keys[mode])->enc.iv = keys[tmp___0];
#line 505
    if (ctos) {
#line 505
      tmp___1 = 2;
    } else {
#line 505
      tmp___1 = 3;
    }
#line 505
    (current_keys[mode])->enc.key = keys[tmp___1];
#line 506
    if (ctos) {
#line 506
      tmp___2 = 4;
    } else {
#line 506
      tmp___2 = 5;
    }
#line 506
    (current_keys[mode])->mac.key = keys[tmp___2];
#line 499
    mode ++;
  }
#line 508
  return;
}
}
#line 510 "kex.c"
Newkeys *kex_get_newkeys(int mode ) 
{ Newkeys *ret___0 ;

  {
#line 515
  ret___0 = current_keys[mode];
#line 516
  current_keys[mode] = (Newkeys *)((void *)0);
#line 517
  return (ret___0);
}
}
#line 520 "kex.c"
void derive_ssh1_session_id(BIGNUM *host_modulus , BIGNUM *server_modulus , u_int8_t *cookie ,
                            u_int8_t *id ) 
{ EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int8_t nbuf[2048] ;
  u_int8_t obuf[64] ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 524
  tmp = EVP_md5();
#line 524
  evp_md = tmp;
#line 529
  EVP_DigestInit(& md, evp_md);
#line 531
  tmp___0 = BN_num_bits((BIGNUM const   *)host_modulus);
#line 531
  len = (tmp___0 + 7) / 8;
#line 532
  if (len < 64) {
#line 533
    fatal("%s: bad host modulus (len %d)", "derive_ssh1_session_id", len);
  } else {
#line 532
    if ((unsigned int )len > sizeof(nbuf)) {
#line 533
      fatal("%s: bad host modulus (len %d)", "derive_ssh1_session_id", len);
    }
  }
#line 534
  BN_bn2bin((BIGNUM const   *)host_modulus, nbuf);
#line 535
  EVP_DigestUpdate(& md, (void const   *)(nbuf), (unsigned int )len);
#line 537
  tmp___1 = BN_num_bits((BIGNUM const   *)server_modulus);
#line 537
  len = (tmp___1 + 7) / 8;
#line 538
  if (len < 64) {
#line 539
    fatal("%s: bad server modulus (len %d)", "derive_ssh1_session_id", len);
  } else {
#line 538
    if ((unsigned int )len > sizeof(nbuf)) {
#line 539
      fatal("%s: bad server modulus (len %d)", "derive_ssh1_session_id", len);
    }
  }
#line 540
  BN_bn2bin((BIGNUM const   *)server_modulus, nbuf);
#line 541
  EVP_DigestUpdate(& md, (void const   *)(nbuf), (unsigned int )len);
#line 543
  EVP_DigestUpdate(& md, (void const   *)cookie, 8U);
#line 545
  EVP_DigestFinal(& md, obuf, (unsigned int *)((void *)0));
#line 546
  memcpy((void * __restrict  )id, (void const   * __restrict  )(obuf), 16U);
#line 548
  memset((void *)(nbuf), 0, sizeof(nbuf));
#line 549
  memset((void *)(obuf), 0, sizeof(obuf));
#line 550
  memset((void *)(& md), 0, sizeof(md));
#line 551
  return;
}
}
#line 1 "mac.o"
#line 611 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_ripemd160(void) ;
#line 26 "mac.h"
int mac_valid(char const   *names ) ;
#line 55 "umac.h"
struct umac_ctx *umac_new(u_char *key ) ;
#line 65
int umac_update(struct umac_ctx *ctx , u_char *input___0 , long len ) ;
#line 68
int umac_final(struct umac_ctx *ctx , u_char *tag , u_char *nonce ) ;
#line 73
int umac_delete(struct umac_ctx *ctx ) ;
#line 50 "mac.c"
struct __anonstruct_macs_74 macs[8]  = 
#line 50 "mac.c"
  {      {(char *)"hmac-sha1", 1, & EVP_sha1, 0, -1, -1}, 
        {(char *)"hmac-sha1-96", 1, & EVP_sha1, 96, -1, -1}, 
        {(char *)"hmac-md5", 1, & EVP_md5, 0, -1, -1}, 
        {(char *)"hmac-md5-96", 1, & EVP_md5, 96, -1, -1}, 
        {(char *)"hmac-ripemd160", 1, & EVP_ripemd160, 0, -1, -1}, 
        {(char *)"hmac-ripemd160@openssh.com", 1, & EVP_ripemd160, 0, -1, -1}, 
        {(char *)"umac-64@openssh.com", 2, (EVP_MD const   *(*)(void))((void *)0), 0,
      128, 64}, 
        {(char *)((void *)0), 0, (EVP_MD const   *(*)(void))((void *)0), 0, -1, -1}};
#line 68 "mac.c"
static void mac_setup_by_id(Mac *mac , int which ) 
{ int evp_len ;

  {
#line 72
  mac->type = macs[which].type;
#line 73
  if (mac->type == 1) {
#line 74
    mac->evp_md = (*(macs[which].mdfunc))();
#line 75
    evp_len = (int )(mac->evp_md)->md_size;
#line 75
    if (evp_len <= 0) {
#line 76
      fatal("mac %s len %d", mac->name, evp_len);
    }
#line 77
    mac->mac_len = (unsigned int )evp_len;
#line 77
    mac->key_len = mac->mac_len;
  } else {
#line 79
    mac->mac_len = (unsigned int )(macs[which].len / 8);
#line 80
    mac->key_len = (unsigned int )(macs[which].key_len / 8);
#line 81
    mac->umac_ctx = (struct umac_ctx *)((void *)0);
  }
#line 83
  if (macs[which].truncatebits != 0) {
#line 84
    mac->mac_len = (unsigned int )(macs[which].truncatebits / 8);
  }
#line 85
  return;
}
}
#line 87 "mac.c"
int mac_setup(Mac *mac , char *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 92
  i = 0;
#line 92
  while (macs[i].name) {
#line 93
    if (0) {
#line 93
      __s1_len = strlen((char const   *)name);
#line 93
      __s2_len = strlen((char const   *)macs[i].name);
#line 93
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___0;
      } else {
#line 93
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 93
          if (! ((unsigned int )((void const   *)(macs[i].name + 1)) - (unsigned int )((void const   *)macs[i].name) == 1U)) {
#line 93
            tmp___8 = 1;
          } else {
#line 93
            if (__s2_len >= 4U) {
#line 93
              tmp___8 = 1;
            } else {
#line 93
              tmp___8 = 0;
            }
          }
        } else {
#line 93
          tmp___8 = 0;
        }
      }
#line 93
      if (tmp___8) {
#line 93
        tmp___4 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
      } else {
#line 93
        tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 93
        tmp___4 = tmp___7;
      }
    } else {
#line 93
      tmp___7 = __builtin_strcmp((char const   *)name, (char const   *)macs[i].name);
#line 93
      tmp___4 = tmp___7;
    }
#line 93
    if (tmp___4 == 0) {
#line 94
      if ((unsigned int )mac != (unsigned int )((void *)0)) {
#line 95
        mac_setup_by_id(mac, i);
      }
#line 96
      debug2("mac_setup: found %s", name);
#line 97
      return (0);
    }
#line 92
    i ++;
  }
#line 100
  debug2("mac_setup: unknown %s", name);
#line 101
  return (-1);
}
}
#line 104 "mac.c"
int mac_init(Mac *mac ) 
{ 

  {
#line 107
  if ((unsigned int )mac->key == (unsigned int )((void *)0)) {
#line 108
    fatal("mac_init: no key");
  }
#line 109
  switch (mac->type) {
  case 1: 
#line 111
  if ((unsigned int )mac->evp_md == (unsigned int )((void *)0)) {
#line 112
    return (-1);
  }
#line 113
  HMAC_Init(& mac->evp_ctx, (void const   *)mac->key, (int )mac->key_len, mac->evp_md);
#line 114
  return (0);
  case 2: 
#line 116
  mac->umac_ctx = umac_new(mac->key);
#line 117
  return (0);
  default: ;
#line 119
  return (-1);
  }
}
}
#line 126 "mac.c"
static u_char m[64]  ;
#line 123 "mac.c"
u_char *mac_compute(Mac *mac , u_int32_t seqno , u_char *data , int datalen ) 
{ u_char b[4] ;
  u_char nonce[8] ;

  {
#line 129
  if (mac->mac_len > sizeof(m)) {
#line 130
    fatal("mac_compute: mac too long %u %lu", mac->mac_len, sizeof(m));
  }
#line 133
  switch (mac->type) {
  case 1: 
#line 135
  put_u32((void *)(b), seqno);
#line 137
  HMAC_Init(& mac->evp_ctx, (void const   *)((void *)0), 0, (EVP_MD const   *)((void *)0));
#line 138
  HMAC_Update(& mac->evp_ctx, (unsigned char const   *)(b), sizeof(b));
#line 139
  HMAC_Update(& mac->evp_ctx, (unsigned char const   *)data, (unsigned int )datalen);
#line 140
  HMAC_Final(& mac->evp_ctx, m, (unsigned int *)((void *)0));
#line 141
  break;
  case 2: 
#line 143
  put_u64((void *)(nonce), (unsigned long long )seqno);
#line 144
  umac_update(mac->umac_ctx, data, (long )datalen);
#line 145
  umac_final(mac->umac_ctx, m, (u_char *)(nonce));
#line 146
  break;
  default: 
#line 148
  fatal("mac_compute: unknown MAC type");
  }
#line 150
  return (m);
}
}
#line 153 "mac.c"
void mac_clear(Mac *mac ) 
{ 

  {
#line 156
  if (mac->type == 2) {
#line 157
    if ((unsigned int )mac->umac_ctx != (unsigned int )((void *)0)) {
#line 158
      umac_delete(mac->umac_ctx);
    }
  } else {
#line 159
    if ((unsigned int )mac->evp_md != (unsigned int )((void *)0)) {
#line 160
      HMAC_CTX_cleanup(& mac->evp_ctx);
    }
  }
#line 161
  mac->evp_md = (EVP_MD const   *)((void *)0);
#line 162
  mac->umac_ctx = (struct umac_ctx *)((void *)0);
#line 163
  return;
}
}
#line 167 "mac.c"
int mac_valid(char const   *names ) 
{ char *maclist ;
  char *cp ;
  char *p ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___24 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
#line 172
  if ((unsigned int )names == (unsigned int )((void *)0)) {
#line 173
    return (0);
  } else {
#line 172
    if (0) {
#line 172
      __s1_len = strlen(names);
#line 172
      __s2_len = strlen("");
#line 172
      if (! ((unsigned int )((void const   *)(names + 1)) - (unsigned int )((void const   *)names) == 1U)) {
        goto _L___0;
      } else {
#line 172
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 172
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 172
            tmp___8 = 1;
          } else {
#line 172
            if (__s2_len >= 4U) {
#line 172
              tmp___8 = 1;
            } else {
#line 172
              tmp___8 = 0;
            }
          }
        } else {
#line 172
          tmp___8 = 0;
        }
      }
#line 172
      if (tmp___8) {
#line 172
        tmp___4 = __builtin_strcmp(names, "");
      } else {
#line 172
        tmp___7 = __builtin_strcmp(names, "");
#line 172
        tmp___4 = tmp___7;
      }
    } else {
#line 172
      tmp___7 = __builtin_strcmp(names, "");
#line 172
      tmp___4 = tmp___7;
    }
#line 172
    if (tmp___4 == 0) {
#line 173
      return (0);
    }
  }
#line 174
  cp = xstrdup(names);
#line 174
  maclist = cp;
#line 175
  tmp___24 = __strsep_g(& cp, ",");
#line 175
  p = tmp___24;
#line 175
  while (1) {
#line 175
    if (p) {
#line 175
      if (! ((int )*p != 0)) {
#line 175
        break;
      }
    } else {
#line 175
      break;
    }
#line 177
    tmp___41 = mac_setup((Mac *)((void *)0), p);
#line 177
    if (tmp___41 < 0) {
#line 178
      debug("bad mac %s [%s]", p, names);
#line 179
      xfree((void *)maclist);
#line 180
      return (0);
    } else {
#line 182
      debug3("mac ok: %s [%s]", p, names);
    }
#line 176
    tmp___40 = __strsep_g(& cp, ",");
#line 176
    p = tmp___40;
  }
#line 185
  debug3("macs ok: [%s]", names);
#line 186
  xfree((void *)maclist);
#line 187
  return (1);
}
}
#line 1 "uidswap.o"
#line 648 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 651
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 710
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 715
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 15 "uidswap.h"
void temporarily_use_uid(struct passwd *pw___0 ) ;
#line 16
void restore_uid(void) ;
#line 17
void permanently_set_uid(struct passwd *pw___0 ) ;
#line 44 "uidswap.c"
static uid_t saved_euid  =    (uid_t )0;
#line 45 "uidswap.c"
static gid_t saved_egid  =    (gid_t )0;
#line 49 "uidswap.c"
static int privileged  =    0;
#line 50 "uidswap.c"
static int temporarily_use_uid_effective  =    0;
#line 51 "uidswap.c"
static gid_t *saved_egroups  =    (gid_t *)((void *)0);
#line 51 "uidswap.c"
static gid_t *user_groups  =    (gid_t *)((void *)0);
#line 52 "uidswap.c"
static int saved_egroupslen  =    -1;
#line 52 "uidswap.c"
static int user_groupslen  =    -1;
#line 58 "uidswap.c"
void temporarily_use_uid(struct passwd *pw___0 ) 
{ int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
#line 63
  saved_euid = geteuid();
#line 64
  saved_egid = getegid();
#line 65
  debug("temporarily_use_uid: %u/%u (e=%u/%u)", pw___0->pw_uid, pw___0->pw_gid, saved_euid,
        saved_egid);
#line 69
  if (saved_euid != 0U) {
#line 70
    privileged = 0;
#line 71
    return;
  }
#line 81
  privileged = 1;
#line 82
  temporarily_use_uid_effective = 1;
#line 84
  saved_egroupslen = getgroups(0, (__gid_t *)((void *)0));
#line 85
  if (saved_egroupslen < 0) {
#line 86
    tmp = __errno_location();
#line 86
    tmp___0 = strerror(*tmp);
#line 86
    fatal("getgroups: %.100s", tmp___0);
  }
#line 87
  if (saved_egroupslen > 0) {
#line 88
    tmp___1 = xrealloc((void *)saved_egroups, (unsigned int )saved_egroupslen, sizeof(gid_t ));
#line 88
    saved_egroups = (gid_t *)tmp___1;
#line 90
    tmp___4 = getgroups(saved_egroupslen, saved_egroups);
#line 90
    if (tmp___4 < 0) {
#line 91
      tmp___2 = __errno_location();
#line 91
      tmp___3 = strerror(*tmp___2);
#line 91
      fatal("getgroups: %.100s", tmp___3);
    }
  } else {
#line 93
    if ((unsigned int )saved_egroups != (unsigned int )((void *)0)) {
#line 94
      xfree((void *)saved_egroups);
    }
  }
#line 98
  if (user_groupslen == -1) {
#line 99
    tmp___7 = initgroups((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 99
    if (tmp___7 < 0) {
#line 100
      tmp___5 = __errno_location();
#line 100
      tmp___6 = strerror(*tmp___5);
#line 100
      fatal("initgroups: %s: %.100s", pw___0->pw_name, tmp___6);
    }
#line 103
    user_groupslen = getgroups(0, (__gid_t *)((void *)0));
#line 104
    if (user_groupslen < 0) {
#line 105
      tmp___8 = __errno_location();
#line 105
      tmp___9 = strerror(*tmp___8);
#line 105
      fatal("getgroups: %.100s", tmp___9);
    }
#line 106
    if (user_groupslen > 0) {
#line 107
      tmp___10 = xrealloc((void *)user_groups, (unsigned int )user_groupslen, sizeof(gid_t ));
#line 107
      user_groups = (gid_t *)tmp___10;
#line 109
      tmp___13 = getgroups(user_groupslen, user_groups);
#line 109
      if (tmp___13 < 0) {
#line 110
        tmp___11 = __errno_location();
#line 110
        tmp___12 = strerror(*tmp___11);
#line 110
        fatal("getgroups: %.100s", tmp___12);
      }
    } else {
#line 112
      if (user_groups) {
#line 113
        xfree((void *)user_groups);
      }
    }
  }
#line 117
  tmp___16 = setgroups((unsigned int )user_groupslen, (__gid_t const   *)user_groups);
#line 117
  if (tmp___16 < 0) {
#line 118
    tmp___14 = __errno_location();
#line 118
    tmp___15 = strerror(*tmp___14);
#line 118
    fatal("setgroups: %.100s", tmp___15);
  }
#line 127
  tmp___19 = setegid(pw___0->pw_gid);
#line 127
  if (tmp___19 < 0) {
#line 128
    tmp___17 = __errno_location();
#line 128
    tmp___18 = strerror(*tmp___17);
#line 128
    fatal("setegid %u: %.100s", pw___0->pw_gid, tmp___18);
  }
#line 130
  tmp___22 = seteuid(pw___0->pw_uid);
#line 130
  if (tmp___22 == -1) {
#line 131
    tmp___20 = __errno_location();
#line 131
    tmp___21 = strerror(*tmp___20);
#line 131
    fatal("seteuid %u: %.100s", pw___0->pw_uid, tmp___21);
  }
#line 133
  return;
}
}
#line 135 "uidswap.c"
void permanently_drop_suid(uid_t uid ) 
{ uid_t old_uid ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
#line 138
  tmp = getuid();
#line 138
  old_uid = tmp;
#line 140
  debug("permanently_drop_suid: %u", uid);
#line 142
  tmp___2 = setresuid(uid, uid, uid);
#line 142
  if (tmp___2 < 0) {
#line 143
    tmp___0 = __errno_location();
#line 143
    tmp___1 = strerror(*tmp___0);
#line 143
    fatal("setresuid %u: %.100s", uid, tmp___1);
  }
#line 158
  if (old_uid != uid) {
#line 158
    tmp___3 = setuid(old_uid);
#line 158
    if (tmp___3 != -1) {
#line 160
      fatal("%s: was able to restore old [e]uid", "permanently_drop_suid");
    } else {
#line 158
      tmp___4 = seteuid(old_uid);
#line 158
      if (tmp___4 != -1) {
#line 160
        fatal("%s: was able to restore old [e]uid", "permanently_drop_suid");
      }
    }
  }
#line 164
  tmp___7 = getuid();
#line 164
  if (tmp___7 != uid) {
#line 165
    tmp___5 = geteuid();
#line 165
    tmp___6 = getuid();
#line 165
    fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_drop_suid",
          tmp___6, tmp___5, uid);
  } else {
#line 164
    tmp___8 = geteuid();
#line 164
    if (tmp___8 != uid) {
#line 165
      tmp___5 = geteuid();
#line 165
      tmp___6 = getuid();
#line 165
      fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_drop_suid",
            tmp___6, tmp___5, uid);
    }
  }
#line 168
  return;
}
}
#line 173 "uidswap.c"
void restore_uid(void) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 177
  if (! privileged) {
#line 178
    debug("restore_uid: (unprivileged)");
#line 179
    return;
  }
#line 181
  if (! temporarily_use_uid_effective) {
#line 182
    fatal("restore_uid: temporarily_use_uid not effective");
  }
#line 185
  debug("restore_uid: %u/%u", saved_euid, saved_egid);
#line 187
  tmp___1 = seteuid(saved_euid);
#line 187
  if (tmp___1 < 0) {
#line 188
    tmp = __errno_location();
#line 188
    tmp___0 = strerror(*tmp);
#line 188
    fatal("seteuid %u: %.100s", saved_euid, tmp___0);
  }
#line 189
  tmp___4 = setegid(saved_egid);
#line 189
  if (tmp___4 < 0) {
#line 190
    tmp___2 = __errno_location();
#line 190
    tmp___3 = strerror(*tmp___2);
#line 190
    fatal("setegid %u: %.100s", saved_egid, tmp___3);
  }
#line 201
  tmp___7 = setgroups((unsigned int )saved_egroupslen, (__gid_t const   *)saved_egroups);
#line 201
  if (tmp___7 < 0) {
#line 202
    tmp___5 = __errno_location();
#line 202
    tmp___6 = strerror(*tmp___5);
#line 202
    fatal("setgroups: %.100s", tmp___6);
  }
#line 203
  temporarily_use_uid_effective = 0;
#line 204
  return;
}
}
#line 210 "uidswap.c"
void permanently_set_uid(struct passwd *pw___0 ) 
{ uid_t old_uid ;
  __uid_t tmp ;
  gid_t old_gid ;
  __gid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  __gid_t tmp___9 ;
  __gid_t tmp___10 ;
  __gid_t tmp___11 ;
  __gid_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  __uid_t tmp___15 ;
  __uid_t tmp___16 ;
  __uid_t tmp___17 ;
  __uid_t tmp___18 ;

  {
#line 213
  tmp = getuid();
#line 213
  old_uid = tmp;
#line 214
  tmp___0 = getgid();
#line 214
  old_gid = tmp___0;
#line 216
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 217
    fatal("permanently_set_uid: no user given");
  }
#line 218
  if (temporarily_use_uid_effective) {
#line 219
    fatal("permanently_set_uid: temporarily_use_uid effective");
  }
#line 220
  debug("permanently_set_uid: %u/%u", pw___0->pw_uid, pw___0->pw_gid);
#line 224
  tmp___3 = setresgid(pw___0->pw_gid, pw___0->pw_gid, pw___0->pw_gid);
#line 224
  if (tmp___3 < 0) {
#line 225
    tmp___1 = __errno_location();
#line 225
    tmp___2 = strerror(*tmp___1);
#line 225
    fatal("setresgid %u: %.100s", pw___0->pw_gid, tmp___2);
  }
#line 237
  tmp___6 = setresuid(pw___0->pw_uid, pw___0->pw_uid, pw___0->pw_uid);
#line 237
  if (tmp___6 < 0) {
#line 238
    tmp___4 = __errno_location();
#line 238
    tmp___5 = strerror(*tmp___4);
#line 238
    fatal("setresuid %u: %.100s", pw___0->pw_uid, tmp___5);
  }
#line 253
  if (old_gid != pw___0->pw_gid) {
#line 253
    if (pw___0->pw_uid != 0U) {
#line 253
      tmp___7 = setgid(old_gid);
#line 253
      if (tmp___7 != -1) {
#line 255
        fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
      } else {
#line 253
        tmp___8 = setegid(old_gid);
#line 253
        if (tmp___8 != -1) {
#line 255
          fatal("%s: was able to restore old [e]gid", "permanently_set_uid");
        }
      }
    }
  }
#line 259
  tmp___11 = getgid();
#line 259
  if (tmp___11 != pw___0->pw_gid) {
#line 260
    tmp___9 = getegid();
#line 260
    tmp___10 = getgid();
#line 260
    fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
          tmp___10, tmp___9, pw___0->pw_gid);
  } else {
#line 259
    tmp___12 = getegid();
#line 259
    if (tmp___12 != pw___0->pw_gid) {
#line 260
      tmp___9 = getegid();
#line 260
      tmp___10 = getgid();
#line 260
      fatal("%s: egid incorrect gid:%u egid:%u (should be %u)", "permanently_set_uid",
            tmp___10, tmp___9, pw___0->pw_gid);
    }
  }
#line 267
  if (old_uid != pw___0->pw_uid) {
#line 267
    tmp___13 = setuid(old_uid);
#line 267
    if (tmp___13 != -1) {
#line 269
      fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
    } else {
#line 267
      tmp___14 = seteuid(old_uid);
#line 267
      if (tmp___14 != -1) {
#line 269
        fatal("%s: was able to restore old [e]uid", "permanently_set_uid");
      }
    }
  }
#line 273
  tmp___17 = getuid();
#line 273
  if (tmp___17 != pw___0->pw_uid) {
#line 274
    tmp___15 = geteuid();
#line 274
    tmp___16 = getuid();
#line 274
    fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
          tmp___16, tmp___15, pw___0->pw_uid);
  } else {
#line 273
    tmp___18 = geteuid();
#line 273
    if (tmp___18 != pw___0->pw_uid) {
#line 274
      tmp___15 = geteuid();
#line 274
      tmp___16 = getuid();
#line 274
      fatal("%s: euid incorrect uid:%u euid:%u (should be %u)", "permanently_set_uid",
            tmp___16, tmp___15, pw___0->pw_uid);
    }
  }
#line 278
  return;
}
}
#line 1 "uuencode.o"
#line 29 "uuencode.h"
void dump_base64(FILE *fp , u_char *data , u_int len ) ;
#line 36 "uuencode.c"
int uuencode(u_char const   *src , u_int srclength , char *target , size_t targsize ) 
{ int tmp ;

  {
#line 40
  tmp = __b64_ntop(src, srclength, target, targsize);
#line 40
  return (tmp);
}
}
#line 43 "uuencode.c"
int uudecode(char const   *src , u_char *target , size_t targsize ) 
{ int len ;
  char *encoded___0 ;
  char *p ;

  {
#line 50
  encoded___0 = xstrdup(src);
#line 52
  p = encoded___0;
#line 52
  while (1) {
#line 52
    if (! ((int )*p == 32)) {
#line 52
      if (! ((int )*p == 9)) {
#line 52
        break;
      }
    }
#line 52
    p ++;
  }
#line 54
  while (1) {
#line 54
    if ((int )*p != 0) {
#line 54
      if ((int )*p != 32) {
#line 54
        if (! ((int )*p != 9)) {
#line 54
          break;
        }
      } else {
#line 54
        break;
      }
    } else {
#line 54
      break;
    }
#line 54
    p ++;
  }
#line 57
  *p = (char )'\000';
#line 58
  len = __b64_pton((char const   *)encoded___0, target, targsize);
#line 59
  xfree((void *)encoded___0);
#line 60
  return (len);
}
}
#line 63 "uuencode.c"
void dump_base64(FILE *fp , u_char *data , u_int len ) 
{ char *buf___1 ;
  int i ;
  int n___0 ;
  void *tmp ;

  {
#line 69
  if (len > 65536U) {
#line 70
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"dump_base64: len > 65536\n");
#line 71
    return;
  }
#line 73
  tmp = xmalloc(2U * len);
#line 73
  buf___1 = (char *)tmp;
#line 74
  n___0 = uuencode((u_char const   *)data, len, buf___1, 2U * len);
#line 75
  i = 0;
#line 75
  while (i < n___0) {
#line 76
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%c", *(buf___1 + i));
#line 77
    if (i % 70 == 69) {
#line 78
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 75
    i ++;
  }
#line 80
  if (i % 70 != 69) {
#line 81
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  }
#line 82
  xfree((void *)buf___1);
#line 83
  return;
}
}
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
#line 1 "misc.o"
#line 184 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 640 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 376 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 441
extern int fgetc(FILE *__stream ) ;
#line 729
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 20 "misc.h"
char *chop(char *s ) ;
#line 21
char *strdelim(char **s ) ;
#line 23
int unset_nonblock(int fd ) ;
#line 25
int a2port(char const   *s ) ;
#line 26
int a2tun(char const   *s , int *remote___0 ) ;
#line 27
char *put_host_port(char const   *host , u_short port___0 ) ;
#line 28
char *hpdelim(char **cp ) ;
#line 29
char *cleanhostname(char *host ) ;
#line 30
char *colon(char *cp ) ;
#line 31
long convtime(char const   *s ) ;
#line 32
char *tilde_expand_filename(char const   *filename , uid_t uid ) ;
#line 33
char *percent_expand(char const   *string  , ...) ;
#line 35
void sanitise_stdfd(void) ;
#line 37
struct passwd *pwcopy(struct passwd *pw___0 ) ;
#line 46
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) ;
#line 48
void ( /* format attribute */  replacearg)(arglist *args , u_int which , char *fmt 
                                           , ...) ;
#line 50
void freeargs(arglist *args ) ;
#line 52
int tun_open(int tun , int mode ) ;
#line 60 "misc.c"
char *chop(char *s ) 
{ char *t ;

  {
#line 63
  t = s;
#line 64
  while (*t) {
#line 65
    if ((int )*t == 10) {
#line 66
      *t = (char )'\000';
#line 67
      return (s);
    } else {
#line 65
      if ((int )*t == 13) {
#line 66
        *t = (char )'\000';
#line 67
        return (s);
      }
    }
#line 69
    t ++;
  }
#line 71
  return (s);
}
}
#line 76 "misc.c"
int set_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 81
  val = fcntl(fd, 3, 0);
#line 82
  if (val < 0) {
#line 83
    tmp = __errno_location();
#line 83
    tmp___0 = strerror(*tmp);
#line 83
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 84
    return (-1);
  }
#line 86
  if (val & 2048) {
#line 87
    debug3("fd %d is O_NONBLOCK", fd);
#line 88
    return (0);
  }
#line 90
  debug2("fd %d setting O_NONBLOCK", fd);
#line 91
  val |= 2048;
#line 92
  tmp___3 = fcntl(fd, 4, val);
#line 92
  if (tmp___3 == -1) {
#line 93
    tmp___1 = __errno_location();
#line 93
    tmp___2 = strerror(*tmp___1);
#line 93
    debug("fcntl(%d, F_SETFL, O_NONBLOCK): %s", fd, tmp___2);
#line 95
    return (-1);
  }
#line 97
  return (0);
}
}
#line 100 "misc.c"
int unset_nonblock(int fd ) 
{ int val ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 105
  val = fcntl(fd, 3, 0);
#line 106
  if (val < 0) {
#line 107
    tmp = __errno_location();
#line 107
    tmp___0 = strerror(*tmp);
#line 107
    error("fcntl(%d, F_GETFL, 0): %s", fd, tmp___0);
#line 108
    return (-1);
  }
#line 110
  if (! (val & 2048)) {
#line 111
    debug3("fd %d is not O_NONBLOCK", fd);
#line 112
    return (0);
  }
#line 114
  debug("fd %d clearing O_NONBLOCK", fd);
#line 115
  val &= -2049;
#line 116
  tmp___3 = fcntl(fd, 4, val);
#line 116
  if (tmp___3 == -1) {
#line 117
    tmp___1 = __errno_location();
#line 117
    tmp___2 = strerror(*tmp___1);
#line 117
    debug("fcntl(%d, F_SETFL, ~O_NONBLOCK): %s", fd, tmp___2);
#line 119
    return (-1);
  }
#line 121
  return (0);
}
}
#line 124 "misc.c"
char const   *ssh_gai_strerror(int gaierr ) 
{ int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 127
  if (gaierr == -11) {
#line 128
    tmp = __errno_location();
#line 128
    tmp___0 = strerror(*tmp);
#line 128
    return ((char const   *)tmp___0);
  }
#line 129
  tmp___1 = gai_strerror(gaierr);
#line 129
  return (tmp___1);
}
}
#line 133 "misc.c"
void set_nodelay(int fd ) 
{ int opt ;
  socklen_t optlen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 139
  optlen = sizeof(opt);
#line 140
  tmp___1 = getsockopt(fd, 6, 1, (void * __restrict  )(& opt), (socklen_t * __restrict  )(& optlen));
#line 140
  if (tmp___1 == -1) {
#line 141
    tmp = __errno_location();
#line 141
    tmp___0 = strerror(*tmp);
#line 141
    debug("getsockopt TCP_NODELAY: %.100s", tmp___0);
#line 142
    return;
  }
#line 144
  if (opt == 1) {
#line 145
    debug2("fd %d is TCP_NODELAY", fd);
#line 146
    return;
  }
#line 148
  opt = 1;
#line 149
  debug2("fd %d setting TCP_NODELAY", fd);
#line 150
  tmp___4 = setsockopt(fd, 6, 1, (void const   *)(& opt), sizeof(opt));
#line 150
  if (tmp___4 == -1) {
#line 151
    tmp___2 = __errno_location();
#line 151
    tmp___3 = strerror(*tmp___2);
#line 151
    error("setsockopt TCP_NODELAY: %.100s", tmp___3);
  }
#line 152
  return;
}
}
#line 159 "misc.c"
char *strdelim(char **s ) 
{ char *old ;
  int wspace ;
  char *tmp___30 ;
  size_t tmp___31 ;
  char *tmp___63 ;
  unsigned int tmp___95 ;
  unsigned int tmp___127 ;

  {
#line 163
  wspace = 0;
#line 165
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 166
    return ((char *)((void *)0));
  }
#line 168
  old = *s;
#line 170
  tmp___30 = __builtin_strpbrk((char const   *)*s, " \t\r\n\"=");
#line 170
  *s = tmp___30;
#line 171
  if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 172
    return (old);
  }
#line 174
  if ((int )*(*(s + 0)) == 34) {
#line 175
    tmp___31 = strlen((char const   *)*s);
#line 175
    memmove((void *)*s, (void const   *)(*s + 1), tmp___31);
#line 177
    tmp___63 = __builtin_strpbrk((char const   *)*s, "\"");
#line 177
    *s = tmp___63;
#line 177
    if ((unsigned int )*s == (unsigned int )((void *)0)) {
#line 178
      return ((char *)((void *)0));
    } else {
#line 180
      *(*(s + 0)) = (char )'\000';
#line 181
      return (old);
    }
  }
#line 186
  if ((int )*(*(s + 0)) == 61) {
#line 187
    wspace = 1;
  }
#line 188
  *(*(s + 0)) = (char )'\000';
#line 191
  tmp___95 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 191
  *s += tmp___95 + 1U;
#line 192
  if ((int )*(*(s + 0)) == 61) {
#line 192
    if (! wspace) {
#line 193
      tmp___127 = __builtin_strspn((char const   *)(*s + 1), " \t\r\n");
#line 193
      *s += tmp___127 + 1U;
    }
  }
#line 195
  return (old);
}
}
#line 198 "misc.c"
struct passwd *pwcopy(struct passwd *pw___0 ) 
{ struct passwd *copy ;
  void *tmp ;

  {
#line 201
  tmp = xcalloc(1U, sizeof(*copy));
#line 201
  copy = (struct passwd *)tmp;
#line 203
  copy->pw_name = xstrdup((char const   *)pw___0->pw_name);
#line 204
  copy->pw_passwd = xstrdup((char const   *)pw___0->pw_passwd);
#line 205
  copy->pw_gecos = xstrdup((char const   *)pw___0->pw_gecos);
#line 206
  copy->pw_uid = pw___0->pw_uid;
#line 207
  copy->pw_gid = pw___0->pw_gid;
#line 217
  copy->pw_dir = xstrdup((char const   *)pw___0->pw_dir);
#line 218
  copy->pw_shell = xstrdup((char const   *)pw___0->pw_shell);
#line 219
  return (copy);
}
}
#line 227 "misc.c"
int a2port(char const   *s ) 
{ long port___0 ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 233
  tmp = __errno_location();
#line 233
  *tmp = 0;
#line 234
  port___0 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& endp),
                    0);
#line 235
  if ((unsigned int )s == (unsigned int )endp) {
#line 238
    return (0);
  } else {
#line 235
    if ((int )*endp != 0) {
#line 238
      return (0);
    } else {
#line 235
      tmp___0 = __errno_location();
#line 235
      if (*tmp___0 == 34) {
#line 235
        if (port___0 == (-0x7FFFFFFF-1)) {
#line 238
          return (0);
        } else {
#line 235
          if (port___0 == 2147483647L) {
#line 238
            return (0);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 235
        if (port___0 <= 0L) {
#line 238
          return (0);
        } else {
#line 235
          if (port___0 > 65535L) {
#line 238
            return (0);
          }
        }
      }
    }
  }
#line 240
  return ((int )port___0);
}
}
#line 243 "misc.c"
int a2tun(char const   *s , int *remote___0 ) 
{ char const   *errstr ;
  char *sp ;
  char *ep ;
  int tun ;
  int tmp ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long long tmp___4 ;

  {
#line 246
  errstr = (char const   *)((void *)0);
#line 250
  if ((unsigned int )remote___0 != (unsigned int )((void *)0)) {
#line 251
    *remote___0 = 2147483647;
#line 252
    sp = xstrdup(s);
#line 253
    tmp___1 = __builtin_strchr(sp, ':');
#line 253
    ep = tmp___1;
#line 253
    if ((unsigned int )ep == (unsigned int )((void *)0)) {
#line 254
      xfree((void *)sp);
#line 255
      tmp = a2tun(s, (int *)((void *)0));
#line 255
      return (tmp);
    }
#line 257
    *(ep + 0) = (char )'\000';
#line 257
    ep ++;
#line 258
    *remote___0 = a2tun((char const   *)ep, (int *)((void *)0));
#line 259
    tun = a2tun((char const   *)sp, (int *)((void *)0));
#line 260
    xfree((void *)sp);
#line 261
    if (*remote___0 == 2147483646) {
#line 261
      tmp___2 = *remote___0;
    } else {
#line 261
      tmp___2 = tun;
    }
#line 261
    return (tmp___2);
  }
#line 264
  tmp___3 = strcasecmp(s, "any");
#line 264
  if (tmp___3 == 0) {
#line 265
    return (2147483647);
  }
#line 267
  tmp___4 = strtonum(s, 0LL, 2147483645LL, & errstr);
#line 267
  tun = (int )tmp___4;
#line 268
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
#line 269
    return (2147483646);
  }
#line 271
  return (tun);
}
}
#line 301 "misc.c"
long convtime(char const   *s ) 
{ long total ;
  long secs ;
  char const   *p ;
  char *endp ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 308
  tmp = __errno_location();
#line 308
  *tmp = 0;
#line 309
  total = 0L;
#line 310
  p = s;
#line 312
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 313
    return (-1L);
  } else {
#line 312
    if ((int const   )*p == 0) {
#line 313
      return (-1L);
    }
  }
#line 315
  while (*p) {
#line 316
    secs = strtol((char const   * __restrict  )p, (char ** __restrict  )(& endp),
                  10);
#line 317
    if ((unsigned int )p == (unsigned int )endp) {
#line 320
      return (-1L);
    } else {
#line 317
      tmp___0 = __errno_location();
#line 317
      if (*tmp___0 == 34) {
#line 317
        if (secs == (-0x7FFFFFFF-1)) {
#line 320
          return (-1L);
        } else {
#line 317
          if (secs == 2147483647L) {
#line 320
            return (-1L);
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 317
        if (secs < 0L) {
#line 320
          return (-1L);
        }
      }
    }
#line 322
    tmp___1 = endp;
#line 322
    endp ++;
#line 322
    switch ((int )*tmp___1) {
    case 0: 
#line 324
    endp --;
#line 325
    break;
    case 115: 
    case 83: 
#line 328
    break;
    case 109: 
    case 77: 
#line 331
    secs *= 60L;
#line 332
    break;
    case 104: 
    case 72: 
#line 335
    secs *= 3600L;
#line 336
    break;
    case 100: 
    case 68: 
#line 339
    secs *= 86400L;
#line 340
    break;
    case 119: 
    case 87: 
#line 343
    secs *= 604800L;
#line 344
    break;
    default: ;
#line 346
    return (-1L);
    }
#line 348
    total += secs;
#line 349
    if (total < 0L) {
#line 350
      return (-1L);
    }
#line 351
    p = (char const   *)endp;
  }
#line 354
  return (total);
}
}
#line 361 "misc.c"
char *put_host_port(char const   *host , u_short port___0 ) 
{ char *hoststr ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 366
  if ((int )port___0 == 0) {
#line 367
    tmp = xstrdup(host);
#line 367
    return (tmp);
  } else {
#line 366
    if ((int )port___0 == 22) {
#line 367
      tmp = xstrdup(host);
#line 367
      return (tmp);
    }
  }
#line 368
  tmp___2 = asprintf((char ** __restrict  )(& hoststr), (char const   * __restrict  )"[%s]:%d",
                     host, (int )port___0);
#line 368
  if (tmp___2 < 0) {
#line 369
    tmp___0 = __errno_location();
#line 369
    tmp___1 = strerror(*tmp___0);
#line 369
    fatal("put_host_port: asprintf: %s", tmp___1);
  }
#line 370
  debug3("put_host_port: %s", hoststr);
#line 371
  return (hoststr);
}
}
#line 381 "misc.c"
char *hpdelim(char **cp ) 
{ char *s ;
  char *old ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___33 ;

  {
#line 386
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 387
    return ((char *)((void *)0));
  } else {
#line 386
    if ((unsigned int )*cp == (unsigned int )((void *)0)) {
#line 387
      return ((char *)((void *)0));
    }
  }
#line 389
  s = *cp;
#line 389
  old = s;
#line 390
  if ((int )*s == 91) {
#line 391
    tmp___0 = __builtin_strchr(s, ']');
#line 391
    s = tmp___0;
#line 391
    if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 392
      return ((char *)((void *)0));
    } else {
#line 394
      s ++;
    }
  } else {
#line 395
    tmp___33 = __builtin_strpbrk((char const   *)s, ":/");
#line 395
    s = tmp___33;
#line 395
    if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 396
      tmp___1 = strlen((char const   *)*cp);
#line 396
      s = *cp + tmp___1;
    }
  }
#line 398
  switch ((int )*s) {
  case 0: 
#line 400
  *cp = (char *)((void *)0);
#line 401
  break;
  case 58: 
  case 47: 
#line 405
  *s = (char )'\000';
#line 406
  *cp = s + 1;
#line 407
  break;
  default: ;
#line 410
  return ((char *)((void *)0));
  }
#line 413
  return (old);
}
}
#line 416 "misc.c"
char *cleanhostname(char *host ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 419
  if ((int )*host == 91) {
#line 419
    tmp___0 = strlen((char const   *)host);
#line 419
    if ((int )*(host + (tmp___0 - 1U)) == 93) {
#line 420
      tmp = strlen((char const   *)host);
#line 420
      *(host + (tmp - 1U)) = (char )'\000';
#line 421
      return (host + 1);
    } else {
#line 423
      return (host);
    }
  } else {
#line 423
    return (host);
  }
}
}
#line 426 "misc.c"
char *colon(char *cp ) 
{ int flag ;

  {
#line 429
  flag = 0;
#line 431
  if ((int )*cp == 58) {
#line 432
    return ((char *)0);
  }
#line 433
  if ((int )*cp == 91) {
#line 434
    flag = 1;
  }
#line 436
  while (*cp) {
#line 437
    if ((int )*cp == 64) {
#line 437
      if ((int )*(cp + 1) == 91) {
#line 438
        flag = 1;
      }
    }
#line 439
    if ((int )*cp == 93) {
#line 439
      if ((int )*(cp + 1) == 58) {
#line 439
        if (flag) {
#line 440
          return (cp + 1);
        }
      }
    }
#line 441
    if ((int )*cp == 58) {
#line 441
      if (! flag) {
#line 442
        return (cp);
      }
    }
#line 443
    if ((int )*cp == 47) {
#line 444
      return ((char *)0);
    }
#line 436
    cp ++;
  }
#line 446
  return ((char *)0);
}
}
#line 450 "misc.c"
void ( /* format attribute */  addargs)(arglist *args , char *fmt  , ...) 
{ va_list ap ;
  char *cp ;
  u_int nalloc ;
  int r ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 458
  __builtin_va_start(ap, fmt);
#line 459
  r = vasprintf((char ** __restrict  )(& cp), (char const   * __restrict  )fmt, ap);
#line 460
  __builtin_va_end(ap);
#line 461
  if (r == -1) {
#line 462
    fatal("addargs: argument too long");
  }
#line 464
  nalloc = args->nalloc;
#line 465
  if ((unsigned int )args->list == (unsigned int )((void *)0)) {
#line 466
    nalloc = 32U;
#line 467
    args->num = 0U;
  } else {
#line 468
    if (args->num + 2U >= nalloc) {
#line 469
      nalloc *= 2U;
    }
  }
#line 471
  tmp = xrealloc((void *)args->list, nalloc, sizeof(char *));
#line 471
  args->list = (char **)tmp;
#line 472
  args->nalloc = nalloc;
#line 473
  tmp___0 = args->num;
#line 473
  (args->num) ++;
#line 473
  *(args->list + tmp___0) = cp;
#line 474
  *(args->list + args->num) = (char *)((void *)0);
#line 475
  return;
}
}
#line 477 "misc.c"
void ( /* format attribute */  replacearg)(arglist *args , u_int which , char *fmt 
                                           , ...) 
{ va_list ap ;
  char *cp ;
  int r ;

  {
#line 484
  __builtin_va_start(ap, fmt);
#line 485
  r = vasprintf((char ** __restrict  )(& cp), (char const   * __restrict  )fmt, ap);
#line 486
  __builtin_va_end(ap);
#line 487
  if (r == -1) {
#line 488
    fatal("replacearg: argument too long");
  }
#line 490
  if (which >= args->num) {
#line 491
    fatal("replacearg: tried to replace invalid arg %d >= %d", which, args->num);
  }
#line 493
  xfree((void *)*(args->list + which));
#line 494
  *(args->list + which) = cp;
#line 495
  return;
}
}
#line 497 "misc.c"
void freeargs(arglist *args ) 
{ u_int i ;

  {
#line 502
  if ((unsigned int )args->list != (unsigned int )((void *)0)) {
#line 503
    i = 0U;
#line 503
    while (i < args->num) {
#line 504
      xfree((void *)*(args->list + i));
#line 503
      i ++;
    }
#line 505
    xfree((void *)args->list);
#line 506
    args->num = 0U;
#line 506
    args->nalloc = args->num;
#line 507
    args->list = (char **)((void *)0);
  }
#line 509
  return;
}
}
#line 515 "misc.c"
char *tilde_expand_filename(char const   *filename , uid_t uid ) 
{ char const   *path ;
  char user[128] ;
  char ret___0[4096] ;
  struct passwd *pw___0 ;
  u_int len ;
  u_int slash ;
  char *tmp ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
#line 523
  if ((int const   )*filename != 126) {
#line 524
    tmp = xstrdup(filename);
#line 524
    return (tmp);
  }
#line 525
  filename ++;
#line 527
  tmp___1 = __builtin_strchr((char *)filename, '/');
#line 527
  path = (char const   *)tmp___1;
#line 528
  if ((unsigned int )path != (unsigned int )((void *)0)) {
#line 528
    if ((unsigned int )path > (unsigned int )filename) {
#line 529
      slash = (unsigned int )(path - filename);
#line 530
      if (slash > sizeof(user) - 1U) {
#line 531
        fatal("tilde_expand_filename: ~username too long");
      }
#line 532
      memcpy((void * __restrict  )(user), (void const   * __restrict  )filename, slash);
#line 533
      user[slash] = (char )'\000';
#line 534
      pw___0 = getpwnam((char const   *)(user));
#line 534
      if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 535
        fatal("tilde_expand_filename: No such user %s", user);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 536
    pw___0 = getpwuid(uid);
#line 536
    if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 537
      fatal("tilde_expand_filename: No such uid %d", uid);
    }
  }
#line 539
  tmp___2 = strlcpy(ret___0, (char const   *)pw___0->pw_dir, sizeof(ret___0));
#line 539
  if (tmp___2 >= sizeof(ret___0)) {
#line 540
    fatal("tilde_expand_filename: Path too long");
  }
#line 543
  len = strlen((char const   *)pw___0->pw_dir);
#line 544
  if (len == 0U) {
    goto _L___0;
  } else {
#line 544
    if ((int )*(pw___0->pw_dir + (len - 1U)) != 47) {
      _L___0: /* CIL Label */ 
#line 544
      tmp___3 = strlcat(ret___0, "/", sizeof(ret___0));
#line 544
      if (tmp___3 >= sizeof(ret___0)) {
#line 546
        fatal("tilde_expand_filename: Path too long");
      }
    }
  }
#line 549
  if ((unsigned int )path != (unsigned int )((void *)0)) {
#line 550
    filename = path + 1;
  }
#line 551
  tmp___4 = strlcat(ret___0, filename, sizeof(ret___0));
#line 551
  if (tmp___4 >= sizeof(ret___0)) {
#line 552
    fatal("tilde_expand_filename: Path too long");
  }
#line 554
  tmp___5 = xstrdup((char const   *)(ret___0));
#line 554
  return (tmp___5);
}
}
#line 563 "misc.c"
char *percent_expand(char const   *string  , ...) 
{ struct __anonstruct_keys_56 keys[16] ;
  u_int num_keys ;
  u_int i ;
  u_int j ;
  char buf___1[4096] ;
  va_list ap ;
  u_int tmp ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 576
  __builtin_va_start(ap, string);
#line 577
  num_keys = 0U;
#line 577
  while (num_keys < 16U) {
#line 578
    keys[num_keys].key = __builtin_va_arg(ap, char *);
#line 579
    if ((unsigned int )keys[num_keys].key == (unsigned int )((void *)0)) {
#line 580
      break;
    }
#line 581
    keys[num_keys].repl = __builtin_va_arg(ap, char *);
#line 582
    if ((unsigned int )keys[num_keys].repl == (unsigned int )((void *)0)) {
#line 583
      fatal("percent_expand: NULL replacement");
    }
#line 577
    num_keys ++;
  }
#line 585
  __builtin_va_end(ap);
#line 587
  if (num_keys >= 16U) {
#line 588
    fatal("percent_expand: too many keys");
  }
#line 591
  buf___1[0] = (char )'\000';
#line 592
  i = 0U;
#line 592
  while ((int const   )*string != 0) {
#line 593
    if ((int const   )*string != 37) {
      append: 
#line 595
      tmp = i;
#line 595
      i ++;
#line 595
      buf___1[tmp] = (char )*string;
#line 596
      if (i >= sizeof(buf___1)) {
#line 597
        fatal("percent_expand: string too long");
      }
#line 598
      buf___1[i] = (char )'\000';
      goto __Cont;
    }
#line 601
    string ++;
#line 602
    if ((int const   )*string == 37) {
      goto append;
    }
#line 604
    j = 0U;
#line 604
    while (j < num_keys) {
#line 605
      tmp___1 = __builtin_strchr((char *)keys[j].key, (int )*string);
#line 605
      if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
#line 606
        i = strlcat(buf___1, keys[j].repl, sizeof(buf___1));
#line 607
        if (i >= sizeof(buf___1)) {
#line 608
          fatal("percent_expand: string too long");
        }
#line 609
        break;
      }
#line 604
      j ++;
    }
#line 612
    if (j >= num_keys) {
#line 613
      fatal("percent_expand: unknown key %%%c", *string);
    }
    __Cont: /* CIL Label */ 
#line 592
    string ++;
  }
#line 615
  tmp___2 = xstrdup((char const   *)(buf___1));
#line 615
  return (tmp___2);
}
}
#line 623 "misc.c"
int read_keyfile_line(FILE *f , char const   *filename , char *buf___1 , size_t bufsz ,
                      u_long *lineno ) 
{ int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 627
  while (1) {
#line 627
    tmp___3 = fgets((char * __restrict  )buf___1, (int )bufsz, (FILE * __restrict  )f);
#line 627
    if (! ((unsigned int )tmp___3 != (unsigned int )((void *)0))) {
#line 627
      break;
    }
#line 628
    if ((int )*(buf___1 + 0) == 0) {
#line 629
      continue;
    }
#line 630
    (*lineno) ++;
#line 631
    tmp___1 = strlen((char const   *)buf___1);
#line 631
    if ((int )*(buf___1 + (tmp___1 - 1U)) == 10) {
#line 632
      return (0);
    } else {
#line 631
      tmp___2 = feof(f);
#line 631
      if (tmp___2) {
#line 632
        return (0);
      } else {
#line 634
        debug("%s: %s line %lu exceeds size limit", "read_keyfile_line", filename,
              *lineno);
#line 637
        while (1) {
#line 637
          tmp = fgetc(f);
#line 637
          if (tmp != 10) {
#line 637
            tmp___0 = feof(f);
#line 637
            if (tmp___0) {
#line 637
              break;
            }
          } else {
#line 637
            break;
          }
        }
      }
    }
  }
#line 641
  return (-1);
}
}
#line 644 "misc.c"
int tun_open(int tun , int mode ) 
{ int tmp ;

  {
#line 648
  tmp = sys_tun_open(tun, mode);
#line 648
  return (tmp);
}
}
#line 715 "misc.c"
void sanitise_stdfd(void) 
{ int nullfd ;
  int dupfd ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 720
  dupfd = open("/dev/null", 2);
#line 720
  nullfd = dupfd;
#line 720
  if (nullfd == -1) {
#line 721
    tmp = __errno_location();
#line 721
    tmp___0 = strerror(*tmp);
#line 721
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t open /dev/null: %s",
            tmp___0);
#line 722
    exit(1);
  }
#line 724
  while (1) {
#line 724
    dupfd ++;
#line 724
    if (! (dupfd <= 2)) {
#line 724
      break;
    }
#line 726
    tmp___1 = fcntl(dupfd, 3, 0);
#line 726
    if (tmp___1 >= 0) {
#line 727
      continue;
    }
#line 728
    tmp___4 = dup2(nullfd, dupfd);
#line 728
    if (tmp___4 == -1) {
#line 729
      tmp___2 = __errno_location();
#line 729
      tmp___3 = strerror(*tmp___2);
#line 729
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dup2: %s",
              tmp___3);
#line 730
      exit(1);
    }
  }
#line 733
  if (nullfd > 2) {
#line 734
    close(nullfd);
  }
#line 735
  return;
}
}
#line 737 "misc.c"
char *tohex(void const   *vp , size_t l ) 
{ u_char const   *p ;
  char b[3] ;
  char *r ;
  size_t i ;
  size_t hl ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 740
  p = (u_char const   *)vp;
#line 744
  if (l > 65536U) {
#line 745
    tmp = xstrdup("tohex: length > 65536");
#line 745
    return (tmp);
  }
#line 747
  hl = l * 2U + 1U;
#line 748
  tmp___0 = xcalloc(1U, hl);
#line 748
  r = (char *)tmp___0;
#line 749
  i = 0U;
#line 749
  while (i < l) {
#line 750
    snprintf((char * __restrict  )(b), sizeof(b), (char const   * __restrict  )"%02x",
             *(p + i));
#line 751
    strlcat(r, (char const   *)(b), hl);
#line 749
    i ++;
  }
#line 753
  return (r);
}
}
#line 756 "misc.c"
u_int64_t get_u64(void const   *vp ) 
{ u_char const   *p ;
  u_int64_t v ;

  {
#line 759
  p = (u_char const   *)vp;
#line 762
  v = (unsigned long long )*(p + 0) << 56;
#line 763
  v |= (unsigned long long )*(p + 1) << 48;
#line 764
  v |= (unsigned long long )*(p + 2) << 40;
#line 765
  v |= (unsigned long long )*(p + 3) << 32;
#line 766
  v |= (unsigned long long )*(p + 4) << 24;
#line 767
  v |= (unsigned long long )*(p + 5) << 16;
#line 768
  v |= (unsigned long long )*(p + 6) << 8;
#line 769
  v |= (unsigned long long )*(p + 7);
#line 771
  return (v);
}
}
#line 774 "misc.c"
u_int32_t get_u32(void const   *vp ) 
{ u_char const   *p ;
  u_int32_t v ;

  {
#line 777
  p = (u_char const   *)vp;
#line 780
  v = (unsigned int )*(p + 0) << 24;
#line 781
  v |= (unsigned int )*(p + 1) << 16;
#line 782
  v |= (unsigned int )*(p + 2) << 8;
#line 783
  v |= (unsigned int )*(p + 3);
#line 785
  return (v);
}
}
#line 788 "misc.c"
u_int16_t get_u16(void const   *vp ) 
{ u_char const   *p ;
  u_int16_t v ;

  {
#line 791
  p = (u_char const   *)vp;
#line 794
  v = (unsigned short )((int )((unsigned short )*(p + 0)) << 8);
#line 795
  v = (unsigned short )((int )v | (int )((unsigned short )*(p + 1)));
#line 797
  return (v);
}
}
#line 800 "misc.c"
void put_u64(void *vp , u_int64_t v ) 
{ u_char *p ;

  {
#line 803
  p = (u_char *)vp;
#line 805
  *(p + 0) = (unsigned char )((int )((unsigned char )(v >> 56)) & 255);
#line 806
  *(p + 1) = (unsigned char )((int )((unsigned char )(v >> 48)) & 255);
#line 807
  *(p + 2) = (unsigned char )((int )((unsigned char )(v >> 40)) & 255);
#line 808
  *(p + 3) = (unsigned char )((int )((unsigned char )(v >> 32)) & 255);
#line 809
  *(p + 4) = (unsigned char )((int )((unsigned char )(v >> 24)) & 255);
#line 810
  *(p + 5) = (unsigned char )((int )((unsigned char )(v >> 16)) & 255);
#line 811
  *(p + 6) = (unsigned char )((int )((unsigned char )(v >> 8)) & 255);
#line 812
  *(p + 7) = (unsigned char )((int )((unsigned char )v) & 255);
#line 813
  return;
}
}
#line 815 "misc.c"
void put_u32(void *vp , u_int32_t v ) 
{ u_char *p ;

  {
#line 818
  p = (u_char *)vp;
#line 820
  *(p + 0) = (unsigned char )((int )((unsigned char )(v >> 24)) & 255);
#line 821
  *(p + 1) = (unsigned char )((int )((unsigned char )(v >> 16)) & 255);
#line 822
  *(p + 2) = (unsigned char )((int )((unsigned char )(v >> 8)) & 255);
#line 823
  *(p + 3) = (unsigned char )((int )((unsigned char )v) & 255);
#line 824
  return;
}
}
#line 827 "misc.c"
void put_u16(void *vp , u_int16_t v ) 
{ u_char *p ;

  {
#line 830
  p = (u_char *)vp;
#line 832
  *(p + 0) = (unsigned char )((int )((unsigned char )((int )v >> 8)) & 255);
#line 833
  *(p + 1) = (unsigned char )((int )((unsigned char )v) & 255);
#line 834
  return;
}
}
#line 1 "monitor_fdpass.o"
#line 171 "/usr/include/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 179
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 31 "monitor_fdpass.h"
int mm_send_fd(int sock , int fd ) ;
#line 32
int mm_receive_fd(int sock ) ;
#line 43 "monitor_fdpass.c"
int mm_send_fd(int sock , int fd ) 
{ struct msghdr msg ;
  struct iovec vec ;
  char ch ;
  ssize_t n___0 ;
  union __anonunion_cmsgbuf_52 cmsgbuf ;
  struct cmsghdr *cmsg ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 49
  ch = (char )'\000';
#line 60
  memset((void *)(& msg), 0, sizeof(msg));
#line 65
  msg.msg_control = (void *)((char *)(& cmsgbuf.buf));
#line 66
  msg.msg_controllen = sizeof(cmsgbuf.buf);
#line 67
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 67
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 67
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 68
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)) + sizeof(int );
#line 69
  cmsg->cmsg_level = 1;
#line 70
  cmsg->cmsg_type = 1;
#line 71
  *((int *)(cmsg->__cmsg_data)) = fd;
#line 74
  vec.iov_base = (void *)(& ch);
#line 75
  vec.iov_len = 1U;
#line 76
  msg.msg_iov = & vec;
#line 77
  msg.msg_iovlen = 1U;
#line 79
  n___0 = sendmsg(sock, (struct msghdr  const  *)(& msg), 0);
#line 79
  if (n___0 == -1) {
#line 80
    tmp = __errno_location();
#line 80
    tmp___0 = strerror(*tmp);
#line 80
    error("%s: sendmsg(%d): %s", "mm_send_fd", fd, tmp___0);
#line 82
    return (-1);
  }
#line 85
  if (n___0 != 1) {
#line 86
    error("%s: sendmsg: expected sent 1 got %ld", "mm_send_fd", (long )n___0);
#line 88
    return (-1);
  }
#line 90
  return (0);
}
}
#line 97 "monitor_fdpass.c"
int mm_receive_fd(int sock ) 
{ struct msghdr msg ;
  struct iovec vec ;
  ssize_t n___0 ;
  char ch ;
  int fd ;
  union __anonunion_cmsgbuf_53 cmsgbuf ;
  struct cmsghdr *cmsg ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 114
  memset((void *)(& msg), 0, sizeof(msg));
#line 115
  vec.iov_base = (void *)(& ch);
#line 116
  vec.iov_len = 1U;
#line 117
  msg.msg_iov = & vec;
#line 118
  msg.msg_iovlen = 1U;
#line 123
  msg.msg_control = (void *)(& cmsgbuf.buf);
#line 124
  msg.msg_controllen = sizeof(cmsgbuf.buf);
#line 127
  n___0 = recvmsg(sock, & msg, 0);
#line 127
  if (n___0 == -1) {
#line 128
    tmp = __errno_location();
#line 128
    tmp___0 = strerror(*tmp);
#line 128
    error("%s: recvmsg: %s", "mm_receive_fd", tmp___0);
#line 129
    return (-1);
  }
#line 131
  if (n___0 != 1) {
#line 132
    error("%s: recvmsg: expected received 1 got %ld", "mm_receive_fd", (long )n___0);
#line 134
    return (-1);
  }
#line 143
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 143
    cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 143
    cmsg = (struct cmsghdr *)((void *)0);
  }
#line 144
  if ((unsigned int )cmsg == (unsigned int )((void *)0)) {
#line 145
    error("%s: no message header", "mm_receive_fd");
#line 146
    return (-1);
  }
#line 149
  if (cmsg->cmsg_type != 1) {
#line 150
    error("%s: expected type %d got %d", "mm_receive_fd", 1, cmsg->cmsg_type);
#line 152
    return (-1);
  }
#line 155
  fd = *((int *)(cmsg->__cmsg_data));
#line 157
  return (fd);
}
}
#line 1 "rijndael.o"
#line 47 "rijndael.h"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int do_encrypt ) ;
#line 48
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 49
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) ;
#line 51 "rijndael.c"
static u32 const   Te0[256]  = 
#line 51 "rijndael.c"
  {      (u32 const   )3328402341U,      (u32 const   )4168907908U,      (u32 const   )4000806809U,      (u32 const   )4135287693U, 
        (u32 const   )4294111757U,      (u32 const   )3597364157U,      (u32 const   )3731845041U,      (u32 const   )2445657428U, 
        (u32 const   )1613770832U,      (u32 const   )33620227U,      (u32 const   )3462883241U,      (u32 const   )1445669757U, 
        (u32 const   )3892248089U,      (u32 const   )3050821474U,      (u32 const   )1303096294U,      (u32 const   )3967186586U, 
        (u32 const   )2412431941U,      (u32 const   )528646813U,      (u32 const   )2311702848U,      (u32 const   )4202528135U, 
        (u32 const   )4026202645U,      (u32 const   )2992200171U,      (u32 const   )2387036105U,      (u32 const   )4226871307U, 
        (u32 const   )1101901292U,      (u32 const   )3017069671U,      (u32 const   )1604494077U,      (u32 const   )1169141738U, 
        (u32 const   )597466303U,      (u32 const   )1403299063U,      (u32 const   )3832705686U,      (u32 const   )2613100635U, 
        (u32 const   )1974974402U,      (u32 const   )3791519004U,      (u32 const   )1033081774U,      (u32 const   )1277568618U, 
        (u32 const   )1815492186U,      (u32 const   )2118074177U,      (u32 const   )4126668546U,      (u32 const   )2211236943U, 
        (u32 const   )1748251740U,      (u32 const   )1369810420U,      (u32 const   )3521504564U,      (u32 const   )4193382664U, 
        (u32 const   )3799085459U,      (u32 const   )2883115123U,      (u32 const   )1647391059U,      (u32 const   )706024767U, 
        (u32 const   )134480908U,      (u32 const   )2512897874U,      (u32 const   )1176707941U,      (u32 const   )2646852446U, 
        (u32 const   )806885416U,      (u32 const   )932615841U,      (u32 const   )168101135U,      (u32 const   )798661301U, 
        (u32 const   )235341577U,      (u32 const   )605164086U,      (u32 const   )461406363U,      (u32 const   )3756188221U, 
        (u32 const   )3454790438U,      (u32 const   )1311188841U,      (u32 const   )2142417613U,      (u32 const   )3933566367U, 
        (u32 const   )302582043U,      (u32 const   )495158174U,      (u32 const   )1479289972U,      (u32 const   )874125870U, 
        (u32 const   )907746093U,      (u32 const   )3698224818U,      (u32 const   )3025820398U,      (u32 const   )1537253627U, 
        (u32 const   )2756858614U,      (u32 const   )1983593293U,      (u32 const   )3084310113U,      (u32 const   )2108928974U, 
        (u32 const   )1378429307U,      (u32 const   )3722699582U,      (u32 const   )1580150641U,      (u32 const   )327451799U, 
        (u32 const   )2790478837U,      (u32 const   )3117535592U,      (u32 const   )0U,      (u32 const   )3253595436U, 
        (u32 const   )1075847264U,      (u32 const   )3825007647U,      (u32 const   )2041688520U,      (u32 const   )3059440621U, 
        (u32 const   )3563743934U,      (u32 const   )2378943302U,      (u32 const   )1740553945U,      (u32 const   )1916352843U, 
        (u32 const   )2487896798U,      (u32 const   )2555137236U,      (u32 const   )2958579944U,      (u32 const   )2244988746U, 
        (u32 const   )3151024235U,      (u32 const   )3320835882U,      (u32 const   )1336584933U,      (u32 const   )3992714006U, 
        (u32 const   )2252555205U,      (u32 const   )2588757463U,      (u32 const   )1714631509U,      (u32 const   )293963156U, 
        (u32 const   )2319795663U,      (u32 const   )3925473552U,      (u32 const   )67240454U,      (u32 const   )4269768577U, 
        (u32 const   )2689618160U,      (u32 const   )2017213508U,      (u32 const   )631218106U,      (u32 const   )1269344483U, 
        (u32 const   )2723238387U,      (u32 const   )1571005438U,      (u32 const   )2151694528U,      (u32 const   )93294474U, 
        (u32 const   )1066570413U,      (u32 const   )563977660U,      (u32 const   )1882732616U,      (u32 const   )4059428100U, 
        (u32 const   )1673313503U,      (u32 const   )2008463041U,      (u32 const   )2950355573U,      (u32 const   )1109467491U, 
        (u32 const   )537923632U,      (u32 const   )3858759450U,      (u32 const   )4260623118U,      (u32 const   )3218264685U, 
        (u32 const   )2177748300U,      (u32 const   )403442708U,      (u32 const   )638784309U,      (u32 const   )3287084079U, 
        (u32 const   )3193921505U,      (u32 const   )899127202U,      (u32 const   )2286175436U,      (u32 const   )773265209U, 
        (u32 const   )2479146071U,      (u32 const   )1437050866U,      (u32 const   )4236148354U,      (u32 const   )2050833735U, 
        (u32 const   )3362022572U,      (u32 const   )3126681063U,      (u32 const   )840505643U,      (u32 const   )3866325909U, 
        (u32 const   )3227541664U,      (u32 const   )427917720U,      (u32 const   )2655997905U,      (u32 const   )2749160575U, 
        (u32 const   )1143087718U,      (u32 const   )1412049534U,      (u32 const   )999329963U,      (u32 const   )193497219U, 
        (u32 const   )2353415882U,      (u32 const   )3354324521U,      (u32 const   )1807268051U,      (u32 const   )672404540U, 
        (u32 const   )2816401017U,      (u32 const   )3160301282U,      (u32 const   )369822493U,      (u32 const   )2916866934U, 
        (u32 const   )3688947771U,      (u32 const   )1681011286U,      (u32 const   )1949973070U,      (u32 const   )336202270U, 
        (u32 const   )2454276571U,      (u32 const   )201721354U,      (u32 const   )1210328172U,      (u32 const   )3093060836U, 
        (u32 const   )2680341085U,      (u32 const   )3184776046U,      (u32 const   )1135389935U,      (u32 const   )3294782118U, 
        (u32 const   )965841320U,      (u32 const   )831886756U,      (u32 const   )3554993207U,      (u32 const   )4068047243U, 
        (u32 const   )3588745010U,      (u32 const   )2345191491U,      (u32 const   )1849112409U,      (u32 const   )3664604599U, 
        (u32 const   )26054028U,      (u32 const   )2983581028U,      (u32 const   )2622377682U,      (u32 const   )1235855840U, 
        (u32 const   )3630984372U,      (u32 const   )2891339514U,      (u32 const   )4092916743U,      (u32 const   )3488279077U, 
        (u32 const   )3395642799U,      (u32 const   )4101667470U,      (u32 const   )1202630377U,      (u32 const   )268961816U, 
        (u32 const   )1874508501U,      (u32 const   )4034427016U,      (u32 const   )1243948399U,      (u32 const   )1546530418U, 
        (u32 const   )941366308U,      (u32 const   )1470539505U,      (u32 const   )1941222599U,      (u32 const   )2546386513U, 
        (u32 const   )3421038627U,      (u32 const   )2715671932U,      (u32 const   )3899946140U,      (u32 const   )1042226977U, 
        (u32 const   )2521517021U,      (u32 const   )1639824860U,      (u32 const   )227249030U,      (u32 const   )260737669U, 
        (u32 const   )3765465232U,      (u32 const   )2084453954U,      (u32 const   )1907733956U,      (u32 const   )3429263018U, 
        (u32 const   )2420656344U,      (u32 const   )100860677U,      (u32 const   )4160157185U,      (u32 const   )470683154U, 
        (u32 const   )3261161891U,      (u32 const   )1781871967U,      (u32 const   )2924959737U,      (u32 const   )1773779408U, 
        (u32 const   )394692241U,      (u32 const   )2579611992U,      (u32 const   )974986535U,      (u32 const   )664706745U, 
        (u32 const   )3655459128U,      (u32 const   )3958962195U,      (u32 const   )731420851U,      (u32 const   )571543859U, 
        (u32 const   )3530123707U,      (u32 const   )2849626480U,      (u32 const   )126783113U,      (u32 const   )865375399U, 
        (u32 const   )765172662U,      (u32 const   )1008606754U,      (u32 const   )361203602U,      (u32 const   )3387549984U, 
        (u32 const   )2278477385U,      (u32 const   )2857719295U,      (u32 const   )1344809080U,      (u32 const   )2782912378U, 
        (u32 const   )59542671U,      (u32 const   )1503764984U,      (u32 const   )160008576U,      (u32 const   )437062935U, 
        (u32 const   )1707065306U,      (u32 const   )3622233649U,      (u32 const   )2218934982U,      (u32 const   )3496503480U, 
        (u32 const   )2185314755U,      (u32 const   )697932208U,      (u32 const   )1512910199U,      (u32 const   )504303377U, 
        (u32 const   )2075177163U,      (u32 const   )2824099068U,      (u32 const   )1841019862U,      (u32 const   )739644986U};
#line 117 "rijndael.c"
static u32 const   Te1[256]  = 
#line 117
  {      (u32 const   )2781242211U,      (u32 const   )2230877308U,      (u32 const   )2582542199U,      (u32 const   )2381740923U, 
        (u32 const   )234877682U,      (u32 const   )3184946027U,      (u32 const   )2984144751U,      (u32 const   )1418839493U, 
        (u32 const   )1348481072U,      (u32 const   )50462977U,      (u32 const   )2848876391U,      (u32 const   )2102799147U, 
        (u32 const   )434634494U,      (u32 const   )1656084439U,      (u32 const   )3863849899U,      (u32 const   )2599188086U, 
        (u32 const   )1167051466U,      (u32 const   )2636087938U,      (u32 const   )1082771913U,      (u32 const   )2281340285U, 
        (u32 const   )368048890U,      (u32 const   )3954334041U,      (u32 const   )3381544775U,      (u32 const   )201060592U, 
        (u32 const   )3963727277U,      (u32 const   )1739838676U,      (u32 const   )4250903202U,      (u32 const   )3930435503U, 
        (u32 const   )3206782108U,      (u32 const   )4149453988U,      (u32 const   )2531553906U,      (u32 const   )1536934080U, 
        (u32 const   )3262494647U,      (u32 const   )484572669U,      (u32 const   )2923271059U,      (u32 const   )1783375398U, 
        (u32 const   )1517041206U,      (u32 const   )1098792767U,      (u32 const   )49674231U,      (u32 const   )1334037708U, 
        (u32 const   )1550332980U,      (u32 const   )4098991525U,      (u32 const   )886171109U,      (u32 const   )150598129U, 
        (u32 const   )2481090929U,      (u32 const   )1940642008U,      (u32 const   )1398944049U,      (u32 const   )1059722517U, 
        (u32 const   )201851908U,      (u32 const   )1385547719U,      (u32 const   )1699095331U,      (u32 const   )1587397571U, 
        (u32 const   )674240536U,      (u32 const   )2704774806U,      (u32 const   )252314885U,      (u32 const   )3039795866U, 
        (u32 const   )151914247U,      (u32 const   )908333586U,      (u32 const   )2602270848U,      (u32 const   )1038082786U, 
        (u32 const   )651029483U,      (u32 const   )1766729511U,      (u32 const   )3447698098U,      (u32 const   )2682942837U, 
        (u32 const   )454166793U,      (u32 const   )2652734339U,      (u32 const   )1951935532U,      (u32 const   )775166490U, 
        (u32 const   )758520603U,      (u32 const   )3000790638U,      (u32 const   )4004797018U,      (u32 const   )4217086112U, 
        (u32 const   )4137964114U,      (u32 const   )1299594043U,      (u32 const   )1639438038U,      (u32 const   )3464344499U, 
        (u32 const   )2068982057U,      (u32 const   )1054729187U,      (u32 const   )1901997871U,      (u32 const   )2534638724U, 
        (u32 const   )4121318227U,      (u32 const   )1757008337U,      (u32 const   )0U,      (u32 const   )750906861U, 
        (u32 const   )1614815264U,      (u32 const   )535035132U,      (u32 const   )3363418545U,      (u32 const   )3988151131U, 
        (u32 const   )3201591914U,      (u32 const   )1183697867U,      (u32 const   )3647454910U,      (u32 const   )1265776953U, 
        (u32 const   )3734260298U,      (u32 const   )3566750796U,      (u32 const   )3903871064U,      (u32 const   )1250283471U, 
        (u32 const   )1807470800U,      (u32 const   )717615087U,      (u32 const   )3847203498U,      (u32 const   )384695291U, 
        (u32 const   )3313910595U,      (u32 const   )3617213773U,      (u32 const   )1432761139U,      (u32 const   )2484176261U, 
        (u32 const   )3481945413U,      (u32 const   )283769337U,      (u32 const   )100925954U,      (u32 const   )2180939647U, 
        (u32 const   )4037038160U,      (u32 const   )1148730428U,      (u32 const   )3123027871U,      (u32 const   )3813386408U, 
        (u32 const   )4087501137U,      (u32 const   )4267549603U,      (u32 const   )3229630528U,      (u32 const   )2315620239U, 
        (u32 const   )2906624658U,      (u32 const   )3156319645U,      (u32 const   )1215313976U,      (u32 const   )82966005U, 
        (u32 const   )3747855548U,      (u32 const   )3245848246U,      (u32 const   )1974459098U,      (u32 const   )1665278241U, 
        (u32 const   )807407632U,      (u32 const   )451280895U,      (u32 const   )251524083U,      (u32 const   )1841287890U, 
        (u32 const   )1283575245U,      (u32 const   )337120268U,      (u32 const   )891687699U,      (u32 const   )801369324U, 
        (u32 const   )3787349855U,      (u32 const   )2721421207U,      (u32 const   )3431482436U,      (u32 const   )959321879U, 
        (u32 const   )1469301956U,      (u32 const   )4065699751U,      (u32 const   )2197585534U,      (u32 const   )1199193405U, 
        (u32 const   )2898814052U,      (u32 const   )3887750493U,      (u32 const   )724703513U,      (u32 const   )2514908019U, 
        (u32 const   )2696962144U,      (u32 const   )2551808385U,      (u32 const   )3516813135U,      (u32 const   )2141445340U, 
        (u32 const   )1715741218U,      (u32 const   )2119445034U,      (u32 const   )2872807568U,      (u32 const   )2198571144U, 
        (u32 const   )3398190662U,      (u32 const   )700968686U,      (u32 const   )3547052216U,      (u32 const   )1009259540U, 
        (u32 const   )2041044702U,      (u32 const   )3803995742U,      (u32 const   )487983883U,      (u32 const   )1991105499U, 
        (u32 const   )1004265696U,      (u32 const   )1449407026U,      (u32 const   )1316239930U,      (u32 const   )504629770U, 
        (u32 const   )3683797321U,      (u32 const   )168560134U,      (u32 const   )1816667172U,      (u32 const   )3837287516U, 
        (u32 const   )1570751170U,      (u32 const   )1857934291U,      (u32 const   )4014189740U,      (u32 const   )2797888098U, 
        (u32 const   )2822345105U,      (u32 const   )2754712981U,      (u32 const   )936633572U,      (u32 const   )2347923833U, 
        (u32 const   )852879335U,      (u32 const   )1133234376U,      (u32 const   )1500395319U,      (u32 const   )3084545389U, 
        (u32 const   )2348912013U,      (u32 const   )1689376213U,      (u32 const   )3533459022U,      (u32 const   )3762923945U, 
        (u32 const   )3034082412U,      (u32 const   )4205598294U,      (u32 const   )133428468U,      (u32 const   )634383082U, 
        (u32 const   )2949277029U,      (u32 const   )2398386810U,      (u32 const   )3913789102U,      (u32 const   )403703816U, 
        (u32 const   )3580869306U,      (u32 const   )2297460856U,      (u32 const   )1867130149U,      (u32 const   )1918643758U, 
        (u32 const   )607656988U,      (u32 const   )4049053350U,      (u32 const   )3346248884U,      (u32 const   )1368901318U, 
        (u32 const   )600565992U,      (u32 const   )2090982877U,      (u32 const   )2632479860U,      (u32 const   )557719327U, 
        (u32 const   )3717614411U,      (u32 const   )3697393085U,      (u32 const   )2249034635U,      (u32 const   )2232388234U, 
        (u32 const   )2430627952U,      (u32 const   )1115438654U,      (u32 const   )3295786421U,      (u32 const   )2865522278U, 
        (u32 const   )3633334344U,      (u32 const   )84280067U,      (u32 const   )33027830U,      (u32 const   )303828494U, 
        (u32 const   )2747425121U,      (u32 const   )1600795957U,      (u32 const   )4188952407U,      (u32 const   )3496589753U, 
        (u32 const   )2434238086U,      (u32 const   )1486471617U,      (u32 const   )658119965U,      (u32 const   )3106381470U, 
        (u32 const   )953803233U,      (u32 const   )334231800U,      (u32 const   )3005978776U,      (u32 const   )857870609U, 
        (u32 const   )3151128937U,      (u32 const   )1890179545U,      (u32 const   )2298973838U,      (u32 const   )2805175444U, 
        (u32 const   )3056442267U,      (u32 const   )574365214U,      (u32 const   )2450884487U,      (u32 const   )550103529U, 
        (u32 const   )1233637070U,      (u32 const   )4289353045U,      (u32 const   )2018519080U,      (u32 const   )2057691103U, 
        (u32 const   )2399374476U,      (u32 const   )4166623649U,      (u32 const   )2148108681U,      (u32 const   )387583245U, 
        (u32 const   )3664101311U,      (u32 const   )836232934U,      (u32 const   )3330556482U,      (u32 const   )3100665960U, 
        (u32 const   )3280093505U,      (u32 const   )2955516313U,      (u32 const   )2002398509U,      (u32 const   )287182607U, 
        (u32 const   )3413881008U,      (u32 const   )4238890068U,      (u32 const   )3597515707U,      (u32 const   )975967766U};
#line 183 "rijndael.c"
static u32 const   Te2[256]  = 
#line 183
  {      (u32 const   )1671808611U,      (u32 const   )2089089148U,      (u32 const   )2006576759U,      (u32 const   )2072901243U, 
        (u32 const   )4061003762U,      (u32 const   )1807603307U,      (u32 const   )1873927791U,      (u32 const   )3310653893U, 
        (u32 const   )810573872U,      (u32 const   )16974337U,      (u32 const   )1739181671U,      (u32 const   )729634347U, 
        (u32 const   )4263110654U,      (u32 const   )3613570519U,      (u32 const   )2883997099U,      (u32 const   )1989864566U, 
        (u32 const   )3393556426U,      (u32 const   )2191335298U,      (u32 const   )3376449993U,      (u32 const   )2106063485U, 
        (u32 const   )4195741690U,      (u32 const   )1508618841U,      (u32 const   )1204391495U,      (u32 const   )4027317232U, 
        (u32 const   )2917941677U,      (u32 const   )3563566036U,      (u32 const   )2734514082U,      (u32 const   )2951366063U, 
        (u32 const   )2629772188U,      (u32 const   )2767672228U,      (u32 const   )1922491506U,      (u32 const   )3227229120U, 
        (u32 const   )3082974647U,      (u32 const   )4246528509U,      (u32 const   )2477669779U,      (u32 const   )644500518U, 
        (u32 const   )911895606U,      (u32 const   )1061256767U,      (u32 const   )4144166391U,      (u32 const   )3427763148U, 
        (u32 const   )878471220U,      (u32 const   )2784252325U,      (u32 const   )3845444069U,      (u32 const   )4043897329U, 
        (u32 const   )1905517169U,      (u32 const   )3631459288U,      (u32 const   )827548209U,      (u32 const   )356461077U, 
        (u32 const   )67897348U,      (u32 const   )3344078279U,      (u32 const   )593839651U,      (u32 const   )3277757891U, 
        (u32 const   )405286936U,      (u32 const   )2527147926U,      (u32 const   )84871685U,      (u32 const   )2595565466U, 
        (u32 const   )118033927U,      (u32 const   )305538066U,      (u32 const   )2157648768U,      (u32 const   )3795705826U, 
        (u32 const   )3945188843U,      (u32 const   )661212711U,      (u32 const   )2999812018U,      (u32 const   )1973414517U, 
        (u32 const   )152769033U,      (u32 const   )2208177539U,      (u32 const   )745822252U,      (u32 const   )439235610U, 
        (u32 const   )455947803U,      (u32 const   )1857215598U,      (u32 const   )1525593178U,      (u32 const   )2700827552U, 
        (u32 const   )1391895634U,      (u32 const   )994932283U,      (u32 const   )3596728278U,      (u32 const   )3016654259U, 
        (u32 const   )695947817U,      (u32 const   )3812548067U,      (u32 const   )795958831U,      (u32 const   )2224493444U, 
        (u32 const   )1408607827U,      (u32 const   )3513301457U,      (u32 const   )0U,      (u32 const   )3979133421U, 
        (u32 const   )543178784U,      (u32 const   )4229948412U,      (u32 const   )2982705585U,      (u32 const   )1542305371U, 
        (u32 const   )1790891114U,      (u32 const   )3410398667U,      (u32 const   )3201918910U,      (u32 const   )961245753U, 
        (u32 const   )1256100938U,      (u32 const   )1289001036U,      (u32 const   )1491644504U,      (u32 const   )3477767631U, 
        (u32 const   )3496721360U,      (u32 const   )4012557807U,      (u32 const   )2867154858U,      (u32 const   )4212583931U, 
        (u32 const   )1137018435U,      (u32 const   )1305975373U,      (u32 const   )861234739U,      (u32 const   )2241073541U, 
        (u32 const   )1171229253U,      (u32 const   )4178635257U,      (u32 const   )33948674U,      (u32 const   )2139225727U, 
        (u32 const   )1357946960U,      (u32 const   )1011120188U,      (u32 const   )2679776671U,      (u32 const   )2833468328U, 
        (u32 const   )1374921297U,      (u32 const   )2751356323U,      (u32 const   )1086357568U,      (u32 const   )2408187279U, 
        (u32 const   )2460827538U,      (u32 const   )2646352285U,      (u32 const   )944271416U,      (u32 const   )4110742005U, 
        (u32 const   )3168756668U,      (u32 const   )3066132406U,      (u32 const   )3665145818U,      (u32 const   )560153121U, 
        (u32 const   )271589392U,      (u32 const   )4279952895U,      (u32 const   )4077846003U,      (u32 const   )3530407890U, 
        (u32 const   )3444343245U,      (u32 const   )202643468U,      (u32 const   )322250259U,      (u32 const   )3962553324U, 
        (u32 const   )1608629855U,      (u32 const   )2543990167U,      (u32 const   )1154254916U,      (u32 const   )389623319U, 
        (u32 const   )3294073796U,      (u32 const   )2817676711U,      (u32 const   )2122513534U,      (u32 const   )1028094525U, 
        (u32 const   )1689045092U,      (u32 const   )1575467613U,      (u32 const   )422261273U,      (u32 const   )1939203699U, 
        (u32 const   )1621147744U,      (u32 const   )2174228865U,      (u32 const   )1339137615U,      (u32 const   )3699352540U, 
        (u32 const   )577127458U,      (u32 const   )712922154U,      (u32 const   )2427141008U,      (u32 const   )2290289544U, 
        (u32 const   )1187679302U,      (u32 const   )3995715566U,      (u32 const   )3100863416U,      (u32 const   )339486740U, 
        (u32 const   )3732514782U,      (u32 const   )1591917662U,      (u32 const   )186455563U,      (u32 const   )3681988059U, 
        (u32 const   )3762019296U,      (u32 const   )844522546U,      (u32 const   )978220090U,      (u32 const   )169743370U, 
        (u32 const   )1239126601U,      (u32 const   )101321734U,      (u32 const   )611076132U,      (u32 const   )1558493276U, 
        (u32 const   )3260915650U,      (u32 const   )3547250131U,      (u32 const   )2901361580U,      (u32 const   )1655096418U, 
        (u32 const   )2443721105U,      (u32 const   )2510565781U,      (u32 const   )3828863972U,      (u32 const   )2039214713U, 
        (u32 const   )3878868455U,      (u32 const   )3359869896U,      (u32 const   )928607799U,      (u32 const   )1840765549U, 
        (u32 const   )2374762893U,      (u32 const   )3580146133U,      (u32 const   )1322425422U,      (u32 const   )2850048425U, 
        (u32 const   )1823791212U,      (u32 const   )1459268694U,      (u32 const   )4094161908U,      (u32 const   )3928346602U, 
        (u32 const   )1706019429U,      (u32 const   )2056189050U,      (u32 const   )2934523822U,      (u32 const   )135794696U, 
        (u32 const   )3134549946U,      (u32 const   )2022240376U,      (u32 const   )628050469U,      (u32 const   )779246638U, 
        (u32 const   )472135708U,      (u32 const   )2800834470U,      (u32 const   )3032970164U,      (u32 const   )3327236038U, 
        (u32 const   )3894660072U,      (u32 const   )3715932637U,      (u32 const   )1956440180U,      (u32 const   )522272287U, 
        (u32 const   )1272813131U,      (u32 const   )3185336765U,      (u32 const   )2340818315U,      (u32 const   )2323976074U, 
        (u32 const   )1888542832U,      (u32 const   )1044544574U,      (u32 const   )3049550261U,      (u32 const   )1722469478U, 
        (u32 const   )1222152264U,      (u32 const   )50660867U,      (u32 const   )4127324150U,      (u32 const   )236067854U, 
        (u32 const   )1638122081U,      (u32 const   )895445557U,      (u32 const   )1475980887U,      (u32 const   )3117443513U, 
        (u32 const   )2257655686U,      (u32 const   )3243809217U,      (u32 const   )489110045U,      (u32 const   )2662934430U, 
        (u32 const   )3778599393U,      (u32 const   )4162055160U,      (u32 const   )2561878936U,      (u32 const   )288563729U, 
        (u32 const   )1773916777U,      (u32 const   )3648039385U,      (u32 const   )2391345038U,      (u32 const   )2493985684U, 
        (u32 const   )2612407707U,      (u32 const   )505560094U,      (u32 const   )2274497927U,      (u32 const   )3911240169U, 
        (u32 const   )3460925390U,      (u32 const   )1442818645U,      (u32 const   )678973480U,      (u32 const   )3749357023U, 
        (u32 const   )2358182796U,      (u32 const   )2717407649U,      (u32 const   )2306869641U,      (u32 const   )219617805U, 
        (u32 const   )3218761151U,      (u32 const   )3862026214U,      (u32 const   )1120306242U,      (u32 const   )1756942440U, 
        (u32 const   )1103331905U,      (u32 const   )2578459033U,      (u32 const   )762796589U,      (u32 const   )252780047U, 
        (u32 const   )2966125488U,      (u32 const   )1425844308U,      (u32 const   )3151392187U,      (u32 const   )372911126U};
#line 249 "rijndael.c"
static u32 const   Te3[256]  = 
#line 249
  {      (u32 const   )1667474886U,      (u32 const   )2088535288U,      (u32 const   )2004326894U,      (u32 const   )2071694838U, 
        (u32 const   )4075949567U,      (u32 const   )1802223062U,      (u32 const   )1869591006U,      (u32 const   )3318043793U, 
        (u32 const   )808472672U,      (u32 const   )16843522U,      (u32 const   )1734846926U,      (u32 const   )724270422U, 
        (u32 const   )4278065639U,      (u32 const   )3621216949U,      (u32 const   )2880169549U,      (u32 const   )1987484396U, 
        (u32 const   )3402253711U,      (u32 const   )2189597983U,      (u32 const   )3385409673U,      (u32 const   )2105378810U, 
        (u32 const   )4210693615U,      (u32 const   )1499065266U,      (u32 const   )1195886990U,      (u32 const   )4042263547U, 
        (u32 const   )2913856577U,      (u32 const   )3570689971U,      (u32 const   )2728590687U,      (u32 const   )2947541573U, 
        (u32 const   )2627518243U,      (u32 const   )2762274643U,      (u32 const   )1920112356U,      (u32 const   )3233831835U, 
        (u32 const   )3082273397U,      (u32 const   )4261223649U,      (u32 const   )2475929149U,      (u32 const   )640051788U, 
        (u32 const   )909531756U,      (u32 const   )1061110142U,      (u32 const   )4160160501U,      (u32 const   )3435941763U, 
        (u32 const   )875846760U,      (u32 const   )2779116625U,      (u32 const   )3857003729U,      (u32 const   )4059105529U, 
        (u32 const   )1903268834U,      (u32 const   )3638064043U,      (u32 const   )825316194U,      (u32 const   )353713962U, 
        (u32 const   )67374088U,      (u32 const   )3351728789U,      (u32 const   )589522246U,      (u32 const   )3284360861U, 
        (u32 const   )404236336U,      (u32 const   )2526454071U,      (u32 const   )84217610U,      (u32 const   )2593830191U, 
        (u32 const   )117901582U,      (u32 const   )303183396U,      (u32 const   )2155911963U,      (u32 const   )3806477791U, 
        (u32 const   )3958056653U,      (u32 const   )656894286U,      (u32 const   )2998062463U,      (u32 const   )1970642922U, 
        (u32 const   )151591698U,      (u32 const   )2206440989U,      (u32 const   )741110872U,      (u32 const   )437923380U, 
        (u32 const   )454765878U,      (u32 const   )1852748508U,      (u32 const   )1515908788U,      (u32 const   )2694904667U, 
        (u32 const   )1381168804U,      (u32 const   )993742198U,      (u32 const   )3604373943U,      (u32 const   )3014905469U, 
        (u32 const   )690584402U,      (u32 const   )3823320797U,      (u32 const   )791638366U,      (u32 const   )2223281939U, 
        (u32 const   )1398011302U,      (u32 const   )3520161977U,      (u32 const   )0U,      (u32 const   )3991743681U, 
        (u32 const   )538992704U,      (u32 const   )4244381667U,      (u32 const   )2981218425U,      (u32 const   )1532751286U, 
        (u32 const   )1785380564U,      (u32 const   )3419096717U,      (u32 const   )3200178535U,      (u32 const   )960056178U, 
        (u32 const   )1246420628U,      (u32 const   )1280103576U,      (u32 const   )1482221744U,      (u32 const   )3486468741U, 
        (u32 const   )3503319995U,      (u32 const   )4025428677U,      (u32 const   )2863326543U,      (u32 const   )4227536621U, 
        (u32 const   )1128514950U,      (u32 const   )1296947098U,      (u32 const   )859002214U,      (u32 const   )2240123921U, 
        (u32 const   )1162203018U,      (u32 const   )4193849577U,      (u32 const   )33687044U,      (u32 const   )2139062782U, 
        (u32 const   )1347481760U,      (u32 const   )1010582648U,      (u32 const   )2678045221U,      (u32 const   )2829640523U, 
        (u32 const   )1364325282U,      (u32 const   )2745433693U,      (u32 const   )1077985408U,      (u32 const   )2408548869U, 
        (u32 const   )2459086143U,      (u32 const   )2644360225U,      (u32 const   )943212656U,      (u32 const   )4126475505U, 
        (u32 const   )3166494563U,      (u32 const   )3065430391U,      (u32 const   )3671750063U,      (u32 const   )555836226U, 
        (u32 const   )269496352U,      (u32 const   )4294908645U,      (u32 const   )4092792573U,      (u32 const   )3537006015U, 
        (u32 const   )3452783745U,      (u32 const   )202118168U,      (u32 const   )320025894U,      (u32 const   )3974901699U, 
        (u32 const   )1600119230U,      (u32 const   )2543297077U,      (u32 const   )1145359496U,      (u32 const   )387397934U, 
        (u32 const   )3301201811U,      (u32 const   )2812801621U,      (u32 const   )2122220284U,      (u32 const   )1027426170U, 
        (u32 const   )1684319432U,      (u32 const   )1566435258U,      (u32 const   )421079858U,      (u32 const   )1936954854U, 
        (u32 const   )1616945344U,      (u32 const   )2172753945U,      (u32 const   )1330631070U,      (u32 const   )3705438115U, 
        (u32 const   )572679748U,      (u32 const   )707427924U,      (u32 const   )2425400123U,      (u32 const   )2290647819U, 
        (u32 const   )1179044492U,      (u32 const   )4008585671U,      (u32 const   )3099120491U,      (u32 const   )336870440U, 
        (u32 const   )3739122087U,      (u32 const   )1583276732U,      (u32 const   )185277718U,      (u32 const   )3688593069U, 
        (u32 const   )3772791771U,      (u32 const   )842159716U,      (u32 const   )976899700U,      (u32 const   )168435220U, 
        (u32 const   )1229577106U,      (u32 const   )101059084U,      (u32 const   )606366792U,      (u32 const   )1549591736U, 
        (u32 const   )3267517855U,      (u32 const   )3553849021U,      (u32 const   )2897014595U,      (u32 const   )1650632388U, 
        (u32 const   )2442242105U,      (u32 const   )2509612081U,      (u32 const   )3840161747U,      (u32 const   )2038008818U, 
        (u32 const   )3890688725U,      (u32 const   )3368567691U,      (u32 const   )926374254U,      (u32 const   )1835907034U, 
        (u32 const   )2374863873U,      (u32 const   )3587531953U,      (u32 const   )1313788572U,      (u32 const   )2846482505U, 
        (u32 const   )1819063512U,      (u32 const   )1448540844U,      (u32 const   )4109633523U,      (u32 const   )3941213647U, 
        (u32 const   )1701162954U,      (u32 const   )2054852340U,      (u32 const   )2930698567U,      (u32 const   )134748176U, 
        (u32 const   )3132806511U,      (u32 const   )2021165296U,      (u32 const   )623210314U,      (u32 const   )774795868U, 
        (u32 const   )471606328U,      (u32 const   )2795958615U,      (u32 const   )3031746419U,      (u32 const   )3334885783U, 
        (u32 const   )3907527627U,      (u32 const   )3722280097U,      (u32 const   )1953799400U,      (u32 const   )522133822U, 
        (u32 const   )1263263126U,      (u32 const   )3183336545U,      (u32 const   )2341176845U,      (u32 const   )2324333839U, 
        (u32 const   )1886425312U,      (u32 const   )1044267644U,      (u32 const   )3048588401U,      (u32 const   )1718004428U, 
        (u32 const   )1212733584U,      (u32 const   )50529542U,      (u32 const   )4143317495U,      (u32 const   )235803164U, 
        (u32 const   )1633788866U,      (u32 const   )892690282U,      (u32 const   )1465383342U,      (u32 const   )3115962473U, 
        (u32 const   )2256965911U,      (u32 const   )3250673817U,      (u32 const   )488449850U,      (u32 const   )2661202215U, 
        (u32 const   )3789633753U,      (u32 const   )4177007595U,      (u32 const   )2560144171U,      (u32 const   )286339874U, 
        (u32 const   )1768537042U,      (u32 const   )3654906025U,      (u32 const   )2391705863U,      (u32 const   )2492770099U, 
        (u32 const   )2610673197U,      (u32 const   )505291324U,      (u32 const   )2273808917U,      (u32 const   )3924369609U, 
        (u32 const   )3469625735U,      (u32 const   )1431699370U,      (u32 const   )673740880U,      (u32 const   )3755965093U, 
        (u32 const   )2358021891U,      (u32 const   )2711746649U,      (u32 const   )2307489801U,      (u32 const   )218961690U, 
        (u32 const   )3217021541U,      (u32 const   )3873845719U,      (u32 const   )1111672452U,      (u32 const   )1751693520U, 
        (u32 const   )1094828930U,      (u32 const   )2576986153U,      (u32 const   )757954394U,      (u32 const   )252645662U, 
        (u32 const   )2964376443U,      (u32 const   )1414855848U,      (u32 const   )3149649517U,      (u32 const   )370555436U};
#line 316 "rijndael.c"
static u32 const   Te4[256]  = 
#line 316
  {      (u32 const   )1667457891U,      (u32 const   )2088533116U,      (u32 const   )2004318071U,      (u32 const   )2071690107U, 
        (u32 const   )4076008178U,      (u32 const   )1802201963U,      (u32 const   )1869573999U,      (u32 const   )3318072773U, 
        (u32 const   )808464432U,      (u32 const   )16843009U,      (u32 const   )1734829927U,      (u32 const   )724249387U, 
        (u32 const   )4278124286U,      (u32 const   )3621246935U,      (u32 const   )2880154539U,      (u32 const   )1987475062U, 
        (u32 const   )3402287818U,      (u32 const   )2189591170U,      (u32 const   )3385444809U,      (u32 const   )2105376125U, 
        (u32 const   )4210752250U,      (u32 const   )1499027801U,      (u32 const   )1195853639U,      (u32 const   )4042322160U, 
        (u32 const   )2913840557U,      (u32 const   )3570717908U,      (u32 const   )2728567458U,      (u32 const   )2947526575U, 
        (u32 const   )2627509404U,      (u32 const   )2762253476U,      (u32 const   )1920103026U,      (u32 const   )3233857728U, 
        (u32 const   )3082270647U,      (u32 const   )4261281277U,      (u32 const   )2475922323U,      (u32 const   )640034342U, 
        (u32 const   )909522486U,      (u32 const   )1061109567U,      (u32 const   )4160223223U,      (u32 const   )3435973836U, 
        (u32 const   )875836468U,      (u32 const   )2779096485U,      (u32 const   )3857049061U,      (u32 const   )4059165169U, 
        (u32 const   )1903260017U,      (u32 const   )3638089944U,      (u32 const   )825307441U,      (u32 const   )353703189U, 
        (u32 const   )67372036U,      (u32 const   )3351758791U,      (u32 const   )589505315U,      (u32 const   )3284386755U, 
        (u32 const   )404232216U,      (u32 const   )2526451350U,      (u32 const   )84215045U,      (u32 const   )2593823386U, 
        (u32 const   )117901063U,      (u32 const   )303174162U,      (u32 const   )2155905152U,      (u32 const   )3806520034U, 
        (u32 const   )3958107115U,      (u32 const   )656877351U,      (u32 const   )2998055602U,      (u32 const   )1970632053U, 
        (u32 const   )151587081U,      (u32 const   )2206434179U,      (u32 const   )741092396U,      (u32 const   )437918234U, 
        (u32 const   )454761243U,      (u32 const   )1852730990U,      (u32 const   )1515870810U,      (u32 const   )2694881440U, 
        (u32 const   )1381126738U,      (u32 const   )993737531U,      (u32 const   )3604403926U,      (u32 const   )3014898611U, 
        (u32 const   )690563369U,      (u32 const   )3823363043U,      (u32 const   )791621423U,      (u32 const   )2223277188U, 
        (u32 const   )1397969747U,      (u32 const   )3520188881U,      (u32 const   )0U,      (u32 const   )3991793133U, 
        (u32 const   )538976288U,      (u32 const   )4244438268U,      (u32 const   )2981212593U,      (u32 const   )1532713819U, 
        (u32 const   )1785358954U,      (u32 const   )3419130827U,      (u32 const   )3200171710U,      (u32 const   )960051513U, 
        (u32 const   )1246382666U,      (u32 const   )1280068684U,      (u32 const   )1482184792U,      (u32 const   )3486502863U, 
        (u32 const   )3503345872U,      (u32 const   )4025479151U,      (u32 const   )2863311530U,      (u32 const   )4227595259U, 
        (u32 const   )1128481603U,      (u32 const   )1296911693U,      (u32 const   )858993459U,      (u32 const   )2240120197U, 
        (u32 const   )1162167621U,      (u32 const   )4193909241U,      (u32 const   )33686018U,      (u32 const   )2139062143U, 
        (u32 const   )1347440720U,      (u32 const   )1010580540U,      (u32 const   )2678038431U,      (u32 const   )2829625512U, 
        (u32 const   )1364283729U,      (u32 const   )2745410467U,      (u32 const   )1077952576U,      (u32 const   )2408550287U, 
        (u32 const   )2459079314U,      (u32 const   )2644352413U,      (u32 const   )943208504U,      (u32 const   )4126537205U, 
        (u32 const   )3166485692U,      (u32 const   )3065427638U,      (u32 const   )3671775962U,      (u32 const   )555819297U, 
        (u32 const   )269488144U,      (u32 const   )4294967295U,      (u32 const   )4092851187U,      (u32 const   )3537031890U, 
        (u32 const   )3452816845U,      (u32 const   )202116108U,      (u32 const   )320017171U,      (u32 const   )3974950124U, 
        (u32 const   )1600085855U,      (u32 const   )2543294359U,      (u32 const   )1145324612U,      (u32 const   )387389207U, 
        (u32 const   )3301229764U,      (u32 const   )2812782503U,      (u32 const   )2122219134U,      (u32 const   )1027423549U, 
        (u32 const   )1684300900U,      (u32 const   )1566399837U,      (u32 const   )421075225U,      (u32 const   )1936946035U, 
        (u32 const   )1616928864U,      (u32 const   )2172748161U,      (u32 const   )1330597711U,      (u32 const   )3705461980U, 
        (u32 const   )572662306U,      (u32 const   )707406378U,      (u32 const   )2425393296U,      (u32 const   )2290649224U, 
        (u32 const   )1179010630U,      (u32 const   )4008636142U,      (u32 const   )3099113656U,      (u32 const   )336860180U, 
        (u32 const   )3739147998U,      (u32 const   )1583242846U,      (u32 const   )185273099U,      (u32 const   )3688618971U, 
        (u32 const   )3772834016U,      (u32 const   )842150450U,      (u32 const   )976894522U,      (u32 const   )168430090U, 
        (u32 const   )1229539657U,      (u32 const   )101058054U,      (u32 const   )606348324U,      (u32 const   )1549556828U, 
        (u32 const   )3267543746U,      (u32 const   )3553874899U,      (u32 const   )2896997548U,      (u32 const   )1650614882U, 
        (u32 const   )2442236305U,      (u32 const   )2509608341U,      (u32 const   )3840206052U,      (u32 const   )2038004089U, 
        (u32 const   )3890735079U,      (u32 const   )3368601800U,      (u32 const   )926365495U,      (u32 const   )1835887981U, 
        (u32 const   )2374864269U,      (u32 const   )3587560917U,      (u32 const   )1313754702U,      (u32 const   )2846468521U, 
        (u32 const   )1819044972U,      (u32 const   )1448498774U,      (u32 const   )4109694196U,      (u32 const   )3941264106U, 
        (u32 const   )1701143909U,      (u32 const   )2054847098U,      (u32 const   )2930683566U,      (u32 const   )134744072U, 
        (u32 const   )3132799674U,      (u32 const   )2021161080U,      (u32 const   )623191333U,      (u32 const   )774778414U, 
        (u32 const   )471604252U,      (u32 const   )2795939494U,      (u32 const   )3031741620U,      (u32 const   )3334915782U, 
        (u32 const   )3907578088U,      (u32 const   )3722304989U,      (u32 const   )1953789044U,      (u32 const   )522133279U, 
        (u32 const   )1263225675U,      (u32 const   )3183328701U,      (u32 const   )2341178251U,      (u32 const   )2324335242U, 
        (u32 const   )1886417008U,      (u32 const   )1044266558U,      (u32 const   )3048584629U,      (u32 const   )1717986918U, 
        (u32 const   )1212696648U,      (u32 const   )50529027U,      (u32 const   )4143380214U,      (u32 const   )235802126U, 
        (u32 const   )1633771873U,      (u32 const   )892679477U,      (u32 const   )1465341783U,      (u32 const   )3115956665U, 
        (u32 const   )2256963206U,      (u32 const   )3250700737U,      (u32 const   )488447261U,      (u32 const   )2661195422U, 
        (u32 const   )3789677025U,      (u32 const   )4177066232U,      (u32 const   )2560137368U,      (u32 const   )286331153U, 
        (u32 const   )1768515945U,      (u32 const   )3654932953U,      (u32 const   )2391707278U,      (u32 const   )2492765332U, 
        (u32 const   )2610666395U,      (u32 const   )505290270U,      (u32 const   )2273806215U,      (u32 const   )3924421097U, 
        (u32 const   )3469659854U,      (u32 const   )1431655765U,      (u32 const   )673720360U,      (u32 const   )3755991007U, 
        (u32 const   )2358021260U,      (u32 const   )2711724449U,      (u32 const   )2307492233U,      (u32 const   )218959117U, 
        (u32 const   )3217014719U,      (u32 const   )3873892070U,      (u32 const   )1111638594U,      (u32 const   )1751672936U, 
        (u32 const   )1094795585U,      (u32 const   )2576980377U,      (u32 const   )757935405U,      (u32 const   )252645135U, 
        (u32 const   )2964369584U,      (u32 const   )1414812756U,      (u32 const   )3149642683U,      (u32 const   )370546198U};
#line 382 "rijndael.c"
static u32 const   Td0[256]  = 
#line 382
  {      (u32 const   )1374988112U,      (u32 const   )2118214995U,      (u32 const   )437757123U,      (u32 const   )975658646U, 
        (u32 const   )1001089995U,      (u32 const   )530400753U,      (u32 const   )2902087851U,      (u32 const   )1273168787U, 
        (u32 const   )540080725U,      (u32 const   )2910219766U,      (u32 const   )2295101073U,      (u32 const   )4110568485U, 
        (u32 const   )1340463100U,      (u32 const   )3307916247U,      (u32 const   )641025152U,      (u32 const   )3043140495U, 
        (u32 const   )3736164937U,      (u32 const   )632953703U,      (u32 const   )1172967064U,      (u32 const   )1576976609U, 
        (u32 const   )3274667266U,      (u32 const   )2169303058U,      (u32 const   )2370213795U,      (u32 const   )1809054150U, 
        (u32 const   )59727847U,      (u32 const   )361929877U,      (u32 const   )3211623147U,      (u32 const   )2505202138U, 
        (u32 const   )3569255213U,      (u32 const   )1484005843U,      (u32 const   )1239443753U,      (u32 const   )2395588676U, 
        (u32 const   )1975683434U,      (u32 const   )4102977912U,      (u32 const   )2572697195U,      (u32 const   )666464733U, 
        (u32 const   )3202437046U,      (u32 const   )4035489047U,      (u32 const   )3374361702U,      (u32 const   )2110667444U, 
        (u32 const   )1675577880U,      (u32 const   )3843699074U,      (u32 const   )2538681184U,      (u32 const   )1649639237U, 
        (u32 const   )2976151520U,      (u32 const   )3144396420U,      (u32 const   )4269907996U,      (u32 const   )4178062228U, 
        (u32 const   )1883793496U,      (u32 const   )2403728665U,      (u32 const   )2497604743U,      (u32 const   )1383856311U, 
        (u32 const   )2876494627U,      (u32 const   )1917518562U,      (u32 const   )3810496343U,      (u32 const   )1716890410U, 
        (u32 const   )3001755655U,      (u32 const   )800440835U,      (u32 const   )2261089178U,      (u32 const   )3543599269U, 
        (u32 const   )807962610U,      (u32 const   )599762354U,      (u32 const   )33778362U,      (u32 const   )3977675356U, 
        (u32 const   )2328828971U,      (u32 const   )2809771154U,      (u32 const   )4077384432U,      (u32 const   )1315562145U, 
        (u32 const   )1708848333U,      (u32 const   )101039829U,      (u32 const   )3509871135U,      (u32 const   )3299278474U, 
        (u32 const   )875451293U,      (u32 const   )2733856160U,      (u32 const   )92987698U,      (u32 const   )2767645557U, 
        (u32 const   )193195065U,      (u32 const   )1080094634U,      (u32 const   )1584504582U,      (u32 const   )3178106961U, 
        (u32 const   )1042385657U,      (u32 const   )2531067453U,      (u32 const   )3711829422U,      (u32 const   )1306967366U, 
        (u32 const   )2438237621U,      (u32 const   )1908694277U,      (u32 const   )67556463U,      (u32 const   )1615861247U, 
        (u32 const   )429456164U,      (u32 const   )3602770327U,      (u32 const   )2302690252U,      (u32 const   )1742315127U, 
        (u32 const   )2968011453U,      (u32 const   )126454664U,      (u32 const   )3877198648U,      (u32 const   )2043211483U, 
        (u32 const   )2709260871U,      (u32 const   )2084704233U,      (u32 const   )4169408201U,      (u32 const   )0U, 
        (u32 const   )159417987U,      (u32 const   )841739592U,      (u32 const   )504459436U,      (u32 const   )1817866830U, 
        (u32 const   )4245618683U,      (u32 const   )260388950U,      (u32 const   )1034867998U,      (u32 const   )908933415U, 
        (u32 const   )168810852U,      (u32 const   )1750902305U,      (u32 const   )2606453969U,      (u32 const   )607530554U, 
        (u32 const   )202008497U,      (u32 const   )2472011535U,      (u32 const   )3035535058U,      (u32 const   )463180190U, 
        (u32 const   )2160117071U,      (u32 const   )1641816226U,      (u32 const   )1517767529U,      (u32 const   )470948374U, 
        (u32 const   )3801332234U,      (u32 const   )3231722213U,      (u32 const   )1008918595U,      (u32 const   )303765277U, 
        (u32 const   )235474187U,      (u32 const   )4069246893U,      (u32 const   )766945465U,      (u32 const   )337553864U, 
        (u32 const   )1475418501U,      (u32 const   )2943682380U,      (u32 const   )4003061179U,      (u32 const   )2743034109U, 
        (u32 const   )4144047775U,      (u32 const   )1551037884U,      (u32 const   )1147550661U,      (u32 const   )1543208500U, 
        (u32 const   )2336434550U,      (u32 const   )3408119516U,      (u32 const   )3069049960U,      (u32 const   )3102011747U, 
        (u32 const   )3610369226U,      (u32 const   )1113818384U,      (u32 const   )328671808U,      (u32 const   )2227573024U, 
        (u32 const   )2236228733U,      (u32 const   )3535486456U,      (u32 const   )2935566865U,      (u32 const   )3341394285U, 
        (u32 const   )496906059U,      (u32 const   )3702665459U,      (u32 const   )226906860U,      (u32 const   )2009195472U, 
        (u32 const   )733156972U,      (u32 const   )2842737049U,      (u32 const   )294930682U,      (u32 const   )1206477858U, 
        (u32 const   )2835123396U,      (u32 const   )2700099354U,      (u32 const   )1451044056U,      (u32 const   )573804783U, 
        (u32 const   )2269728455U,      (u32 const   )3644379585U,      (u32 const   )2362090238U,      (u32 const   )2564033334U, 
        (u32 const   )2801107407U,      (u32 const   )2776292904U,      (u32 const   )3669462566U,      (u32 const   )1068351396U, 
        (u32 const   )742039012U,      (u32 const   )1350078989U,      (u32 const   )1784663195U,      (u32 const   )1417561698U, 
        (u32 const   )4136440770U,      (u32 const   )2430122216U,      (u32 const   )775550814U,      (u32 const   )2193862645U, 
        (u32 const   )2673705150U,      (u32 const   )1775276924U,      (u32 const   )1876241833U,      (u32 const   )3475313331U, 
        (u32 const   )3366754619U,      (u32 const   )270040487U,      (u32 const   )3902563182U,      (u32 const   )3678124923U, 
        (u32 const   )3441850377U,      (u32 const   )1851332852U,      (u32 const   )3969562369U,      (u32 const   )2203032232U, 
        (u32 const   )3868552805U,      (u32 const   )2868897406U,      (u32 const   )566021896U,      (u32 const   )4011190502U, 
        (u32 const   )3135740889U,      (u32 const   )1248802510U,      (u32 const   )3936291284U,      (u32 const   )699432150U, 
        (u32 const   )832877231U,      (u32 const   )708780849U,      (u32 const   )3332740144U,      (u32 const   )899835584U, 
        (u32 const   )1951317047U,      (u32 const   )4236429990U,      (u32 const   )3767586992U,      (u32 const   )866637845U, 
        (u32 const   )4043610186U,      (u32 const   )1106041591U,      (u32 const   )2144161806U,      (u32 const   )395441711U, 
        (u32 const   )1984812685U,      (u32 const   )1139781709U,      (u32 const   )3433712980U,      (u32 const   )3835036895U, 
        (u32 const   )2664543715U,      (u32 const   )1282050075U,      (u32 const   )3240894392U,      (u32 const   )1181045119U, 
        (u32 const   )2640243204U,      (u32 const   )25965917U,      (u32 const   )4203181171U,      (u32 const   )4211818798U, 
        (u32 const   )3009879386U,      (u32 const   )2463879762U,      (u32 const   )3910161971U,      (u32 const   )1842759443U, 
        (u32 const   )2597806476U,      (u32 const   )933301370U,      (u32 const   )1509430414U,      (u32 const   )3943906441U, 
        (u32 const   )3467192302U,      (u32 const   )3076639029U,      (u32 const   )3776767469U,      (u32 const   )2051518780U, 
        (u32 const   )2631065433U,      (u32 const   )1441952575U,      (u32 const   )404016761U,      (u32 const   )1942435775U, 
        (u32 const   )1408749034U,      (u32 const   )1610459739U,      (u32 const   )3745345300U,      (u32 const   )2017778566U, 
        (u32 const   )3400528769U,      (u32 const   )3110650942U,      (u32 const   )941896748U,      (u32 const   )3265478751U, 
        (u32 const   )371049330U,      (u32 const   )3168937228U,      (u32 const   )675039627U,      (u32 const   )4279080257U, 
        (u32 const   )967311729U,      (u32 const   )135050206U,      (u32 const   )3635733660U,      (u32 const   )1683407248U, 
        (u32 const   )2076935265U,      (u32 const   )3576870512U,      (u32 const   )1215061108U,      (u32 const   )3501741890U};
#line 448 "rijndael.c"
static u32 const   Td1[256]  = 
#line 448
  {      (u32 const   )1347548327U,      (u32 const   )1400783205U,      (u32 const   )3273267108U,      (u32 const   )2520393566U, 
        (u32 const   )3409685355U,      (u32 const   )4045380933U,      (u32 const   )2880240216U,      (u32 const   )2471224067U, 
        (u32 const   )1428173050U,      (u32 const   )4138563181U,      (u32 const   )2441661558U,      (u32 const   )636813900U, 
        (u32 const   )4233094615U,      (u32 const   )3620022987U,      (u32 const   )2149987652U,      (u32 const   )2411029155U, 
        (u32 const   )1239331162U,      (u32 const   )1730525723U,      (u32 const   )2554718734U,      (u32 const   )3781033664U, 
        (u32 const   )46346101U,      (u32 const   )310463728U,      (u32 const   )2743944855U,      (u32 const   )3328955385U, 
        (u32 const   )3875770207U,      (u32 const   )2501218972U,      (u32 const   )3955191162U,      (u32 const   )3667219033U, 
        (u32 const   )768917123U,      (u32 const   )3545789473U,      (u32 const   )692707433U,      (u32 const   )1150208456U, 
        (u32 const   )1786102409U,      (u32 const   )2029293177U,      (u32 const   )1805211710U,      (u32 const   )3710368113U, 
        (u32 const   )3065962831U,      (u32 const   )401639597U,      (u32 const   )1724457132U,      (u32 const   )3028143674U, 
        (u32 const   )409198410U,      (u32 const   )2196052529U,      (u32 const   )1620529459U,      (u32 const   )1164071807U, 
        (u32 const   )3769721975U,      (u32 const   )2226875310U,      (u32 const   )486441376U,      (u32 const   )2499348523U, 
        (u32 const   )1483753576U,      (u32 const   )428819965U,      (u32 const   )2274680428U,      (u32 const   )3075636216U, 
        (u32 const   )598438867U,      (u32 const   )3799141122U,      (u32 const   )1474502543U,      (u32 const   )711349675U, 
        (u32 const   )129166120U,      (u32 const   )53458370U,      (u32 const   )2592523643U,      (u32 const   )2782082824U, 
        (u32 const   )4063242375U,      (u32 const   )2988687269U,      (u32 const   )3120694122U,      (u32 const   )1559041666U, 
        (u32 const   )730517276U,      (u32 const   )2460449204U,      (u32 const   )4042459122U,      (u32 const   )2706270690U, 
        (u32 const   )3446004468U,      (u32 const   )3573941694U,      (u32 const   )533804130U,      (u32 const   )2328143614U, 
        (u32 const   )2637442643U,      (u32 const   )2695033685U,      (u32 const   )839224033U,      (u32 const   )1973745387U, 
        (u32 const   )957055980U,      (u32 const   )2856345839U,      (u32 const   )106852767U,      (u32 const   )1371368976U, 
        (u32 const   )4181598602U,      (u32 const   )1033297158U,      (u32 const   )2933734917U,      (u32 const   )1179510461U, 
        (u32 const   )3046200461U,      (u32 const   )91341917U,      (u32 const   )1862534868U,      (u32 const   )4284502037U, 
        (u32 const   )605657339U,      (u32 const   )2547432937U,      (u32 const   )3431546947U,      (u32 const   )2003294622U, 
        (u32 const   )3182487618U,      (u32 const   )2282195339U,      (u32 const   )954669403U,      (u32 const   )3682191598U, 
        (u32 const   )1201765386U,      (u32 const   )3917234703U,      (u32 const   )3388507166U,      (u32 const   )0U, 
        (u32 const   )2198438022U,      (u32 const   )1211247597U,      (u32 const   )2887651696U,      (u32 const   )1315723890U, 
        (u32 const   )4227665663U,      (u32 const   )1443857720U,      (u32 const   )507358933U,      (u32 const   )657861945U, 
        (u32 const   )1678381017U,      (u32 const   )560487590U,      (u32 const   )3516619604U,      (u32 const   )975451694U, 
        (u32 const   )2970356327U,      (u32 const   )261314535U,      (u32 const   )3535072918U,      (u32 const   )2652609425U, 
        (u32 const   )1333838021U,      (u32 const   )2724322336U,      (u32 const   )1767536459U,      (u32 const   )370938394U, 
        (u32 const   )182621114U,      (u32 const   )3854606378U,      (u32 const   )1128014560U,      (u32 const   )487725847U, 
        (u32 const   )185469197U,      (u32 const   )2918353863U,      (u32 const   )3106780840U,      (u32 const   )3356761769U, 
        (u32 const   )2237133081U,      (u32 const   )1286567175U,      (u32 const   )3152976349U,      (u32 const   )4255350624U, 
        (u32 const   )2683765030U,      (u32 const   )3160175349U,      (u32 const   )3309594171U,      (u32 const   )878443390U, 
        (u32 const   )1988838185U,      (u32 const   )3704300486U,      (u32 const   )1756818940U,      (u32 const   )1673061617U, 
        (u32 const   )3403100636U,      (u32 const   )272786309U,      (u32 const   )1075025698U,      (u32 const   )545572369U, 
        (u32 const   )2105887268U,      (u32 const   )4174560061U,      (u32 const   )296679730U,      (u32 const   )1841768865U, 
        (u32 const   )1260232239U,      (u32 const   )4091327024U,      (u32 const   )3960309330U,      (u32 const   )3497509347U, 
        (u32 const   )1814803222U,      (u32 const   )2578018489U,      (u32 const   )4195456072U,      (u32 const   )575138148U, 
        (u32 const   )3299409036U,      (u32 const   )446754879U,      (u32 const   )3629546796U,      (u32 const   )4011996048U, 
        (u32 const   )3347532110U,      (u32 const   )3252238545U,      (u32 const   )4270639778U,      (u32 const   )915985419U, 
        (u32 const   )3483825537U,      (u32 const   )681933534U,      (u32 const   )651868046U,      (u32 const   )2755636671U, 
        (u32 const   )3828103837U,      (u32 const   )223377554U,      (u32 const   )2607439820U,      (u32 const   )1649704518U, 
        (u32 const   )3270937875U,      (u32 const   )3901806776U,      (u32 const   )1580087799U,      (u32 const   )4118987695U, 
        (u32 const   )3198115200U,      (u32 const   )2087309459U,      (u32 const   )2842678573U,      (u32 const   )3016697106U, 
        (u32 const   )1003007129U,      (u32 const   )2802849917U,      (u32 const   )1860738147U,      (u32 const   )2077965243U, 
        (u32 const   )164439672U,      (u32 const   )4100872472U,      (u32 const   )32283319U,      (u32 const   )2827177882U, 
        (u32 const   )1709610350U,      (u32 const   )2125135846U,      (u32 const   )136428751U,      (u32 const   )3874428392U, 
        (u32 const   )3652904859U,      (u32 const   )3460984630U,      (u32 const   )3572145929U,      (u32 const   )3593056380U, 
        (u32 const   )2939266226U,      (u32 const   )824852259U,      (u32 const   )818324884U,      (u32 const   )3224740454U, 
        (u32 const   )930369212U,      (u32 const   )2801566410U,      (u32 const   )2967507152U,      (u32 const   )355706840U, 
        (u32 const   )1257309336U,      (u32 const   )4148292826U,      (u32 const   )243256656U,      (u32 const   )790073846U, 
        (u32 const   )2373340630U,      (u32 const   )1296297904U,      (u32 const   )1422699085U,      (u32 const   )3756299780U, 
        (u32 const   )3818836405U,      (u32 const   )457992840U,      (u32 const   )3099667487U,      (u32 const   )2135319889U, 
        (u32 const   )77422314U,      (u32 const   )1560382517U,      (u32 const   )1945798516U,      (u32 const   )788204353U, 
        (u32 const   )1521706781U,      (u32 const   )1385356242U,      (u32 const   )870912086U,      (u32 const   )325965383U, 
        (u32 const   )2358957921U,      (u32 const   )2050466060U,      (u32 const   )2388260884U,      (u32 const   )2313884476U, 
        (u32 const   )4006521127U,      (u32 const   )901210569U,      (u32 const   )3990953189U,      (u32 const   )1014646705U, 
        (u32 const   )1503449823U,      (u32 const   )1062597235U,      (u32 const   )2031621326U,      (u32 const   )3212035895U, 
        (u32 const   )3931371469U,      (u32 const   )1533017514U,      (u32 const   )350174575U,      (u32 const   )2256028891U, 
        (u32 const   )2177544179U,      (u32 const   )1052338372U,      (u32 const   )741876788U,      (u32 const   )1606591296U, 
        (u32 const   )1914052035U,      (u32 const   )213705253U,      (u32 const   )2334669897U,      (u32 const   )1107234197U, 
        (u32 const   )1899603969U,      (u32 const   )3725069491U,      (u32 const   )2631447780U,      (u32 const   )2422494913U, 
        (u32 const   )1635502980U,      (u32 const   )1893020342U,      (u32 const   )1950903388U,      (u32 const   )1120974935U};
#line 514 "rijndael.c"
static u32 const   Td2[256]  = 
#line 514
  {      (u32 const   )2807058932U,      (u32 const   )1699970625U,      (u32 const   )2764249623U,      (u32 const   )1586903591U, 
        (u32 const   )1808481195U,      (u32 const   )1173430173U,      (u32 const   )1487645946U,      (u32 const   )59984867U, 
        (u32 const   )4199882800U,      (u32 const   )1844882806U,      (u32 const   )1989249228U,      (u32 const   )1277555970U, 
        (u32 const   )3623636965U,      (u32 const   )3419915562U,      (u32 const   )1149249077U,      (u32 const   )2744104290U, 
        (u32 const   )1514790577U,      (u32 const   )459744698U,      (u32 const   )244860394U,      (u32 const   )3235995134U, 
        (u32 const   )1963115311U,      (u32 const   )4027744588U,      (u32 const   )2544078150U,      (u32 const   )4190530515U, 
        (u32 const   )1608975247U,      (u32 const   )2627016082U,      (u32 const   )2062270317U,      (u32 const   )1507497298U, 
        (u32 const   )2200818878U,      (u32 const   )567498868U,      (u32 const   )1764313568U,      (u32 const   )3359936201U, 
        (u32 const   )2305455554U,      (u32 const   )2037970062U,      (u32 const   )1047239000U,      (u32 const   )1910319033U, 
        (u32 const   )1337376481U,      (u32 const   )2904027272U,      (u32 const   )2892417312U,      (u32 const   )984907214U, 
        (u32 const   )1243112415U,      (u32 const   )830661914U,      (u32 const   )861968209U,      (u32 const   )2135253587U, 
        (u32 const   )2011214180U,      (u32 const   )2927934315U,      (u32 const   )2686254721U,      (u32 const   )731183368U, 
        (u32 const   )1750626376U,      (u32 const   )4246310725U,      (u32 const   )1820824798U,      (u32 const   )4172763771U, 
        (u32 const   )3542330227U,      (u32 const   )48394827U,      (u32 const   )2404901663U,      (u32 const   )2871682645U, 
        (u32 const   )671593195U,      (u32 const   )3254988725U,      (u32 const   )2073724613U,      (u32 const   )145085239U, 
        (u32 const   )2280796200U,      (u32 const   )2779915199U,      (u32 const   )1790575107U,      (u32 const   )2187128086U, 
        (u32 const   )472615631U,      (u32 const   )3029510009U,      (u32 const   )4075877127U,      (u32 const   )3802222185U, 
        (u32 const   )4107101658U,      (u32 const   )3201631749U,      (u32 const   )1646252340U,      (u32 const   )4270507174U, 
        (u32 const   )1402811438U,      (u32 const   )1436590835U,      (u32 const   )3778151818U,      (u32 const   )3950355702U, 
        (u32 const   )3963161475U,      (u32 const   )4020912224U,      (u32 const   )2667994737U,      (u32 const   )273792366U, 
        (u32 const   )2331590177U,      (u32 const   )104699613U,      (u32 const   )95345982U,      (u32 const   )3175501286U, 
        (u32 const   )2377486676U,      (u32 const   )1560637892U,      (u32 const   )3564045318U,      (u32 const   )369057872U, 
        (u32 const   )4213447064U,      (u32 const   )3919042237U,      (u32 const   )1137477952U,      (u32 const   )2658625497U, 
        (u32 const   )1119727848U,      (u32 const   )2340947849U,      (u32 const   )1530455833U,      (u32 const   )4007360968U, 
        (u32 const   )172466556U,      (u32 const   )266959938U,      (u32 const   )516552836U,      (u32 const   )0U, 
        (u32 const   )2256734592U,      (u32 const   )3980931627U,      (u32 const   )1890328081U,      (u32 const   )1917742170U, 
        (u32 const   )4294704398U,      (u32 const   )945164165U,      (u32 const   )3575528878U,      (u32 const   )958871085U, 
        (u32 const   )3647212047U,      (u32 const   )2787207260U,      (u32 const   )1423022939U,      (u32 const   )775562294U, 
        (u32 const   )1739656202U,      (u32 const   )3876557655U,      (u32 const   )2530391278U,      (u32 const   )2443058075U, 
        (u32 const   )3310321856U,      (u32 const   )547512796U,      (u32 const   )1265195639U,      (u32 const   )437656594U, 
        (u32 const   )3121275539U,      (u32 const   )719700128U,      (u32 const   )3762502690U,      (u32 const   )387781147U, 
        (u32 const   )218828297U,      (u32 const   )3350065803U,      (u32 const   )2830708150U,      (u32 const   )2848461854U, 
        (u32 const   )428169201U,      (u32 const   )122466165U,      (u32 const   )3720081049U,      (u32 const   )1627235199U, 
        (u32 const   )648017665U,      (u32 const   )4122762354U,      (u32 const   )1002783846U,      (u32 const   )2117360635U, 
        (u32 const   )695634755U,      (u32 const   )3336358691U,      (u32 const   )4234721005U,      (u32 const   )4049844452U, 
        (u32 const   )3704280881U,      (u32 const   )2232435299U,      (u32 const   )574624663U,      (u32 const   )287343814U, 
        (u32 const   )612205898U,      (u32 const   )1039717051U,      (u32 const   )840019705U,      (u32 const   )2708326185U, 
        (u32 const   )793451934U,      (u32 const   )821288114U,      (u32 const   )1391201670U,      (u32 const   )3822090177U, 
        (u32 const   )376187827U,      (u32 const   )3113855344U,      (u32 const   )1224348052U,      (u32 const   )1679968233U, 
        (u32 const   )2361698556U,      (u32 const   )1058709744U,      (u32 const   )752375421U,      (u32 const   )2431590963U, 
        (u32 const   )1321699145U,      (u32 const   )3519142200U,      (u32 const   )2734591178U,      (u32 const   )188127444U, 
        (u32 const   )2177869557U,      (u32 const   )3727205754U,      (u32 const   )2384911031U,      (u32 const   )3215212461U, 
        (u32 const   )2648976442U,      (u32 const   )2450346104U,      (u32 const   )3432737375U,      (u32 const   )1180849278U, 
        (u32 const   )331544205U,      (u32 const   )3102249176U,      (u32 const   )4150144569U,      (u32 const   )2952102595U, 
        (u32 const   )2159976285U,      (u32 const   )2474404304U,      (u32 const   )766078933U,      (u32 const   )313773861U, 
        (u32 const   )2570832044U,      (u32 const   )2108100632U,      (u32 const   )1668212892U,      (u32 const   )3145456443U, 
        (u32 const   )2013908262U,      (u32 const   )418672217U,      (u32 const   )3070356634U,      (u32 const   )2594734927U, 
        (u32 const   )1852171925U,      (u32 const   )3867060991U,      (u32 const   )3473416636U,      (u32 const   )3907448597U, 
        (u32 const   )2614737639U,      (u32 const   )919489135U,      (u32 const   )164948639U,      (u32 const   )2094410160U, 
        (u32 const   )2997825956U,      (u32 const   )590424639U,      (u32 const   )2486224549U,      (u32 const   )1723872674U, 
        (u32 const   )3157750862U,      (u32 const   )3399941250U,      (u32 const   )3501252752U,      (u32 const   )3625268135U, 
        (u32 const   )2555048196U,      (u32 const   )3673637356U,      (u32 const   )1343127501U,      (u32 const   )4130281361U, 
        (u32 const   )3599595085U,      (u32 const   )2957853679U,      (u32 const   )1297403050U,      (u32 const   )81781910U, 
        (u32 const   )3051593425U,      (u32 const   )2283490410U,      (u32 const   )532201772U,      (u32 const   )1367295589U, 
        (u32 const   )3926170974U,      (u32 const   )895287692U,      (u32 const   )1953757831U,      (u32 const   )1093597963U, 
        (u32 const   )492483431U,      (u32 const   )3528626907U,      (u32 const   )1446242576U,      (u32 const   )1192455638U, 
        (u32 const   )1636604631U,      (u32 const   )209336225U,      (u32 const   )344873464U,      (u32 const   )1015671571U, 
        (u32 const   )669961897U,      (u32 const   )3375740769U,      (u32 const   )3857572124U,      (u32 const   )2973530695U, 
        (u32 const   )3747192018U,      (u32 const   )1933530610U,      (u32 const   )3464042516U,      (u32 const   )935293895U, 
        (u32 const   )3454686199U,      (u32 const   )2858115069U,      (u32 const   )1863638845U,      (u32 const   )3683022916U, 
        (u32 const   )4085369519U,      (u32 const   )3292445032U,      (u32 const   )875313188U,      (u32 const   )1080017571U, 
        (u32 const   )3279033885U,      (u32 const   )621591778U,      (u32 const   )1233856572U,      (u32 const   )2504130317U, 
        (u32 const   )24197544U,      (u32 const   )3017672716U,      (u32 const   )3835484340U,      (u32 const   )3247465558U, 
        (u32 const   )2220981195U,      (u32 const   )3060847922U,      (u32 const   )1551124588U,      (u32 const   )1463996600U};
#line 581 "rijndael.c"
static u32 const   Td3[256]  = 
#line 581
  {      (u32 const   )4104605777U,      (u32 const   )1097159550U,      (u32 const   )396673818U,      (u32 const   )660510266U, 
        (u32 const   )2875968315U,      (u32 const   )2638606623U,      (u32 const   )4200115116U,      (u32 const   )3808662347U, 
        (u32 const   )821712160U,      (u32 const   )1986918061U,      (u32 const   )3430322568U,      (u32 const   )38544885U, 
        (u32 const   )3856137295U,      (u32 const   )718002117U,      (u32 const   )893681702U,      (u32 const   )1654886325U, 
        (u32 const   )2975484382U,      (u32 const   )3122358053U,      (u32 const   )3926825029U,      (u32 const   )4274053469U, 
        (u32 const   )796197571U,      (u32 const   )1290801793U,      (u32 const   )1184342925U,      (u32 const   )3556361835U, 
        (u32 const   )2405426947U,      (u32 const   )2459735317U,      (u32 const   )1836772287U,      (u32 const   )1381620373U, 
        (u32 const   )3196267988U,      (u32 const   )1948373848U,      (u32 const   )3764988233U,      (u32 const   )3385345166U, 
        (u32 const   )3263785589U,      (u32 const   )2390325492U,      (u32 const   )1480485785U,      (u32 const   )3111247143U, 
        (u32 const   )3780097726U,      (u32 const   )2293045232U,      (u32 const   )548169417U,      (u32 const   )3459953789U, 
        (u32 const   )3746175075U,      (u32 const   )439452389U,      (u32 const   )1362321559U,      (u32 const   )1400849762U, 
        (u32 const   )1685577905U,      (u32 const   )1806599355U,      (u32 const   )2174754046U,      (u32 const   )137073913U, 
        (u32 const   )1214797936U,      (u32 const   )1174215055U,      (u32 const   )3731654548U,      (u32 const   )2079897426U, 
        (u32 const   )1943217067U,      (u32 const   )1258480242U,      (u32 const   )529487843U,      (u32 const   )1437280870U, 
        (u32 const   )3945269170U,      (u32 const   )3049390895U,      (u32 const   )3313212038U,      (u32 const   )923313619U, 
        (u32 const   )679998000U,      (u32 const   )3215307299U,      (u32 const   )57326082U,      (u32 const   )377642221U, 
        (u32 const   )3474729866U,      (u32 const   )2041877159U,      (u32 const   )133361907U,      (u32 const   )1776460110U, 
        (u32 const   )3673476453U,      (u32 const   )96392454U,      (u32 const   )878845905U,      (u32 const   )2801699524U, 
        (u32 const   )777231668U,      (u32 const   )4082475170U,      (u32 const   )2330014213U,      (u32 const   )4142626212U, 
        (u32 const   )2213296395U,      (u32 const   )1626319424U,      (u32 const   )1906247262U,      (u32 const   )1846563261U, 
        (u32 const   )562755902U,      (u32 const   )3708173718U,      (u32 const   )1040559837U,      (u32 const   )3871163981U, 
        (u32 const   )1418573201U,      (u32 const   )3294430577U,      (u32 const   )114585348U,      (u32 const   )1343618912U, 
        (u32 const   )2566595609U,      (u32 const   )3186202582U,      (u32 const   )1078185097U,      (u32 const   )3651041127U, 
        (u32 const   )3896688048U,      (u32 const   )2307622919U,      (u32 const   )425408743U,      (u32 const   )3371096953U, 
        (u32 const   )2081048481U,      (u32 const   )1108339068U,      (u32 const   )2216610296U,      (u32 const   )0U, 
        (u32 const   )2156299017U,      (u32 const   )736970802U,      (u32 const   )292596766U,      (u32 const   )1517440620U, 
        (u32 const   )251657213U,      (u32 const   )2235061775U,      (u32 const   )2933202493U,      (u32 const   )758720310U, 
        (u32 const   )265905162U,      (u32 const   )1554391400U,      (u32 const   )1532285339U,      (u32 const   )908999204U, 
        (u32 const   )174567692U,      (u32 const   )1474760595U,      (u32 const   )4002861748U,      (u32 const   )2610011675U, 
        (u32 const   )3234156416U,      (u32 const   )3693126241U,      (u32 const   )2001430874U,      (u32 const   )303699484U, 
        (u32 const   )2478443234U,      (u32 const   )2687165888U,      (u32 const   )585122620U,      (u32 const   )454499602U, 
        (u32 const   )151849742U,      (u32 const   )2345119218U,      (u32 const   )3064510765U,      (u32 const   )514443284U, 
        (u32 const   )4044981591U,      (u32 const   )1963412655U,      (u32 const   )2581445614U,      (u32 const   )2137062819U, 
        (u32 const   )19308535U,      (u32 const   )1928707164U,      (u32 const   )1715193156U,      (u32 const   )4219352155U, 
        (u32 const   )1126790795U,      (u32 const   )600235211U,      (u32 const   )3992742070U,      (u32 const   )3841024952U, 
        (u32 const   )836553431U,      (u32 const   )1669664834U,      (u32 const   )2535604243U,      (u32 const   )3323011204U, 
        (u32 const   )1243905413U,      (u32 const   )3141400786U,      (u32 const   )4180808110U,      (u32 const   )698445255U, 
        (u32 const   )2653899549U,      (u32 const   )2989552604U,      (u32 const   )2253581325U,      (u32 const   )3252932727U, 
        (u32 const   )3004591147U,      (u32 const   )1891211689U,      (u32 const   )2487810577U,      (u32 const   )3915653703U, 
        (u32 const   )4237083816U,      (u32 const   )4030667424U,      (u32 const   )2100090966U,      (u32 const   )865136418U, 
        (u32 const   )1229899655U,      (u32 const   )953270745U,      (u32 const   )3399679628U,      (u32 const   )3557504664U, 
        (u32 const   )4118925222U,      (u32 const   )2061379749U,      (u32 const   )3079546586U,      (u32 const   )2915017791U, 
        (u32 const   )983426092U,      (u32 const   )2022837584U,      (u32 const   )1607244650U,      (u32 const   )2118541908U, 
        (u32 const   )2366882550U,      (u32 const   )3635996816U,      (u32 const   )972512814U,      (u32 const   )3283088770U, 
        (u32 const   )1568718495U,      (u32 const   )3499326569U,      (u32 const   )3576539503U,      (u32 const   )621982671U, 
        (u32 const   )2895723464U,      (u32 const   )410887952U,      (u32 const   )2623762152U,      (u32 const   )1002142683U, 
        (u32 const   )645401037U,      (u32 const   )1494807662U,      (u32 const   )2595684844U,      (u32 const   )1335535747U, 
        (u32 const   )2507040230U,      (u32 const   )4293295786U,      (u32 const   )3167684641U,      (u32 const   )367585007U, 
        (u32 const   )3885750714U,      (u32 const   )1865862730U,      (u32 const   )2668221674U,      (u32 const   )2960971305U, 
        (u32 const   )2763173681U,      (u32 const   )1059270954U,      (u32 const   )2777952454U,      (u32 const   )2724642869U, 
        (u32 const   )1320957812U,      (u32 const   )2194319100U,      (u32 const   )2429595872U,      (u32 const   )2815956275U, 
        (u32 const   )77089521U,      (u32 const   )3973773121U,      (u32 const   )3444575871U,      (u32 const   )2448830231U, 
        (u32 const   )1305906550U,      (u32 const   )4021308739U,      (u32 const   )2857194700U,      (u32 const   )2516901860U, 
        (u32 const   )3518358430U,      (u32 const   )1787304780U,      (u32 const   )740276417U,      (u32 const   )1699839814U, 
        (u32 const   )1592394909U,      (u32 const   )2352307457U,      (u32 const   )2272556026U,      (u32 const   )188821243U, 
        (u32 const   )1729977011U,      (u32 const   )3687994002U,      (u32 const   )274084841U,      (u32 const   )3594982253U, 
        (u32 const   )3613494426U,      (u32 const   )2701949495U,      (u32 const   )4162096729U,      (u32 const   )322734571U, 
        (u32 const   )2837966542U,      (u32 const   )1640576439U,      (u32 const   )484830689U,      (u32 const   )1202797690U, 
        (u32 const   )3537852828U,      (u32 const   )4067639125U,      (u32 const   )349075736U,      (u32 const   )3342319475U, 
        (u32 const   )4157467219U,      (u32 const   )4255800159U,      (u32 const   )1030690015U,      (u32 const   )1155237496U, 
        (u32 const   )2951971274U,      (u32 const   )1757691577U,      (u32 const   )607398968U,      (u32 const   )2738905026U, 
        (u32 const   )499347990U,      (u32 const   )3794078908U,      (u32 const   )1011452712U,      (u32 const   )227885567U, 
        (u32 const   )2818666809U,      (u32 const   )213114376U,      (u32 const   )3034881240U,      (u32 const   )1455525988U, 
        (u32 const   )3414450555U,      (u32 const   )850817237U,      (u32 const   )1817998408U,      (u32 const   )3092726480U};
#line 647 "rijndael.c"
static u32 const   Td4[256]  = 
#line 647
  {      (u32 const   )1381126738U,      (u32 const   )151587081U,      (u32 const   )1785358954U,      (u32 const   )3587560917U, 
        (u32 const   )808464432U,      (u32 const   )909522486U,      (u32 const   )2779096485U,      (u32 const   )943208504U, 
        (u32 const   )3217014719U,      (u32 const   )1077952576U,      (u32 const   )2745410467U,      (u32 const   )2661195422U, 
        (u32 const   )2172748161U,      (u32 const   )4092851187U,      (u32 const   )3621246935U,      (u32 const   )4227595259U, 
        (u32 const   )2088533116U,      (u32 const   )3823363043U,      (u32 const   )960051513U,      (u32 const   )2189591170U, 
        (u32 const   )2610666395U,      (u32 const   )791621423U,      (u32 const   )4294967295U,      (u32 const   )2273806215U, 
        (u32 const   )875836468U,      (u32 const   )2391707278U,      (u32 const   )1128481603U,      (u32 const   )1145324612U, 
        (u32 const   )3301229764U,      (u32 const   )3739147998U,      (u32 const   )3924421097U,      (u32 const   )3419130827U, 
        (u32 const   )1414812756U,      (u32 const   )2071690107U,      (u32 const   )2492765332U,      (u32 const   )842150450U, 
        (u32 const   )2795939494U,      (u32 const   )3267543746U,      (u32 const   )589505315U,      (u32 const   )1027423549U, 
        (u32 const   )4008636142U,      (u32 const   )1280068684U,      (u32 const   )2509608341U,      (u32 const   )185273099U, 
        (u32 const   )1111638594U,      (u32 const   )4210752250U,      (u32 const   )3284386755U,      (u32 const   )1313754702U, 
        (u32 const   )134744072U,      (u32 const   )774778414U,      (u32 const   )2711724449U,      (u32 const   )1717986918U, 
        (u32 const   )673720360U,      (u32 const   )3654932953U,      (u32 const   )606348324U,      (u32 const   )2998055602U, 
        (u32 const   )1987475062U,      (u32 const   )1532713819U,      (u32 const   )2728567458U,      (u32 const   )1229539657U, 
        (u32 const   )1835887981U,      (u32 const   )2341178251U,      (u32 const   )3520188881U,      (u32 const   )623191333U, 
        (u32 const   )1920103026U,      (u32 const   )4177066232U,      (u32 const   )4143380214U,      (u32 const   )1684300900U, 
        (u32 const   )2256963206U,      (u32 const   )1751672936U,      (u32 const   )2560137368U,      (u32 const   )370546198U, 
        (u32 const   )3570717908U,      (u32 const   )2762253476U,      (u32 const   )1549556828U,      (u32 const   )3435973836U, 
        (u32 const   )1566399837U,      (u32 const   )1701143909U,      (u32 const   )3065427638U,      (u32 const   )2459079314U, 
        (u32 const   )1819044972U,      (u32 const   )1886417008U,      (u32 const   )1212696648U,      (u32 const   )1347440720U, 
        (u32 const   )4261281277U,      (u32 const   )3991793133U,      (u32 const   )3115956665U,      (u32 const   )3671775962U, 
        (u32 const   )1583242846U,      (u32 const   )353703189U,      (u32 const   )1179010630U,      (u32 const   )1465341783U, 
        (u32 const   )2812782503U,      (u32 const   )2374864269U,      (u32 const   )2644352413U,      (u32 const   )2223277188U, 
        (u32 const   )2425393296U,      (u32 const   )3638089944U,      (u32 const   )2880154539U,      (u32 const   )0U, 
        (u32 const   )2358021260U,      (u32 const   )3166485692U,      (u32 const   )3553874899U,      (u32 const   )168430090U, 
        (u32 const   )4160223223U,      (u32 const   )3840206052U,      (u32 const   )1482184792U,      (u32 const   )84215045U, 
        (u32 const   )3099113656U,      (u32 const   )3014898611U,      (u32 const   )1162167621U,      (u32 const   )101058054U, 
        (u32 const   )3503345872U,      (u32 const   )741092396U,      (u32 const   )505290270U,      (u32 const   )2408550287U, 
        (u32 const   )3402287818U,      (u32 const   )1061109567U,      (u32 const   )252645135U,      (u32 const   )33686018U, 
        (u32 const   )3250700737U,      (u32 const   )2947526575U,      (u32 const   )3183328701U,      (u32 const   )50529027U, 
        (u32 const   )16843009U,      (u32 const   )320017171U,      (u32 const   )2324335242U,      (u32 const   )1802201963U, 
        (u32 const   )976894522U,      (u32 const   )2442236305U,      (u32 const   )286331153U,      (u32 const   )1094795585U, 
        (u32 const   )1330597711U,      (u32 const   )1734829927U,      (u32 const   )3705461980U,      (u32 const   )3941264106U, 
        (u32 const   )2543294359U,      (u32 const   )4076008178U,      (u32 const   )3486502863U,      (u32 const   )3469659854U, 
        (u32 const   )4042322160U,      (u32 const   )3031741620U,      (u32 const   )3873892070U,      (u32 const   )1936946035U, 
        (u32 const   )2526451350U,      (u32 const   )2896997548U,      (u32 const   )1953789044U,      (u32 const   )572662306U, 
        (u32 const   )3890735079U,      (u32 const   )2913840557U,      (u32 const   )892679477U,      (u32 const   )2240120197U, 
        (u32 const   )3806520034U,      (u32 const   )4193909241U,      (u32 const   )926365495U,      (u32 const   )3907578088U, 
        (u32 const   )471604252U,      (u32 const   )1970632053U,      (u32 const   )3755991007U,      (u32 const   )1852730990U, 
        (u32 const   )1195853639U,      (u32 const   )4059165169U,      (u32 const   )437918234U,      (u32 const   )1903260017U, 
        (u32 const   )488447261U,      (u32 const   )690563369U,      (u32 const   )3318072773U,      (u32 const   )2307492233U, 
        (u32 const   )1869573999U,      (u32 const   )3082270647U,      (u32 const   )1650614882U,      (u32 const   )235802126U, 
        (u32 const   )2863311530U,      (u32 const   )404232216U,      (u32 const   )3200171710U,      (u32 const   )454761243U, 
        (u32 const   )4244438268U,      (u32 const   )1448498774U,      (u32 const   )1044266558U,      (u32 const   )1263225675U, 
        (u32 const   )3334915782U,      (u32 const   )3537031890U,      (u32 const   )2038004089U,      (u32 const   )538976288U, 
        (u32 const   )2593823386U,      (u32 const   )3688618971U,      (u32 const   )3233857728U,      (u32 const   )4278124286U, 
        (u32 const   )2021161080U,      (u32 const   )3452816845U,      (u32 const   )1515870810U,      (u32 const   )4109694196U, 
        (u32 const   )522133279U,      (u32 const   )3722304989U,      (u32 const   )2829625512U,      (u32 const   )858993459U, 
        (u32 const   )2290649224U,      (u32 const   )117901063U,      (u32 const   )3351758791U,      (u32 const   )825307441U, 
        (u32 const   )2981212593U,      (u32 const   )303174162U,      (u32 const   )269488144U,      (u32 const   )1499027801U, 
        (u32 const   )656877351U,      (u32 const   )2155905152U,      (u32 const   )3974950124U,      (u32 const   )1600085855U, 
        (u32 const   )1616928864U,      (u32 const   )1364283729U,      (u32 const   )2139062143U,      (u32 const   )2846468521U, 
        (u32 const   )421075225U,      (u32 const   )3048584629U,      (u32 const   )1246382666U,      (u32 const   )218959117U, 
        (u32 const   )757935405U,      (u32 const   )3857049061U,      (u32 const   )2054847098U,      (u32 const   )2678038431U, 
        (u32 const   )2475922323U,      (u32 const   )3385444809U,      (u32 const   )2627509404U,      (u32 const   )4025479151U, 
        (u32 const   )2694881440U,      (u32 const   )3772834016U,      (u32 const   )993737531U,      (u32 const   )1296911693U, 
        (u32 const   )2930683566U,      (u32 const   )707406378U,      (u32 const   )4126537205U,      (u32 const   )2964369584U, 
        (u32 const   )3368601800U,      (u32 const   )3958107115U,      (u32 const   )3149642683U,      (u32 const   )1010580540U, 
        (u32 const   )2206434179U,      (u32 const   )1397969747U,      (u32 const   )2576980377U,      (u32 const   )1633771873U, 
        (u32 const   )387389207U,      (u32 const   )724249387U,      (u32 const   )67372036U,      (u32 const   )2122219134U, 
        (u32 const   )3132799674U,      (u32 const   )2004318071U,      (u32 const   )3604403926U,      (u32 const   )640034342U, 
        (u32 const   )3789677025U,      (u32 const   )1768515945U,      (u32 const   )336860180U,      (u32 const   )1667457891U, 
        (u32 const   )1431655765U,      (u32 const   )555819297U,      (u32 const   )202116108U,      (u32 const   )2105376125U};
#line 713 "rijndael.c"
static u32 const   rcon[10]  = 
#line 713
  {      (u32 const   )16777216,      (u32 const   )33554432,      (u32 const   )67108864,      (u32 const   )134217728, 
        (u32 const   )268435456,      (u32 const   )536870912,      (u32 const   )1073741824,      (u32 const   )2147483648U, 
        (u32 const   )452984832,      (u32 const   )905969664};
#line 727 "rijndael.c"
static int rijndaelKeySetupEnc(u32 *rk , u8 const   *cipherKey , int keyBits ) 
{ int i ;
  u32 temp ;

  {
#line 728
  i = 0;
#line 731
  *(rk + 0) = ((((unsigned int )*(cipherKey + 0) << 24) ^ ((unsigned int )*(cipherKey + 1) << 16)) ^ ((unsigned int )*(cipherKey + 2) << 8)) ^ (unsigned int )*(cipherKey + 3);
#line 732
  *(rk + 1) = ((((unsigned int )*((cipherKey + 4) + 0) << 24) ^ ((unsigned int )*((cipherKey + 4) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 4) + 2) << 8)) ^ (unsigned int )*((cipherKey + 4) + 3);
#line 733
  *(rk + 2) = ((((unsigned int )*((cipherKey + 8) + 0) << 24) ^ ((unsigned int )*((cipherKey + 8) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 8) + 2) << 8)) ^ (unsigned int )*((cipherKey + 8) + 3);
#line 734
  *(rk + 3) = ((((unsigned int )*((cipherKey + 12) + 0) << 24) ^ ((unsigned int )*((cipherKey + 12) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 12) + 2) << 8)) ^ (unsigned int )*((cipherKey + 12) + 3);
#line 735
  if (keyBits == 128) {
#line 736
    while (1) {
#line 737
      temp = *(rk + 3);
#line 738
      *(rk + 4) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 744
      *(rk + 5) = *(rk + 1) ^ *(rk + 4);
#line 745
      *(rk + 6) = *(rk + 2) ^ *(rk + 5);
#line 746
      *(rk + 7) = *(rk + 3) ^ *(rk + 6);
#line 747
      i ++;
#line 747
      if (i == 10) {
#line 748
        return (10);
      }
#line 750
      rk += 4;
    }
  }
#line 753
  *(rk + 4) = ((((unsigned int )*((cipherKey + 16) + 0) << 24) ^ ((unsigned int )*((cipherKey + 16) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 16) + 2) << 8)) ^ (unsigned int )*((cipherKey + 16) + 3);
#line 754
  *(rk + 5) = ((((unsigned int )*((cipherKey + 20) + 0) << 24) ^ ((unsigned int )*((cipherKey + 20) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 20) + 2) << 8)) ^ (unsigned int )*((cipherKey + 20) + 3);
#line 755
  if (keyBits == 192) {
#line 756
    while (1) {
#line 757
      temp = *(rk + 5);
#line 758
      *(rk + 6) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 764
      *(rk + 7) = *(rk + 1) ^ *(rk + 6);
#line 765
      *(rk + 8) = *(rk + 2) ^ *(rk + 7);
#line 766
      *(rk + 9) = *(rk + 3) ^ *(rk + 8);
#line 767
      i ++;
#line 767
      if (i == 8) {
#line 768
        return (12);
      }
#line 770
      *(rk + 10) = *(rk + 4) ^ *(rk + 9);
#line 771
      *(rk + 11) = *(rk + 5) ^ *(rk + 10);
#line 772
      rk += 6;
    }
  }
#line 775
  *(rk + 6) = ((((unsigned int )*((cipherKey + 24) + 0) << 24) ^ ((unsigned int )*((cipherKey + 24) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 24) + 2) << 8)) ^ (unsigned int )*((cipherKey + 24) + 3);
#line 776
  *(rk + 7) = ((((unsigned int )*((cipherKey + 28) + 0) << 24) ^ ((unsigned int )*((cipherKey + 28) + 1) << 16)) ^ ((unsigned int )*((cipherKey + 28) + 2) << 8)) ^ (unsigned int )*((cipherKey + 28) + 3);
#line 777
  if (keyBits == 256) {
#line 778
    while (1) {
#line 779
      temp = *(rk + 7);
#line 780
      *(rk + 8) = ((((*(rk + 0) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 16711680U)) ^ (unsigned int )(Te4[temp & 255U] & 65280U)) ^ (unsigned int )(Te4[temp >> 24] & 255U)) ^ (unsigned int )rcon[i];
#line 786
      *(rk + 9) = *(rk + 1) ^ *(rk + 8);
#line 787
      *(rk + 10) = *(rk + 2) ^ *(rk + 9);
#line 788
      *(rk + 11) = *(rk + 3) ^ *(rk + 10);
#line 789
      i ++;
#line 789
      if (i == 7) {
#line 790
        return (14);
      }
#line 792
      temp = *(rk + 11);
#line 793
      *(rk + 12) = (((*(rk + 4) ^ (unsigned int )(Te4[temp >> 24] & 4278190080U)) ^ (unsigned int )(Te4[(temp >> 16) & 255U] & 16711680U)) ^ (unsigned int )(Te4[(temp >> 8) & 255U] & 65280U)) ^ (unsigned int )(Te4[temp & 255U] & 255U);
#line 798
      *(rk + 13) = *(rk + 5) ^ *(rk + 12);
#line 799
      *(rk + 14) = *(rk + 6) ^ *(rk + 13);
#line 800
      *(rk + 15) = *(rk + 7) ^ *(rk + 14);
#line 801
      rk += 8;
    }
  }
#line 804
  return (0);
}
}
#line 812 "rijndael.c"
static int rijndaelKeySetupDec(u32 *rk , u8 const   *cipherKey , int keyBits , int have_encrypt ) 
{ int Nr ;
  int i ;
  int j ;
  u32 temp ;

  {
#line 818
  if (have_encrypt) {
#line 819
    Nr = have_encrypt;
  } else {
#line 822
    Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
  }
#line 825
  i = 0;
#line 825
  j = 4 * Nr;
#line 825
  while (i < j) {
#line 826
    temp = *(rk + i);
#line 826
    *(rk + i) = *(rk + j);
#line 826
    *(rk + j) = temp;
#line 827
    temp = *(rk + (i + 1));
#line 827
    *(rk + (i + 1)) = *(rk + (j + 1));
#line 827
    *(rk + (j + 1)) = temp;
#line 828
    temp = *(rk + (i + 2));
#line 828
    *(rk + (i + 2)) = *(rk + (j + 2));
#line 828
    *(rk + (j + 2)) = temp;
#line 829
    temp = *(rk + (i + 3));
#line 829
    *(rk + (i + 3)) = *(rk + (j + 3));
#line 829
    *(rk + (j + 3)) = temp;
#line 825
    i += 4;
#line 825
    j -= 4;
  }
#line 832
  i = 1;
#line 832
  while (i < Nr) {
#line 833
    rk += 4;
#line 834
    *(rk + 0) = (unsigned int )(((Td0[Te4[*(rk + 0) >> 24] & 255U] ^ Td1[Te4[(*(rk + 0) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 0) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 0) & 255U] & 255U]);
#line 839
    *(rk + 1) = (unsigned int )(((Td0[Te4[*(rk + 1) >> 24] & 255U] ^ Td1[Te4[(*(rk + 1) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 1) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 1) & 255U] & 255U]);
#line 844
    *(rk + 2) = (unsigned int )(((Td0[Te4[*(rk + 2) >> 24] & 255U] ^ Td1[Te4[(*(rk + 2) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 2) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 2) & 255U] & 255U]);
#line 849
    *(rk + 3) = (unsigned int )(((Td0[Te4[*(rk + 3) >> 24] & 255U] ^ Td1[Te4[(*(rk + 3) >> 16) & 255U] & 255U]) ^ Td2[Te4[(*(rk + 3) >> 8) & 255U] & 255U]) ^ Td3[Te4[*(rk + 3) & 255U] & 255U]);
#line 832
    i ++;
  }
#line 855
  return (Nr);
}
}
#line 858 "rijndael.c"
static void rijndaelEncrypt(u32 const   *rk , int Nr , u8 const   *pt , u8 *ct ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 868
  s0 = (((((unsigned int )*(pt + 0) << 24) ^ ((unsigned int )*(pt + 1) << 16)) ^ ((unsigned int )*(pt + 2) << 8)) ^ (unsigned int )*(pt + 3)) ^ (unsigned int )*(rk + 0);
#line 869
  s1 = (((((unsigned int )*((pt + 4) + 0) << 24) ^ ((unsigned int )*((pt + 4) + 1) << 16)) ^ ((unsigned int )*((pt + 4) + 2) << 8)) ^ (unsigned int )*((pt + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 870
  s2 = (((((unsigned int )*((pt + 8) + 0) << 24) ^ ((unsigned int )*((pt + 8) + 1) << 16)) ^ ((unsigned int )*((pt + 8) + 2) << 8)) ^ (unsigned int )*((pt + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 871
  s3 = (((((unsigned int )*((pt + 12) + 0) << 24) ^ ((unsigned int )*((pt + 12) + 1) << 16)) ^ ((unsigned int )*((pt + 12) + 2) << 8)) ^ (unsigned int )*((pt + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 874
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 4));
#line 875
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 5));
#line 876
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 6));
#line 877
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 7));
#line 879
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 8));
#line 880
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 9));
#line 881
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 10));
#line 882
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 11));
#line 884
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 12));
#line 885
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 13));
#line 886
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 14));
#line 887
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 15));
#line 889
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 16));
#line 890
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 17));
#line 891
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 18));
#line 892
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 19));
#line 894
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 20));
#line 895
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 21));
#line 896
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 22));
#line 897
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 23));
#line 899
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 24));
#line 900
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 25));
#line 901
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 26));
#line 902
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 27));
#line 904
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 28));
#line 905
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 29));
#line 906
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 30));
#line 907
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 31));
#line 909
  s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 32));
#line 910
  s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 33));
#line 911
  s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 34));
#line 912
  s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 35));
#line 914
  t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 36));
#line 915
  t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 37));
#line 916
  t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 38));
#line 917
  t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 39));
#line 918
  if (Nr > 10) {
#line 920
    s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 40));
#line 921
    s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 41));
#line 922
    s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 42));
#line 923
    s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 43));
#line 925
    t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 44));
#line 926
    t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 45));
#line 927
    t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 46));
#line 928
    t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 47));
#line 929
    if (Nr > 12) {
#line 931
      s0 = (unsigned int )((((Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 255U]) ^ Te2[(t2 >> 8) & 255U]) ^ Te3[t3 & 255U]) ^ *(rk + 48));
#line 932
      s1 = (unsigned int )((((Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 255U]) ^ Te2[(t3 >> 8) & 255U]) ^ Te3[t0 & 255U]) ^ *(rk + 49));
#line 933
      s2 = (unsigned int )((((Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 255U]) ^ Te2[(t0 >> 8) & 255U]) ^ Te3[t1 & 255U]) ^ *(rk + 50));
#line 934
      s3 = (unsigned int )((((Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 255U]) ^ Te2[(t1 >> 8) & 255U]) ^ Te3[t2 & 255U]) ^ *(rk + 51));
#line 936
      t0 = (unsigned int )((((Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 255U]) ^ Te2[(s2 >> 8) & 255U]) ^ Te3[s3 & 255U]) ^ *(rk + 52));
#line 937
      t1 = (unsigned int )((((Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 255U]) ^ Te2[(s3 >> 8) & 255U]) ^ Te3[s0 & 255U]) ^ *(rk + 53));
#line 938
      t2 = (unsigned int )((((Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 255U]) ^ Te2[(s0 >> 8) & 255U]) ^ Te3[s1 & 255U]) ^ *(rk + 54));
#line 939
      t3 = (unsigned int )((((Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 255U]) ^ Te2[(s1 >> 8) & 255U]) ^ Te3[s2 & 255U]) ^ *(rk + 55));
    }
  }
#line 942
  rk += Nr << 2;
#line 1009
  s0 = (unsigned int )(((((Te4[t0 >> 24] & 4278190080U) ^ (Te4[(t1 >> 16) & 255U] & 16711680U)) ^ (Te4[(t2 >> 8) & 255U] & 65280U)) ^ (Te4[t3 & 255U] & 255U)) ^ *(rk + 0));
#line 1015
  *(ct + 0) = (unsigned char )(s0 >> 24);
#line 1015
  *(ct + 1) = (unsigned char )(s0 >> 16);
#line 1015
  *(ct + 2) = (unsigned char )(s0 >> 8);
#line 1015
  *(ct + 3) = (unsigned char )s0;
#line 1016
  s1 = (unsigned int )(((((Te4[t1 >> 24] & 4278190080U) ^ (Te4[(t2 >> 16) & 255U] & 16711680U)) ^ (Te4[(t3 >> 8) & 255U] & 65280U)) ^ (Te4[t0 & 255U] & 255U)) ^ *(rk + 1));
#line 1022
  *((ct + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1022
  *((ct + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1022
  *((ct + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1022
  *((ct + 4) + 3) = (unsigned char )s1;
#line 1023
  s2 = (unsigned int )(((((Te4[t2 >> 24] & 4278190080U) ^ (Te4[(t3 >> 16) & 255U] & 16711680U)) ^ (Te4[(t0 >> 8) & 255U] & 65280U)) ^ (Te4[t1 & 255U] & 255U)) ^ *(rk + 2));
#line 1029
  *((ct + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1029
  *((ct + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1029
  *((ct + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1029
  *((ct + 8) + 3) = (unsigned char )s2;
#line 1030
  s3 = (unsigned int )(((((Te4[t3 >> 24] & 4278190080U) ^ (Te4[(t0 >> 16) & 255U] & 16711680U)) ^ (Te4[(t1 >> 8) & 255U] & 65280U)) ^ (Te4[t2 & 255U] & 255U)) ^ *(rk + 3));
#line 1036
  *((ct + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1036
  *((ct + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1036
  *((ct + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1036
  *((ct + 12) + 3) = (unsigned char )s3;
#line 1037
  return;
}
}
#line 1039 "rijndael.c"
static void rijndaelDecrypt(u32 const   *rk , int Nr , u8 const   *ct , u8 *pt ) 
{ u32 s0 ;
  u32 s1 ;
  u32 s2 ;
  u32 s3 ;
  u32 t0 ;
  u32 t1 ;
  u32 t2 ;
  u32 t3 ;

  {
#line 1049
  s0 = (((((unsigned int )*(ct + 0) << 24) ^ ((unsigned int )*(ct + 1) << 16)) ^ ((unsigned int )*(ct + 2) << 8)) ^ (unsigned int )*(ct + 3)) ^ (unsigned int )*(rk + 0);
#line 1050
  s1 = (((((unsigned int )*((ct + 4) + 0) << 24) ^ ((unsigned int )*((ct + 4) + 1) << 16)) ^ ((unsigned int )*((ct + 4) + 2) << 8)) ^ (unsigned int )*((ct + 4) + 3)) ^ (unsigned int )*(rk + 1);
#line 1051
  s2 = (((((unsigned int )*((ct + 8) + 0) << 24) ^ ((unsigned int )*((ct + 8) + 1) << 16)) ^ ((unsigned int )*((ct + 8) + 2) << 8)) ^ (unsigned int )*((ct + 8) + 3)) ^ (unsigned int )*(rk + 2);
#line 1052
  s3 = (((((unsigned int )*((ct + 12) + 0) << 24) ^ ((unsigned int )*((ct + 12) + 1) << 16)) ^ ((unsigned int )*((ct + 12) + 2) << 8)) ^ (unsigned int )*((ct + 12) + 3)) ^ (unsigned int )*(rk + 3);
#line 1055
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 4));
#line 1056
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 5));
#line 1057
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 6));
#line 1058
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 7));
#line 1060
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 8));
#line 1061
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 9));
#line 1062
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 10));
#line 1063
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 11));
#line 1065
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 12));
#line 1066
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 13));
#line 1067
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 14));
#line 1068
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 15));
#line 1070
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 16));
#line 1071
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 17));
#line 1072
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 18));
#line 1073
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 19));
#line 1075
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 20));
#line 1076
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 21));
#line 1077
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 22));
#line 1078
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 23));
#line 1080
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 24));
#line 1081
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 25));
#line 1082
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 26));
#line 1083
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 27));
#line 1085
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 28));
#line 1086
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 29));
#line 1087
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 30));
#line 1088
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 31));
#line 1090
  s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 32));
#line 1091
  s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 33));
#line 1092
  s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 34));
#line 1093
  s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 35));
#line 1095
  t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 36));
#line 1096
  t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 37));
#line 1097
  t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 38));
#line 1098
  t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 39));
#line 1099
  if (Nr > 10) {
#line 1101
    s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 40));
#line 1102
    s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 41));
#line 1103
    s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 42));
#line 1104
    s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 43));
#line 1106
    t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 44));
#line 1107
    t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 45));
#line 1108
    t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 46));
#line 1109
    t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 47));
#line 1110
    if (Nr > 12) {
#line 1112
      s0 = (unsigned int )((((Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 255U]) ^ Td2[(t2 >> 8) & 255U]) ^ Td3[t1 & 255U]) ^ *(rk + 48));
#line 1113
      s1 = (unsigned int )((((Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 255U]) ^ Td2[(t3 >> 8) & 255U]) ^ Td3[t2 & 255U]) ^ *(rk + 49));
#line 1114
      s2 = (unsigned int )((((Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 255U]) ^ Td2[(t0 >> 8) & 255U]) ^ Td3[t3 & 255U]) ^ *(rk + 50));
#line 1115
      s3 = (unsigned int )((((Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 255U]) ^ Td2[(t1 >> 8) & 255U]) ^ Td3[t0 & 255U]) ^ *(rk + 51));
#line 1117
      t0 = (unsigned int )((((Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 255U]) ^ Td2[(s2 >> 8) & 255U]) ^ Td3[s1 & 255U]) ^ *(rk + 52));
#line 1118
      t1 = (unsigned int )((((Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 255U]) ^ Td2[(s3 >> 8) & 255U]) ^ Td3[s2 & 255U]) ^ *(rk + 53));
#line 1119
      t2 = (unsigned int )((((Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 255U]) ^ Td2[(s0 >> 8) & 255U]) ^ Td3[s3 & 255U]) ^ *(rk + 54));
#line 1120
      t3 = (unsigned int )((((Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 255U]) ^ Td2[(s1 >> 8) & 255U]) ^ Td3[s0 & 255U]) ^ *(rk + 55));
    }
  }
#line 1123
  rk += Nr << 2;
#line 1190
  s0 = (unsigned int )(((((Td4[t0 >> 24] & 4278190080U) ^ (Td4[(t3 >> 16) & 255U] & 16711680U)) ^ (Td4[(t2 >> 8) & 255U] & 65280U)) ^ (Td4[t1 & 255U] & 255U)) ^ *(rk + 0));
#line 1196
  *(pt + 0) = (unsigned char )(s0 >> 24);
#line 1196
  *(pt + 1) = (unsigned char )(s0 >> 16);
#line 1196
  *(pt + 2) = (unsigned char )(s0 >> 8);
#line 1196
  *(pt + 3) = (unsigned char )s0;
#line 1197
  s1 = (unsigned int )(((((Td4[t1 >> 24] & 4278190080U) ^ (Td4[(t0 >> 16) & 255U] & 16711680U)) ^ (Td4[(t3 >> 8) & 255U] & 65280U)) ^ (Td4[t2 & 255U] & 255U)) ^ *(rk + 1));
#line 1203
  *((pt + 4) + 0) = (unsigned char )(s1 >> 24);
#line 1203
  *((pt + 4) + 1) = (unsigned char )(s1 >> 16);
#line 1203
  *((pt + 4) + 2) = (unsigned char )(s1 >> 8);
#line 1203
  *((pt + 4) + 3) = (unsigned char )s1;
#line 1204
  s2 = (unsigned int )(((((Td4[t2 >> 24] & 4278190080U) ^ (Td4[(t1 >> 16) & 255U] & 16711680U)) ^ (Td4[(t0 >> 8) & 255U] & 65280U)) ^ (Td4[t3 & 255U] & 255U)) ^ *(rk + 2));
#line 1210
  *((pt + 8) + 0) = (unsigned char )(s2 >> 24);
#line 1210
  *((pt + 8) + 1) = (unsigned char )(s2 >> 16);
#line 1210
  *((pt + 8) + 2) = (unsigned char )(s2 >> 8);
#line 1210
  *((pt + 8) + 3) = (unsigned char )s2;
#line 1211
  s3 = (unsigned int )(((((Td4[t3 >> 24] & 4278190080U) ^ (Td4[(t2 >> 16) & 255U] & 16711680U)) ^ (Td4[(t1 >> 8) & 255U] & 65280U)) ^ (Td4[t0 & 255U] & 255U)) ^ *(rk + 3));
#line 1217
  *((pt + 12) + 0) = (unsigned char )(s3 >> 24);
#line 1217
  *((pt + 12) + 1) = (unsigned char )(s3 >> 16);
#line 1217
  *((pt + 12) + 2) = (unsigned char )(s3 >> 8);
#line 1217
  *((pt + 12) + 3) = (unsigned char )s3;
#line 1218
  return;
}
}
#line 1220 "rijndael.c"
void rijndael_set_key(rijndael_ctx *ctx , u_char *key , int bits , int do_encrypt ) 
{ 

  {
#line 1223
  ctx->Nr = rijndaelKeySetupEnc(ctx->ek, (u8 const   *)key, bits);
#line 1224
  if (do_encrypt) {
#line 1225
    ctx->decrypt = 0;
#line 1226
    memset((void *)(ctx->dk), 0, sizeof(ctx->dk));
  } else {
#line 1228
    ctx->decrypt = 1;
#line 1229
    memcpy((void * __restrict  )(ctx->dk), (void const   * __restrict  )(ctx->ek),
           sizeof(ctx->dk));
#line 1230
    rijndaelKeySetupDec(ctx->dk, (u8 const   *)key, bits, ctx->Nr);
  }
#line 1232
  return;
}
}
#line 1234 "rijndael.c"
void rijndael_decrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1237
  rijndaelDecrypt((u32 const   *)(ctx->dk), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1238
  return;
}
}
#line 1240 "rijndael.c"
void rijndael_encrypt(rijndael_ctx *ctx , u_char *src , u_char *dst ) 
{ 

  {
#line 1243
  rijndaelEncrypt((u32 const   *)(ctx->ek), ctx->Nr, (u8 const   *)src, (u8 *)dst);
#line 1244
  return;
}
}
#line 1 "ssh-dss.o"
#line 175 "/usr/include/openssl/dsa.h"
extern DSA_SIG *DSA_SIG_new(void) ;
#line 176
extern void DSA_SIG_free(DSA_SIG *a ) ;
#line 180
extern DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 181
extern int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                         DSA *dsa ) ;
#line 45 "ssh-dss.c"
int ssh_dss_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char sigblob[40] ;
  u_int rlen ;
  u_int slen ;
  u_int len ;
  u_int dlen ;
  Buffer b ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 50
  tmp = EVP_sha1();
#line 50
  evp_md = tmp;
#line 56
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 57
    error("ssh_dss_sign: no DSA key");
#line 58
    return (-1);
  } else {
#line 56
    if (key->type != 2) {
#line 57
      error("ssh_dss_sign: no DSA key");
#line 58
      return (-1);
    } else {
#line 56
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 57
        error("ssh_dss_sign: no DSA key");
#line 58
        return (-1);
      }
    }
  }
#line 60
  EVP_DigestInit(& md, evp_md);
#line 61
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 62
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 64
  sig = DSA_do_sign((unsigned char const   *)(digest___1), (int )dlen, (DSA *)key->dsa);
#line 65
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 67
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 68
    error("ssh_dss_sign: sign failed");
#line 69
    return (-1);
  }
#line 72
  tmp___0 = BN_num_bits((BIGNUM const   *)sig->r);
#line 72
  rlen = (unsigned int )((tmp___0 + 7) / 8);
#line 73
  tmp___1 = BN_num_bits((BIGNUM const   *)sig->s);
#line 73
  slen = (unsigned int )((tmp___1 + 7) / 8);
#line 74
  if (rlen > 20U) {
#line 75
    error("bad sig size %u %u", rlen, slen);
#line 76
    DSA_SIG_free(sig);
#line 77
    return (-1);
  } else {
#line 74
    if (slen > 20U) {
#line 75
      error("bad sig size %u %u", rlen, slen);
#line 76
      DSA_SIG_free(sig);
#line 77
      return (-1);
    }
  }
#line 79
  memset((void *)(sigblob), 0, 40U);
#line 80
  BN_bn2bin((BIGNUM const   *)sig->r, ((sigblob + 40) - 20) - rlen);
#line 81
  BN_bn2bin((BIGNUM const   *)sig->s, (sigblob + 40) - slen);
#line 82
  DSA_SIG_free(sig);
#line 84
  if (datafellows & 1) {
#line 85
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 86
      *lenp = 40U;
    }
#line 87
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 88
      tmp___2 = xmalloc(40U);
#line 88
      *sigp = (u_char *)tmp___2;
#line 89
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )(sigblob), 40U);
    }
  } else {
#line 93
    buffer_init(& b);
#line 94
    buffer_put_cstring(& b, "ssh-dss");
#line 95
    buffer_put_string(& b, (void const   *)(sigblob), 40U);
#line 96
    len = buffer_len(& b);
#line 97
    if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 98
      *lenp = len;
    }
#line 99
    if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 100
      tmp___3 = xmalloc(len);
#line 100
      *sigp = (u_char *)tmp___3;
#line 101
      tmp___4 = buffer_ptr(& b);
#line 101
      memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___4, len);
    }
#line 103
    buffer_free(& b);
  }
#line 105
  return (0);
}
}
#line 107 "ssh-dss.c"
int ssh_dss_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ DSA_SIG *sig ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  int rlen ;
  int ret___0 ;
  Buffer b ;
  void *tmp___0 ;
  char *ktype ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  BIGNUM *tmp___14 ;
  BIGNUM *tmp___15 ;
  char const   *tmp___17 ;

  {
#line 112
  tmp = EVP_sha1();
#line 112
  evp_md = tmp;
#line 119
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 120
    error("ssh_dss_verify: no DSA key");
#line 121
    return (-1);
  } else {
#line 119
    if (key->type != 2) {
#line 120
      error("ssh_dss_verify: no DSA key");
#line 121
      return (-1);
    } else {
#line 119
      if ((unsigned int )key->dsa == (unsigned int )((void *)0)) {
#line 120
        error("ssh_dss_verify: no DSA key");
#line 121
        return (-1);
      }
    }
  }
#line 125
  if (datafellows & 1) {
#line 126
    tmp___0 = xmalloc(signaturelen);
#line 126
    sigblob = (u_char *)tmp___0;
#line 127
    memcpy((void * __restrict  )sigblob, (void const   * __restrict  )signature, signaturelen);
#line 128
    len = signaturelen;
  } else {
#line 132
    buffer_init(& b);
#line 133
    buffer_append(& b, (void const   *)signature, signaturelen);
#line 134
    tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 134
    ktype = (char *)tmp___1;
#line 135
    if (0) {
#line 135
      __s1_len = strlen("ssh-dss");
#line 135
      __s2_len = strlen((char const   *)ktype);
#line 135
      if (! ((unsigned int )((void const   *)("ssh-dss" + 1)) - (unsigned int )((void const   *)"ssh-dss") == 1U)) {
        goto _L___0;
      } else {
#line 135
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 135
          if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 135
            tmp___11 = 1;
          } else {
#line 135
            if (__s2_len >= 4U) {
#line 135
              tmp___11 = 1;
            } else {
#line 135
              tmp___11 = 0;
            }
          }
        } else {
#line 135
          tmp___11 = 0;
        }
      }
#line 135
      if (tmp___11) {
#line 135
        tmp___7 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
      } else {
#line 135
        tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 135
        tmp___7 = tmp___10;
      }
    } else {
#line 135
      tmp___10 = __builtin_strcmp("ssh-dss", (char const   *)ktype);
#line 135
      tmp___7 = tmp___10;
    }
#line 135
    if (tmp___7 != 0) {
#line 136
      error("ssh_dss_verify: cannot handle type %s", ktype);
#line 137
      buffer_free(& b);
#line 138
      xfree((void *)ktype);
#line 139
      return (-1);
    }
#line 141
    xfree((void *)ktype);
#line 142
    tmp___12 = buffer_get_string(& b, & len);
#line 142
    sigblob = (u_char *)tmp___12;
#line 143
    tmp___13 = buffer_len(& b);
#line 143
    rlen = (int )tmp___13;
#line 144
    buffer_free(& b);
#line 145
    if (rlen != 0) {
#line 146
      error("ssh_dss_verify: remaining bytes in signature %d", rlen);
#line 148
      xfree((void *)sigblob);
#line 149
      return (-1);
    }
  }
#line 153
  if (len != 40U) {
#line 154
    fatal("bad sigbloblen %u != SIGBLOB_LEN", len);
  }
#line 158
  sig = DSA_SIG_new();
#line 158
  if ((unsigned int )sig == (unsigned int )((void *)0)) {
#line 159
    fatal("ssh_dss_verify: DSA_SIG_new failed");
  }
#line 160
  sig->r = BN_new();
#line 160
  if ((unsigned int )sig->r == (unsigned int )((void *)0)) {
#line 161
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 162
  sig->s = BN_new();
#line 162
  if ((unsigned int )sig->s == (unsigned int )((void *)0)) {
#line 163
    fatal("ssh_dss_verify: BN_new failed");
  }
#line 164
  tmp___14 = BN_bin2bn((unsigned char const   *)sigblob, 20, sig->r);
#line 164
  if ((unsigned int )tmp___14 == (unsigned int )((void *)0)) {
#line 166
    fatal("ssh_dss_verify: BN_bin2bn failed");
  } else {
#line 164
    tmp___15 = BN_bin2bn((unsigned char const   *)(sigblob + 20), 20, sig->s);
#line 164
    if ((unsigned int )tmp___15 == (unsigned int )((void *)0)) {
#line 166
      fatal("ssh_dss_verify: BN_bin2bn failed");
    }
  }
#line 169
  memset((void *)sigblob, 0, len);
#line 170
  xfree((void *)sigblob);
#line 173
  EVP_DigestInit(& md, evp_md);
#line 174
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 175
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 177
  ret___0 = DSA_do_verify((unsigned char const   *)(digest___1), (int )dlen, sig,
                          (DSA *)key->dsa);
#line 178
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 180
  DSA_SIG_free(sig);
#line 182
  if (ret___0 == 1) {
#line 182
    tmp___17 = "correct";
  } else {
#line 182
    if (ret___0 == 0) {
#line 182
      tmp___17 = "incorrect";
    } else {
#line 182
      tmp___17 = "error";
    }
  }
#line 182
  debug("ssh_dss_verify: signature %s", tmp___17);
#line 184
  return (ret___0);
}
}
#line 1 "ssh-rsa.o"
#line 1006 "/usr/include/openssl/objects.h"
extern char const   *OBJ_nid2sn(int n ) ;
#line 732 "/usr/include/openssl/evp.h"
extern EVP_MD const   *EVP_get_digestbyname(char const   *name ) ;
#line 271 "/usr/include/openssl/err.h"
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 217 "/usr/include/openssl/rsa.h"
extern int RSA_size(RSA const   * ) ;
#line 234
extern int RSA_public_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                              RSA *rsa , int padding ) ;
#line 284
extern int RSA_sign(int type , unsigned char const   *m , unsigned int m_length ,
                    unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 35 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) ;
#line 38 "ssh-rsa.c"
int ssh_rsa_sign(Key const   *key , u_char **sigp , u_int *lenp , u_char const   *data ,
                 u_int datalen ) 
{ EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  u_char digest___1[64] ;
  u_char *sig ;
  u_int slen ;
  u_int dlen ;
  u_int len ;
  int ok ;
  int nid ;
  Buffer b ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int ecode ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  u_int diff ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 49
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 50
    error("ssh_rsa_sign: no RSA key");
#line 51
    return (-1);
  } else {
#line 49
    if (key->type != 1) {
#line 50
      error("ssh_rsa_sign: no RSA key");
#line 51
      return (-1);
    } else {
#line 49
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 50
        error("ssh_rsa_sign: no RSA key");
#line 51
        return (-1);
      }
    }
  }
#line 53
  if (datafellows & 8192) {
#line 53
    nid = 4;
  } else {
#line 53
    nid = 64;
  }
#line 54
  tmp = OBJ_nid2sn(nid);
#line 54
  evp_md = EVP_get_digestbyname(tmp);
#line 54
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 55
    error("ssh_rsa_sign: EVP_get_digestbynid %d failed", nid);
#line 56
    return (-1);
  }
#line 58
  EVP_DigestInit(& md, evp_md);
#line 59
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 60
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 62
  tmp___0 = RSA_size((RSA const   *)key->rsa);
#line 62
  slen = (unsigned int )tmp___0;
#line 63
  tmp___1 = xmalloc(slen);
#line 63
  sig = (u_char *)tmp___1;
#line 65
  ok = RSA_sign(nid, (unsigned char const   *)(digest___1), dlen, sig, & len, (RSA *)key->rsa);
#line 66
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 68
  if (ok != 1) {
#line 69
    tmp___2 = ERR_get_error();
#line 69
    ecode = (int )tmp___2;
#line 71
    tmp___3 = ERR_error_string((unsigned long )ecode, (char *)((void *)0));
#line 71
    error("ssh_rsa_sign: RSA_sign failed: %s", tmp___3);
#line 73
    xfree((void *)sig);
#line 74
    return (-1);
  }
#line 76
  if (len < slen) {
#line 77
    diff = slen - len;
#line 78
    debug("slen %u > len %u", slen, len);
#line 79
    memmove((void *)(sig + diff), (void const   *)sig, len);
#line 80
    memset((void *)sig, 0, diff);
  } else {
#line 81
    if (len > slen) {
#line 82
      error("ssh_rsa_sign: slen %u slen2 %u", slen, len);
#line 83
      xfree((void *)sig);
#line 84
      return (-1);
    }
  }
#line 87
  buffer_init(& b);
#line 88
  buffer_put_cstring(& b, "ssh-rsa");
#line 89
  buffer_put_string(& b, (void const   *)sig, slen);
#line 90
  len = buffer_len(& b);
#line 91
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 92
    *lenp = len;
  }
#line 93
  if ((unsigned int )sigp != (unsigned int )((void *)0)) {
#line 94
    tmp___4 = xmalloc(len);
#line 94
    *sigp = (u_char *)tmp___4;
#line 95
    tmp___5 = buffer_ptr(& b);
#line 95
    memcpy((void * __restrict  )*sigp, (void const   * __restrict  )tmp___5, len);
  }
#line 97
  buffer_free(& b);
#line 98
  memset((void *)sig, 's', slen);
#line 99
  xfree((void *)sig);
#line 101
  return (0);
}
}
#line 104 "ssh-rsa.c"
int ssh_rsa_verify(Key const   *key , u_char const   *signature , u_int signaturelen ,
                   u_char const   *data , u_int datalen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD_CTX md ;
  char *ktype ;
  u_char digest___1[64] ;
  u_char *sigblob ;
  u_int len ;
  u_int dlen ;
  u_int modlen ;
  int rlen ;
  int ret___0 ;
  int nid ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  int tmp___14 ;
  u_int diff ;
  void *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 116
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 117
    error("ssh_rsa_verify: no RSA key");
#line 118
    return (-1);
  } else {
#line 116
    if (key->type != 1) {
#line 117
      error("ssh_rsa_verify: no RSA key");
#line 118
      return (-1);
    } else {
#line 116
      if ((unsigned int )key->rsa == (unsigned int )((void *)0)) {
#line 117
        error("ssh_rsa_verify: no RSA key");
#line 118
        return (-1);
      }
    }
  }
#line 120
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 120
  if (tmp___0 < 768) {
#line 121
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 121
    error("ssh_rsa_verify: RSA modulus too small: %d < minimum %d bits", tmp, 768);
#line 123
    return (-1);
  }
#line 125
  buffer_init(& b);
#line 126
  buffer_append(& b, (void const   *)signature, signaturelen);
#line 127
  tmp___1 = buffer_get_string(& b, (u_int *)((void *)0));
#line 127
  ktype = (char *)tmp___1;
#line 128
  if (0) {
#line 128
    __s1_len = strlen("ssh-rsa");
#line 128
    __s2_len = strlen((char const   *)ktype);
#line 128
    if (! ((unsigned int )((void const   *)("ssh-rsa" + 1)) - (unsigned int )((void const   *)"ssh-rsa") == 1U)) {
      goto _L___0;
    } else {
#line 128
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 128
        if (! ((unsigned int )((void const   *)(ktype + 1)) - (unsigned int )((void const   *)ktype) == 1U)) {
#line 128
          tmp___11 = 1;
        } else {
#line 128
          if (__s2_len >= 4U) {
#line 128
            tmp___11 = 1;
          } else {
#line 128
            tmp___11 = 0;
          }
        }
      } else {
#line 128
        tmp___11 = 0;
      }
    }
#line 128
    if (tmp___11) {
#line 128
      tmp___7 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
    } else {
#line 128
      tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 128
      tmp___7 = tmp___10;
    }
  } else {
#line 128
    tmp___10 = __builtin_strcmp("ssh-rsa", (char const   *)ktype);
#line 128
    tmp___7 = tmp___10;
  }
#line 128
  if (tmp___7 != 0) {
#line 129
    error("ssh_rsa_verify: cannot handle type %s", ktype);
#line 130
    buffer_free(& b);
#line 131
    xfree((void *)ktype);
#line 132
    return (-1);
  }
#line 134
  xfree((void *)ktype);
#line 135
  tmp___12 = buffer_get_string(& b, & len);
#line 135
  sigblob = (u_char *)tmp___12;
#line 136
  tmp___13 = buffer_len(& b);
#line 136
  rlen = (int )tmp___13;
#line 137
  buffer_free(& b);
#line 138
  if (rlen != 0) {
#line 139
    error("ssh_rsa_verify: remaining bytes in signature %d", rlen);
#line 140
    xfree((void *)sigblob);
#line 141
    return (-1);
  }
#line 144
  tmp___14 = RSA_size((RSA const   *)key->rsa);
#line 144
  modlen = (unsigned int )tmp___14;
#line 145
  if (len > modlen) {
#line 146
    error("ssh_rsa_verify: len %u > modlen %u", len, modlen);
#line 147
    xfree((void *)sigblob);
#line 148
    return (-1);
  } else {
#line 149
    if (len < modlen) {
#line 150
      diff = modlen - len;
#line 151
      debug("ssh_rsa_verify: add padding: modlen %u > len %u", modlen, len);
#line 153
      tmp___15 = xrealloc((void *)sigblob, 1U, modlen);
#line 153
      sigblob = (u_char *)tmp___15;
#line 154
      memmove((void *)(sigblob + diff), (void const   *)sigblob, len);
#line 155
      memset((void *)sigblob, 0, diff);
#line 156
      len = modlen;
    }
  }
#line 158
  if (datafellows & 8192) {
#line 158
    nid = 4;
  } else {
#line 158
    nid = 64;
  }
#line 159
  tmp___16 = OBJ_nid2sn(nid);
#line 159
  evp_md = EVP_get_digestbyname(tmp___16);
#line 159
  if ((unsigned int )evp_md == (unsigned int )((void *)0)) {
#line 160
    error("ssh_rsa_verify: EVP_get_digestbynid %d failed", nid);
#line 161
    xfree((void *)sigblob);
#line 162
    return (-1);
  }
#line 164
  EVP_DigestInit(& md, evp_md);
#line 165
  EVP_DigestUpdate(& md, (void const   *)data, datalen);
#line 166
  EVP_DigestFinal(& md, digest___1, & dlen);
#line 168
  ret___0 = openssh_RSA_verify(nid, digest___1, dlen, sigblob, len, (RSA *)key->rsa);
#line 169
  memset((void *)(digest___1), 'd', sizeof(digest___1));
#line 170
  memset((void *)sigblob, 's', len);
#line 171
  xfree((void *)sigblob);
#line 172
  if (ret___0 == 0) {
#line 172
    tmp___17 = "in";
  } else {
#line 172
    tmp___17 = "";
  }
#line 172
  debug("ssh_rsa_verify: signature %scorrect", tmp___17);
#line 173
  return (ret___0);
}
}
#line 185 "ssh-rsa.c"
static u_char const   id_sha1[15]  = 
#line 185
  {      (u_char const   )48,      (u_char const   )33,      (u_char const   )48,      (u_char const   )9, 
        (u_char const   )6,      (u_char const   )5,      (u_char const   )43,      (u_char const   )14, 
        (u_char const   )3,      (u_char const   )2,      (u_char const   )26,      (u_char const   )5, 
        (u_char const   )0,      (u_char const   )4,      (u_char const   )20};
#line 197 "ssh-rsa.c"
static u_char const   id_md5[18]  = 
#line 197
  {      (u_char const   )48,      (u_char const   )32,      (u_char const   )48,      (u_char const   )12, 
        (u_char const   )6,      (u_char const   )8,      (u_char const   )42,      (u_char const   )134, 
        (u_char const   )72,      (u_char const   )134,      (u_char const   )247,      (u_char const   )13, 
        (u_char const   )2,      (u_char const   )5,      (u_char const   )5,      (u_char const   )0, 
        (u_char const   )4,      (u_char const   )16};
#line 206 "ssh-rsa.c"
static int openssh_RSA_verify(int type , u_char *hash , u_int hashlen , u_char *sigbuf ,
                              u_int siglen , RSA *rsa ) 
{ u_int ret___0 ;
  u_int rsasize ;
  u_int oidlen ;
  u_int hlen ;
  int len ;
  u_char const   *oid ;
  u_char *decrypted ;
  int tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 210
  oidlen = (u_int )0;
#line 210
  hlen = (u_int )0;
#line 212
  oid = (u_char const   *)((void *)0);
#line 213
  decrypted = (u_char *)((void *)0);
#line 215
  ret___0 = 0U;
#line 216
  switch (type) {
  case 64: 
#line 218
  oid = id_sha1;
#line 219
  oidlen = sizeof(id_sha1);
#line 220
  hlen = 20U;
#line 221
  break;
  case 4: 
#line 223
  oid = id_md5;
#line 224
  oidlen = sizeof(id_md5);
#line 225
  hlen = 16U;
#line 226
  break;
  default: ;
  goto done;
  }
#line 230
  if (hashlen != hlen) {
#line 231
    error("bad hashlen");
    goto done;
  }
#line 234
  tmp = RSA_size((RSA const   *)rsa);
#line 234
  rsasize = (unsigned int )tmp;
#line 235
  if (siglen == 0U) {
#line 236
    error("bad siglen");
    goto done;
  } else {
#line 235
    if (siglen > rsasize) {
#line 236
      error("bad siglen");
      goto done;
    }
  }
#line 239
  tmp___0 = xmalloc(rsasize);
#line 239
  decrypted = (u_char *)tmp___0;
#line 240
  len = RSA_public_decrypt((int )siglen, (unsigned char const   *)sigbuf, decrypted,
                           rsa, 1);
#line 240
  if (len < 0) {
#line 242
    tmp___1 = ERR_get_error();
#line 242
    tmp___2 = ERR_error_string(tmp___1, (char *)((void *)0));
#line 242
    error("RSA_public_decrypt failed: %s", tmp___2);
    goto done;
  }
#line 246
  if (len < 0) {
#line 247
    error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
    goto done;
  } else {
#line 246
    if ((unsigned int )len != hlen + oidlen) {
#line 247
      error("bad decrypted len: %d != %d + %d", len, hlen, oidlen);
      goto done;
    }
  }
#line 250
  tmp___3 = memcmp((void const   *)decrypted, (void const   *)oid, oidlen);
#line 250
  if (tmp___3 != 0) {
#line 251
    error("oid mismatch");
    goto done;
  }
#line 254
  tmp___4 = memcmp((void const   *)(decrypted + oidlen), (void const   *)hash, hlen);
#line 254
  if (tmp___4 != 0) {
#line 255
    error("hash mismatch");
    goto done;
  }
#line 258
  ret___0 = 1U;
  done: 
#line 260
  if (decrypted) {
#line 261
    xfree((void *)decrypted);
  }
#line 262
  return ((int )ret___0);
}
}
#line 1 "dh.o"
#line 660 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 459 "/usr/include/openssl/bn.h"
extern int BN_is_bit_set(BIGNUM const   *a , int n ) ;
#line 173 "/usr/include/openssl/dh.h"
extern DH *DH_new(void) ;
#line 193
extern int DH_generate_key(DH *dh ) ;
#line 35 "dh.h"
DH *choose_dh(int min , int wantbits , int max ) ;
#line 36
DH *dh_new_group_asc(char const   *gen___1 , char const   *modulus ) ;
#line 37
DH *dh_new_group(BIGNUM *gen___1 , BIGNUM *modulus ) ;
#line 38
DH *dh_new_group1(void) ;
#line 39
DH *dh_new_group14(void) ;
#line 41
void dh_gen_key(DH *dh , int need ) ;
#line 42
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) ;
#line 44
int dh_estimate(int bits ) ;
#line 43 "dh.c"
static int parse_prime(int linenum , char *line , struct dhgroup *dhg ) 
{ char *cp ;
  char *arg ;
  char *strsize ;
  char *gen___1 ;
  char *prime ;
  char const   *errstr ;
  char *tmp___14 ;
  char *tmp___30 ;
  char *tmp___46 ;
  char *tmp___62 ;
  long long tmp___63 ;
  char *tmp___79 ;
  char *tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;

  {
#line 48
  errstr = (char const   *)((void *)0);
#line 50
  cp = line;
#line 51
  arg = strdelim(& cp);
#line 51
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 52
    return (0);
  }
#line 54
  if ((int )*arg == 0) {
#line 55
    arg = strdelim(& cp);
  }
#line 56
  if (! arg) {
#line 57
    return (0);
  } else {
#line 56
    if (! *arg) {
#line 57
      return (0);
    } else {
#line 56
      if ((int )*arg == 35) {
#line 57
        return (0);
      }
    }
  }
#line 60
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 60
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 62
  tmp___14 = __strsep_g(& cp, " ");
#line 62
  arg = tmp___14;
#line 63
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 63
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 65
  tmp___30 = __strsep_g(& cp, " ");
#line 65
  arg = tmp___30;
#line 66
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 66
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 68
  tmp___46 = __strsep_g(& cp, " ");
#line 68
  arg = tmp___46;
#line 69
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 69
    if ((int )*arg == 0) {
      goto fail;
    }
  }
#line 71
  tmp___62 = __strsep_g(& cp, " ");
#line 71
  strsize = tmp___62;
#line 72
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 72
    if ((int )*strsize == 0) {
      goto fail;
    } else {
#line 72
      tmp___63 = strtonum((char const   *)strsize, 0LL, 65536LL, & errstr);
#line 72
      dhg->size = (int )((unsigned int )tmp___63);
#line 72
      if (dhg->size == 0) {
        goto fail;
      } else {
#line 72
        if (errstr) {
          goto fail;
        }
      }
    }
  }
#line 77
  (dhg->size) ++;
#line 78
  tmp___79 = __strsep_g(& cp, " ");
#line 78
  gen___1 = tmp___79;
#line 79
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 79
    if ((int )*gen___1 == 0) {
      goto fail;
    }
  }
#line 81
  tmp___95 = __strsep_g(& cp, " ");
#line 81
  prime = tmp___95;
#line 82
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    goto fail;
  } else {
#line 82
    if ((int )*prime == 0) {
      goto fail;
    }
  }
#line 85
  dhg->g = BN_new();
#line 85
  if ((unsigned int )dhg->g == (unsigned int )((void *)0)) {
#line 86
    fatal("parse_prime: BN_new failed");
  }
#line 87
  dhg->p = BN_new();
#line 87
  if ((unsigned int )dhg->p == (unsigned int )((void *)0)) {
#line 88
    fatal("parse_prime: BN_new failed");
  }
#line 89
  tmp___96 = BN_hex2bn(& dhg->g, (char const   *)gen___1);
#line 89
  if (tmp___96 == 0) {
    goto failclean;
  }
#line 92
  tmp___97 = BN_hex2bn(& dhg->p, (char const   *)prime);
#line 92
  if (tmp___97 == 0) {
    goto failclean;
  }
#line 95
  tmp___98 = BN_num_bits((BIGNUM const   *)dhg->p);
#line 95
  if (tmp___98 != dhg->size) {
    goto failclean;
  }
#line 98
  if ((dhg->g)->top == 0) {
    goto failclean;
  } else {
#line 98
    if ((dhg->g)->top == 1) {
#line 98
      if (*((dhg->g)->d + 0) == 1UL) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 98
      if (0) {
        _L: /* CIL Label */ 
#line 98
        if (! (dhg->g)->neg) {
          goto failclean;
        }
      }
    }
  }
#line 101
  return (1);
  failclean: 
#line 104
  BN_clear_free(dhg->g);
#line 105
  BN_clear_free(dhg->p);
  fail: 
#line 107
  error("Bad prime description in line %d", linenum);
#line 108
  return (0);
}
}
#line 111 "dh.c"
DH *choose_dh(int min , int wantbits , int max ) 
{ FILE *f ;
  char line[4096] ;
  int best ;
  int bestcount ;
  int which ;
  int linenum ;
  struct dhgroup dhg ;
  DH *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  DH *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  DH *tmp___7 ;

  {
#line 120
  f = fopen((char const   * __restrict  )"/usr/local/etc/moduli", (char const   * __restrict  )"r");
#line 120
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 120
    f = fopen((char const   * __restrict  )"/usr/local/etc/primes", (char const   * __restrict  )"r");
#line 120
    if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 122
      logit("WARNING: %s does not exist, using fixed modulus", "/usr/local/etc/moduli");
#line 124
      tmp = dh_new_group14();
#line 124
      return (tmp);
    }
  }
#line 127
  linenum = 0;
#line 128
  bestcount = 0;
#line 128
  best = bestcount;
#line 129
  while (1) {
#line 129
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 129
    if (! tmp___1) {
#line 129
      break;
    }
#line 130
    linenum ++;
#line 131
    tmp___0 = parse_prime(linenum, line, & dhg);
#line 131
    if (! tmp___0) {
#line 132
      continue;
    }
#line 133
    BN_clear_free(dhg.g);
#line 134
    BN_clear_free(dhg.p);
#line 136
    if (dhg.size > max) {
#line 137
      continue;
    } else {
#line 136
      if (dhg.size < min) {
#line 137
        continue;
      }
    }
#line 139
    if (dhg.size > wantbits) {
#line 139
      if (dhg.size < best) {
#line 141
        best = dhg.size;
#line 142
        bestcount = 0;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 139
      if (dhg.size > best) {
#line 139
        if (best < wantbits) {
#line 141
          best = dhg.size;
#line 142
          bestcount = 0;
        }
      }
    }
#line 144
    if (dhg.size == best) {
#line 145
      bestcount ++;
    }
  }
#line 147
  rewind(f);
#line 149
  if (bestcount == 0) {
#line 150
    fclose(f);
#line 151
    logit("WARNING: no suitable primes in %s", "/usr/local/etc/primes");
#line 152
    tmp___2 = dh_new_group14();
#line 152
    return (tmp___2);
  }
#line 155
  linenum = 0;
#line 156
  tmp___3 = arc4random();
#line 156
  which = (int )(tmp___3 % (unsigned int )bestcount);
#line 157
  while (1) {
#line 157
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 157
    if (! tmp___6) {
#line 157
      break;
    }
#line 158
    tmp___4 = parse_prime(linenum, line, & dhg);
#line 158
    if (! tmp___4) {
#line 159
      continue;
    }
#line 160
    if (dhg.size > max) {
#line 163
      BN_clear_free(dhg.g);
#line 164
      BN_clear_free(dhg.p);
#line 165
      continue;
    } else {
#line 160
      if (dhg.size < min) {
#line 163
        BN_clear_free(dhg.g);
#line 164
        BN_clear_free(dhg.p);
#line 165
        continue;
      } else {
#line 160
        if (dhg.size != best) {
#line 163
          BN_clear_free(dhg.g);
#line 164
          BN_clear_free(dhg.p);
#line 165
          continue;
        } else {
#line 160
          tmp___5 = linenum;
#line 160
          linenum ++;
#line 160
          if (tmp___5 != which) {
#line 163
            BN_clear_free(dhg.g);
#line 164
            BN_clear_free(dhg.p);
#line 165
            continue;
          }
        }
      }
    }
#line 167
    break;
  }
#line 169
  fclose(f);
#line 170
  if (linenum != which + 1) {
#line 171
    fatal("WARNING: line %d disappeared in %s, giving up", which, "/usr/local/etc/primes");
  }
#line 174
  tmp___7 = dh_new_group(dhg.g, dhg.p);
#line 174
  return (tmp___7);
}
}
#line 179 "dh.c"
int dh_pub_is_valid(DH *dh , BIGNUM *dh_pub ) 
{ int i ;
  int n___0 ;
  int tmp ;
  int bits_set ;
  BIGNUM *tmp___0 ;
  BIGNUM const   *tmp___1 ;
  int tmp___2 ;
  BIGNUM const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 183
  tmp = BN_num_bits((BIGNUM const   *)dh_pub);
#line 183
  n___0 = tmp;
#line 184
  bits_set = 0;
#line 187
  if (dh_pub->neg) {
#line 188
    logit("invalid public DH value: negative");
#line 189
    return (0);
  }
#line 191
  tmp___1 = BN_value_one();
#line 191
  tmp___2 = BN_cmp((BIGNUM const   *)dh_pub, tmp___1);
#line 191
  if (tmp___2 != 1) {
#line 192
    logit("invalid public DH value: <= 1");
#line 193
    return (0);
  }
#line 196
  tmp___0 = BN_new();
#line 196
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 197
    error("%s: BN_new failed", "dh_pub_is_valid");
#line 198
    return (0);
  }
#line 200
  tmp___3 = BN_value_one();
#line 200
  tmp___4 = BN_sub(tmp___0, (BIGNUM const   *)dh->p, tmp___3);
#line 200
  if (tmp___4) {
#line 200
    tmp___5 = BN_cmp((BIGNUM const   *)dh_pub, (BIGNUM const   *)tmp___0);
#line 200
    if (tmp___5 != -1) {
#line 202
      BN_clear_free(tmp___0);
#line 203
      logit("invalid public DH value: >= p-1");
#line 204
      return (0);
    }
  } else {
#line 202
    BN_clear_free(tmp___0);
#line 203
    logit("invalid public DH value: >= p-1");
#line 204
    return (0);
  }
#line 206
  BN_clear_free(tmp___0);
#line 208
  i = 0;
#line 208
  while (i <= n___0) {
#line 209
    tmp___6 = BN_is_bit_set((BIGNUM const   *)dh_pub, i);
#line 209
    if (tmp___6) {
#line 210
      bits_set ++;
    }
#line 208
    i ++;
  }
#line 211
  tmp___7 = BN_num_bits((BIGNUM const   *)dh->p);
#line 211
  debug2("bits set: %d/%d", bits_set, tmp___7);
#line 214
  if (bits_set > 1) {
#line 215
    return (1);
  }
#line 217
  tmp___8 = BN_num_bits((BIGNUM const   *)dh->p);
#line 217
  logit("invalid public DH value (%d/%d)", bits_set, tmp___8);
#line 218
  return (0);
}
}
#line 221 "dh.c"
void dh_gen_key(DH *dh , int need ) 
{ int i ;
  int bits_set ;
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 224
  tries = 0;
#line 226
  if ((unsigned int )dh->p == (unsigned int )((void *)0)) {
#line 227
    fatal("dh_gen_key: dh->p == NULL");
  }
#line 228
  if (need > 1073741823) {
#line 229
    tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 229
    fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
  } else {
#line 228
    tmp___0 = BN_num_bits((BIGNUM const   *)dh->p);
#line 228
    if (2 * need >= tmp___0) {
#line 229
      tmp = BN_num_bits((BIGNUM const   *)dh->p);
#line 229
      fatal("dh_gen_key: group too small: %d (2*need %d)", tmp, 2 * need);
    }
  }
#line 231
  while (1) {
#line 232
    if ((unsigned int )dh->priv_key != (unsigned int )((void *)0)) {
#line 233
      BN_clear_free(dh->priv_key);
    }
#line 234
    dh->priv_key = BN_new();
#line 234
    if ((unsigned int )dh->priv_key == (unsigned int )((void *)0)) {
#line 235
      fatal("dh_gen_key: BN_new failed");
    }
#line 237
    tmp___1 = BN_rand(dh->priv_key, 2 * need, 0, 0);
#line 237
    if (! tmp___1) {
#line 238
      fatal("dh_gen_key: BN_rand failed");
    }
#line 239
    tmp___2 = DH_generate_key(dh);
#line 239
    if (tmp___2 == 0) {
#line 240
      fatal("DH_generate_key");
    }
#line 241
    i = 0;
#line 241
    bits_set = 0;
#line 241
    while (1) {
#line 241
      tmp___4 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 241
      if (! (i <= tmp___4)) {
#line 241
        break;
      }
#line 242
      tmp___3 = BN_is_bit_set((BIGNUM const   *)dh->priv_key, i);
#line 242
      if (tmp___3) {
#line 243
        bits_set ++;
      }
#line 241
      i ++;
    }
#line 244
    tmp___5 = BN_num_bits((BIGNUM const   *)dh->priv_key);
#line 244
    debug2("dh_gen_key: priv key bits set: %d/%d", bits_set, tmp___5);
#line 246
    tmp___6 = tries;
#line 246
    tries ++;
#line 246
    if (tmp___6 > 10) {
#line 247
      fatal("dh_gen_key: too many bad keys: giving up");
    }
#line 231
    tmp___7 = dh_pub_is_valid(dh, dh->pub_key);
#line 231
    if (tmp___7) {
#line 231
      break;
    }
  }
#line 249
  return;
}
}
#line 251 "dh.c"
DH *dh_new_group_asc(char const   *gen___1 , char const   *modulus ) 
{ DH *dh ;
  int tmp ;
  int tmp___0 ;

  {
#line 256
  dh = DH_new();
#line 256
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 257
    fatal("dh_new_group_asc: DH_new");
  }
#line 259
  tmp = BN_hex2bn(& dh->p, modulus);
#line 259
  if (tmp == 0) {
#line 260
    fatal("BN_hex2bn p");
  }
#line 261
  tmp___0 = BN_hex2bn(& dh->g, gen___1);
#line 261
  if (tmp___0 == 0) {
#line 262
    fatal("BN_hex2bn g");
  }
#line 264
  return (dh);
}
}
#line 272 "dh.c"
DH *dh_new_group(BIGNUM *gen___1 , BIGNUM *modulus ) 
{ DH *dh ;

  {
#line 277
  dh = DH_new();
#line 277
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 278
    fatal("dh_new_group: DH_new");
  }
#line 279
  dh->p = modulus;
#line 280
  dh->g = gen___1;
#line 282
  return (dh);
}
}
#line 288 "dh.c"
static char *gen  =    (char *)"2";
#line 288 "dh.c"
static char *group1  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF";
#line 285 "dh.c"
DH *dh_new_group1(void) 
{ DH *tmp ;

  {
#line 296
  tmp = dh_new_group_asc((char const   *)gen, (char const   *)group1);
#line 296
  return (tmp);
}
}
#line 302 "dh.c"
static char *gen___0  =    (char *)"2";
#line 302 "dh.c"
static char *group14  =    (char *)"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF";
#line 299 "dh.c"
DH *dh_new_group14(void) 
{ DH *tmp ;

  {
#line 315
  tmp = dh_new_group_asc((char const   *)gen___0, (char const   *)group14);
#line 315
  return (tmp);
}
}
#line 324 "dh.c"
int dh_estimate(int bits ) 
{ 

  {
#line 328
  if (bits <= 128) {
#line 329
    return (1024);
  }
#line 330
  if (bits <= 192) {
#line 331
    return (2048);
  }
#line 332
  return (4096);
}
}
#line 1 "kexdh.o"
#line 144 "kex.h"
void kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) ;
#line 53 "kexdh.c"
static u_char digest[64]  ;
#line 40 "kexdh.c"
void kex_dh_hash(char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) 
{ Buffer b ;
  EVP_MD const   *evp_md ;
  EVP_MD const   *tmp ;
  EVP_MD_CTX md ;
  u_int tmp___0 ;
  void *tmp___1 ;

  {
#line 54
  tmp = EVP_sha1();
#line 54
  evp_md = tmp;
#line 57
  buffer_init(& b);
#line 58
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 59
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 62
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 63
  buffer_put_char(& b, 20);
#line 64
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 65
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 66
  buffer_put_char(& b, 20);
#line 67
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 69
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 70
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 71
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 72
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 77
  EVP_DigestInit(& md, evp_md);
#line 78
  tmp___0 = buffer_len(& b);
#line 78
  tmp___1 = buffer_ptr(& b);
#line 78
  EVP_DigestUpdate(& md, (void const   *)tmp___1, tmp___0);
#line 79
  EVP_DigestFinal(& md, digest, (unsigned int *)((void *)0));
#line 81
  buffer_free(& b);
#line 86
  *hash = digest;
#line 87
  *hashlen = (unsigned int )evp_md->md_size;
#line 88
  return;
}
}
#line 1 "kexgex.o"
#line 147 "kex.h"
void kexgex_hash(EVP_MD const   *evp_md , char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                 int max , BIGNUM *prime , BIGNUM *gen___1 , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) ;
#line 55 "kexgex.c"
static u_char digest___0[64]  ;
#line 40 "kexgex.c"
void kexgex_hash(EVP_MD const   *evp_md , char *client_version_string___0 , char *server_version_string___0 ,
                 char *ckexinit , int ckexinitlen , char *skexinit , int skexinitlen ,
                 u_char *serverhostkeyblob , int sbloblen , int min , int wantbits ,
                 int max , BIGNUM *prime , BIGNUM *gen___1 , BIGNUM *client_dh_pub ,
                 BIGNUM *server_dh_pub , BIGNUM *shared_secret , u_char **hash , u_int *hashlen ) 
{ Buffer b ;
  EVP_MD_CTX md ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 58
  buffer_init(& b);
#line 59
  buffer_put_cstring(& b, (char const   *)client_version_string___0);
#line 60
  buffer_put_cstring(& b, (char const   *)server_version_string___0);
#line 63
  buffer_put_int(& b, (unsigned int )(ckexinitlen + 1));
#line 64
  buffer_put_char(& b, 20);
#line 65
  buffer_append(& b, (void const   *)ckexinit, (unsigned int )ckexinitlen);
#line 66
  buffer_put_int(& b, (unsigned int )(skexinitlen + 1));
#line 67
  buffer_put_char(& b, 20);
#line 68
  buffer_append(& b, (void const   *)skexinit, (unsigned int )skexinitlen);
#line 70
  buffer_put_string(& b, (void const   *)serverhostkeyblob, (unsigned int )sbloblen);
#line 71
  if (min == -1) {
#line 72
    buffer_put_int(& b, (unsigned int )wantbits);
  } else {
#line 71
    if (max == -1) {
#line 72
      buffer_put_int(& b, (unsigned int )wantbits);
    } else {
#line 74
      buffer_put_int(& b, (unsigned int )min);
#line 75
      buffer_put_int(& b, (unsigned int )wantbits);
#line 76
      buffer_put_int(& b, (unsigned int )max);
    }
  }
#line 78
  buffer_put_bignum2(& b, (BIGNUM const   *)prime);
#line 79
  buffer_put_bignum2(& b, (BIGNUM const   *)gen___1);
#line 80
  buffer_put_bignum2(& b, (BIGNUM const   *)client_dh_pub);
#line 81
  buffer_put_bignum2(& b, (BIGNUM const   *)server_dh_pub);
#line 82
  buffer_put_bignum2(& b, (BIGNUM const   *)shared_secret);
#line 88
  EVP_DigestInit(& md, evp_md);
#line 89
  tmp = buffer_len(& b);
#line 89
  tmp___0 = buffer_ptr(& b);
#line 89
  EVP_DigestUpdate(& md, (void const   *)tmp___0, tmp);
#line 90
  EVP_DigestFinal(& md, digest___0, (unsigned int *)((void *)0));
#line 92
  buffer_free(& b);
#line 93
  *hash = digest___0;
#line 94
  *hashlen = (unsigned int )evp_md->md_size;
#line 98
  return;
}
}
#line 1 "kexdhc.o"
#line 174 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 176
extern int DH_size(DH const   *dh ) ;
#line 194
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 139 "kex.h"
void kexdh_client(Kex *kex ) ;
#line 45 "kexdhc.c"
void kexdh_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  DH *dh ;
  Key *server_host_key ;
  u_char *server_host_key_blob ;
  u_char *signature ;
  u_char *kbuf ;
  u_char *hash ;
  u_int klen ;
  u_int slen ;
  u_int sbloblen ;
  u_int hashlen ;
  int kout ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  BIGNUM *tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;

  {
#line 48
  dh_server_pub = (BIGNUM *)((void *)0);
#line 48
  shared_secret = (BIGNUM *)((void *)0);
#line 51
  server_host_key_blob = (u_char *)((void *)0);
#line 51
  signature = (u_char *)((void *)0);
#line 57
  switch (kex->kex_type) {
  case 0: 
#line 59
  dh = dh_new_group1();
#line 60
  break;
  case 1: 
#line 62
  dh = dh_new_group14();
#line 63
  break;
  default: 
#line 65
  fatal("%s: Unexpected KEX type %d", "kexdh_client", kex->kex_type);
  }
#line 67
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 68
  packet_start((unsigned char)30);
#line 69
  packet_put_bignum2(dh->pub_key);
#line 70
  packet_send();
#line 72
  debug("sending SSH2_MSG_KEXDH_INIT");
#line 80
  debug("expecting SSH2_MSG_KEXDH_REPLY");
#line 81
  packet_read_expect(31);
#line 84
  tmp = packet_get_string(& sbloblen);
#line 84
  server_host_key_blob = (u_char *)tmp;
#line 85
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 86
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 87
    fatal("cannot decode server_host_key_blob");
  }
#line 88
  if (server_host_key->type != kex->hostkey_type) {
#line 89
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 90
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 91
    fatal("cannot verify server_host_key");
  }
#line 92
  tmp___0 = (*(kex->verify_host_key))(server_host_key);
#line 92
  if (tmp___0 == -1) {
#line 93
    fatal("server_host_key verification failed");
  }
#line 96
  dh_server_pub = BN_new();
#line 96
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 97
    fatal("dh_server_pub == NULL");
  }
#line 98
  packet_get_bignum2(dh_server_pub);
#line 108
  tmp___1 = packet_get_string(& slen);
#line 108
  signature = (u_char *)tmp___1;
#line 109
  while (1) {
#line 109
    tmp___2 = packet_remaining();
#line 109
    _len = tmp___2;
#line 109
    if (_len > 0) {
#line 109
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhc.c",
            109);
#line 109
      packet_disconnect("Packet integrity error.");
    }
#line 109
    break;
  }
#line 111
  tmp___3 = dh_pub_is_valid(dh, dh_server_pub);
#line 111
  if (! tmp___3) {
#line 112
    packet_disconnect("bad server public DH value");
  }
#line 114
  tmp___4 = DH_size((DH const   *)dh);
#line 114
  klen = (unsigned int )tmp___4;
#line 115
  tmp___5 = xmalloc(klen);
#line 115
  kbuf = (u_char *)tmp___5;
#line 116
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 116
  if (kout < 0) {
#line 117
    fatal("DH_compute_key: failed");
  }
#line 121
  shared_secret = BN_new();
#line 121
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 122
    fatal("kexdh_client: BN_new failed");
  }
#line 123
  tmp___6 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 123
  if ((unsigned int )tmp___6 == (unsigned int )((void *)0)) {
#line 124
    fatal("kexdh_client: BN_bin2bn failed");
  }
#line 125
  memset((void *)kbuf, 0, klen);
#line 126
  xfree((void *)kbuf);
#line 129
  tmp___7 = buffer_len(& kex->peer);
#line 129
  tmp___8 = buffer_ptr(& kex->peer);
#line 129
  tmp___9 = buffer_len(& kex->my);
#line 129
  tmp___10 = buffer_ptr(& kex->my);
#line 129
  kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___10,
              (int )tmp___9, (char *)tmp___8, (int )tmp___7, server_host_key_blob,
              (int )sbloblen, dh->pub_key, dh_server_pub, shared_secret, & hash, & hashlen);
#line 140
  xfree((void *)server_host_key_blob);
#line 141
  BN_clear_free(dh_server_pub);
#line 142
  DH_free(dh);
#line 144
  tmp___11 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, hashlen);
#line 144
  if (tmp___11 != 1) {
#line 145
    fatal("key_verify failed for server_host_key");
  }
#line 146
  key_free(server_host_key);
#line 147
  xfree((void *)signature);
#line 150
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 151
    kex->session_id_len = hashlen;
#line 152
    tmp___12 = xmalloc(kex->session_id_len);
#line 152
    kex->session_id = (u_char *)tmp___12;
#line 153
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 156
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 157
  BN_clear_free(shared_secret);
#line 158
  kex_finish(kex);
#line 159
  return;
}
}
#line 1 "kexgexc.o"
#line 141 "kex.h"
void kexgex_client(Kex *kex ) ;
#line 47 "kexgexc.c"
void kexgex_client(Kex *kex ) 
{ BIGNUM *dh_server_pub ;
  BIGNUM *shared_secret ;
  BIGNUM *p ;
  BIGNUM *g ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int klen ;
  u_int slen ;
  u_int sbloblen ;
  u_int hashlen ;
  int kout ;
  int min ;
  int max ;
  int nbits ;
  DH *dh ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  BIGNUM *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 50
  dh_server_pub = (BIGNUM *)((void *)0);
#line 50
  shared_secret = (BIGNUM *)((void *)0);
#line 51
  p = (BIGNUM *)((void *)0);
#line 51
  g = (BIGNUM *)((void *)0);
#line 53
  signature = (u_char *)((void *)0);
#line 53
  server_host_key_blob = (u_char *)((void *)0);
#line 59
  nbits = dh_estimate((int )(kex->we_need * 8U));
#line 61
  if (datafellows & 16384) {
#line 63
    packet_start((unsigned char)30);
#line 64
    packet_put_int((unsigned int )nbits);
#line 65
    min = 1024;
#line 66
    max = 8192;
#line 68
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD(%u) sent", nbits);
  } else {
#line 71
    min = 1024;
#line 72
    max = 8192;
#line 73
    packet_start((unsigned char)34);
#line 74
    packet_put_int((unsigned int )min);
#line 75
    packet_put_int((unsigned int )nbits);
#line 76
    packet_put_int((unsigned int )max);
#line 78
    debug("SSH2_MSG_KEX_DH_GEX_REQUEST(%u<%u<%u) sent", min, nbits, max);
  }
#line 85
  packet_send();
#line 87
  debug("expecting SSH2_MSG_KEX_DH_GEX_GROUP");
#line 88
  packet_read_expect(31);
#line 90
  p = BN_new();
#line 90
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 91
    fatal("BN_new");
  }
#line 92
  packet_get_bignum2(p);
#line 93
  g = BN_new();
#line 93
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 94
    fatal("BN_new");
  }
#line 95
  packet_get_bignum2(g);
#line 96
  while (1) {
#line 96
    tmp = packet_remaining();
#line 96
    _len = tmp;
#line 96
    if (_len > 0) {
#line 96
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexc.c",
            96);
#line 96
      packet_disconnect("Packet integrity error.");
    }
#line 96
    break;
  }
#line 98
  tmp___1 = BN_num_bits((BIGNUM const   *)p);
#line 98
  if (tmp___1 < min) {
#line 99
    tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 99
    fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
  } else {
#line 98
    tmp___2 = BN_num_bits((BIGNUM const   *)p);
#line 98
    if (tmp___2 > max) {
#line 99
      tmp___0 = BN_num_bits((BIGNUM const   *)p);
#line 99
      fatal("DH_GEX group out of range: %d !< %d !< %d", min, tmp___0, max);
    }
  }
#line 102
  dh = dh_new_group(g, p);
#line 103
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 112
  debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
#line 114
  packet_start((unsigned char)32);
#line 115
  packet_put_bignum2(dh->pub_key);
#line 116
  packet_send();
#line 118
  debug("expecting SSH2_MSG_KEX_DH_GEX_REPLY");
#line 119
  packet_read_expect(33);
#line 122
  tmp___3 = packet_get_string(& sbloblen);
#line 122
  server_host_key_blob = (u_char *)tmp___3;
#line 123
  server_host_key = key_from_blob((u_char const   *)server_host_key_blob, sbloblen);
#line 124
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 125
    fatal("cannot decode server_host_key_blob");
  }
#line 126
  if (server_host_key->type != kex->hostkey_type) {
#line 127
    fatal("type mismatch for decoded server_host_key_blob");
  }
#line 128
  if ((unsigned int )kex->verify_host_key == (unsigned int )((void *)0)) {
#line 129
    fatal("cannot verify server_host_key");
  }
#line 130
  tmp___4 = (*(kex->verify_host_key))(server_host_key);
#line 130
  if (tmp___4 == -1) {
#line 131
    fatal("server_host_key verification failed");
  }
#line 134
  dh_server_pub = BN_new();
#line 134
  if ((unsigned int )dh_server_pub == (unsigned int )((void *)0)) {
#line 135
    fatal("dh_server_pub == NULL");
  }
#line 136
  packet_get_bignum2(dh_server_pub);
#line 146
  tmp___5 = packet_get_string(& slen);
#line 146
  signature = (u_char *)tmp___5;
#line 147
  while (1) {
#line 147
    tmp___6 = packet_remaining();
#line 147
    _len___0 = tmp___6;
#line 147
    if (_len___0 > 0) {
#line 147
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexc.c",
            147);
#line 147
      packet_disconnect("Packet integrity error.");
    }
#line 147
    break;
  }
#line 149
  tmp___7 = dh_pub_is_valid(dh, dh_server_pub);
#line 149
  if (! tmp___7) {
#line 150
    packet_disconnect("bad server public DH value");
  }
#line 152
  tmp___8 = DH_size((DH const   *)dh);
#line 152
  klen = (unsigned int )tmp___8;
#line 153
  tmp___9 = xmalloc(klen);
#line 153
  kbuf = (u_char *)tmp___9;
#line 154
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_server_pub, dh);
#line 154
  if (kout < 0) {
#line 155
    fatal("DH_compute_key: failed");
  }
#line 159
  shared_secret = BN_new();
#line 159
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 160
    fatal("kexgex_client: BN_new failed");
  }
#line 161
  tmp___10 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 161
  if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
#line 162
    fatal("kexgex_client: BN_bin2bn failed");
  }
#line 163
  memset((void *)kbuf, 0, klen);
#line 164
  xfree((void *)kbuf);
#line 166
  if (datafellows & 16384) {
#line 167
    max = -1;
#line 167
    min = max;
  }
#line 170
  tmp___11 = buffer_len(& kex->peer);
#line 170
  tmp___12 = buffer_ptr(& kex->peer);
#line 170
  tmp___13 = buffer_len(& kex->my);
#line 170
  tmp___14 = buffer_ptr(& kex->my);
#line 170
  kexgex_hash(kex->evp_md, kex->client_version_string, kex->server_version_string,
              (char *)tmp___14, (int )tmp___13, (char *)tmp___12, (int )tmp___11,
              server_host_key_blob, (int )sbloblen, min, nbits, max, dh->p, dh->g,
              dh->pub_key, dh_server_pub, shared_secret, & hash, & hashlen);
#line 186
  DH_free(dh);
#line 187
  xfree((void *)server_host_key_blob);
#line 188
  BN_clear_free(dh_server_pub);
#line 190
  tmp___15 = key_verify((Key const   *)server_host_key, (u_char const   *)signature,
                        slen, (u_char const   *)hash, hashlen);
#line 190
  if (tmp___15 != 1) {
#line 191
    fatal("key_verify failed for server_host_key");
  }
#line 192
  key_free(server_host_key);
#line 193
  xfree((void *)signature);
#line 196
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 197
    kex->session_id_len = hashlen;
#line 198
    tmp___16 = xmalloc(kex->session_id_len);
#line 198
    kex->session_id = (u_char *)tmp___16;
#line 199
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 201
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 202
  BN_clear_free(shared_secret);
#line 204
  kex_finish(kex);
#line 205
  return;
}
}
#line 1 "scard.o"
#line 1 "msg.o"
#line 28 "msg.h"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) ;
#line 29
int ssh_msg_recv(int fd , Buffer *m___0 ) ;
#line 43 "msg.c"
int ssh_msg_send(int fd , u_char type , Buffer *m___0 ) 
{ u_char buf___1[5] ;
  u_int mlen ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 47
  tmp = buffer_len(m___0);
#line 47
  mlen = tmp;
#line 49
  debug3("ssh_msg_send: type %u", (unsigned int )type & 255U);
#line 51
  put_u32((void *)(buf___1), mlen + 1U);
#line 52
  buf___1[4] = type;
#line 53
  tmp___0 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(buf___1),
                     sizeof(buf___1));
#line 53
  if (tmp___0 != sizeof(buf___1)) {
#line 54
    error("ssh_msg_send: write");
#line 55
    return (-1);
  }
#line 57
  tmp___1 = buffer_ptr(m___0);
#line 57
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, tmp___1,
                     mlen);
#line 57
  if (tmp___2 != mlen) {
#line 58
    error("ssh_msg_send: write");
#line 59
    return (-1);
  }
#line 61
  return (0);
}
}
#line 64 "msg.c"
int ssh_msg_recv(int fd , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  u_int msg_len ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
#line 70
  debug3("ssh_msg_recv entering");
#line 72
  tmp___0 = atomicio(& read, fd, (void *)(buf___1), sizeof(buf___1));
#line 72
  if (tmp___0 != sizeof(buf___1)) {
#line 73
    tmp = __errno_location();
#line 73
    if (*tmp != 32) {
#line 74
      error("ssh_msg_recv: read: header");
    }
#line 75
    return (-1);
  }
#line 77
  msg_len = get_u32((void const   *)(buf___1));
#line 78
  if (msg_len > 262144U) {
#line 79
    error("ssh_msg_recv: read: bad msg_len %u", msg_len);
#line 80
    return (-1);
  }
#line 82
  buffer_clear(m___0);
#line 83
  buffer_append_space(m___0, msg_len);
#line 84
  tmp___3 = buffer_ptr(m___0);
#line 84
  tmp___4 = atomicio(& read, fd, tmp___3, msg_len);
#line 84
  if (tmp___4 != msg_len) {
#line 85
    tmp___1 = __errno_location();
#line 85
    tmp___2 = strerror(*tmp___1);
#line 85
    error("ssh_msg_recv: read: %s", tmp___2);
#line 86
    return (-1);
  }
#line 88
  return (0);
}
}
#line 1 "progressmeter.o"
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 581
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 805
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 26 "progressmeter.h"
void start_progress_meter(char *f , off_t filesize , off_t *ctr ) ;
#line 27
void stop_progress_meter(void) ;
#line 50 "progressmeter.c"
static int can_output(void) ;
#line 53
static void format_size(char *buf___1 , int size , off_t bytes ) ;
#line 54
static void format_rate(char *buf___1 , int size , off_t bytes ) ;
#line 57
static void sig_winch(int sig ) ;
#line 58
static void setscreensize(void) ;
#line 61
void refresh_progress_meter(void) ;
#line 64
static void update_progress_meter(int ignore ) ;
#line 66 "progressmeter.c"
static time_t start  ;
#line 67 "progressmeter.c"
static time_t last_update  ;
#line 68 "progressmeter.c"
static char *file  ;
#line 69 "progressmeter.c"
static off_t end_pos  ;
#line 70 "progressmeter.c"
static off_t cur_pos  ;
#line 71 "progressmeter.c"
static off_t volatile   *counter  ;
#line 72 "progressmeter.c"
static long stalled  ;
#line 73 "progressmeter.c"
static int bytes_per_second  ;
#line 74 "progressmeter.c"
static int win_size  ;
#line 75 "progressmeter.c"
static sig_atomic_t volatile   win_resized  ;
#line 78 "progressmeter.c"
static char const   unit[6]  = {      (char const   )' ',      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'\000'};
#line 80 "progressmeter.c"
static int can_output(void) 
{ __pid_t tmp ;
  __pid_t tmp___0 ;

  {
#line 83
  tmp = getpgrp();
#line 83
  tmp___0 = tcgetpgrp(1);
#line 83
  return (tmp == tmp___0);
}
}
#line 86 "progressmeter.c"
static void format_rate(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 91
  bytes *= 100LL;
#line 92
  i = 0;
#line 92
  while (1) {
#line 92
    if (bytes >= 100000LL) {
#line 92
      if (! ((int const   )unit[i] != 84)) {
#line 92
        break;
      }
    } else {
#line 92
      break;
    }
#line 93
    bytes = (bytes + 512LL) / 1024LL;
#line 92
    i ++;
  }
#line 94
  if (i == 0) {
#line 95
    i ++;
#line 96
    bytes = (bytes + 512LL) / 1024LL;
  }
#line 98
  if (i) {
#line 98
    tmp = "B";
  } else {
#line 98
    tmp = " ";
  }
#line 98
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%3lld.%1lld%c%s",
           (bytes + 5LL) / 100LL, ((bytes + 5LL) / 10LL) % 10LL, unit[i], tmp);
#line 103
  return;
}
}
#line 105 "progressmeter.c"
static void format_size(char *buf___1 , int size , off_t bytes ) 
{ int i ;
  char const   *tmp ;

  {
#line 110
  i = 0;
#line 110
  while (1) {
#line 110
    if (bytes >= 10000LL) {
#line 110
      if (! ((int const   )unit[i] != 84)) {
#line 110
        break;
      }
    } else {
#line 110
      break;
    }
#line 111
    bytes = (bytes + 512LL) / 1024LL;
#line 110
    i ++;
  }
#line 112
  if (i) {
#line 112
    tmp = "B";
  } else {
#line 112
    tmp = " ";
  }
#line 112
  snprintf((char * __restrict  )buf___1, (unsigned int )size, (char const   * __restrict  )"%4lld%c%s",
           bytes, unit[i], tmp);
#line 116
  return;
}
}
#line 118 "progressmeter.c"
void refresh_progress_meter(void) 
{ char buf___1[513] ;
  time_t now ;
  off_t transferred ;
  double elapsed ;
  int percent ;
  off_t bytes_left ;
  int cur_speed ;
  int hours ;
  int minutes ;
  int seconds ;
  int i ;
  int len ;
  int file_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 132
  transferred = (long long )(*counter - (off_t volatile   )cur_pos);
#line 133
  cur_pos = (long long )*counter;
#line 134
  now = time((time_t *)((void *)0));
#line 135
  bytes_left = end_pos - cur_pos;
#line 137
  if (bytes_left > 0LL) {
#line 138
    elapsed = (double )(now - last_update);
  } else {
#line 140
    elapsed = (double )(now - start);
#line 142
    transferred = end_pos;
#line 143
    bytes_per_second = 0;
  }
#line 147
  if (elapsed != (double )0) {
#line 148
    cur_speed = (int )((double )transferred / elapsed);
  } else {
#line 150
    cur_speed = (int )transferred;
  }
#line 153
  if (bytes_per_second != 0) {
#line 154
    bytes_per_second = (int )((double )bytes_per_second * 0.9 + (double )cur_speed * (1.0 - 0.9));
  } else {
#line 157
    bytes_per_second = cur_speed;
  }
#line 160
  buf___1[0] = (char )'\000';
#line 161
  file_len = win_size - 35;
#line 162
  if (file_len > 0) {
#line 163
    len = snprintf((char * __restrict  )(buf___1), (unsigned int )(file_len + 1),
                   (char const   * __restrict  )"\r%s", file);
#line 164
    if (len < 0) {
#line 165
      len = 0;
    }
#line 166
    if (len >= file_len + 1) {
#line 167
      len = file_len;
    }
#line 168
    i = len;
#line 168
    while (i < file_len) {
#line 169
      buf___1[i] = (char )' ';
#line 168
      i ++;
    }
#line 170
    buf___1[file_len] = (char )'\000';
  }
#line 174
  if (end_pos != 0LL) {
#line 175
    percent = (int )(((float )cur_pos / (float )end_pos) * (float )100);
  } else {
#line 177
    percent = 100;
  }
#line 178
  tmp = strlen((char const   *)(buf___1));
#line 178
  tmp___0 = strlen((char const   *)(buf___1));
#line 178
  snprintf((char * __restrict  )(buf___1 + tmp___0), (size_t )win_size - tmp, (char const   * __restrict  )" %3d%% ",
           percent);
#line 182
  tmp___1 = strlen((char const   *)(buf___1));
#line 182
  tmp___2 = strlen((char const   *)(buf___1));
#line 182
  format_size(buf___1 + tmp___2, (int )((size_t )win_size - tmp___1), cur_pos);
#line 184
  strlcat(buf___1, " ", (unsigned int )win_size);
#line 187
  tmp___3 = strlen((char const   *)(buf___1));
#line 187
  tmp___4 = strlen((char const   *)(buf___1));
#line 187
  format_rate(buf___1 + tmp___4, (int )((size_t )win_size - tmp___3), (long long )bytes_per_second);
#line 189
  strlcat(buf___1, "/s ", (unsigned int )win_size);
#line 192
  if (! transferred) {
#line 193
    stalled = (long )((double )stalled + elapsed);
  } else {
#line 195
    stalled = 0L;
  }
#line 197
  if (stalled >= 5L) {
#line 198
    strlcat(buf___1, "- stalled -", (unsigned int )win_size);
  } else {
#line 199
    if (bytes_per_second == 0) {
#line 199
      if (bytes_left) {
#line 200
        strlcat(buf___1, "  --:-- ETA", (unsigned int )win_size);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 202
      if (bytes_left > 0LL) {
#line 203
        seconds = (int )(bytes_left / (off_t )bytes_per_second);
      } else {
#line 205
        seconds = (int )elapsed;
      }
#line 207
      hours = seconds / 3600;
#line 208
      seconds -= hours * 3600;
#line 209
      minutes = seconds / 60;
#line 210
      seconds -= minutes * 60;
#line 212
      if (hours != 0) {
#line 213
        tmp___5 = strlen((char const   *)(buf___1));
#line 213
        tmp___6 = strlen((char const   *)(buf___1));
#line 213
        snprintf((char * __restrict  )(buf___1 + tmp___6), (size_t )win_size - tmp___5,
                 (char const   * __restrict  )"%d:%02d:%02d", hours, minutes, seconds);
      } else {
#line 216
        tmp___7 = strlen((char const   *)(buf___1));
#line 216
        tmp___8 = strlen((char const   *)(buf___1));
#line 216
        snprintf((char * __restrict  )(buf___1 + tmp___8), (size_t )win_size - tmp___7,
                 (char const   * __restrict  )"  %02d:%02d", minutes, seconds);
      }
#line 219
      if (bytes_left > 0LL) {
#line 220
        strlcat(buf___1, " ETA", (unsigned int )win_size);
      } else {
#line 222
        strlcat(buf___1, "    ", (unsigned int )win_size);
      }
    }
  }
#line 225
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)(buf___1),
           (unsigned int )(win_size - 1));
#line 226
  last_update = now;
#line 227
  return;
}
}
#line 230 "progressmeter.c"
static void update_progress_meter(int ignore ) 
{ int save_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 235
  tmp = __errno_location();
#line 235
  save_errno = *tmp;
#line 237
  if (win_resized) {
#line 238
    setscreensize();
#line 239
    win_resized = (int volatile   )0;
  }
#line 241
  tmp___0 = can_output();
#line 241
  if (tmp___0) {
#line 242
    refresh_progress_meter();
  }
#line 244
  mysignal(14, & update_progress_meter);
#line 245
  alarm(1U);
#line 246
  tmp___1 = __errno_location();
#line 246
  *tmp___1 = save_errno;
#line 247
  return;
}
}
#line 249 "progressmeter.c"
void start_progress_meter(char *f , off_t filesize , off_t *ctr ) 
{ int tmp ;

  {
#line 252
  last_update = time((time_t *)((void *)0));
#line 252
  start = last_update;
#line 253
  file = f;
#line 254
  end_pos = filesize;
#line 255
  cur_pos = 0LL;
#line 256
  counter = (off_t volatile   *)ctr;
#line 257
  stalled = 0L;
#line 258
  bytes_per_second = 0;
#line 260
  setscreensize();
#line 261
  tmp = can_output();
#line 261
  if (tmp) {
#line 262
    refresh_progress_meter();
  }
#line 264
  mysignal(14, & update_progress_meter);
#line 265
  mysignal(28, & sig_winch);
#line 266
  alarm(1U);
#line 267
  return;
}
}
#line 269 "progressmeter.c"
void stop_progress_meter(void) 
{ int tmp ;

  {
#line 272
  alarm(0U);
#line 274
  tmp = can_output();
#line 274
  if (! tmp) {
#line 275
    return;
  }
#line 278
  if (cur_pos != end_pos) {
#line 279
    refresh_progress_meter();
  }
#line 281
  atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), 1, (void *)"\n", 1U);
#line 282
  return;
}
}
#line 285 "progressmeter.c"
static void sig_winch(int sig ) 
{ 

  {
#line 288
  win_resized = (int volatile   )1;
#line 289
  return;
}
}
#line 291 "progressmeter.c"
static void setscreensize(void) 
{ struct winsize winsize ;
  int tmp ;

  {
#line 296
  tmp = ioctl(1, 21523UL, & winsize);
#line 296
  if (tmp != -1) {
#line 296
    if ((int )winsize.ws_col != 0) {
#line 298
      if ((int )winsize.ws_col > 512) {
#line 299
        win_size = 512;
      } else {
#line 301
        win_size = (int )winsize.ws_col;
      }
    } else {
#line 303
      win_size = 80;
    }
  } else {
#line 303
    win_size = 80;
  }
#line 304
  win_size ++;
#line 305
  return;
}
}
#line 1 "dns.o"
#line 49 "dns.h"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) ;
#line 50
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) ;
#line 43 "dns.c"
static char const   *errset_text[6]  = {      "success",      "out of memory",      "general failure",      "invalid parameter", 
        "name does not exist",      "data does not exist"};
#line 52 "dns.c"
static char const   *dns_result_totext(unsigned int res ) 
{ 

  {
#line 55
  switch ((int )res) {
  case 0: 
#line 57
  return (errset_text[0]);
  case 1: 
#line 59
  return (errset_text[1]);
  case 2: 
#line 61
  return (errset_text[2]);
  case 3: 
#line 63
  return (errset_text[3]);
  case 4: 
#line 65
  return (errset_text[4]);
  case 5: 
#line 67
  return (errset_text[5]);
  default: ;
#line 69
  return ("unknown error");
  }
}
}
#line 76 "dns.c"
static int dns_read_key(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                        u_int *digest_len , Key const   *key ) 
{ int success ;

  {
#line 80
  success = 0;
#line 82
  switch ((int )key->type) {
  case 1: 
#line 84
  *algorithm = (unsigned char)1;
#line 85
  break;
  case 2: 
#line 87
  *algorithm = (unsigned char)2;
#line 88
  break;
  default: 
#line 90
  *algorithm = (unsigned char)0;
  }
#line 93
  if (*algorithm) {
#line 94
    *digest_type = (unsigned char)1;
#line 95
    *digest___1 = key_fingerprint_raw(key, 0, digest_len);
#line 96
    if ((unsigned int )*digest___1 == (unsigned int )((void *)0)) {
#line 97
      fatal("dns_read_key: null from key_fingerprint_raw()");
    }
#line 98
    success = 1;
  } else {
#line 100
    *digest_type = (unsigned char)0;
#line 101
    *digest___1 = (u_char *)((void *)0);
#line 102
    *digest_len = 0U;
#line 103
    success = 0;
  }
#line 106
  return (success);
}
}
#line 112 "dns.c"
static int dns_read_rdata(u_int8_t *algorithm , u_int8_t *digest_type , u_char **digest___1 ,
                          u_int *digest_len , u_char *rdata , int rdata_len ) 
{ int success ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 116
  success = 0;
#line 118
  *algorithm = (unsigned char)0;
#line 119
  *digest_type = (unsigned char)0;
#line 121
  if (rdata_len >= 2) {
#line 122
    *algorithm = *(rdata + 0);
#line 123
    *digest_type = *(rdata + 1);
#line 124
    *digest_len = (unsigned int )(rdata_len - 2);
#line 126
    if (*digest_len > 0U) {
#line 127
      tmp = xmalloc(*digest_len);
#line 127
      *digest___1 = (u_char *)tmp;
#line 128
      memcpy((void * __restrict  )*digest___1, (void const   * __restrict  )(rdata + 2),
             *digest_len);
    } else {
#line 130
      tmp___0 = xstrdup("");
#line 130
      *digest___1 = (u_char *)tmp___0;
    }
#line 133
    success = 1;
  }
#line 136
  return (success);
}
}
#line 143 "dns.c"
static int is_numeric_hostname(char const   *hostname ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  int tmp ;

  {
#line 148
  memset((void *)(& hints), 0, sizeof(hints));
#line 149
  hints.ai_socktype = 2;
#line 150
  hints.ai_flags = 4;
#line 152
  tmp = getaddrinfo((char const   * __restrict  )hostname, (char const   * __restrict  )"0",
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
#line 152
  if (tmp == 0) {
#line 153
    freeaddrinfo(ai);
#line 154
    return (-1);
  }
#line 157
  return (0);
}
}
#line 164 "dns.c"
int verify_host_key_dns(char const   *hostname , struct sockaddr *address , Key const   *hostkey ,
                        int *flags ) 
{ u_int counter___0 ;
  int result ;
  struct rrsetinfo *fingerprints ;
  u_int8_t hostkey_algorithm ;
  u_int8_t hostkey_digest_type ;
  u_char *hostkey_digest ;
  u_int hostkey_digest_len ;
  u_int8_t dnskey_algorithm ;
  u_int8_t dnskey_digest_type ;
  u_char *dnskey_digest ;
  u_int dnskey_digest_len ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 170
  fingerprints = (struct rrsetinfo *)((void *)0);
#line 182
  *flags = 0;
#line 184
  debug3("verify_host_key_dns");
#line 185
  if ((unsigned int )hostkey == (unsigned int )((void *)0)) {
#line 186
    fatal("No key to look up!");
  }
#line 188
  tmp = is_numeric_hostname(hostname);
#line 188
  if (tmp) {
#line 189
    debug("skipped DNS lookup for numerical hostname");
#line 190
    return (-1);
  }
#line 193
  result = getrrsetbyname(hostname, 1U, 44U, 0U, & fingerprints);
#line 195
  if (result) {
#line 196
    tmp___0 = dns_result_totext((unsigned int )result);
#line 196
    verbose("DNS lookup error: %s", tmp___0);
#line 197
    return (-1);
  }
#line 200
  if (fingerprints->rri_flags & 1U) {
#line 201
    *flags |= 4;
#line 202
    debug("found %d secure fingerprints in DNS", fingerprints->rri_nrdatas);
  } else {
#line 205
    debug("found %d insecure fingerprints in DNS", fingerprints->rri_nrdatas);
  }
#line 210
  tmp___1 = dns_read_key(& hostkey_algorithm, & hostkey_digest_type, & hostkey_digest,
                         & hostkey_digest_len, hostkey);
#line 210
  if (! tmp___1) {
#line 212
    error("Error calculating host key fingerprint.");
#line 213
    freerrset(fingerprints);
#line 214
    return (-1);
  }
#line 217
  if (fingerprints->rri_nrdatas) {
#line 218
    *flags |= 1;
  }
#line 220
  counter___0 = 0U;
#line 220
  while (counter___0 < fingerprints->rri_nrdatas) {
#line 225
    tmp___2 = dns_read_rdata(& dnskey_algorithm, & dnskey_digest_type, & dnskey_digest,
                             & dnskey_digest_len, (fingerprints->rri_rdatas + counter___0)->rdi_data,
                             (int )(fingerprints->rri_rdatas + counter___0)->rdi_length);
#line 225
    if (! tmp___2) {
#line 229
      verbose("Error parsing fingerprint from DNS.");
      goto __Cont;
    }
#line 234
    if ((int )hostkey_algorithm == (int )dnskey_algorithm) {
#line 234
      if ((int )hostkey_digest_type == (int )dnskey_digest_type) {
#line 237
        if (hostkey_digest_len == dnskey_digest_len) {
#line 237
          tmp___3 = memcmp((void const   *)hostkey_digest, (void const   *)dnskey_digest,
                           hostkey_digest_len);
#line 237
          if (tmp___3 == 0) {
#line 241
            *flags |= 2;
          }
        }
      }
    }
#line 244
    xfree((void *)dnskey_digest);
    __Cont: /* CIL Label */ 
#line 220
    counter___0 ++;
  }
#line 247
  xfree((void *)hostkey_digest);
#line 248
  freerrset(fingerprints);
#line 250
  if (*flags & 1) {
#line 251
    if (*flags & 2) {
#line 252
      debug("matching host key fingerprint found in DNS");
    } else {
#line 254
      debug("mismatching host key fingerprint found in DNS");
    }
  } else {
#line 256
    debug("no host key fingerprint found in DNS");
  }
#line 258
  return (0);
}
}
#line 264 "dns.c"
int export_dns_rr(char const   *hostname , Key const   *key , FILE *f , int generic ) 
{ u_int8_t rdata_pubkey_algorithm ;
  u_int8_t rdata_digest_type ;
  u_char *rdata_digest ;
  u_int rdata_digest_len ;
  u_int i ;
  int success ;
  int tmp ;

  {
#line 267
  rdata_pubkey_algorithm = (u_int8_t )0;
#line 268
  rdata_digest_type = (u_int8_t )1;
#line 273
  success = 0;
#line 275
  tmp = dns_read_key(& rdata_pubkey_algorithm, & rdata_digest_type, & rdata_digest,
                     & rdata_digest_len, key);
#line 275
  if (tmp) {
#line 278
    if (generic) {
#line 279
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN TYPE%d \\# %d %02x %02x ",
              hostname, 44, 2U + rdata_digest_len, rdata_pubkey_algorithm, rdata_digest_type);
    } else {
#line 283
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s IN SSHFP %d %d ",
              hostname, rdata_pubkey_algorithm, rdata_digest_type);
    }
#line 286
    i = 0U;
#line 286
    while (i < rdata_digest_len) {
#line 287
      fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%02x", *(rdata_digest + i));
#line 286
      i ++;
    }
#line 288
    fprintf((FILE * __restrict  )f, (char const   * __restrict  )"\n");
#line 289
    xfree((void *)rdata_digest);
#line 290
    success = 1;
  } else {
#line 292
    error("export_dns_rr: unsupported algorithm");
  }
#line 295
  return (success);
}
}
#line 1 "entropy.o"
#line 33 "entropy.h"
void init_rng(void) ;
#line 109 "/usr/include/openssl/rand.h"
extern int RAND_status(void) ;
#line 381 "/usr/include/openssl/crypto.h"
extern unsigned long SSLeay(void) ;
#line 70 "entropy.c"
void seed_rng(void) 
{ int tmp ;

  {
#line 147
  tmp = RAND_status();
#line 147
  if (tmp != 1) {
#line 148
    fatal("PRNG is not seeded");
  }
#line 149
  return;
}
}
#line 151 "entropy.c"
void init_rng(void) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 158
  tmp___0 = SSLeay();
#line 158
  if ((tmp___0 ^ 9469999UL) & 4294963215UL) {
#line 159
    tmp = SSLeay();
#line 159
    fatal("OpenSSL version mismatch. Built against %lx, you have %lx", 9469999L, tmp);
  }
#line 166
  return;
}
}
#line 1 "scard-opensc.o"
#line 1 "gss-genr.o"
#line 1 "umac.o"
#line 131 "umac.c"
static UINT32 LOAD_UINT32_REVERSED(void *ptr ) 
{ UINT32 temp ;

  {
#line 133
  temp = *((UINT32 *)ptr);
#line 134
  temp = (((temp >> 24) | ((temp & 16711680U) >> 8)) | ((temp & 65280U) << 8)) | (temp << 24);
#line 136
  return (temp);
}
}
#line 139 "umac.c"
static void STORE_UINT32_REVERSED(void *ptr , UINT32 x ) 
{ UINT32 i ;

  {
#line 141
  i = x;
#line 142
  *((UINT32 *)ptr) = (((i >> 24) | ((i & 16711680U) >> 8)) | ((i & 65280U) << 8)) | (i << 24);
#line 144
  return;
}
}
#line 185 "umac.c"
static void kdf(void *buffer_ptr___0 , AES_KEY *key , UINT8 ndx , int nbytes ) 
{ UINT8 in_buf[16] ;
  UINT8 out_buf[16] ;
  UINT8 *dst_buf ;
  int i ;

  {
#line 187
  in_buf[0] = (UINT8 )0;
#line 187
  in_buf[1] = (unsigned char)0;
#line 187
  in_buf[2] = (unsigned char)0;
#line 187
  in_buf[3] = (unsigned char)0;
#line 187
  in_buf[4] = (unsigned char)0;
#line 187
  in_buf[5] = (unsigned char)0;
#line 187
  in_buf[6] = (unsigned char)0;
#line 187
  in_buf[7] = (unsigned char)0;
#line 187
  in_buf[8] = (unsigned char)0;
#line 187
  in_buf[9] = (unsigned char)0;
#line 187
  in_buf[10] = (unsigned char)0;
#line 187
  in_buf[11] = (unsigned char)0;
#line 187
  in_buf[12] = (unsigned char)0;
#line 187
  in_buf[13] = (unsigned char)0;
#line 187
  in_buf[14] = (unsigned char)0;
#line 187
  in_buf[15] = (unsigned char)0;
#line 189
  dst_buf = (UINT8 *)buffer_ptr___0;
#line 193
  in_buf[7] = ndx;
#line 194
  i = 1;
#line 194
  in_buf[15] = (unsigned char )i;
#line 196
  while (nbytes >= 16) {
#line 197
    AES_encrypt((unsigned char const   *)(in_buf), out_buf, (AES_KEY const   *)((AES_KEY *)key));
#line 198
    memcpy((void * __restrict  )dst_buf, (void const   * __restrict  )(out_buf), 16U);
#line 199
    i ++;
#line 199
    in_buf[15] = (unsigned char )i;
#line 200
    nbytes -= 16;
#line 201
    dst_buf += 16;
  }
#line 203
  if (nbytes) {
#line 204
    AES_encrypt((unsigned char const   *)(in_buf), out_buf, (AES_KEY const   *)((AES_KEY *)key));
#line 205
    memcpy((void * __restrict  )dst_buf, (void const   * __restrict  )(out_buf), (unsigned int )nbytes);
  }
#line 207
  return;
}
}
#line 221 "umac.c"
static void pdf_init(pdf_ctx *pc , AES_KEY *prf_key ) 
{ UINT8 buf___1[16] ;

  {
#line 225
  kdf((void *)(buf___1), prf_key, (unsigned char)0, 16);
#line 226
  AES_set_encrypt_key((unsigned char const   *)(buf___1), 128, pc->prf_key);
#line 229
  memset((void *)(pc->nonce), 0, sizeof(pc->nonce));
#line 230
  AES_encrypt((unsigned char const   *)(pc->nonce), pc->cache, (AES_KEY const   *)(pc->prf_key));
#line 231
  return;
}
}
#line 233 "umac.c"
static void pdf_gen_xor(pdf_ctx *pc , UINT8 *nonce , UINT8 *buf___1 ) 
{ UINT8 tmp_nonce_lo[4] ;
  int ndx ;

  {
#line 250
  ndx = (int )*(nonce + 7) & 1;
#line 252
  *((UINT32 *)(tmp_nonce_lo)) = *((UINT32 *)nonce + 1);
#line 253
  tmp_nonce_lo[3] = (unsigned char )((int )tmp_nonce_lo[3] & -2);
#line 255
  if (*((UINT32 *)(tmp_nonce_lo) + 0) != *((UINT32 *)(pc->nonce) + 1)) {
#line 258
    *((UINT32 *)(pc->nonce) + 0) = *((UINT32 *)nonce + 0);
#line 259
    *((UINT32 *)(pc->nonce) + 1) = *((UINT32 *)(tmp_nonce_lo) + 0);
#line 260
    AES_encrypt((unsigned char const   *)(pc->nonce), pc->cache, (AES_KEY const   *)(pc->prf_key));
  } else {
#line 255
    if (*((UINT32 *)nonce + 0) != *((UINT32 *)(pc->nonce) + 0)) {
#line 258
      *((UINT32 *)(pc->nonce) + 0) = *((UINT32 *)nonce + 0);
#line 259
      *((UINT32 *)(pc->nonce) + 1) = *((UINT32 *)(tmp_nonce_lo) + 0);
#line 260
      AES_encrypt((unsigned char const   *)(pc->nonce), pc->cache, (AES_KEY const   *)(pc->prf_key));
    }
  }
#line 266
  *((UINT64 *)buf___1) ^= *((UINT64 *)(pc->cache) + ndx);
#line 274
  return;
}
}
#line 361 "umac.c"
static void nh_aux(void *kp , void *dp , void *hp , UINT32 dlen ) 
{ UINT64 h1 ;
  UINT64 h2 ;
  UWORD c ;
  UINT32 *k ;
  UINT32 *d ;
  UINT32 d0 ;
  UINT32 d1 ;
  UINT32 d2 ;
  UINT32 d3 ;
  UINT32 d4 ;
  UINT32 d5 ;
  UINT32 d6 ;
  UINT32 d7 ;
  UINT32 k0 ;
  UINT32 k1 ;
  UINT32 k2 ;
  UINT32 k3 ;
  UINT32 k4 ;
  UINT32 k5 ;
  UINT32 k6 ;
  UINT32 k7 ;
  UINT32 k8 ;
  UINT32 k9 ;
  UINT32 k10 ;
  UINT32 k11 ;

  {
#line 367
  c = dlen / 32U;
#line 368
  k = (UINT32 *)kp;
#line 369
  d = (UINT32 *)dp;
#line 374
  h1 = *((UINT64 *)hp);
#line 375
  h2 = *((UINT64 *)hp + 1);
#line 376
  k0 = *(k + 0);
#line 376
  k1 = *(k + 1);
#line 376
  k2 = *(k + 2);
#line 376
  k3 = *(k + 3);
#line 377
  while (1) {
#line 378
    d0 = *(d + 0);
#line 378
    d1 = *(d + 1);
#line 379
    d2 = *(d + 2);
#line 379
    d3 = *(d + 3);
#line 380
    d4 = *(d + 4);
#line 380
    d5 = *(d + 5);
#line 381
    d6 = *(d + 6);
#line 381
    d7 = *(d + 7);
#line 382
    k4 = *(k + 4);
#line 382
    k5 = *(k + 5);
#line 382
    k6 = *(k + 6);
#line 382
    k7 = *(k + 7);
#line 383
    k8 = *(k + 8);
#line 383
    k9 = *(k + 9);
#line 383
    k10 = *(k + 10);
#line 383
    k11 = *(k + 11);
#line 385
    h1 += (unsigned long long )(k0 + d0) * (unsigned long long )(k4 + d4);
#line 386
    h2 += (unsigned long long )(k4 + d0) * (unsigned long long )(k8 + d4);
#line 388
    h1 += (unsigned long long )(k1 + d1) * (unsigned long long )(k5 + d5);
#line 389
    h2 += (unsigned long long )(k5 + d1) * (unsigned long long )(k9 + d5);
#line 391
    h1 += (unsigned long long )(k2 + d2) * (unsigned long long )(k6 + d6);
#line 392
    h2 += (unsigned long long )(k6 + d2) * (unsigned long long )(k10 + d6);
#line 394
    h1 += (unsigned long long )(k3 + d3) * (unsigned long long )(k7 + d7);
#line 395
    h2 += (unsigned long long )(k7 + d3) * (unsigned long long )(k11 + d7);
#line 397
    k0 = k8;
#line 397
    k1 = k9;
#line 397
    k2 = k10;
#line 397
    k3 = k11;
#line 399
    d += 8;
#line 400
    k += 8;
#line 377
    c --;
#line 377
    if (! c) {
#line 377
      break;
    }
  }
#line 402
  *((UINT64 *)hp + 0) = h1;
#line 403
  *((UINT64 *)hp + 1) = h2;
#line 404
  return;
}
}
#line 532 "umac.c"
static void nh_transform(nh_ctx *hc , UINT8 *buf___1 , UINT32 nbytes ) 
{ UINT8 *key ;

  {
#line 541
  key = hc->nh_key + hc->bytes_hashed;
#line 542
  nh_aux((void *)key, (void *)buf___1, (void *)(hc->state), nbytes);
#line 543
  return;
}
}
#line 547 "umac.c"
static void endian_convert(void *buf___1 , UWORD bpw , UINT32 num_bytes ) 
{ UWORD iters ;
  UINT32 *p ;
  UINT32 *p___0 ;
  UINT32 t ;

  {
#line 551
  iters = num_bytes / bpw;
#line 552
  if (bpw == 4U) {
#line 553
    p = (UINT32 *)buf___1;
#line 554
    while (1) {
#line 555
      *p = LOAD_UINT32_REVERSED((void *)p);
#line 556
      p ++;
#line 554
      iters --;
#line 554
      if (! iters) {
#line 554
        break;
      }
    }
  } else {
#line 558
    if (bpw == 8U) {
#line 559
      p___0 = (UINT32 *)buf___1;
#line 561
      while (1) {
#line 562
        t = LOAD_UINT32_REVERSED((void *)(p___0 + 1));
#line 563
        *(p___0 + 1) = LOAD_UINT32_REVERSED((void *)p___0);
#line 564
        *(p___0 + 0) = t;
#line 565
        p___0 += 2;
#line 561
        iters --;
#line 561
        if (! iters) {
#line 561
          break;
        }
      }
    }
  }
#line 568
  return;
}
}
#line 577 "umac.c"
static void nh_reset(nh_ctx *hc ) 
{ 

  {
#line 580
  hc->bytes_hashed = 0;
#line 581
  hc->next_data_empty = 0;
#line 582
  hc->state[0] = 0ULL;
#line 584
  hc->state[1] = 0ULL;
#line 593
  return;
}
}
#line 597 "umac.c"
static void nh_init(nh_ctx *hc , AES_KEY *prf_key ) 
{ 

  {
#line 600
  kdf((void *)(hc->nh_key), prf_key, (unsigned char)1, (int )sizeof(hc->nh_key));
#line 601
  endian_convert((void *)(hc->nh_key), 4U, sizeof(hc->nh_key));
#line 602
  nh_reset(hc);
#line 603
  return;
}
}
#line 607 "umac.c"
static void nh_update(nh_ctx *hc , UINT8 *buf___1 , UINT32 nbytes ) 
{ UINT32 i ;
  UINT32 j ;

  {
#line 613
  j = (unsigned int )hc->next_data_empty;
#line 614
  if (j + nbytes >= 64U) {
#line 615
    if (j) {
#line 616
      i = 64U - j;
#line 617
      memcpy((void * __restrict  )(hc->data + j), (void const   * __restrict  )buf___1,
             i);
#line 618
      nh_transform(hc, hc->data, 64U);
#line 619
      nbytes -= i;
#line 620
      buf___1 += i;
#line 621
      hc->bytes_hashed += 64;
    }
#line 623
    if (nbytes >= 64U) {
#line 624
      i = nbytes & 4294967232U;
#line 625
      nh_transform(hc, buf___1, i);
#line 626
      nbytes -= i;
#line 627
      buf___1 += i;
#line 628
      hc->bytes_hashed = (int )((UINT32 )hc->bytes_hashed + i);
    }
#line 630
    j = 0U;
  }
#line 632
  memcpy((void * __restrict  )(hc->data + j), (void const   * __restrict  )buf___1,
         nbytes);
#line 633
  hc->next_data_empty = (int )(j + nbytes);
#line 634
  return;
}
}
#line 638 "umac.c"
static void zero_pad(UINT8 *p , int nbytes ) 
{ 

  {
#line 641
  if (nbytes >= (int )sizeof(UWORD )) {
#line 642
    while ((unsigned int )((int )p) % sizeof(UWORD )) {
#line 643
      *p = (unsigned char)0;
#line 644
      nbytes --;
#line 645
      p ++;
    }
#line 647
    while (nbytes >= (int )sizeof(UWORD )) {
#line 648
      *((UWORD *)p) = 0U;
#line 649
      nbytes = (int )((unsigned int )nbytes - sizeof(UWORD ));
#line 650
      p += sizeof(UWORD );
    }
  }
#line 653
  while (nbytes) {
#line 654
    *p = (unsigned char)0;
#line 655
    nbytes --;
#line 656
    p ++;
  }
#line 658
  return;
}
}
#line 662 "umac.c"
static void nh_final(nh_ctx *hc , UINT8 *result ) 
{ int nh_len ;
  int nbits ;

  {
#line 673
  if (hc->next_data_empty != 0) {
#line 674
    nh_len = (hc->next_data_empty + 31) & -32;
#line 676
    zero_pad(hc->data + hc->next_data_empty, nh_len - hc->next_data_empty);
#line 678
    nh_transform(hc, hc->data, (unsigned int )nh_len);
#line 679
    hc->bytes_hashed += hc->next_data_empty;
  } else {
#line 680
    if (hc->bytes_hashed == 0) {
#line 681
      nh_len = 32;
#line 682
      zero_pad(hc->data, 32);
#line 683
      nh_transform(hc, hc->data, (unsigned int )nh_len);
    }
  }
#line 686
  nbits = hc->bytes_hashed << 3;
#line 687
  *((UINT64 *)result + 0) = hc->state[0] + (UINT64 )nbits;
#line 689
  *((UINT64 *)result + 1) = hc->state[1] + (UINT64 )nbits;
#line 697
  nh_reset(hc);
#line 698
  return;
}
}
#line 702 "umac.c"
static void nh(nh_ctx *hc , UINT8 *buf___1 , UINT32 padded_len , UINT32 unpadded_len ,
               UINT8 *result ) 
{ UINT32 nbits ;

  {
#line 712
  nbits = unpadded_len << 3;
#line 714
  *((UINT64 *)result + 0) = (unsigned long long )nbits;
#line 716
  *((UINT64 *)result + 1) = (unsigned long long )nbits;
#line 725
  nh_aux((void *)(hc->nh_key), (void *)buf___1, (void *)result, padded_len);
#line 726
  return;
}
}
#line 792 "umac.c"
static UINT64 poly64(UINT64 cur , UINT64 key , UINT64 data ) 
{ UINT32 key_hi ;
  UINT32 key_lo ;
  UINT32 cur_hi ;
  UINT32 cur_lo ;
  UINT32 x_lo ;
  UINT32 x_hi ;
  UINT64 X ;
  UINT64 T ;
  UINT64 res ;

  {
#line 794
  key_hi = (unsigned int )(key >> 32);
#line 794
  key_lo = (unsigned int )key;
#line 794
  cur_hi = (unsigned int )(cur >> 32);
#line 794
  cur_lo = (unsigned int )cur;
#line 802
  X = (unsigned long long )key_hi * (unsigned long long )cur_lo + (unsigned long long )cur_hi * (unsigned long long )key_lo;
#line 803
  x_lo = (unsigned int )X;
#line 804
  x_hi = (unsigned int )(X >> 32);
#line 806
  res = ((unsigned long long )key_hi * (unsigned long long )cur_hi + (unsigned long long )x_hi) * 59ULL + (unsigned long long )key_lo * (unsigned long long )cur_lo;
#line 808
  T = (unsigned long long )x_lo << 32;
#line 809
  res += T;
#line 810
  if (res < T) {
#line 811
    res += 59ULL;
  }
#line 813
  res += data;
#line 814
  if (res < data) {
#line 815
    res += 59ULL;
  }
#line 817
  return (res);
}
}
#line 827 "umac.c"
static void poly_hash(uhash_ctx_t hc , UINT32 *data_in ) 
{ int i ;
  UINT64 *data ;

  {
#line 830
  data = (UINT64 *)data_in;
#line 832
  i = 0;
#line 832
  while (i < 2) {
#line 833
    if ((unsigned long )((unsigned int )(*(data + i) >> 32)) == 4294967295UL) {
#line 834
      hc->poly_accum[i] = poly64(hc->poly_accum[i], hc->poly_key_8[i], 0xffffffffffffffc4ULL);
#line 836
      hc->poly_accum[i] = poly64(hc->poly_accum[i], hc->poly_key_8[i], *(data + i) - 59ULL);
    } else {
#line 839
      hc->poly_accum[i] = poly64(hc->poly_accum[i], hc->poly_key_8[i], *(data + i));
    }
#line 832
    i ++;
  }
#line 843
  return;
}
}
#line 855 "umac.c"
static UINT64 ip_aux(UINT64 t , UINT64 *ipkp , UINT64 data ) 
{ 

  {
#line 857
  t += *(ipkp + 0) * (unsigned long long )((unsigned short )(data >> 48));
#line 858
  t += *(ipkp + 1) * (unsigned long long )((unsigned short )(data >> 32));
#line 859
  t += *(ipkp + 2) * (unsigned long long )((unsigned short )(data >> 16));
#line 860
  t += *(ipkp + 3) * (unsigned long long )((unsigned short )data);
#line 862
  return (t);
}
}
#line 865 "umac.c"
static UINT32 ip_reduce_p36(UINT64 t ) 
{ UINT64 ret___0 ;

  {
#line 870
  ret___0 = (t & 68719476735ULL) + 5ULL * (t >> 36);
#line 871
  if (ret___0 >= 68719476731ULL) {
#line 872
    ret___0 -= 68719476731ULL;
  }
#line 875
  return ((unsigned int )ret___0);
}
}
#line 883 "umac.c"
static void ip_short(uhash_ctx_t ahc , UINT8 *nh_res , u_char *res ) 
{ UINT64 t ;
  UINT64 *nhp ;
  UINT32 tmp ;
  UINT32 tmp___0 ;

  {
#line 886
  nhp = (UINT64 *)nh_res;
#line 888
  t = ip_aux(0ULL, ahc->ip_keys, *(nhp + 0));
#line 889
  tmp = ip_reduce_p36(t);
#line 889
  STORE_UINT32_REVERSED((void *)((UINT32 *)res + 0), tmp ^ ahc->ip_trans[0]);
#line 891
  t = ip_aux(0ULL, ahc->ip_keys + 4, *(nhp + 1));
#line 892
  tmp___0 = ip_reduce_p36(t);
#line 892
  STORE_UINT32_REVERSED((void *)((UINT32 *)res + 1), tmp___0 ^ ahc->ip_trans[1]);
#line 902
  return;
}
}
#line 908 "umac.c"
static void ip_long(uhash_ctx_t ahc , u_char *res ) 
{ int i ;
  UINT64 t ;
  UINT32 tmp ;

  {
#line 913
  i = 0;
#line 913
  while (i < 2) {
#line 915
    if (ahc->poly_accum[i] >= 0xffffffffffffffc5ULL) {
#line 916
      ahc->poly_accum[i] -= 0xffffffffffffffc5ULL;
    }
#line 917
    t = ip_aux(0ULL, ahc->ip_keys + i * 4, ahc->poly_accum[i]);
#line 918
    tmp = ip_reduce_p36(t);
#line 918
    STORE_UINT32_REVERSED((void *)((UINT32 *)res + i), tmp ^ ahc->ip_trans[i]);
#line 913
    i ++;
  }
#line 921
  return;
}
}
#line 929 "umac.c"
static int uhash_reset(uhash_ctx_t pc ) 
{ 

  {
#line 931
  nh_reset(& pc->hash);
#line 932
  pc->msg_len = 0U;
#line 933
  pc->poly_accum[0] = 1ULL;
#line 935
  pc->poly_accum[1] = 1ULL;
#line 943
  return (1);
}
}
#line 953 "umac.c"
static void uhash_init(uhash_ctx_t ahc , AES_KEY *prf_key ) 
{ int i ;
  UINT8 buf___1[20U * sizeof(UINT64 )] ;

  {
#line 959
  memset((void *)ahc, 0, sizeof(uhash_ctx ));
#line 962
  nh_init(& ahc->hash, prf_key);
#line 965
  kdf((void *)(buf___1), prf_key, (unsigned char)2, (int )sizeof(buf___1));
#line 966
  i = 0;
#line 966
  while (i < 2) {
#line 971
    memcpy((void * __restrict  )(ahc->poly_key_8 + i), (void const   * __restrict  )(buf___1 + 24 * i),
           8U);
#line 972
    endian_convert((void *)(ahc->poly_key_8 + i), 8U, 8U);
#line 974
    ahc->poly_key_8[i] &= (33554431ULL << 32) + 33554431ULL;
#line 975
    ahc->poly_accum[i] = 1ULL;
#line 966
    i ++;
  }
#line 979
  kdf((void *)(buf___1), prf_key, (unsigned char)3, (int )sizeof(buf___1));
#line 980
  i = 0;
#line 980
  while (i < 2) {
#line 981
    memcpy((void * __restrict  )(ahc->ip_keys + 4 * i), (void const   * __restrict  )(buf___1 + (unsigned int )(8 * i + 4) * sizeof(UINT64 )),
           4U * sizeof(UINT64 ));
#line 980
    i ++;
  }
#line 983
  endian_convert((void *)(ahc->ip_keys), sizeof(UINT64 ), sizeof(ahc->ip_keys));
#line 985
  i = 0;
#line 985
  while (i < 8) {
#line 986
    ahc->ip_keys[i] %= 68719476731ULL;
#line 985
    i ++;
  }
#line 990
  kdf((void *)(ahc->ip_trans), prf_key, (unsigned char)4, (int )(2U * sizeof(UINT32 )));
#line 991
  endian_convert((void *)(ahc->ip_trans), sizeof(UINT32 ), 2U * sizeof(UINT32 ));
#line 993
  return;
}
}
#line 1040 "umac.c"
static int uhash_update(uhash_ctx_t ctx , u_char *input___0 , long len ) 
{ UWORD bytes_hashed ;
  UWORD bytes_remaining ;
  UINT8 nh_result[2U * sizeof(UINT64 )] ;

  {
#line 1048
  if ((unsigned long )ctx->msg_len + (unsigned long )len <= 1024UL) {
#line 1049
    nh_update(& ctx->hash, input___0, (unsigned int )len);
#line 1050
    ctx->msg_len = (unsigned int )((unsigned long )ctx->msg_len + (unsigned long )len);
  } else {
#line 1053
    bytes_hashed = ctx->msg_len % 1024U;
#line 1054
    if (ctx->msg_len == 1024U) {
#line 1055
      bytes_hashed = 1024U;
    }
#line 1057
    if ((unsigned long )bytes_hashed + (unsigned long )len >= 1024UL) {
#line 1062
      if (bytes_hashed) {
#line 1063
        bytes_remaining = 1024U - bytes_hashed;
#line 1064
        nh_update(& ctx->hash, input___0, bytes_remaining);
#line 1065
        nh_final(& ctx->hash, nh_result);
#line 1066
        ctx->msg_len += bytes_remaining;
#line 1067
        poly_hash(ctx, (UINT32 *)(nh_result));
#line 1068
        len = (long )((unsigned long )len - (unsigned long )bytes_remaining);
#line 1069
        input___0 += bytes_remaining;
      }
#line 1073
      while (len >= 1024L) {
#line 1074
        nh(& ctx->hash, input___0, 1024U, 1024U, nh_result);
#line 1076
        ctx->msg_len += 1024U;
#line 1077
        len -= 1024L;
#line 1078
        input___0 += 1024;
#line 1079
        poly_hash(ctx, (UINT32 *)(nh_result));
      }
    }
#line 1084
    if (len) {
#line 1085
      nh_update(& ctx->hash, input___0, (unsigned int )len);
#line 1086
      ctx->msg_len = (unsigned int )((unsigned long )ctx->msg_len + (unsigned long )len);
    }
  }
#line 1090
  return (1);
}
}
#line 1095 "umac.c"
static int uhash_final(uhash_ctx_t ctx , u_char *res ) 
{ UINT8 nh_result[2U * sizeof(UINT64 )] ;

  {
#line 1100
  if (ctx->msg_len > 1024U) {
#line 1101
    if (ctx->msg_len % 1024U) {
#line 1102
      nh_final(& ctx->hash, nh_result);
#line 1103
      poly_hash(ctx, (UINT32 *)(nh_result));
    }
#line 1105
    ip_long(ctx, res);
  } else {
#line 1107
    nh_final(& ctx->hash, nh_result);
#line 1108
    ip_short(ctx, nh_result, res);
  }
#line 1110
  uhash_reset(ctx);
#line 1111
  return (1);
}
}
#line 1175 "umac.c"
struct umac_ctx umac_ctx  ;
#line 1194 "umac.c"
int umac_delete(struct umac_ctx *ctx ) 
{ 

  {
#line 1197
  if (ctx) {
#line 1199
    ctx = (struct umac_ctx *)ctx->free_ptr;
#line 1200
    xfree((void *)ctx);
  }
#line 1202
  return (1);
}
}
#line 1207 "umac.c"
struct umac_ctx *umac_new(u_char *key ) 
{ struct umac_ctx *ctx ;
  struct umac_ctx *octx ;
  size_t bytes_to_add ;
  aes_int_key prf_key ;
  void *tmp ;

  {
#line 1216
  tmp = xmalloc(sizeof(*ctx) + 16U);
#line 1216
  ctx = (struct umac_ctx *)tmp;
#line 1216
  octx = ctx;
#line 1217
  if (ctx) {
#line 1219
    bytes_to_add = (unsigned int )(16 - ((int )ctx & 15));
#line 1221
    ctx = (struct umac_ctx *)((u_char *)ctx + bytes_to_add);
#line 1223
    ctx->free_ptr = (void *)octx;
#line 1224
    AES_set_encrypt_key((unsigned char const   *)key, 128, prf_key);
#line 1225
    pdf_init(& ctx->pdf, (AES_KEY *)(prf_key));
#line 1226
    uhash_init(& ctx->hash, (AES_KEY *)(prf_key));
  }
#line 1229
  return (ctx);
}
}
#line 1234 "umac.c"
int umac_final(struct umac_ctx *ctx , u_char *tag , u_char *nonce ) 
{ 

  {
#line 1237
  uhash_final(& ctx->hash, tag);
#line 1238
  pdf_gen_xor(& ctx->pdf, (UINT8 *)((UINT8 *)nonce), (UINT8 *)tag);
#line 1240
  return (1);
}
}
#line 1245 "umac.c"
int umac_update(struct umac_ctx *ctx , u_char *input___0 , long len ) 
{ 

  {
#line 1250
  uhash_update(& ctx->hash, input___0, len);
#line 1251
  return (1);
}
}
#line 1 "sshd.o"
#line 106 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 682 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 21 "platform.h"
void platform_pre_fork(void) ;
#line 22
void platform_post_fork_parent(pid_t child_pid ) ;
#line 23
void platform_post_fork_child(void) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 478 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 457 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 910
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 380 "/usr/include/openssl/crypto.h"
extern char const   *SSLeay_version(int type ) ;
#line 104 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 711 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 151 "servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 152
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 153
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum , int *activep , char const   *user , char const   *host ,
                               char const   *address ) ;
#line 155
void load_server_config(char const   *filename , Buffer *conf ) ;
#line 156
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ,
                         char const   *user , char const   *host , char const   *address ) ;
#line 140 "kex.h"
void kexdh_server(Kex *kex ) ;
#line 142
void kexgex_server(Kex *kex ) ;
#line 57 "myproposal.h"
static char *myproposal[10]  = 
#line 57 "myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha256,diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr", 
        (char *)"hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib@openssh.com,zlib",      (char *)"none,zlib@openssh.com,zlib", 
        (char *)"",      (char *)""};
#line 140 "auth.h"
void do_authentication(Authctxt *authctxt___0 ) ;
#line 141
void do_authentication2(Authctxt *authctxt___0 ) ;
#line 150
void privsep_challenge_enable(void) ;
#line 177
Key *get_hostkey_by_index(int ind ) ;
#line 178
Key *get_hostkey_by_type(int type ) ;
#line 179
int get_hostkey_index(Key *key ) ;
#line 180
int ssh1_session_key(BIGNUM *session_key_int ) ;
#line 64 "session.h"
void do_authenticated(Authctxt *authctxt___0 ) ;
#line 65
void do_cleanup(Authctxt *authctxt___0 ) ;
#line 77
void do_setusercontext(struct passwd *pw___0 ) ;
#line 76 "monitor.h"
struct monitor *monitor_init(void) ;
#line 77
void monitor_reinit(struct monitor *mon ) ;
#line 78
void monitor_sync(struct monitor *pmonitor___0 ) ;
#line 81
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) ;
#line 82
void monitor_child_postauth(struct monitor *pmonitor___0 ) ;
#line 31 "monitor_wrap.h"
int use_privsep ;
#line 80
void mm_terminate(void) ;
#line 85
void mm_ssh1_session_id(u_char *session_id___0 ) ;
#line 86
int mm_ssh1_session_key(BIGNUM *num ) ;
#line 92
void monitor_apply_keystate(struct monitor *pmonitor___0 ) ;
#line 94
void mm_send_keystate(struct monitor *monitor ) ;
#line 142 "sshd.c"
ServerOptions options  ;
#line 145 "sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 153 "sshd.c"
int debug_flag  =    0;
#line 156 "sshd.c"
int test_flag  =    0;
#line 159 "sshd.c"
int inetd_flag  =    0;
#line 162 "sshd.c"
int no_daemon_flag  =    0;
#line 165 "sshd.c"
int log_stderr  =    0;
#line 168 "sshd.c"
char **saved_argv  ;
#line 169 "sshd.c"
int saved_argc  ;
#line 172 "sshd.c"
int rexeced_flag  =    0;
#line 173 "sshd.c"
int rexec_flag  =    1;
#line 174 "sshd.c"
int rexec_argc  =    0;
#line 175 "sshd.c"
char **rexec_argv  ;
#line 182 "sshd.c"
int listen_socks[16]  ;
#line 183 "sshd.c"
int num_listen_socks  =    0;
#line 189 "sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 190 "sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 193 "sshd.c"
Kex *xxx_kex  ;
#line 203 "sshd.c"
struct __anonstruct_sensitive_data_83 sensitive_data  ;
#line 216 "sshd.c"
static int volatile   key_do_regen  =    (sig_atomic_t volatile   )0;
#line 219 "sshd.c"
static int volatile   received_sighup  =    (sig_atomic_t volatile   )0;
#line 220 "sshd.c"
static int volatile   received_sigterm  =    (sig_atomic_t volatile   )0;
#line 223 "sshd.c"
u_char session_id[16]  ;
#line 226 "sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 227 "sshd.c"
u_int session_id2_len  =    (u_int )0;
#line 230 "sshd.c"
u_int utmp_len  =    (u_int )64;
#line 233 "sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 234 "sshd.c"
int startup_pipe  ;
#line 237 "sshd.c"
int use_privsep  =    -1;
#line 238 "sshd.c"
struct monitor *pmonitor  =    (struct monitor *)((void *)0);
#line 241 "sshd.c"
Authctxt *the_authctxt  =    (Authctxt *)((void *)0);
#line 244 "sshd.c"
Buffer cfg  ;
#line 247 "sshd.c"
Buffer loginmsg  ;
#line 250 "sshd.c"
struct passwd *privsep_pw  =    (struct passwd *)((void *)0);
#line 253
void destroy_sensitive_data(void) ;
#line 254
void demote_sensitive_data(void) ;
#line 256
static void do_ssh1_kex(void) ;
#line 257
static void do_ssh2_kex(void) ;
#line 262 "sshd.c"
static void close_listen_socks(void) 
{ int i ;

  {
#line 267
  i = 0;
#line 267
  while (i < num_listen_socks) {
#line 268
    close(listen_socks[i]);
#line 267
    i ++;
  }
#line 269
  num_listen_socks = -1;
#line 270
  return;
}
}
#line 272 "sshd.c"
static void close_startup_pipes(void) 
{ int i ;

  {
#line 277
  if (startup_pipes) {
#line 278
    i = 0;
#line 278
    while (i < options.max_startups) {
#line 279
      if (*(startup_pipes + i) != -1) {
#line 280
        close(*(startup_pipes + i));
      }
#line 278
      i ++;
    }
  }
#line 281
  return;
}
}
#line 290 "sshd.c"
static void sighup_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 293
  tmp = __errno_location();
#line 293
  save_errno = *tmp;
#line 295
  received_sighup = (int volatile   )1;
#line 296
  mysignal(1, & sighup_handler);
#line 297
  tmp___0 = __errno_location();
#line 297
  *tmp___0 = save_errno;
#line 298
  return;
}
}
#line 304 "sshd.c"
static void sighup_restart(void) 
{ int *tmp ;
  char *tmp___0 ;

  {
#line 307
  logit("Received SIGHUP; restarting.");
#line 308
  close_listen_socks();
#line 309
  close_startup_pipes();
#line 310
  alarm(0U);
#line 311
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
#line 312
  tmp = __errno_location();
#line 312
  tmp___0 = strerror(*tmp);
#line 312
  logit("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
#line 314
  exit(1);
}
}
#line 321 "sshd.c"
static void sigterm_handler(int sig ) 
{ 

  {
#line 324
  received_sigterm = (int volatile   )sig;
#line 325
  return;
}
}
#line 332 "sshd.c"
static void main_sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  pid_t pid ;
  int status ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 335
  tmp = __errno_location();
#line 335
  save_errno = *tmp;
#line 339
  while (1) {
#line 339
    pid = waitpid(-1, & status, 1);
#line 339
    if (! (pid > 0)) {
#line 339
      if (pid < 0) {
#line 339
        tmp___0 = __errno_location();
#line 339
        if (! (*tmp___0 == 4)) {
#line 339
          break;
        }
      } else {
#line 339
        break;
      }
    }
  }
#line 343
  mysignal(17, & main_sigchld_handler);
#line 344
  tmp___1 = __errno_location();
#line 344
  *tmp___1 = save_errno;
#line 345
  return;
}
}
#line 351 "sshd.c"
static void grace_alarm_handler(int sig ) 
{ char const   *tmp ;

  {
#line 354
  if (use_privsep) {
#line 354
    if ((unsigned int )pmonitor != (unsigned int )((void *)0)) {
#line 354
      if (pmonitor->m_pid > 0) {
#line 355
        kill(pmonitor->m_pid, 14);
      }
    }
  }
#line 358
  tmp = get_remote_ipaddr();
#line 358
  sigdie("Timeout before authentication for %s", tmp);
#line 359
  return;
}
}
#line 368 "sshd.c"
static void generate_ephemeral_server_key(void) 
{ u_int32_t rnd ;
  int i ;
  char const   *tmp ;

  {
#line 371
  rnd = (u_int32_t )0;
#line 374
  if (sensitive_data.server_key) {
#line 374
    tmp = "new ";
  } else {
#line 374
    tmp = "";
  }
#line 374
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
#line 376
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 377
    key_free(sensitive_data.server_key);
  }
#line 378
  sensitive_data.server_key = key_generate(0, (unsigned int )options.server_key_bits);
#line 380
  verbose("RSA key generation complete.");
#line 382
  i = 0;
#line 382
  while (i < 32) {
#line 383
    if (i % 4 == 0) {
#line 384
      rnd = arc4random();
    }
#line 385
    sensitive_data.ssh1_cookie[i] = (unsigned char )(rnd & 255U);
#line 386
    rnd >>= 8;
#line 382
    i ++;
  }
#line 388
  arc4random_stir();
#line 389
  return;
}
}
#line 392 "sshd.c"
static void key_regeneration_alarm(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 395
  tmp = __errno_location();
#line 395
  save_errno = *tmp;
#line 397
  mysignal(14, (void (*)(int  ))0);
#line 398
  tmp___0 = __errno_location();
#line 398
  *tmp___0 = save_errno;
#line 399
  key_do_regen = (int volatile   )1;
#line 400
  return;
}
}
#line 402 "sshd.c"
static void sshd_exchange_identification(int sock_in , int sock_out ) 
{ u_int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  size_t tmp___36 ;
  char const   *tmp___37 ;

  {
#line 413
  if (options.protocol & 1) {
#line 413
    if (options.protocol & 4) {
#line 415
      major = 1;
#line 416
      minor = 99;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 417
    if (options.protocol & 4) {
#line 418
      major = 2;
#line 419
      minor = 0;
    } else {
#line 421
      major = 1;
#line 422
      minor = 5;
    }
  }
#line 424
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_5.0");
#line 425
  server_version_string = xstrdup((char const   *)(buf___1));
#line 428
  tmp___0 = strlen((char const   *)server_version_string);
#line 428
  tmp___1 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)server_version_string,
                     tmp___0);
#line 428
  tmp___2 = strlen((char const   *)server_version_string);
#line 428
  if (tmp___1 != tmp___2) {
#line 431
    tmp = get_remote_ipaddr();
#line 431
    logit("Could not write ident string to %s", tmp);
#line 432
    cleanup_exit(255);
  }
#line 436
  memset((void *)(buf___1), 0, sizeof(buf___1));
#line 437
  i = 0U;
#line 437
  while (i < sizeof(buf___1) - 1U) {
#line 438
    tmp___4 = atomicio(& read, sock_in, (void *)(& buf___1[i]), 1U);
#line 438
    if (tmp___4 != 1U) {
#line 439
      tmp___3 = get_remote_ipaddr();
#line 439
      logit("Did not receive identification string from %s", tmp___3);
#line 441
      cleanup_exit(255);
    }
#line 443
    if ((int )buf___1[i] == 13) {
#line 444
      buf___1[i] = (char)0;
#line 447
      if (i == 12U) {
#line 447
        if (0) {
#line 447
          if (0) {
#line 447
            __s1_len___0 = strlen((char const   *)(buf___1));
#line 447
            __s2_len___0 = strlen("SSH-1.5-W1.0");
#line 447
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
              goto _L___3;
            } else {
#line 447
              if (__s1_len___0 >= 4U) {
                _L___3: /* CIL Label */ 
#line 447
                if (! ((unsigned int )((void const   *)("SSH-1.5-W1.0" + 1)) - (unsigned int )((void const   *)"SSH-1.5-W1.0") == 1U)) {
#line 447
                  tmp___28 = 1;
                } else {
#line 447
                  if (__s2_len___0 >= 4U) {
#line 447
                    tmp___28 = 1;
                  } else {
#line 447
                    tmp___28 = 0;
                  }
                }
              } else {
#line 447
                tmp___28 = 0;
              }
            }
#line 447
            if (tmp___28) {
#line 447
              tmp___24 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
            } else {
#line 447
              tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 447
              tmp___24 = tmp___27;
            }
          } else {
#line 447
            tmp___27 = __builtin_strcmp((char const   *)(buf___1), "SSH-1.5-W1.0");
#line 447
            tmp___24 = tmp___27;
          }
#line 447
          tmp___18 = tmp___24;
        } else {
#line 447
          tmp___18 = strncmp((char const   *)(buf___1), "SSH-1.5-W1.0", 12U);
        }
#line 447
        if (tmp___18 == 0) {
#line 448
          break;
        }
      }
      goto __Cont;
    }
#line 451
    if ((int )buf___1[i] == 10) {
#line 452
      buf___1[i] = (char)0;
#line 453
      break;
    }
    __Cont: /* CIL Label */ 
#line 437
    i ++;
  }
#line 456
  buf___1[sizeof(buf___1) - 1U] = (char)0;
#line 457
  client_version_string = xstrdup((char const   *)(buf___1));
#line 463
  tmp___33 = sscanf((char const   * __restrict  )client_version_string, (char const   * __restrict  )"SSH-%d.%d-%[^\n]\n",
                    & remote_major, & remote_minor, remote_version);
#line 463
  if (tmp___33 != 3) {
#line 465
    s = (char *)"Protocol mismatch.\n";
#line 466
    tmp___31 = strlen((char const   *)s);
#line 466
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___31);
#line 467
    close(sock_in);
#line 468
    close(sock_out);
#line 469
    tmp___32 = get_remote_ipaddr();
#line 469
    logit("Bad protocol version identification \'%.100s\' from %s", client_version_string,
          tmp___32);
#line 471
    cleanup_exit(255);
  }
#line 473
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
#line 476
  compat_datafellows((char const   *)(remote_version));
#line 478
  if (datafellows & 4194304) {
#line 479
    tmp___34 = get_remote_ipaddr();
#line 479
    logit("probed from %s with %s.  Don\'t panic.", tmp___34, client_version_string);
#line 481
    cleanup_exit(255);
  }
#line 484
  if (datafellows & 2048) {
#line 485
    tmp___35 = get_remote_ipaddr();
#line 485
    logit("scanned from %s with %s.  Don\'t panic.", tmp___35, client_version_string);
#line 487
    cleanup_exit(255);
  }
#line 490
  mismatch = 0;
#line 491
  switch (remote_major) {
  case 1: 
#line 493
  if (remote_minor == 99) {
#line 494
    if (options.protocol & 4) {
#line 495
      enable_compat20();
    } else {
#line 497
      mismatch = 1;
    }
#line 498
    break;
  }
#line 500
  if (! (options.protocol & 1)) {
#line 501
    mismatch = 1;
#line 502
    break;
  }
#line 504
  if (remote_minor < 3) {
#line 505
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
  } else {
#line 507
    if (remote_minor == 3) {
#line 509
      enable_compat13();
    }
  }
#line 511
  break;
  case 2: 
#line 513
  if (options.protocol & 4) {
#line 514
    enable_compat20();
#line 515
    break;
  }
  default: 
#line 519
  mismatch = 1;
#line 520
  break;
  }
#line 522
  chop(server_version_string);
#line 523
  debug("Local version string %.200s", server_version_string);
#line 525
  if (mismatch) {
#line 526
    s = (char *)"Protocol major versions differ.\n";
#line 527
    tmp___36 = strlen((char const   *)s);
#line 527
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___36);
#line 528
    close(sock_in);
#line 529
    close(sock_out);
#line 530
    tmp___37 = get_remote_ipaddr();
#line 530
    logit("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___37, server_version_string,
          client_version_string);
#line 533
    cleanup_exit(255);
  }
#line 535
  return;
}
}
#line 538 "sshd.c"
void destroy_sensitive_data(void) 
{ int i ;

  {
#line 543
  if (sensitive_data.server_key) {
#line 544
    key_free(sensitive_data.server_key);
#line 545
    sensitive_data.server_key = (Key *)((void *)0);
  }
#line 547
  i = 0;
#line 547
  while (i < options.num_host_key_files) {
#line 548
    if (*(sensitive_data.host_keys + i)) {
#line 549
      key_free(*(sensitive_data.host_keys + i));
#line 550
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    }
#line 547
    i ++;
  }
#line 553
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 554
  memset((void *)(sensitive_data.ssh1_cookie), 0, 32U);
#line 555
  return;
}
}
#line 558 "sshd.c"
void demote_sensitive_data(void) 
{ Key *tmp ;
  int i ;

  {
#line 564
  if (sensitive_data.server_key) {
#line 565
    tmp = key_demote((Key const   *)sensitive_data.server_key);
#line 566
    key_free(sensitive_data.server_key);
#line 567
    sensitive_data.server_key = tmp;
  }
#line 570
  i = 0;
#line 570
  while (i < options.num_host_key_files) {
#line 571
    if (*(sensitive_data.host_keys + i)) {
#line 572
      tmp = key_demote((Key const   *)*(sensitive_data.host_keys + i));
#line 573
      key_free(*(sensitive_data.host_keys + i));
#line 574
      *(sensitive_data.host_keys + i) = tmp;
#line 575
      if (tmp->type == 0) {
#line 576
        sensitive_data.ssh1_host_key = tmp;
      }
    }
#line 570
    i ++;
  }
#line 581
  return;
}
}
#line 583 "sshd.c"
static void privsep_preauth_child(void) 
{ u_int32_t rnd[256] ;
  gid_t gidset[1] ;
  u_int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 591
  privsep_challenge_enable();
#line 593
  arc4random_stir();
#line 594
  i = 0U;
#line 594
  while (i < 256U) {
#line 595
    rnd[i] = arc4random();
#line 594
    i ++;
  }
#line 596
  RAND_seed((void const   *)(rnd), (int )sizeof(rnd));
#line 599
  demote_sensitive_data();
#line 602
  tmp___1 = chroot("/var/empty");
#line 602
  if (tmp___1 == -1) {
#line 603
    tmp = __errno_location();
#line 603
    tmp___0 = strerror(*tmp);
#line 603
    fatal("chroot(\"%s\"): %s", "/var/empty", tmp___0);
  }
#line 605
  tmp___4 = chdir("/");
#line 605
  if (tmp___4 == -1) {
#line 606
    tmp___2 = __errno_location();
#line 606
    tmp___3 = strerror(*tmp___2);
#line 606
    fatal("chdir(\"/\"): %s", tmp___3);
  }
#line 609
  debug3("privsep user:group %u:%u", privsep_pw->pw_uid, privsep_pw->pw_gid);
#line 615
  gidset[0] = privsep_pw->pw_gid;
#line 616
  tmp___7 = setgroups(1U, (__gid_t const   *)(gidset));
#line 616
  if (tmp___7 < 0) {
#line 617
    tmp___5 = __errno_location();
#line 617
    tmp___6 = strerror(*tmp___5);
#line 617
    fatal("setgroups: %.100s", tmp___6);
  }
#line 618
  permanently_set_uid(privsep_pw);
#line 620
  return;
}
}
#line 622 "sshd.c"
static int privsep_preauth(Authctxt *authctxt___0 ) 
{ int status ;
  pid_t pid ;
  int *tmp ;
  __pid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;

  {
#line 629
  pmonitor = monitor_init();
#line 631
  pmonitor->m_pkex = & xxx_kex;
#line 633
  pid = fork();
#line 634
  if (pid == -1) {
#line 635
    fatal("fork of unprivileged child failed");
  } else {
#line 636
    if (pid != 0) {
#line 637
      debug2("Network child is on pid %ld", (long )pid);
#line 639
      close(pmonitor->m_recvfd);
#line 640
      pmonitor->m_pid = pid;
#line 641
      monitor_child_preauth(authctxt___0, pmonitor);
#line 642
      close(pmonitor->m_sendfd);
#line 645
      monitor_sync(pmonitor);
#line 648
      while (1) {
#line 648
        tmp___0 = waitpid(pid, & status, 0);
#line 648
        if (! (tmp___0 < 0)) {
#line 648
          break;
        }
#line 649
        tmp = __errno_location();
#line 649
        if (*tmp != 4) {
#line 650
          break;
        }
      }
#line 651
      return (1);
    } else {
#line 655
      close(pmonitor->m_sendfd);
#line 658
      tmp___1 = getuid();
#line 658
      if (tmp___1 == 0U) {
#line 659
        privsep_preauth_child();
      } else {
#line 658
        tmp___2 = geteuid();
#line 658
        if (tmp___2 == 0U) {
#line 659
          privsep_preauth_child();
        }
      }
#line 660
      setproctitle("%s", "[net]");
    }
  }
#line 662
  return (0);
}
}
#line 665 "sshd.c"
static void privsep_postauth(Authctxt *authctxt___0 ) 
{ u_int32_t rnd[256] ;
  u_int i ;

  {
#line 674
  if ((authctxt___0->pw)->pw_uid == 0U) {
#line 677
    use_privsep = 0;
    goto skip;
  } else {
#line 674
    if (options.use_login) {
#line 677
      use_privsep = 0;
      goto skip;
    }
  }
#line 682
  monitor_reinit(pmonitor);
#line 684
  pmonitor->m_pid = fork();
#line 685
  if (pmonitor->m_pid == -1) {
#line 686
    fatal("fork of unprivileged child failed");
  } else {
#line 687
    if (pmonitor->m_pid != 0) {
#line 688
      debug2("User child is on pid %ld", (long )pmonitor->m_pid);
#line 689
      close(pmonitor->m_recvfd);
#line 690
      buffer_clear(& loginmsg);
#line 691
      monitor_child_postauth(pmonitor);
#line 694
      exit(0);
    }
  }
#line 697
  close(pmonitor->m_sendfd);
#line 700
  demote_sensitive_data();
#line 702
  arc4random_stir();
#line 703
  i = 0U;
#line 703
  while (i < 256U) {
#line 704
    rnd[i] = arc4random();
#line 703
    i ++;
  }
#line 705
  RAND_seed((void const   *)(rnd), (int )sizeof(rnd));
#line 708
  do_setusercontext(authctxt___0->pw);
  skip: 
#line 712
  monitor_apply_keystate(pmonitor);
#line 718
  packet_set_authenticated();
#line 719
  return;
}
}
#line 721 "sshd.c"
static char *list_hostkey_types(void) 
{ Buffer b ;
  char const   *p ;
  char *ret___0 ;
  int i ;
  Key *key ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 729
  buffer_init(& b);
#line 730
  i = 0;
#line 730
  while (i < options.num_host_key_files) {
#line 731
    key = *(sensitive_data.host_keys + i);
#line 732
    if ((unsigned int )key == (unsigned int )((void *)0)) {
      goto __Cont;
    }
#line 734
    switch (key->type) {
    case 1: 
    case 2: 
#line 737
    tmp = buffer_len(& b);
#line 737
    if (tmp > 0U) {
#line 738
      buffer_append(& b, (void const   *)",", 1U);
    }
#line 739
    p = key_ssh_name((Key const   *)key);
#line 740
    tmp___0 = strlen(p);
#line 740
    buffer_append(& b, (void const   *)p, tmp___0);
#line 741
    break;
    }
    __Cont: /* CIL Label */ 
#line 730
    i ++;
  }
#line 744
  buffer_append(& b, (void const   *)"\000", 1U);
#line 745
  tmp___1 = buffer_ptr(& b);
#line 745
  ret___0 = xstrdup((char const   *)tmp___1);
#line 746
  buffer_free(& b);
#line 747
  debug("list_hostkey_types: %s", ret___0);
#line 748
  return (ret___0);
}
}
#line 751 "sshd.c"
Key *get_hostkey_by_type(int type ) 
{ int i ;
  Key *key ;

  {
#line 756
  i = 0;
#line 756
  while (i < options.num_host_key_files) {
#line 757
    key = *(sensitive_data.host_keys + i);
#line 758
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 758
      if (key->type == type) {
#line 759
        return (key);
      }
    }
#line 756
    i ++;
  }
#line 761
  return ((Key *)((void *)0));
}
}
#line 764 "sshd.c"
Key *get_hostkey_by_index(int ind ) 
{ 

  {
#line 767
  if (ind < 0) {
#line 768
    return ((Key *)((void *)0));
  } else {
#line 767
    if (ind >= options.num_host_key_files) {
#line 768
      return ((Key *)((void *)0));
    }
  }
#line 769
  return (*(sensitive_data.host_keys + ind));
}
}
#line 772 "sshd.c"
int get_hostkey_index(Key *key ) 
{ int i ;

  {
#line 777
  i = 0;
#line 777
  while (i < options.num_host_key_files) {
#line 778
    if ((unsigned int )key == (unsigned int )*(sensitive_data.host_keys + i)) {
#line 779
      return (i);
    }
#line 777
    i ++;
  }
#line 781
  return (-1);
}
}
#line 790 "sshd.c"
static int drop_connection(int startups ) 
{ int p ;
  int r ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 795
  if (startups < options.max_startups_begin) {
#line 796
    return (0);
  }
#line 797
  if (startups >= options.max_startups) {
#line 798
    return (1);
  }
#line 799
  if (options.max_startups_rate == 100) {
#line 800
    return (1);
  }
#line 802
  p = 100 - options.max_startups_rate;
#line 803
  p *= startups - options.max_startups_begin;
#line 804
  p /= options.max_startups - options.max_startups_begin;
#line 805
  p += options.max_startups_rate;
#line 806
  tmp = arc4random();
#line 806
  r = (int )(tmp % 100U);
#line 808
  debug("drop_connection: p %d, r %d", p, r);
#line 809
  if (r < p) {
#line 809
    tmp___0 = 1;
  } else {
#line 809
    tmp___0 = 0;
  }
#line 809
  return (tmp___0);
}
}
#line 812 "sshd.c"
static void usage(void) 
{ char const   *tmp ;

  {
#line 815
  tmp = SSLeay_version(0);
#line 815
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s, %s\n", "OpenSSH_5.0p1",
          tmp);
#line 817
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: sshd [-46Ddeiqt] [-b bits] [-f config_file] [-g login_grace_time]\n            [-h host_key_file] [-k key_gen_time] [-o option] [-p port] [-u len]\n");
#line 821
  exit(1);
}
}
#line 824 "sshd.c"
static void send_rexec_state(int fd , Buffer *conf ) 
{ Buffer m___0 ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 829
  tmp = buffer_len(conf);
#line 829
  debug3("%s: entering fd = %d config len %d", "send_rexec_state", fd, tmp);
#line 844
  buffer_init(& m___0);
#line 845
  tmp___0 = buffer_ptr(conf);
#line 845
  buffer_put_cstring(& m___0, (char const   *)tmp___0);
#line 847
  if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 847
    if ((sensitive_data.server_key)->type == 0) {
#line 849
      buffer_put_int(& m___0, 1U);
#line 850
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->e);
#line 851
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 852
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->d);
#line 853
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->iqmp);
#line 854
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->p);
#line 855
      buffer_put_bignum(& m___0, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->q);
    } else {
#line 857
      buffer_put_int(& m___0, 0U);
    }
  } else {
#line 857
    buffer_put_int(& m___0, 0U);
  }
#line 863
  tmp___1 = ssh_msg_send(fd, (unsigned char)0, & m___0);
#line 863
  if (tmp___1 == -1) {
#line 864
    fatal("%s: ssh_msg_send failed", "send_rexec_state");
  }
#line 866
  buffer_free(& m___0);
#line 868
  debug3("%s: done", "send_rexec_state");
#line 869
  return;
}
}
#line 871 "sshd.c"
static void recv_rexec_state(int fd , Buffer *conf ) 
{ Buffer m___0 ;
  char *cp ;
  u_int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;

  {
#line 878
  debug3("%s: entering fd = %d", "recv_rexec_state", fd);
#line 880
  buffer_init(& m___0);
#line 882
  tmp = ssh_msg_recv(fd, & m___0);
#line 882
  if (tmp == -1) {
#line 883
    fatal("%s: ssh_msg_recv failed", "recv_rexec_state");
  }
#line 884
  tmp___0 = buffer_get_char(& m___0);
#line 884
  if (tmp___0 != 0) {
#line 885
    fatal("%s: rexec version mismatch", "recv_rexec_state");
  }
#line 887
  tmp___1 = buffer_get_string(& m___0, & len);
#line 887
  cp = (char *)tmp___1;
#line 888
  if ((unsigned int )conf != (unsigned int )((void *)0)) {
#line 889
    buffer_append(conf, (void const   *)cp, len + 1U);
  }
#line 890
  xfree((void *)cp);
#line 892
  tmp___2 = buffer_get_int(& m___0);
#line 892
  if (tmp___2) {
#line 893
    if ((unsigned int )sensitive_data.server_key != (unsigned int )((void *)0)) {
#line 894
      key_free(sensitive_data.server_key);
    }
#line 895
    sensitive_data.server_key = key_new_private(0);
#line 896
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->e);
#line 897
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->n);
#line 898
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->d);
#line 899
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->iqmp);
#line 900
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->p);
#line 901
    buffer_get_bignum(& m___0, ((sensitive_data.server_key)->rsa)->q);
#line 902
    rsa_generate_additional_parameters((sensitive_data.server_key)->rsa);
  }
#line 910
  buffer_free(& m___0);
#line 912
  debug3("%s: done", "recv_rexec_state");
#line 913
  return;
}
}
#line 916 "sshd.c"
static void server_accept_inetd(int *sock_in , int *sock_out ) 
{ int fd ;

  {
#line 921
  startup_pipe = -1;
#line 922
  if (rexeced_flag) {
#line 923
    close(5);
#line 924
    *sock_out = dup(0);
#line 924
    *sock_in = *sock_out;
#line 925
    if (! debug_flag) {
#line 926
      startup_pipe = dup(4);
#line 927
      close(4);
    }
  } else {
#line 930
    *sock_in = dup(0);
#line 931
    *sock_out = dup(1);
  }
#line 938
  fd = open("/dev/null", 2, 0);
#line 938
  if (fd != -1) {
#line 939
    dup2(fd, 0);
#line 940
    dup2(fd, 1);
#line 941
    if (fd > 1) {
#line 942
      close(fd);
    }
  }
#line 944
  debug("inetd sockets after dupping: %d, %d", *sock_in, *sock_out);
#line 945
  return;
}
}
#line 950 "sshd.c"
static void server_listen(void) 
{ int ret___0 ;
  int listen_sock ;
  int on ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 953
  on = 1;
#line 957
  ai = options.listen_addrs;
#line 957
  while (ai) {
#line 958
    if (ai->ai_family != 2) {
#line 958
      if (ai->ai_family != 10) {
        goto __Cont;
      }
    }
#line 960
    if (num_listen_socks >= 16) {
#line 961
      fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
    }
#line 963
    ret___0 = getnameinfo((struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen,
                          (char * __restrict  )(ntop), sizeof(ntop), (char * __restrict  )(strport),
                          sizeof(strport), 3U);
#line 963
    if (ret___0 != 0) {
#line 966
      tmp = ssh_gai_strerror(ret___0);
#line 966
      error("getnameinfo failed: %.100s", tmp);
      goto __Cont;
    }
#line 971
    listen_sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
#line 973
    if (listen_sock < 0) {
#line 975
      tmp___0 = __errno_location();
#line 975
      tmp___1 = strerror(*tmp___0);
#line 975
      verbose("socket: %.100s", tmp___1);
      goto __Cont;
    }
#line 978
    tmp___2 = set_nonblock(listen_sock);
#line 978
    if (tmp___2 == -1) {
#line 979
      close(listen_sock);
      goto __Cont;
    }
#line 986
    tmp___5 = setsockopt(listen_sock, 1, 2, (void const   *)(& on), sizeof(on));
#line 986
    if (tmp___5 == -1) {
#line 988
      tmp___3 = __errno_location();
#line 988
      tmp___4 = strerror(*tmp___3);
#line 988
      error("setsockopt SO_REUSEADDR: %s", tmp___4);
    }
#line 992
    if (ai->ai_family == 10) {
#line 993
      tmp___8 = setsockopt(listen_sock, 41, 26, (void const   *)(& on), sizeof(on));
#line 993
      if (tmp___8 == -1) {
#line 995
        tmp___6 = __errno_location();
#line 995
        tmp___7 = strerror(*tmp___6);
#line 995
        error("setsockopt IPV6_V6ONLY: %s", tmp___7);
      }
    }
#line 1000
    debug("Bind to port %s on %s.", strport, ntop);
#line 1003
    tmp___11 = bind(listen_sock, (struct sockaddr  const  * __restrict  )ai->ai_addr,
                    ai->ai_addrlen);
#line 1003
    if (tmp___11 < 0) {
#line 1004
      tmp___9 = __errno_location();
#line 1004
      tmp___10 = strerror(*tmp___9);
#line 1004
      error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___10);
#line 1006
      close(listen_sock);
      goto __Cont;
    }
#line 1009
    listen_socks[num_listen_socks] = listen_sock;
#line 1010
    num_listen_socks ++;
#line 1013
    tmp___14 = listen(listen_sock, 128);
#line 1013
    if (tmp___14 < 0) {
#line 1014
      tmp___12 = __errno_location();
#line 1014
      tmp___13 = strerror(*tmp___12);
#line 1014
      fatal("listen on [%s]:%s: %.100s", ntop, strport, tmp___13);
    }
#line 1016
    logit("Server listening on %s port %s.", ntop, strport);
    __Cont: /* CIL Label */ 
#line 957
    ai = ai->ai_next;
  }
#line 1018
  freeaddrinfo(options.listen_addrs);
#line 1020
  if (! num_listen_socks) {
#line 1021
    fatal("Cannot bind any address.");
  }
#line 1022
  return;
}
}
#line 1028 "sshd.c"
static void server_accept_loop(int *sock_in , int *sock_out , int *newsock , int *config_s ) 
{ fd_set *fdset ;
  int i ;
  int j ;
  int ret___0 ;
  int maxfd ;
  int key_used ;
  int startups ;
  int startup_p[2] ;
  struct sockaddr_storage from ;
  socklen_t fromlen ;
  pid_t pid ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  register char __result ;
  register char __result___0 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;

  {
#line 1033
  key_used = 0;
#line 1033
  startups = 0;
#line 1034
  startup_p[0] = -1;
#line 1034
  startup_p[1] = -1;
#line 1040
  fdset = (fd_set *)((void *)0);
#line 1041
  maxfd = 0;
#line 1042
  i = 0;
#line 1042
  while (i < num_listen_socks) {
#line 1043
    if (listen_socks[i] > maxfd) {
#line 1044
      maxfd = listen_socks[i];
    }
#line 1042
    i ++;
  }
#line 1046
  tmp = xcalloc((unsigned int )options.max_startups, sizeof(int ));
#line 1046
  startup_pipes = (int *)tmp;
#line 1047
  i = 0;
#line 1047
  while (i < options.max_startups) {
#line 1048
    *(startup_pipes + i) = -1;
#line 1047
    i ++;
  }
#line 1054
  while (1) {
#line 1055
    if (received_sighup) {
#line 1056
      sighup_restart();
    }
#line 1057
    if ((unsigned int )fdset != (unsigned int )((void *)0)) {
#line 1058
      xfree((void *)fdset);
    }
#line 1059
    tmp___0 = xcalloc(((unsigned int )(maxfd + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask )),
                      sizeof(fd_mask ));
#line 1059
    fdset = (fd_set *)tmp___0;
#line 1062
    i = 0;
#line 1062
    while (i < num_listen_socks) {
#line 1063
      __asm__  volatile   ("btsl %1,%0": "=m" (fdset->fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 1062
      i ++;
    }
#line 1064
    i = 0;
#line 1064
    while (i < options.max_startups) {
#line 1065
      if (*(startup_pipes + i) != -1) {
#line 1066
        __asm__  volatile   ("btsl %1,%0": "=m" (fdset->fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 1064
      i ++;
    }
#line 1069
    ret___0 = select(maxfd + 1, (fd_set * __restrict  )fdset, (fd_set * __restrict  )((void *)0),
                     (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1070
    if (ret___0 < 0) {
#line 1070
      tmp___3 = __errno_location();
#line 1070
      if (*tmp___3 != 4) {
#line 1071
        tmp___1 = __errno_location();
#line 1071
        tmp___2 = strerror(*tmp___1);
#line 1071
        error("select: %.100s", tmp___2);
      }
    }
#line 1072
    if (received_sigterm) {
#line 1073
      logit("Received signal %d; terminating.", (int )received_sigterm);
#line 1075
      close_listen_socks();
#line 1076
      unlink((char const   *)options.pid_file);
#line 1077
      exit(255);
    }
#line 1079
    if (key_used) {
#line 1079
      if (key_do_regen) {
#line 1080
        generate_ephemeral_server_key();
#line 1081
        key_used = 0;
#line 1082
        key_do_regen = (int volatile   )0;
      }
    }
#line 1084
    if (ret___0 < 0) {
      goto __Cont;
    }
#line 1087
    i = 0;
#line 1087
    while (i < options.max_startups) {
#line 1089
      if (*(startup_pipes + i) != -1) {
#line 1089
        __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )*(startup_pipes + i) % (8U * sizeof(__fd_mask ))),
                             "m" (fdset->fds_bits[(unsigned int )*(startup_pipes + i) / (8U * sizeof(__fd_mask ))]): "cc");
#line 1089
        if (__result) {
#line 1096
          close(*(startup_pipes + i));
#line 1097
          *(startup_pipes + i) = -1;
#line 1098
          startups --;
        }
      }
#line 1087
      i ++;
    }
#line 1100
    i = 0;
#line 1100
    while (i < num_listen_socks) {
#line 1101
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )listen_socks[i] % (8U * sizeof(__fd_mask ))),
                           "m" (fdset->fds_bits[(unsigned int )listen_socks[i] / (8U * sizeof(__fd_mask ))]): "cc");
#line 1101
      if (! __result___0) {
        goto __Cont___0;
      }
#line 1103
      fromlen = sizeof(from);
#line 1104
      *newsock = accept(listen_socks[i], (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                        (socklen_t * __restrict  )(& fromlen));
#line 1106
      if (*newsock < 0) {
#line 1107
        tmp___6 = __errno_location();
#line 1107
        if (*tmp___6 != 4) {
#line 1107
          tmp___7 = __errno_location();
#line 1107
          if (*tmp___7 != 11) {
#line 1108
            tmp___4 = __errno_location();
#line 1108
            tmp___5 = strerror(*tmp___4);
#line 1108
            error("accept: %.100s", tmp___5);
          }
        }
        goto __Cont___0;
      }
#line 1111
      tmp___8 = unset_nonblock(*newsock);
#line 1111
      if (tmp___8 == -1) {
#line 1112
        close(*newsock);
        goto __Cont___0;
      }
#line 1115
      tmp___9 = drop_connection(startups);
#line 1115
      if (tmp___9 == 1) {
#line 1116
        debug("drop connection #%d", startups);
#line 1117
        close(*newsock);
        goto __Cont___0;
      }
#line 1120
      tmp___10 = pipe((int *)(startup_p));
#line 1120
      if (tmp___10 == -1) {
#line 1121
        close(*newsock);
        goto __Cont___0;
      }
#line 1125
      if (rexec_flag) {
#line 1125
        tmp___13 = socketpair(1, 1, 0, (int *)config_s);
#line 1125
        if (tmp___13 == -1) {
#line 1127
          tmp___11 = __errno_location();
#line 1127
          tmp___12 = strerror(*tmp___11);
#line 1127
          error("reexec socketpair: %s", tmp___12);
#line 1129
          close(*newsock);
#line 1130
          close(startup_p[0]);
#line 1131
          close(startup_p[1]);
          goto __Cont___0;
        }
      }
#line 1135
      j = 0;
#line 1135
      while (j < options.max_startups) {
#line 1136
        if (*(startup_pipes + j) == -1) {
#line 1137
          *(startup_pipes + j) = startup_p[0];
#line 1138
          if (maxfd < startup_p[0]) {
#line 1139
            maxfd = startup_p[0];
          }
#line 1140
          startups ++;
#line 1141
          break;
        }
#line 1135
        j ++;
      }
#line 1148
      if (debug_flag) {
#line 1154
        debug("Server will not fork when running in debugging mode.");
#line 1155
        close_listen_socks();
#line 1156
        *sock_in = *newsock;
#line 1157
        *sock_out = *newsock;
#line 1158
        close(startup_p[0]);
#line 1159
        close(startup_p[1]);
#line 1160
        startup_pipe = -1;
#line 1161
        pid = getpid();
#line 1162
        if (rexec_flag) {
#line 1163
          send_rexec_state(*(config_s + 0), & cfg);
#line 1165
          close(*(config_s + 0));
        }
#line 1167
        break;
      }
#line 1175
      platform_pre_fork();
#line 1176
      pid = fork();
#line 1176
      if (pid == 0) {
#line 1185
        platform_post_fork_child();
#line 1186
        startup_pipe = startup_p[1];
#line 1187
        close_startup_pipes();
#line 1188
        close_listen_socks();
#line 1189
        *sock_in = *newsock;
#line 1190
        *sock_out = *newsock;
#line 1191
        log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1195
        if (rexec_flag) {
#line 1196
          close(*(config_s + 0));
        }
#line 1197
        break;
      }
#line 1201
      platform_post_fork_parent(pid);
#line 1202
      if (pid < 0) {
#line 1203
        tmp___14 = __errno_location();
#line 1203
        tmp___15 = strerror(*tmp___14);
#line 1203
        error("fork: %.100s", tmp___15);
      } else {
#line 1205
        debug("Forked child %ld.", (long )pid);
      }
#line 1207
      close(startup_p[1]);
#line 1209
      if (rexec_flag) {
#line 1210
        send_rexec_state(*(config_s + 0), & cfg);
#line 1211
        close(*(config_s + 0));
#line 1212
        close(*(config_s + 1));
      }
#line 1219
      if (options.protocol & 1) {
#line 1219
        if (key_used == 0) {
#line 1222
          mysignal(14, & key_regeneration_alarm);
#line 1223
          alarm((unsigned int )options.key_regeneration_time);
#line 1224
          key_used = 1;
        }
      }
#line 1227
      close(*newsock);
#line 1233
      arc4random_stir();
      __Cont___0: /* CIL Label */ 
#line 1100
      i ++;
    }
#line 1237
    if (num_listen_socks < 0) {
#line 1238
      break;
    }
    __Cont: /* CIL Label */ ;
  }
#line 1240
  return;
}
}
#line 1246 "sshd.c"
int main(int ac , char **av ) 
{ int opt ;
  int i ;
  int on ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  char const   *remote_ip___0 ;
  int remote_port ;
  char *line ;
  int config_s[2] ;
  Key *key ;
  Authctxt *authctxt___0 ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  long long tmp___4 ;
  u_int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  struct stat st ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int fd ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  FILE *f ;
  FILE *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  __pid_t tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  __pid_t tmp___37 ;
  int fd___0 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  void *tmp___44 ;
  int tmp___45 ;

  {
#line 1251
  on = 1;
#line 1252
  sock_in = -1;
#line 1252
  sock_out = -1;
#line 1252
  newsock = -1;
#line 1256
  config_s[0] = -1;
#line 1256
  config_s[1] = -1;
#line 1263
  __progname = ssh_get_progname(*(av + 0));
#line 1264
  init_rng();
#line 1267
  saved_argc = ac;
#line 1268
  rexec_argc = ac;
#line 1269
  tmp = xcalloc((unsigned int )(ac + 1), sizeof(*saved_argv));
#line 1269
  saved_argv = (char **)tmp;
#line 1270
  i = 0;
#line 1270
  while (i < ac) {
#line 1271
    *(saved_argv + i) = xstrdup((char const   *)*(av + i));
#line 1270
    i ++;
  }
#line 1272
  *(saved_argv + i) = (char *)((void *)0);
#line 1276
  compat_init_setproctitle(ac, av);
#line 1277
  av = saved_argv;
#line 1280
  tmp___2 = geteuid();
#line 1280
  if (tmp___2 == 0U) {
#line 1280
    tmp___3 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 1280
    if (tmp___3 == -1) {
#line 1281
      tmp___0 = __errno_location();
#line 1281
      tmp___1 = strerror(*tmp___0);
#line 1281
      debug("setgroups(): %.200s", tmp___1);
    }
  }
#line 1284
  sanitise_stdfd();
#line 1287
  initialize_server_options(& options);
#line 1290
  while (1) {
#line 1290
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:u:o:dDeiqrtQR46");
#line 1290
    if (! (opt != -1)) {
#line 1290
      break;
    }
#line 1291
    switch (opt) {
    case 52: 
#line 1293
    options.address_family = 2;
#line 1294
    break;
    case 54: 
#line 1296
    options.address_family = 10;
#line 1297
    break;
    case 102: 
#line 1299
    config_file_name = BSDoptarg;
#line 1300
    break;
    case 100: 
#line 1302
    if (debug_flag == 0) {
#line 1303
      debug_flag = 1;
#line 1304
      options.log_level = 5;
    } else {
#line 1305
      if ((int )options.log_level < 7) {
#line 1306
        options.log_level = (LogLevel )((int )options.log_level + 1);
      }
    }
#line 1307
    break;
    case 68: 
#line 1309
    no_daemon_flag = 1;
#line 1310
    break;
    case 101: 
#line 1312
    log_stderr = 1;
#line 1313
    break;
    case 105: 
#line 1315
    inetd_flag = 1;
#line 1316
    break;
    case 114: 
#line 1318
    rexec_flag = 0;
#line 1319
    break;
    case 82: 
#line 1321
    rexeced_flag = 1;
#line 1322
    inetd_flag = 1;
#line 1323
    break;
    case 81: 
#line 1326
    break;
    case 113: 
#line 1328
    options.log_level = 0;
#line 1329
    break;
    case 98: 
#line 1331
    tmp___4 = strtonum((char const   *)BSDoptarg, 256LL, 32768LL, (char const   **)((void *)0));
#line 1331
    options.server_key_bits = (int )tmp___4;
#line 1333
    break;
    case 112: 
#line 1335
    options.ports_from_cmdline = 1U;
#line 1336
    if (options.num_ports >= 256U) {
#line 1337
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many ports.\n");
#line 1338
      exit(1);
    }
#line 1340
    tmp___5 = options.num_ports;
#line 1340
    (options.num_ports) ++;
#line 1340
    tmp___6 = a2port((char const   *)BSDoptarg);
#line 1340
    options.ports[tmp___5] = (unsigned short )tmp___6;
#line 1341
    if ((int )options.ports[options.num_ports - 1U] == 0) {
#line 1342
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad port number.\n");
#line 1343
      exit(1);
    }
#line 1345
    break;
    case 103: 
#line 1347
    tmp___7 = convtime((char const   *)BSDoptarg);
#line 1347
    options.login_grace_time = (int )tmp___7;
#line 1347
    if (options.login_grace_time == -1) {
#line 1348
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid login grace time.\n");
#line 1349
      exit(1);
    }
#line 1351
    break;
    case 107: 
#line 1353
    tmp___8 = convtime((char const   *)BSDoptarg);
#line 1353
    options.key_regeneration_time = (int )tmp___8;
#line 1353
    if (options.key_regeneration_time == -1) {
#line 1354
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid key regeneration interval.\n");
#line 1355
      exit(1);
    }
#line 1357
    break;
    case 104: 
#line 1359
    if (options.num_host_key_files >= 256) {
#line 1360
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"too many host keys.\n");
#line 1361
      exit(1);
    }
#line 1363
    tmp___9 = options.num_host_key_files;
#line 1363
    (options.num_host_key_files) ++;
#line 1363
    options.host_key_files[tmp___9] = BSDoptarg;
#line 1364
    break;
    case 116: 
#line 1366
    test_flag = 1;
#line 1367
    break;
    case 117: 
#line 1369
    tmp___10 = strtonum((char const   *)BSDoptarg, 0LL, 65LL, (char const   **)((void *)0));
#line 1369
    utmp_len = (unsigned int )tmp___10;
#line 1370
    if (utmp_len > 64U) {
#line 1371
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid utmp length.\n");
#line 1372
      exit(1);
    }
#line 1374
    break;
    case 111: 
#line 1376
    line = xstrdup((char const   *)BSDoptarg);
#line 1377
    tmp___11 = process_server_config_line(& options, line, "command-line", 0, (int *)((void *)0),
                                          (char const   *)((void *)0), (char const   *)((void *)0),
                                          (char const   *)((void *)0));
#line 1377
    if (tmp___11 != 0) {
#line 1379
      exit(1);
    }
#line 1380
    xfree((void *)line);
#line 1381
    break;
    case 63: 
    default: 
#line 1384
    usage();
#line 1385
    break;
    }
  }
#line 1388
  if (rexeced_flag) {
#line 1389
    rexec_flag = 0;
  } else {
#line 1388
    if (inetd_flag) {
#line 1389
      rexec_flag = 0;
    }
  }
#line 1390
  if (! test_flag) {
#line 1390
    if (rexec_flag) {
#line 1390
      if ((unsigned int )*(av + 0) == (unsigned int )((void *)0)) {
#line 1391
        fatal("sshd re-exec requires execution with an absolute path");
      } else {
#line 1390
        if ((int )*(*(av + 0)) != 47) {
#line 1391
          fatal("sshd re-exec requires execution with an absolute path");
        }
      }
    }
  }
#line 1392
  if (rexeced_flag) {
#line 1393
    closefrom(6);
  } else {
#line 1395
    closefrom(3);
  }
#line 1397
  OPENSSL_add_all_algorithms_noconf();
#line 1403
  if (log_stderr) {
#line 1403
    tmp___12 = 1;
  } else {
#line 1403
    if (! inetd_flag) {
#line 1403
      tmp___12 = 1;
    } else {
#line 1403
      tmp___12 = 0;
    }
  }
#line 1403
  if ((int )options.log_facility == -1) {
#line 1403
    tmp___13 = 2;
  } else {
#line 1403
    tmp___13 = (int )options.log_facility;
  }
#line 1403
  if ((int )options.log_level == -1) {
#line 1403
    tmp___14 = 3;
  } else {
#line 1403
    tmp___14 = (int )options.log_level;
  }
#line 1403
  log_init(__progname, (enum __anonenum_LogLevel_51 )tmp___14, (int )tmp___13, tmp___12);
#line 1414
  tmp___15 = getenv("KRB5CCNAME");
#line 1414
  if ((unsigned int )tmp___15 != (unsigned int )((void *)0)) {
#line 1415
    unsetenv("KRB5CCNAME");
  }
#line 1424
  sensitive_data.server_key = (Key *)((void *)0);
#line 1425
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 1426
  sensitive_data.have_ssh1_key = 0;
#line 1427
  sensitive_data.have_ssh2_key = 0;
#line 1430
  buffer_init(& cfg);
#line 1431
  if (rexeced_flag) {
#line 1432
    recv_rexec_state(5, & cfg);
  } else {
#line 1434
    load_server_config((char const   *)config_file_name, & cfg);
  }
#line 1436
  if (rexeced_flag) {
#line 1436
    tmp___16 = "rexec";
  } else {
#line 1436
    tmp___16 = (char const   *)config_file_name;
  }
#line 1436
  parse_server_config(& options, tmp___16, & cfg, (char const   *)((void *)0), (char const   *)((void *)0),
                      (char const   *)((void *)0));
#line 1439
  seed_rng();
#line 1442
  fill_default_server_options(& options);
#line 1445
  if (options.challenge_response_authentication) {
#line 1446
    options.kbd_interactive_authentication = 1;
  }
#line 1449
  channel_set_af(options.address_family);
#line 1452
  if (BSDoptind < ac) {
#line 1453
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extra argument %s.\n",
            *(av + BSDoptind));
#line 1454
    exit(1);
  }
#line 1457
  debug("sshd version %.100s", "OpenSSH_5.0p1");
#line 1460
  privsep_pw = getpwnam("sshd");
#line 1460
  if ((unsigned int )privsep_pw == (unsigned int )((void *)0)) {
#line 1461
    if (use_privsep) {
#line 1462
      fatal("Privilege separation user %s does not exist", "sshd");
    } else {
#line 1461
      if (options.kerberos_authentication) {
#line 1462
        fatal("Privilege separation user %s does not exist", "sshd");
      }
    }
  } else {
#line 1465
    tmp___17 = strlen((char const   *)privsep_pw->pw_passwd);
#line 1465
    memset((void *)privsep_pw->pw_passwd, 0, tmp___17);
#line 1466
    privsep_pw = pwcopy(privsep_pw);
#line 1467
    xfree((void *)privsep_pw->pw_passwd);
#line 1468
    privsep_pw->pw_passwd = xstrdup("*");
  }
#line 1470
  endpwent();
#line 1473
  tmp___18 = xcalloc((unsigned int )options.num_host_key_files, sizeof(Key *));
#line 1473
  sensitive_data.host_keys = (Key **)tmp___18;
#line 1475
  i = 0;
#line 1475
  while (i < options.num_host_key_files) {
#line 1476
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 1475
    i ++;
  }
#line 1478
  i = 0;
#line 1478
  while (i < options.num_host_key_files) {
#line 1479
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
#line 1480
    *(sensitive_data.host_keys + i) = key;
#line 1481
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1482
      error("Could not load host key: %s", options.host_key_files[i]);
#line 1484
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      goto __Cont;
    }
#line 1487
    switch (key->type) {
    case 0: 
#line 1489
    sensitive_data.ssh1_host_key = key;
#line 1490
    sensitive_data.have_ssh1_key = 1;
#line 1491
    break;
    case 1: 
    case 2: 
#line 1494
    sensitive_data.have_ssh2_key = 1;
#line 1495
    break;
    }
#line 1497
    tmp___19 = key_type((Key const   *)key);
#line 1497
    debug("private host key: #%d type %d %s", i, key->type, tmp___19);
    __Cont: /* CIL Label */ 
#line 1478
    i ++;
  }
#line 1500
  if (options.protocol & 1) {
#line 1500
    if (! sensitive_data.have_ssh1_key) {
#line 1501
      logit("Disabling protocol version 1. Could not load host key");
#line 1502
      options.protocol &= -2;
    }
  }
#line 1504
  if (options.protocol & 4) {
#line 1504
    if (! sensitive_data.have_ssh2_key) {
#line 1505
      logit("Disabling protocol version 2. Could not load host key");
#line 1506
      options.protocol &= -5;
    }
  }
#line 1508
  if (! (options.protocol & 5)) {
#line 1509
    logit("sshd: no hostkeys available -- exiting.");
#line 1510
    exit(1);
  }
#line 1514
  if (options.protocol & 1) {
#line 1515
    if (options.server_key_bits < 512) {
#line 1517
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1518
      exit(1);
    } else {
#line 1515
      if (options.server_key_bits > 32768) {
#line 1517
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad server key size.\n");
#line 1518
        exit(1);
      }
    }
#line 1525
    tmp___21 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1525
    if (options.server_key_bits > tmp___21 - 128) {
#line 1525
      tmp___22 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1525
      if (options.server_key_bits < tmp___22 + 128) {
#line 1530
        tmp___20 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1530
        options.server_key_bits = tmp___20 + 128;
#line 1533
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
      }
    }
  }
#line 1538
  if (use_privsep) {
#line 1541
    tmp___23 = stat((char const   * __restrict  )"/var/empty", (struct stat * __restrict  )(& st));
#line 1541
    if (tmp___23 == -1) {
#line 1543
      fatal("Missing privilege separation directory: %s", "/var/empty");
    } else {
#line 1541
      if (((st.st_mode & 61440U) == 16384U) == 0) {
#line 1543
        fatal("Missing privilege separation directory: %s", "/var/empty");
      }
    }
#line 1551
    if (st.st_uid != 0U) {
#line 1553
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
    } else {
#line 1551
      if ((st.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
#line 1553
        fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
    }
  }
#line 1558
  if (test_flag) {
#line 1559
    exit(0);
  }
#line 1568
  tmp___26 = setgroups(0U, (__gid_t const   *)((void *)0));
#line 1568
  if (tmp___26 < 0) {
#line 1569
    tmp___24 = __errno_location();
#line 1569
    tmp___25 = strerror(*tmp___24);
#line 1569
    debug("setgroups() failed: %.200s", tmp___25);
  }
#line 1571
  if (rexec_flag) {
#line 1572
    tmp___27 = xcalloc((unsigned int )(rexec_argc + 2), sizeof(char *));
#line 1572
    rexec_argv = (char **)tmp___27;
#line 1573
    i = 0;
#line 1573
    while (i < rexec_argc) {
#line 1574
      debug("rexec_argv[%d]=\'%s\'", i, *(saved_argv + i));
#line 1575
      *(rexec_argv + i) = *(saved_argv + i);
#line 1573
      i ++;
    }
#line 1577
    *(rexec_argv + rexec_argc) = (char *)"-R";
#line 1578
    *(rexec_argv + (rexec_argc + 1)) = (char *)((void *)0);
  }
#line 1582
  if (debug_flag) {
#line 1582
    if (! inetd_flag) {
#line 1583
      log_stderr = 1;
    } else {
#line 1582
      if (rexeced_flag) {
#line 1583
        log_stderr = 1;
      }
    }
  }
#line 1584
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1591
  if (! debug_flag) {
#line 1591
    if (! inetd_flag) {
#line 1591
      if (! no_daemon_flag) {
#line 1595
        tmp___30 = daemon(0, 0);
#line 1595
        if (tmp___30 < 0) {
#line 1596
          tmp___28 = __errno_location();
#line 1596
          tmp___29 = strerror(*tmp___28);
#line 1596
          fatal("daemon() failed: %.200s", tmp___29);
        }
#line 1600
        fd = open("/dev/tty", 258);
#line 1601
        if (fd >= 0) {
#line 1602
          ioctl(fd, 21538UL, (void *)0);
#line 1603
          close(fd);
        }
      }
    }
  }
#line 1608
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1611
  arc4random_stir();
#line 1615
  chdir("/");
#line 1618
  mysignal(13, (void (*)(int  ))1);
#line 1621
  if (inetd_flag) {
#line 1622
    server_accept_inetd(& sock_in, & sock_out);
  } else {
#line 1624
    server_listen();
#line 1626
    if (options.protocol & 1) {
#line 1627
      generate_ephemeral_server_key();
    }
#line 1629
    mysignal(1, & sighup_handler);
#line 1630
    mysignal(17, & main_sigchld_handler);
#line 1631
    mysignal(15, & sigterm_handler);
#line 1632
    mysignal(3, & sigterm_handler);
#line 1638
    if (! debug_flag) {
#line 1639
      tmp___31 = fopen((char const   * __restrict  )options.pid_file, (char const   * __restrict  )"w");
#line 1639
      f = tmp___31;
#line 1641
      if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 1642
        tmp___32 = __errno_location();
#line 1642
        tmp___33 = strerror(*tmp___32);
#line 1642
        error("Couldn\'t create pid file \"%s\": %s", options.pid_file, tmp___33);
      } else {
#line 1645
        tmp___34 = getpid();
#line 1645
        fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%ld\n", (long )tmp___34);
#line 1646
        fclose(f);
      }
    }
#line 1651
    server_accept_loop(& sock_in, & sock_out, & newsock, config_s);
  }
#line 1656
  setproctitle("%s", "[accepted]");
#line 1669
  if (! debug_flag) {
#line 1669
    if (! inetd_flag) {
#line 1669
      tmp___37 = setsid();
#line 1669
      if (tmp___37 < 0) {
#line 1670
        tmp___35 = __errno_location();
#line 1670
        tmp___36 = strerror(*tmp___35);
#line 1670
        error("setsid: %.100s", tmp___36);
      }
    }
  }
#line 1673
  if (rexec_flag) {
#line 1676
    debug("rexec start in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
#line 1678
    dup2(newsock, 0);
#line 1679
    dup2(0, 1);
#line 1680
    if (startup_pipe == -1) {
#line 1681
      close(4);
    } else {
#line 1683
      dup2(startup_pipe, 4);
    }
#line 1685
    dup2(config_s[1], 5);
#line 1686
    close(config_s[1]);
#line 1687
    if (startup_pipe != -1) {
#line 1688
      close(startup_pipe);
    }
#line 1690
    execv((char const   *)*(rexec_argv + 0), (char * const  *)rexec_argv);
#line 1693
    tmp___38 = __errno_location();
#line 1693
    tmp___39 = strerror(*tmp___38);
#line 1693
    error("rexec of %s failed: %s", *(rexec_argv + 0), tmp___39);
#line 1694
    recv_rexec_state(5, (Buffer *)((void *)0));
#line 1695
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 1699
    startup_pipe = 4;
#line 1700
    close(config_s[1]);
#line 1701
    close(5);
#line 1702
    sock_in = dup(0);
#line 1702
    sock_out = sock_in;
#line 1702
    newsock = sock_out;
#line 1703
    fd___0 = open("/dev/null", 2, 0);
#line 1703
    if (fd___0 != -1) {
#line 1704
      dup2(fd___0, 0);
#line 1705
      dup2(fd___0, 1);
#line 1706
      if (fd___0 > 2) {
#line 1707
        close(fd___0);
      }
    }
#line 1709
    debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
  }
#line 1718
  alarm(0U);
#line 1719
  mysignal(14, (void (*)(int  ))0);
#line 1720
  mysignal(1, (void (*)(int  ))0);
#line 1721
  mysignal(15, (void (*)(int  ))0);
#line 1722
  mysignal(3, (void (*)(int  ))0);
#line 1723
  mysignal(17, (void (*)(int  ))0);
#line 1724
  mysignal(2, (void (*)(int  ))0);
#line 1730
  packet_set_connection(sock_in, sock_out);
#line 1731
  packet_set_server();
#line 1734
  if (options.tcp_keep_alive) {
#line 1734
    tmp___42 = packet_connection_is_on_socket();
#line 1734
    if (tmp___42) {
#line 1734
      tmp___43 = setsockopt(sock_in, 1, 9, (void const   *)(& on), sizeof(on));
#line 1734
      if (tmp___43 < 0) {
#line 1736
        tmp___40 = __errno_location();
#line 1736
        tmp___41 = strerror(*tmp___40);
#line 1736
        error("setsockopt SO_KEEPALIVE: %.100s", tmp___41);
      }
    }
  }
#line 1738
  remote_port = get_remote_port();
#line 1738
  if (remote_port < 0) {
#line 1739
    debug("get_remote_port failed");
#line 1740
    cleanup_exit(255);
  }
#line 1747
  get_canonical_hostname(0);
#line 1753
  remote_ip___0 = get_remote_ipaddr();
#line 1778
  verbose("Connection from %.500s port %d", remote_ip___0, remote_port);
#line 1788
  mysignal(14, & grace_alarm_handler);
#line 1789
  if (! debug_flag) {
#line 1790
    alarm((unsigned int )options.login_grace_time);
  }
#line 1792
  sshd_exchange_identification(sock_in, sock_out);
#line 1795
  if (! compat20) {
#line 1795
    if (inetd_flag) {
#line 1795
      if ((unsigned int )sensitive_data.server_key == (unsigned int )((void *)0)) {
#line 1796
        generate_ephemeral_server_key();
      }
    }
  }
#line 1798
  packet_set_nonblocking();
#line 1801
  tmp___44 = xcalloc(1U, sizeof(*authctxt___0));
#line 1801
  authctxt___0 = (Authctxt *)tmp___44;
#line 1803
  authctxt___0->loginmsg = & loginmsg;
#line 1806
  the_authctxt = authctxt___0;
#line 1809
  buffer_init(& loginmsg);
#line 1811
  if (use_privsep) {
#line 1812
    tmp___45 = privsep_preauth(authctxt___0);
#line 1812
    if (tmp___45 == 1) {
      goto authenticated;
    }
  }
#line 1817
  if (compat20) {
#line 1818
    do_ssh2_kex();
#line 1819
    do_authentication2(authctxt___0);
  } else {
#line 1821
    do_ssh1_kex();
#line 1822
    do_authentication(authctxt___0);
  }
#line 1828
  if (use_privsep) {
#line 1829
    mm_send_keystate(pmonitor);
#line 1830
    exit(0);
  }
  authenticated: 
#line 1838
  alarm(0U);
#line 1839
  mysignal(14, (void (*)(int  ))0);
#line 1840
  authctxt___0->authenticated = 1;
#line 1841
  if (startup_pipe != -1) {
#line 1842
    close(startup_pipe);
#line 1843
    startup_pipe = -1;
  }
#line 1868
  if (use_privsep) {
#line 1869
    privsep_postauth(authctxt___0);
#line 1871
    if (! compat20) {
#line 1872
      destroy_sensitive_data();
    }
  }
#line 1876
  do_authenticated(authctxt___0);
#line 1879
  verbose("Closing connection to %.100s", remote_ip___0);
#line 1890
  packet_close();
#line 1892
  if (use_privsep) {
#line 1893
    mm_terminate();
  }
#line 1895
  exit(0);
}
}
#line 1902 "sshd.c"
int ssh1_session_key(BIGNUM *session_key_int ) 
{ int rsafail ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1905
  rsafail = 0;
#line 1907
  tmp___13 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1907
  if (tmp___13 > 0) {
#line 1910
    tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1910
    tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1910
    if (tmp___2 < tmp___3 + 128) {
#line 1913
      tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1913
      tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1913
      tmp___1 = get_remote_ipaddr();
#line 1913
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___1, tmp___0, tmp, 128);
    }
#line 1920
    tmp___4 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1920
    if (tmp___4 <= 0) {
#line 1922
      rsafail ++;
    }
#line 1923
    tmp___5 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1923
    if (tmp___5 <= 0) {
#line 1925
      rsafail ++;
    }
  } else {
#line 1928
    tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1928
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1928
    if (tmp___9 < tmp___10 + 128) {
#line 1931
      tmp___6 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1931
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1931
      tmp___8 = get_remote_ipaddr();
#line 1931
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___8, tmp___7, tmp___6, 128);
    }
#line 1938
    tmp___11 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
#line 1938
    if (tmp___11 < 0) {
#line 1940
      rsafail ++;
    }
#line 1941
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
#line 1941
    if (tmp___12 < 0) {
#line 1943
      rsafail ++;
    }
  }
#line 1945
  return (rsafail);
}
}
#line 1950 "sshd.c"
static void do_ssh1_kex(void) 
{ int i ;
  int len ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rnd ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _len ;
  int tmp___7 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int bytes ;
  int tmp___12 ;
  u_char *buf___1 ;
  void *tmp___13 ;
  MD5_CTX md ;

  {
#line 1954
  rsafail = 0;
#line 1959
  rnd = (u_int32_t )0;
#line 1970
  i = 0;
#line 1970
  while (i < 8) {
#line 1971
    if (i % 4 == 0) {
#line 1972
      rnd = arc4random();
    }
#line 1973
    cookie[i] = (unsigned char )(rnd & 255U);
#line 1974
    rnd >>= 8;
#line 1970
    i ++;
  }
#line 1982
  packet_start((unsigned char)2);
#line 1983
  i = 0;
#line 1983
  while (i < 8) {
#line 1984
    packet_put_char((int )cookie[i]);
#line 1983
    i ++;
  }
#line 1987
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 1987
  packet_put_int((unsigned int )tmp);
#line 1988
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
#line 1989
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
#line 1992
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1992
  packet_put_int((unsigned int )tmp___0);
#line 1993
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
#line 1994
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
#line 1997
  packet_put_int(2U);
#line 2000
  tmp___1 = cipher_mask_ssh1(0);
#line 2000
  packet_put_int(tmp___1);
#line 2003
  auth_mask = 0U;
#line 2004
  if (options.rhosts_rsa_authentication) {
#line 2005
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 2006
  if (options.rsa_authentication) {
#line 2007
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 2008
  if (options.challenge_response_authentication == 1) {
#line 2009
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 2010
  if (options.password_authentication) {
#line 2011
    auth_mask |= (unsigned int )(1 << 3);
  }
#line 2012
  packet_put_int(auth_mask);
#line 2015
  packet_send();
#line 2016
  packet_write_wait();
#line 2018
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
#line 2018
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
#line 2018
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
#line 2023
  packet_read_expect(3);
#line 2026
  cipher_type = packet_get_char();
#line 2028
  tmp___4 = cipher_mask_ssh1(0);
#line 2028
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
#line 2029
    packet_disconnect("Warning: client selects unsupported cipher.");
  }
#line 2033
  i = 0;
#line 2033
  while (i < 8) {
#line 2034
    tmp___5 = packet_get_char();
#line 2034
    if ((u_int )cookie[i] != tmp___5) {
#line 2035
      packet_disconnect("IP Spoofing check bytes do not match.");
    }
#line 2033
    i ++;
  }
#line 2037
  tmp___6 = cipher_name((int )cipher_type);
#line 2037
  debug("Encryption type: %.200s", tmp___6);
#line 2040
  session_key_int = BN_new();
#line 2040
  if ((unsigned int )session_key_int == (unsigned int )((void *)0)) {
#line 2041
    fatal("do_ssh1_kex: BN_new failed");
  }
#line 2042
  packet_get_bignum(session_key_int);
#line 2044
  protocol_flags = packet_get_int();
#line 2045
  packet_set_protocol_flags(protocol_flags);
#line 2046
  while (1) {
#line 2046
    tmp___7 = packet_remaining();
#line 2046
    _len = tmp___7;
#line 2046
    if (_len > 0) {
#line 2046
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "sshd.c",
            2046);
#line 2046
      packet_disconnect("Packet integrity error.");
    }
#line 2046
    break;
  }
#line 2049
  if (use_privsep) {
#line 2049
    rsafail = mm_ssh1_session_key(session_key_int);
  } else {
#line 2049
    rsafail = ssh1_session_key(session_key_int);
  }
#line 2056
  if (! rsafail) {
#line 2057
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8U));
#line 2058
    tmp___10 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 2058
    len = (tmp___10 + 7) / 8;
#line 2059
    if (len < 0) {
#line 2060
      tmp___11 = get_remote_ipaddr();
#line 2060
      error("do_ssh1_kex: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, (unsigned long )sizeof(session_key));
#line 2063
      rsafail ++;
    } else {
#line 2059
      if ((unsigned int )len > sizeof(session_key)) {
#line 2060
        tmp___11 = get_remote_ipaddr();
#line 2060
        error("do_ssh1_kex: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
              tmp___11, len, (unsigned long )sizeof(session_key));
#line 2063
        rsafail ++;
      } else {
#line 2065
        memset((void *)(session_key), 0, sizeof(session_key));
#line 2066
        BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
#line 2069
        derive_ssh1_session_id(((sensitive_data.ssh1_host_key)->rsa)->n, ((sensitive_data.server_key)->rsa)->n,
                               (u_int8_t *)(cookie), (u_int8_t *)(session_id));
#line 2077
        i = 0;
#line 2077
        while (i < 16) {
#line 2078
          session_key[i] = (unsigned char )((int )session_key[i] ^ (int )session_id[i]);
#line 2077
          i ++;
        }
      }
    }
  }
#line 2081
  if (rsafail) {
#line 2082
    tmp___12 = BN_num_bits((BIGNUM const   *)session_key_int);
#line 2082
    bytes = (tmp___12 + 7) / 8;
#line 2083
    tmp___13 = xmalloc((unsigned int )bytes);
#line 2083
    buf___1 = (u_char *)tmp___13;
#line 2086
    logit("do_connection: generating a fake encryption key");
#line 2087
    BN_bn2bin((BIGNUM const   *)session_key_int, buf___1);
#line 2088
    MD5_Init(& md);
#line 2089
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 2090
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 2091
    MD5_Final(session_key, & md);
#line 2092
    MD5_Init(& md);
#line 2093
    MD5_Update(& md, (void const   *)(session_key), 16U);
#line 2094
    MD5_Update(& md, (void const   *)buf___1, (unsigned int )bytes);
#line 2095
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), 32U);
#line 2096
    MD5_Final(session_key + 16, & md);
#line 2097
    memset((void *)buf___1, 0, (unsigned int )bytes);
#line 2098
    xfree((void *)buf___1);
#line 2099
    i = 0;
#line 2099
    while (i < 16) {
#line 2100
      session_id[i] = (unsigned char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 2099
      i ++;
    }
  }
#line 2103
  destroy_sensitive_data();
#line 2105
  if (use_privsep) {
#line 2106
    mm_ssh1_session_id(session_id);
  }
#line 2109
  BN_clear_free(session_key_int);
#line 2112
  packet_set_encryption_key((u_char const   *)(session_key), 32U, (int )cipher_type);
#line 2115
  memset((void *)(session_key), 0, sizeof(session_key));
#line 2117
  debug("Received session key; encryption turned on.");
#line 2120
  packet_start((unsigned char)14);
#line 2121
  packet_send();
#line 2122
  packet_write_wait();
#line 2123
  return;
}
}
#line 2128 "sshd.c"
static void do_ssh2_kex(void) 
{ Kex *kex ;

  {
#line 2133
  if ((unsigned int )options.ciphers != (unsigned int )((void *)0)) {
#line 2134
    myproposal[3] = options.ciphers;
#line 2134
    myproposal[2] = myproposal[3];
  }
#line 2137
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
#line 2139
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
#line 2142
  if ((unsigned int )options.macs != (unsigned int )((void *)0)) {
#line 2143
    myproposal[5] = options.macs;
#line 2143
    myproposal[4] = myproposal[5];
  }
#line 2146
  if (options.compression == 0) {
#line 2147
    myproposal[7] = (char *)"none";
#line 2147
    myproposal[6] = myproposal[7];
  } else {
#line 2149
    if (options.compression == 2) {
#line 2150
      myproposal[7] = (char *)"none,zlib@openssh.com";
#line 2150
      myproposal[6] = myproposal[7];
    }
  }
#line 2154
  myproposal[1] = list_hostkey_types();
#line 2157
  kex = kex_setup((char **)(myproposal));
#line 2158
  kex->kex[0] = & kexdh_server;
#line 2159
  kex->kex[1] = & kexdh_server;
#line 2160
  kex->kex[2] = & kexgex_server;
#line 2161
  kex->kex[3] = & kexgex_server;
#line 2162
  kex->server = 1;
#line 2163
  kex->client_version_string = client_version_string;
#line 2164
  kex->server_version_string = server_version_string;
#line 2165
  kex->load_host_key = & get_hostkey_by_type;
#line 2166
  kex->host_key_index = & get_hostkey_index;
#line 2168
  xxx_kex = kex;
#line 2170
  dispatch_run(0, (sig_atomic_t volatile   *)(& kex->done), (void *)kex);
#line 2172
  session_id2 = kex->session_id;
#line 2173
  session_id2_len = kex->session_id_len;
#line 2182
  debug("KEX done");
#line 2183
  return;
}
}
#line 1 "auth-rhosts.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 105 "auth.h"
int auth_rhosts(struct passwd *pw___0 , char const   *client_user___0 ) ;
#line 106
int auth_rhosts2(struct passwd *pw___0 , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 183
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) ;
#line 184
void auth_debug_send(void) ;
#line 185
void auth_debug_reset(void) ;
#line 51 "auth-rhosts.c"
static int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                             char const   *client_user___0 , char const   *server_user ) 
{ FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
#line 60
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 61
  if (! f) {
#line 62
    return (0);
  }
#line 64
  while (1) {
#line 64
    tmp___50 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 64
    if (! tmp___50) {
#line 64
      break;
    }
#line 69
    cp = buf___1;
#line 69
    while (1) {
#line 69
      if (! ((int )*cp == 32)) {
#line 69
        if (! ((int )*cp == 9)) {
#line 69
          break;
        }
      }
#line 69
      cp ++;
    }
#line 71
    if ((int )*cp == 35) {
#line 72
      continue;
    } else {
#line 71
      if ((int )*cp == 10) {
#line 72
        continue;
      } else {
#line 71
        if (! *cp) {
#line 72
          continue;
        }
      }
    }
#line 78
    if (0) {
#line 78
      if (0) {
#line 78
        __s1_len___0 = strlen((char const   *)cp);
#line 78
        __s2_len___0 = strlen("NO_PLUS");
#line 78
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 78
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 78
            if (! ((unsigned int )((void const   *)("NO_PLUS" + 1)) - (unsigned int )((void const   *)"NO_PLUS") == 1U)) {
#line 78
              tmp___22 = 1;
            } else {
#line 78
              if (__s2_len___0 >= 4U) {
#line 78
                tmp___22 = 1;
              } else {
#line 78
                tmp___22 = 0;
              }
            }
          } else {
#line 78
            tmp___22 = 0;
          }
        }
#line 78
        if (tmp___22) {
#line 78
          tmp___18 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
        } else {
#line 78
          tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 78
          tmp___18 = tmp___21;
        }
      } else {
#line 78
        tmp___21 = __builtin_strcmp((char const   *)cp, "NO_PLUS");
#line 78
        tmp___18 = tmp___21;
      }
#line 78
      tmp___12 = tmp___18;
    } else {
#line 78
      tmp___12 = strncmp((char const   *)cp, "NO_PLUS", 7U);
    }
#line 78
    if (tmp___12 == 0) {
#line 79
      continue;
    }
#line 85
    tmp___25 = sscanf((char const   * __restrict  )(buf___1), (char const   * __restrict  )"%1023s %1023s %1023s",
                      hostbuf, userbuf, dummy);
#line 85
    switch (tmp___25) {
    case 0: 
#line 88
    auth_debug_add("Found empty line in %.100s.", filename);
#line 89
    continue;
    case 1: 
#line 92
    strlcpy(userbuf, server_user, sizeof(userbuf));
#line 93
    break;
    case 2: 
#line 96
    break;
    case 3: 
#line 98
    auth_debug_add("Found garbage in %.100s.", filename);
#line 99
    continue;
    default: ;
#line 102
    continue;
    }
#line 105
    host = hostbuf;
#line 106
    user = userbuf;
#line 107
    negated = 0;
#line 110
    if ((int )*(host + 0) == 45) {
#line 111
      negated = 1;
#line 112
      host ++;
    } else {
#line 113
      if ((int )*(host + 0) == 43) {
#line 114
        host ++;
      }
    }
#line 116
    if ((int )*(user + 0) == 45) {
#line 117
      negated = 1;
#line 118
      user ++;
    } else {
#line 119
      if ((int )*(user + 0) == 43) {
#line 120
        user ++;
      }
    }
#line 123
    if (! *(host + 0)) {
#line 125
      auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 127
      continue;
    } else {
#line 123
      if (! *(user + 0)) {
#line 125
        auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
#line 127
        continue;
      }
    }
#line 130
    if ((int )*(host + 0) == 64) {
#line 131
      tmp___26 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                         (char const   *)((void *)0));
#line 131
      if (! tmp___26) {
#line 131
        tmp___27 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                           (char const   *)((void *)0));
#line 131
        if (! tmp___27) {
#line 133
          continue;
        }
      }
    } else {
#line 134
      tmp___28 = strcasecmp((char const   *)host, hostname);
#line 134
      if (tmp___28) {
#line 134
        if (0) {
#line 134
          __s1_len___1 = strlen((char const   *)host);
#line 134
          __s2_len___1 = strlen(ipaddr);
#line 134
          if (! ((unsigned int )((void const   *)(host + 1)) - (unsigned int )((void const   *)host) == 1U)) {
            goto _L___4;
          } else {
#line 134
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
#line 134
              if (! ((unsigned int )((void const   *)(ipaddr + 1)) - (unsigned int )((void const   *)ipaddr) == 1U)) {
#line 134
                tmp___38 = 1;
              } else {
#line 134
                if (__s2_len___1 >= 4U) {
#line 134
                  tmp___38 = 1;
                } else {
#line 134
                  tmp___38 = 0;
                }
              }
            } else {
#line 134
              tmp___38 = 0;
            }
          }
#line 134
          if (tmp___38) {
#line 134
            tmp___34 = __builtin_strcmp((char const   *)host, ipaddr);
          } else {
#line 134
            tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 134
            tmp___34 = tmp___37;
          }
        } else {
#line 134
          tmp___37 = __builtin_strcmp((char const   *)host, ipaddr);
#line 134
          tmp___34 = tmp___37;
        }
#line 134
        if (tmp___34 != 0) {
#line 135
          continue;
        }
      }
    }
#line 138
    if ((int )*(user + 0) == 64) {
#line 139
      tmp___39 = innetgr((char const   *)(user + 1), (char const   *)((void *)0),
                         client_user___0, (char const   *)((void *)0));
#line 139
      if (! tmp___39) {
#line 140
        continue;
      }
    } else {
#line 141
      if (0) {
#line 141
        __s1_len___2 = strlen((char const   *)user);
#line 141
        __s2_len___2 = strlen(client_user___0);
#line 141
        if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
          goto _L___6;
        } else {
#line 141
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
#line 141
            if (! ((unsigned int )((void const   *)(client_user___0 + 1)) - (unsigned int )((void const   *)client_user___0) == 1U)) {
#line 141
              tmp___49 = 1;
            } else {
#line 141
              if (__s2_len___2 >= 4U) {
#line 141
                tmp___49 = 1;
              } else {
#line 141
                tmp___49 = 0;
              }
            }
          } else {
#line 141
            tmp___49 = 0;
          }
        }
#line 141
        if (tmp___49) {
#line 141
          tmp___45 = __builtin_strcmp((char const   *)user, client_user___0);
        } else {
#line 141
          tmp___48 = __builtin_strcmp((char const   *)user, client_user___0);
#line 141
          tmp___45 = tmp___48;
        }
      } else {
#line 141
        tmp___48 = __builtin_strcmp((char const   *)user, client_user___0);
#line 141
        tmp___45 = tmp___48;
      }
#line 141
      if (tmp___45 != 0) {
#line 142
        continue;
      }
    }
#line 145
    fclose(f);
#line 148
    if (negated) {
#line 149
      auth_debug_add("Matched negative entry in %.100s.", filename);
#line 151
      return (0);
    }
#line 154
    return (1);
  }
#line 158
  fclose(f);
#line 159
  return (0);
}
}
#line 168 "auth-rhosts.c"
int auth_rhosts(struct passwd *pw___0 , char const   *client_user___0 ) 
{ char const   *hostname ;
  char const   *ipaddr ;
  int tmp ;

  {
#line 173
  hostname = get_canonical_hostname(options.use_dns);
#line 174
  ipaddr = get_remote_ipaddr();
#line 175
  tmp = auth_rhosts2(pw___0, client_user___0, hostname, ipaddr);
#line 175
  return (tmp);
}
}
#line 184
static int auth_rhosts2_raw(struct passwd *pw___0 , char const   *client_user___0 ,
                            char const   *hostname , char const   *ipaddr ) ;
#line 184 "auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 178 "auth-rhosts.c"
static int auth_rhosts2_raw(struct passwd *pw___0 , char const   *client_user___0 ,
                            char const   *hostname , char const   *ipaddr ) 
{ char buf___1[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 187
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user___0, hostname,
         ipaddr);
#line 191
  temporarily_use_uid(pw___0);
#line 197
  rhosts_file_index = 0U;
#line 197
  while (rhosts_files[rhosts_file_index]) {
#line 200
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw___0->pw_dir, rhosts_files[rhosts_file_index]);
#line 202
    tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 202
    if (tmp >= 0) {
#line 203
      break;
    }
#line 197
    rhosts_file_index ++;
  }
#line 206
  restore_uid();
#line 209
  if (! rhosts_files[rhosts_file_index]) {
#line 209
    tmp___0 = stat((char const   * __restrict  )"/etc/hosts.equiv", (struct stat * __restrict  )(& st));
#line 209
    if (tmp___0 < 0) {
#line 209
      tmp___1 = stat((char const   * __restrict  )"/usr/local/etc/shosts.equiv", (struct stat * __restrict  )(& st));
#line 209
      if (tmp___1 < 0) {
#line 212
        return (0);
      }
    }
  }
#line 215
  if (pw___0->pw_uid != 0U) {
#line 216
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw___0->pw_name);
#line 216
    if (tmp___2) {
#line 218
      auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                     ipaddr);
#line 220
      return (1);
    }
#line 222
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw___0->pw_name);
#line 222
    if (tmp___3) {
#line 224
      auth_debug_add("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                     "/usr/local/etc/shosts.equiv");
#line 226
      return (1);
    }
  }
#line 233
  tmp___4 = stat((char const   * __restrict  )pw___0->pw_dir, (struct stat * __restrict  )(& st));
#line 233
  if (tmp___4 < 0) {
#line 234
    logit("Rhosts authentication refused for %.100s: no home directory %.200s", pw___0->pw_name,
          pw___0->pw_dir);
#line 236
    auth_debug_add("Rhosts authentication refused for %.100s: no home directory %.200s",
                   pw___0->pw_name, pw___0->pw_dir);
#line 238
    return (0);
  }
#line 240
  if (options.strict_modes) {
#line 240
    if (st.st_uid != 0U) {
#line 240
      if (st.st_uid != pw___0->pw_uid) {
#line 243
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw___0->pw_name);
#line 245
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw___0->pw_name);
#line 247
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 240
      if ((st.st_mode & 18U) != 0U) {
#line 243
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw___0->pw_name);
#line 245
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw___0->pw_name);
#line 247
        return (0);
      }
    }
  }
#line 250
  temporarily_use_uid(pw___0);
#line 253
  rhosts_file_index = 0U;
#line 253
  while (rhosts_files[rhosts_file_index]) {
#line 256
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.500s/%.100s",
             pw___0->pw_dir, rhosts_files[rhosts_file_index]);
#line 258
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 258
    if (tmp___5 < 0) {
      goto __Cont;
    }
#line 267
    if (options.strict_modes) {
#line 267
      if (st.st_uid != 0U) {
#line 267
        if (st.st_uid != pw___0->pw_uid) {
#line 270
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw___0->pw_name, buf___1);
#line 272
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 267
        if ((st.st_mode & 18U) != 0U) {
#line 270
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw___0->pw_name, buf___1);
#line 272
          auth_debug_add("Bad file modes for %.200s", buf___1);
          goto __Cont;
        }
      }
    }
#line 276
    if (options.ignore_rhosts) {
#line 277
      auth_debug_add("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      goto __Cont;
    }
#line 282
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user___0,
                                (char const   *)pw___0->pw_name);
#line 282
    if (tmp___6) {
#line 283
      auth_debug_add("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
#line 286
      restore_uid();
#line 287
      auth_debug_add("Accepted host %s ip %s client_user %s server_user %s", hostname,
                     ipaddr, client_user___0, pw___0->pw_name);
#line 289
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 253
    rhosts_file_index ++;
  }
#line 294
  restore_uid();
#line 295
  return (0);
}
}
#line 298 "auth-rhosts.c"
int auth_rhosts2(struct passwd *pw___0 , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) 
{ int ret___0 ;

  {
#line 304
  auth_debug_reset();
#line 305
  ret___0 = auth_rhosts2_raw(pw___0, client_user___0, hostname, ipaddr);
#line 306
  if (! use_privsep) {
#line 307
    auth_debug_send();
  }
#line 308
  return (ret___0);
}
}
#line 1 "auth-passwd.o"
#line 110 "auth.h"
int auth_password(Authctxt *authctxt___0 , char const   *password ) ;
#line 131
int auth_shadow_pwexpired(Authctxt *ctxt ) ;
#line 138
void disable_forwarding(void) ;
#line 189
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) ;
#line 25 "auth-options.h"
int no_port_forwarding_flag ;
#line 26
int no_agent_forwarding_flag ;
#line 27
int no_x11_forwarding_flag ;
#line 68 "auth-passwd.c"
void disable_forwarding(void) 
{ 

  {
#line 71
  no_port_forwarding_flag = 1;
#line 72
  no_agent_forwarding_flag = 1;
#line 73
  no_x11_forwarding_flag = 1;
#line 74
  return;
}
}
#line 86 "auth-passwd.c"
static int expire_checked  =    0;
#line 80 "auth-passwd.c"
int auth_password(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw___0 ;
  int result ;
  int ok ;
  int tmp ;
  int tmp___0 ;

  {
#line 83
  pw___0 = authctxt___0->pw;
#line 84
  ok = authctxt___0->valid;
#line 90
  if (pw___0->pw_uid == 0U) {
#line 90
    if (options.permit_root_login != 3) {
#line 91
      ok = 0;
    }
  }
#line 93
  if ((int const   )*password == 0) {
#line 93
    if (options.permit_empty_passwd == 0) {
#line 94
      return (0);
    }
  }
#line 119
  if (! expire_checked) {
#line 120
    expire_checked = 1;
#line 121
    tmp = auth_shadow_pwexpired(authctxt___0);
#line 121
    if (tmp) {
#line 122
      authctxt___0->force_pwchange = 1;
    }
  }
#line 125
  result = sys_auth_passwd(authctxt___0, password);
#line 126
  if (authctxt___0->force_pwchange) {
#line 127
    disable_forwarding();
  }
#line 128
  if (result) {
#line 128
    if (ok) {
#line 128
      tmp___0 = 1;
    } else {
#line 128
      tmp___0 = 0;
    }
  } else {
#line 128
    tmp___0 = 0;
  }
#line 128
  return (tmp___0);
}
}
#line 191 "auth-passwd.c"
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) 
{ struct passwd *pw___0 ;
  char *encrypted_password ;
  char *pw_password ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 194
  pw___0 = authctxt___0->pw;
#line 198
  if (authctxt___0->valid) {
#line 198
    tmp___0 = shadow_pw(pw___0);
  } else {
#line 198
    tmp___0 = pw___0->pw_passwd;
  }
#line 198
  pw_password = tmp___0;
#line 201
  if (0) {
#line 201
    __s1_len = strlen((char const   *)pw_password);
#line 201
    __s2_len = strlen("");
#line 201
    if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
      goto _L___0;
    } else {
#line 201
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 201
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 201
          tmp___10 = 1;
        } else {
#line 201
          if (__s2_len >= 4U) {
#line 201
            tmp___10 = 1;
          } else {
#line 201
            tmp___10 = 0;
          }
        }
      } else {
#line 201
        tmp___10 = 0;
      }
    }
#line 201
    if (tmp___10) {
#line 201
      tmp___6 = __builtin_strcmp((char const   *)pw_password, "");
    } else {
#line 201
      tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 201
      tmp___6 = tmp___9;
    }
  } else {
#line 201
    tmp___9 = __builtin_strcmp((char const   *)pw_password, "");
#line 201
    tmp___6 = tmp___9;
  }
#line 201
  if (tmp___6 == 0) {
#line 201
    if (0) {
#line 201
      __s1_len___0 = strlen(password);
#line 201
      __s2_len___0 = strlen("");
#line 201
      if (! ((unsigned int )((void const   *)(password + 1)) - (unsigned int )((void const   *)password) == 1U)) {
        goto _L___2;
      } else {
#line 201
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 201
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 201
            tmp___20 = 1;
          } else {
#line 201
            if (__s2_len___0 >= 4U) {
#line 201
              tmp___20 = 1;
            } else {
#line 201
              tmp___20 = 0;
            }
          }
        } else {
#line 201
          tmp___20 = 0;
        }
      }
#line 201
      if (tmp___20) {
#line 201
        tmp___16 = __builtin_strcmp(password, "");
      } else {
#line 201
        tmp___19 = __builtin_strcmp(password, "");
#line 201
        tmp___16 = tmp___19;
      }
    } else {
#line 201
      tmp___19 = __builtin_strcmp(password, "");
#line 201
      tmp___16 = tmp___19;
    }
#line 201
    if (tmp___16 == 0) {
#line 202
      return (1);
    }
  }
#line 205
  if (*(pw_password + 0)) {
#line 205
    if (*(pw_password + 1)) {
#line 205
      tmp___21 = (char const   *)pw_password;
    } else {
#line 205
      tmp___21 = "xx";
    }
  } else {
#line 205
    tmp___21 = "xx";
  }
#line 205
  encrypted_password = xcrypt(password, tmp___21);
#line 212
  if (0) {
#line 212
    __s1_len___1 = strlen((char const   *)encrypted_password);
#line 212
    __s2_len___1 = strlen((char const   *)pw_password);
#line 212
    if (! ((unsigned int )((void const   *)(encrypted_password + 1)) - (unsigned int )((void const   *)encrypted_password) == 1U)) {
      goto _L___4;
    } else {
#line 212
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 212
        if (! ((unsigned int )((void const   *)(pw_password + 1)) - (unsigned int )((void const   *)pw_password) == 1U)) {
#line 212
          tmp___31 = 1;
        } else {
#line 212
          if (__s2_len___1 >= 4U) {
#line 212
            tmp___31 = 1;
          } else {
#line 212
            tmp___31 = 0;
          }
        }
      } else {
#line 212
        tmp___31 = 0;
      }
    }
#line 212
    if (tmp___31) {
#line 212
      tmp___27 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
    } else {
#line 212
      tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 212
      tmp___27 = tmp___30;
    }
  } else {
#line 212
    tmp___30 = __builtin_strcmp((char const   *)encrypted_password, (char const   *)pw_password);
#line 212
    tmp___27 = tmp___30;
  }
#line 212
  return (tmp___27 == 0);
}
}
#line 1 "auth-rsa.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 34 "auth-options.h"
int auth_parse_options(struct passwd *pw___0 , char *opts , char *file___0 , u_long linenum ) ;
#line 35
void auth_clear_options(void) ;
#line 111 "auth.h"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) ;
#line 112
int auth_rsa_challenge_dialog(Key *key ) ;
#line 113
BIGNUM *auth_rsa_generate_challenge(Key *key ) ;
#line 114
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) ;
#line 115
int auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) ;
#line 166
char *authorized_keys_file(struct passwd *pw___0 ) ;
#line 169
int secure_filename(FILE *f , char const   *file___0 , struct passwd *pw___0 , char *err ,
                    size_t errlen ) ;
#line 52 "monitor_wrap.h"
int mm_auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) ;
#line 53
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) ;
#line 54
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) ;
#line 70 "auth-rsa.c"
BIGNUM *auth_rsa_generate_challenge(Key *key ) 
{ BIGNUM *challenge ;
  BN_CTX *ctx ;
  int tmp ;
  int tmp___0 ;

  {
#line 76
  challenge = BN_new();
#line 76
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 77
    fatal("auth_rsa_generate_challenge: BN_new() failed");
  }
#line 79
  tmp = BN_rand(challenge, 256, 0, 0);
#line 79
  if (tmp == 0) {
#line 80
    fatal("auth_rsa_generate_challenge: BN_rand failed");
  }
#line 81
  ctx = BN_CTX_new();
#line 81
  if ((unsigned int )ctx == (unsigned int )((void *)0)) {
#line 82
    fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
  }
#line 83
  tmp___0 = BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge,
                   (BIGNUM const   *)(key->rsa)->n, ctx);
#line 83
  if (tmp___0 == 0) {
#line 84
    fatal("auth_rsa_generate_challenge: BN_mod failed");
  }
#line 85
  BN_CTX_free(ctx);
#line 87
  return (challenge);
}
}
#line 90 "auth-rsa.c"
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) 
{ u_char buf___1[32] ;
  u_char mdbuf[16] ;
  MD5_CTX md ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 98
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 98
  if (tmp___0 < 768) {
#line 99
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 99
    error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
          tmp, 768);
#line 101
    return (0);
  }
#line 105
  tmp___1 = BN_num_bits((BIGNUM const   *)challenge);
#line 105
  len = (tmp___1 + 7) / 8;
#line 106
  if (len <= 0) {
#line 107
    fatal("auth_rsa_verify_response: bad challenge length %d", len);
  } else {
#line 106
    if (len > 32) {
#line 107
      fatal("auth_rsa_verify_response: bad challenge length %d", len);
    }
  }
#line 108
  memset((void *)(buf___1), 0, 32U);
#line 109
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
#line 110
  MD5_Init(& md);
#line 111
  MD5_Update(& md, (void const   *)(buf___1), 32U);
#line 112
  MD5_Update(& md, (void const   *)(session_id), 16U);
#line 113
  MD5_Final(mdbuf, & md);
#line 116
  tmp___2 = memcmp((void const   *)response, (void const   *)(mdbuf), 16U);
#line 116
  if (tmp___2 != 0) {
#line 118
    return (0);
  }
#line 121
  return (1);
}
}
#line 130 "auth-rsa.c"
int auth_rsa_challenge_dialog(Key *key ) 
{ BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  u_char response[16] ;
  int i ;
  int success ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 137
  encrypted_challenge = BN_new();
#line 137
  if ((unsigned int )encrypted_challenge == (unsigned int )((void *)0)) {
#line 138
    fatal("auth_rsa_challenge_dialog: BN_new() failed");
  }
#line 140
  if (use_privsep) {
#line 140
    challenge = mm_auth_rsa_generate_challenge(key);
  } else {
#line 140
    challenge = auth_rsa_generate_challenge(key);
  }
#line 143
  rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
#line 146
  packet_start((unsigned char)7);
#line 147
  packet_put_bignum(encrypted_challenge);
#line 148
  packet_send();
#line 149
  BN_clear_free(encrypted_challenge);
#line 150
  packet_write_wait();
#line 153
  packet_read_expect(8);
#line 154
  i = 0;
#line 154
  while (i < 16) {
#line 155
    tmp___1 = packet_get_char();
#line 155
    response[i] = (unsigned char )tmp___1;
#line 154
    i ++;
  }
#line 156
  while (1) {
#line 156
    tmp___2 = packet_remaining();
#line 156
    _len = tmp___2;
#line 156
    if (_len > 0) {
#line 156
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth-rsa.c",
            156);
#line 156
      packet_disconnect("Packet integrity error.");
    }
#line 156
    break;
  }
#line 158
  if (use_privsep) {
#line 158
    success = mm_auth_rsa_verify_response(key, challenge, response);
  } else {
#line 158
    success = auth_rsa_verify_response(key, challenge, (u_char *)(response));
  }
#line 159
  BN_clear_free(challenge);
#line 160
  return (success);
}
}
#line 168 "auth-rsa.c"
int auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) 
{ char line[8192] ;
  char *file___0 ;
  int allowed ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *key_options ;
  int keybits ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 172
  allowed = 0;
#line 175
  linenum = (u_long )0;
#line 180
  temporarily_use_uid(pw___0);
#line 183
  file___0 = authorized_keys_file(pw___0);
#line 184
  debug("trying public RSA key file %s", file___0);
#line 187
  tmp = stat((char const   * __restrict  )file___0, (struct stat * __restrict  )(& st));
#line 187
  if (tmp < 0) {
#line 189
    restore_uid();
#line 190
    xfree((void *)file___0);
#line 191
    return (0);
  }
#line 194
  f = fopen((char const   * __restrict  )file___0, (char const   * __restrict  )"r");
#line 195
  if (! f) {
#line 197
    restore_uid();
#line 198
    xfree((void *)file___0);
#line 199
    return (0);
  }
#line 201
  if (options.strict_modes) {
#line 201
    tmp___0 = secure_filename(f, (char const   *)file___0, pw___0, line, sizeof(line));
#line 201
    if (tmp___0 != 0) {
#line 203
      xfree((void *)file___0);
#line 204
      fclose(f);
#line 205
      logit("Authentication refused: %s", line);
#line 206
      restore_uid();
#line 207
      return (0);
    }
  }
#line 211
  allowed = 0;
#line 213
  key = key_new(0);
#line 220
  while (1) {
#line 220
    tmp___5 = read_keyfile_line(f, (char const   *)file___0, line, sizeof(line), & linenum);
#line 220
    if (! (tmp___5 != -1)) {
#line 220
      break;
    }
#line 226
    cp = line;
#line 226
    while (1) {
#line 226
      if (! ((int )*cp == 32)) {
#line 226
        if (! ((int )*cp == 9)) {
#line 226
          break;
        }
      }
#line 226
      cp ++;
    }
#line 228
    if (! *cp) {
#line 229
      continue;
    } else {
#line 228
      if ((int )*cp == 10) {
#line 229
        continue;
      } else {
#line 228
        if ((int )*cp == 35) {
#line 229
          continue;
        }
      }
    }
#line 237
    if ((int )*cp < 48) {
      goto _L___0;
    } else {
#line 237
      if ((int )*cp > 57) {
        _L___0: /* CIL Label */ 
#line 238
        quoted = 0;
#line 239
        key_options = cp;
#line 240
        while (1) {
#line 240
          if (*cp) {
#line 240
            if (! quoted) {
#line 240
              if ((int )*cp != 32) {
#line 240
                if (! ((int )*cp != 9)) {
#line 240
                  break;
                }
              } else {
#line 240
                break;
              }
            }
          } else {
#line 240
            break;
          }
#line 241
          if ((int )*cp == 92) {
#line 241
            if ((int )*(cp + 1) == 34) {
#line 242
              cp ++;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 243
            if ((int )*cp == 34) {
#line 244
              quoted = ! quoted;
            }
          }
#line 240
          cp ++;
        }
      } else {
#line 247
        key_options = (char *)((void *)0);
      }
    }
#line 250
    tmp___1 = hostfile_read_key(& cp, & bits, key);
#line 250
    if (tmp___1 == 0) {
#line 251
      debug("%.100s, line %lu: non ssh1 key syntax", file___0, linenum);
#line 253
      continue;
    }
#line 258
    tmp___2 = BN_cmp((BIGNUM const   *)(key->rsa)->n, (BIGNUM const   *)client_n);
#line 258
    if (tmp___2 != 0) {
#line 259
      continue;
    }
#line 262
    keybits = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 263
    if (keybits < 0) {
#line 264
      tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 264
      logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
            file___0, linenum, tmp___3, bits);
    } else {
#line 263
      if (bits != (unsigned int )keybits) {
#line 264
        tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
#line 264
        logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
              file___0, linenum, tmp___3, bits);
      }
    }
#line 273
    tmp___4 = auth_parse_options(pw___0, key_options, file___0, linenum);
#line 273
    if (! tmp___4) {
#line 274
      continue;
    }
#line 277
    allowed = 1;
#line 278
    break;
  }
#line 282
  restore_uid();
#line 285
  xfree((void *)file___0);
#line 286
  fclose(f);
#line 289
  if (allowed) {
#line 289
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 290
      *rkey = key;
    } else {
#line 292
      key_free(key);
    }
  } else {
#line 292
    key_free(key);
  }
#line 293
  return (allowed);
}
}
#line 301 "auth-rsa.c"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) 
{ Key *key ;
  char *fp ;
  struct passwd *pw___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 306
  pw___0 = authctxt___0->pw;
#line 309
  if (! authctxt___0->valid) {
#line 310
    return (0);
  }
#line 312
  if (use_privsep) {
#line 312
    tmp___1 = mm_auth_rsa_key_allowed(pw___0, client_n, & key);
  } else {
#line 312
    tmp___1 = auth_rsa_key_allowed(pw___0, client_n, & key);
  }
#line 312
  if (! tmp___1) {
#line 313
    auth_clear_options();
#line 314
    return (0);
  }
#line 318
  tmp___2 = auth_rsa_challenge_dialog(key);
#line 318
  if (! tmp___2) {
#line 320
    verbose("Wrong response to RSA authentication challenge.");
#line 321
    packet_send_debug("Wrong response to RSA authentication challenge.");
#line 326
    key_free(key);
#line 327
    return (0);
  }
#line 335
  fp = key_fingerprint((Key const   *)key, 1, 0);
#line 336
  tmp___3 = key_type((Key const   *)key);
#line 336
  verbose("Found matching %s key: %s", tmp___3, fp);
#line 338
  xfree((void *)fp);
#line 339
  key_free(key);
#line 341
  packet_send_debug("RSA authentication accepted.");
#line 342
  return (1);
}
}
#line 1 "auth-rh-rsa.o"
#line 109 "auth.h"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) ;
#line 117
int auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *cuser , char *chost ,
                                Key *client_host_key ) ;
#line 172
HostStatus check_key_in_hostfiles(struct passwd *pw___0 , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) ;
#line 50 "monitor_wrap.h"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *user , char *host ,
                                   Key *key ) ;
#line 41 "auth-rh-rsa.c"
int auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *cuser , char *chost ,
                                Key *client_host_key ) 
{ HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 48
  tmp = auth_rhosts(pw___0, (char const   *)cuser);
#line 48
  if (! tmp) {
#line 49
    return (0);
  }
#line 51
  if (options.ignore_user_known_hosts) {
#line 51
    tmp___0 = (char const   *)((void *)0);
  } else {
#line 51
    tmp___0 = "~/.ssh/known_hosts";
  }
#line 51
  host_status = check_key_in_hostfiles(pw___0, client_host_key, (char const   *)chost,
                                       "/usr/local/etc/ssh_known_hosts", tmp___0);
#line 55
  return ((int )host_status == 0);
}
}
#line 62 "auth-rh-rsa.c"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) 
{ char *chost ;
  struct passwd *pw___0 ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 66
  pw___0 = authctxt___0->pw;
#line 68
  debug("Trying rhosts with RSA host authentication for client user %.100s", cuser);
#line 71
  if (! authctxt___0->valid) {
#line 73
    return (0);
  } else {
#line 71
    if ((unsigned int )client_host_key == (unsigned int )((void *)0)) {
#line 73
      return (0);
    } else {
#line 71
      if ((unsigned int )client_host_key->rsa == (unsigned int )((void *)0)) {
#line 73
        return (0);
      }
    }
  }
#line 75
  tmp = get_canonical_hostname(options.use_dns);
#line 75
  chost = (char *)tmp;
#line 76
  debug("Rhosts RSA authentication: canonical host %.900s", chost);
#line 78
  if (use_privsep) {
#line 78
    tmp___2 = mm_auth_rhosts_rsa_key_allowed(pw___0, cuser, chost, client_host_key);
  } else {
#line 78
    tmp___2 = auth_rhosts_rsa_key_allowed(pw___0, cuser, chost, client_host_key);
  }
#line 78
  if (! tmp___2) {
#line 79
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
#line 80
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
#line 81
    return (0);
  }
#line 86
  tmp___3 = auth_rsa_challenge_dialog(client_host_key);
#line 86
  if (! tmp___3) {
#line 87
    logit("Client on %.800s failed to respond correctly to host authentication.",
          chost);
#line 89
    return (0);
  }
#line 96
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw___0->pw_name, cuser, chost);
#line 98
  packet_send_debug("Rhosts with RSA host authentication accepted.");
#line 99
  return (1);
}
}
#line 1 "sshpty.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 23 "sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) ;
#line 24
void pty_release(char const   *tty ) ;
#line 25
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) ;
#line 26
void pty_change_window_size(int ptyfd , u_int row , u_int col , u_int xpixel , u_int ypixel ) ;
#line 27
void pty_setowner(struct passwd *pw___0 , char const   *tty ) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 56 "sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) 
{ char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 63
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
#line 64
  if (i < 0) {
#line 65
    tmp = __errno_location();
#line 65
    tmp___0 = strerror(*tmp);
#line 65
    error("openpty: %.100s", tmp___0);
#line 66
    return (0);
  }
#line 68
  name = ttyname(*ttyfd);
#line 69
  if (! name) {
#line 70
    fatal("openpty returns device for which ttyname fails.");
  }
#line 72
  strlcpy(namebuf, (char const   *)name, namebuflen);
#line 73
  return (1);
}
}
#line 78 "sshpty.c"
void pty_release(char const   *tty ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 81
  tmp___1 = chown(tty, 0U, 0U);
#line 81
  if (tmp___1 < 0) {
#line 82
    tmp = __errno_location();
#line 82
    tmp___0 = strerror(*tmp);
#line 82
    error("chown %.100s 0 0 failed: %.100s", tty, tmp___0);
  }
#line 83
  tmp___4 = chmod(tty, 438U);
#line 83
  if (tmp___4 < 0) {
#line 84
    tmp___2 = __errno_location();
#line 84
    tmp___3 = strerror(*tmp___2);
#line 84
    error("chmod %.100s 0666 failed: %.100s", tty, tmp___3);
  }
#line 85
  return;
}
}
#line 89 "sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) 
{ int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void (*tmp___5)(int  ) ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 123
  fd = open("/dev/tty", 258);
#line 124
  if (fd >= 0) {
#line 125
    ioctl(fd, 21538UL, (void *)0);
#line 126
    close(fd);
  }
#line 129
  tmp___1 = setsid();
#line 129
  if (tmp___1 < 0) {
#line 130
    tmp = __errno_location();
#line 130
    tmp___0 = strerror(*tmp);
#line 130
    error("setsid: %.100s", tmp___0);
  }
#line 136
  fd = open("/dev/tty", 258);
#line 137
  if (fd >= 0) {
#line 138
    error("Failed to disconnect from controlling tty.");
#line 139
    close(fd);
  }
#line 143
  debug("Setting controlling tty using TIOCSCTTY.");
#line 144
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
#line 144
  if (tmp___4 < 0) {
#line 145
    tmp___2 = __errno_location();
#line 145
    tmp___3 = strerror(*tmp___2);
#line 145
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
  }
#line 152
  tmp___5 = mysignal(1, (void (*)(int  ))1);
#line 152
  old = (void *)tmp___5;
#line 153
  vhangup();
#line 154
  mysignal(1, (void (*)(int  ))old);
#line 156
  fd = open(tty, 2);
#line 157
  if (fd < 0) {
#line 158
    tmp___6 = __errno_location();
#line 158
    tmp___7 = strerror(*tmp___6);
#line 158
    error("%.100s: %.100s", tty, tmp___7);
  } else {
#line 161
    close(*ttyfd);
#line 162
    *ttyfd = fd;
  }
#line 168
  fd = open("/dev/tty", 1);
#line 169
  if (fd < 0) {
#line 170
    tmp___8 = __errno_location();
#line 170
    tmp___9 = strerror(*tmp___8);
#line 170
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
  } else {
#line 173
    close(fd);
  }
#line 175
  return;
}
}
#line 179 "sshpty.c"
void pty_change_window_size(int ptyfd , u_int row , u_int col , u_int xpixel , u_int ypixel ) 
{ struct winsize w ;

  {
#line 186
  w.ws_row = (unsigned short )row;
#line 187
  w.ws_col = (unsigned short )col;
#line 188
  w.ws_xpixel = (unsigned short )xpixel;
#line 189
  w.ws_ypixel = (unsigned short )ypixel;
#line 190
  ioctl(ptyfd, 21524UL, & w);
#line 191
  return;
}
}
#line 193 "sshpty.c"
void pty_setowner(struct passwd *pw___0 , char const   *tty ) 
{ struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
#line 202
  grp = getgrnam("tty");
#line 203
  if (grp) {
#line 204
    gid = grp->gr_gid;
#line 205
    mode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 207
    gid = pw___0->pw_gid;
#line 208
    mode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
#line 216
  tmp___1 = stat((char const   * __restrict  )tty, (struct stat * __restrict  )(& st));
#line 216
  if (tmp___1) {
#line 217
    tmp = __errno_location();
#line 217
    tmp___0 = strerror(*tmp);
#line 217
    fatal("stat(%.100s) failed: %.100s", tty, tmp___0);
  }
#line 224
  if (st.st_uid != pw___0->pw_uid) {
    goto _L;
  } else {
#line 224
    if (st.st_gid != gid) {
      _L: /* CIL Label */ 
#line 225
      tmp___7 = chown(tty, pw___0->pw_uid, gid);
#line 225
      if (tmp___7 < 0) {
#line 226
        tmp___6 = __errno_location();
#line 226
        if (*tmp___6 == 30) {
#line 226
          if (st.st_uid == pw___0->pw_uid) {
#line 228
            tmp___2 = __errno_location();
#line 228
            tmp___3 = strerror(*tmp___2);
#line 228
            debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                  tmp___3);
          } else {
#line 226
            if (st.st_uid == 0U) {
#line 228
              tmp___2 = __errno_location();
#line 228
              tmp___3 = strerror(*tmp___2);
#line 228
              debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                    tmp___3);
            } else {
#line 232
              tmp___4 = __errno_location();
#line 232
              tmp___5 = strerror(*tmp___4);
#line 232
              fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                    tmp___5);
            }
          }
        } else {
#line 232
          tmp___4 = __errno_location();
#line 232
          tmp___5 = strerror(*tmp___4);
#line 232
          fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw___0->pw_uid, gid,
                tmp___5);
        }
      }
    }
  }
#line 238
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
#line 239
    tmp___13 = chmod(tty, mode);
#line 239
    if (tmp___13 < 0) {
#line 240
      tmp___12 = __errno_location();
#line 240
      if (*tmp___12 == 30) {
#line 240
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
#line 242
          tmp___8 = __errno_location();
#line 242
          tmp___9 = strerror(*tmp___8);
#line 242
          debug("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___9);
        } else {
#line 245
          tmp___10 = __errno_location();
#line 245
          tmp___11 = strerror(*tmp___10);
#line 245
          fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
        }
      } else {
#line 245
        tmp___10 = __errno_location();
#line 245
        tmp___11 = strerror(*tmp___10);
#line 245
        fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
      }
    }
  }
#line 249
  return;
}
}
#line 1 "sshlogin.o"
#line 89 "loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 92
void login_free_entry(struct logininfo *li ) ;
#line 100
int login_login(struct logininfo *li ) ;
#line 101
int login_logout(struct logininfo *li ) ;
#line 113
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) ;
#line 120
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) ;
#line 71 "sshlogin.c"
time_t get_last_login_time(uid_t uid , char const   *logname , char *buf___1 , size_t bufsize ) 
{ struct logininfo li ;

  {
#line 77
  login_get_lastlog(& li, (int )uid);
#line 78
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
#line 79
  return ((long )li.tv_sec);
}
}
#line 86 "sshlogin.c"
static void store_lastlog_message(char const   *user , uid_t uid ) 
{ char *time_string ;
  char hostname[64] ;
  char buf___1[512] ;
  time_t last_login_time ;
  unsigned int tmp___31 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t tmp___42 ;

  {
#line 89
  hostname[0] = (char )'\000';
#line 93
  if (! options.print_lastlog) {
#line 94
    return;
  }
#line 96
  last_login_time = get_last_login_time(uid, user, hostname, sizeof(hostname));
#line 99
  if (last_login_time != 0L) {
#line 100
    time_string = ctime((time_t const   *)(& last_login_time));
#line 101
    tmp___31 = __builtin_strcspn((char const   *)time_string, "\n");
#line 101
    *(time_string + tmp___31) = (char )'\000';
#line 102
    if (0) {
#line 102
      __s1_len = strlen((char const   *)(hostname));
#line 102
      __s2_len = strlen("");
#line 102
      if (! ((unsigned int )((void const   *)(hostname + 1)) - (unsigned int )((void const   *)(hostname)) == 1U)) {
        goto _L___0;
      } else {
#line 102
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 102
          if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 102
            tmp___41 = 1;
          } else {
#line 102
            if (__s2_len >= 4U) {
#line 102
              tmp___41 = 1;
            } else {
#line 102
              tmp___41 = 0;
            }
          }
        } else {
#line 102
          tmp___41 = 0;
        }
      }
#line 102
      if (tmp___41) {
#line 102
        tmp___37 = __builtin_strcmp((char const   *)(hostname), "");
      } else {
#line 102
        tmp___40 = __builtin_strcmp((char const   *)(hostname), "");
#line 102
        tmp___37 = tmp___40;
      }
    } else {
#line 102
      tmp___40 = __builtin_strcmp((char const   *)(hostname), "");
#line 102
      tmp___37 = tmp___40;
    }
#line 102
    if (tmp___37 == 0) {
#line 103
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Last login: %s\r\n",
               time_string);
    } else {
#line 106
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Last login: %s from %s\r\n",
               time_string, hostname);
    }
#line 108
    tmp___42 = strlen((char const   *)(buf___1));
#line 108
    buffer_append(& loginmsg, (void const   *)(buf___1), tmp___42);
  }
#line 111
  return;
}
}
#line 117 "sshlogin.c"
void record_login(pid_t pid , char const   *tty , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr , socklen_t addrlen ) 
{ struct logininfo *li ;

  {
#line 124
  store_lastlog_message(user, uid);
#line 126
  li = login_alloc_entry(pid, user, host, tty);
#line 127
  login_set_addr(li, (struct sockaddr  const  *)addr, addrlen);
#line 128
  login_login(li);
#line 129
  login_free_entry(li);
#line 130
  return;
}
}
#line 147 "sshlogin.c"
void record_logout(pid_t pid , char const   *tty , char const   *user ) 
{ struct logininfo *li ;

  {
#line 152
  li = login_alloc_entry(pid, user, (char const   *)((void *)0), tty);
#line 153
  login_logout(li);
#line 154
  login_free_entry(li);
#line 155
  return;
}
}
#line 1 "servconf.o"
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 747 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 158 "servconf.h"
void parse_server_match_config(ServerOptions *options___0 , char const   *user , char const   *host ,
                               char const   *address ) ;
#line 160
void copy_set_server_options(ServerOptions *dst , ServerOptions *src , int preauth ) ;
#line 30 "groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 31
int ga_match(char * const  *groups , int n___0 ) ;
#line 32
void ga_free(void) ;
#line 43 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) ;
#line 44
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) ;
#line 52 "servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 

  {
#line 55
  memset((void *)options___0, 0, sizeof(*options___0));
#line 58
  options___0->use_pam = -1;
#line 61
  options___0->num_ports = 0U;
#line 62
  options___0->ports_from_cmdline = 0U;
#line 63
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 64
  options___0->address_family = -1;
#line 65
  options___0->num_host_key_files = 0;
#line 66
  options___0->pid_file = (char *)((void *)0);
#line 67
  options___0->server_key_bits = -1;
#line 68
  options___0->login_grace_time = -1;
#line 69
  options___0->key_regeneration_time = -1;
#line 70
  options___0->permit_root_login = -1;
#line 71
  options___0->ignore_rhosts = -1;
#line 72
  options___0->ignore_user_known_hosts = -1;
#line 73
  options___0->print_motd = -1;
#line 74
  options___0->print_lastlog = -1;
#line 75
  options___0->x11_forwarding = -1;
#line 76
  options___0->x11_display_offset = -1;
#line 77
  options___0->x11_use_localhost = -1;
#line 78
  options___0->xauth_location = (char *)((void *)0);
#line 79
  options___0->strict_modes = -1;
#line 80
  options___0->tcp_keep_alive = -1;
#line 81
  options___0->log_facility = -1;
#line 82
  options___0->log_level = -1;
#line 83
  options___0->rhosts_rsa_authentication = -1;
#line 84
  options___0->hostbased_authentication = -1;
#line 85
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 86
  options___0->rsa_authentication = -1;
#line 87
  options___0->pubkey_authentication = -1;
#line 88
  options___0->kerberos_authentication = -1;
#line 89
  options___0->kerberos_or_local_passwd = -1;
#line 90
  options___0->kerberos_ticket_cleanup = -1;
#line 91
  options___0->kerberos_get_afs_token = -1;
#line 92
  options___0->gss_authentication = -1;
#line 93
  options___0->gss_cleanup_creds = -1;
#line 94
  options___0->password_authentication = -1;
#line 95
  options___0->kbd_interactive_authentication = -1;
#line 96
  options___0->challenge_response_authentication = -1;
#line 97
  options___0->permit_empty_passwd = -1;
#line 98
  options___0->permit_user_env = -1;
#line 99
  options___0->use_login = -1;
#line 100
  options___0->compression = -1;
#line 101
  options___0->allow_tcp_forwarding = -1;
#line 102
  options___0->num_allow_users = 0U;
#line 103
  options___0->num_deny_users = 0U;
#line 104
  options___0->num_allow_groups = 0U;
#line 105
  options___0->num_deny_groups = 0U;
#line 106
  options___0->ciphers = (char *)((void *)0);
#line 107
  options___0->macs = (char *)((void *)0);
#line 108
  options___0->protocol = 0;
#line 109
  options___0->gateway_ports = -1;
#line 110
  options___0->num_subsystems = 0U;
#line 111
  options___0->max_startups_begin = -1;
#line 112
  options___0->max_startups_rate = -1;
#line 113
  options___0->max_startups = -1;
#line 114
  options___0->max_authtries = -1;
#line 115
  options___0->banner = (char *)((void *)0);
#line 116
  options___0->use_dns = -1;
#line 117
  options___0->client_alive_interval = -1;
#line 118
  options___0->client_alive_count_max = -1;
#line 119
  options___0->authorized_keys_file = (char *)((void *)0);
#line 120
  options___0->authorized_keys_file2 = (char *)((void *)0);
#line 121
  options___0->num_accept_env = 0U;
#line 122
  options___0->permit_tun = -1;
#line 123
  options___0->num_permitted_opens = -1;
#line 124
  options___0->adm_forced_command = (char *)((void *)0);
#line 125
  options___0->chroot_directory = (char *)((void *)0);
#line 126
  return;
}
}
#line 128 "servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;

  {
#line 132
  if (options___0->use_pam == -1) {
#line 133
    options___0->use_pam = 0;
  }
#line 136
  if (options___0->protocol == 0) {
#line 137
    options___0->protocol = 5;
  }
#line 138
  if (options___0->num_host_key_files == 0) {
#line 140
    if (options___0->protocol & 1) {
#line 141
      tmp = options___0->num_host_key_files;
#line 141
      (options___0->num_host_key_files) ++;
#line 141
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 143
    if (options___0->protocol & 4) {
#line 144
      tmp___0 = options___0->num_host_key_files;
#line 144
      (options___0->num_host_key_files) ++;
#line 144
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_rsa_key";
#line 146
      tmp___1 = options___0->num_host_key_files;
#line 146
      (options___0->num_host_key_files) ++;
#line 146
      options___0->host_key_files[tmp___1] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 150
  if (options___0->num_ports == 0U) {
#line 151
    tmp___2 = options___0->num_ports;
#line 151
    (options___0->num_ports) ++;
#line 151
    options___0->ports[tmp___2] = (unsigned short)22;
  }
#line 152
  if ((unsigned int )options___0->listen_addrs == (unsigned int )((void *)0)) {
#line 153
    add_listen_addr(options___0, (char *)((void *)0), (unsigned short)0);
  }
#line 154
  if ((unsigned int )options___0->pid_file == (unsigned int )((void *)0)) {
#line 155
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 156
  if (options___0->server_key_bits == -1) {
#line 157
    options___0->server_key_bits = 768;
  }
#line 158
  if (options___0->login_grace_time == -1) {
#line 159
    options___0->login_grace_time = 120;
  }
#line 160
  if (options___0->key_regeneration_time == -1) {
#line 161
    options___0->key_regeneration_time = 3600;
  }
#line 162
  if (options___0->permit_root_login == -1) {
#line 163
    options___0->permit_root_login = 3;
  }
#line 164
  if (options___0->ignore_rhosts == -1) {
#line 165
    options___0->ignore_rhosts = 1;
  }
#line 166
  if (options___0->ignore_user_known_hosts == -1) {
#line 167
    options___0->ignore_user_known_hosts = 0;
  }
#line 168
  if (options___0->print_motd == -1) {
#line 169
    options___0->print_motd = 1;
  }
#line 170
  if (options___0->print_lastlog == -1) {
#line 171
    options___0->print_lastlog = 1;
  }
#line 172
  if (options___0->x11_forwarding == -1) {
#line 173
    options___0->x11_forwarding = 0;
  }
#line 174
  if (options___0->x11_display_offset == -1) {
#line 175
    options___0->x11_display_offset = 10;
  }
#line 176
  if (options___0->x11_use_localhost == -1) {
#line 177
    options___0->x11_use_localhost = 1;
  }
#line 178
  if ((unsigned int )options___0->xauth_location == (unsigned int )((void *)0)) {
#line 179
    options___0->xauth_location = (char *)"/usr/bin//xauth";
  }
#line 180
  if (options___0->strict_modes == -1) {
#line 181
    options___0->strict_modes = 1;
  }
#line 182
  if (options___0->tcp_keep_alive == -1) {
#line 183
    options___0->tcp_keep_alive = 1;
  }
#line 184
  if ((int )options___0->log_facility == -1) {
#line 185
    options___0->log_facility = 2;
  }
#line 186
  if ((int )options___0->log_level == -1) {
#line 187
    options___0->log_level = 3;
  }
#line 188
  if (options___0->rhosts_rsa_authentication == -1) {
#line 189
    options___0->rhosts_rsa_authentication = 0;
  }
#line 190
  if (options___0->hostbased_authentication == -1) {
#line 191
    options___0->hostbased_authentication = 0;
  }
#line 192
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 193
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 194
  if (options___0->rsa_authentication == -1) {
#line 195
    options___0->rsa_authentication = 1;
  }
#line 196
  if (options___0->pubkey_authentication == -1) {
#line 197
    options___0->pubkey_authentication = 1;
  }
#line 198
  if (options___0->kerberos_authentication == -1) {
#line 199
    options___0->kerberos_authentication = 0;
  }
#line 200
  if (options___0->kerberos_or_local_passwd == -1) {
#line 201
    options___0->kerberos_or_local_passwd = 1;
  }
#line 202
  if (options___0->kerberos_ticket_cleanup == -1) {
#line 203
    options___0->kerberos_ticket_cleanup = 1;
  }
#line 204
  if (options___0->kerberos_get_afs_token == -1) {
#line 205
    options___0->kerberos_get_afs_token = 0;
  }
#line 206
  if (options___0->gss_authentication == -1) {
#line 207
    options___0->gss_authentication = 0;
  }
#line 208
  if (options___0->gss_cleanup_creds == -1) {
#line 209
    options___0->gss_cleanup_creds = 1;
  }
#line 210
  if (options___0->password_authentication == -1) {
#line 211
    options___0->password_authentication = 1;
  }
#line 212
  if (options___0->kbd_interactive_authentication == -1) {
#line 213
    options___0->kbd_interactive_authentication = 0;
  }
#line 214
  if (options___0->challenge_response_authentication == -1) {
#line 215
    options___0->challenge_response_authentication = 1;
  }
#line 216
  if (options___0->permit_empty_passwd == -1) {
#line 217
    options___0->permit_empty_passwd = 0;
  }
#line 218
  if (options___0->permit_user_env == -1) {
#line 219
    options___0->permit_user_env = 0;
  }
#line 220
  if (options___0->use_login == -1) {
#line 221
    options___0->use_login = 0;
  }
#line 222
  if (options___0->compression == -1) {
#line 223
    options___0->compression = 2;
  }
#line 224
  if (options___0->allow_tcp_forwarding == -1) {
#line 225
    options___0->allow_tcp_forwarding = 1;
  }
#line 226
  if (options___0->gateway_ports == -1) {
#line 227
    options___0->gateway_ports = 0;
  }
#line 228
  if (options___0->max_startups == -1) {
#line 229
    options___0->max_startups = 10;
  }
#line 230
  if (options___0->max_startups_rate == -1) {
#line 231
    options___0->max_startups_rate = 100;
  }
#line 232
  if (options___0->max_startups_begin == -1) {
#line 233
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 234
  if (options___0->max_authtries == -1) {
#line 235
    options___0->max_authtries = 6;
  }
#line 236
  if (options___0->use_dns == -1) {
#line 237
    options___0->use_dns = 1;
  }
#line 238
  if (options___0->client_alive_interval == -1) {
#line 239
    options___0->client_alive_interval = 0;
  }
#line 240
  if (options___0->client_alive_count_max == -1) {
#line 241
    options___0->client_alive_count_max = 3;
  }
#line 242
  if ((unsigned int )options___0->authorized_keys_file2 == (unsigned int )((void *)0)) {
#line 244
    if ((unsigned int )options___0->authorized_keys_file != (unsigned int )((void *)0)) {
#line 245
      options___0->authorized_keys_file2 = options___0->authorized_keys_file;
    } else {
#line 247
      options___0->authorized_keys_file2 = (char *)".ssh/authorized_keys2";
    }
  }
#line 249
  if ((unsigned int )options___0->authorized_keys_file == (unsigned int )((void *)0)) {
#line 250
    options___0->authorized_keys_file = (char *)".ssh/authorized_keys";
  }
#line 251
  if (options___0->permit_tun == -1) {
#line 252
    options___0->permit_tun = 0;
  }
#line 255
  if (use_privsep == -1) {
#line 256
    use_privsep = 1;
  }
#line 267
  return;
}
}
#line 305 "servconf.c"
static struct __anonstruct_keywords_79 keywords[77]  = 
#line 305
  {      {"usepam", 68, (u_int )1}, 
        {"pamauthenticationviakbdint", 67, (u_int )1}, 
        {"port", 2, (u_int )1}, 
        {"hostkey", 3, (u_int )1}, 
        {"hostdsakey", 3, (u_int )1}, 
        {"pidfile", 43, (u_int )1}, 
        {"serverkeybits", 4, (u_int )1}, 
        {"logingracetime", 5, (u_int )1}, 
        {"keyregenerationinterval", 6, (u_int )1}, 
        {"permitrootlogin", 7, (u_int )3}, 
        {"syslogfacility", 8, (u_int )1}, 
        {"loglevel", 9, (u_int )1}, 
        {"rhostsauthentication", 67, (u_int )1}, 
        {"rhostsrsaauthentication", 10, (u_int )3}, 
        {"hostbasedauthentication", 52, (u_int )3}, 
        {"hostbasedusesnamefrompacketonly", 53, (u_int )1}, 
        {"rsaauthentication", 11, (u_int )3}, 
        {"pubkeyauthentication", 45, (u_int )3}, 
        {"dsaauthentication", 45, (u_int )1}, 
        {"kerberosauthentication", 68, (u_int )3}, 
        {"kerberosorlocalpasswd", 68, (u_int )1}, 
        {"kerberosticketcleanup", 68, (u_int )1}, 
        {"kerberosgetafstoken", 68, (u_int )1}, 
        {"kerberostgtpassing", 68, (u_int )1}, 
        {"afstokenpassing", 68, (u_int )1}, 
        {"gssapiauthentication", 68, (u_int )3}, 
        {"gssapicleanupcredentials", 68, (u_int )1}, 
        {"passwordauthentication", 18, (u_int )3}, 
        {"kbdinteractiveauthentication", 19, (u_int )3}, 
        {"challengeresponseauthentication", 17, (u_int )1}, 
        {"skeyauthentication", 17, (u_int )1}, 
        {"checkmail", 67, (u_int )1}, 
        {"listenaddress", 20, (u_int )1}, 
        {"addressfamily", 21, (u_int )1}, 
        {"printmotd", 22, (u_int )1}, 
        {"printlastlog", 23, (u_int )1}, 
        {"ignorerhosts", 24, (u_int )1}, 
        {"ignoreuserknownhosts", 39, (u_int )1}, 
        {"x11forwarding", 25, (u_int )3}, 
        {"x11displayoffset", 26, (u_int )3}, 
        {"x11uselocalhost", 27, (u_int )3}, 
        {"xauthlocation", 46, (u_int )1}, 
        {"strictmodes", 28, (u_int )1}, 
        {"permitemptypasswords", 29, (u_int )1}, 
        {"permituserenvironment", 31, (u_int )1}, 
        {"uselogin", 32, (u_int )1}, 
        {"compression", 34, (u_int )1}, 
        {"tcpkeepalive", 30, (u_int )1}, 
        {"keepalive", 30, (u_int )1}, 
        {"allowtcpforwarding", 33, (u_int )3}, 
        {"allowusers", 35, (u_int )1}, 
        {"denyusers", 36, (u_int )1}, 
        {"allowgroups", 37, (u_int )1}, 
        {"denygroups", 38, (u_int )1}, 
        {"ciphers", 40, (u_int )1}, 
        {"macs", 41, (u_int )1}, 
        {"protocol", 42, (u_int )1}, 
        {"gatewayports", 44, (u_int )3}, 
        {"subsystem", 47, (u_int )1}, 
        {"maxstartups", 48, (u_int )1}, 
        {"maxauthtries", 49, (u_int )1}, 
        {"banner", 50, (u_int )3}, 
        {"usedns", 51, (u_int )1}, 
        {"verifyreversemapping", 67, (u_int )1}, 
        {"reversemappingcheck", 67, (u_int )1}, 
        {"clientaliveinterval", 54, (u_int )1}, 
        {"clientalivecountmax", 55, (u_int )1}, 
        {"authorizedkeysfile", 56, (u_int )1}, 
        {"authorizedkeysfile2", 57, (u_int )1}, 
        {"useprivilegeseparation", 66, (u_int )1}, 
        {"acceptenv", 60, (u_int )1}, 
        {"permittunnel", 61, (u_int )1}, 
        {"match", 62, (u_int )3}, 
        {"permitopen", 63, (u_int )3}, 
        {"forcecommand", 64, (u_int )3}, 
        {"chrootdirectory", 65, (u_int )3}, 
        {(char const   *)((void *)0), 0, (u_int )0}};
#line 415 "servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ,
                                 u_int *flags ) 
{ u_int i ;
  int tmp ;

  {
#line 421
  i = 0U;
#line 421
  while (keywords[i].name) {
#line 422
    tmp = strcasecmp(cp, keywords[i].name);
#line 422
    if (tmp == 0) {
#line 423
      *flags = keywords[i].flags;
#line 424
      return (keywords[i].opcode);
    }
#line 421
    i ++;
  }
#line 427
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
#line 429
  return (0);
}
}
#line 432 "servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) 
{ u_int i ;
  u_int tmp ;

  {
#line 437
  if (options___0->num_ports == 0U) {
#line 438
    tmp = options___0->num_ports;
#line 438
    (options___0->num_ports) ++;
#line 438
    options___0->ports[tmp] = (unsigned short)22;
  }
#line 439
  if (options___0->address_family == -1) {
#line 440
    options___0->address_family = 0;
  }
#line 441
  if ((int )port___0 == 0) {
#line 442
    i = 0U;
#line 442
    while (i < options___0->num_ports) {
#line 443
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
#line 442
      i ++;
    }
  } else {
#line 445
    add_one_listen_addr(options___0, addr, port___0);
  }
#line 446
  return;
}
}
#line 448 "servconf.c"
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port___0 ) 
{ struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 455
  memset((void *)(& hints), 0, sizeof(hints));
#line 456
  hints.ai_family = options___0->address_family;
#line 457
  hints.ai_socktype = 1;
#line 458
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 458
    hints.ai_flags = 1;
  } else {
#line 458
    hints.ai_flags = 0;
  }
#line 459
  snprintf((char * __restrict  )(strport), sizeof(strport), (char const   * __restrict  )"%u",
           port___0);
#line 460
  gaierr = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )(strport),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& aitop));
#line 460
  if (gaierr != 0) {
#line 461
    tmp = ssh_gai_strerror(gaierr);
#line 461
    if (addr) {
#line 461
      tmp___0 = (char const   *)addr;
    } else {
#line 461
      tmp___0 = "<NULL>";
    }
#line 461
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
  }
#line 464
  ai = aitop;
#line 464
  while (ai->ai_next) {
#line 464
    ai = ai->ai_next;
  }
#line 466
  ai->ai_next = options___0->listen_addrs;
#line 467
  options___0->listen_addrs = aitop;
#line 468
  return;
}
}
#line 503 "servconf.c"
static int match_cfg_line_group(char const   *grps , int line , char const   *user ) 
{ int result ;
  u_int ngrps ;
  char *arg ;
  char *p ;
  char *cp ;
  char *grplist[256] ;
  struct passwd *pw___0 ;
  u_int tmp ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 506
  result = 0;
#line 507
  ngrps = (u_int )0;
#line 515
  cp = xstrdup(grps);
#line 515
  arg = cp;
#line 516
  while (1) {
#line 516
    tmp___15 = __strsep_g(& cp, ",");
#line 516
    p = tmp___15;
#line 516
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 516
      if (! ((int )*p != 0)) {
#line 516
        break;
      }
    } else {
#line 516
      break;
    }
#line 517
    if (ngrps >= 256U) {
#line 518
      error("line %d: too many groups in Match Group", line);
#line 519
      result = -1;
      goto out;
    }
#line 522
    tmp = ngrps;
#line 522
    ngrps ++;
#line 522
    grplist[tmp] = p;
  }
#line 525
  if ((unsigned int )user == (unsigned int )((void *)0)) {
    goto out;
  }
#line 528
  pw___0 = getpwnam(user);
#line 528
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 529
    debug("Can\'t match group at line %d because user %.100s does not exist", line,
          user);
  } else {
#line 531
    tmp___17 = ga_init((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 531
    if (tmp___17 == 0) {
#line 532
      debug("Can\'t Match group because user %.100s not in any group at line %d",
            user, line);
    } else {
#line 534
      tmp___16 = ga_match((char * const  *)(grplist), (int )ngrps);
#line 534
      if (tmp___16 != 1) {
#line 535
        debug("user %.100s does not match group %.100s at line %d", user, arg, line);
      } else {
#line 538
        debug("user %.100s matched group %.100s at line %d", user, arg, line);
#line 540
        result = 1;
      }
    }
  }
  out: 
#line 543
  ga_free();
#line 544
  xfree((void *)arg);
#line 545
  return (result);
}
}
#line 548 "servconf.c"
static int match_cfg_line(char **condition , int line , char const   *user , char const   *host ,
                          char const   *address ) 
{ int result ;
  char *arg ;
  char *attrib ;
  char *cp ;
  size_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;

  {
#line 552
  result = 1;
#line 553
  cp = *condition;
#line 556
  if ((unsigned int )user == (unsigned int )((void *)0)) {
#line 557
    debug3("checking syntax for \'Match %s\'", cp);
  } else {
#line 559
    if (address) {
#line 559
      tmp = address;
    } else {
#line 559
      tmp = "(null)";
    }
#line 559
    if (host) {
#line 559
      tmp___0 = host;
    } else {
#line 559
      tmp___0 = "(null)";
    }
#line 559
    if (user) {
#line 559
      tmp___1 = user;
    } else {
#line 559
      tmp___1 = "(null)";
    }
#line 559
    debug3("checking match for \'%s\' user %s host %s addr %s", cp, tmp___1, tmp___0,
           tmp);
  }
#line 563
  while (1) {
#line 563
    attrib = strdelim(& cp);
#line 563
    if (attrib) {
#line 563
      if (! ((int )*attrib != 0)) {
#line 563
        break;
      }
    } else {
#line 563
      break;
    }
#line 564
    arg = strdelim(& cp);
#line 564
    if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 565
      error("Missing Match criteria for %s", attrib);
#line 566
      return (-1);
    } else {
#line 564
      if ((int )*arg == 0) {
#line 565
        error("Missing Match criteria for %s", attrib);
#line 566
        return (-1);
      }
    }
#line 568
    len = strlen((char const   *)arg);
#line 569
    tmp___9 = strcasecmp((char const   *)attrib, "user");
#line 569
    if (tmp___9 == 0) {
#line 570
      if (! user) {
#line 571
        result = 0;
#line 572
        continue;
      }
#line 574
      tmp___2 = match_pattern_list(user, (char const   *)arg, len, 0);
#line 574
      if (tmp___2 != 1) {
#line 575
        result = 0;
      } else {
#line 577
        debug("user %.100s matched \'User %.100s\' at line %d", user, arg, line);
      }
    } else {
#line 579
      tmp___8 = strcasecmp((char const   *)attrib, "group");
#line 579
      if (tmp___8 == 0) {
#line 580
        tmp___3 = match_cfg_line_group((char const   *)arg, line, user);
#line 580
        switch (tmp___3) {
        case -1: 
#line 582
        return (-1);
        case 0: 
#line 584
        result = 0;
        }
      } else {
#line 586
        tmp___7 = strcasecmp((char const   *)attrib, "host");
#line 586
        if (tmp___7 == 0) {
#line 587
          if (! host) {
#line 588
            result = 0;
#line 589
            continue;
          }
#line 591
          tmp___4 = match_hostname(host, (char const   *)arg, len);
#line 591
          if (tmp___4 != 1) {
#line 592
            result = 0;
          } else {
#line 594
            debug("connection from %.100s matched \'Host %.100s\' at line %d", host,
                  arg, line);
          }
        } else {
#line 596
          tmp___6 = strcasecmp((char const   *)attrib, "address");
#line 596
          if (tmp___6 == 0) {
#line 597
            if (! address) {
#line 598
              result = 0;
#line 599
              continue;
            }
#line 601
            tmp___5 = match_hostname(address, (char const   *)arg, len);
#line 601
            if (tmp___5 != 1) {
#line 602
              result = 0;
            } else {
#line 604
              debug("connection from %.100s matched \'Address %.100s\' at line %d",
                    address, arg, line);
            }
          } else {
#line 607
            error("Unsupported Match attribute %s", attrib);
#line 608
            return (-1);
          }
        }
      }
    }
  }
#line 611
  if ((unsigned int )user != (unsigned int )((void *)0)) {
#line 612
    if (result) {
#line 612
      tmp___10 = "";
    } else {
#line 612
      tmp___10 = "not ";
    }
#line 612
    debug3("match %sfound", tmp___10);
  }
#line 613
  *condition = cp;
#line 614
  return (result);
}
}
#line 619 "servconf.c"
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum , int *activep , char const   *user , char const   *host ,
                               char const   *address ) 
{ char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int cmdline ;
  int *intptr ;
  int value ;
  int n___0 ;
  SyslogFacility *log_facility_ptr ;
  LogLevel *log_level_ptr ;
  ServerOpCodes opcode ;
  u_short port___0 ;
  u_int i ;
  u_int flags ;
  size_t len ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___78 ;
  int tmp___81 ;
  int tmp___82 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___88 ;
  int tmp___91 ;
  int tmp___92 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___98 ;
  int tmp___101 ;
  int tmp___102 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___108 ;
  int tmp___111 ;
  int tmp___112 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___118 ;
  int tmp___121 ;
  int tmp___122 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___128 ;
  int tmp___131 ;
  int tmp___132 ;
  SyslogFacility tmp___133 ;
  char const   *tmp___134 ;
  LogLevel tmp___135 ;
  char const   *tmp___136 ;
  u_int tmp___137 ;
  u_int tmp___138 ;
  u_int tmp___139 ;
  u_int tmp___140 ;
  char const   *tmp___141 ;
  int tmp___142 ;
  char const   *tmp___143 ;
  int tmp___144 ;
  char const   *tmp___145 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___151 ;
  int tmp___154 ;
  int tmp___155 ;
  size_t tmp___156 ;
  size_t tmp___157 ;
  void *tmp___158 ;
  char *tmp___160 ;
  u_int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___171 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  unsigned int tmp___208 ;

  {
#line 625
  cmdline = 0;
#line 630
  flags = (u_int )0;
#line 633
  cp = line;
#line 634
  arg = strdelim(& cp);
#line 634
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 635
    return (0);
  }
#line 637
  if ((int )*arg == 0) {
#line 638
    arg = strdelim(& cp);
  }
#line 639
  if (! arg) {
#line 640
    return (0);
  } else {
#line 639
    if (! *arg) {
#line 640
      return (0);
    } else {
#line 639
      if ((int )*arg == 35) {
#line 640
        return (0);
      }
    }
  }
#line 641
  intptr = (int *)((void *)0);
#line 642
  charptr = (char **)((void *)0);
#line 643
  opcode = parse_token((char const   *)arg, filename, linenum, & flags);
#line 645
  if ((unsigned int )activep == (unsigned int )((void *)0)) {
#line 646
    cmdline = 1;
#line 647
    activep = & cmdline;
  }
#line 649
  if (*activep) {
#line 649
    if ((int )opcode != 62) {
#line 650
      debug3("%s:%d setting %s %s", filename, linenum, arg, cp);
    }
  }
#line 651
  if (*activep == 0) {
#line 651
    if (! (flags & 2U)) {
#line 652
      if ((unsigned int )user == (unsigned int )((void *)0)) {
#line 653
        fatal("%s line %d: Directive \'%s\' is not allowed within a Match block",
              filename, linenum, arg);
      } else {
#line 656
        while (arg) {
#line 657
          arg = strdelim(& cp);
        }
#line 658
        return (0);
      }
    }
  }
#line 662
  switch ((int )opcode) {
  case 1: 
#line 665
  intptr = & options___0->use_pam;
  goto parse_flag;
  case 0: 
#line 670
  return (-1);
  case 2: 
#line 673
  if (options___0->ports_from_cmdline) {
#line 674
    return (0);
  }
#line 675
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 676
    fatal("%s line %d: ports must be specified before ListenAddress.", filename, linenum);
  }
#line 678
  if (options___0->num_ports >= 256U) {
#line 679
    fatal("%s line %d: too many ports.", filename, linenum);
  }
#line 681
  arg = strdelim(& cp);
#line 682
  if (! arg) {
#line 683
    fatal("%s line %d: missing port number.", filename, linenum);
  } else {
#line 682
    if ((int )*arg == 0) {
#line 683
      fatal("%s line %d: missing port number.", filename, linenum);
    }
  }
#line 685
  tmp = options___0->num_ports;
#line 685
  (options___0->num_ports) ++;
#line 685
  tmp___0 = a2port((char const   *)arg);
#line 685
  options___0->ports[tmp] = (unsigned short )tmp___0;
#line 686
  if ((int )options___0->ports[options___0->num_ports - 1U] == 0) {
#line 687
    fatal("%s line %d: Badly formatted port number.", filename, linenum);
  }
#line 689
  break;
  case 4: 
#line 692
  intptr = & options___0->server_key_bits;
  parse_int: 
#line 694
  arg = strdelim(& cp);
#line 695
  if (! arg) {
#line 696
    fatal("%s line %d: missing integer value.", filename, linenum);
  } else {
#line 695
    if ((int )*arg == 0) {
#line 696
      fatal("%s line %d: missing integer value.", filename, linenum);
    }
  }
#line 698
  value = atoi((char const   *)arg);
#line 699
  if (*activep) {
#line 699
    if (*intptr == -1) {
#line 700
      *intptr = value;
    }
  }
#line 701
  break;
  case 5: 
#line 704
  intptr = & options___0->login_grace_time;
  parse_time: 
#line 706
  arg = strdelim(& cp);
#line 707
  if (! arg) {
#line 708
    fatal("%s line %d: missing time value.", filename, linenum);
  } else {
#line 707
    if ((int )*arg == 0) {
#line 708
      fatal("%s line %d: missing time value.", filename, linenum);
    }
  }
#line 710
  tmp___1 = convtime((char const   *)arg);
#line 710
  value = (int )tmp___1;
#line 710
  if (value == -1) {
#line 711
    fatal("%s line %d: invalid time value.", filename, linenum);
  }
#line 713
  if (*intptr == -1) {
#line 714
    *intptr = value;
  }
#line 715
  break;
  case 6: 
#line 718
  intptr = & options___0->key_regeneration_time;
  goto parse_time;
  case 20: 
#line 722
  arg = strdelim(& cp);
#line 723
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 724
    fatal("%s line %d: missing address", filename, linenum);
  } else {
#line 723
    if ((int )*arg == 0) {
#line 724
      fatal("%s line %d: missing address", filename, linenum);
    }
  }
#line 727
  tmp___3 = __builtin_strchr(arg, '[');
#line 727
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 727
    tmp___5 = __builtin_strchr(arg, ':');
#line 727
    p = tmp___5;
#line 727
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 727
      tmp___7 = __builtin_strchr(p + 1, ':');
#line 727
      if ((unsigned int )tmp___7 != (unsigned int )((void *)0)) {
#line 729
        add_listen_addr(options___0, arg, (unsigned short)0);
#line 730
        break;
      }
    }
  }
#line 732
  p = hpdelim(& arg);
#line 733
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 734
    fatal("%s line %d: bad address:port usage", filename, linenum);
  }
#line 736
  p = cleanhostname(p);
#line 737
  if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 738
    port___0 = (unsigned short)0;
  } else {
#line 739
    tmp___8 = a2port((char const   *)arg);
#line 739
    port___0 = (unsigned short )tmp___8;
#line 739
    if ((int )port___0 == 0) {
#line 740
      fatal("%s line %d: bad port number", filename, linenum);
    }
  }
#line 742
  add_listen_addr(options___0, p, port___0);
#line 744
  break;
  case 21: 
#line 747
  arg = strdelim(& cp);
#line 748
  if (! arg) {
#line 749
    fatal("%s line %d: missing address family.", filename, linenum);
  } else {
#line 748
    if ((int )*arg == 0) {
#line 749
      fatal("%s line %d: missing address family.", filename, linenum);
    }
  }
#line 751
  intptr = & options___0->address_family;
#line 752
  if ((unsigned int )options___0->listen_addrs != (unsigned int )((void *)0)) {
#line 753
    fatal("%s line %d: address family must be specified before ListenAddress.", filename,
          linenum);
  }
#line 755
  tmp___11 = strcasecmp((char const   *)arg, "inet");
#line 755
  if (tmp___11 == 0) {
#line 756
    value = 2;
  } else {
#line 757
    tmp___10 = strcasecmp((char const   *)arg, "inet6");
#line 757
    if (tmp___10 == 0) {
#line 758
      value = 10;
    } else {
#line 759
      tmp___9 = strcasecmp((char const   *)arg, "any");
#line 759
      if (tmp___9 == 0) {
#line 760
        value = 0;
      } else {
#line 762
        fatal("%s line %d: unsupported address family \"%s\".", filename, linenum,
              arg);
      }
    }
  }
#line 764
  if (*intptr == -1) {
#line 765
    *intptr = value;
  }
#line 766
  break;
  case 3: 
#line 769
  intptr = & options___0->num_host_key_files;
#line 770
  if (*intptr >= 256) {
#line 771
    fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
          256);
  }
#line 773
  charptr = & options___0->host_key_files[*intptr];
  parse_filename: 
#line 775
  arg = strdelim(& cp);
#line 776
  if (! arg) {
#line 777
    fatal("%s line %d: missing file name.", filename, linenum);
  } else {
#line 776
    if ((int )*arg == 0) {
#line 777
      fatal("%s line %d: missing file name.", filename, linenum);
    }
  }
#line 779
  if (*activep) {
#line 779
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 780
      tmp___12 = getuid();
#line 780
      *charptr = tilde_expand_filename((char const   *)arg, tmp___12);
#line 782
      if ((unsigned int )intptr != (unsigned int )((void *)0)) {
#line 783
        (*intptr) ++;
      }
    }
  }
#line 785
  break;
  case 43: 
#line 788
  charptr = & options___0->pid_file;
  goto parse_filename;
  case 7: 
#line 792
  intptr = & options___0->permit_root_login;
#line 793
  arg = strdelim(& cp);
#line 794
  if (! arg) {
#line 795
    fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
          filename, linenum);
  } else {
#line 794
    if ((int )*arg == 0) {
#line 795
      fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
            filename, linenum);
    }
  }
#line 798
  value = 0;
#line 799
  if (0) {
#line 799
    __s1_len___2 = strlen((char const   *)arg);
#line 799
    __s2_len___2 = strlen("without-password");
#line 799
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___6;
    } else {
#line 799
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 799
        if (! ((unsigned int )((void const   *)("without-password" + 1)) - (unsigned int )((void const   *)"without-password") == 1U)) {
#line 799
          tmp___52 = 1;
        } else {
#line 799
          if (__s2_len___2 >= 4U) {
#line 799
            tmp___52 = 1;
          } else {
#line 799
            tmp___52 = 0;
          }
        }
      } else {
#line 799
        tmp___52 = 0;
      }
    }
#line 799
    if (tmp___52) {
#line 799
      tmp___48 = __builtin_strcmp((char const   *)arg, "without-password");
    } else {
#line 799
      tmp___51 = __builtin_strcmp((char const   *)arg, "without-password");
#line 799
      tmp___48 = tmp___51;
    }
  } else {
#line 799
    tmp___51 = __builtin_strcmp((char const   *)arg, "without-password");
#line 799
    tmp___48 = tmp___51;
  }
#line 799
  if (tmp___48 == 0) {
#line 800
    value = 2;
  } else {
#line 801
    if (0) {
#line 801
      __s1_len___1 = strlen((char const   *)arg);
#line 801
      __s2_len___1 = strlen("forced-commands-only");
#line 801
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___4;
      } else {
#line 801
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 801
          if (! ((unsigned int )((void const   *)("forced-commands-only" + 1)) - (unsigned int )((void const   *)"forced-commands-only") == 1U)) {
#line 801
            tmp___42 = 1;
          } else {
#line 801
            if (__s2_len___1 >= 4U) {
#line 801
              tmp___42 = 1;
            } else {
#line 801
              tmp___42 = 0;
            }
          }
        } else {
#line 801
          tmp___42 = 0;
        }
      }
#line 801
      if (tmp___42) {
#line 801
        tmp___38 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
      } else {
#line 801
        tmp___41 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 801
        tmp___38 = tmp___41;
      }
    } else {
#line 801
      tmp___41 = __builtin_strcmp((char const   *)arg, "forced-commands-only");
#line 801
      tmp___38 = tmp___41;
    }
#line 801
    if (tmp___38 == 0) {
#line 802
      value = 1;
    } else {
#line 803
      if (0) {
#line 803
        __s1_len___0 = strlen((char const   *)arg);
#line 803
        __s2_len___0 = strlen("yes");
#line 803
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___2;
        } else {
#line 803
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 803
            if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 803
              tmp___32 = 1;
            } else {
#line 803
              if (__s2_len___0 >= 4U) {
#line 803
                tmp___32 = 1;
              } else {
#line 803
                tmp___32 = 0;
              }
            }
          } else {
#line 803
            tmp___32 = 0;
          }
        }
#line 803
        if (tmp___32) {
#line 803
          tmp___28 = __builtin_strcmp((char const   *)arg, "yes");
        } else {
#line 803
          tmp___31 = __builtin_strcmp((char const   *)arg, "yes");
#line 803
          tmp___28 = tmp___31;
        }
      } else {
#line 803
        tmp___31 = __builtin_strcmp((char const   *)arg, "yes");
#line 803
        tmp___28 = tmp___31;
      }
#line 803
      if (tmp___28 == 0) {
#line 804
        value = 3;
      } else {
#line 805
        if (0) {
#line 805
          __s1_len = strlen((char const   *)arg);
#line 805
          __s2_len = strlen("no");
#line 805
          if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
            goto _L___0;
          } else {
#line 805
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 805
              if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 805
                tmp___22 = 1;
              } else {
#line 805
                if (__s2_len >= 4U) {
#line 805
                  tmp___22 = 1;
                } else {
#line 805
                  tmp___22 = 0;
                }
              }
            } else {
#line 805
              tmp___22 = 0;
            }
          }
#line 805
          if (tmp___22) {
#line 805
            tmp___18 = __builtin_strcmp((char const   *)arg, "no");
          } else {
#line 805
            tmp___21 = __builtin_strcmp((char const   *)arg, "no");
#line 805
            tmp___18 = tmp___21;
          }
        } else {
#line 805
          tmp___21 = __builtin_strcmp((char const   *)arg, "no");
#line 805
          tmp___18 = tmp___21;
        }
#line 805
        if (tmp___18 == 0) {
#line 806
          value = 0;
        } else {
#line 808
          fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                filename, linenum, arg);
        }
      }
    }
  }
#line 811
  if (*activep) {
#line 811
    if (*intptr == -1) {
#line 812
      *intptr = value;
    }
  }
#line 813
  break;
  case 24: 
#line 816
  intptr = & options___0->ignore_rhosts;
  parse_flag: 
#line 818
  arg = strdelim(& cp);
#line 819
  if (! arg) {
#line 820
    fatal("%s line %d: missing yes/no argument.", filename, linenum);
  } else {
#line 819
    if ((int )*arg == 0) {
#line 820
      fatal("%s line %d: missing yes/no argument.", filename, linenum);
    }
  }
#line 822
  value = 0;
#line 823
  if (0) {
#line 823
    __s1_len___4 = strlen((char const   *)arg);
#line 823
    __s2_len___4 = strlen("yes");
#line 823
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___10;
    } else {
#line 823
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
#line 823
        if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 823
          tmp___72 = 1;
        } else {
#line 823
          if (__s2_len___4 >= 4U) {
#line 823
            tmp___72 = 1;
          } else {
#line 823
            tmp___72 = 0;
          }
        }
      } else {
#line 823
        tmp___72 = 0;
      }
    }
#line 823
    if (tmp___72) {
#line 823
      tmp___68 = __builtin_strcmp((char const   *)arg, "yes");
    } else {
#line 823
      tmp___71 = __builtin_strcmp((char const   *)arg, "yes");
#line 823
      tmp___68 = tmp___71;
    }
  } else {
#line 823
    tmp___71 = __builtin_strcmp((char const   *)arg, "yes");
#line 823
    tmp___68 = tmp___71;
  }
#line 823
  if (tmp___68 == 0) {
#line 824
    value = 1;
  } else {
#line 825
    if (0) {
#line 825
      __s1_len___3 = strlen((char const   *)arg);
#line 825
      __s2_len___3 = strlen("no");
#line 825
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___8;
      } else {
#line 825
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
#line 825
          if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 825
            tmp___62 = 1;
          } else {
#line 825
            if (__s2_len___3 >= 4U) {
#line 825
              tmp___62 = 1;
            } else {
#line 825
              tmp___62 = 0;
            }
          }
        } else {
#line 825
          tmp___62 = 0;
        }
      }
#line 825
      if (tmp___62) {
#line 825
        tmp___58 = __builtin_strcmp((char const   *)arg, "no");
      } else {
#line 825
        tmp___61 = __builtin_strcmp((char const   *)arg, "no");
#line 825
        tmp___58 = tmp___61;
      }
    } else {
#line 825
      tmp___61 = __builtin_strcmp((char const   *)arg, "no");
#line 825
      tmp___58 = tmp___61;
    }
#line 825
    if (tmp___58 == 0) {
#line 826
      value = 0;
    } else {
#line 828
      fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
    }
  }
#line 830
  if (*activep) {
#line 830
    if (*intptr == -1) {
#line 831
      *intptr = value;
    }
  }
#line 832
  break;
  case 39: 
#line 835
  intptr = & options___0->ignore_user_known_hosts;
  goto parse_flag;
  case 10: 
#line 839
  intptr = & options___0->rhosts_rsa_authentication;
  goto parse_flag;
  case 52: 
#line 843
  intptr = & options___0->hostbased_authentication;
  goto parse_flag;
  case 53: 
#line 847
  intptr = & options___0->hostbased_uses_name_from_packet_only;
  goto parse_flag;
  case 11: 
#line 851
  intptr = & options___0->rsa_authentication;
  goto parse_flag;
  case 45: 
#line 855
  intptr = & options___0->pubkey_authentication;
  goto parse_flag;
  case 12: 
#line 859
  intptr = & options___0->kerberos_authentication;
  goto parse_flag;
  case 13: 
#line 863
  intptr = & options___0->kerberos_or_local_passwd;
  goto parse_flag;
  case 14: 
#line 867
  intptr = & options___0->kerberos_ticket_cleanup;
  goto parse_flag;
  case 15: 
#line 871
  intptr = & options___0->kerberos_get_afs_token;
  goto parse_flag;
  case 58: 
#line 875
  intptr = & options___0->gss_authentication;
  goto parse_flag;
  case 59: 
#line 879
  intptr = & options___0->gss_cleanup_creds;
  goto parse_flag;
  case 18: 
#line 883
  intptr = & options___0->password_authentication;
  goto parse_flag;
  case 19: 
#line 887
  intptr = & options___0->kbd_interactive_authentication;
  goto parse_flag;
  case 17: 
#line 891
  intptr = & options___0->challenge_response_authentication;
  goto parse_flag;
  case 22: 
#line 895
  intptr = & options___0->print_motd;
  goto parse_flag;
  case 23: 
#line 899
  intptr = & options___0->print_lastlog;
  goto parse_flag;
  case 25: 
#line 903
  intptr = & options___0->x11_forwarding;
  goto parse_flag;
  case 26: 
#line 907
  intptr = & options___0->x11_display_offset;
  goto parse_int;
  case 27: 
#line 911
  intptr = & options___0->x11_use_localhost;
  goto parse_flag;
  case 46: 
#line 915
  charptr = & options___0->xauth_location;
  goto parse_filename;
  case 28: 
#line 919
  intptr = & options___0->strict_modes;
  goto parse_flag;
  case 30: 
#line 923
  intptr = & options___0->tcp_keep_alive;
  goto parse_flag;
  case 29: 
#line 927
  intptr = & options___0->permit_empty_passwd;
  goto parse_flag;
  case 31: 
#line 931
  intptr = & options___0->permit_user_env;
  goto parse_flag;
  case 32: 
#line 935
  intptr = & options___0->use_login;
  goto parse_flag;
  case 34: 
#line 939
  intptr = & options___0->compression;
#line 940
  arg = strdelim(& cp);
#line 941
  if (! arg) {
#line 942
    fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
  } else {
#line 941
    if ((int )*arg == 0) {
#line 942
      fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
    }
  }
#line 944
  value = 0;
#line 945
  if (0) {
#line 945
    __s1_len___7 = strlen((char const   *)arg);
#line 945
    __s2_len___7 = strlen("delayed");
#line 945
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___16;
    } else {
#line 945
      if (__s1_len___7 >= 4U) {
        _L___16: /* CIL Label */ 
#line 945
        if (! ((unsigned int )((void const   *)("delayed" + 1)) - (unsigned int )((void const   *)"delayed") == 1U)) {
#line 945
          tmp___102 = 1;
        } else {
#line 945
          if (__s2_len___7 >= 4U) {
#line 945
            tmp___102 = 1;
          } else {
#line 945
            tmp___102 = 0;
          }
        }
      } else {
#line 945
        tmp___102 = 0;
      }
    }
#line 945
    if (tmp___102) {
#line 945
      tmp___98 = __builtin_strcmp((char const   *)arg, "delayed");
    } else {
#line 945
      tmp___101 = __builtin_strcmp((char const   *)arg, "delayed");
#line 945
      tmp___98 = tmp___101;
    }
  } else {
#line 945
    tmp___101 = __builtin_strcmp((char const   *)arg, "delayed");
#line 945
    tmp___98 = tmp___101;
  }
#line 945
  if (tmp___98 == 0) {
#line 946
    value = 2;
  } else {
#line 947
    if (0) {
#line 947
      __s1_len___6 = strlen((char const   *)arg);
#line 947
      __s2_len___6 = strlen("yes");
#line 947
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___14;
      } else {
#line 947
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 947
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 947
            tmp___92 = 1;
          } else {
#line 947
            if (__s2_len___6 >= 4U) {
#line 947
              tmp___92 = 1;
            } else {
#line 947
              tmp___92 = 0;
            }
          }
        } else {
#line 947
          tmp___92 = 0;
        }
      }
#line 947
      if (tmp___92) {
#line 947
        tmp___88 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 947
        tmp___91 = __builtin_strcmp((char const   *)arg, "yes");
#line 947
        tmp___88 = tmp___91;
      }
    } else {
#line 947
      tmp___91 = __builtin_strcmp((char const   *)arg, "yes");
#line 947
      tmp___88 = tmp___91;
    }
#line 947
    if (tmp___88 == 0) {
#line 948
      value = 1;
    } else {
#line 949
      if (0) {
#line 949
        __s1_len___5 = strlen((char const   *)arg);
#line 949
        __s2_len___5 = strlen("no");
#line 949
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___12;
        } else {
#line 949
          if (__s1_len___5 >= 4U) {
            _L___12: /* CIL Label */ 
#line 949
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 949
              tmp___82 = 1;
            } else {
#line 949
              if (__s2_len___5 >= 4U) {
#line 949
                tmp___82 = 1;
              } else {
#line 949
                tmp___82 = 0;
              }
            }
          } else {
#line 949
            tmp___82 = 0;
          }
        }
#line 949
        if (tmp___82) {
#line 949
          tmp___78 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 949
          tmp___81 = __builtin_strcmp((char const   *)arg, "no");
#line 949
          tmp___78 = tmp___81;
        }
      } else {
#line 949
        tmp___81 = __builtin_strcmp((char const   *)arg, "no");
#line 949
        tmp___78 = tmp___81;
      }
#line 949
      if (tmp___78 == 0) {
#line 950
        value = 0;
      } else {
#line 952
        fatal("%s line %d: Bad yes/no/delayed argument: %s", filename, linenum, arg);
      }
    }
  }
#line 954
  if (*intptr == -1) {
#line 955
    *intptr = value;
  }
#line 956
  break;
  case 44: 
#line 959
  intptr = & options___0->gateway_ports;
#line 960
  arg = strdelim(& cp);
#line 961
  if (! arg) {
#line 962
    fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
  } else {
#line 961
    if ((int )*arg == 0) {
#line 962
      fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
    }
  }
#line 964
  value = 0;
#line 965
  if (0) {
#line 965
    __s1_len___10 = strlen((char const   *)arg);
#line 965
    __s2_len___10 = strlen("clientspecified");
#line 965
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___22;
    } else {
#line 965
      if (__s1_len___10 >= 4U) {
        _L___22: /* CIL Label */ 
#line 965
        if (! ((unsigned int )((void const   *)("clientspecified" + 1)) - (unsigned int )((void const   *)"clientspecified") == 1U)) {
#line 965
          tmp___132 = 1;
        } else {
#line 965
          if (__s2_len___10 >= 4U) {
#line 965
            tmp___132 = 1;
          } else {
#line 965
            tmp___132 = 0;
          }
        }
      } else {
#line 965
        tmp___132 = 0;
      }
    }
#line 965
    if (tmp___132) {
#line 965
      tmp___128 = __builtin_strcmp((char const   *)arg, "clientspecified");
    } else {
#line 965
      tmp___131 = __builtin_strcmp((char const   *)arg, "clientspecified");
#line 965
      tmp___128 = tmp___131;
    }
  } else {
#line 965
    tmp___131 = __builtin_strcmp((char const   *)arg, "clientspecified");
#line 965
    tmp___128 = tmp___131;
  }
#line 965
  if (tmp___128 == 0) {
#line 966
    value = 2;
  } else {
#line 967
    if (0) {
#line 967
      __s1_len___9 = strlen((char const   *)arg);
#line 967
      __s2_len___9 = strlen("yes");
#line 967
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___20;
      } else {
#line 967
        if (__s1_len___9 >= 4U) {
          _L___20: /* CIL Label */ 
#line 967
          if (! ((unsigned int )((void const   *)("yes" + 1)) - (unsigned int )((void const   *)"yes") == 1U)) {
#line 967
            tmp___122 = 1;
          } else {
#line 967
            if (__s2_len___9 >= 4U) {
#line 967
              tmp___122 = 1;
            } else {
#line 967
              tmp___122 = 0;
            }
          }
        } else {
#line 967
          tmp___122 = 0;
        }
      }
#line 967
      if (tmp___122) {
#line 967
        tmp___118 = __builtin_strcmp((char const   *)arg, "yes");
      } else {
#line 967
        tmp___121 = __builtin_strcmp((char const   *)arg, "yes");
#line 967
        tmp___118 = tmp___121;
      }
    } else {
#line 967
      tmp___121 = __builtin_strcmp((char const   *)arg, "yes");
#line 967
      tmp___118 = tmp___121;
    }
#line 967
    if (tmp___118 == 0) {
#line 968
      value = 1;
    } else {
#line 969
      if (0) {
#line 969
        __s1_len___8 = strlen((char const   *)arg);
#line 969
        __s2_len___8 = strlen("no");
#line 969
        if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
          goto _L___18;
        } else {
#line 969
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 969
            if (! ((unsigned int )((void const   *)("no" + 1)) - (unsigned int )((void const   *)"no") == 1U)) {
#line 969
              tmp___112 = 1;
            } else {
#line 969
              if (__s2_len___8 >= 4U) {
#line 969
                tmp___112 = 1;
              } else {
#line 969
                tmp___112 = 0;
              }
            }
          } else {
#line 969
            tmp___112 = 0;
          }
        }
#line 969
        if (tmp___112) {
#line 969
          tmp___108 = __builtin_strcmp((char const   *)arg, "no");
        } else {
#line 969
          tmp___111 = __builtin_strcmp((char const   *)arg, "no");
#line 969
          tmp___108 = tmp___111;
        }
      } else {
#line 969
        tmp___111 = __builtin_strcmp((char const   *)arg, "no");
#line 969
        tmp___108 = tmp___111;
      }
#line 969
      if (tmp___108 == 0) {
#line 970
        value = 0;
      } else {
#line 972
        fatal("%s line %d: Bad yes/no/clientspecified argument: %s", filename, linenum,
              arg);
      }
    }
  }
#line 974
  if (*activep) {
#line 974
    if (*intptr == -1) {
#line 975
      *intptr = value;
    }
  }
#line 976
  break;
  case 51: 
#line 979
  intptr = & options___0->use_dns;
  goto parse_flag;
  case 8: 
#line 983
  log_facility_ptr = & options___0->log_facility;
#line 984
  arg = strdelim(& cp);
#line 985
  tmp___133 = log_facility_number(arg);
#line 985
  value = (int )tmp___133;
#line 986
  if (value == -1) {
#line 987
    if (arg) {
#line 987
      tmp___134 = (char const   *)arg;
    } else {
#line 987
      tmp___134 = "<NONE>";
    }
#line 987
    fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum, tmp___134);
  }
#line 989
  if ((int )*log_facility_ptr == -1) {
#line 990
    *log_facility_ptr = (int )value;
  }
#line 991
  break;
  case 9: 
#line 994
  log_level_ptr = & options___0->log_level;
#line 995
  arg = strdelim(& cp);
#line 996
  tmp___135 = log_level_number(arg);
#line 996
  value = (int )tmp___135;
#line 997
  if (value == -1) {
#line 998
    if (arg) {
#line 998
      tmp___136 = (char const   *)arg;
    } else {
#line 998
      tmp___136 = "<NONE>";
    }
#line 998
    fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___136);
  }
#line 1000
  if ((int )*log_level_ptr == -1) {
#line 1001
    *log_level_ptr = (enum __anonenum_LogLevel_51 )value;
  }
#line 1002
  break;
  case 33: 
#line 1005
  intptr = & options___0->allow_tcp_forwarding;
  goto parse_flag;
  case 66: 
#line 1009
  intptr = & use_privsep;
  goto parse_flag;
  case 35: 
#line 1013
  while (1) {
#line 1013
    arg = strdelim(& cp);
#line 1013
    if (arg) {
#line 1013
      if (! ((int )*arg != 0)) {
#line 1013
        break;
      }
    } else {
#line 1013
      break;
    }
#line 1014
    if (options___0->num_allow_users >= 256U) {
#line 1015
      fatal("%s line %d: too many allow users.", filename, linenum);
    }
#line 1017
    tmp___137 = options___0->num_allow_users;
#line 1017
    (options___0->num_allow_users) ++;
#line 1017
    options___0->allow_users[tmp___137] = xstrdup((char const   *)arg);
  }
#line 1020
  break;
  case 36: 
#line 1023
  while (1) {
#line 1023
    arg = strdelim(& cp);
#line 1023
    if (arg) {
#line 1023
      if (! ((int )*arg != 0)) {
#line 1023
        break;
      }
    } else {
#line 1023
      break;
    }
#line 1024
    if (options___0->num_deny_users >= 256U) {
#line 1025
      fatal("%s line %d: too many deny users.", filename, linenum);
    }
#line 1027
    tmp___138 = options___0->num_deny_users;
#line 1027
    (options___0->num_deny_users) ++;
#line 1027
    options___0->deny_users[tmp___138] = xstrdup((char const   *)arg);
  }
#line 1030
  break;
  case 37: 
#line 1033
  while (1) {
#line 1033
    arg = strdelim(& cp);
#line 1033
    if (arg) {
#line 1033
      if (! ((int )*arg != 0)) {
#line 1033
        break;
      }
    } else {
#line 1033
      break;
    }
#line 1034
    if (options___0->num_allow_groups >= 256U) {
#line 1035
      fatal("%s line %d: too many allow groups.", filename, linenum);
    }
#line 1037
    tmp___139 = options___0->num_allow_groups;
#line 1037
    (options___0->num_allow_groups) ++;
#line 1037
    options___0->allow_groups[tmp___139] = xstrdup((char const   *)arg);
  }
#line 1040
  break;
  case 38: 
#line 1043
  while (1) {
#line 1043
    arg = strdelim(& cp);
#line 1043
    if (arg) {
#line 1043
      if (! ((int )*arg != 0)) {
#line 1043
        break;
      }
    } else {
#line 1043
      break;
    }
#line 1044
    if (options___0->num_deny_groups >= 256U) {
#line 1045
      fatal("%s line %d: too many deny groups.", filename, linenum);
    }
#line 1047
    tmp___140 = options___0->num_deny_groups;
#line 1047
    (options___0->num_deny_groups) ++;
#line 1047
    options___0->deny_groups[tmp___140] = xstrdup((char const   *)arg);
  }
#line 1049
  break;
  case 40: 
#line 1052
  arg = strdelim(& cp);
#line 1053
  if (! arg) {
#line 1054
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 1053
    if ((int )*arg == 0) {
#line 1054
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 1055
  tmp___142 = ciphers_valid((char const   *)arg);
#line 1055
  if (! tmp___142) {
#line 1056
    if (arg) {
#line 1056
      tmp___141 = (char const   *)arg;
    } else {
#line 1056
      tmp___141 = "<NONE>";
    }
#line 1056
    fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___141);
  }
#line 1058
  if ((unsigned int )options___0->ciphers == (unsigned int )((void *)0)) {
#line 1059
    options___0->ciphers = xstrdup((char const   *)arg);
  }
#line 1060
  break;
  case 41: 
#line 1063
  arg = strdelim(& cp);
#line 1064
  if (! arg) {
#line 1065
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 1064
    if ((int )*arg == 0) {
#line 1065
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 1066
  tmp___144 = mac_valid((char const   *)arg);
#line 1066
  if (! tmp___144) {
#line 1067
    if (arg) {
#line 1067
      tmp___143 = (char const   *)arg;
    } else {
#line 1067
      tmp___143 = "<NONE>";
    }
#line 1067
    fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___143);
  }
#line 1069
  if ((unsigned int )options___0->macs == (unsigned int )((void *)0)) {
#line 1070
    options___0->macs = xstrdup((char const   *)arg);
  }
#line 1071
  break;
  case 42: 
#line 1074
  intptr = & options___0->protocol;
#line 1075
  arg = strdelim(& cp);
#line 1076
  if (! arg) {
#line 1077
    fatal("%s line %d: Missing argument.", filename, linenum);
  } else {
#line 1076
    if ((int )*arg == 0) {
#line 1077
      fatal("%s line %d: Missing argument.", filename, linenum);
    }
  }
#line 1078
  value = proto_spec((char const   *)arg);
#line 1079
  if (value == 0) {
#line 1080
    if (arg) {
#line 1080
      tmp___145 = (char const   *)arg;
    } else {
#line 1080
      tmp___145 = "<NONE>";
    }
#line 1080
    fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___145);
  }
#line 1082
  if (*intptr == 0) {
#line 1083
    *intptr = value;
  }
#line 1084
  break;
  case 47: 
#line 1087
  if (options___0->num_subsystems >= 256U) {
#line 1088
    fatal("%s line %d: too many subsystems defined.", filename, linenum);
  }
#line 1091
  arg = strdelim(& cp);
#line 1092
  if (! arg) {
#line 1093
    fatal("%s line %d: Missing subsystem name.", filename, linenum);
  } else {
#line 1092
    if ((int )*arg == 0) {
#line 1093
      fatal("%s line %d: Missing subsystem name.", filename, linenum);
    }
  }
#line 1095
  if (! *activep) {
#line 1096
    arg = strdelim(& cp);
#line 1097
    break;
  }
#line 1099
  i = 0U;
#line 1099
  while (i < options___0->num_subsystems) {
#line 1100
    if (0) {
#line 1100
      __s1_len___11 = strlen((char const   *)arg);
#line 1100
      __s2_len___11 = strlen((char const   *)options___0->subsystem_name[i]);
#line 1100
      if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
        goto _L___24;
      } else {
#line 1100
        if (__s1_len___11 >= 4U) {
          _L___24: /* CIL Label */ 
#line 1100
          if (! ((unsigned int )((void const   *)(options___0->subsystem_name[i] + 1)) - (unsigned int )((void const   *)options___0->subsystem_name[i]) == 1U)) {
#line 1100
            tmp___155 = 1;
          } else {
#line 1100
            if (__s2_len___11 >= 4U) {
#line 1100
              tmp___155 = 1;
            } else {
#line 1100
              tmp___155 = 0;
            }
          }
        } else {
#line 1100
          tmp___155 = 0;
        }
      }
#line 1100
      if (tmp___155) {
#line 1100
        tmp___151 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
      } else {
#line 1100
        tmp___154 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 1100
        tmp___151 = tmp___154;
      }
    } else {
#line 1100
      tmp___154 = __builtin_strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
#line 1100
      tmp___151 = tmp___154;
    }
#line 1100
    if (tmp___151 == 0) {
#line 1101
      fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum, arg);
    }
#line 1099
    i ++;
  }
#line 1103
  options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 1104
  arg = strdelim(& cp);
#line 1105
  if (! arg) {
#line 1106
    fatal("%s line %d: Missing subsystem command.", filename, linenum);
  } else {
#line 1105
    if ((int )*arg == 0) {
#line 1106
      fatal("%s line %d: Missing subsystem command.", filename, linenum);
    }
  }
#line 1108
  options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
#line 1111
  p = xstrdup((char const   *)arg);
#line 1112
  tmp___156 = strlen((char const   *)p);
#line 1112
  len = tmp___156 + 1U;
#line 1113
  while (1) {
#line 1113
    arg = strdelim(& cp);
#line 1113
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 1113
      if (! ((int )*arg != 0)) {
#line 1113
        break;
      }
    } else {
#line 1113
      break;
    }
#line 1114
    tmp___157 = strlen((char const   *)arg);
#line 1114
    len += 1U + tmp___157;
#line 1115
    tmp___158 = xrealloc((void *)p, 1U, len);
#line 1115
    p = (char *)tmp___158;
#line 1116
    strlcat(p, " ", len);
#line 1117
    strlcat(p, (char const   *)arg, len);
  }
#line 1119
  options___0->subsystem_args[options___0->num_subsystems] = p;
#line 1120
  (options___0->num_subsystems) ++;
#line 1121
  break;
  case 48: 
#line 1124
  arg = strdelim(& cp);
#line 1125
  if (! arg) {
#line 1126
    fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
  } else {
#line 1125
    if ((int )*arg == 0) {
#line 1126
      fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    }
  }
#line 1128
  n___0 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"%d:%d:%d",
                 & options___0->max_startups_begin, & options___0->max_startups_rate,
                 & options___0->max_startups);
#line 1128
  if (n___0 == 3) {
#line 1132
    if (options___0->max_startups_begin > options___0->max_startups) {
#line 1136
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 1132
      if (options___0->max_startups_rate > 100) {
#line 1136
        fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      } else {
#line 1132
        if (options___0->max_startups_rate < 1) {
#line 1136
          fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
        }
      }
    }
  } else {
#line 1138
    if (n___0 != 1) {
#line 1139
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    } else {
#line 1142
      options___0->max_startups = options___0->max_startups_begin;
    }
  }
#line 1143
  break;
  case 49: 
#line 1146
  intptr = & options___0->max_authtries;
  goto parse_int;
  case 50: 
#line 1150
  charptr = & options___0->banner;
  goto parse_filename;
  case 56: 
  case 57: 
#line 1161
  if ((int )opcode == 56) {
#line 1161
    charptr = & options___0->authorized_keys_file;
  } else {
#line 1161
    charptr = & options___0->authorized_keys_file2;
  }
  goto parse_filename;
  case 54: 
#line 1167
  intptr = & options___0->client_alive_interval;
  goto parse_time;
  case 55: 
#line 1171
  intptr = & options___0->client_alive_count_max;
  goto parse_int;
  case 60: 
#line 1175
  while (1) {
#line 1175
    arg = strdelim(& cp);
#line 1175
    if (arg) {
#line 1175
      if (! ((int )*arg != 0)) {
#line 1175
        break;
      }
    } else {
#line 1175
      break;
    }
#line 1176
    tmp___160 = __builtin_strchr(arg, '=');
#line 1176
    if ((unsigned int )tmp___160 != (unsigned int )((void *)0)) {
#line 1177
      fatal("%s line %d: Invalid environment name.", filename, linenum);
    }
#line 1179
    if (options___0->num_accept_env >= 256U) {
#line 1180
      fatal("%s line %d: too many allow env.", filename, linenum);
    }
#line 1182
    if (! *activep) {
#line 1183
      break;
    }
#line 1184
    tmp___161 = options___0->num_accept_env;
#line 1184
    (options___0->num_accept_env) ++;
#line 1184
    options___0->accept_env[tmp___161] = xstrdup((char const   *)arg);
  }
#line 1187
  break;
  case 61: 
#line 1190
  intptr = & options___0->permit_tun;
#line 1191
  arg = strdelim(& cp);
#line 1192
  if (! arg) {
#line 1193
    fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
          linenum);
  } else {
#line 1192
    if ((int )*arg == 0) {
#line 1193
      fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
            linenum);
    }
  }
#line 1195
  value = 0;
#line 1196
  tmp___165 = strcasecmp((char const   *)arg, "ethernet");
#line 1196
  if (tmp___165 == 0) {
#line 1197
    value = 2;
  } else {
#line 1198
    tmp___164 = strcasecmp((char const   *)arg, "point-to-point");
#line 1198
    if (tmp___164 == 0) {
#line 1199
      value = 1;
    } else {
#line 1200
      tmp___163 = strcasecmp((char const   *)arg, "yes");
#line 1200
      if (tmp___163 == 0) {
#line 1201
        value = 3;
      } else {
#line 1202
        tmp___162 = strcasecmp((char const   *)arg, "no");
#line 1202
        if (tmp___162 == 0) {
#line 1203
          value = 0;
        } else {
#line 1205
          fatal("%s line %d: Bad yes/point-to-point/ethernet/no argument: %s", filename,
                linenum, arg);
        }
      }
    }
  }
#line 1207
  if (*intptr == -1) {
#line 1208
    *intptr = value;
  }
#line 1209
  break;
  case 62: 
#line 1212
  if (cmdline) {
#line 1213
    fatal("Match directive not supported as a command-line option");
  }
#line 1215
  value = match_cfg_line(& cp, linenum, user, host, address);
#line 1216
  if (value < 0) {
#line 1217
    fatal("%s line %d: Bad Match condition", filename, linenum);
  }
#line 1219
  *activep = value;
#line 1220
  break;
  case 63: 
#line 1223
  arg = strdelim(& cp);
#line 1224
  if (! arg) {
#line 1225
    fatal("%s line %d: missing PermitOpen specification", filename, linenum);
  } else {
#line 1224
    if ((int )*arg == 0) {
#line 1225
      fatal("%s line %d: missing PermitOpen specification", filename, linenum);
    }
  }
#line 1227
  n___0 = options___0->num_permitted_opens;
#line 1228
  if (0) {
#line 1228
    __s1_len___12 = strlen((char const   *)arg);
#line 1228
    __s2_len___12 = strlen("any");
#line 1228
    if (! ((unsigned int )((void const   *)(arg + 1)) - (unsigned int )((void const   *)arg) == 1U)) {
      goto _L___26;
    } else {
#line 1228
      if (__s1_len___12 >= 4U) {
        _L___26: /* CIL Label */ 
#line 1228
        if (! ((unsigned int )((void const   *)("any" + 1)) - (unsigned int )((void const   *)"any") == 1U)) {
#line 1228
          tmp___175 = 1;
        } else {
#line 1228
          if (__s2_len___12 >= 4U) {
#line 1228
            tmp___175 = 1;
          } else {
#line 1228
            tmp___175 = 0;
          }
        }
      } else {
#line 1228
        tmp___175 = 0;
      }
    }
#line 1228
    if (tmp___175) {
#line 1228
      tmp___171 = __builtin_strcmp((char const   *)arg, "any");
    } else {
#line 1228
      tmp___174 = __builtin_strcmp((char const   *)arg, "any");
#line 1228
      tmp___171 = tmp___174;
    }
  } else {
#line 1228
    tmp___174 = __builtin_strcmp((char const   *)arg, "any");
#line 1228
    tmp___171 = tmp___174;
  }
#line 1228
  if (tmp___171 == 0) {
#line 1229
    if (*activep) {
#line 1229
      if (n___0 == -1) {
#line 1230
        channel_clear_adm_permitted_opens();
#line 1231
        options___0->num_permitted_opens = 0;
      }
    }
#line 1233
    break;
  }
#line 1235
  if (*activep) {
#line 1235
    if (n___0 == -1) {
#line 1236
      channel_clear_adm_permitted_opens();
    }
  }
#line 1237
  while (1) {
#line 1237
    if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 1237
      if (! ((int )*arg != 0)) {
#line 1237
        break;
      }
    } else {
#line 1237
      break;
    }
#line 1238
    p = hpdelim(& arg);
#line 1239
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1240
      fatal("%s line %d: missing host in PermitOpen", filename, linenum);
    }
#line 1242
    p = cleanhostname(p);
#line 1243
    if ((unsigned int )arg == (unsigned int )((void *)0)) {
#line 1244
      fatal("%s line %d: bad port number in PermitOpen", filename, linenum);
    } else {
#line 1243
      tmp___176 = a2port((char const   *)arg);
#line 1243
      port___0 = (unsigned short )tmp___176;
#line 1243
      if ((int )port___0 == 0) {
#line 1244
        fatal("%s line %d: bad port number in PermitOpen", filename, linenum);
      }
    }
#line 1246
    if (*activep) {
#line 1246
      if (n___0 == -1) {
#line 1247
        options___0->num_permitted_opens = channel_add_adm_permitted_opens(p, (int )port___0);
      }
    }
#line 1237
    arg = strdelim(& cp);
  }
#line 1250
  break;
  case 64: 
#line 1253
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1254
    fatal("%.200s line %d: Missing argument.", filename, linenum);
  }
#line 1256
  tmp___208 = __builtin_strspn((char const   *)cp, " \t\r\n");
#line 1256
  len = tmp___208;
#line 1257
  if (*activep) {
#line 1257
    if ((unsigned int )options___0->adm_forced_command == (unsigned int )((void *)0)) {
#line 1258
      options___0->adm_forced_command = xstrdup((char const   *)(cp + len));
    }
  }
#line 1259
  return (0);
  case 65: 
#line 1262
  charptr = & options___0->chroot_directory;
#line 1264
  arg = strdelim(& cp);
#line 1265
  if (! arg) {
#line 1266
    fatal("%s line %d: missing file name.", filename, linenum);
  } else {
#line 1265
    if ((int )*arg == 0) {
#line 1266
      fatal("%s line %d: missing file name.", filename, linenum);
    }
  }
#line 1268
  if (*activep) {
#line 1268
    if ((unsigned int )*charptr == (unsigned int )((void *)0)) {
#line 1269
      *charptr = xstrdup((char const   *)arg);
    }
  }
#line 1270
  break;
  case 67: 
#line 1273
  logit("%s line %d: Deprecated option %s", filename, linenum, arg);
#line 1275
  while (arg) {
#line 1276
    arg = strdelim(& cp);
  }
#line 1277
  break;
  case 68: 
#line 1280
  logit("%s line %d: Unsupported option %s", filename, linenum, arg);
#line 1282
  while (arg) {
#line 1283
    arg = strdelim(& cp);
  }
#line 1284
  break;
  default: 
#line 1287
  fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
        opcode);
  }
#line 1290
  arg = strdelim(& cp);
#line 1290
  if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 1290
    if ((int )*arg != 0) {
#line 1291
      fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
            arg);
    }
  }
#line 1293
  return (0);
}
}
#line 1298 "servconf.c"
void load_server_config(char const   *filename , Buffer *conf ) 
{ char line[1024] ;
  char *cp ;
  FILE *f ;
  char *tmp___0 ;
  unsigned int tmp___32 ;
  size_t tmp___33 ;
  char *tmp___34 ;
  u_int tmp___35 ;

  {
#line 1304
  debug2("%s: filename %s", "load_server_config", filename);
#line 1305
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 1305
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 1306
    perror(filename);
#line 1307
    exit(1);
  }
#line 1309
  buffer_clear(conf);
#line 1310
  while (1) {
#line 1310
    tmp___34 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )f);
#line 1310
    if (! tmp___34) {
#line 1310
      break;
    }
#line 1316
    tmp___0 = __builtin_strchr(line, '#');
#line 1316
    cp = tmp___0;
#line 1316
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1317
      memcpy((void * __restrict  )cp, (void const   * __restrict  )"\n", 2U);
    }
#line 1318
    tmp___32 = __builtin_strspn((char const   *)(line), " \t\r");
#line 1318
    cp = line + tmp___32;
#line 1320
    tmp___33 = strlen((char const   *)cp);
#line 1320
    buffer_append(conf, (void const   *)cp, tmp___33);
  }
#line 1322
  buffer_append(conf, (void const   *)"\000", 1U);
#line 1323
  fclose(f);
#line 1324
  tmp___35 = buffer_len(conf);
#line 1324
  debug2("%s: done config len = %d", "load_server_config", tmp___35);
#line 1325
  return;
}
}
#line 1327 "servconf.c"
void parse_server_match_config(ServerOptions *options___0 , char const   *user , char const   *host ,
                               char const   *address ) 
{ ServerOptions mo ;

  {
#line 1333
  initialize_server_options(& mo);
#line 1334
  parse_server_config(& mo, "reprocess config", & cfg, user, host, address);
#line 1335
  copy_set_server_options(options___0, & mo, 0);
#line 1336
  return;
}
}
#line 1358 "servconf.c"
void copy_set_server_options(ServerOptions *dst , ServerOptions *src , int preauth ) 
{ 

  {
#line 1361
  while (1) {
#line 1361
    if (src->password_authentication != -1) {
#line 1361
      dst->password_authentication = src->password_authentication;
    }
#line 1361
    break;
  }
#line 1362
  while (1) {
#line 1362
    if (src->gss_authentication != -1) {
#line 1362
      dst->gss_authentication = src->gss_authentication;
    }
#line 1362
    break;
  }
#line 1363
  while (1) {
#line 1363
    if (src->rsa_authentication != -1) {
#line 1363
      dst->rsa_authentication = src->rsa_authentication;
    }
#line 1363
    break;
  }
#line 1364
  while (1) {
#line 1364
    if (src->pubkey_authentication != -1) {
#line 1364
      dst->pubkey_authentication = src->pubkey_authentication;
    }
#line 1364
    break;
  }
#line 1365
  while (1) {
#line 1365
    if (src->kerberos_authentication != -1) {
#line 1365
      dst->kerberos_authentication = src->kerberos_authentication;
    }
#line 1365
    break;
  }
#line 1366
  while (1) {
#line 1366
    if (src->hostbased_authentication != -1) {
#line 1366
      dst->hostbased_authentication = src->hostbased_authentication;
    }
#line 1366
    break;
  }
#line 1367
  while (1) {
#line 1367
    if (src->kbd_interactive_authentication != -1) {
#line 1367
      dst->kbd_interactive_authentication = src->kbd_interactive_authentication;
    }
#line 1367
    break;
  }
#line 1368
  while (1) {
#line 1368
    if (src->permit_root_login != -1) {
#line 1368
      dst->permit_root_login = src->permit_root_login;
    }
#line 1368
    break;
  }
#line 1370
  while (1) {
#line 1370
    if (src->allow_tcp_forwarding != -1) {
#line 1370
      dst->allow_tcp_forwarding = src->allow_tcp_forwarding;
    }
#line 1370
    break;
  }
#line 1371
  while (1) {
#line 1371
    if (src->gateway_ports != -1) {
#line 1371
      dst->gateway_ports = src->gateway_ports;
    }
#line 1371
    break;
  }
#line 1372
  while (1) {
#line 1372
    if (src->x11_display_offset != -1) {
#line 1372
      dst->x11_display_offset = src->x11_display_offset;
    }
#line 1372
    break;
  }
#line 1373
  while (1) {
#line 1373
    if (src->x11_forwarding != -1) {
#line 1373
      dst->x11_forwarding = src->x11_forwarding;
    }
#line 1373
    break;
  }
#line 1374
  while (1) {
#line 1374
    if (src->x11_use_localhost != -1) {
#line 1374
      dst->x11_use_localhost = src->x11_use_localhost;
    }
#line 1374
    break;
  }
#line 1376
  while (1) {
#line 1376
    if ((unsigned int )src->banner != (unsigned int )((void *)0)) {
#line 1376
      if ((unsigned int )dst->banner != (unsigned int )((void *)0)) {
#line 1376
        xfree((void *)dst->banner);
      }
#line 1376
      dst->banner = src->banner;
    }
#line 1376
    break;
  }
#line 1377
  if (preauth) {
#line 1378
    return;
  }
#line 1379
  while (1) {
#line 1379
    if ((unsigned int )src->adm_forced_command != (unsigned int )((void *)0)) {
#line 1379
      if ((unsigned int )dst->adm_forced_command != (unsigned int )((void *)0)) {
#line 1379
        xfree((void *)dst->adm_forced_command);
      }
#line 1379
      dst->adm_forced_command = src->adm_forced_command;
    }
#line 1379
    break;
  }
#line 1380
  while (1) {
#line 1380
    if ((unsigned int )src->chroot_directory != (unsigned int )((void *)0)) {
#line 1380
      if ((unsigned int )dst->chroot_directory != (unsigned int )((void *)0)) {
#line 1380
        xfree((void *)dst->chroot_directory);
      }
#line 1380
      dst->chroot_directory = src->chroot_directory;
    }
#line 1380
    break;
  }
#line 1381
  return;
}
}
#line 1386 "servconf.c"
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ,
                         char const   *user , char const   *host , char const   *address ) 
{ int active ;
  int linenum ;
  int bad_options ;
  char *cp ;
  char *obuf ;
  char *cbuf ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___18 ;

  {
#line 1390
  bad_options = 0;
#line 1393
  tmp = buffer_len(conf);
#line 1393
  debug2("%s: config %s len %d", "parse_server_config", filename, tmp);
#line 1395
  tmp___0 = buffer_ptr(conf);
#line 1395
  cbuf = xstrdup((char const   *)tmp___0);
#line 1395
  obuf = cbuf;
#line 1396
  if (user) {
#line 1396
    active = 0;
  } else {
#line 1396
    active = 1;
  }
#line 1397
  linenum = 1;
#line 1398
  while (1) {
#line 1398
    tmp___18 = __strsep_g(& cbuf, "\n");
#line 1398
    cp = tmp___18;
#line 1398
    if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 1398
      break;
    }
#line 1399
    tmp___1 = linenum;
#line 1399
    linenum ++;
#line 1399
    tmp___2 = process_server_config_line(options___0, cp, filename, tmp___1, & active,
                                         user, host, address);
#line 1399
    if (tmp___2 != 0) {
#line 1401
      bad_options ++;
    }
  }
#line 1403
  xfree((void *)obuf);
#line 1404
  if (bad_options > 0) {
#line 1405
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
  }
#line 1407
  return;
}
}
#line 1 "serverloop.o"
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 67 "session.h"
int session_open(Authctxt *authctxt___0 , int chanid ) ;
#line 68
int session_input_channel_req(Channel *c , char const   *rtype ) ;
#line 69
void session_close_by_pid(pid_t pid , int status ) ;
#line 70
void session_close_by_channel(int id , void *arg ) ;
#line 71
void session_destroy_all(void (*closefunc)(Session * ) ) ;
#line 32 "auth-options.h"
int forced_tun_device ;
#line 24 "serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 25
void server_loop2(Authctxt *authctxt___0 ) ;
#line 88 "serverloop.c"
static Buffer stdin_buffer  ;
#line 89 "serverloop.c"
static Buffer stdout_buffer  ;
#line 90 "serverloop.c"
static Buffer stderr_buffer  ;
#line 91 "serverloop.c"
static int fdin  ;
#line 92 "serverloop.c"
static int fdout  ;
#line 94 "serverloop.c"
static int fderr  ;
#line 95 "serverloop.c"
static long stdin_bytes  =    0L;
#line 96 "serverloop.c"
static long stdout_bytes  =    0L;
#line 97 "serverloop.c"
static long stderr_bytes  =    0L;
#line 98 "serverloop.c"
static long fdout_bytes  =    0L;
#line 99 "serverloop.c"
static int stdin_eof  =    0;
#line 100 "serverloop.c"
static int fdout_eof  =    0;
#line 101 "serverloop.c"
static int fderr_eof  =    0;
#line 102 "serverloop.c"
static int fdin_is_tty  =    0;
#line 103 "serverloop.c"
static int connection_in___0  ;
#line 104 "serverloop.c"
static int connection_out___0  ;
#line 105 "serverloop.c"
static int connection_closed  =    0;
#line 106 "serverloop.c"
static u_int buffer_high  ;
#line 113 "serverloop.c"
static int volatile   child_terminated  =    (sig_atomic_t volatile   )0;
#line 116 "serverloop.c"
static int volatile   received_sigterm___0  =    (sig_atomic_t volatile   )0;
#line 119
static void server_init_dispatch(void) ;
#line 125 "serverloop.c"
static int notify_pipe[2]  ;
#line 126 "serverloop.c"
static void notify_setup(void) 
{ int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 129
  tmp___5 = pipe((int *)(notify_pipe));
#line 129
  if (tmp___5 < 0) {
#line 130
    tmp = __errno_location();
#line 130
    tmp___0 = strerror(*tmp);
#line 130
    error("pipe(notify_pipe) failed %s", tmp___0);
  } else {
#line 131
    tmp___3 = fcntl(notify_pipe[0], 2, 1);
#line 131
    if (tmp___3 == -1) {
#line 133
      tmp___1 = __errno_location();
#line 133
      tmp___2 = strerror(*tmp___1);
#line 133
      error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 134
      close(notify_pipe[0]);
#line 135
      close(notify_pipe[1]);
    } else {
#line 131
      tmp___4 = fcntl(notify_pipe[1], 2, 1);
#line 131
      if (tmp___4 == -1) {
#line 133
        tmp___1 = __errno_location();
#line 133
        tmp___2 = strerror(*tmp___1);
#line 133
        error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
#line 134
        close(notify_pipe[0]);
#line 135
        close(notify_pipe[1]);
      } else {
#line 137
        set_nonblock(notify_pipe[0]);
#line 138
        set_nonblock(notify_pipe[1]);
#line 139
        return;
      }
    }
  }
#line 141
  notify_pipe[0] = -1;
#line 142
  notify_pipe[1] = -1;
#line 143
  return;
}
}
#line 144 "serverloop.c"
static void notify_parent(void) 
{ 

  {
#line 147
  if (notify_pipe[1] != -1) {
#line 148
    write(notify_pipe[1], (void const   *)"", 1U);
  }
#line 149
  return;
}
}
#line 150 "serverloop.c"
static void notify_prepare(fd_set *readset ) 
{ 

  {
#line 153
  if (notify_pipe[0] != -1) {
#line 154
    __asm__  volatile   ("btsl %1,%0": "=m" (readset->fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 155
  return;
}
}
#line 156 "serverloop.c"
static void notify_done(fd_set *readset ) 
{ char c ;
  ssize_t tmp ;
  register char __result ;

  {
#line 161
  if (notify_pipe[0] != -1) {
#line 161
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )notify_pipe[0] % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )notify_pipe[0] / (8U * sizeof(__fd_mask ))]): "cc");
#line 161
    if (__result) {
#line 162
      while (1) {
#line 162
        tmp = read(notify_pipe[0], (void *)(& c), 1U);
#line 162
        if (! (tmp != -1)) {
#line 162
          break;
        }
#line 163
        debug2("notify_done: reading");
      }
    }
  }
#line 164
  return;
}
}
#line 167 "serverloop.c"
static void sigchld_handler(int sig ) 
{ int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 170
  tmp = __errno_location();
#line 170
  save_errno = *tmp;
#line 171
  child_terminated = (int volatile   )1;
#line 173
  mysignal(17, & sigchld_handler);
#line 175
  notify_parent();
#line 176
  tmp___0 = __errno_location();
#line 176
  *tmp___0 = save_errno;
#line 177
  return;
}
}
#line 180 "serverloop.c"
static void sigterm_handler___0(int sig ) 
{ 

  {
#line 183
  received_sigterm___0 = (int volatile   )sig;
#line 184
  return;
}
}
#line 190 "serverloop.c"
static void make_packets_from_stderr_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 196
  while (1) {
#line 196
    tmp___1 = buffer_len(& stderr_buffer);
#line 196
    if (tmp___1 > 0U) {
#line 196
      tmp___2 = packet_not_very_much_data_to_write();
#line 196
      if (! tmp___2) {
#line 196
        break;
      }
    } else {
#line 196
      break;
    }
#line 198
    len = buffer_len(& stderr_buffer);
#line 199
    tmp = packet_is_interactive();
#line 199
    if (tmp) {
#line 200
      if (len > 512U) {
#line 201
        len = 512U;
      }
    } else {
#line 204
      if (len > max_packet_size) {
#line 205
        len = max_packet_size;
      }
    }
#line 207
    packet_start((unsigned char)18);
#line 208
    tmp___0 = buffer_ptr(& stderr_buffer);
#line 208
    packet_put_string((void const   *)tmp___0, len);
#line 209
    packet_send();
#line 210
    buffer_consume(& stderr_buffer, len);
#line 211
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )len);
  }
#line 213
  return;
}
}
#line 219 "serverloop.c"
static void make_packets_from_stdout_data(void) 
{ u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 225
  while (1) {
#line 225
    tmp___1 = buffer_len(& stdout_buffer);
#line 225
    if (tmp___1 > 0U) {
#line 225
      tmp___2 = packet_not_very_much_data_to_write();
#line 225
      if (! tmp___2) {
#line 225
        break;
      }
    } else {
#line 225
      break;
    }
#line 227
    len = buffer_len(& stdout_buffer);
#line 228
    tmp = packet_is_interactive();
#line 228
    if (tmp) {
#line 229
      if (len > 512U) {
#line 230
        len = 512U;
      }
    } else {
#line 233
      if (len > max_packet_size) {
#line 234
        len = max_packet_size;
      }
    }
#line 236
    packet_start((unsigned char)17);
#line 237
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 237
    packet_put_string((void const   *)tmp___0, len);
#line 238
    packet_send();
#line 239
    buffer_consume(& stdout_buffer, len);
#line 240
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )len);
  }
#line 242
  return;
}
}
#line 244 "serverloop.c"
static void client_alive_check(void) 
{ int channel_id ;

  {
#line 250
  keep_alive_timeouts ++;
#line 250
  if (keep_alive_timeouts > options.client_alive_count_max) {
#line 251
    logit("Timeout, client not responding.");
#line 252
    cleanup_exit(255);
  }
#line 259
  channel_id = channel_find_open();
#line 259
  if (channel_id == -1) {
#line 260
    packet_start((unsigned char)80);
#line 261
    packet_put_cstring("keepalive@openssh.com");
#line 262
    packet_put_char(1);
  } else {
#line 264
    channel_request_start(channel_id, (char *)"keepalive@openssh.com", 1);
  }
#line 266
  packet_send();
#line 267
  return;
}
}
#line 275 "serverloop.c"
static void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                        u_int *nallocp , u_int max_time_milliseconds ) 
{ struct timeval tv___0 ;
  struct timeval *tvp ;
  int ret___0 ;
  int client_alive_scheduled ;
  int program_alive_scheduled ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
#line 281
  client_alive_scheduled = 0;
#line 282
  program_alive_scheduled = 0;
#line 292
  if (compat20) {
#line 292
    if (max_time_milliseconds == 0U) {
#line 292
      if (options.client_alive_interval) {
#line 294
        client_alive_scheduled = 1;
#line 295
        max_time_milliseconds = (unsigned int )(options.client_alive_interval * 1000);
      }
    }
  }
#line 299
  channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
#line 301
  if (compat20) {
#line 306
    __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  } else {
#line 312
    tmp = buffer_len(& stdin_buffer);
#line 312
    if (tmp < buffer_high) {
#line 312
      tmp___0 = channel_not_very_much_buffered_data();
#line 312
      if (tmp___0) {
#line 314
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 319
    tmp___1 = packet_not_very_much_data_to_write();
#line 319
    if (tmp___1) {
#line 320
      program_alive_scheduled = (int )child_terminated;
#line 321
      if (! fdout_eof) {
#line 322
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
#line 323
      if (! fderr_eof) {
#line 324
        __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 330
    if (fdin != -1) {
#line 330
      tmp___2 = buffer_len(& stdin_buffer);
#line 330
      if (tmp___2 > 0U) {
#line 331
        __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
  }
#line 333
  notify_prepare(*readsetp);
#line 339
  tmp___3 = packet_have_data_to_write();
#line 339
  if (tmp___3) {
#line 340
    __asm__  volatile   ("btsl %1,%0": "=m" ((*writesetp)->fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))): "cc",
                         "memory");
  }
#line 346
  if (child_terminated) {
#line 346
    tmp___4 = packet_not_very_much_data_to_write();
#line 346
    if (tmp___4) {
#line 347
      if (max_time_milliseconds == 0U) {
#line 348
        max_time_milliseconds = 100U;
      } else {
#line 347
        if (client_alive_scheduled) {
#line 348
          max_time_milliseconds = 100U;
        }
      }
    }
  }
#line 350
  if (max_time_milliseconds == 0U) {
#line 351
    tvp = (struct timeval *)((void *)0);
  } else {
#line 353
    tv___0.tv_sec = (long )(max_time_milliseconds / 1000U);
#line 354
    tv___0.tv_usec = (long )(1000U * (max_time_milliseconds % 1000U));
#line 355
    tvp = & tv___0;
  }
#line 359
  ret___0 = select(*maxfdp + 1, (fd_set * __restrict  )*readsetp, (fd_set * __restrict  )*writesetp,
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tvp);
#line 361
  if (ret___0 == -1) {
#line 362
    memset((void *)*readsetp, 0, *nallocp);
#line 363
    memset((void *)*writesetp, 0, *nallocp);
#line 364
    tmp___7 = __errno_location();
#line 364
    if (*tmp___7 != 4) {
#line 365
      tmp___5 = __errno_location();
#line 365
      tmp___6 = strerror(*tmp___5);
#line 365
      error("select: %.100s", tmp___6);
    }
  } else {
#line 367
    if (ret___0 == 0) {
#line 367
      if (client_alive_scheduled) {
#line 368
        client_alive_check();
      }
    }
#line 369
    if (! compat20) {
#line 369
      if (program_alive_scheduled) {
#line 369
        if (fdin_is_tty) {
#line 370
          if (! fdout_eof) {
#line 371
            __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))): "cc",
                                 "memory");
          }
#line 372
          if (! fderr_eof) {
#line 373
            __asm__  volatile   ("btsl %1,%0": "=m" ((*readsetp)->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))): "cc",
                                 "memory");
          }
        }
      }
    }
  }
#line 377
  notify_done(*readsetp);
#line 378
  return;
}
}
#line 384 "serverloop.c"
static void process_input(fd_set *readset ) 
{ int len ;
  char buf___1[16384] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  register char __result ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  register char __result___0 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  register char __result___1 ;

  {
#line 391
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )connection_in___0 % (8U * sizeof(__fd_mask ))),
                       "m" (readset->fds_bits[(unsigned int )connection_in___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 391
  if (__result) {
#line 392
    len = read(connection_in___0, (void *)(buf___1), sizeof(buf___1));
#line 393
    if (len == 0) {
#line 394
      tmp = get_remote_ipaddr();
#line 394
      verbose("Connection closed by %.100s", tmp);
#line 396
      connection_closed = 1;
#line 397
      if (compat20) {
#line 398
        return;
      }
#line 399
      cleanup_exit(255);
    } else {
#line 400
      if (len < 0) {
#line 401
        tmp___3 = __errno_location();
#line 401
        if (*tmp___3 != 4) {
#line 401
          tmp___4 = __errno_location();
#line 401
          if (*tmp___4 != 11) {
#line 402
            tmp___0 = __errno_location();
#line 402
            tmp___1 = strerror(*tmp___0);
#line 402
            tmp___2 = get_remote_ipaddr();
#line 402
            verbose("Read error from remote host %.100s: %.100s", tmp___2, tmp___1);
#line 405
            cleanup_exit(255);
          }
        }
      } else {
#line 409
        packet_process_incoming((char const   *)(buf___1), (unsigned int )len);
      }
    }
  }
#line 412
  if (compat20) {
#line 413
    return;
  }
#line 416
  if (! fdout_eof) {
#line 416
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )fdout % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )fdout / (8U * sizeof(__fd_mask ))]): "cc");
#line 416
    if (__result___0) {
#line 417
      tmp___5 = __errno_location();
#line 417
      *tmp___5 = 0;
#line 418
      len = read(fdout, (void *)(buf___1), sizeof(buf___1));
#line 419
      if (len < 0) {
#line 419
        tmp___6 = __errno_location();
#line 419
        if (! (*tmp___6 == 4)) {
#line 419
          tmp___7 = __errno_location();
#line 419
          if (*tmp___7 == 11) {
#line 419
            if (! (! child_terminated)) {
              goto _L;
            }
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
#line 423
        if (len <= 0) {
#line 428
          fdout_eof = 1;
        } else {
#line 430
          buffer_append(& stdout_buffer, (void const   *)(buf___1), (unsigned int )len);
#line 431
          fdout_bytes += (long )len;
        }
      }
    }
  }
#line 435
  if (! fderr_eof) {
#line 435
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___1): "r" ((unsigned int )fderr % (8U * sizeof(__fd_mask ))),
                         "m" (readset->fds_bits[(unsigned int )fderr / (8U * sizeof(__fd_mask ))]): "cc");
#line 435
    if (__result___1) {
#line 436
      tmp___8 = __errno_location();
#line 436
      *tmp___8 = 0;
#line 437
      len = read(fderr, (void *)(buf___1), sizeof(buf___1));
#line 438
      if (len < 0) {
#line 438
        tmp___9 = __errno_location();
#line 438
        if (! (*tmp___9 == 4)) {
#line 438
          tmp___10 = __errno_location();
#line 438
          if (*tmp___10 == 11) {
#line 438
            if (! (! child_terminated)) {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 442
        if (len <= 0) {
#line 447
          fderr_eof = 1;
        } else {
#line 449
          buffer_append(& stderr_buffer, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
  }
#line 452
  return;
}
}
#line 457 "serverloop.c"
static void process_output(fd_set *writeset ) 
{ struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  register char __result ;
  register char __result___0 ;

  {
#line 466
  if (! compat20) {
#line 466
    if (fdin != -1) {
#line 466
      __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )fdin % (8U * sizeof(__fd_mask ))),
                           "m" (writeset->fds_bits[(unsigned int )fdin / (8U * sizeof(__fd_mask ))]): "cc");
#line 466
      if (__result) {
#line 467
        tmp = buffer_ptr(& stdin_buffer);
#line 467
        data = (u_char *)tmp;
#line 468
        dlen = buffer_len(& stdin_buffer);
#line 469
        len = write(fdin, (void const   *)data, dlen);
#line 470
        if (len < 0) {
#line 470
          tmp___1 = __errno_location();
#line 470
          if (! (*tmp___1 == 4)) {
#line 470
            tmp___2 = __errno_location();
#line 470
            if (! (*tmp___2 == 11)) {
              goto _L;
            }
          }
        } else {
          _L: /* CIL Label */ 
#line 472
          if (len <= 0) {
#line 473
            if (fdin != fdout) {
#line 474
              close(fdin);
            } else {
#line 476
              shutdown(fdin, 1);
            }
#line 477
            fdin = -1;
          } else {
#line 480
            if (fdin_is_tty) {
#line 480
              if (dlen >= 1U) {
#line 480
                if ((int )*(data + 0) != 13) {
#line 480
                  tmp___0 = tcgetattr(fdin, & tio);
#line 480
                  if (tmp___0 == 0) {
#line 480
                    if (! (tio.c_lflag & 8U)) {
#line 480
                      if (tio.c_lflag & 2U) {
#line 487
                        packet_send_ignore(len);
#line 488
                        packet_send();
                      }
                    }
                  }
                }
              }
            }
#line 491
            buffer_consume(& stdin_buffer, (unsigned int )len);
#line 493
            stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 497
  __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )connection_out___0 % (8U * sizeof(__fd_mask ))),
                       "m" (writeset->fds_bits[(unsigned int )connection_out___0 / (8U * sizeof(__fd_mask ))]): "cc");
#line 497
  if (__result___0) {
#line 498
    packet_write_poll();
  }
#line 499
  return;
}
}
#line 505 "serverloop.c"
static void drain_output(void) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 509
  tmp___2 = buffer_len(& stdout_buffer);
#line 509
  if (tmp___2 > 0U) {
#line 510
    packet_start((unsigned char)17);
#line 511
    tmp = buffer_len(& stdout_buffer);
#line 511
    tmp___0 = buffer_ptr(& stdout_buffer);
#line 511
    packet_put_string((void const   *)tmp___0, tmp);
#line 513
    packet_send();
#line 515
    tmp___1 = buffer_len(& stdout_buffer);
#line 515
    stdout_bytes = (long )((unsigned long )stdout_bytes + (unsigned long )tmp___1);
  }
#line 518
  tmp___6 = buffer_len(& stderr_buffer);
#line 518
  if (tmp___6 > 0U) {
#line 519
    packet_start((unsigned char)18);
#line 520
    tmp___3 = buffer_len(& stderr_buffer);
#line 520
    tmp___4 = buffer_ptr(& stderr_buffer);
#line 520
    packet_put_string((void const   *)tmp___4, tmp___3);
#line 522
    packet_send();
#line 524
    tmp___5 = buffer_len(& stderr_buffer);
#line 524
    stderr_bytes = (long )((unsigned long )stderr_bytes + (unsigned long )tmp___5);
  }
#line 527
  packet_write_wait();
#line 528
  return;
}
}
#line 530 "serverloop.c"
static void process_buffered_input_packets(void) 
{ Kex *tmp ;

  {
#line 533
  if (compat20) {
#line 533
    tmp = xxx_kex;
  } else {
#line 533
    tmp = (Kex *)((void *)0);
  }
#line 533
  dispatch_run(1, (sig_atomic_t volatile   *)((void *)0), (void *)tmp);
#line 534
  return;
}
}
#line 543 "serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  u_int nalloc ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  union __anonunion___u_82 __u ;
  union __anonunion___u_83 __u___0 ;
  union __anonunion___u_84 __u___1 ;
  union __anonunion___u_85 __u___2 ;
  union __anonunion___u_86 __u___3 ;

  {
#line 546
  readset = (fd_set *)((void *)0);
#line 546
  writeset = (fd_set *)((void *)0);
#line 547
  max_fd = 0;
#line 548
  nalloc = (u_int )0;
#line 551
  waiting_termination = 0;
#line 557
  debug("Entering interactive session.");
#line 560
  child_terminated = (int volatile   )0;
#line 561
  mysignal(17, & sigchld_handler);
#line 563
  if (! use_privsep) {
#line 564
    mysignal(15, & sigterm_handler___0);
#line 565
    mysignal(2, & sigterm_handler___0);
#line 566
    mysignal(3, & sigterm_handler___0);
  }
#line 570
  fdin = fdin_arg;
#line 571
  fdout = fdout_arg;
#line 572
  fderr = fderr_arg;
#line 575
  set_nonblock(fdin);
#line 576
  set_nonblock(fdout);
#line 578
  if (fderr != -1) {
#line 579
    set_nonblock(fderr);
  }
#line 581
  if (! (datafellows & 256)) {
#line 581
    tmp = isatty(fdin);
#line 581
    if (tmp) {
#line 582
      fdin_is_tty = 1;
    }
  }
#line 584
  connection_in___0 = packet_get_connection_in();
#line 585
  connection_out___0 = packet_get_connection_out();
#line 587
  notify_setup();
#line 589
  previous_stdout_buffer_bytes = 0U;
#line 592
  tmp___0 = packet_is_interactive();
#line 592
  if (tmp___0) {
#line 593
    buffer_high = 4096U;
  } else {
#line 595
    buffer_high = 65536U;
  }
#line 607
  buffer_init(& stdin_buffer);
#line 608
  buffer_init(& stdout_buffer);
#line 609
  buffer_init(& stderr_buffer);
#line 617
  if (fderr == -1) {
#line 618
    fderr_eof = 1;
  }
#line 620
  server_init_dispatch();
#line 623
  while (1) {
#line 626
    process_buffered_input_packets();
#line 632
    if (stdin_eof) {
#line 632
      if (fdin != -1) {
#line 632
        tmp___1 = buffer_len(& stdin_buffer);
#line 632
        if (tmp___1 == 0U) {
#line 633
          if (fdin != fdout) {
#line 634
            close(fdin);
          } else {
#line 636
            shutdown(fdin, 1);
          }
#line 637
          fdin = -1;
        }
      }
    }
#line 640
    make_packets_from_stderr_data();
#line 649
    max_time_milliseconds = 0U;
#line 650
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 651
    if (stdout_buffer_bytes != 0U) {
#line 651
      if (stdout_buffer_bytes < 256U) {
#line 651
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 654
          max_time_milliseconds = 10U;
        } else {
#line 657
          make_packets_from_stdout_data();
        }
      } else {
#line 657
        make_packets_from_stdout_data();
      }
    } else {
#line 657
      make_packets_from_stdout_data();
    }
#line 659
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
#line 662
    tmp___2 = packet_not_very_much_data_to_write();
#line 662
    if (tmp___2) {
#line 663
      channel_output_poll();
    }
#line 670
    if (fdout_eof) {
#line 670
      if (fderr_eof) {
#line 670
        tmp___6 = packet_have_data_to_write();
#line 670
        if (! tmp___6) {
#line 670
          tmp___7 = buffer_len(& stdout_buffer);
#line 670
          if (tmp___7 == 0U) {
#line 670
            tmp___8 = buffer_len(& stderr_buffer);
#line 670
            if (tmp___8 == 0U) {
#line 672
              tmp___3 = channel_still_open();
#line 672
              if (! tmp___3) {
#line 673
                break;
              }
#line 674
              if (! waiting_termination) {
#line 675
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 677
                waiting_termination = 1;
#line 678
                tmp___4 = strlen(s);
#line 678
                buffer_append(& stderr_buffer, (void const   *)s, tmp___4);
#line 681
                cp = channel_open_message();
#line 682
                tmp___5 = strlen((char const   *)cp);
#line 682
                buffer_append(& stderr_buffer, (void const   *)cp, tmp___5);
#line 683
                xfree((void *)cp);
              }
            }
          }
        }
      }
    }
#line 686
    if (connection_in___0 > connection_out___0) {
#line 686
      max_fd = connection_in___0;
    } else {
#line 686
      max_fd = connection_out___0;
    }
#line 687
    if (max_fd > fdin) {
#line 687
      max_fd = max_fd;
    } else {
#line 687
      max_fd = fdin;
    }
#line 688
    if (max_fd > fdout) {
#line 688
      max_fd = max_fd;
    } else {
#line 688
      max_fd = fdout;
    }
#line 689
    if (max_fd > fderr) {
#line 689
      max_fd = max_fd;
    } else {
#line 689
      max_fd = fderr;
    }
#line 690
    if (max_fd > notify_pipe[0]) {
#line 690
      max_fd = max_fd;
    } else {
#line 690
      max_fd = notify_pipe[0];
    }
#line 693
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, max_time_milliseconds);
#line 696
    if (received_sigterm___0) {
#line 697
      logit("Exiting on signal %d", received_sigterm___0);
#line 699
      cleanup_exit(255);
    }
#line 703
    channel_after_select(readset, writeset);
#line 706
    process_input(readset);
#line 709
    process_output(writeset);
  }
#line 711
  if (readset) {
#line 712
    xfree((void *)readset);
  }
#line 713
  if (writeset) {
#line 714
    xfree((void *)writeset);
  }
#line 719
  drain_output();
#line 721
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
#line 725
  buffer_free(& stdin_buffer);
#line 726
  buffer_free(& stdout_buffer);
#line 727
  buffer_free(& stderr_buffer);
#line 730
  if (fdout != -1) {
#line 731
    close(fdout);
  }
#line 732
  fdout = -1;
#line 733
  fdout_eof = 1;
#line 734
  if (fderr != -1) {
#line 735
    close(fderr);
  }
#line 736
  fderr = -1;
#line 737
  fderr_eof = 1;
#line 738
  if (fdin != -1) {
#line 739
    close(fdin);
  }
#line 740
  fdin = -1;
#line 742
  channel_free_all();
#line 745
  mysignal(17, (void (*)(int  ))0);
#line 747
  while (1) {
#line 747
    wait_pid = waitpid(-1, & wait_status, 0);
#line 747
    if (! (wait_pid < 0)) {
#line 747
      break;
    }
#line 748
    tmp___11 = __errno_location();
#line 748
    if (*tmp___11 != 4) {
#line 749
      tmp___9 = __errno_location();
#line 749
      tmp___10 = strerror(*tmp___9);
#line 749
      packet_disconnect("wait: %.100s", tmp___10);
    }
  }
#line 750
  if (wait_pid != pid) {
#line 751
    error("Strange, wait returned pid %ld, expected %ld", (long )wait_pid, (long )pid);
  }
#line 755
  __u___1.__in = wait_status;
#line 755
  if ((__u___1.__i & 127) == 0) {
#line 757
    __u.__in = wait_status;
#line 757
    debug("Command exited with status %d.", (__u.__i & 65280) >> 8);
#line 758
    packet_start((unsigned char)20);
#line 759
    __u___0.__in = wait_status;
#line 759
    packet_put_int((unsigned int )((__u___0.__i & 65280) >> 8));
#line 760
    packet_send();
#line 761
    packet_write_wait();
#line 770
    while (1) {
#line 771
      type = packet_read();
#line 770
      if (! (type != 33)) {
#line 770
        break;
      }
    }
#line 775
    debug("Received exit confirmation.");
#line 776
    return;
  }
#line 779
  __u___3.__in = wait_status;
#line 779
  if ((int )((signed char )((__u___3.__i & 127) + 1)) >> 1 > 0) {
#line 781
    __u___2.__in = wait_status;
#line 781
    packet_disconnect("Command terminated on signal %d.", __u___2.__i & 127);
  }
#line 784
  packet_disconnect("wait returned status %04x.", wait_status);
#line 786
  return;
}
}
#line 788 "serverloop.c"
static void collect_children(void) 
{ pid_t pid ;
  sigset_t oset ;
  sigset_t nset ;
  int status ;
  int *tmp ;

  {
#line 796
  sigemptyset(& nset);
#line 797
  sigaddset(& nset, 17);
#line 798
  sigprocmask(0, (sigset_t const   * __restrict  )(& nset), (sigset_t * __restrict  )(& oset));
#line 799
  if (child_terminated) {
#line 800
    debug("Received SIGCHLD.");
#line 801
    while (1) {
#line 801
      pid = waitpid(-1, & status, 1);
#line 801
      if (! (pid > 0)) {
#line 801
        if (pid < 0) {
#line 801
          tmp = __errno_location();
#line 801
          if (! (*tmp == 4)) {
#line 801
            break;
          }
        } else {
#line 801
          break;
        }
      }
#line 803
      if (pid > 0) {
#line 804
        session_close_by_pid(pid, status);
      }
    }
#line 805
    child_terminated = (int volatile   )0;
  }
#line 807
  sigprocmask(2, (sigset_t const   * __restrict  )(& oset), (sigset_t * __restrict  )((void *)0));
#line 808
  return;
}
}
#line 810 "serverloop.c"
void server_loop2(Authctxt *authctxt___0 ) 
{ fd_set *readset ;
  fd_set *writeset ;
  int rekeying___0 ;
  int max_fd ;
  int nalloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 813
  readset = (fd_set *)((void *)0);
#line 813
  writeset = (fd_set *)((void *)0);
#line 814
  rekeying___0 = 0;
#line 814
  nalloc = 0;
#line 816
  debug("Entering interactive session for SSH2.");
#line 818
  mysignal(17, & sigchld_handler);
#line 819
  child_terminated = (int volatile   )0;
#line 820
  connection_in___0 = packet_get_connection_in();
#line 821
  connection_out___0 = packet_get_connection_out();
#line 823
  if (! use_privsep) {
#line 824
    mysignal(15, & sigterm_handler___0);
#line 825
    mysignal(2, & sigterm_handler___0);
#line 826
    mysignal(3, & sigterm_handler___0);
  }
#line 829
  notify_setup();
#line 831
  if (connection_in___0 > connection_out___0) {
#line 831
    max_fd = connection_in___0;
  } else {
#line 831
    max_fd = connection_out___0;
  }
#line 832
  if (max_fd > notify_pipe[0]) {
#line 832
    max_fd = max_fd;
  } else {
#line 832
    max_fd = notify_pipe[0];
  }
#line 834
  server_init_dispatch();
#line 836
  while (1) {
#line 837
    process_buffered_input_packets();
#line 839
    if ((unsigned int )xxx_kex != (unsigned int )((void *)0)) {
#line 839
      if (! xxx_kex->done) {
#line 839
        tmp = 1;
      } else {
#line 839
        tmp = 0;
      }
    } else {
#line 839
      tmp = 0;
    }
#line 839
    rekeying___0 = tmp;
#line 841
    if (! rekeying___0) {
#line 841
      tmp___0 = packet_not_very_much_data_to_write();
#line 841
      if (tmp___0) {
#line 842
        channel_output_poll();
      }
    }
#line 843
    wait_until_can_do_something(& readset, & writeset, & max_fd, (u_int *)(& nalloc),
                                0U);
#line 846
    if (received_sigterm___0) {
#line 847
      logit("Exiting on signal %d", received_sigterm___0);
#line 849
      cleanup_exit(255);
    }
#line 852
    collect_children();
#line 853
    if (! rekeying___0) {
#line 854
      channel_after_select(readset, writeset);
#line 855
      tmp___1 = packet_need_rekeying();
#line 855
      if (tmp___1) {
#line 856
        debug("need rekeying");
#line 857
        xxx_kex->done = 0;
#line 858
        kex_send_kexinit(xxx_kex);
      }
    }
#line 861
    process_input(readset);
#line 862
    if (connection_closed) {
#line 863
      break;
    }
#line 864
    process_output(writeset);
  }
#line 866
  collect_children();
#line 868
  if (readset) {
#line 869
    xfree((void *)readset);
  }
#line 870
  if (writeset) {
#line 871
    xfree((void *)writeset);
  }
#line 874
  channel_free_all();
#line 877
  session_destroy_all((void (*)(Session * ))((void *)0));
#line 878
  return;
}
}
#line 880 "serverloop.c"
static void server_input_keep_alive(int type , u_int32_t seq , void *ctxt ) 
{ 

  {
#line 883
  debug("Got %d/%u for keepalive", type, seq);
#line 889
  keep_alive_timeouts = 0;
#line 890
  return;
}
}
#line 892 "serverloop.c"
static void server_input_stdin_data(int type , u_int32_t seq , void *ctxt ) 
{ char *data ;
  u_int data_len ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 900
  if (fdin == -1) {
#line 901
    return;
  }
#line 902
  tmp = packet_get_string(& data_len);
#line 902
  data = (char *)tmp;
#line 903
  while (1) {
#line 903
    tmp___0 = packet_remaining();
#line 903
    _len = tmp___0;
#line 903
    if (_len > 0) {
#line 903
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            903);
#line 903
      packet_disconnect("Packet integrity error.");
    }
#line 903
    break;
  }
#line 904
  buffer_append(& stdin_buffer, (void const   *)data, data_len);
#line 905
  memset((void *)data, 0, data_len);
#line 906
  xfree((void *)data);
#line 907
  return;
}
}
#line 909 "serverloop.c"
static void server_input_eof(int type , u_int32_t seq , void *ctxt ) 
{ int _len ;
  int tmp ;

  {
#line 917
  debug("EOF received for stdin.");
#line 918
  while (1) {
#line 918
    tmp = packet_remaining();
#line 918
    _len = tmp;
#line 918
    if (_len > 0) {
#line 918
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            918);
#line 918
      packet_disconnect("Packet integrity error.");
    }
#line 918
    break;
  }
#line 919
  stdin_eof = 1;
#line 920
  return;
}
}
#line 922 "serverloop.c"
static void server_input_window_size(int type , u_int32_t seq , void *ctxt ) 
{ u_int row ;
  u_int tmp ;
  u_int col ;
  u_int tmp___0 ;
  u_int xpixel ;
  u_int tmp___1 ;
  u_int ypixel ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 925
  tmp = packet_get_int();
#line 925
  row = tmp;
#line 926
  tmp___0 = packet_get_int();
#line 926
  col = tmp___0;
#line 927
  tmp___1 = packet_get_int();
#line 927
  xpixel = tmp___1;
#line 928
  tmp___2 = packet_get_int();
#line 928
  ypixel = tmp___2;
#line 930
  debug("Window change received.");
#line 931
  while (1) {
#line 931
    tmp___3 = packet_remaining();
#line 931
    _len = tmp___3;
#line 931
    if (_len > 0) {
#line 931
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            931);
#line 931
      packet_disconnect("Packet integrity error.");
    }
#line 931
    break;
  }
#line 932
  if (fdin != -1) {
#line 933
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
  }
#line 934
  return;
}
}
#line 936 "serverloop.c"
static Channel *server_request_direct_tcpip(void) 
{ Channel *c ;
  int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;

  {
#line 944
  tmp = packet_get_string((u_int *)((void *)0));
#line 944
  target = (char *)tmp;
#line 945
  tmp___0 = packet_get_int();
#line 945
  target_port = (int )tmp___0;
#line 946
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 946
  originator = (char *)tmp___1;
#line 947
  tmp___2 = packet_get_int();
#line 947
  originator_port = (int )tmp___2;
#line 948
  while (1) {
#line 948
    tmp___3 = packet_remaining();
#line 948
    _len = tmp___3;
#line 948
    if (_len > 0) {
#line 948
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            948);
#line 948
      packet_disconnect("Packet integrity error.");
    }
#line 948
    break;
  }
#line 950
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
#line 954
  sock = channel_connect_to((char const   *)target, (unsigned short )target_port);
#line 955
  xfree((void *)target);
#line 956
  xfree((void *)originator);
#line 957
  if (sock < 0) {
#line 958
    return ((Channel *)((void *)0));
  }
#line 959
  c = channel_new((char *)"direct-tcpip", 12, sock, sock, -1, 2097152U, 32768U, 0,
                  (char *)"direct-tcpip", 1);
#line 962
  return (c);
}
}
#line 965 "serverloop.c"
static Channel *server_request_tun(void) 
{ Channel *c ;
  int mode ;
  int tun ;
  int sock ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 968
  c = (Channel *)((void *)0);
#line 972
  tmp = packet_get_int();
#line 972
  mode = (int )tmp;
#line 973
  switch (mode) {
  case 1: 
  case 2: 
#line 976
  break;
  default: 
#line 978
  packet_send_debug("Unsupported tunnel device mode.");
#line 979
  return ((Channel *)((void *)0));
  }
#line 981
  if ((options.permit_tun & mode) == 0) {
#line 982
    packet_send_debug("Server has rejected tunnel device forwarding");
#line 984
    return ((Channel *)((void *)0));
  }
#line 987
  tmp___0 = packet_get_int();
#line 987
  tun = (int )tmp___0;
#line 988
  if (forced_tun_device != -1) {
#line 989
    if (tun != 2147483647) {
#line 989
      if (forced_tun_device != tun) {
        goto done;
      }
    }
#line 991
    tun = forced_tun_device;
  }
#line 993
  sock = tun_open(tun, mode);
#line 994
  if (sock < 0) {
    goto done;
  }
#line 996
  c = channel_new((char *)"tun", 4, sock, sock, -1, 2097152U, 32768U, 0, (char *)"tun",
                  1);
#line 998
  c->datagram = 1;
#line 1000
  if (mode == 1) {
#line 1001
    channel_register_filter(c->self, & sys_tun_infilter, & sys_tun_outfilter);
  }
  done: 
#line 1006
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1007
    packet_send_debug("Failed to open the tunnel device.");
  }
#line 1008
  return (c);
}
}
#line 1011 "serverloop.c"
static Channel *server_request_session(void) 
{ Channel *c ;
  int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 1016
  debug("input_session_request");
#line 1017
  while (1) {
#line 1017
    tmp = packet_remaining();
#line 1017
    _len = tmp;
#line 1017
    if (_len > 0) {
#line 1017
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "serverloop.c",
            1017);
#line 1017
      packet_disconnect("Packet integrity error.");
    }
#line 1017
    break;
  }
#line 1024
  c = channel_new((char *)"session", 10, -1, -1, -1, 0U, 32768U, 0, (char *)"server-session",
                  1);
#line 1027
  tmp___0 = session_open(the_authctxt, c->self);
#line 1027
  if (tmp___0 != 1) {
#line 1028
    debug("session open failed, free channel %d", c->self);
#line 1029
    channel_free(c);
#line 1030
    return ((Channel *)((void *)0));
  }
#line 1032
  channel_register_cleanup(c->self, & session_close_by_channel, 0);
#line 1033
  return (c);
}
}
#line 1036 "serverloop.c"
static void server_input_channel_open(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  char *ctype ;
  int rchan ;
  u_int rmaxpack ;
  u_int rwindow ;
  u_int len ;
  void *tmp ;
  u_int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 1039
  c = (Channel *)((void *)0);
#line 1044
  tmp = packet_get_string(& len);
#line 1044
  ctype = (char *)tmp;
#line 1045
  tmp___0 = packet_get_int();
#line 1045
  rchan = (int )tmp___0;
#line 1046
  rwindow = packet_get_int();
#line 1047
  rmaxpack = packet_get_int();
#line 1049
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
#line 1052
  if (0) {
#line 1052
    __s1_len___1 = strlen((char const   *)ctype);
#line 1052
    __s2_len___1 = strlen("session");
#line 1052
    if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
      goto _L___4;
    } else {
#line 1052
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1052
        if (! ((unsigned int )((void const   *)("session" + 1)) - (unsigned int )((void const   *)"session") == 1U)) {
#line 1052
          tmp___30 = 1;
        } else {
#line 1052
          if (__s2_len___1 >= 4U) {
#line 1052
            tmp___30 = 1;
          } else {
#line 1052
            tmp___30 = 0;
          }
        }
      } else {
#line 1052
        tmp___30 = 0;
      }
    }
#line 1052
    if (tmp___30) {
#line 1052
      tmp___26 = __builtin_strcmp((char const   *)ctype, "session");
    } else {
#line 1052
      tmp___29 = __builtin_strcmp((char const   *)ctype, "session");
#line 1052
      tmp___26 = tmp___29;
    }
  } else {
#line 1052
    tmp___29 = __builtin_strcmp((char const   *)ctype, "session");
#line 1052
    tmp___26 = tmp___29;
  }
#line 1052
  if (tmp___26 == 0) {
#line 1053
    c = server_request_session();
  } else {
#line 1054
    if (0) {
#line 1054
      __s1_len___0 = strlen((char const   *)ctype);
#line 1054
      __s2_len___0 = strlen("direct-tcpip");
#line 1054
      if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
        goto _L___2;
      } else {
#line 1054
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1054
          if (! ((unsigned int )((void const   *)("direct-tcpip" + 1)) - (unsigned int )((void const   *)"direct-tcpip") == 1U)) {
#line 1054
            tmp___20 = 1;
          } else {
#line 1054
            if (__s2_len___0 >= 4U) {
#line 1054
              tmp___20 = 1;
            } else {
#line 1054
              tmp___20 = 0;
            }
          }
        } else {
#line 1054
          tmp___20 = 0;
        }
      }
#line 1054
      if (tmp___20) {
#line 1054
        tmp___16 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
      } else {
#line 1054
        tmp___19 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 1054
        tmp___16 = tmp___19;
      }
    } else {
#line 1054
      tmp___19 = __builtin_strcmp((char const   *)ctype, "direct-tcpip");
#line 1054
      tmp___16 = tmp___19;
    }
#line 1054
    if (tmp___16 == 0) {
#line 1055
      c = server_request_direct_tcpip();
    } else {
#line 1056
      if (0) {
#line 1056
        __s1_len = strlen((char const   *)ctype);
#line 1056
        __s2_len = strlen("tun@openssh.com");
#line 1056
        if (! ((unsigned int )((void const   *)(ctype + 1)) - (unsigned int )((void const   *)ctype) == 1U)) {
          goto _L___0;
        } else {
#line 1056
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 1056
            if (! ((unsigned int )((void const   *)("tun@openssh.com" + 1)) - (unsigned int )((void const   *)"tun@openssh.com") == 1U)) {
#line 1056
              tmp___10 = 1;
            } else {
#line 1056
              if (__s2_len >= 4U) {
#line 1056
                tmp___10 = 1;
              } else {
#line 1056
                tmp___10 = 0;
              }
            }
          } else {
#line 1056
            tmp___10 = 0;
          }
        }
#line 1056
        if (tmp___10) {
#line 1056
          tmp___6 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
        } else {
#line 1056
          tmp___9 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
#line 1056
          tmp___6 = tmp___9;
        }
      } else {
#line 1056
        tmp___9 = __builtin_strcmp((char const   *)ctype, "tun@openssh.com");
#line 1056
        tmp___6 = tmp___9;
      }
#line 1056
      if (tmp___6 == 0) {
#line 1057
        c = server_request_tun();
      }
    }
  }
#line 1059
  if ((unsigned int )c != (unsigned int )((void *)0)) {
#line 1060
    debug("server_input_channel_open: confirm %s", ctype);
#line 1061
    c->remote_id = rchan;
#line 1062
    c->remote_window = rwindow;
#line 1063
    c->remote_maxpacket = rmaxpack;
#line 1064
    if (c->type != 12) {
#line 1065
      packet_start((unsigned char)91);
#line 1066
      packet_put_int((unsigned int )c->remote_id);
#line 1067
      packet_put_int((unsigned int )c->self);
#line 1068
      packet_put_int(c->local_window);
#line 1069
      packet_put_int(c->local_maxpacket);
#line 1070
      packet_send();
    }
  } else {
#line 1073
    debug("server_input_channel_open: failure %s", ctype);
#line 1074
    packet_start((unsigned char)92);
#line 1075
    packet_put_int((unsigned int )rchan);
#line 1076
    packet_put_int(1U);
#line 1077
    if (! (datafellows & 131072)) {
#line 1078
      packet_put_cstring("open failed");
#line 1079
      packet_put_cstring("");
    }
#line 1081
    packet_send();
  }
#line 1083
  xfree((void *)ctype);
#line 1084
  return;
}
}
#line 1086 "serverloop.c"
static void server_input_global_request(int type , u_int32_t seq , void *ctxt ) 
{ char *rtype ;
  int want_reply ;
  int success ;
  void *tmp ;
  u_int tmp___0 ;
  struct passwd *pw___0 ;
  char *listen_address ;
  u_short listen_port ;
  void *tmp___1 ;
  u_int tmp___2 ;
  char *cancel_address ;
  u_short cancel_port ;
  void *tmp___3 ;
  u_int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1091
  success = 0;
#line 1093
  tmp = packet_get_string((u_int *)((void *)0));
#line 1093
  rtype = (char *)tmp;
#line 1094
  tmp___0 = packet_get_char();
#line 1094
  want_reply = (int )tmp___0;
#line 1095
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
#line 1098
  if (0) {
#line 1098
    __s1_len___0 = strlen((char const   *)rtype);
#line 1098
    __s2_len___0 = strlen("tcpip-forward");
#line 1098
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___2;
    } else {
#line 1098
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 1098
        if (! ((unsigned int )((void const   *)("tcpip-forward" + 1)) - (unsigned int )((void const   *)"tcpip-forward") == 1U)) {
#line 1098
          tmp___24 = 1;
        } else {
#line 1098
          if (__s2_len___0 >= 4U) {
#line 1098
            tmp___24 = 1;
          } else {
#line 1098
            tmp___24 = 0;
          }
        }
      } else {
#line 1098
        tmp___24 = 0;
      }
    }
#line 1098
    if (tmp___24) {
#line 1098
      tmp___20 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
    } else {
#line 1098
      tmp___23 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 1098
      tmp___20 = tmp___23;
    }
  } else {
#line 1098
    tmp___23 = __builtin_strcmp((char const   *)rtype, "tcpip-forward");
#line 1098
    tmp___20 = tmp___23;
  }
#line 1098
  if (tmp___20 == 0) {
#line 1103
    pw___0 = the_authctxt->pw;
#line 1104
    if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 1105
      fatal("server_input_global_request: no/invalid user");
    } else {
#line 1104
      if (! the_authctxt->valid) {
#line 1105
        fatal("server_input_global_request: no/invalid user");
      }
    }
#line 1106
    tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1106
    listen_address = (char *)tmp___1;
#line 1107
    tmp___2 = packet_get_int();
#line 1107
    listen_port = (unsigned short )tmp___2;
#line 1108
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          listen_port);
#line 1112
    if (! options.allow_tcp_forwarding) {
#line 1118
      success = 0;
#line 1119
      packet_send_debug("Server has disabled port forwarding.");
    } else {
#line 1112
      if (no_port_forwarding_flag) {
#line 1118
        success = 0;
#line 1119
        packet_send_debug("Server has disabled port forwarding.");
      } else {
#line 1112
        if ((int )listen_port < 1024) {
#line 1112
          if (pw___0->pw_uid != 0U) {
#line 1118
            success = 0;
#line 1119
            packet_send_debug("Server has disabled port forwarding.");
          } else {
#line 1122
            success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                        listen_port, options.gateway_ports);
          }
        } else {
#line 1122
          success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                      listen_port, options.gateway_ports);
        }
      }
    }
#line 1125
    xfree((void *)listen_address);
  } else {
#line 1126
    if (0) {
#line 1126
      __s1_len = strlen((char const   *)rtype);
#line 1126
      __s2_len = strlen("cancel-tcpip-forward");
#line 1126
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___0;
      } else {
#line 1126
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 1126
          if (! ((unsigned int )((void const   *)("cancel-tcpip-forward" + 1)) - (unsigned int )((void const   *)"cancel-tcpip-forward") == 1U)) {
#line 1126
            tmp___14 = 1;
          } else {
#line 1126
            if (__s2_len >= 4U) {
#line 1126
              tmp___14 = 1;
            } else {
#line 1126
              tmp___14 = 0;
            }
          }
        } else {
#line 1126
          tmp___14 = 0;
        }
      }
#line 1126
      if (tmp___14) {
#line 1126
        tmp___10 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
      } else {
#line 1126
        tmp___13 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
#line 1126
        tmp___10 = tmp___13;
      }
    } else {
#line 1126
      tmp___13 = __builtin_strcmp((char const   *)rtype, "cancel-tcpip-forward");
#line 1126
      tmp___10 = tmp___13;
    }
#line 1126
    if (tmp___10 == 0) {
#line 1130
      tmp___3 = packet_get_string((u_int *)((void *)0));
#line 1130
      cancel_address = (char *)tmp___3;
#line 1131
      tmp___4 = packet_get_int();
#line 1131
      cancel_port = (unsigned short )tmp___4;
#line 1132
      debug("%s: cancel-tcpip-forward addr %s port %d", "server_input_global_request",
            cancel_address, cancel_port);
#line 1135
      success = channel_cancel_rport_listener((char const   *)cancel_address, cancel_port);
#line 1137
      xfree((void *)cancel_address);
    }
  }
#line 1139
  if (want_reply) {
#line 1140
    if (success) {
#line 1140
      tmp___25 = 81;
    } else {
#line 1140
      tmp___25 = 82;
    }
#line 1140
    packet_start((unsigned char )tmp___25);
#line 1142
    packet_send();
#line 1143
    packet_write_wait();
  }
#line 1145
  xfree((void *)rtype);
#line 1146
  return;
}
}
#line 1148 "serverloop.c"
static void server_input_channel_req(int type , u_int32_t seq , void *ctxt ) 
{ Channel *c ;
  int id ;
  int reply ;
  int success ;
  char *rtype ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
#line 1152
  success = 0;
#line 1155
  tmp = packet_get_int();
#line 1155
  id = (int )tmp;
#line 1156
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1156
  rtype = (char *)tmp___0;
#line 1157
  tmp___1 = packet_get_char();
#line 1157
  reply = (int )tmp___1;
#line 1159
  debug("server_input_channel_req: channel %d request %s reply %d", id, rtype, reply);
#line 1162
  c = channel_lookup(id);
#line 1162
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 1163
    packet_disconnect("server_input_channel_req: unknown channel %d", id);
  }
#line 1165
  if (c->type == 10) {
#line 1166
    success = session_input_channel_req(c, (char const   *)rtype);
  } else {
#line 1165
    if (c->type == 4) {
#line 1166
      success = session_input_channel_req(c, (char const   *)rtype);
    }
  }
#line 1167
  if (reply) {
#line 1168
    if (success) {
#line 1168
      tmp___2 = 99;
    } else {
#line 1168
      tmp___2 = 100;
    }
#line 1168
    packet_start((unsigned char )tmp___2);
#line 1170
    packet_put_int((unsigned int )c->remote_id);
#line 1171
    packet_send();
  }
#line 1173
  xfree((void *)rtype);
#line 1174
  return;
}
}
#line 1176 "serverloop.c"
static void server_init_dispatch_20(void) 
{ 

  {
#line 1179
  debug("server_init_dispatch_20");
#line 1180
  dispatch_init(& dispatch_protocol_error);
#line 1181
  dispatch_set(97, & channel_input_oclose);
#line 1182
  dispatch_set(94, & channel_input_data);
#line 1183
  dispatch_set(96, & channel_input_ieof);
#line 1184
  dispatch_set(95, & channel_input_extended_data);
#line 1185
  dispatch_set(90, & server_input_channel_open);
#line 1186
  dispatch_set(91, & channel_input_open_confirmation);
#line 1187
  dispatch_set(92, & channel_input_open_failure);
#line 1188
  dispatch_set(98, & server_input_channel_req);
#line 1189
  dispatch_set(93, & channel_input_window_adjust);
#line 1190
  dispatch_set(80, & server_input_global_request);
#line 1192
  dispatch_set(100, & server_input_keep_alive);
#line 1193
  dispatch_set(81, & server_input_keep_alive);
#line 1194
  dispatch_set(82, & server_input_keep_alive);
#line 1196
  dispatch_set(20, & kex_input_kexinit);
#line 1197
  return;
}
}
#line 1198 "serverloop.c"
static void server_init_dispatch_13(void) 
{ 

  {
#line 1201
  debug("server_init_dispatch_13");
#line 1202
  dispatch_init((dispatch_fn *)((void *)0));
#line 1203
  dispatch_set(19, & server_input_eof);
#line 1204
  dispatch_set(16, & server_input_stdin_data);
#line 1205
  dispatch_set(11, & server_input_window_size);
#line 1206
  dispatch_set(24, & channel_input_close);
#line 1207
  dispatch_set(25, & channel_input_close_confirmation);
#line 1208
  dispatch_set(23, & channel_input_data);
#line 1209
  dispatch_set(21, & channel_input_open_confirmation);
#line 1210
  dispatch_set(22, & channel_input_open_failure);
#line 1211
  dispatch_set(29, & channel_input_port_open);
#line 1212
  return;
}
}
#line 1213 "serverloop.c"
static void server_init_dispatch_15(void) 
{ 

  {
#line 1216
  server_init_dispatch_13();
#line 1217
  debug("server_init_dispatch_15");
#line 1218
  dispatch_set(24, & channel_input_ieof);
#line 1219
  dispatch_set(25, & channel_input_oclose);
#line 1220
  return;
}
}
#line 1221 "serverloop.c"
static void server_init_dispatch(void) 
{ 

  {
#line 1224
  if (compat20) {
#line 1225
    server_init_dispatch_20();
  } else {
#line 1226
    if (compat13) {
#line 1227
      server_init_dispatch_13();
    } else {
#line 1229
      server_init_dispatch_15();
    }
  }
#line 1230
  return;
}
}
#line 1 "auth.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 756 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 130 "auth.h"
int auth_shadow_acctexpired(struct spwd *spw ) ;
#line 143
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) ;
#line 146
int auth_root_allowed(char *method ) ;
#line 159
int allowed_user(struct passwd *pw___0 ) ;
#line 160
struct passwd *getpwnamallow(char const   *user ) ;
#line 167
char *authorized_keys_file2(struct passwd *pw___0 ) ;
#line 187
struct passwd *fakepw(void) ;
#line 30 "auth-options.h"
char *forced_command ;
#line 129 "loginrec.h"
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) ;
#line 40 "monitor_wrap.h"
int mm_is_monitor(void) ;
#line 79 "auth.c"
Buffer auth_debug  ;
#line 80 "auth.c"
int auth_debug_init  ;
#line 91 "auth.c"
int allowed_user(struct passwd *pw___0 ) 
{ struct stat st ;
  char const   *hostname ;
  char const   *ipaddr ;
  char const   *passwd ;
  char *shell ;
  u_int i ;
  struct spwd *spw ;
  int tmp ;
  int locked ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t tmp___28 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
#line 95
  hostname = (char const   *)((void *)0);
#line 95
  ipaddr = (char const   *)((void *)0);
#line 95
  passwd = (char const   *)((void *)0);
#line 99
  spw = (struct spwd *)((void *)0);
#line 103
  if (! pw___0) {
#line 104
    return (0);
  } else {
#line 103
    if (! pw___0->pw_name) {
#line 104
      return (0);
    }
  }
#line 107
  if (! options.use_pam) {
#line 108
    spw = getspnam((char const   *)pw___0->pw_name);
  }
#line 110
  if (! options.use_pam) {
#line 110
    if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 110
      tmp = auth_shadow_acctexpired(spw);
#line 110
      if (tmp) {
#line 111
        return (0);
      }
    }
  }
#line 117
  if ((unsigned int )spw != (unsigned int )((void *)0)) {
#line 121
    passwd = (char const   *)spw->sp_pwdp;
  }
#line 128
  if (! options.use_pam) {
#line 128
    if (passwd) {
#line 128
      if (*passwd) {
#line 129
        locked = 0;
#line 136
        if (0) {
#line 136
          if (0) {
#line 136
            __s1_len___0 = strlen(passwd);
#line 136
            __s2_len___0 = strlen("!");
#line 136
            if (! ((unsigned int )((void const   *)(passwd + 1)) - (unsigned int )((void const   *)passwd) == 1U)) {
              goto _L___2;
            } else {
#line 136
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 136
                if (! ((unsigned int )((void const   *)("!" + 1)) - (unsigned int )((void const   *)"!") == 1U)) {
#line 136
                  tmp___27 = 1;
                } else {
#line 136
                  if (__s2_len___0 >= 4U) {
#line 136
                    tmp___27 = 1;
                  } else {
#line 136
                    tmp___27 = 0;
                  }
                }
              } else {
#line 136
                tmp___27 = 0;
              }
            }
#line 136
            if (tmp___27) {
#line 136
              tmp___23 = __builtin_strcmp(passwd, "!");
            } else {
#line 136
              tmp___26 = __builtin_strcmp(passwd, "!");
#line 136
              tmp___23 = tmp___26;
            }
          } else {
#line 136
            tmp___26 = __builtin_strcmp(passwd, "!");
#line 136
            tmp___23 = tmp___26;
          }
#line 136
          tmp___17 = tmp___23;
        } else {
#line 136
          tmp___28 = strlen("!");
#line 136
          tmp___17 = strncmp(passwd, "!", tmp___28);
        }
#line 136
        if (tmp___17 == 0) {
#line 138
          locked = 1;
        }
#line 147
        if (locked) {
#line 148
          logit("User %.100s not allowed because account is locked", pw___0->pw_name);
#line 150
          return (0);
        }
      }
    }
  }
#line 158
  if ((int )*(pw___0->pw_shell + 0) == 0) {
#line 158
    shell = (char *)"/bin/sh";
  } else {
#line 158
    shell = pw___0->pw_shell;
  }
#line 161
  tmp___34 = stat((char const   * __restrict  )shell, (struct stat * __restrict  )(& st));
#line 161
  if (tmp___34 != 0) {
#line 162
    logit("User %.100s not allowed because shell %.100s does not exist", pw___0->pw_name,
          shell);
#line 164
    return (0);
  }
#line 166
  if (((st.st_mode & 61440U) == 32768U) == 0) {
#line 168
    logit("User %.100s not allowed because shell %.100s is not executable", pw___0->pw_name,
          shell);
#line 170
    return (0);
  } else {
#line 166
    if ((st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3))) == 0U) {
#line 168
      logit("User %.100s not allowed because shell %.100s is not executable", pw___0->pw_name,
            shell);
#line 170
      return (0);
    }
  }
#line 173
  if (options.num_deny_users > 0U) {
#line 175
    hostname = get_canonical_hostname(options.use_dns);
#line 176
    ipaddr = get_remote_ipaddr();
  } else {
#line 173
    if (options.num_allow_users > 0U) {
#line 175
      hostname = get_canonical_hostname(options.use_dns);
#line 176
      ipaddr = get_remote_ipaddr();
    } else {
#line 173
      if (options.num_deny_groups > 0U) {
#line 175
        hostname = get_canonical_hostname(options.use_dns);
#line 176
        ipaddr = get_remote_ipaddr();
      } else {
#line 173
        if (options.num_allow_groups > 0U) {
#line 175
          hostname = get_canonical_hostname(options.use_dns);
#line 176
          ipaddr = get_remote_ipaddr();
        }
      }
    }
  }
#line 180
  if (options.num_deny_users > 0U) {
#line 181
    i = 0U;
#line 181
    while (i < options.num_deny_users) {
#line 182
      tmp___35 = match_user((char const   *)pw___0->pw_name, hostname, ipaddr, (char const   *)options.deny_users[i]);
#line 182
      if (tmp___35) {
#line 184
        logit("User %.100s from %.100s not allowed because listed in DenyUsers", pw___0->pw_name,
              hostname);
#line 187
        return (0);
      }
#line 181
      i ++;
    }
  }
#line 191
  if (options.num_allow_users > 0U) {
#line 192
    i = 0U;
#line 192
    while (i < options.num_allow_users) {
#line 193
      tmp___36 = match_user((char const   *)pw___0->pw_name, hostname, ipaddr, (char const   *)options.allow_users[i]);
#line 193
      if (tmp___36) {
#line 195
        break;
      }
#line 192
      i ++;
    }
#line 197
    if (i >= options.num_allow_users) {
#line 198
      logit("User %.100s from %.100s not allowed because not listed in AllowUsers",
            pw___0->pw_name, hostname);
#line 200
      return (0);
    }
  }
#line 203
  if (options.num_deny_groups > 0U) {
    goto _L___3;
  } else {
#line 203
    if (options.num_allow_groups > 0U) {
      _L___3: /* CIL Label */ 
#line 205
      tmp___37 = ga_init((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 205
      if (tmp___37 == 0) {
#line 206
        logit("User %.100s from %.100s not allowed because not in any group", pw___0->pw_name,
              hostname);
#line 208
        return (0);
      }
#line 212
      if (options.num_deny_groups > 0U) {
#line 213
        tmp___38 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
#line 213
        if (tmp___38) {
#line 215
          ga_free();
#line 216
          logit("User %.100s from %.100s not allowed because a group is listed in DenyGroups",
                pw___0->pw_name, hostname);
#line 219
          return (0);
        }
      }
#line 225
      if (options.num_allow_groups > 0U) {
#line 226
        tmp___39 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
#line 226
        if (! tmp___39) {
#line 228
          ga_free();
#line 229
          logit("User %.100s from %.100s not allowed because none of user\'s groups are listed in AllowGroups",
                pw___0->pw_name, hostname);
#line 232
          return (0);
        }
      }
#line 234
      ga_free();
    }
  }
#line 243
  return (1);
}
}
#line 246 "auth.c"
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) 
{ void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___37 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;

  {
#line 249
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 252
  if (use_privsep) {
#line 252
    tmp = mm_is_monitor();
#line 252
    if (! tmp) {
#line 252
      if (! authctxt___0->postponed) {
#line 253
        return;
      }
    }
  }
#line 259
  if (authenticated == 1) {
#line 260
    authlog = (void (*)(char const   *fmt  , ...))(& logit);
  } else {
#line 259
    if (! authctxt___0->valid) {
#line 260
      authlog = (void (*)(char const   *fmt  , ...))(& logit);
    } else {
#line 259
      if (authctxt___0->failures >= options.max_authtries / 2) {
#line 260
        authlog = (void (*)(char const   *fmt  , ...))(& logit);
      } else {
#line 259
        if (0) {
#line 259
          __s1_len = strlen((char const   *)method);
#line 259
          __s2_len = strlen("password");
#line 259
          if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
            goto _L___0;
          } else {
#line 259
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 259
              if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 259
                tmp___9 = 1;
              } else {
#line 259
                if (__s2_len >= 4U) {
#line 259
                  tmp___9 = 1;
                } else {
#line 259
                  tmp___9 = 0;
                }
              }
            } else {
#line 259
              tmp___9 = 0;
            }
          }
#line 259
          if (tmp___9) {
#line 259
            tmp___5 = __builtin_strcmp((char const   *)method, "password");
          } else {
#line 259
            tmp___8 = __builtin_strcmp((char const   *)method, "password");
#line 259
            tmp___5 = tmp___8;
          }
        } else {
#line 259
          tmp___8 = __builtin_strcmp((char const   *)method, "password");
#line 259
          tmp___5 = tmp___8;
        }
#line 259
        if (tmp___5 == 0) {
#line 260
          authlog = (void (*)(char const   *fmt  , ...))(& logit);
        }
      }
    }
  }
#line 262
  if (authctxt___0->postponed) {
#line 263
    authmsg = (char *)"Postponed";
  } else {
#line 265
    if (authenticated) {
#line 265
      authmsg = (char *)"Accepted";
    } else {
#line 265
      authmsg = (char *)"Failed";
    }
  }
#line 267
  tmp___10 = get_remote_port();
#line 267
  tmp___11 = get_remote_ipaddr();
#line 267
  if (authctxt___0->valid) {
#line 267
    tmp___12 = "";
  } else {
#line 267
    tmp___12 = "invalid user ";
  }
#line 267
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___12,
             authctxt___0->user, tmp___11, tmp___10, info);
#line 280
  if (authenticated == 0) {
#line 280
    if (! authctxt___0->postponed) {
#line 278
      if (0) {
#line 278
        __s1_len___0 = strlen((char const   *)method);
#line 278
        __s2_len___0 = strlen("password");
#line 278
        if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
          goto _L___2;
        } else {
#line 278
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 278
            if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 278
              tmp___23 = 1;
            } else {
#line 278
              if (__s2_len___0 >= 4U) {
#line 278
                tmp___23 = 1;
              } else {
#line 278
                tmp___23 = 0;
              }
            }
          } else {
#line 278
            tmp___23 = 0;
          }
        }
#line 278
        if (tmp___23) {
#line 278
          tmp___19 = __builtin_strcmp((char const   *)method, "password");
        } else {
#line 278
          tmp___22 = __builtin_strcmp((char const   *)method, "password");
#line 278
          tmp___19 = tmp___22;
        }
      } else {
#line 278
        tmp___22 = __builtin_strcmp((char const   *)method, "password");
#line 278
        tmp___19 = tmp___22;
      }
#line 280
      if (tmp___19 == 0) {
#line 281
        tmp___13 = get_canonical_hostname(options.use_dns);
#line 281
        record_failed_login((char const   *)authctxt___0->user, tmp___13, "ssh");
      } else {
#line 279
        if (0) {
#line 279
          if (0) {
#line 279
            __s1_len___2 = strlen((char const   *)method);
#line 279
            __s2_len___2 = strlen("keyboard-interactive");
#line 279
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___6;
            } else {
#line 279
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 279
                if (! ((unsigned int )((void const   *)("keyboard-interactive" + 1)) - (unsigned int )((void const   *)"keyboard-interactive") == 1U)) {
#line 279
                  tmp___47 = 1;
                } else {
#line 279
                  if (__s2_len___2 >= 4U) {
#line 279
                    tmp___47 = 1;
                  } else {
#line 279
                    tmp___47 = 0;
                  }
                }
              } else {
#line 279
                tmp___47 = 0;
              }
            }
#line 279
            if (tmp___47) {
#line 279
              tmp___43 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
            } else {
#line 279
              tmp___46 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
#line 279
              tmp___43 = tmp___46;
            }
          } else {
#line 279
            tmp___46 = __builtin_strcmp((char const   *)method, "keyboard-interactive");
#line 279
            tmp___43 = tmp___46;
          }
#line 279
          tmp___37 = tmp___43;
        } else {
#line 279
          tmp___37 = strncmp((char const   *)method, "keyboard-interactive", 20U);
        }
#line 280
        if (tmp___37 == 0) {
#line 281
          tmp___13 = get_canonical_hostname(options.use_dns);
#line 281
          record_failed_login((char const   *)authctxt___0->user, tmp___13, "ssh");
        } else {
#line 280
          if (0) {
#line 280
            __s1_len___3 = strlen((char const   *)method);
#line 280
            __s2_len___3 = strlen("challenge-response");
#line 280
            if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
              goto _L___8;
            } else {
#line 280
              if (__s1_len___3 >= 4U) {
                _L___8: /* CIL Label */ 
#line 280
                if (! ((unsigned int )((void const   *)("challenge-response" + 1)) - (unsigned int )((void const   *)"challenge-response") == 1U)) {
#line 280
                  tmp___59 = 1;
                } else {
#line 280
                  if (__s2_len___3 >= 4U) {
#line 280
                    tmp___59 = 1;
                  } else {
#line 280
                    tmp___59 = 0;
                  }
                }
              } else {
#line 280
                tmp___59 = 0;
              }
            }
#line 280
            if (tmp___59) {
#line 280
              tmp___55 = __builtin_strcmp((char const   *)method, "challenge-response");
            } else {
#line 280
              tmp___58 = __builtin_strcmp((char const   *)method, "challenge-response");
#line 280
              tmp___55 = tmp___58;
            }
          } else {
#line 280
            tmp___58 = __builtin_strcmp((char const   *)method, "challenge-response");
#line 280
            tmp___55 = tmp___58;
          }
#line 280
          if (tmp___55 == 0) {
#line 281
            tmp___13 = get_canonical_hostname(options.use_dns);
#line 281
            record_failed_login((char const   *)authctxt___0->user, tmp___13, "ssh");
          }
        }
      }
    }
  }
#line 293
  return;
}
}
#line 298 "auth.c"
int auth_root_allowed(char *method ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 301
  switch (options.permit_root_login) {
  case 3: 
#line 303
  return (1);
  case 2: 
#line 305
  if (0) {
#line 305
    __s1_len = strlen((char const   *)method);
#line 305
    __s2_len = strlen("password");
#line 305
    if (! ((unsigned int )((void const   *)(method + 1)) - (unsigned int )((void const   *)method) == 1U)) {
      goto _L___0;
    } else {
#line 305
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 305
        if (! ((unsigned int )((void const   *)("password" + 1)) - (unsigned int )((void const   *)"password") == 1U)) {
#line 305
          tmp___8 = 1;
        } else {
#line 305
          if (__s2_len >= 4U) {
#line 305
            tmp___8 = 1;
          } else {
#line 305
            tmp___8 = 0;
          }
        }
      } else {
#line 305
        tmp___8 = 0;
      }
    }
#line 305
    if (tmp___8) {
#line 305
      tmp___4 = __builtin_strcmp((char const   *)method, "password");
    } else {
#line 305
      tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 305
      tmp___4 = tmp___7;
    }
  } else {
#line 305
    tmp___7 = __builtin_strcmp((char const   *)method, "password");
#line 305
    tmp___4 = tmp___7;
  }
#line 305
  if (tmp___4 != 0) {
#line 306
    return (1);
  }
#line 307
  break;
  case 1: 
#line 309
  if (forced_command) {
#line 310
    logit("Root login accepted for forced command.");
#line 311
    return (1);
  }
#line 313
  break;
  }
#line 315
  tmp___9 = get_remote_ipaddr();
#line 315
  logit("ROOT LOGIN REFUSED FROM %.200s", tmp___9);
#line 316
  return (0);
}
}
#line 327 "auth.c"
static char *expand_authorized_keys(char const   *filename , struct passwd *pw___0 ) 
{ char *file___0 ;
  char ret___0[4096] ;
  int i ;
  char *tmp ;

  {
#line 333
  file___0 = percent_expand(filename, "h", pw___0->pw_dir, "u", pw___0->pw_name, (char *)((void *)0));
#line 340
  if ((int )*file___0 == 47) {
#line 341
    return (file___0);
  }
#line 343
  i = snprintf((char * __restrict  )(ret___0), sizeof(ret___0), (char const   * __restrict  )"%s/%s",
               pw___0->pw_dir, file___0);
#line 344
  if (i < 0) {
#line 345
    fatal("expand_authorized_keys: path too long");
  } else {
#line 344
    if ((unsigned int )i >= sizeof(ret___0)) {
#line 345
      fatal("expand_authorized_keys: path too long");
    }
  }
#line 346
  xfree((void *)file___0);
#line 347
  tmp = xstrdup((char const   *)(ret___0));
#line 347
  return (tmp);
}
}
#line 350 "auth.c"
char *authorized_keys_file(struct passwd *pw___0 ) 
{ char *tmp ;

  {
#line 353
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file, pw___0);
#line 353
  return (tmp);
}
}
#line 356 "auth.c"
char *authorized_keys_file2(struct passwd *pw___0 ) 
{ char *tmp ;

  {
#line 359
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file2, pw___0);
#line 359
  return (tmp);
}
}
#line 363 "auth.c"
HostStatus check_key_in_hostfiles(struct passwd *pw___0 , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) 
{ Key *found ;
  char *user_hostfile ;
  struct stat st ;
  HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 373
  found = key_new(key->type);
#line 374
  host_status = check_host_in_hostfile(sysfile, host, (Key const   *)key, found, (int *)((void *)0));
#line 376
  if ((int )host_status != 0) {
#line 376
    if ((unsigned int )userfile != (unsigned int )((void *)0)) {
#line 377
      user_hostfile = tilde_expand_filename(userfile, pw___0->pw_uid);
#line 378
      if (options.strict_modes) {
#line 378
        tmp = stat((char const   * __restrict  )user_hostfile, (struct stat * __restrict  )(& st));
#line 378
        if (tmp == 0) {
#line 378
          if (st.st_uid != 0U) {
#line 378
            if (st.st_uid != pw___0->pw_uid) {
#line 382
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw___0->pw_name, user_hostfile);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 378
            if ((st.st_mode & 18U) != 0U) {
#line 382
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw___0->pw_name, user_hostfile);
            } else {
#line 386
              temporarily_use_uid(pw___0);
#line 387
              host_status = check_host_in_hostfile((char const   *)user_hostfile,
                                                   host, (Key const   *)key, found,
                                                   (int *)((void *)0));
#line 389
              restore_uid();
            }
          }
        } else {
#line 386
          temporarily_use_uid(pw___0);
#line 387
          host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                               (Key const   *)key, found, (int *)((void *)0));
#line 389
          restore_uid();
        }
      } else {
#line 386
        temporarily_use_uid(pw___0);
#line 387
        host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                             (Key const   *)key, found, (int *)((void *)0));
#line 389
        restore_uid();
      }
#line 391
      xfree((void *)user_hostfile);
    }
  }
#line 393
  key_free(found);
#line 395
  if ((int )host_status == 0) {
#line 395
    tmp___0 = "ok";
  } else {
#line 395
    tmp___0 = "not found";
  }
#line 395
  debug2("check_key_in_hostfiles: key %s for %s", tmp___0, host);
#line 397
  return (host_status);
}
}
#line 413 "auth.c"
int secure_filename(FILE *f , char const   *file___0 , struct passwd *pw___0 , char *err ,
                    size_t errlen ) 
{ uid_t uid ;
  char buf___1[4096] ;
  char homedir[4096] ;
  char *cp ;
  int comparehome ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 417
  uid = pw___0->pw_uid;
#line 420
  comparehome = 0;
#line 423
  tmp___1 = realpath((char const   * __restrict  )file___0, (char * __restrict  )(buf___1));
#line 423
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 424
    tmp = __errno_location();
#line 424
    tmp___0 = strerror(*tmp);
#line 424
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"realpath %s failed: %s",
             file___0, tmp___0);
#line 426
    return (-1);
  }
#line 428
  tmp___2 = realpath((char const   * __restrict  )pw___0->pw_dir, (char * __restrict  )(homedir));
#line 428
  if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 429
    comparehome = 1;
  }
#line 432
  tmp___3 = fileno(f);
#line 432
  tmp___4 = fstat(tmp___3, & st);
#line 432
  if (tmp___4 < 0) {
#line 435
    snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
             buf___1);
#line 437
    return (-1);
  } else {
#line 432
    if (st.st_uid != 0U) {
#line 432
      if (st.st_uid != uid) {
#line 435
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 437
        return (-1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 432
      if ((st.st_mode & 18U) != 0U) {
#line 435
        snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for file %s",
                 buf___1);
#line 437
        return (-1);
      }
    }
  }
#line 441
  while (1) {
#line 442
    cp = dirname(buf___1);
#line 442
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 443
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"dirname() failed");
#line 444
      return (-1);
    }
#line 446
    strlcpy(buf___1, (char const   *)cp, sizeof(buf___1));
#line 448
    debug3("secure_filename: checking \'%s\'", buf___1);
#line 449
    tmp___5 = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 449
    if (tmp___5 < 0) {
#line 452
      snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
               buf___1);
#line 454
      return (-1);
    } else {
#line 449
      if (st.st_uid != 0U) {
#line 449
        if (st.st_uid != uid) {
#line 452
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 454
          return (-1);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 449
        if ((st.st_mode & 18U) != 0U) {
#line 452
          snprintf((char * __restrict  )err, errlen, (char const   * __restrict  )"bad ownership or modes for directory %s",
                   buf___1);
#line 454
          return (-1);
        }
      }
    }
#line 458
    if (comparehome) {
#line 458
      if (0) {
#line 458
        __s1_len = strlen((char const   *)(homedir));
#line 458
        __s2_len = strlen((char const   *)(buf___1));
#line 458
        if (! ((unsigned int )((void const   *)(homedir + 1)) - (unsigned int )((void const   *)(homedir)) == 1U)) {
          goto _L___2;
        } else {
#line 458
          if (__s1_len >= 4U) {
            _L___2: /* CIL Label */ 
#line 458
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 458
              tmp___15 = 1;
            } else {
#line 458
              if (__s2_len >= 4U) {
#line 458
                tmp___15 = 1;
              } else {
#line 458
                tmp___15 = 0;
              }
            }
          } else {
#line 458
            tmp___15 = 0;
          }
        }
#line 458
        if (tmp___15) {
#line 458
          tmp___11 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
        } else {
#line 458
          tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 458
          tmp___11 = tmp___14;
        }
      } else {
#line 458
        tmp___14 = __builtin_strcmp((char const   *)(homedir), (char const   *)(buf___1));
#line 458
        tmp___11 = tmp___14;
      }
#line 458
      if (tmp___11 == 0) {
#line 459
        debug3("secure_filename: terminating check at \'%s\'", buf___1);
#line 461
        break;
      }
    }
#line 467
    if (0) {
#line 467
      __s1_len___0 = strlen("/");
#line 467
      __s2_len___0 = strlen((char const   *)(buf___1));
#line 467
      if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
        goto _L___4;
      } else {
#line 467
        if (__s1_len___0 >= 4U) {
          _L___4: /* CIL Label */ 
#line 467
          if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 467
            tmp___25 = 1;
          } else {
#line 467
            if (__s2_len___0 >= 4U) {
#line 467
              tmp___25 = 1;
            } else {
#line 467
              tmp___25 = 0;
            }
          }
        } else {
#line 467
          tmp___25 = 0;
        }
      }
#line 467
      if (tmp___25) {
#line 467
        tmp___21 = __builtin_strcmp("/", (char const   *)(buf___1));
      } else {
#line 467
        tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 467
        tmp___21 = tmp___24;
      }
    } else {
#line 467
      tmp___24 = __builtin_strcmp("/", (char const   *)(buf___1));
#line 467
      tmp___21 = tmp___24;
    }
#line 467
    if (tmp___21 == 0) {
#line 468
      break;
    } else {
#line 467
      if (0) {
#line 467
        __s1_len___1 = strlen(".");
#line 467
        __s2_len___1 = strlen((char const   *)(buf___1));
#line 467
        if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
          goto _L___6;
        } else {
#line 467
          if (__s1_len___1 >= 4U) {
            _L___6: /* CIL Label */ 
#line 467
            if (! ((unsigned int )((void const   *)(buf___1 + 1)) - (unsigned int )((void const   *)(buf___1)) == 1U)) {
#line 467
              tmp___35 = 1;
            } else {
#line 467
              if (__s2_len___1 >= 4U) {
#line 467
                tmp___35 = 1;
              } else {
#line 467
                tmp___35 = 0;
              }
            }
          } else {
#line 467
            tmp___35 = 0;
          }
        }
#line 467
        if (tmp___35) {
#line 467
          tmp___31 = __builtin_strcmp(".", (char const   *)(buf___1));
        } else {
#line 467
          tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 467
          tmp___31 = tmp___34;
        }
      } else {
#line 467
        tmp___34 = __builtin_strcmp(".", (char const   *)(buf___1));
#line 467
        tmp___31 = tmp___34;
      }
#line 467
      if (tmp___31 == 0) {
#line 468
        break;
      }
    }
  }
#line 470
  return (0);
}
}
#line 473 "auth.c"
struct passwd *getpwnamallow(char const   *user ) 
{ struct passwd *pw___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  struct passwd *tmp___4 ;

  {
#line 484
  tmp = get_remote_ipaddr();
#line 484
  tmp___0 = get_canonical_hostname(options.use_dns);
#line 484
  parse_server_match_config(& options, user, tmp___0, tmp);
#line 487
  pw___0 = getpwnam(user);
#line 488
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 489
    tmp___1 = get_remote_ipaddr();
#line 489
    logit("Invalid user %.100s from %.100s", user, tmp___1);
#line 492
    tmp___2 = get_canonical_hostname(options.use_dns);
#line 492
    record_failed_login(user, tmp___2, "ssh");
#line 498
    return ((struct passwd *)((void *)0));
  }
#line 500
  tmp___3 = allowed_user(pw___0);
#line 500
  if (! tmp___3) {
#line 501
    return ((struct passwd *)((void *)0));
  }
#line 517
  if ((unsigned int )pw___0 != (unsigned int )((void *)0)) {
#line 518
    tmp___4 = pwcopy(pw___0);
#line 518
    return (tmp___4);
  }
#line 519
  return ((struct passwd *)((void *)0));
}
}
#line 522 "auth.c"
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) 
{ char buf___1[1024] ;
  va_list args ;

  {
#line 528
  if (! auth_debug_init) {
#line 529
    return;
  }
#line 531
  __builtin_va_start(args, fmt);
#line 532
  vsnprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )fmt,
            args);
#line 533
  __builtin_va_end(args);
#line 534
  buffer_put_cstring(& auth_debug, (char const   *)(buf___1));
#line 535
  return;
}
}
#line 537 "auth.c"
void auth_debug_send(void) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 542
  if (! auth_debug_init) {
#line 543
    return;
  }
#line 544
  while (1) {
#line 544
    tmp___0 = buffer_len(& auth_debug);
#line 544
    if (! tmp___0) {
#line 544
      break;
    }
#line 545
    tmp = buffer_get_string(& auth_debug, (u_int *)((void *)0));
#line 545
    msg = (char *)tmp;
#line 546
    packet_send_debug("%s", msg);
#line 547
    xfree((void *)msg);
  }
#line 549
  return;
}
}
#line 551 "auth.c"
void auth_debug_reset(void) 
{ 

  {
#line 554
  if (auth_debug_init) {
#line 555
    buffer_clear(& auth_debug);
  } else {
#line 557
    buffer_init(& auth_debug);
#line 558
    auth_debug_init = 1;
  }
#line 560
  return;
}
}
#line 565 "auth.c"
static struct passwd fake  ;
#line 562 "auth.c"
struct passwd *fakepw(void) 
{ 

  {
#line 567
  memset((void *)(& fake), 0, sizeof(fake));
#line 568
  fake.pw_name = (char *)"NOUSER";
#line 569
  fake.pw_passwd = (char *)"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
#line 571
  fake.pw_gecos = (char *)"NOUSER";
#line 572
  if ((unsigned int )privsep_pw == (unsigned int )((void *)0)) {
#line 572
    fake.pw_uid = 4294967295U;
  } else {
#line 572
    fake.pw_uid = privsep_pw->pw_uid;
  }
#line 573
  if ((unsigned int )privsep_pw == (unsigned int )((void *)0)) {
#line 573
    fake.pw_gid = 4294967295U;
  } else {
#line 573
    fake.pw_gid = privsep_pw->pw_gid;
  }
#line 577
  fake.pw_dir = (char *)"/nonexist";
#line 578
  fake.pw_shell = (char *)"/nonexist";
#line 580
  return (& fake);
}
}
#line 1 "auth1.o"
#line 162 "auth.h"
char *get_challenge(Authctxt *authctxt___0 ) ;
#line 163
int verify_response(Authctxt *authctxt___0 , char const   *response ) ;
#line 164
void abandon_challenge_response(Authctxt *authctxt___0 ) ;
#line 44 "monitor_wrap.h"
struct passwd *mm_getpwnamallow(char const   *username ) ;
#line 46
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) ;
#line 47 "auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 48
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 49
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 50
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 51
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 53 "auth1.c"
static char *client_user  =    (char *)((void *)0);
#line 62 "auth1.c"
struct AuthMethod1  const  auth1_methods[6]  = {      {9, (char *)"password", & options.password_authentication, & auth1_process_password}, 
        {6,
      (char *)"rsa", & options.rsa_authentication, & auth1_process_rsa}, 
        {35, (char *)"rhosts-rsa", & options.rhosts_rsa_authentication, & auth1_process_rhosts_rsa}, 
        {39,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_challenge}, 
        {41,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_response}, 
        {-1,
      (char *)((void *)0), (int *)((void *)0), (int (*)(Authctxt * , char * , size_t  ))((void *)0)}};
#line 88 "auth1.c"
static struct AuthMethod1  const  *lookup_authmethod1(int type ) 
{ int i ;

  {
#line 93
  i = 0;
#line 93
  while ((unsigned int )auth1_methods[i].name != (unsigned int )((void *)0)) {
#line 94
    if (auth1_methods[i].type == (int const   )type) {
#line 95
      return (& auth1_methods[i]);
    }
#line 93
    i ++;
  }
#line 97
  return ((struct AuthMethod1  const  *)((void *)0));
}
}
#line 104 "auth1.c"
static char buf[64]  ;
#line 100 "auth1.c"
static char *get_authname(int type ) 
{ struct AuthMethod1  const  *a___0 ;

  {
#line 106
  a___0 = lookup_authmethod1(type);
#line 106
  if ((unsigned int )a___0 != (unsigned int )((void *)0)) {
#line 107
    return ((char *)a___0->name);
  }
#line 108
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"bad-auth-msg-%d",
           type);
#line 109
  return (buf);
}
}
#line 113 "auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  char *password ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 116
  authenticated = 0;
#line 125
  tmp = packet_get_string(& dlen);
#line 125
  password = (char *)tmp;
#line 126
  while (1) {
#line 126
    tmp___0 = packet_remaining();
#line 126
    _len = tmp___0;
#line 126
    if (_len > 0) {
#line 126
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            126);
#line 126
      packet_disconnect("Packet integrity error.");
    }
#line 126
    break;
  }
#line 129
  if (use_privsep) {
#line 129
    authenticated = mm_auth_password(authctxt___0, password);
  } else {
#line 129
    authenticated = auth_password(authctxt___0, (char const   *)password);
  }
#line 131
  memset((void *)password, 0, dlen);
#line 132
  xfree((void *)password);
#line 134
  return (authenticated);
}
}
#line 138 "auth1.c"
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  BIGNUM *n___0 ;
  int _len ;
  int tmp ;

  {
#line 141
  authenticated = 0;
#line 145
  n___0 = BN_new();
#line 145
  if ((unsigned int )n___0 == (unsigned int )((void *)0)) {
#line 146
    fatal("do_authloop: BN_new failed");
  }
#line 147
  packet_get_bignum(n___0);
#line 148
  while (1) {
#line 148
    tmp = packet_remaining();
#line 148
    _len = tmp;
#line 148
    if (_len > 0) {
#line 148
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            148);
#line 148
      packet_disconnect("Packet integrity error.");
    }
#line 148
    break;
  }
#line 149
  authenticated = auth_rsa(authctxt___0, n___0);
#line 150
  BN_clear_free(n___0);
#line 152
  return (authenticated);
}
}
#line 156 "auth1.c"
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int keybits ;
  int authenticated ;
  u_int bits ;
  Key *client_host_key ;
  u_int ulen ;
  void *tmp ;
  int tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 159
  authenticated = 0;
#line 169
  tmp = packet_get_string(& ulen);
#line 169
  client_user = (char *)tmp;
#line 172
  client_host_key = key_new(0);
#line 173
  bits = packet_get_int();
#line 174
  packet_get_bignum((client_host_key->rsa)->e);
#line 175
  packet_get_bignum((client_host_key->rsa)->n);
#line 177
  keybits = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 178
  if (keybits < 0) {
#line 179
    tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 179
    verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
            tmp___0, bits);
  } else {
#line 178
    if (bits != (unsigned int )keybits) {
#line 179
      tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
#line 179
      verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
              tmp___0, bits);
    }
  }
#line 183
  while (1) {
#line 183
    tmp___1 = packet_remaining();
#line 183
    _len = tmp___1;
#line 183
    if (_len > 0) {
#line 183
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            183);
#line 183
      packet_disconnect("Packet integrity error.");
    }
#line 183
    break;
  }
#line 185
  authenticated = auth_rhosts_rsa(authctxt___0, client_user, client_host_key);
#line 187
  key_free(client_host_key);
#line 189
  snprintf((char * __restrict  )info, infolen, (char const   * __restrict  )" ruser %.100s",
           client_user);
#line 191
  return (authenticated);
}
}
#line 195 "auth1.c"
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ char *challenge ;

  {
#line 200
  challenge = get_challenge(authctxt___0);
#line 200
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 201
    return (0);
  }
#line 203
  debug("sending challenge \'%s\'", challenge);
#line 204
  packet_start((unsigned char)40);
#line 205
  packet_put_cstring((char const   *)challenge);
#line 206
  xfree((void *)challenge);
#line 207
  packet_send();
#line 208
  packet_write_wait();
#line 210
  return (-1);
}
}
#line 214 "auth1.c"
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ int authenticated ;
  char *response ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 217
  authenticated = 0;
#line 221
  tmp = packet_get_string(& dlen);
#line 221
  response = (char *)tmp;
#line 222
  while (1) {
#line 222
    tmp___0 = packet_remaining();
#line 222
    _len = tmp___0;
#line 222
    if (_len > 0) {
#line 222
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            222);
#line 222
      packet_disconnect("Packet integrity error.");
    }
#line 222
    break;
  }
#line 223
  authenticated = verify_response(authctxt___0, (char const   *)response);
#line 224
  memset((void *)response, 'r', dlen);
#line 225
  xfree((void *)response);
#line 227
  return (authenticated);
}
}
#line 234 "auth1.c"
static void do_authloop(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char info[1024] ;
  int prev ;
  int type ;
  struct AuthMethod1  const  *meth ;
  char const   *tmp ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 237
  authenticated = 0;
#line 239
  prev = 0;
#line 239
  type = 0;
#line 242
  if (authctxt___0->valid) {
#line 242
    tmp = "";
  } else {
#line 242
    tmp = "invalid user ";
  }
#line 242
  debug("Attempting authentication for %s%.100s.", tmp, authctxt___0->user);
#line 246
  if (options.password_authentication) {
#line 246
    if (use_privsep) {
#line 246
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 246
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 246
    if (tmp___2) {
#line 255
      auth_log(authctxt___0, 1, (char *)"without authentication", (char *)"");
#line 256
      return;
    }
  }
#line 261
  packet_start((unsigned char)15);
#line 262
  packet_send();
#line 263
  packet_write_wait();
#line 265
  while (1) {
#line 267
    authenticated = 0;
#line 269
    info[0] = (char )'\000';
#line 272
    prev = type;
#line 273
    type = packet_read();
#line 282
    if (prev == 39) {
#line 282
      if (type != 41) {
#line 284
        abandon_challenge_response(authctxt___0);
      }
    }
#line 286
    meth = lookup_authmethod1(type);
#line 286
    if ((unsigned int )meth == (unsigned int )((void *)0)) {
#line 287
      logit("Unknown message during authentication: type %d", type);
      goto skip;
    }
#line 292
    if (! *(meth->enabled)) {
#line 293
      verbose("%s authentication disabled.", meth->name);
      goto skip;
    }
#line 297
    authenticated = (*(meth->method))(authctxt___0, info, sizeof(info));
#line 298
    if (authenticated == -1) {
      goto __Cont;
    }
#line 307
    if (! authctxt___0->valid) {
#line 307
      if (authenticated) {
#line 308
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
      }
    }
#line 328
    if (authenticated) {
#line 328
      if ((authctxt___0->pw)->pw_uid == 0U) {
#line 328
        tmp___3 = auth_root_allowed((char *)meth->name);
#line 328
        if (! tmp___3) {
#line 330
          authenticated = 0;
        }
      }
    }
    skip: 
#line 360
    tmp___4 = get_authname(type);
#line 360
    auth_log(authctxt___0, authenticated, tmp___4, info);
#line 362
    if ((unsigned int )client_user != (unsigned int )((void *)0)) {
#line 363
      xfree((void *)client_user);
#line 364
      client_user = (char *)((void *)0);
    }
#line 367
    if (authenticated) {
#line 368
      return;
    }
#line 370
    tmp___5 = authctxt___0->failures;
#line 370
    (authctxt___0->failures) ++;
#line 370
    if (tmp___5 > options.max_authtries) {
#line 374
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 377
    packet_start((unsigned char)15);
#line 378
    packet_send();
#line 379
    packet_write_wait();
    __Cont: /* CIL Label */ ;
  }
}
}
#line 387 "auth1.c"
void do_authentication(Authctxt *authctxt___0 ) 
{ u_int ulen ;
  char *user ;
  char *style ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;

  {
#line 391
  style = (char *)((void *)0);
#line 394
  packet_read_expect(4);
#line 397
  tmp = packet_get_string(& ulen);
#line 397
  user = (char *)tmp;
#line 398
  while (1) {
#line 398
    tmp___0 = packet_remaining();
#line 398
    _len = tmp___0;
#line 398
    if (_len > 0) {
#line 398
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth1.c",
            398);
#line 398
      packet_disconnect("Packet integrity error.");
    }
#line 398
    break;
  }
#line 400
  tmp___3 = __builtin_strchr(user, ':');
#line 400
  style = tmp___3;
#line 400
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 401
    tmp___1 = style;
#line 401
    style ++;
#line 401
    *tmp___1 = (char )'\000';
  }
#line 403
  authctxt___0->user = user;
#line 404
  authctxt___0->style = style;
#line 407
  if (use_privsep) {
#line 407
    authctxt___0->pw = mm_getpwnamallow((char const   *)user);
  } else {
#line 407
    authctxt___0->pw = getpwnamallow((char const   *)user);
  }
#line 407
  if ((unsigned int )authctxt___0->pw != (unsigned int )((void *)0)) {
#line 408
    authctxt___0->valid = 1;
  } else {
#line 410
    debug("do_authentication: invalid user %s", user);
#line 411
    authctxt___0->pw = fakepw();
  }
#line 414
  if (use_privsep) {
#line 414
    tmp___6 = " [net]";
  } else {
#line 414
    tmp___6 = "";
  }
#line 414
  if (authctxt___0->valid) {
#line 414
    tmp___7 = (char const   *)user;
  } else {
#line 414
    tmp___7 = "unknown";
  }
#line 414
  setproctitle("%s%s", tmp___7, tmp___6);
#line 427
  if (! use_privsep) {
#line 427
    tmp___8 = getuid();
#line 427
    if (tmp___8 != 0U) {
#line 427
      if (authctxt___0->pw) {
#line 427
        tmp___9 = getuid();
#line 427
        if ((authctxt___0->pw)->pw_uid != tmp___9) {
#line 429
          packet_disconnect("Cannot change user when server not running as root.");
        }
      }
    }
  }
#line 436
  do_authloop(authctxt___0);
#line 439
  packet_start((unsigned char)14);
#line 440
  packet_send();
#line 441
  packet_write_wait();
#line 442
  return;
}
}
#line 1 "auth2.o"
#line 144 "auth.h"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) ;
#line 153
void auth2_challenge_stop(Authctxt *authctxt___0 ) ;
#line 43 "monitor_wrap.h"
void mm_inform_authserv(char *service , char *style ) ;
#line 61 "auth2.c"
Authmethod method_none ;
#line 62
Authmethod method_pubkey ;
#line 63
Authmethod method_passwd ;
#line 64
Authmethod method_kbdint ;
#line 65
Authmethod method_hostbased ;
#line 70 "auth2.c"
Authmethod *authmethods[6]  = {      & method_none,      & method_pubkey,      & method_passwd,      & method_kbdint, 
        & method_hostbased,      (Authmethod *)((void *)0)};
#line 84
static void input_service_request(int type , u_int32_t seq , void *ctxt ) ;
#line 85
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) ;
#line 88
static Authmethod *authmethod_lookup(char const   *name ) ;
#line 89
static char *authmethods_get(void) ;
#line 95 "auth2.c"
void do_authentication2(Authctxt *authctxt___0 ) 
{ 

  {
#line 98
  dispatch_init(& dispatch_protocol_error);
#line 99
  dispatch_set(5, & input_service_request);
#line 100
  dispatch_run(0, (sig_atomic_t volatile   *)(& authctxt___0->success), (void *)authctxt___0);
#line 101
  return;
}
}
#line 104 "auth2.c"
static void input_service_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  u_int len ;
  int acceptit ;
  char *service ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 107
  authctxt___0 = (Authctxt *)ctxt;
#line 109
  acceptit = 0;
#line 110
  tmp = packet_get_string(& len);
#line 110
  service = (char *)tmp;
#line 111
  while (1) {
#line 111
    tmp___0 = packet_remaining();
#line 111
    _len = tmp___0;
#line 111
    if (_len > 0) {
#line 111
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2.c",
            111);
#line 111
      packet_disconnect("Packet integrity error.");
    }
#line 111
    break;
  }
#line 113
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 114
    fatal("input_service_request: no authctxt");
  }
#line 116
  if (0) {
#line 116
    __s1_len = strlen((char const   *)service);
#line 116
    __s2_len = strlen("ssh-userauth");
#line 116
    if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
      goto _L___0;
    } else {
#line 116
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 116
        if (! ((unsigned int )((void const   *)("ssh-userauth" + 1)) - (unsigned int )((void const   *)"ssh-userauth") == 1U)) {
#line 116
          tmp___10 = 1;
        } else {
#line 116
          if (__s2_len >= 4U) {
#line 116
            tmp___10 = 1;
          } else {
#line 116
            tmp___10 = 0;
          }
        }
      } else {
#line 116
        tmp___10 = 0;
      }
    }
#line 116
    if (tmp___10) {
#line 116
      tmp___6 = __builtin_strcmp((char const   *)service, "ssh-userauth");
    } else {
#line 116
      tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 116
      tmp___6 = tmp___9;
    }
  } else {
#line 116
    tmp___9 = __builtin_strcmp((char const   *)service, "ssh-userauth");
#line 116
    tmp___6 = tmp___9;
  }
#line 116
  if (tmp___6 == 0) {
#line 117
    if (! authctxt___0->success) {
#line 118
      acceptit = 1;
#line 120
      dispatch_set(50, & input_userauth_request);
    }
  }
#line 125
  if (acceptit) {
#line 126
    packet_start((unsigned char)6);
#line 127
    packet_put_cstring((char const   *)service);
#line 128
    packet_send();
#line 129
    packet_write_wait();
  } else {
#line 131
    debug("bad service request %s", service);
#line 132
    packet_disconnect("bad service request %s", service);
  }
#line 134
  xfree((void *)service);
#line 135
  return;
}
}
#line 138 "auth2.c"
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  Authmethod *m___0 ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
#line 141
  authctxt___0 = (Authctxt *)ctxt;
#line 142
  m___0 = (Authmethod *)((void *)0);
#line 143
  style = (char *)((void *)0);
#line 144
  authenticated = 0;
#line 146
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 147
    fatal("input_userauth_request: no authctxt");
  }
#line 149
  tmp = packet_get_string((u_int *)((void *)0));
#line 149
  user = (char *)tmp;
#line 150
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 150
  service = (char *)tmp___0;
#line 151
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 151
  method = (char *)tmp___1;
#line 152
  debug("userauth-request for user %s service %s method %s", user, service, method);
#line 153
  debug("attempt %d failures %d", authctxt___0->attempt, authctxt___0->failures);
#line 155
  tmp___4 = __builtin_strchr(user, ':');
#line 155
  style = tmp___4;
#line 155
  if ((unsigned int )style != (unsigned int )((void *)0)) {
#line 156
    tmp___2 = style;
#line 156
    style ++;
#line 156
    *tmp___2 = (char)0;
  }
#line 158
  tmp___40 = authctxt___0->attempt;
#line 158
  (authctxt___0->attempt) ++;
#line 158
  if (tmp___40 == 0) {
#line 160
    if (use_privsep) {
#line 160
      authctxt___0->pw = mm_getpwnamallow((char const   *)user);
    } else {
#line 160
      authctxt___0->pw = getpwnamallow((char const   *)user);
    }
#line 161
    authctxt___0->user = xstrdup((char const   *)user);
#line 162
    if (authctxt___0->pw) {
#line 162
      if (0) {
#line 162
        __s1_len = strlen((char const   *)service);
#line 162
        __s2_len = strlen("ssh-connection");
#line 162
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___0;
        } else {
#line 162
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 162
            if (! ((unsigned int )((void const   *)("ssh-connection" + 1)) - (unsigned int )((void const   *)"ssh-connection") == 1U)) {
#line 162
              tmp___16 = 1;
            } else {
#line 162
              if (__s2_len >= 4U) {
#line 162
                tmp___16 = 1;
              } else {
#line 162
                tmp___16 = 0;
              }
            }
          } else {
#line 162
            tmp___16 = 0;
          }
        }
#line 162
        if (tmp___16) {
#line 162
          tmp___12 = __builtin_strcmp((char const   *)service, "ssh-connection");
        } else {
#line 162
          tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 162
          tmp___12 = tmp___15;
        }
      } else {
#line 162
        tmp___15 = __builtin_strcmp((char const   *)service, "ssh-connection");
#line 162
        tmp___12 = tmp___15;
      }
#line 162
      if (tmp___12 == 0) {
#line 163
        authctxt___0->valid = 1;
#line 164
        debug2("input_userauth_request: setting up authctxt for %s", user);
      } else {
#line 166
        logit("input_userauth_request: invalid user %s", user);
#line 167
        authctxt___0->pw = fakepw();
      }
    } else {
#line 166
      logit("input_userauth_request: invalid user %s", user);
#line 167
      authctxt___0->pw = fakepw();
    }
#line 176
    if (use_privsep) {
#line 176
      tmp___17 = " [net]";
    } else {
#line 176
      tmp___17 = "";
    }
#line 176
    if (authctxt___0->valid) {
#line 176
      tmp___18 = (char const   *)user;
    } else {
#line 176
      tmp___18 = "unknown";
    }
#line 176
    setproctitle("%s%s", tmp___18, tmp___17);
#line 178
    authctxt___0->service = xstrdup((char const   *)service);
#line 179
    if (style) {
#line 179
      authctxt___0->style = xstrdup((char const   *)style);
    } else {
#line 179
      authctxt___0->style = (char *)((void *)0);
    }
#line 180
    if (use_privsep) {
#line 181
      mm_inform_authserv(service, style);
    }
  } else {
#line 182
    if (0) {
#line 182
      __s1_len___0 = strlen((char const   *)user);
#line 182
      __s2_len___0 = strlen((char const   *)authctxt___0->user);
#line 182
      if (! ((unsigned int )((void const   *)(user + 1)) - (unsigned int )((void const   *)user) == 1U)) {
        goto _L___2;
      } else {
#line 182
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 182
          if (! ((unsigned int )((void const   *)(authctxt___0->user + 1)) - (unsigned int )((void const   *)authctxt___0->user) == 1U)) {
#line 182
            tmp___29 = 1;
          } else {
#line 182
            if (__s2_len___0 >= 4U) {
#line 182
              tmp___29 = 1;
            } else {
#line 182
              tmp___29 = 0;
            }
          }
        } else {
#line 182
          tmp___29 = 0;
        }
      }
#line 182
      if (tmp___29) {
#line 182
        tmp___25 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
      } else {
#line 182
        tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 182
        tmp___25 = tmp___28;
      }
    } else {
#line 182
      tmp___28 = __builtin_strcmp((char const   *)user, (char const   *)authctxt___0->user);
#line 182
      tmp___25 = tmp___28;
    }
#line 183
    if (tmp___25 != 0) {
#line 184
      packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                        authctxt___0->user, authctxt___0->service, user, service);
    } else {
#line 183
      if (0) {
#line 183
        __s1_len___1 = strlen((char const   *)service);
#line 183
        __s2_len___1 = strlen((char const   *)authctxt___0->service);
#line 183
        if (! ((unsigned int )((void const   *)(service + 1)) - (unsigned int )((void const   *)service) == 1U)) {
          goto _L___4;
        } else {
#line 183
          if (__s1_len___1 >= 4U) {
            _L___4: /* CIL Label */ 
#line 183
            if (! ((unsigned int )((void const   *)(authctxt___0->service + 1)) - (unsigned int )((void const   *)authctxt___0->service) == 1U)) {
#line 183
              tmp___39 = 1;
            } else {
#line 183
              if (__s2_len___1 >= 4U) {
#line 183
                tmp___39 = 1;
              } else {
#line 183
                tmp___39 = 0;
              }
            }
          } else {
#line 183
            tmp___39 = 0;
          }
        }
#line 183
        if (tmp___39) {
#line 183
          tmp___35 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
        } else {
#line 183
          tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 183
          tmp___35 = tmp___38;
        }
      } else {
#line 183
        tmp___38 = __builtin_strcmp((char const   *)service, (char const   *)authctxt___0->service);
#line 183
        tmp___35 = tmp___38;
      }
#line 183
      if (tmp___35 != 0) {
#line 184
        packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                          authctxt___0->user, authctxt___0->service, user, service);
      }
    }
  }
#line 189
  auth2_challenge_stop(authctxt___0);
#line 196
  authctxt___0->postponed = 0;
#line 199
  m___0 = authmethod_lookup((char const   *)method);
#line 200
  if ((unsigned int )m___0 != (unsigned int )((void *)0)) {
#line 201
    debug2("input_userauth_request: try method %s", method);
#line 202
    authenticated = (*(m___0->userauth))(authctxt___0);
  }
#line 204
  userauth_finish(authctxt___0, authenticated, method);
#line 206
  xfree((void *)service);
#line 207
  xfree((void *)user);
#line 208
  xfree((void *)method);
#line 209
  return;
}
}
#line 211 "auth2.c"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) 
{ char *methods ;
  int tmp ;
  int tmp___0 ;

  {
#line 216
  if (! authctxt___0->valid) {
#line 216
    if (authenticated) {
#line 217
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
    }
  }
#line 221
  if (authenticated) {
#line 221
    if ((authctxt___0->pw)->pw_uid == 0U) {
#line 221
      tmp = auth_root_allowed(method);
#line 221
      if (! tmp) {
#line 223
        authenticated = 0;
      }
    }
  }
#line 252
  auth_log(authctxt___0, authenticated, method, (char *)" ssh2");
#line 254
  if (authctxt___0->postponed) {
#line 255
    return;
  }
#line 258
  if (authenticated == 1) {
#line 260
    dispatch_set(50, & dispatch_protocol_ignore);
#line 261
    packet_start((unsigned char)52);
#line 262
    packet_send();
#line 263
    packet_write_wait();
#line 265
    authctxt___0->success = 1;
  } else {
#line 267
    tmp___0 = authctxt___0->failures;
#line 267
    (authctxt___0->failures) ++;
#line 267
    if (tmp___0 > options.max_authtries) {
#line 271
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
    }
#line 273
    methods = authmethods_get();
#line 274
    packet_start((unsigned char)51);
#line 275
    packet_put_cstring((char const   *)methods);
#line 276
    packet_put_char(0);
#line 277
    packet_send();
#line 278
    packet_write_wait();
#line 279
    xfree((void *)methods);
  }
#line 281
  return;
}
}
#line 283 "auth2.c"
static char *authmethods_get(void) 
{ Buffer b ;
  char *list ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  u_int tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;

  {
#line 290
  buffer_init(& b);
#line 291
  i = 0;
#line 291
  while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 292
    if (0) {
#line 292
      __s1_len = strlen((char const   *)(authmethods[i])->name);
#line 292
      __s2_len = strlen("none");
#line 292
      if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
        goto _L___0;
      } else {
#line 292
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 292
          if (! ((unsigned int )((void const   *)("none" + 1)) - (unsigned int )((void const   *)"none") == 1U)) {
#line 292
            tmp___8 = 1;
          } else {
#line 292
            if (__s2_len >= 4U) {
#line 292
              tmp___8 = 1;
            } else {
#line 292
              tmp___8 = 0;
            }
          }
        } else {
#line 292
          tmp___8 = 0;
        }
      }
#line 292
      if (tmp___8) {
#line 292
        tmp___4 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
      } else {
#line 292
        tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 292
        tmp___4 = tmp___7;
      }
    } else {
#line 292
      tmp___7 = __builtin_strcmp((char const   *)(authmethods[i])->name, "none");
#line 292
      tmp___4 = tmp___7;
    }
#line 292
    if (tmp___4 == 0) {
      goto __Cont;
    }
#line 294
    if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 294
      if (*((authmethods[i])->enabled) != 0) {
#line 296
        tmp___9 = buffer_len(& b);
#line 296
        if (tmp___9 > 0U) {
#line 297
          buffer_append(& b, (void const   *)",", 1U);
        }
#line 298
        tmp___10 = strlen((char const   *)(authmethods[i])->name);
#line 298
        buffer_append(& b, (void const   *)(authmethods[i])->name, tmp___10);
      }
    }
    __Cont: /* CIL Label */ 
#line 291
    i ++;
  }
#line 302
  buffer_append(& b, (void const   *)"\000", 1U);
#line 303
  tmp___11 = buffer_ptr(& b);
#line 303
  list = xstrdup((char const   *)tmp___11);
#line 304
  buffer_free(& b);
#line 305
  return (list);
}
}
#line 308 "auth2.c"
static Authmethod *authmethod_lookup(char const   *name ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 313
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 314
    i = 0;
#line 314
    while ((unsigned int )authmethods[i] != (unsigned int )((void *)0)) {
#line 317
      if ((unsigned int )(authmethods[i])->enabled != (unsigned int )((void *)0)) {
#line 317
        if (*((authmethods[i])->enabled) != 0) {
#line 317
          if (0) {
#line 317
            __s1_len = strlen(name);
#line 317
            __s2_len = strlen((char const   *)(authmethods[i])->name);
#line 317
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___0;
            } else {
#line 317
              if (__s1_len >= 4U) {
                _L___0: /* CIL Label */ 
#line 317
                if (! ((unsigned int )((void const   *)((authmethods[i])->name + 1)) - (unsigned int )((void const   *)(authmethods[i])->name) == 1U)) {
#line 317
                  tmp___8 = 1;
                } else {
#line 317
                  if (__s2_len >= 4U) {
#line 317
                    tmp___8 = 1;
                  } else {
#line 317
                    tmp___8 = 0;
                  }
                }
              } else {
#line 317
                tmp___8 = 0;
              }
            }
#line 317
            if (tmp___8) {
#line 317
              tmp___4 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
            } else {
#line 317
              tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 317
              tmp___4 = tmp___7;
            }
          } else {
#line 317
            tmp___7 = __builtin_strcmp(name, (char const   *)(authmethods[i])->name);
#line 317
            tmp___4 = tmp___7;
          }
#line 317
          if (tmp___4 == 0) {
#line 318
            return (authmethods[i]);
          }
        }
      }
#line 314
      i ++;
    }
  }
#line 319
  if (name) {
#line 319
    tmp___9 = name;
  } else {
#line 319
    tmp___9 = "NULL";
  }
#line 319
  debug2("Unrecognized authentication method name: %s", tmp___9);
#line 321
  return ((Authmethod *)((void *)0));
}
}
#line 1 "auth-options.o"
#line 58 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 28 "auth-options.h"
int no_pty_flag ;
#line 29
int no_user_rc ;
#line 31
struct envstring *custom_environment ;
#line 41 "auth-options.c"
int no_port_forwarding_flag  =    0;
#line 42 "auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 43 "auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 44 "auth-options.c"
int no_pty_flag  =    0;
#line 45 "auth-options.c"
int no_user_rc  =    0;
#line 48 "auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 51 "auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 54 "auth-options.c"
int forced_tun_device  =    -1;
#line 58 "auth-options.c"
void auth_clear_options(void) 
{ struct envstring *ce ;

  {
#line 61
  no_agent_forwarding_flag = 0;
#line 62
  no_port_forwarding_flag = 0;
#line 63
  no_pty_flag = 0;
#line 64
  no_x11_forwarding_flag = 0;
#line 65
  no_user_rc = 0;
#line 66
  while (custom_environment) {
#line 67
    ce = custom_environment;
#line 68
    custom_environment = ce->next;
#line 69
    xfree((void *)ce->s);
#line 70
    xfree((void *)ce);
  }
#line 72
  if (forced_command) {
#line 73
    xfree((void *)forced_command);
#line 74
    forced_command = (char *)((void *)0);
  }
#line 76
  forced_tun_device = -1;
#line 77
  channel_clear_permitted_opens();
#line 78
  auth_debug_reset();
#line 79
  return;
}
}
#line 85 "auth-options.c"
int auth_parse_options(struct passwd *pw___0 , char *opts , char *file___0 , u_long linenum ) 
{ char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  char const   *remote_ip___0 ;
  char const   *tmp___31 ;
  char const   *remote_host ;
  char const   *tmp___32 ;
  char *patterns ;
  size_t tmp___33 ;
  void *tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  char *host ;
  char *p ;
  u_short port___0 ;
  char *patterns___0 ;
  size_t tmp___42 ;
  void *tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  size_t tmp___48 ;
  char const   *tmp___49 ;
  int tmp___50 ;
  size_t tmp___51 ;
  int tmp___52 ;
  char *tun ;
  size_t tmp___53 ;
  size_t tmp___54 ;
  void *tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;
  size_t tmp___58 ;
  int tmp___59 ;

  {
#line 92
  auth_clear_options();
#line 94
  if (! opts) {
#line 95
    return (1);
  }
#line 97
  while (1) {
#line 97
    if (*opts) {
#line 97
      if ((int )*opts != 32) {
#line 97
        if (! ((int )*opts != 9)) {
#line 97
          break;
        }
      } else {
#line 97
        break;
      }
    } else {
#line 97
      break;
    }
#line 98
    cp = "no-port-forwarding";
#line 99
    tmp___0 = strlen(cp);
#line 99
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
#line 99
    if (tmp___1 == 0) {
#line 100
      auth_debug_add("Port forwarding disabled.");
#line 101
      no_port_forwarding_flag = 1;
#line 102
      tmp = strlen(cp);
#line 102
      opts += tmp;
      goto next_option;
    }
#line 105
    cp = "no-agent-forwarding";
#line 106
    tmp___3 = strlen(cp);
#line 106
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
#line 106
    if (tmp___4 == 0) {
#line 107
      auth_debug_add("Agent forwarding disabled.");
#line 108
      no_agent_forwarding_flag = 1;
#line 109
      tmp___2 = strlen(cp);
#line 109
      opts += tmp___2;
      goto next_option;
    }
#line 112
    cp = "no-X11-forwarding";
#line 113
    tmp___6 = strlen(cp);
#line 113
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
#line 113
    if (tmp___7 == 0) {
#line 114
      auth_debug_add("X11 forwarding disabled.");
#line 115
      no_x11_forwarding_flag = 1;
#line 116
      tmp___5 = strlen(cp);
#line 116
      opts += tmp___5;
      goto next_option;
    }
#line 119
    cp = "no-pty";
#line 120
    tmp___9 = strlen(cp);
#line 120
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
#line 120
    if (tmp___10 == 0) {
#line 121
      auth_debug_add("Pty allocation disabled.");
#line 122
      no_pty_flag = 1;
#line 123
      tmp___8 = strlen(cp);
#line 123
      opts += tmp___8;
      goto next_option;
    }
#line 126
    cp = "no-user-rc";
#line 127
    tmp___12 = strlen(cp);
#line 127
    tmp___13 = strncasecmp((char const   *)opts, cp, tmp___12);
#line 127
    if (tmp___13 == 0) {
#line 128
      auth_debug_add("User rc file execution disabled.");
#line 129
      no_user_rc = 1;
#line 130
      tmp___11 = strlen(cp);
#line 130
      opts += tmp___11;
      goto next_option;
    }
#line 133
    cp = "command=\"";
#line 134
    tmp___20 = strlen(cp);
#line 134
    tmp___21 = strncasecmp((char const   *)opts, cp, tmp___20);
#line 134
    if (tmp___21 == 0) {
#line 135
      tmp___14 = strlen(cp);
#line 135
      opts += tmp___14;
#line 136
      tmp___15 = strlen((char const   *)opts);
#line 136
      tmp___16 = xmalloc(tmp___15 + 1U);
#line 136
      forced_command = (char *)tmp___16;
#line 137
      i = 0;
#line 138
      while (*opts) {
#line 139
        if ((int )*opts == 34) {
#line 140
          break;
        }
#line 141
        if ((int )*opts == 92) {
#line 141
          if ((int )*(opts + 1) == 34) {
#line 142
            opts += 2;
#line 143
            tmp___17 = i;
#line 143
            i ++;
#line 143
            *(forced_command + tmp___17) = (char )'\"';
#line 144
            continue;
          }
        }
#line 146
        tmp___18 = i;
#line 146
        i ++;
#line 146
        tmp___19 = opts;
#line 146
        opts ++;
#line 146
        *(forced_command + tmp___18) = *tmp___19;
      }
#line 148
      if (! *opts) {
#line 149
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 151
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 153
        xfree((void *)forced_command);
#line 154
        forced_command = (char *)((void *)0);
        goto bad_option;
      }
#line 157
      *(forced_command + i) = (char )'\000';
#line 158
      auth_debug_add("Forced command: %.900s", forced_command);
#line 159
      opts ++;
      goto next_option;
    }
#line 162
    cp = "environment=\"";
#line 163
    if (options.permit_user_env) {
#line 163
      tmp___29 = strlen(cp);
#line 163
      tmp___30 = strncasecmp((char const   *)opts, cp, tmp___29);
#line 163
      if (tmp___30 == 0) {
#line 168
        tmp___22 = strlen(cp);
#line 168
        opts += tmp___22;
#line 169
        tmp___23 = strlen((char const   *)opts);
#line 169
        tmp___24 = xmalloc(tmp___23 + 1U);
#line 169
        s = (char *)tmp___24;
#line 170
        i = 0;
#line 171
        while (*opts) {
#line 172
          if ((int )*opts == 34) {
#line 173
            break;
          }
#line 174
          if ((int )*opts == 92) {
#line 174
            if ((int )*(opts + 1) == 34) {
#line 175
              opts += 2;
#line 176
              tmp___25 = i;
#line 176
              i ++;
#line 176
              *(s + tmp___25) = (char )'\"';
#line 177
              continue;
            }
          }
#line 179
          tmp___26 = i;
#line 179
          i ++;
#line 179
          tmp___27 = opts;
#line 179
          opts ++;
#line 179
          *(s + tmp___26) = *tmp___27;
        }
#line 181
        if (! *opts) {
#line 182
          debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 184
          auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 186
          xfree((void *)s);
          goto bad_option;
        }
#line 189
        *(s + i) = (char )'\000';
#line 190
        auth_debug_add("Adding to environment: %.900s", s);
#line 191
        debug("Adding to environment: %.900s", s);
#line 192
        opts ++;
#line 193
        tmp___28 = xmalloc(sizeof(struct envstring ));
#line 193
        new_envstring = (struct envstring *)tmp___28;
#line 194
        new_envstring->s = s;
#line 195
        new_envstring->next = custom_environment;
#line 196
        custom_environment = new_envstring;
        goto next_option;
      }
    }
#line 199
    cp = "from=\"";
#line 200
    tmp___40 = strlen(cp);
#line 200
    tmp___41 = strncasecmp((char const   *)opts, cp, tmp___40);
#line 200
    if (tmp___41 == 0) {
#line 201
      tmp___31 = get_remote_ipaddr();
#line 201
      remote_ip___0 = tmp___31;
#line 202
      tmp___32 = get_canonical_hostname(options.use_dns);
#line 202
      remote_host = tmp___32;
#line 204
      tmp___33 = strlen((char const   *)opts);
#line 204
      tmp___34 = xmalloc(tmp___33 + 1U);
#line 204
      patterns = (char *)tmp___34;
#line 206
      tmp___35 = strlen(cp);
#line 206
      opts += tmp___35;
#line 207
      i = 0;
#line 208
      while (*opts) {
#line 209
        if ((int )*opts == 34) {
#line 210
          break;
        }
#line 211
        if ((int )*opts == 92) {
#line 211
          if ((int )*(opts + 1) == 34) {
#line 212
            opts += 2;
#line 213
            tmp___36 = i;
#line 213
            i ++;
#line 213
            *(patterns + tmp___36) = (char )'\"';
#line 214
            continue;
          }
        }
#line 216
        tmp___37 = i;
#line 216
        i ++;
#line 216
        tmp___38 = opts;
#line 216
        opts ++;
#line 216
        *(patterns + tmp___37) = *tmp___38;
      }
#line 218
      if (! *opts) {
#line 219
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 221
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 223
        xfree((void *)patterns);
        goto bad_option;
      }
#line 226
      *(patterns + i) = (char )'\000';
#line 227
      opts ++;
#line 228
      tmp___39 = match_host_and_ip(remote_host, remote_ip___0, (char const   *)patterns);
#line 228
      if (tmp___39 != 1) {
#line 230
        xfree((void *)patterns);
#line 231
        logit("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
              pw___0->pw_name, remote_host, remote_ip___0);
#line 235
        auth_debug_add("Your host \'%.200s\' is not permitted to use this key for login.",
                       remote_host);
#line 239
        return (0);
      }
#line 241
      xfree((void *)patterns);
      goto next_option;
    }
#line 245
    cp = "permitopen=\"";
#line 246
    tmp___51 = strlen(cp);
#line 246
    tmp___52 = strncasecmp((char const   *)opts, cp, tmp___51);
#line 246
    if (tmp___52 == 0) {
#line 249
      tmp___42 = strlen((char const   *)opts);
#line 249
      tmp___43 = xmalloc(tmp___42 + 1U);
#line 249
      patterns___0 = (char *)tmp___43;
#line 251
      tmp___44 = strlen(cp);
#line 251
      opts += tmp___44;
#line 252
      i = 0;
#line 253
      while (*opts) {
#line 254
        if ((int )*opts == 34) {
#line 255
          break;
        }
#line 256
        if ((int )*opts == 92) {
#line 256
          if ((int )*(opts + 1) == 34) {
#line 257
            opts += 2;
#line 258
            tmp___45 = i;
#line 258
            i ++;
#line 258
            *(patterns___0 + tmp___45) = (char )'\"';
#line 259
            continue;
          }
        }
#line 261
        tmp___46 = i;
#line 261
        i ++;
#line 261
        tmp___47 = opts;
#line 261
        opts ++;
#line 261
        *(patterns___0 + tmp___46) = *tmp___47;
      }
#line 263
      if (! *opts) {
#line 264
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 266
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 268
        xfree((void *)patterns___0);
        goto bad_option;
      }
#line 271
      *(patterns___0 + i) = (char )'\000';
#line 272
      opts ++;
#line 273
      p = patterns___0;
#line 274
      host = hpdelim(& p);
#line 275
      if ((unsigned int )host == (unsigned int )((void *)0)) {
#line 276
        debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file___0,
              linenum, patterns___0);
#line 279
        auth_debug_add("%.100s, line %lu: Bad permitopen specification", file___0,
                       linenum);
#line 282
        xfree((void *)patterns___0);
        goto bad_option;
      } else {
#line 275
        tmp___48 = strlen((char const   *)host);
#line 275
        if (tmp___48 >= 1025U) {
#line 276
          debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file___0,
                linenum, patterns___0);
#line 279
          auth_debug_add("%.100s, line %lu: Bad permitopen specification", file___0,
                         linenum);
#line 282
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 285
      host = cleanhostname(host);
#line 286
      if ((unsigned int )p == (unsigned int )((void *)0)) {
        goto _L;
      } else {
#line 286
        tmp___50 = a2port((char const   *)p);
#line 286
        port___0 = (unsigned short )tmp___50;
#line 286
        if ((int )port___0 == 0) {
          _L: /* CIL Label */ 
#line 287
          if (p) {
#line 287
            tmp___49 = (char const   *)p;
          } else {
#line 287
            tmp___49 = "";
          }
#line 287
          debug("%.100s, line %lu: Bad permitopen port <%.100s>", file___0, linenum,
                tmp___49);
#line 289
          auth_debug_add("%.100s, line %lu: Bad permitopen port", file___0, linenum);
#line 291
          xfree((void *)patterns___0);
          goto bad_option;
        }
      }
#line 294
      if (options.allow_tcp_forwarding) {
#line 295
        channel_add_permitted_opens(host, (int )port___0);
      }
#line 296
      xfree((void *)patterns___0);
      goto next_option;
    }
#line 299
    cp = "tunnel=\"";
#line 300
    tmp___58 = strlen(cp);
#line 300
    tmp___59 = strncasecmp((char const   *)opts, cp, tmp___58);
#line 300
    if (tmp___59 == 0) {
#line 301
      tun = (char *)((void *)0);
#line 302
      tmp___53 = strlen(cp);
#line 302
      opts += tmp___53;
#line 303
      tmp___54 = strlen((char const   *)opts);
#line 303
      tmp___55 = xmalloc(tmp___54 + 1U);
#line 303
      tun = (char *)tmp___55;
#line 304
      i = 0;
#line 305
      while (*opts) {
#line 306
        if ((int )*opts == 34) {
#line 307
          break;
        }
#line 308
        tmp___56 = i;
#line 308
        i ++;
#line 308
        tmp___57 = opts;
#line 308
        opts ++;
#line 308
        *(tun + tmp___56) = *tmp___57;
      }
#line 310
      if (! *opts) {
#line 311
        debug("%.100s, line %lu: missing end quote", file___0, linenum);
#line 313
        auth_debug_add("%.100s, line %lu: missing end quote", file___0, linenum);
#line 315
        xfree((void *)tun);
#line 316
        forced_tun_device = -1;
        goto bad_option;
      }
#line 319
      *(tun + i) = (char )'\000';
#line 320
      forced_tun_device = a2tun((char const   *)tun, (int *)((void *)0));
#line 321
      xfree((void *)tun);
#line 322
      if (forced_tun_device == 2147483646) {
#line 323
        debug("%.100s, line %lu: invalid tun device", file___0, linenum);
#line 325
        auth_debug_add("%.100s, line %lu: invalid tun device", file___0, linenum);
#line 327
        forced_tun_device = -1;
        goto bad_option;
      }
#line 330
      auth_debug_add("Forced tun device: %d", forced_tun_device);
#line 331
      opts ++;
      goto next_option;
    }
    next_option: 
#line 339
    if (! *opts) {
#line 340
      fatal("Bugs in auth-options.c option processing.");
    }
#line 341
    if ((int )*opts == 32) {
#line 342
      break;
    } else {
#line 341
      if ((int )*opts == 9) {
#line 342
        break;
      }
    }
#line 343
    if ((int )*opts != 44) {
      goto bad_option;
    }
#line 345
    opts ++;
  }
#line 349
  if (! use_privsep) {
#line 350
    auth_debug_send();
  }
#line 353
  return (1);
  bad_option: 
#line 356
  logit("Bad options in %.100s file, line %lu: %.50s", file___0, linenum, opts);
#line 358
  auth_debug_add("Bad options in %.100s file, line %lu: %.50s", file___0, linenum,
                 opts);
#line 361
  if (! use_privsep) {
#line 362
    auth_debug_send();
  }
#line 365
  return (0);
}
}
#line 1 "session.o"
#line 81 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 333 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 199
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 504 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 845
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 72 "session.h"
void session_pty_cleanup2(Session *s ) ;
#line 74
Session *session_new(void) ;
#line 75
Session *session_by_tty(char *tty ) ;
#line 76
void session_close(Session *s ) ;
#line 78
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) ;
#line 81 "monitor_wrap.h"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) ;
#line 82
void mm_session_pty_cleanup2(struct Session *s ) ;
#line 96 "sftp.h"
int sftp_server_main(int argc , char **argv , struct passwd *user_pw ) ;
#line 100 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 101
void session_pty_cleanup(Session *s ) ;
#line 102
void session_proctitle(Session *s ) ;
#line 103
int session_setup_x11fwd(Session *s ) ;
#line 104
void do_exec_pty(Session *s , char const   *command ) ;
#line 105
void do_exec_no_pty(Session *s , char const   *command ) ;
#line 106
void do_exec(Session *s , char const   *command ) ;
#line 107
void do_login(Session *s , char const   *command ) ;
#line 111
void do_child(Session *s , char const   *command ) ;
#line 112
void do_motd(void) ;
#line 113
int check_quietlogin(Session *s , char const   *command ) ;
#line 115
static void do_authenticated1(Authctxt *authctxt___0 ) ;
#line 116
static void do_authenticated2(Authctxt *authctxt___0 ) ;
#line 118
static int session_pty_req(Session *s ) ;
#line 131 "session.c"
char const   *original_command  =    (char const   *)((void *)0);
#line 135 "session.c"
Session sessions[20]  ;
#line 145 "session.c"
static int is_child  =    0;
#line 148 "session.c"
static char *auth_sock_name  =    (char *)((void *)0);
#line 149 "session.c"
static char *auth_sock_dir  =    (char *)((void *)0);
#line 153 "session.c"
static void auth_sock_cleanup_proc(struct passwd *pw___0 ) 
{ 

  {
#line 156
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 157
    temporarily_use_uid(pw___0);
#line 158
    unlink((char const   *)auth_sock_name);
#line 159
    rmdir((char const   *)auth_sock_dir);
#line 160
    auth_sock_name = (char *)((void *)0);
#line 161
    restore_uid();
  }
#line 163
  return;
}
}
#line 165 "session.c"
static int auth_input_request_forwarding(struct passwd *pw___0 ) 
{ Channel *nc ;
  int sock ;
  struct sockaddr_un sunaddr ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 172
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 173
    error("authentication forwarding requested twice.");
#line 174
    return (0);
  }
#line 178
  temporarily_use_uid(pw___0);
#line 181
  tmp = xmalloc(4096U);
#line 181
  auth_sock_name = (char *)tmp;
#line 182
  tmp___0 = xmalloc(4096U);
#line 182
  auth_sock_dir = (char *)tmp___0;
#line 183
  strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", 4096U);
#line 186
  tmp___3 = mkdtemp(auth_sock_dir);
#line 186
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 187
    tmp___1 = __errno_location();
#line 187
    tmp___2 = strerror(*tmp___1);
#line 187
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___2);
#line 189
    restore_uid();
#line 190
    xfree((void *)auth_sock_name);
#line 191
    xfree((void *)auth_sock_dir);
#line 192
    auth_sock_name = (char *)((void *)0);
#line 193
    auth_sock_dir = (char *)((void *)0);
#line 194
    return (0);
  }
#line 196
  tmp___4 = getpid();
#line 196
  snprintf((char * __restrict  )auth_sock_name, 4096U, (char const   * __restrict  )"%s/agent.%ld",
           auth_sock_dir, (long )tmp___4);
#line 200
  sock = socket(1, 1, 0);
#line 201
  if (sock < 0) {
#line 202
    tmp___5 = __errno_location();
#line 202
    tmp___6 = strerror(*tmp___5);
#line 202
    packet_disconnect("socket: %.100s", tmp___6);
  }
#line 205
  memset((void *)(& sunaddr), 0, sizeof(sunaddr));
#line 206
  sunaddr.sun_family = (unsigned short)1;
#line 207
  strlcpy(sunaddr.sun_path, (char const   *)auth_sock_name, sizeof(sunaddr.sun_path));
#line 209
  tmp___9 = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sunaddr)),
                 sizeof(sunaddr));
#line 209
  if (tmp___9 < 0) {
#line 210
    tmp___7 = __errno_location();
#line 210
    tmp___8 = strerror(*tmp___7);
#line 210
    packet_disconnect("bind: %.100s", tmp___8);
  }
#line 213
  restore_uid();
#line 216
  tmp___12 = listen(sock, 128);
#line 216
  if (tmp___12 < 0) {
#line 217
    tmp___10 = __errno_location();
#line 217
    tmp___11 = strerror(*tmp___10);
#line 217
    packet_disconnect("listen: %.100s", tmp___11);
  }
#line 220
  nc = channel_new((char *)"auth socket", 6, sock, sock, -1, 65536U, 16384U, 0, (char *)"auth socket",
                   1);
#line 224
  strlcpy(nc->path, (char const   *)auth_sock_name, sizeof(nc->path));
#line 225
  return (1);
}
}
#line 228 "session.c"
static void display_loginmsg(void) 
{ void *tmp ;
  u_int tmp___0 ;

  {
#line 231
  tmp___0 = buffer_len(& loginmsg);
#line 231
  if (tmp___0 > 0U) {
#line 232
    buffer_append(& loginmsg, (void const   *)"\000", 1U);
#line 233
    tmp = buffer_ptr(& loginmsg);
#line 233
    printf((char const   * __restrict  )"%s", (char *)tmp);
#line 234
    buffer_clear(& loginmsg);
  }
#line 236
  return;
}
}
#line 238 "session.c"
void do_authenticated(Authctxt *authctxt___0 ) 
{ 

  {
#line 241
  setproctitle("%s", (authctxt___0->pw)->pw_name);
#line 244
  if (! no_port_forwarding_flag) {
#line 244
    if (options.allow_tcp_forwarding) {
#line 245
      channel_permit_all_opens();
    }
  }
#line 247
  if (compat20) {
#line 248
    do_authenticated2(authctxt___0);
  } else {
#line 250
    do_authenticated1(authctxt___0);
  }
#line 252
  do_cleanup(authctxt___0);
#line 253
  return;
}
}
#line 261 "session.c"
static void do_authenticated1(Authctxt *authctxt___0 ) 
{ Session *s ;
  char *command ;
  int success ;
  int type ;
  int screen_flag ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  u_int compression_level ;
  int _len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int _len___1 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 267
  enable_compression_after_reply = 0;
#line 268
  compression_level = (u_int )0;
#line 270
  s = session_new();
#line 271
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 272
    error("no more sessions");
#line 273
    return;
  }
#line 275
  s->authctxt = authctxt___0;
#line 276
  s->pw = authctxt___0->pw;
#line 282
  while (1) {
#line 283
    success = 0;
#line 286
    type = packet_read();
#line 289
    switch (type) {
    case 37: 
#line 291
    compression_level = packet_get_int();
#line 292
    while (1) {
#line 292
      tmp = packet_remaining();
#line 292
      _len = tmp;
#line 292
      if (_len > 0) {
#line 292
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
              292);
#line 292
        packet_disconnect("Packet integrity error.");
      }
#line 292
      break;
    }
#line 293
    if (compression_level < 1U) {
#line 294
      packet_send_debug("Received invalid compression level %d.", compression_level);
#line 296
      break;
    } else {
#line 293
      if (compression_level > 9U) {
#line 294
        packet_send_debug("Received invalid compression level %d.", compression_level);
#line 296
        break;
      }
    }
#line 298
    if (options.compression == 0) {
#line 299
      debug2("compression disabled");
#line 300
      break;
    }
#line 303
    enable_compression_after_reply = 1;
#line 304
    success = 1;
#line 305
    break;
    case 10: 
#line 308
    success = session_pty_req(s);
#line 309
    break;
    case 34: 
#line 312
    tmp___0 = packet_get_string(& proto_len);
#line 312
    s->auth_proto = (char *)tmp___0;
#line 313
    tmp___1 = packet_get_string(& data_len);
#line 313
    s->auth_data = (char *)tmp___1;
#line 315
    tmp___2 = packet_get_protocol_flags();
#line 315
    screen_flag = (int )(tmp___2 & 1U);
#line 317
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
#line 319
    tmp___3 = packet_remaining();
#line 319
    if (tmp___3 == 4) {
#line 320
      if (! screen_flag) {
#line 321
        debug2("Buggy client: X11 screen flag missing");
      }
#line 323
      s->screen = packet_get_int();
    } else {
#line 325
      s->screen = 0U;
    }
#line 327
    while (1) {
#line 327
      tmp___4 = packet_remaining();
#line 327
      _len___0 = tmp___4;
#line 327
      if (_len___0 > 0) {
#line 327
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "session.c",
              327);
#line 327
        packet_disconnect("Packet integrity error.");
      }
#line 327
      break;
    }
#line 328
    success = session_setup_x11fwd(s);
#line 329
    if (! success) {
#line 330
      xfree((void *)s->auth_proto);
#line 331
      xfree((void *)s->auth_data);
#line 332
      s->auth_proto = (char *)((void *)0);
#line 333
      s->auth_data = (char *)((void *)0);
    }
#line 335
    break;
    case 30: 
#line 338
    if (no_agent_forwarding_flag) {
#line 339
      debug("Authentication agent forwarding not permitted for this authentication.");
#line 340
      break;
    } else {
#line 338
      if (compat13) {
#line 339
        debug("Authentication agent forwarding not permitted for this authentication.");
#line 340
        break;
      }
    }
#line 342
    debug("Received authentication agent forwarding request.");
#line 343
    success = auth_input_request_forwarding(s->pw);
#line 344
    break;
    case 28: 
#line 347
    if (no_port_forwarding_flag) {
#line 348
      debug("Port forwarding not permitted for this authentication.");
#line 349
      break;
    }
#line 351
    if (! options.allow_tcp_forwarding) {
#line 352
      debug("Port forwarding not permitted.");
#line 353
      break;
    }
#line 355
    debug("Received TCP/IP port forwarding request.");
#line 356
    tmp___5 = channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
#line 356
    if (tmp___5 < 0) {
#line 358
      debug("Port forwarding failed.");
#line 359
      break;
    }
#line 361
    success = 1;
#line 362
    break;
    case 38: 
#line 365
    tmp___6 = packet_get_int();
#line 365
    tmp___7 = packet_set_maxsize(tmp___6);
#line 365
    if (tmp___7 > 0) {
#line 366
      success = 1;
    }
#line 367
    break;
    case 12: 
    case 13: 
#line 371
    if (type == 13) {
#line 372
      tmp___8 = packet_get_string(& dlen);
#line 372
      command = (char *)tmp___8;
#line 373
      debug("Exec command \'%.500s\'", command);
#line 374
      do_exec(s, (char const   *)command);
#line 375
      xfree((void *)command);
    } else {
#line 377
      do_exec(s, (char const   *)((void *)0));
    }
#line 379
    while (1) {
#line 379
      tmp___9 = packet_remaining();
#line 379
      _len___1 = tmp___9;
#line 379
      if (_len___1 > 0) {
#line 379
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "session.c",
              379);
#line 379
        packet_disconnect("Packet integrity error.");
      }
#line 379
      break;
    }
#line 380
    session_close(s);
#line 381
    return;
    default: 
#line 388
    logit("Unknown packet type received after authentication: %d", type);
    }
#line 390
    if (success) {
#line 390
      tmp___10 = 14;
    } else {
#line 390
      tmp___10 = 15;
    }
#line 390
    packet_start((unsigned char )tmp___10);
#line 391
    packet_send();
#line 392
    packet_write_wait();
#line 395
    if (enable_compression_after_reply) {
#line 396
      enable_compression_after_reply = 0;
#line 397
      packet_start_compression((int )compression_level);
    }
  }
}
}
#line 407 "session.c"
void do_exec_no_pty(Session *s , char const   *command ) 
{ pid_t pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 421
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
#line 421
  if (tmp___1 < 0) {
#line 423
    tmp = __errno_location();
#line 423
    tmp___0 = strerror(*tmp);
#line 423
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
  } else {
#line 421
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
#line 421
    if (tmp___2 < 0) {
#line 423
      tmp = __errno_location();
#line 423
      tmp___0 = strerror(*tmp);
#line 423
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
  }
#line 426
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 427
    fatal("do_exec_no_pty: no session");
  }
#line 429
  session_proctitle(s);
#line 432
  pid = fork();
#line 432
  if (pid == 0) {
#line 433
    is_child = 1;
#line 436
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 442
    tmp___5 = setsid();
#line 442
    if (tmp___5 < 0) {
#line 443
      tmp___3 = __errno_location();
#line 443
      tmp___4 = strerror(*tmp___3);
#line 443
      error("setsid failed: %.100s", tmp___4);
    }
#line 472
    close(inout[1]);
#line 473
    close(err[1]);
#line 474
    tmp___6 = dup2(inout[0], 0);
#line 474
    if (tmp___6 < 0) {
#line 475
      perror("dup2 stdin");
    }
#line 476
    tmp___7 = dup2(inout[0], 1);
#line 476
    if (tmp___7 < 0) {
#line 477
      perror("dup2 stdout");
    }
#line 478
    tmp___8 = dup2(err[0], 2);
#line 478
    if (tmp___8 < 0) {
#line 479
      perror("dup2 stderr");
    }
#line 487
    do_child(s, command);
  }
#line 497
  if (pid < 0) {
#line 498
    tmp___9 = __errno_location();
#line 498
    tmp___10 = strerror(*tmp___9);
#line 498
    packet_disconnect("fork failed: %.100s", tmp___10);
  }
#line 499
  s->pid = pid;
#line 501
  packet_set_interactive((unsigned int )s->display != (unsigned int )((void *)0));
#line 521
  close(inout[0]);
#line 522
  close(err[0]);
#line 529
  buffer_clear(& loginmsg);
#line 535
  if (compat20) {
#line 536
    if (s->is_subsystem) {
#line 536
      tmp___11 = -1;
    } else {
#line 536
      tmp___11 = err[1];
    }
#line 536
    session_set_fds(s, inout[1], inout[1], tmp___11);
  } else {
#line 538
    server_loop(pid, inout[1], inout[1], err[1]);
  }
#line 542
  return;
}
}
#line 550 "session.c"
void do_exec_pty(Session *s , char const   *command ) 
{ int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;

  {
#line 556
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 557
    fatal("do_exec_pty: no session");
  }
#line 558
  ptyfd = s->ptyfd;
#line 559
  ttyfd = s->ttyfd;
#line 562
  pid = fork();
#line 562
  if (pid == 0) {
#line 563
    is_child = 1;
#line 566
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
#line 568
    close(ptyfd);
#line 571
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
#line 574
    tmp___1 = dup2(ttyfd, 0);
#line 574
    if (tmp___1 < 0) {
#line 575
      tmp = __errno_location();
#line 575
      tmp___0 = strerror(*tmp);
#line 575
      error("dup2 stdin: %s", tmp___0);
    }
#line 576
    tmp___4 = dup2(ttyfd, 1);
#line 576
    if (tmp___4 < 0) {
#line 577
      tmp___2 = __errno_location();
#line 577
      tmp___3 = strerror(*tmp___2);
#line 577
      error("dup2 stdout: %s", tmp___3);
    }
#line 578
    tmp___7 = dup2(ttyfd, 2);
#line 578
    if (tmp___7 < 0) {
#line 579
      tmp___5 = __errno_location();
#line 579
      tmp___6 = strerror(*tmp___5);
#line 579
      error("dup2 stderr: %s", tmp___6);
    }
#line 582
    close(ttyfd);
#line 586
    if (options.use_login) {
#line 586
      if (! ((unsigned int )command == (unsigned int )((void *)0))) {
#line 590
        do_login(s, command);
      }
    } else {
#line 590
      do_login(s, command);
    }
#line 599
    do_child(s, command);
  }
#line 609
  if (pid < 0) {
#line 610
    tmp___8 = __errno_location();
#line 610
    tmp___9 = strerror(*tmp___8);
#line 610
    packet_disconnect("fork failed: %.100s", tmp___9);
  }
#line 611
  s->pid = pid;
#line 614
  close(ttyfd);
#line 621
  fdout___0 = dup(ptyfd);
#line 622
  if (fdout___0 < 0) {
#line 623
    tmp___10 = __errno_location();
#line 623
    tmp___11 = strerror(*tmp___10);
#line 623
    packet_disconnect("dup #1 failed: %.100s", tmp___11);
  }
#line 626
  ptymaster = dup(ptyfd);
#line 627
  if (ptymaster < 0) {
#line 628
    tmp___12 = __errno_location();
#line 628
    tmp___13 = strerror(*tmp___12);
#line 628
    packet_disconnect("dup #2 failed: %.100s", tmp___13);
  }
#line 629
  s->ptymaster = ptymaster;
#line 632
  packet_set_interactive(1);
#line 633
  if (compat20) {
#line 634
    session_set_fds(s, ptyfd, fdout___0, -1);
  } else {
#line 636
    server_loop(pid, ptyfd, fdout___0, -1);
  }
#line 639
  return;
}
}
#line 673 "session.c"
void do_exec(Session *s , char const   *command ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 676
  if (options.adm_forced_command) {
#line 677
    original_command = command;
#line 678
    command = (char const   *)options.adm_forced_command;
#line 679
    if (0) {
#line 679
      __s1_len = strlen("internal-sftp");
#line 679
      __s2_len = strlen(command);
#line 679
      if (! ((unsigned int )((void const   *)("internal-sftp" + 1)) - (unsigned int )((void const   *)"internal-sftp") == 1U)) {
        goto _L___0;
      } else {
#line 679
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 679
          if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) == 1U)) {
#line 679
            tmp___8 = 1;
          } else {
#line 679
            if (__s2_len >= 4U) {
#line 679
              tmp___8 = 1;
            } else {
#line 679
              tmp___8 = 0;
            }
          }
        } else {
#line 679
          tmp___8 = 0;
        }
      }
#line 679
      if (tmp___8) {
#line 679
        tmp___4 = __builtin_strcmp("internal-sftp", command);
      } else {
#line 679
        tmp___7 = __builtin_strcmp("internal-sftp", command);
#line 679
        tmp___4 = tmp___7;
      }
    } else {
#line 679
      tmp___7 = __builtin_strcmp("internal-sftp", command);
#line 679
      tmp___4 = tmp___7;
    }
#line 679
    if (tmp___4 == 0) {
#line 680
      s->is_subsystem = 2;
    } else {
#line 681
      if (s->is_subsystem) {
#line 682
        s->is_subsystem = 1;
      }
    }
#line 683
    debug("Forced command (config) \'%.900s\'", command);
  } else {
#line 684
    if (forced_command) {
#line 685
      original_command = command;
#line 686
      command = (char const   *)forced_command;
#line 687
      if (0) {
#line 687
        __s1_len___0 = strlen("internal-sftp");
#line 687
        __s2_len___0 = strlen(command);
#line 687
        if (! ((unsigned int )((void const   *)("internal-sftp" + 1)) - (unsigned int )((void const   *)"internal-sftp") == 1U)) {
          goto _L___2;
        } else {
#line 687
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 687
            if (! ((unsigned int )((void const   *)(command + 1)) - (unsigned int )((void const   *)command) == 1U)) {
#line 687
              tmp___18 = 1;
            } else {
#line 687
              if (__s2_len___0 >= 4U) {
#line 687
                tmp___18 = 1;
              } else {
#line 687
                tmp___18 = 0;
              }
            }
          } else {
#line 687
            tmp___18 = 0;
          }
        }
#line 687
        if (tmp___18) {
#line 687
          tmp___14 = __builtin_strcmp("internal-sftp", command);
        } else {
#line 687
          tmp___17 = __builtin_strcmp("internal-sftp", command);
#line 687
          tmp___14 = tmp___17;
        }
      } else {
#line 687
        tmp___17 = __builtin_strcmp("internal-sftp", command);
#line 687
        tmp___14 = tmp___17;
      }
#line 687
      if (tmp___14 == 0) {
#line 688
        s->is_subsystem = 2;
      } else {
#line 689
        if (s->is_subsystem) {
#line 690
          s->is_subsystem = 1;
        }
      }
#line 691
      debug("Forced command (key option) \'%.900s\'", command);
    }
  }
#line 705
  if (s->ttyfd != -1) {
#line 706
    do_exec_pty(s, command);
  } else {
#line 708
    do_exec_no_pty(s, command);
  }
#line 710
  original_command = (char const   *)((void *)0);
#line 717
  buffer_clear(& loginmsg);
#line 718
  return;
}
}
#line 721 "session.c"
void do_login(Session *s , char const   *command ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct passwd *pw___0 ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 726
  pw___0 = s->pw;
#line 727
  tmp = getpid();
#line 727
  pid = tmp;
#line 733
  memset((void *)(& from), 0, sizeof(from));
#line 734
  fromlen = sizeof(from);
#line 735
  tmp___4 = packet_connection_is_on_socket();
#line 735
  if (tmp___4) {
#line 736
    tmp___2 = packet_get_connection_in();
#line 736
    tmp___3 = getpeername(tmp___2, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 736
    if (tmp___3 < 0) {
#line 738
      tmp___0 = __errno_location();
#line 738
      tmp___1 = strerror(*tmp___0);
#line 738
      debug("getpeername: %.100s", tmp___1);
#line 739
      cleanup_exit(255);
    }
  }
#line 744
  if (! use_privsep) {
#line 745
    tmp___5 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 745
    record_login(pid, (char const   *)(s->tty), (char const   *)pw___0->pw_name, pw___0->pw_uid,
                 tmp___5, (struct sockaddr *)(& from), fromlen);
  }
#line 763
  tmp___6 = check_quietlogin(s, command);
#line 763
  if (tmp___6) {
#line 764
    return;
  }
#line 766
  display_loginmsg();
#line 768
  do_motd();
#line 769
  return;
}
}
#line 774 "session.c"
void do_motd(void) 
{ FILE *f ;
  char buf___1[256] ;
  char *tmp ;

  {
#line 780
  if (options.print_motd) {
#line 785
    f = fopen((char const   * __restrict  )"/etc/motd", (char const   * __restrict  )"r");
#line 787
    if (f) {
#line 788
      while (1) {
#line 788
        tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 788
        if (! tmp) {
#line 788
          break;
        }
#line 789
        fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stdout);
      }
#line 790
      fclose(f);
    }
  }
#line 793
  return;
}
}
#line 799 "session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ char buf___1[256] ;
  struct passwd *pw___0 ;
  struct stat st ;
  int tmp ;

  {
#line 803
  pw___0 = s->pw;
#line 807
  if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 808
    return (1);
  }
#line 809
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.hushlogin",
           pw___0->pw_dir);
#line 814
  tmp = stat((char const   * __restrict  )(buf___1), (struct stat * __restrict  )(& st));
#line 814
  if (tmp >= 0) {
#line 815
    return (1);
  }
#line 817
  return (0);
}
}
#line 824 "session.c"
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ char **env ;
  u_int envsize ;
  u_int i ;
  u_int namelen ;
  void *tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;

  {
#line 836
  if ((unsigned int )*envp == (unsigned int )((void *)0)) {
#line 836
    if (*envsizep == 0U) {
#line 837
      tmp = xmalloc(sizeof(char *));
#line 837
      *envp = (char **)tmp;
#line 838
      *(*(envp + 0)) = (char *)((void *)0);
#line 839
      *envsizep = 1U;
    }
  }
#line 847
  env = *envp;
#line 848
  namelen = strlen(name);
#line 849
  i = 0U;
#line 849
  while (*(env + i)) {
#line 850
    if (0) {
#line 850
      if (0) {
#line 850
        __s1_len___0 = strlen((char const   *)*(env + i));
#line 850
        __s2_len___0 = strlen(name);
#line 850
        if (! ((unsigned int )((void const   *)(*(env + i) + 1)) - (unsigned int )((void const   *)*(env + i)) == 1U)) {
          goto _L___2;
        } else {
#line 850
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 850
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
#line 850
              tmp___23 = 1;
            } else {
#line 850
              if (__s2_len___0 >= 4U) {
#line 850
                tmp___23 = 1;
              } else {
#line 850
                tmp___23 = 0;
              }
            }
          } else {
#line 850
            tmp___23 = 0;
          }
        }
#line 850
        if (tmp___23) {
#line 850
          tmp___19 = __builtin_strcmp((char const   *)*(env + i), name);
        } else {
#line 850
          tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 850
          tmp___19 = tmp___22;
        }
      } else {
#line 850
        tmp___22 = __builtin_strcmp((char const   *)*(env + i), name);
#line 850
        tmp___19 = tmp___22;
      }
#line 850
      tmp___13 = tmp___19;
    } else {
#line 850
      tmp___13 = strncmp((char const   *)*(env + i), name, namelen);
    }
#line 850
    if (tmp___13 == 0) {
#line 850
      if ((int )*(*(env + i) + namelen) == 61) {
#line 851
        break;
      }
    }
#line 849
    i ++;
  }
#line 852
  if (*(env + i)) {
#line 854
    xfree((void *)*(env + i));
  } else {
#line 857
    envsize = *envsizep;
#line 858
    if (i >= envsize - 1U) {
#line 859
      if (envsize >= 1000U) {
#line 860
        fatal("child_set_env: too many env vars");
      }
#line 861
      envsize += 50U;
#line 862
      tmp___26 = xrealloc((void *)env, envsize, sizeof(char *));
#line 862
      *envp = (char **)tmp___26;
#line 862
      env = *envp;
#line 863
      *envsizep = envsize;
    }
#line 866
    *(env + (i + 1U)) = (char *)((void *)0);
  }
#line 870
  tmp___27 = strlen(name);
#line 870
  tmp___28 = strlen(value);
#line 870
  tmp___29 = xmalloc(((tmp___27 + 1U) + tmp___28) + 1U);
#line 870
  *(env + i) = (char *)tmp___29;
#line 871
  tmp___30 = strlen(name);
#line 871
  tmp___31 = strlen(value);
#line 871
  snprintf((char * __restrict  )*(env + i), ((tmp___30 + 1U) + tmp___31) + 1U, (char const   * __restrict  )"%s=%s",
           name, value);
#line 872
  return;
}
}
#line 880 "session.c"
static void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  u_int lineno ;
  unsigned int tmp___31 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
#line 887
  lineno = (u_int )0;
#line 889
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 890
  if (! f) {
#line 891
    return;
  }
#line 893
  while (1) {
#line 893
    tmp___34 = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 893
    if (! tmp___34) {
#line 893
      break;
    }
#line 894
    lineno ++;
#line 894
    if (lineno > 1000U) {
#line 895
      fatal("Too many lines in environment file %s", filename);
    }
#line 896
    cp = buf___1;
#line 896
    while (1) {
#line 896
      if (! ((int )*cp == 32)) {
#line 896
        if (! ((int )*cp == 9)) {
#line 896
          break;
        }
      }
#line 896
      cp ++;
    }
#line 898
    if (! *cp) {
#line 899
      continue;
    } else {
#line 898
      if ((int )*cp == 35) {
#line 899
        continue;
      } else {
#line 898
        if ((int )*cp == 10) {
#line 899
          continue;
        }
      }
    }
#line 901
    tmp___31 = __builtin_strcspn((char const   *)cp, "\n");
#line 901
    *(cp + tmp___31) = (char )'\000';
#line 903
    tmp___33 = __builtin_strchr(cp, '=');
#line 903
    value = tmp___33;
#line 904
    if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 905
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad line %u in %.100s\n",
              lineno, filename);
#line 907
      continue;
    }
#line 913
    *value = (char )'\000';
#line 914
    value ++;
#line 915
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
  }
#line 917
  fclose(f);
#line 918
  return;
}
}
#line 975 "session.c"
void copy_environment(char **source , char ***env , u_int *envsize ) 
{ char *var_name ;
  char *var_val ;
  int i ;
  char *tmp ;

  {
#line 981
  if ((unsigned int )source == (unsigned int )((void *)0)) {
#line 982
    return;
  }
#line 984
  i = 0;
#line 984
  while ((unsigned int )*(source + i) != (unsigned int )((void *)0)) {
#line 985
    var_name = xstrdup((char const   *)*(source + i));
#line 986
    var_val = strstr((char const   *)var_name, "=");
#line 986
    if ((unsigned int )var_val == (unsigned int )((void *)0)) {
#line 987
      xfree((void *)var_name);
      goto __Cont;
    }
#line 990
    tmp = var_val;
#line 990
    var_val ++;
#line 990
    *tmp = (char )'\000';
#line 992
    debug3("Copy environment: %s=%s", var_name, var_val);
#line 993
    child_set_env(env, envsize, (char const   *)var_name, (char const   *)var_val);
#line 995
    xfree((void *)var_name);
    __Cont: /* CIL Label */ 
#line 984
    i ++;
  }
#line 997
  return;
}
}
#line 999 "session.c"
static char **do_setup_env(Session *s , char const   *shell ) 
{ char buf___1[256] ;
  u_int i ;
  u_int envsize ;
  char **env ;
  char *laddr ;
  struct passwd *pw___0 ;
  char *path ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct envstring *ce ;
  char *str ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *cp ;
  char const   *tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 1005
  pw___0 = s->pw;
#line 1007
  path = (char *)((void *)0);
#line 1011
  envsize = 100U;
#line 1012
  tmp = xcalloc(envsize, sizeof(char *));
#line 1012
  env = (char **)tmp;
#line 1013
  *(env + 0) = (char *)((void *)0);
#line 1036
  if (! options.use_login) {
#line 1038
    i = 0U;
#line 1038
    while (i < s->num_env) {
#line 1039
      child_set_env(& env, & envsize, (char const   *)(s->env + i)->name, (char const   *)(s->env + i)->val);
#line 1038
      i ++;
    }
#line 1042
    child_set_env(& env, & envsize, "USER", (char const   *)pw___0->pw_name);
#line 1043
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw___0->pw_name);
#line 1047
    child_set_env(& env, & envsize, "HOME", (char const   *)pw___0->pw_dir);
#line 1065
    if ((unsigned int )path == (unsigned int )((void *)0)) {
      goto _L;
    } else {
#line 1065
      if ((int )*path == 0) {
        _L: /* CIL Label */ 
#line 1066
        if ((s->pw)->pw_uid == 0U) {
#line 1066
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        } else {
#line 1066
          tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
        }
#line 1066
        child_set_env(& env, & envsize, "PATH", tmp___0);
      }
    }
#line 1073
    snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/%.50s",
             "/var/mail", pw___0->pw_name);
#line 1075
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
#line 1078
    child_set_env(& env, & envsize, "SHELL", shell);
  }
#line 1080
  tmp___2 = getenv("TZ");
#line 1080
  if (tmp___2) {
#line 1081
    tmp___1 = getenv("TZ");
#line 1081
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___1);
  }
#line 1084
  if (! options.use_login) {
#line 1085
    while (custom_environment) {
#line 1086
      ce = custom_environment;
#line 1087
      str = ce->s;
#line 1089
      i = 0U;
#line 1089
      while (1) {
#line 1089
        if ((int )*(str + i) != 61) {
#line 1089
          if (! *(str + i)) {
#line 1089
            break;
          }
        } else {
#line 1089
          break;
        }
#line 1089
        i ++;
      }
#line 1091
      if ((int )*(str + i) == 61) {
#line 1092
        *(str + i) = (char)0;
#line 1093
        child_set_env(& env, & envsize, (char const   *)str, (char const   *)((str + i) + 1));
      }
#line 1095
      custom_environment = ce->next;
#line 1096
      xfree((void *)ce->s);
#line 1097
      xfree((void *)ce);
    }
  }
#line 1102
  tmp___3 = get_local_port();
#line 1102
  tmp___4 = get_remote_port();
#line 1102
  tmp___5 = get_remote_ipaddr();
#line 1102
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %d",
           tmp___5, tmp___4, tmp___3);
#line 1104
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
#line 1106
  tmp___6 = packet_get_connection_in();
#line 1106
  laddr = get_local_ipaddr(tmp___6);
#line 1107
  tmp___7 = get_local_port();
#line 1107
  tmp___8 = get_remote_port();
#line 1107
  tmp___9 = get_remote_ipaddr();
#line 1107
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.50s %d %.50s %d",
           tmp___9, tmp___8, laddr, tmp___7);
#line 1109
  xfree((void *)laddr);
#line 1110
  child_set_env(& env, & envsize, "SSH_CONNECTION", (char const   *)(buf___1));
#line 1112
  if (s->ttyfd != -1) {
#line 1113
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
  }
#line 1114
  if (s->term) {
#line 1115
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
  }
#line 1116
  if (s->display) {
#line 1117
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
  }
#line 1118
  if (original_command) {
#line 1119
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", original_command);
  }
#line 1135
  cp = getenv("KRB5CCNAME");
#line 1135
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1136
    child_set_env(& env, & envsize, "KRB5CCNAME", (char const   *)cp);
  }
#line 1171
  if ((unsigned int )auth_sock_name != (unsigned int )((void *)0)) {
#line 1172
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)auth_sock_name);
  }
#line 1176
  if (options.permit_user_env) {
#line 1176
    if (! options.use_login) {
#line 1178
      if (0) {
#line 1178
        __s1_len___0 = strlen((char const   *)pw___0->pw_dir);
#line 1178
        __s2_len___0 = strlen("/");
#line 1178
        if (! ((unsigned int )((void const   *)(pw___0->pw_dir + 1)) - (unsigned int )((void const   *)pw___0->pw_dir) == 1U)) {
          goto _L___3;
        } else {
#line 1178
          if (__s1_len___0 >= 4U) {
            _L___3: /* CIL Label */ 
#line 1178
            if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 1178
              tmp___30 = 1;
            } else {
#line 1178
              if (__s2_len___0 >= 4U) {
#line 1178
                tmp___30 = 1;
              } else {
#line 1178
                tmp___30 = 0;
              }
            }
          } else {
#line 1178
            tmp___30 = 0;
          }
        }
#line 1178
        if (tmp___30) {
#line 1178
          tmp___26 = __builtin_strcmp((char const   *)pw___0->pw_dir, "/");
        } else {
#line 1178
          tmp___29 = __builtin_strcmp((char const   *)pw___0->pw_dir, "/");
#line 1178
          tmp___26 = tmp___29;
        }
      } else {
#line 1178
        tmp___29 = __builtin_strcmp((char const   *)pw___0->pw_dir, "/");
#line 1178
        tmp___26 = tmp___29;
      }
#line 1178
      if (tmp___26) {
#line 1178
        tmp___20 = (char const   *)pw___0->pw_dir;
      } else {
#line 1178
        tmp___20 = "";
      }
#line 1178
      snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%.200s/.ssh/environment",
               tmp___20);
#line 1179
      read_environment_file(& env, & envsize, (char const   *)(buf___1));
    }
  }
#line 1181
  if (debug_flag) {
#line 1183
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Environment:\n");
#line 1184
    i = 0U;
#line 1184
    while (*(env + i)) {
#line 1185
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %.200s\n",
              *(env + i));
#line 1184
      i ++;
    }
  }
#line 1187
  return (env);
}
}
#line 1194 "session.c"
static void do_rc_files(Session *s , char const   *shell ) 
{ FILE *f ;
  char cmd[1024] ;
  int do_xauth ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1197
  f = (FILE *)((void *)0);
#line 1202
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 1202
    if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1202
      if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1202
        tmp = 1;
      } else {
#line 1202
        tmp = 0;
      }
    } else {
#line 1202
      tmp = 0;
    }
  } else {
#line 1202
    tmp = 0;
  }
#line 1202
  do_xauth = tmp;
#line 1206
  if (! s->is_subsystem) {
#line 1206
    if ((unsigned int )options.adm_forced_command == (unsigned int )((void *)0)) {
#line 1206
      if (! no_user_rc) {
#line 1206
        tmp___1 = stat((char const   * __restrict  )".ssh/rc", (struct stat * __restrict  )(& st));
#line 1206
        if (tmp___1 >= 0) {
#line 1208
          snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -c \'%s %s\'",
                   shell, "/bin/sh", ".ssh/rc");
#line 1210
          if (debug_flag) {
#line 1211
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s\n",
                    cmd);
          }
#line 1212
          f = popen((char const   *)(cmd), "w");
#line 1213
          if (f) {
#line 1214
            if (do_xauth) {
#line 1215
              fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                      s->auth_proto, s->auth_data);
            }
#line 1217
            pclose(f);
          } else {
#line 1219
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                    ".ssh/rc");
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1221
    tmp___0 = stat((char const   * __restrict  )"/usr/local/etc/sshrc", (struct stat * __restrict  )(& st));
#line 1221
    if (tmp___0 >= 0) {
#line 1222
      if (debug_flag) {
#line 1223
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %s %s\n",
                "/bin/sh", "/usr/local/etc/sshrc");
      }
#line 1225
      f = popen("/bin/sh /usr/local/etc/sshrc", "w");
#line 1226
      if (f) {
#line 1227
        if (do_xauth) {
#line 1228
          fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %s\n",
                  s->auth_proto, s->auth_data);
        }
#line 1230
        pclose(f);
      } else {
#line 1232
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                "/usr/local/etc/sshrc");
      }
    } else {
#line 1234
      if (do_xauth) {
#line 1234
        if ((unsigned int )options.xauth_location != (unsigned int )((void *)0)) {
#line 1236
          if (debug_flag) {
#line 1237
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Running %.500s remove %.100s\n",
                    options.xauth_location, s->auth_display);
#line 1240
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%.500s add %.100s %.100s %.100s\n",
                    options.xauth_location, s->auth_display, s->auth_proto, s->auth_data);
          }
#line 1245
          snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"%s -q -",
                   options.xauth_location);
#line 1247
          f = popen((char const   *)(cmd), "w");
#line 1248
          if (f) {
#line 1249
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"remove %s\n",
                    s->auth_display);
#line 1251
            fprintf((FILE * __restrict  )f, (char const   * __restrict  )"add %s %s %s\n",
                    s->auth_display, s->auth_proto, s->auth_data);
#line 1254
            pclose(f);
          } else {
#line 1256
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not run %s\n",
                    cmd);
          }
        }
      }
    }
  }
#line 1260
  return;
}
}
#line 1262 "session.c"
static void do_nologin(struct passwd *pw___0 ) 
{ FILE *f ;
  char buf___1[1024] ;
  char *tmp ;

  {
#line 1265
  f = (FILE *)((void *)0);
#line 1273
  if (pw___0->pw_uid) {
#line 1274
    f = fopen((char const   * __restrict  )"/etc/nologin", (char const   * __restrict  )"r");
  }
#line 1276
  if (f) {
#line 1278
    logit("User %.100s not allowed because %s exists", pw___0->pw_name, "/etc/nologin");
#line 1280
    while (1) {
#line 1280
      tmp = fgets((char * __restrict  )(buf___1), (int )sizeof(buf___1), (FILE * __restrict  )f);
#line 1280
      if (! tmp) {
#line 1280
        break;
      }
#line 1281
      fputs((char const   * __restrict  )(buf___1), (FILE * __restrict  )stderr);
    }
#line 1282
    fclose(f);
#line 1283
    fflush((FILE *)((void *)0));
#line 1284
    exit(254);
  }
#line 1286
  return;
}
}
#line 1292 "session.c"
static void safely_chroot(char const   *path , uid_t uid ) 
{ char const   *cp ;
  char component[4096] ;
  struct stat st ;
  size_t tmp ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
#line 1299
  if ((int const   )*path != 47) {
#line 1300
    fatal("chroot path does not begin at root");
  }
#line 1301
  tmp = strlen(path);
#line 1301
  if (tmp >= sizeof(component)) {
#line 1302
    fatal("chroot path too long");
  }
#line 1308
  cp = path;
#line 1308
  while ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1309
    tmp___1 = __builtin_strchr((char *)cp, '/');
#line 1309
    cp = (char const   *)tmp___1;
#line 1309
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1310
      strlcpy(component, path, sizeof(component));
    } else {
#line 1312
      cp ++;
#line 1313
      memcpy((void * __restrict  )(component), (void const   * __restrict  )path,
             (unsigned int )(cp - path));
#line 1314
      component[cp - path] = (char )'\000';
    }
#line 1317
    debug3("%s: checking \'%s\'", "safely_chroot", component);
#line 1319
    tmp___4 = stat((char const   * __restrict  )(component), (struct stat * __restrict  )(& st));
#line 1319
    if (tmp___4 != 0) {
#line 1320
      tmp___2 = __errno_location();
#line 1320
      tmp___3 = strerror(*tmp___2);
#line 1320
      fatal("%s: stat(\"%s\"): %s", "safely_chroot", component, tmp___3);
    }
#line 1322
    if (st.st_uid != 0U) {
      goto _L;
    } else {
#line 1322
      if ((st.st_mode & 18U) != 0U) {
        _L: /* CIL Label */ 
#line 1323
        if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1323
          tmp___5 = "";
        } else {
#line 1323
          tmp___5 = "component ";
        }
#line 1323
        fatal("bad ownership or modes for chroot directory %s\"%s\"", tmp___5, component);
      }
    }
#line 1326
    if (! ((st.st_mode & 61440U) == 16384U)) {
#line 1327
      if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1327
        tmp___6 = "";
      } else {
#line 1327
        tmp___6 = "component ";
      }
#line 1327
      fatal("chroot path %s\"%s\" is not a directory", tmp___6, component);
    }
  }
#line 1332
  tmp___9 = chdir(path);
#line 1332
  if (tmp___9 == -1) {
#line 1333
    tmp___7 = __errno_location();
#line 1333
    tmp___8 = strerror(*tmp___7);
#line 1333
    fatal("Unable to chdir to chroot path \"%s\": %s", path, tmp___8);
  }
#line 1335
  tmp___12 = chroot(path);
#line 1335
  if (tmp___12 == -1) {
#line 1336
    tmp___10 = __errno_location();
#line 1336
    tmp___11 = strerror(*tmp___10);
#line 1336
    fatal("chroot(\"%s\"): %s", path, tmp___11);
  }
#line 1337
  tmp___15 = chdir("/");
#line 1337
  if (tmp___15 == -1) {
#line 1338
    tmp___13 = __errno_location();
#line 1338
    tmp___14 = strerror(*tmp___13);
#line 1338
    fatal("%s: chdir(/) after chroot: %s", "safely_chroot", tmp___14);
  }
#line 1340
  verbose("Changed root directory to \"%s\"", path);
#line 1341
  return;
}
}
#line 1344 "session.c"
void do_setusercontext(struct passwd *pw___0 ) 
{ char *chroot_path ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  __uid_t tmp___9 ;

  {
#line 1355
  tmp___6 = getuid();
#line 1355
  if (tmp___6 == 0U) {
    goto _L;
  } else {
#line 1355
    tmp___7 = geteuid();
#line 1355
    if (tmp___7 == 0U) {
      _L: /* CIL Label */ 
#line 1384
      tmp___2 = setlogin((char const   *)pw___0->pw_name);
#line 1384
      if (tmp___2 < 0) {
#line 1385
        tmp___0 = __errno_location();
#line 1385
        tmp___1 = strerror(*tmp___0);
#line 1385
        error("setlogin failed: %s", tmp___1);
      }
#line 1386
      tmp___3 = setgid(pw___0->pw_gid);
#line 1386
      if (tmp___3 < 0) {
#line 1387
        perror("setgid");
#line 1388
        exit(1);
      }
#line 1391
      tmp___4 = initgroups((char const   *)pw___0->pw_name, pw___0->pw_gid);
#line 1391
      if (tmp___4 < 0) {
#line 1392
        perror("initgroups");
#line 1393
        exit(1);
      }
#line 1395
      endgrent();
#line 1419
      if ((unsigned int )options.chroot_directory != (unsigned int )((void *)0)) {
#line 1419
        tmp___5 = strcasecmp((char const   *)options.chroot_directory, "none");
#line 1419
        if (tmp___5 != 0) {
#line 1421
          tmp = tilde_expand_filename((char const   *)options.chroot_directory, pw___0->pw_uid);
#line 1423
          chroot_path = percent_expand((char const   *)tmp, "h", pw___0->pw_dir, "u",
                                       pw___0->pw_name, (char *)((void *)0));
#line 1425
          safely_chroot((char const   *)chroot_path, pw___0->pw_uid);
#line 1426
          free((void *)tmp);
#line 1427
          free((void *)chroot_path);
        }
      }
#line 1437
      permanently_set_uid(pw___0);
    }
  }
#line 1444
  tmp___8 = getuid();
#line 1444
  if (tmp___8 != pw___0->pw_uid) {
#line 1445
    fatal("Failed to set uids to %u.", pw___0->pw_uid);
  } else {
#line 1444
    tmp___9 = geteuid();
#line 1444
    if (tmp___9 != pw___0->pw_uid) {
#line 1445
      fatal("Failed to set uids to %u.", pw___0->pw_uid);
    }
  }
#line 1450
  return;
}
}
#line 1452 "session.c"
static void do_pwchange(Session *s ) 
{ 

  {
#line 1455
  fflush((FILE *)((void *)0));
#line 1456
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Your password has expired.\n");
#line 1457
  if (s->ttyfd != -1) {
#line 1458
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"You must change your password now and login again!\n");
#line 1464
    execl("/usr/bin//passwd", "passwd", (char *)((void *)0));
#line 1466
    perror("passwd");
  } else {
#line 1468
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Password change required but no TTY available.\n");
  }
#line 1471
  exit(1);
}
}
#line 1474 "session.c"
static void launch_login(struct passwd *pw___0 , char const   *hostname ) 
{ 

  {
#line 1479
  execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw___0->pw_name,
        (char *)((void *)0));
#line 1491
  perror("login");
#line 1492
  exit(1);
}
}
#line 1495 "session.c"
static void child_close_fds(void) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1500
  tmp___2 = packet_get_connection_in();
#line 1500
  tmp___3 = packet_get_connection_out();
#line 1500
  if (tmp___2 == tmp___3) {
#line 1501
    tmp = packet_get_connection_in();
#line 1501
    close(tmp);
  } else {
#line 1503
    tmp___0 = packet_get_connection_in();
#line 1503
    close(tmp___0);
#line 1504
    tmp___1 = packet_get_connection_out();
#line 1504
    close(tmp___1);
  }
#line 1511
  channel_close_all();
#line 1517
  endpwent();
#line 1525
  i = 3;
#line 1525
  while (i < 64) {
#line 1526
    close(i);
#line 1525
    i ++;
  }
#line 1527
  return;
}
}
#line 1535 "session.c"
void do_child(Session *s , char const   *command ) 
{ char **env ;
  char *argv[10] ;
  char const   *shell ;
  char const   *shell0 ;
  char const   *hostname ;
  struct passwd *pw___0 ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int i ;
  char *p ;
  char *args ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char argv0___0[256] ;
  int *tmp___26 ;
  size_t tmp___27 ;

  {
#line 1541
  hostname = (char const   *)((void *)0);
#line 1542
  pw___0 = s->pw;
#line 1545
  destroy_sensitive_data();
#line 1548
  if ((s->authctxt)->force_pwchange) {
#line 1549
    do_setusercontext(pw___0);
#line 1550
    child_close_fds();
#line 1551
    do_pwchange(s);
#line 1552
    exit(1);
  }
#line 1556
  if (options.use_login) {
#line 1556
    if ((unsigned int )command != (unsigned int )((void *)0)) {
#line 1557
      options.use_login = 0;
    }
  }
#line 1567
  if (! options.use_login) {
#line 1574
    if (! options.use_pam) {
#line 1575
      do_nologin(pw___0);
    }
#line 1576
    do_setusercontext(pw___0);
#line 1582
    tmp = check_quietlogin(s, command);
#line 1582
    if (! tmp) {
#line 1583
      display_loginmsg();
    }
  }
#line 1599
  if ((int )*(pw___0->pw_shell + 0) == 0) {
#line 1599
    shell = "/bin/sh";
  } else {
#line 1599
    shell = (char const   *)pw___0->pw_shell;
  }
#line 1605
  env = do_setup_env(s, shell);
#line 1612
  if (options.use_login) {
#line 1613
    hostname = get_remote_name_or_ip(utmp_len, options.use_dns);
  }
#line 1622
  child_close_fds();
#line 1628
  environ = env;
#line 1657
  tmp___2 = chdir((char const   *)pw___0->pw_dir);
#line 1657
  if (tmp___2 < 0) {
#line 1658
    tmp___0 = __errno_location();
#line 1658
    tmp___1 = strerror(*tmp___0);
#line 1658
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not chdir to home directory %s: %s\n",
            pw___0->pw_dir, tmp___1);
  }
#line 1666
  closefrom(3);
#line 1668
  if (! options.use_login) {
#line 1669
    do_rc_files(s, shell);
  }
#line 1672
  mysignal(13, (void (*)(int  ))0);
#line 1674
  if (s->is_subsystem == 2) {
#line 1679
    setproctitle("%s@internal-sftp-server", (s->pw)->pw_name);
#line 1680
    if (command) {
#line 1680
      tmp___21 = command;
    } else {
#line 1680
      tmp___21 = "sftp-server";
    }
#line 1680
    tmp___22 = __strdup(tmp___21);
#line 1680
    args = tmp___22;
#line 1681
    i = 0;
#line 1681
    p = strtok((char * __restrict  )args, (char const   * __restrict  )" ");
#line 1681
    while (p) {
#line 1682
      if (i < 9) {
#line 1683
        tmp___23 = i;
#line 1683
        i ++;
#line 1683
        argv[tmp___23] = p;
      }
#line 1681
      p = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" ");
    }
#line 1684
    argv[i] = (char *)((void *)0);
#line 1685
    BSDoptreset = 1;
#line 1685
    BSDoptind = BSDoptreset;
#line 1686
    __progname = argv[0];
#line 1687
    tmp___24 = sftp_server_main(i, argv, s->pw);
#line 1687
    exit(tmp___24);
  }
#line 1690
  if (options.use_login) {
#line 1691
    launch_login(pw___0, hostname);
  }
#line 1696
  tmp___25 = strrchr(shell, '/');
#line 1696
  shell0 = (char const   *)tmp___25;
#line 1696
  if ((unsigned int )shell0 != (unsigned int )((void *)0)) {
#line 1697
    shell0 ++;
  } else {
#line 1699
    shell0 = shell;
  }
#line 1706
  if (! command) {
#line 1710
    argv0___0[0] = (char )'-';
#line 1712
    tmp___27 = strlcpy(argv0___0 + 1, shell0, sizeof(argv0___0) - 1U);
#line 1712
    if (tmp___27 >= sizeof(argv0___0) - 1U) {
#line 1714
      tmp___26 = __errno_location();
#line 1714
      *tmp___26 = 22;
#line 1715
      perror(shell);
#line 1716
      exit(1);
    }
#line 1720
    argv[0] = argv0___0;
#line 1721
    argv[1] = (char *)((void *)0);
#line 1722
    execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1725
    perror(shell);
#line 1726
    exit(1);
  }
#line 1732
  argv[0] = (char *)shell0;
#line 1733
  argv[1] = (char *)"-c";
#line 1734
  argv[2] = (char *)command;
#line 1735
  argv[3] = (char *)((void *)0);
#line 1736
  execve(shell, (char * const  *)(argv), (char * const  *)env);
#line 1737
  perror(shell);
#line 1738
  exit(1);
}
}
#line 1745 "session.c"
static int did_init___0  =    0;
#line 1741 "session.c"
Session *session_new(void) 
{ int i ;
  Session *s ;

  {
#line 1746
  if (! did_init___0) {
#line 1747
    debug("session_new: init");
#line 1748
    i = 0;
#line 1748
    while (i < 20) {
#line 1749
      sessions[i].used = 0;
#line 1748
      i ++;
    }
#line 1751
    did_init___0 = 1;
  }
#line 1753
  i = 0;
#line 1753
  while (i < 20) {
#line 1754
    s = & sessions[i];
#line 1755
    if (! s->used) {
#line 1756
      memset((void *)s, 0, sizeof(*s));
#line 1757
      s->chanid = -1;
#line 1758
      s->ptyfd = -1;
#line 1759
      s->ttyfd = -1;
#line 1760
      s->used = 1;
#line 1761
      s->self = i;
#line 1762
      s->x11_chanids = (int *)((void *)0);
#line 1763
      debug("session_new: session %d", i);
#line 1764
      return (s);
    }
#line 1753
    i ++;
  }
#line 1767
  return ((Session *)((void *)0));
}
}
#line 1770 "session.c"
static void session_dump(void) 
{ int i ;
  Session *s ;

  {
#line 1774
  i = 0;
#line 1774
  while (i < 20) {
#line 1775
    s = & sessions[i];
#line 1776
    debug("dump: used %d session %d %p channel %d pid %ld", s->used, s->self, s, s->chanid,
          (long )s->pid);
#line 1774
    i ++;
  }
#line 1783
  return;
}
}
#line 1785 "session.c"
int session_open(Authctxt *authctxt___0 , int chanid ) 
{ Session *s ;
  Session *tmp ;

  {
#line 1788
  tmp = session_new();
#line 1788
  s = tmp;
#line 1789
  debug("session_open: channel %d", chanid);
#line 1790
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 1791
    error("no more sessions");
#line 1792
    return (0);
  }
#line 1794
  s->authctxt = authctxt___0;
#line 1795
  s->pw = authctxt___0->pw;
#line 1796
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 1797
    fatal("no user for session %d", s->self);
  } else {
#line 1796
    if (! authctxt___0->valid) {
#line 1797
      fatal("no user for session %d", s->self);
    }
  }
#line 1798
  debug("session_open: session %d: link with channel %d", s->self, chanid);
#line 1799
  s->chanid = chanid;
#line 1800
  return (1);
}
}
#line 1803 "session.c"
Session *session_by_tty(char *tty ) 
{ int i ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1807
  i = 0;
#line 1807
  while (i < 20) {
#line 1808
    s = & sessions[i];
#line 1809
    if (s->used) {
#line 1809
      if (s->ttyfd != -1) {
#line 1809
        if (0) {
#line 1809
          __s1_len = strlen((char const   *)(s->tty));
#line 1809
          __s2_len = strlen((char const   *)tty);
#line 1809
          if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
            goto _L___0;
          } else {
#line 1809
            if (__s1_len >= 4U) {
              _L___0: /* CIL Label */ 
#line 1809
              if (! ((unsigned int )((void const   *)(tty + 1)) - (unsigned int )((void const   *)tty) == 1U)) {
#line 1809
                tmp___8 = 1;
              } else {
#line 1809
                if (__s2_len >= 4U) {
#line 1809
                  tmp___8 = 1;
                } else {
#line 1809
                  tmp___8 = 0;
                }
              }
            } else {
#line 1809
              tmp___8 = 0;
            }
          }
#line 1809
          if (tmp___8) {
#line 1809
            tmp___4 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
          } else {
#line 1809
            tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1809
            tmp___4 = tmp___7;
          }
        } else {
#line 1809
          tmp___7 = __builtin_strcmp((char const   *)(s->tty), (char const   *)tty);
#line 1809
          tmp___4 = tmp___7;
        }
#line 1809
        if (tmp___4 == 0) {
#line 1810
          debug("session_by_tty: session %d tty %s", i, tty);
#line 1811
          return (s);
        }
      }
    }
#line 1807
    i ++;
  }
#line 1814
  debug("session_by_tty: unknown tty %.100s", tty);
#line 1815
  session_dump();
#line 1816
  return ((Session *)((void *)0));
}
}
#line 1819 "session.c"
static Session *session_by_channel(int id ) 
{ int i ;
  Session *s ;

  {
#line 1823
  i = 0;
#line 1823
  while (i < 20) {
#line 1824
    s = & sessions[i];
#line 1825
    if (s->used) {
#line 1825
      if (s->chanid == id) {
#line 1826
        debug("session_by_channel: session %d channel %d", i, id);
#line 1827
        return (s);
      }
    }
#line 1823
    i ++;
  }
#line 1830
  debug("session_by_channel: unknown channel %d", id);
#line 1831
  session_dump();
#line 1832
  return ((Session *)((void *)0));
}
}
#line 1835 "session.c"
static Session *session_by_x11_channel(int id ) 
{ int i ;
  int j ;
  Session *s ;

  {
#line 1840
  i = 0;
#line 1840
  while (i < 20) {
#line 1841
    s = & sessions[i];
#line 1843
    if ((unsigned int )s->x11_chanids == (unsigned int )((void *)0)) {
      goto __Cont;
    } else {
#line 1843
      if (! s->used) {
        goto __Cont;
      }
    }
#line 1845
    j = 0;
#line 1845
    while (*(s->x11_chanids + j) != -1) {
#line 1846
      if (*(s->x11_chanids + j) == id) {
#line 1847
        debug("session_by_x11_channel: session %d channel %d", s->self, id);
#line 1849
        return (s);
      }
#line 1845
      j ++;
    }
    __Cont: /* CIL Label */ 
#line 1840
    i ++;
  }
#line 1853
  debug("session_by_x11_channel: unknown channel %d", id);
#line 1854
  session_dump();
#line 1855
  return ((Session *)((void *)0));
}
}
#line 1858 "session.c"
static Session *session_by_pid(pid_t pid ) 
{ int i ;
  Session *s ;

  {
#line 1862
  debug("session_by_pid: pid %ld", (long )pid);
#line 1863
  i = 0;
#line 1863
  while (i < 20) {
#line 1864
    s = & sessions[i];
#line 1865
    if (s->used) {
#line 1865
      if (s->pid == pid) {
#line 1866
        return (s);
      }
    }
#line 1863
    i ++;
  }
#line 1868
  error("session_by_pid: unknown pid %ld", (long )pid);
#line 1869
  session_dump();
#line 1870
  return ((Session *)((void *)0));
}
}
#line 1873 "session.c"
static int session_window_change_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 1876
  s->col = packet_get_int();
#line 1877
  s->row = packet_get_int();
#line 1878
  s->xpixel = packet_get_int();
#line 1879
  s->ypixel = packet_get_int();
#line 1880
  while (1) {
#line 1880
    tmp = packet_remaining();
#line 1880
    _len = tmp;
#line 1880
    if (_len > 0) {
#line 1880
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1880);
#line 1880
      packet_disconnect("Packet integrity error.");
    }
#line 1880
    break;
  }
#line 1881
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1882
  return (1);
}
}
#line 1885 "session.c"
static int session_pty_req(Session *s ) 
{ u_int len ;
  int n_bytes ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___12 ;
  int _len ;
  int tmp___13 ;

  {
#line 1891
  if (no_pty_flag) {
#line 1892
    debug("Allocating a pty not permitted for this authentication.");
#line 1893
    return (0);
  }
#line 1895
  if (s->ttyfd != -1) {
#line 1896
    packet_disconnect("Protocol error: you already have a pty.");
#line 1897
    return (0);
  }
#line 1900
  tmp = packet_get_string(& len);
#line 1900
  s->term = (char *)tmp;
#line 1902
  if (compat20) {
#line 1903
    s->col = packet_get_int();
#line 1904
    s->row = packet_get_int();
  } else {
#line 1906
    s->row = packet_get_int();
#line 1907
    s->col = packet_get_int();
  }
#line 1909
  s->xpixel = packet_get_int();
#line 1910
  s->ypixel = packet_get_int();
#line 1912
  if (0) {
#line 1912
    __s1_len = strlen((char const   *)s->term);
#line 1912
    __s2_len = strlen("");
#line 1912
    if (! ((unsigned int )((void const   *)(s->term + 1)) - (unsigned int )((void const   *)s->term) == 1U)) {
      goto _L___0;
    } else {
#line 1912
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1912
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 1912
          tmp___9 = 1;
        } else {
#line 1912
          if (__s2_len >= 4U) {
#line 1912
            tmp___9 = 1;
          } else {
#line 1912
            tmp___9 = 0;
          }
        }
      } else {
#line 1912
        tmp___9 = 0;
      }
    }
#line 1912
    if (tmp___9) {
#line 1912
      tmp___5 = __builtin_strcmp((char const   *)s->term, "");
    } else {
#line 1912
      tmp___8 = __builtin_strcmp((char const   *)s->term, "");
#line 1912
      tmp___5 = tmp___8;
    }
  } else {
#line 1912
    tmp___8 = __builtin_strcmp((char const   *)s->term, "");
#line 1912
    tmp___5 = tmp___8;
  }
#line 1912
  if (tmp___5 == 0) {
#line 1913
    xfree((void *)s->term);
#line 1914
    s->term = (char *)((void *)0);
  }
#line 1918
  debug("Allocating pty.");
#line 1919
  if (use_privsep) {
#line 1919
    tmp___12 = mm_pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, sizeof(s->tty));
  } else {
#line 1919
    tmp___12 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, sizeof(s->tty));
  }
#line 1919
  if (! tmp___12) {
#line 1920
    if (s->term) {
#line 1921
      xfree((void *)s->term);
    }
#line 1922
    s->term = (char *)((void *)0);
#line 1923
    s->ptyfd = -1;
#line 1924
    s->ttyfd = -1;
#line 1925
    error("session_pty_req: session %d alloc failed", s->self);
#line 1926
    return (0);
  }
#line 1928
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
#line 1931
  if (! compat20) {
#line 1932
    n_bytes = packet_remaining();
  }
#line 1933
  tty_parse_modes(s->ttyfd, & n_bytes);
#line 1935
  if (! use_privsep) {
#line 1936
    pty_setowner(s->pw, (char const   *)(s->tty));
  }
#line 1939
  pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
#line 1941
  while (1) {
#line 1941
    tmp___13 = packet_remaining();
#line 1941
    _len = tmp___13;
#line 1941
    if (_len > 0) {
#line 1941
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1941);
#line 1941
      packet_disconnect("Packet integrity error.");
    }
#line 1941
    break;
  }
#line 1942
  session_proctitle(s);
#line 1943
  return (1);
}
}
#line 1946 "session.c"
static int session_subsystem_req(Session *s ) 
{ struct stat st ;
  u_int len ;
  int success ;
  char *prog ;
  char *cmd ;
  char *subsys ;
  void *tmp ;
  u_int i ;
  int _len ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 1951
  success = 0;
#line 1952
  tmp = packet_get_string(& len);
#line 1952
  subsys = (char *)tmp;
#line 1955
  while (1) {
#line 1955
    tmp___0 = packet_remaining();
#line 1955
    _len = tmp___0;
#line 1955
    if (_len > 0) {
#line 1955
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            1955);
#line 1955
      packet_disconnect("Packet integrity error.");
    }
#line 1955
    break;
  }
#line 1956
  logit("subsystem request for %.100s", subsys);
#line 1958
  i = 0U;
#line 1958
  while (i < options.num_subsystems) {
#line 1959
    if (0) {
#line 1959
      __s1_len___0 = strlen((char const   *)subsys);
#line 1959
      __s2_len___0 = strlen((char const   *)options.subsystem_name[i]);
#line 1959
      if (! ((unsigned int )((void const   *)(subsys + 1)) - (unsigned int )((void const   *)subsys) == 1U)) {
        goto _L___2;
      } else {
#line 1959
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1959
          if (! ((unsigned int )((void const   *)(options.subsystem_name[i] + 1)) - (unsigned int )((void const   *)options.subsystem_name[i]) == 1U)) {
#line 1959
            tmp___23 = 1;
          } else {
#line 1959
            if (__s2_len___0 >= 4U) {
#line 1959
              tmp___23 = 1;
            } else {
#line 1959
              tmp___23 = 0;
            }
          }
        } else {
#line 1959
          tmp___23 = 0;
        }
      }
#line 1959
      if (tmp___23) {
#line 1959
        tmp___19 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
      } else {
#line 1959
        tmp___22 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1959
        tmp___19 = tmp___22;
      }
    } else {
#line 1959
      tmp___22 = __builtin_strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
#line 1959
      tmp___19 = tmp___22;
    }
#line 1959
    if (tmp___19 == 0) {
#line 1960
      prog = options.subsystem_command[i];
#line 1961
      cmd = options.subsystem_args[i];
#line 1962
      if (0) {
#line 1962
        __s1_len = strlen("internal-sftp");
#line 1962
        __s2_len = strlen((char const   *)prog);
#line 1962
        if (! ((unsigned int )((void const   *)("internal-sftp" + 1)) - (unsigned int )((void const   *)"internal-sftp") == 1U)) {
          goto _L___0;
        } else {
#line 1962
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 1962
            if (! ((unsigned int )((void const   *)(prog + 1)) - (unsigned int )((void const   *)prog) == 1U)) {
#line 1962
              tmp___13 = 1;
            } else {
#line 1962
              if (__s2_len >= 4U) {
#line 1962
                tmp___13 = 1;
              } else {
#line 1962
                tmp___13 = 0;
              }
            }
          } else {
#line 1962
            tmp___13 = 0;
          }
        }
#line 1962
        if (tmp___13) {
#line 1962
          tmp___9 = __builtin_strcmp("internal-sftp", (char const   *)prog);
        } else {
#line 1962
          tmp___12 = __builtin_strcmp("internal-sftp", (char const   *)prog);
#line 1962
          tmp___9 = tmp___12;
        }
      } else {
#line 1962
        tmp___12 = __builtin_strcmp("internal-sftp", (char const   *)prog);
#line 1962
        tmp___9 = tmp___12;
      }
#line 1962
      if (tmp___9) {
#line 1964
        tmp___3 = stat((char const   * __restrict  )prog, (struct stat * __restrict  )(& st));
#line 1964
        if (tmp___3 < 0) {
#line 1965
          tmp___1 = __errno_location();
#line 1965
          tmp___2 = strerror(*tmp___1);
#line 1965
          error("subsystem: cannot stat %s: %s", prog, tmp___2);
#line 1967
          break;
        } else {
#line 1969
          s->is_subsystem = 1;
        }
      } else {
#line 1963
        s->is_subsystem = 2;
      }
#line 1971
      debug("subsystem: exec() %s", cmd);
#line 1972
      do_exec(s, (char const   *)cmd);
#line 1973
      success = 1;
#line 1974
      break;
    }
#line 1958
    i ++;
  }
#line 1978
  if (! success) {
#line 1979
    logit("subsystem request for %.100s failed, subsystem not found", subsys);
  }
#line 1982
  xfree((void *)subsys);
#line 1983
  return (success);
}
}
#line 1986 "session.c"
static int session_x11_req(Session *s ) 
{ int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;

  {
#line 1991
  if ((unsigned int )s->auth_proto != (unsigned int )((void *)0)) {
#line 1992
    error("session_x11_req: session %d: x11 forwarding already active", s->self);
#line 1994
    return (0);
  } else {
#line 1991
    if ((unsigned int )s->auth_data != (unsigned int )((void *)0)) {
#line 1992
      error("session_x11_req: session %d: x11 forwarding already active", s->self);
#line 1994
      return (0);
    }
  }
#line 1996
  tmp = packet_get_char();
#line 1996
  s->single_connection = (int )tmp;
#line 1997
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 1997
  s->auth_proto = (char *)tmp___0;
#line 1998
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 1998
  s->auth_data = (char *)tmp___1;
#line 1999
  s->screen = packet_get_int();
#line 2000
  while (1) {
#line 2000
    tmp___2 = packet_remaining();
#line 2000
    _len = tmp___2;
#line 2000
    if (_len > 0) {
#line 2000
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2000);
#line 2000
      packet_disconnect("Packet integrity error.");
    }
#line 2000
    break;
  }
#line 2002
  success = session_setup_x11fwd(s);
#line 2003
  if (! success) {
#line 2004
    xfree((void *)s->auth_proto);
#line 2005
    xfree((void *)s->auth_data);
#line 2006
    s->auth_proto = (char *)((void *)0);
#line 2007
    s->auth_data = (char *)((void *)0);
  }
#line 2009
  return (success);
}
}
#line 2012 "session.c"
static int session_shell_req(Session *s ) 
{ int _len ;
  int tmp ;

  {
#line 2015
  while (1) {
#line 2015
    tmp = packet_remaining();
#line 2015
    _len = tmp;
#line 2015
    if (_len > 0) {
#line 2015
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2015);
#line 2015
      packet_disconnect("Packet integrity error.");
    }
#line 2015
    break;
  }
#line 2016
  do_exec(s, (char const   *)((void *)0));
#line 2017
  return (1);
}
}
#line 2020 "session.c"
static int session_exec_req(Session *s ) 
{ u_int len ;
  char *command ;
  void *tmp ;
  int _len ;
  int tmp___0 ;

  {
#line 2024
  tmp = packet_get_string(& len);
#line 2024
  command = (char *)tmp;
#line 2025
  while (1) {
#line 2025
    tmp___0 = packet_remaining();
#line 2025
    _len = tmp___0;
#line 2025
    if (_len > 0) {
#line 2025
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2025);
#line 2025
      packet_disconnect("Packet integrity error.");
    }
#line 2025
    break;
  }
#line 2026
  do_exec(s, (char const   *)command);
#line 2027
  xfree((void *)command);
#line 2028
  return (1);
}
}
#line 2031 "session.c"
static int session_break_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 2035
  packet_get_int();
#line 2036
  while (1) {
#line 2036
    tmp = packet_remaining();
#line 2036
    _len = tmp;
#line 2036
    if (_len > 0) {
#line 2036
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2036);
#line 2036
      packet_disconnect("Packet integrity error.");
    }
#line 2036
    break;
  }
#line 2038
  if (s->ttyfd == -1) {
#line 2040
    return (0);
  } else {
#line 2038
    tmp___0 = tcsendbreak(s->ttyfd, 0);
#line 2038
    if (tmp___0 < 0) {
#line 2040
      return (0);
    }
  }
#line 2041
  return (1);
}
}
#line 2044 "session.c"
static int session_env_req(Session *s ) 
{ char *name ;
  char *val ;
  u_int name_len ;
  u_int val_len ;
  u_int i ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 2050
  tmp = packet_get_string(& name_len);
#line 2050
  name = (char *)tmp;
#line 2051
  tmp___0 = packet_get_string(& val_len);
#line 2051
  val = (char *)tmp___0;
#line 2052
  while (1) {
#line 2052
    tmp___1 = packet_remaining();
#line 2052
    _len = tmp___1;
#line 2052
    if (_len > 0) {
#line 2052
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2052);
#line 2052
      packet_disconnect("Packet integrity error.");
    }
#line 2052
    break;
  }
#line 2055
  if (s->num_env > 128U) {
#line 2056
    debug2("Ignoring env request %s: too many env vars", name);
    goto fail;
  }
#line 2060
  i = 0U;
#line 2060
  while (i < options.num_accept_env) {
#line 2061
    tmp___3 = match_pattern((char const   *)name, (char const   *)options.accept_env[i]);
#line 2061
    if (tmp___3) {
#line 2062
      debug2("Setting env %d: %s=%s", s->num_env, name, val);
#line 2063
      tmp___2 = xrealloc((void *)s->env, s->num_env + 1U, sizeof(*(s->env)));
#line 2063
      s->env = (struct __anonstruct_env_80 *)tmp___2;
#line 2065
      (s->env + s->num_env)->name = name;
#line 2066
      (s->env + s->num_env)->val = val;
#line 2067
      (s->num_env) ++;
#line 2068
      return (1);
    }
#line 2060
    i ++;
  }
#line 2071
  debug2("Ignoring env request %s: disallowed name", name);
  fail: 
#line 2074
  xfree((void *)name);
#line 2075
  xfree((void *)val);
#line 2076
  return (0);
}
}
#line 2082
static int session_auth_agent_req(Session *s ) ;
#line 2082 "session.c"
static int called___1  =    0;
#line 2079 "session.c"
static int session_auth_agent_req(Session *s ) 
{ int _len ;
  int tmp ;
  int tmp___0 ;

  {
#line 2083
  while (1) {
#line 2083
    tmp = packet_remaining();
#line 2083
    _len = tmp;
#line 2083
    if (_len > 0) {
#line 2083
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "session.c",
            2083);
#line 2083
      packet_disconnect("Packet integrity error.");
    }
#line 2083
    break;
  }
#line 2084
  if (no_agent_forwarding_flag) {
#line 2085
    debug("session_auth_agent_req: no_agent_forwarding_flag");
#line 2086
    return (0);
  }
#line 2088
  if (called___1) {
#line 2089
    return (0);
  } else {
#line 2091
    called___1 = 1;
#line 2092
    tmp___0 = auth_input_request_forwarding(s->pw);
#line 2092
    return (tmp___0);
  }
}
}
#line 2096 "session.c"
int session_input_channel_req(Channel *c , char const   *rtype ) 
{ int success ;
  Session *s ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___54 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;

  {
#line 2099
  success = 0;
#line 2102
  s = session_by_channel(c->self);
#line 2102
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2103
    logit("session_input_channel_req: no session %d req %.100s", c->self, rtype);
#line 2105
    return (0);
  }
#line 2107
  debug("session_input_channel_req: session %d req %s", s->self, rtype);
#line 2113
  if (c->type == 10) {
#line 2114
    if (0) {
#line 2114
      __s1_len___5 = strlen(rtype);
#line 2114
      __s2_len___5 = strlen("shell");
#line 2114
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___12;
      } else {
#line 2114
        if (__s1_len___5 >= 4U) {
          _L___12: /* CIL Label */ 
#line 2114
          if (! ((unsigned int )((void const   *)("shell" + 1)) - (unsigned int )((void const   *)"shell") == 1U)) {
#line 2114
            tmp___68 = 1;
          } else {
#line 2114
            if (__s2_len___5 >= 4U) {
#line 2114
              tmp___68 = 1;
            } else {
#line 2114
              tmp___68 = 0;
            }
          }
        } else {
#line 2114
          tmp___68 = 0;
        }
      }
#line 2114
      if (tmp___68) {
#line 2114
        tmp___64 = __builtin_strcmp(rtype, "shell");
      } else {
#line 2114
        tmp___67 = __builtin_strcmp(rtype, "shell");
#line 2114
        tmp___64 = tmp___67;
      }
    } else {
#line 2114
      tmp___67 = __builtin_strcmp(rtype, "shell");
#line 2114
      tmp___64 = tmp___67;
    }
#line 2114
    if (tmp___64 == 0) {
#line 2115
      success = session_shell_req(s);
    } else {
#line 2116
      if (0) {
#line 2116
        __s1_len___4 = strlen(rtype);
#line 2116
        __s2_len___4 = strlen("exec");
#line 2116
        if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
          goto _L___10;
        } else {
#line 2116
          if (__s1_len___4 >= 4U) {
            _L___10: /* CIL Label */ 
#line 2116
            if (! ((unsigned int )((void const   *)("exec" + 1)) - (unsigned int )((void const   *)"exec") == 1U)) {
#line 2116
              tmp___58 = 1;
            } else {
#line 2116
              if (__s2_len___4 >= 4U) {
#line 2116
                tmp___58 = 1;
              } else {
#line 2116
                tmp___58 = 0;
              }
            }
          } else {
#line 2116
            tmp___58 = 0;
          }
        }
#line 2116
        if (tmp___58) {
#line 2116
          tmp___54 = __builtin_strcmp(rtype, "exec");
        } else {
#line 2116
          tmp___57 = __builtin_strcmp(rtype, "exec");
#line 2116
          tmp___54 = tmp___57;
        }
      } else {
#line 2116
        tmp___57 = __builtin_strcmp(rtype, "exec");
#line 2116
        tmp___54 = tmp___57;
      }
#line 2116
      if (tmp___54 == 0) {
#line 2117
        success = session_exec_req(s);
      } else {
#line 2118
        if (0) {
#line 2118
          __s1_len___3 = strlen(rtype);
#line 2118
          __s2_len___3 = strlen("pty-req");
#line 2118
          if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
            goto _L___8;
          } else {
#line 2118
            if (__s1_len___3 >= 4U) {
              _L___8: /* CIL Label */ 
#line 2118
              if (! ((unsigned int )((void const   *)("pty-req" + 1)) - (unsigned int )((void const   *)"pty-req") == 1U)) {
#line 2118
                tmp___48 = 1;
              } else {
#line 2118
                if (__s2_len___3 >= 4U) {
#line 2118
                  tmp___48 = 1;
                } else {
#line 2118
                  tmp___48 = 0;
                }
              }
            } else {
#line 2118
              tmp___48 = 0;
            }
          }
#line 2118
          if (tmp___48) {
#line 2118
            tmp___44 = __builtin_strcmp(rtype, "pty-req");
          } else {
#line 2118
            tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 2118
            tmp___44 = tmp___47;
          }
        } else {
#line 2118
          tmp___47 = __builtin_strcmp(rtype, "pty-req");
#line 2118
          tmp___44 = tmp___47;
        }
#line 2118
        if (tmp___44 == 0) {
#line 2119
          success = session_pty_req(s);
        } else {
#line 2120
          if (0) {
#line 2120
            __s1_len___2 = strlen(rtype);
#line 2120
            __s2_len___2 = strlen("x11-req");
#line 2120
            if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
              goto _L___6;
            } else {
#line 2120
              if (__s1_len___2 >= 4U) {
                _L___6: /* CIL Label */ 
#line 2120
                if (! ((unsigned int )((void const   *)("x11-req" + 1)) - (unsigned int )((void const   *)"x11-req") == 1U)) {
#line 2120
                  tmp___38 = 1;
                } else {
#line 2120
                  if (__s2_len___2 >= 4U) {
#line 2120
                    tmp___38 = 1;
                  } else {
#line 2120
                    tmp___38 = 0;
                  }
                }
              } else {
#line 2120
                tmp___38 = 0;
              }
            }
#line 2120
            if (tmp___38) {
#line 2120
              tmp___34 = __builtin_strcmp(rtype, "x11-req");
            } else {
#line 2120
              tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 2120
              tmp___34 = tmp___37;
            }
          } else {
#line 2120
            tmp___37 = __builtin_strcmp(rtype, "x11-req");
#line 2120
            tmp___34 = tmp___37;
          }
#line 2120
          if (tmp___34 == 0) {
#line 2121
            success = session_x11_req(s);
          } else {
#line 2122
            if (0) {
#line 2122
              __s1_len___1 = strlen(rtype);
#line 2122
              __s2_len___1 = strlen("auth-agent-req@openssh.com");
#line 2122
              if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                goto _L___4;
              } else {
#line 2122
                if (__s1_len___1 >= 4U) {
                  _L___4: /* CIL Label */ 
#line 2122
                  if (! ((unsigned int )((void const   *)("auth-agent-req@openssh.com" + 1)) - (unsigned int )((void const   *)"auth-agent-req@openssh.com") == 1U)) {
#line 2122
                    tmp___28 = 1;
                  } else {
#line 2122
                    if (__s2_len___1 >= 4U) {
#line 2122
                      tmp___28 = 1;
                    } else {
#line 2122
                      tmp___28 = 0;
                    }
                  }
                } else {
#line 2122
                  tmp___28 = 0;
                }
              }
#line 2122
              if (tmp___28) {
#line 2122
                tmp___24 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
              } else {
#line 2122
                tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 2122
                tmp___24 = tmp___27;
              }
            } else {
#line 2122
              tmp___27 = __builtin_strcmp(rtype, "auth-agent-req@openssh.com");
#line 2122
              tmp___24 = tmp___27;
            }
#line 2122
            if (tmp___24 == 0) {
#line 2123
              success = session_auth_agent_req(s);
            } else {
#line 2124
              if (0) {
#line 2124
                __s1_len___0 = strlen(rtype);
#line 2124
                __s2_len___0 = strlen("subsystem");
#line 2124
                if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                  goto _L___2;
                } else {
#line 2124
                  if (__s1_len___0 >= 4U) {
                    _L___2: /* CIL Label */ 
#line 2124
                    if (! ((unsigned int )((void const   *)("subsystem" + 1)) - (unsigned int )((void const   *)"subsystem") == 1U)) {
#line 2124
                      tmp___18 = 1;
                    } else {
#line 2124
                      if (__s2_len___0 >= 4U) {
#line 2124
                        tmp___18 = 1;
                      } else {
#line 2124
                        tmp___18 = 0;
                      }
                    }
                  } else {
#line 2124
                    tmp___18 = 0;
                  }
                }
#line 2124
                if (tmp___18) {
#line 2124
                  tmp___14 = __builtin_strcmp(rtype, "subsystem");
                } else {
#line 2124
                  tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 2124
                  tmp___14 = tmp___17;
                }
              } else {
#line 2124
                tmp___17 = __builtin_strcmp(rtype, "subsystem");
#line 2124
                tmp___14 = tmp___17;
              }
#line 2124
              if (tmp___14 == 0) {
#line 2125
                success = session_subsystem_req(s);
              } else {
#line 2126
                if (0) {
#line 2126
                  __s1_len = strlen(rtype);
#line 2126
                  __s2_len = strlen("env");
#line 2126
                  if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
                    goto _L___0;
                  } else {
#line 2126
                    if (__s1_len >= 4U) {
                      _L___0: /* CIL Label */ 
#line 2126
                      if (! ((unsigned int )((void const   *)("env" + 1)) - (unsigned int )((void const   *)"env") == 1U)) {
#line 2126
                        tmp___8 = 1;
                      } else {
#line 2126
                        if (__s2_len >= 4U) {
#line 2126
                          tmp___8 = 1;
                        } else {
#line 2126
                          tmp___8 = 0;
                        }
                      }
                    } else {
#line 2126
                      tmp___8 = 0;
                    }
                  }
#line 2126
                  if (tmp___8) {
#line 2126
                    tmp___4 = __builtin_strcmp(rtype, "env");
                  } else {
#line 2126
                    tmp___7 = __builtin_strcmp(rtype, "env");
#line 2126
                    tmp___4 = tmp___7;
                  }
                } else {
#line 2126
                  tmp___7 = __builtin_strcmp(rtype, "env");
#line 2126
                  tmp___4 = tmp___7;
                }
#line 2126
                if (tmp___4 == 0) {
#line 2127
                  success = session_env_req(s);
                }
              }
            }
          }
        }
      }
    }
  }
#line 2130
  if (0) {
#line 2130
    __s1_len___7 = strlen(rtype);
#line 2130
    __s2_len___7 = strlen("window-change");
#line 2130
    if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
      goto _L___16;
    } else {
#line 2130
      if (__s1_len___7 >= 4U) {
        _L___16: /* CIL Label */ 
#line 2130
        if (! ((unsigned int )((void const   *)("window-change" + 1)) - (unsigned int )((void const   *)"window-change") == 1U)) {
#line 2130
          tmp___88 = 1;
        } else {
#line 2130
          if (__s2_len___7 >= 4U) {
#line 2130
            tmp___88 = 1;
          } else {
#line 2130
            tmp___88 = 0;
          }
        }
      } else {
#line 2130
        tmp___88 = 0;
      }
    }
#line 2130
    if (tmp___88) {
#line 2130
      tmp___84 = __builtin_strcmp(rtype, "window-change");
    } else {
#line 2130
      tmp___87 = __builtin_strcmp(rtype, "window-change");
#line 2130
      tmp___84 = tmp___87;
    }
  } else {
#line 2130
    tmp___87 = __builtin_strcmp(rtype, "window-change");
#line 2130
    tmp___84 = tmp___87;
  }
#line 2130
  if (tmp___84 == 0) {
#line 2131
    success = session_window_change_req(s);
  } else {
#line 2132
    if (0) {
#line 2132
      __s1_len___6 = strlen(rtype);
#line 2132
      __s2_len___6 = strlen("break");
#line 2132
      if (! ((unsigned int )((void const   *)(rtype + 1)) - (unsigned int )((void const   *)rtype) == 1U)) {
        goto _L___14;
      } else {
#line 2132
        if (__s1_len___6 >= 4U) {
          _L___14: /* CIL Label */ 
#line 2132
          if (! ((unsigned int )((void const   *)("break" + 1)) - (unsigned int )((void const   *)"break") == 1U)) {
#line 2132
            tmp___78 = 1;
          } else {
#line 2132
            if (__s2_len___6 >= 4U) {
#line 2132
              tmp___78 = 1;
            } else {
#line 2132
              tmp___78 = 0;
            }
          }
        } else {
#line 2132
          tmp___78 = 0;
        }
      }
#line 2132
      if (tmp___78) {
#line 2132
        tmp___74 = __builtin_strcmp(rtype, "break");
      } else {
#line 2132
        tmp___77 = __builtin_strcmp(rtype, "break");
#line 2132
        tmp___74 = tmp___77;
      }
    } else {
#line 2132
      tmp___77 = __builtin_strcmp(rtype, "break");
#line 2132
      tmp___74 = tmp___77;
    }
#line 2132
    if (tmp___74 == 0) {
#line 2133
      success = session_break_req(s);
    }
  }
#line 2136
  return (success);
}
}
#line 2139 "session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ int tmp ;

  {
#line 2142
  if (! compat20) {
#line 2143
    fatal("session_set_fds: called for proto != 2.0");
  }
#line 2148
  if (s->chanid == -1) {
#line 2149
    fatal("no channel for session %d", s->self);
  }
#line 2150
  if (fderr___0 == -1) {
#line 2150
    tmp = 0;
  } else {
#line 2150
    tmp = 1;
  }
#line 2150
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1, 2097152U);
#line 2155
  return;
}
}
#line 2161 "session.c"
void session_pty_cleanup2(Session *s ) 
{ __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 2164
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2165
    error("session_pty_cleanup: no session");
#line 2166
    return;
  }
#line 2168
  if (s->ttyfd == -1) {
#line 2169
    return;
  }
#line 2171
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
#line 2174
  if (s->pid != 0) {
#line 2175
    record_logout(s->pid, (char const   *)(s->tty), (char const   *)(s->pw)->pw_name);
  }
#line 2178
  tmp = getuid();
#line 2178
  if (tmp == 0U) {
#line 2179
    pty_release((char const   *)(s->tty));
  }
#line 2186
  tmp___2 = close(s->ptymaster);
#line 2186
  if (tmp___2 < 0) {
#line 2187
    tmp___0 = __errno_location();
#line 2187
    tmp___1 = strerror(*tmp___0);
#line 2187
    error("close(s->ptymaster/%d): %s", s->ptymaster, tmp___1);
  }
#line 2190
  s->ttyfd = -1;
#line 2191
  return;
}
}
#line 2193 "session.c"
void session_pty_cleanup(Session *s ) 
{ 

  {
#line 2196
  if (use_privsep) {
#line 2196
    mm_session_pty_cleanup2(s);
  } else {
#line 2196
    session_pty_cleanup2(s);
  }
#line 2197
  return;
}
}
#line 2199 "session.c"
static char *sig2name(int sig ) 
{ 

  {
#line 2203
  if (sig == 6) {
#line 2203
    return ((char *)"ABRT");
  }
#line 2204
  if (sig == 14) {
#line 2204
    return ((char *)"ALRM");
  }
#line 2205
  if (sig == 8) {
#line 2205
    return ((char *)"FPE");
  }
#line 2206
  if (sig == 1) {
#line 2206
    return ((char *)"HUP");
  }
#line 2207
  if (sig == 4) {
#line 2207
    return ((char *)"ILL");
  }
#line 2208
  if (sig == 2) {
#line 2208
    return ((char *)"INT");
  }
#line 2209
  if (sig == 9) {
#line 2209
    return ((char *)"KILL");
  }
#line 2210
  if (sig == 13) {
#line 2210
    return ((char *)"PIPE");
  }
#line 2211
  if (sig == 3) {
#line 2211
    return ((char *)"QUIT");
  }
#line 2212
  if (sig == 11) {
#line 2212
    return ((char *)"SEGV");
  }
#line 2213
  if (sig == 15) {
#line 2213
    return ((char *)"TERM");
  }
#line 2214
  if (sig == 10) {
#line 2214
    return ((char *)"USR1");
  }
#line 2215
  if (sig == 12) {
#line 2215
    return ((char *)"USR2");
  }
#line 2217
  return ((char *)"SIG@openssh.com");
}
}
#line 2220 "session.c"
static void session_close_x11(int id ) 
{ Channel *c ;

  {
#line 2225
  c = channel_by_id(id);
#line 2225
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2226
    debug("session_close_x11: x11 channel %d missing", id);
  } else {
#line 2229
    debug("session_close_x11: detach x11 channel %d", id);
#line 2230
    channel_cancel_cleanup(id);
#line 2231
    if (c->ostate != 3U) {
#line 2232
      chan_mark_dead(c);
    }
  }
#line 2234
  return;
}
}
#line 2236 "session.c"
static void session_close_single_x11(int id , void *arg ) 
{ Session *s ;
  u_int i ;

  {
#line 2242
  debug3("session_close_single_x11: channel %d", id);
#line 2243
  channel_cancel_cleanup(id);
#line 2244
  s = session_by_x11_channel(id);
#line 2244
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2245
    fatal("session_close_single_x11: no x11 channel %d", id);
  }
#line 2246
  i = 0U;
#line 2246
  while (*(s->x11_chanids + i) != -1) {
#line 2247
    debug("session_close_single_x11: session %d: closing channel %d", s->self, *(s->x11_chanids + i));
#line 2253
    if (*(s->x11_chanids + i) != id) {
#line 2254
      session_close_x11(*(s->x11_chanids + i));
    }
#line 2246
    i ++;
  }
#line 2256
  xfree((void *)s->x11_chanids);
#line 2257
  s->x11_chanids = (int *)((void *)0);
#line 2258
  if (s->display) {
#line 2259
    xfree((void *)s->display);
#line 2260
    s->display = (char *)((void *)0);
  }
#line 2262
  if (s->auth_proto) {
#line 2263
    xfree((void *)s->auth_proto);
#line 2264
    s->auth_proto = (char *)((void *)0);
  }
#line 2266
  if (s->auth_data) {
#line 2267
    xfree((void *)s->auth_data);
#line 2268
    s->auth_data = (char *)((void *)0);
  }
#line 2270
  if (s->auth_display) {
#line 2271
    xfree((void *)s->auth_display);
#line 2272
    s->auth_display = (char *)((void *)0);
  }
#line 2274
  return;
}
}
#line 2276 "session.c"
static void session_exit_message(Session *s , int status ) 
{ Channel *c ;
  union __anonunion___u_81 __u ;
  union __anonunion___u_82___0 __u___0 ;
  char *tmp ;
  int tmp___0 ;
  union __anonunion___u_84___0 __u___2 ;
  union __anonunion___u_85___0 __u___3 ;
  union __anonunion___u_86___0 __u___4 ;

  {
#line 2281
  c = channel_lookup(s->chanid);
#line 2281
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 2282
    fatal("session_exit_message: session %d: no channel %d", s->self, s->chanid);
  }
#line 2284
  debug("session_exit_message: session %d channel %d pid %ld", s->self, s->chanid,
        (long )s->pid);
#line 2287
  __u___4.__in = status;
#line 2287
  if ((__u___4.__i & 127) == 0) {
#line 2288
    channel_request_start(s->chanid, (char *)"exit-status", 0);
#line 2289
    __u.__in = status;
#line 2289
    packet_put_int((unsigned int )((__u.__i & 65280) >> 8));
#line 2290
    packet_send();
  } else {
#line 2291
    __u___3.__in = status;
#line 2291
    if ((int )((signed char )((__u___3.__i & 127) + 1)) >> 1 > 0) {
#line 2292
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
#line 2293
      __u___0.__in = status;
#line 2293
      tmp = sig2name(__u___0.__i & 127);
#line 2293
      packet_put_cstring((char const   *)tmp);
#line 2295
      __u___2.__in = status;
#line 2295
      if (__u___2.__i & 128) {
#line 2295
        tmp___0 = 1;
      } else {
#line 2295
        tmp___0 = 0;
      }
#line 2295
      packet_put_char(tmp___0);
#line 2299
      packet_put_cstring("");
#line 2300
      packet_put_cstring("");
#line 2301
      packet_send();
    } else {
#line 2304
      packet_disconnect("wait returned status %04x.", status);
    }
  }
#line 2308
  debug("session_exit_message: release channel %d", s->chanid);
#line 2315
  channel_register_cleanup(c->self, & session_close_by_channel, 1);
#line 2323
  if (c->ostate != 3U) {
#line 2324
    chan_write_failed(c);
  }
#line 2325
  return;
}
}
#line 2327 "session.c"
void session_close(Session *s ) 
{ u_int i ;

  {
#line 2332
  debug("session_close: session %d pid %ld", s->self, (long )s->pid);
#line 2333
  if (s->ttyfd != -1) {
#line 2334
    session_pty_cleanup(s);
  }
#line 2335
  if (s->term) {
#line 2336
    xfree((void *)s->term);
  }
#line 2337
  if (s->display) {
#line 2338
    xfree((void *)s->display);
  }
#line 2339
  if (s->x11_chanids) {
#line 2340
    xfree((void *)s->x11_chanids);
  }
#line 2341
  if (s->auth_display) {
#line 2342
    xfree((void *)s->auth_display);
  }
#line 2343
  if (s->auth_data) {
#line 2344
    xfree((void *)s->auth_data);
  }
#line 2345
  if (s->auth_proto) {
#line 2346
    xfree((void *)s->auth_proto);
  }
#line 2347
  s->used = 0;
#line 2348
  if ((unsigned int )s->env != (unsigned int )((void *)0)) {
#line 2349
    i = 0U;
#line 2349
    while (i < s->num_env) {
#line 2350
      xfree((void *)(s->env + i)->name);
#line 2351
      xfree((void *)(s->env + i)->val);
#line 2349
      i ++;
    }
#line 2353
    xfree((void *)s->env);
  }
#line 2355
  session_proctitle(s);
#line 2356
  return;
}
}
#line 2358 "session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ Session *s ;
  Session *tmp ;

  {
#line 2361
  tmp = session_by_pid(pid);
#line 2361
  s = tmp;
#line 2362
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2363
    debug("session_close_by_pid: no session for pid %ld", (long )pid);
#line 2365
    return;
  }
#line 2367
  if (s->chanid != -1) {
#line 2368
    session_exit_message(s, status);
  }
#line 2369
  if (s->ttyfd != -1) {
#line 2370
    session_pty_cleanup(s);
  }
#line 2371
  s->pid = 0;
#line 2372
  return;
}
}
#line 2378 "session.c"
void session_close_by_channel(int id , void *arg ) 
{ Session *s ;
  Session *tmp ;
  u_int i ;

  {
#line 2381
  tmp = session_by_channel(id);
#line 2381
  s = tmp;
#line 2384
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2385
    debug("session_close_by_channel: no session for id %d", id);
#line 2386
    return;
  }
#line 2388
  debug("session_close_by_channel: channel %d child %ld", id, (long )s->pid);
#line 2390
  if (s->pid != 0) {
#line 2391
    debug("session_close_by_channel: channel %d: has child", id);
#line 2396
    if (s->ttyfd != -1) {
#line 2397
      session_pty_cleanup(s);
    }
#line 2398
    return;
  }
#line 2401
  channel_cancel_cleanup(s->chanid);
#line 2404
  if ((unsigned int )s->x11_chanids != (unsigned int )((void *)0)) {
#line 2405
    i = 0U;
#line 2405
    while (*(s->x11_chanids + i) != -1) {
#line 2406
      session_close_x11(*(s->x11_chanids + i));
#line 2407
      *(s->x11_chanids + i) = -1;
#line 2405
      i ++;
    }
  }
#line 2411
  s->chanid = -1;
#line 2412
  session_close(s);
#line 2413
  return;
}
}
#line 2415 "session.c"
void session_destroy_all(void (*closefunc)(Session * ) ) 
{ int i ;
  Session *s ;

  {
#line 2419
  i = 0;
#line 2419
  while (i < 20) {
#line 2420
    s = & sessions[i];
#line 2421
    if (s->used) {
#line 2422
      if ((unsigned int )closefunc != (unsigned int )((void *)0)) {
#line 2423
        (*closefunc)(s);
      } else {
#line 2425
        session_close(s);
      }
    }
#line 2419
    i ++;
  }
#line 2428
  return;
}
}
#line 2433 "session.c"
static char buf___0[1024]  ;
#line 2430 "session.c"
static char *session_tty_list(void) 
{ int i ;
  char *cp ;
  Session *s ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 2437
  buf___0[0] = (char )'\000';
#line 2438
  i = 0;
#line 2438
  while (i < 20) {
#line 2439
    s = & sessions[i];
#line 2440
    if (s->used) {
#line 2440
      if (s->ttyfd != -1) {
#line 2442
        if (0) {
#line 2442
          if (0) {
#line 2442
            __s1_len___0 = strlen((char const   *)(s->tty));
#line 2442
            __s2_len___0 = strlen("/dev/");
#line 2442
            if (! ((unsigned int )((void const   *)(s->tty + 1)) - (unsigned int )((void const   *)(s->tty)) == 1U)) {
              goto _L___2;
            } else {
#line 2442
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
#line 2442
                if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 2442
                  tmp___22 = 1;
                } else {
#line 2442
                  if (__s2_len___0 >= 4U) {
#line 2442
                    tmp___22 = 1;
                  } else {
#line 2442
                    tmp___22 = 0;
                  }
                }
              } else {
#line 2442
                tmp___22 = 0;
              }
            }
#line 2442
            if (tmp___22) {
#line 2442
              tmp___18 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
            } else {
#line 2442
              tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2442
              tmp___18 = tmp___21;
            }
          } else {
#line 2442
            tmp___21 = __builtin_strcmp((char const   *)(s->tty), "/dev/");
#line 2442
            tmp___18 = tmp___21;
          }
#line 2442
          tmp___12 = tmp___18;
        } else {
#line 2442
          tmp___12 = strncmp((char const   *)(s->tty), "/dev/", 5U);
        }
#line 2442
        if (tmp___12 != 0) {
#line 2443
          cp = strrchr((char const   *)(s->tty), '/');
#line 2444
          if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 2444
            cp = s->tty;
          } else {
#line 2444
            cp ++;
          }
        } else {
#line 2446
          cp = s->tty + 5;
        }
#line 2448
        if ((int )buf___0[0] != 0) {
#line 2449
          strlcat(buf___0, ",", sizeof(buf___0));
        }
#line 2450
        strlcat(buf___0, (char const   *)cp, sizeof(buf___0));
      }
    }
#line 2438
    i ++;
  }
#line 2453
  if ((int )buf___0[0] == 0) {
#line 2454
    strlcpy(buf___0, "notty", sizeof(buf___0));
  }
#line 2455
  return (buf___0);
}
}
#line 2458 "session.c"
void session_proctitle(Session *s ) 
{ char *tmp ;

  {
#line 2461
  if ((unsigned int )s->pw == (unsigned int )((void *)0)) {
#line 2462
    error("no user for session %d", s->self);
  } else {
#line 2464
    tmp = session_tty_list();
#line 2464
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
  }
#line 2465
  return;
}
}
#line 2467 "session.c"
int session_setup_x11fwd(Session *s ) 
{ struct stat st ;
  char display[512] ;
  char auth_display[512] ;
  char hostname[64] ;
  u_int i ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 2475
  if (no_x11_forwarding_flag) {
#line 2476
    packet_send_debug("X11 forwarding disabled in user configuration file.");
#line 2477
    return (0);
  }
#line 2479
  if (! options.x11_forwarding) {
#line 2480
    debug("X11 forwarding disabled in server configuration file.");
#line 2481
    return (0);
  }
#line 2483
  if (! options.xauth_location) {
#line 2485
    packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2486
    return (0);
  } else {
#line 2483
    tmp = stat((char const   * __restrict  )options.xauth_location, (struct stat * __restrict  )(& st));
#line 2483
    if (tmp == -1) {
#line 2485
      packet_send_debug("No xauth program; cannot forward with spoofing.");
#line 2486
      return (0);
    }
  }
#line 2488
  if (options.use_login) {
#line 2489
    packet_send_debug("X11 forwarding disabled; not compatible with UseLogin=yes.");
#line 2491
    return (0);
  }
#line 2493
  if ((unsigned int )s->display != (unsigned int )((void *)0)) {
#line 2494
    debug("X11 display already set.");
#line 2495
    return (0);
  }
#line 2497
  tmp___0 = x11_create_display_inet(options.x11_display_offset, options.x11_use_localhost,
                                    s->single_connection, & s->display_number, & s->x11_chanids);
#line 2497
  if (tmp___0 == -1) {
#line 2500
    debug("x11_create_display_inet failed.");
#line 2501
    return (0);
  }
#line 2503
  i = 0U;
#line 2503
  while (*(s->x11_chanids + i) != -1) {
#line 2504
    channel_register_cleanup(*(s->x11_chanids + i), & session_close_single_x11, 0);
#line 2503
    i ++;
  }
#line 2509
  tmp___3 = gethostname(hostname, sizeof(hostname));
#line 2509
  if (tmp___3 < 0) {
#line 2510
    tmp___1 = __errno_location();
#line 2510
    tmp___2 = strerror(*tmp___1);
#line 2510
    fatal("gethostname: %.100s", tmp___2);
  }
#line 2516
  if (options.x11_use_localhost) {
#line 2517
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"localhost:%u.%u",
             s->display_number, s->screen);
#line 2519
    snprintf((char * __restrict  )(auth_display), sizeof(auth_display), (char const   * __restrict  )"unix:%u.%u",
             s->display_number, s->screen);
#line 2521
    s->display = xstrdup((char const   *)(display));
#line 2522
    s->auth_display = xstrdup((char const   *)(auth_display));
  } else {
#line 2538
    snprintf((char * __restrict  )(display), sizeof(display), (char const   * __restrict  )"%.400s:%u.%u",
             hostname, s->display_number, s->screen);
#line 2541
    s->display = xstrdup((char const   *)(display));
#line 2542
    s->auth_display = xstrdup((char const   *)(display));
  }
#line 2545
  return (1);
}
}
#line 2548 "session.c"
static void do_authenticated2(Authctxt *authctxt___0 ) 
{ 

  {
#line 2551
  server_loop2(authctxt___0);
#line 2552
  return;
}
}
#line 2557 "session.c"
static int called___2  =    0;
#line 2554 "session.c"
void do_cleanup(Authctxt *authctxt___0 ) 
{ int tmp ;

  {
#line 2559
  debug("do_cleanup");
#line 2562
  if (is_child) {
#line 2563
    return;
  }
#line 2566
  if (called___2) {
#line 2567
    return;
  }
#line 2568
  called___2 = 1;
#line 2570
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 2571
    return;
  }
#line 2580
  if (! authctxt___0->authenticated) {
#line 2581
    return;
  }
#line 2595
  auth_sock_cleanup_proc(authctxt___0->pw);
#line 2601
  if (! use_privsep) {
#line 2602
    session_destroy_all(& session_pty_cleanup2);
  } else {
#line 2601
    tmp = mm_is_monitor();
#line 2601
    if (tmp) {
#line 2602
      session_destroy_all(& session_pty_cleanup2);
    }
  }
#line 2603
  return;
}
}
#line 1 "auth-chall.o"
#line 41 "auth-chall.c"
KbdintDevice *devices[1] ;
#line 42 "auth-chall.c"
static KbdintDevice *device  ;
#line 45 "auth-chall.c"
char *get_challenge(Authctxt *authctxt___0 ) 
{ char *challenge ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int tmp ;

  {
#line 57
  device = devices[0];
#line 58
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 59
    return ((char *)((void *)0));
  }
#line 60
  authctxt___0->kbdintctxt = (*(device->init_ctx))(authctxt___0);
#line 60
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 61
    return ((char *)((void *)0));
  }
#line 62
  tmp = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                           & prompts, & echo_on);
#line 62
  if (tmp) {
#line 64
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 65
    authctxt___0->kbdintctxt = (void *)0;
#line 66
    return ((char *)((void *)0));
  }
#line 68
  if (numprompts < 1U) {
#line 69
    fatal("get_challenge: numprompts < 1");
  }
#line 70
  challenge = xstrdup((char const   *)*(prompts + 0));
#line 71
  i = 0U;
#line 71
  while (i < numprompts) {
#line 72
    xfree((void *)*(prompts + i));
#line 71
    i ++;
  }
#line 73
  xfree((void *)prompts);
#line 74
  xfree((void *)name);
#line 75
  xfree((void *)echo_on);
#line 76
  xfree((void *)info);
#line 78
  return (challenge);
}
}
#line 80 "auth-chall.c"
int verify_response(Authctxt *authctxt___0 , char const   *response ) 
{ char *resp[1] ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int authenticated ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 85
  authenticated = 0;
#line 87
  if ((unsigned int )device == (unsigned int )((void *)0)) {
#line 88
    return (0);
  }
#line 89
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 90
    return (0);
  }
#line 91
  resp[0] = (char *)response;
#line 92
  tmp = (*(device->respond))(authctxt___0->kbdintctxt, 1U, resp);
#line 92
  switch (tmp) {
  case 0: 
#line 94
  authenticated = 1;
#line 95
  break;
  case 1: 
#line 97
  tmp___0 = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                               & prompts, & echo_on);
#line 97
  if (tmp___0 != 0) {
#line 99
    break;
  }
#line 100
  if (numprompts == 0U) {
#line 100
    tmp___1 = (*(device->respond))(authctxt___0->kbdintctxt, 0U, resp);
#line 100
    if (tmp___1 == 0) {
#line 102
      authenticated = 1;
    }
  }
#line 104
  i = 0U;
#line 104
  while (i < numprompts) {
#line 105
    xfree((void *)*(prompts + i));
#line 104
    i ++;
  }
#line 106
  xfree((void *)prompts);
#line 107
  xfree((void *)name);
#line 108
  xfree((void *)echo_on);
#line 109
  xfree((void *)info);
#line 110
  break;
  }
#line 112
  (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 113
  authctxt___0->kbdintctxt = (void *)0;
#line 114
  return (authenticated);
}
}
#line 116 "auth-chall.c"
void abandon_challenge_response(Authctxt *authctxt___0 ) 
{ 

  {
#line 119
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 120
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
#line 121
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 123
  return;
}
}
#line 1 "auth2-chall.o"
#line 152 "auth.h"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) ;
#line 49 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) ;
#line 50
static int send_userauth_info_request(Authctxt *authctxt___0 ) ;
#line 51
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) ;
#line 64 "auth2-chall.c"
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
#line 102 "auth2-chall.c"
static KbdintAuthctxt *kbdint_alloc(char const   *devs ) 
{ KbdintAuthctxt *kbdintctxt ;
  Buffer b ;
  int i ;
  void *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 114
  tmp = xmalloc(sizeof(KbdintAuthctxt ));
#line 114
  kbdintctxt = (KbdintAuthctxt *)tmp;
#line 115
  if (0) {
#line 115
    __s1_len = strlen(devs);
#line 115
    __s2_len = strlen("");
#line 115
    if (! ((unsigned int )((void const   *)(devs + 1)) - (unsigned int )((void const   *)devs) == 1U)) {
      goto _L___0;
    } else {
#line 115
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 115
        if (! ((unsigned int )((void const   *)("" + 1)) - (unsigned int )((void const   *)"") == 1U)) {
#line 115
          tmp___12 = 1;
        } else {
#line 115
          if (__s2_len >= 4U) {
#line 115
            tmp___12 = 1;
          } else {
#line 115
            tmp___12 = 0;
          }
        }
      } else {
#line 115
        tmp___12 = 0;
      }
    }
#line 115
    if (tmp___12) {
#line 115
      tmp___8 = __builtin_strcmp(devs, "");
    } else {
#line 115
      tmp___11 = __builtin_strcmp(devs, "");
#line 115
      tmp___8 = tmp___11;
    }
  } else {
#line 115
    tmp___11 = __builtin_strcmp(devs, "");
#line 115
    tmp___8 = tmp___11;
  }
#line 115
  if (tmp___8 == 0) {
#line 116
    buffer_init(& b);
#line 117
    i = 0;
#line 117
    while (devices[i]) {
#line 118
      tmp___0 = buffer_len(& b);
#line 118
      if (tmp___0 > 0U) {
#line 119
        buffer_append(& b, (void const   *)",", 1U);
      }
#line 120
      tmp___1 = strlen((devices[i])->name);
#line 120
      buffer_append(& b, (void const   *)(devices[i])->name, tmp___1);
#line 117
      i ++;
    }
#line 123
    buffer_append(& b, (void const   *)"\000", 1U);
#line 124
    tmp___2 = buffer_ptr(& b);
#line 124
    kbdintctxt->devices = xstrdup((char const   *)tmp___2);
#line 125
    buffer_free(& b);
  } else {
#line 127
    kbdintctxt->devices = xstrdup(devs);
  }
#line 129
  debug("kbdint_alloc: devices \'%s\'", kbdintctxt->devices);
#line 130
  kbdintctxt->ctxt = (void *)0;
#line 131
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 132
  kbdintctxt->nreq = 0U;
#line 134
  return (kbdintctxt);
}
}
#line 136 "auth2-chall.c"
static void kbdint_reset_device(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 139
  if (kbdintctxt->ctxt) {
#line 140
    (*((kbdintctxt->device)->free_ctx))(kbdintctxt->ctxt);
#line 141
    kbdintctxt->ctxt = (void *)0;
  }
#line 143
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 144
  return;
}
}
#line 145 "auth2-chall.c"
static void kbdint_free(KbdintAuthctxt *kbdintctxt ) 
{ 

  {
#line 148
  if (kbdintctxt->device) {
#line 149
    kbdint_reset_device(kbdintctxt);
  }
#line 150
  if (kbdintctxt->devices) {
#line 151
    xfree((void *)kbdintctxt->devices);
#line 152
    kbdintctxt->devices = (char *)((void *)0);
  }
#line 154
  xfree((void *)kbdintctxt);
#line 155
  return;
}
}
#line 157 "auth2-chall.c"
static int kbdint_next_device(KbdintAuthctxt *kbdintctxt ) 
{ size_t len ;
  char *t ;
  int i ;
  unsigned int tmp___64 ;
  int tmp___78 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___84 ;
  int tmp___87 ;
  int tmp___88 ;
  char const   *tmp___92 ;
  int tmp___93 ;

  {
#line 164
  if (kbdintctxt->device) {
#line 165
    kbdint_reset_device(kbdintctxt);
  }
#line 166
  while (1) {
#line 168
    if (kbdintctxt->devices) {
#line 168
      tmp___64 = __builtin_strcspn((char const   *)kbdintctxt->devices, ",");
#line 168
      len = tmp___64;
    } else {
#line 168
      len = 0U;
    }
#line 170
    if (len == 0U) {
#line 171
      break;
    }
#line 172
    i = 0;
#line 172
    while (devices[i]) {
#line 173
      if (0) {
#line 173
        if (0) {
#line 173
          __s1_len___0 = strlen((char const   *)kbdintctxt->devices);
#line 173
          __s2_len___0 = strlen((devices[i])->name);
#line 173
          if (! ((unsigned int )((void const   *)(kbdintctxt->devices + 1)) - (unsigned int )((void const   *)kbdintctxt->devices) == 1U)) {
            goto _L___2;
          } else {
#line 173
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 173
              if (! ((unsigned int )((void const   *)((devices[i])->name + 1)) - (unsigned int )((void const   *)(devices[i])->name) == 1U)) {
#line 173
                tmp___88 = 1;
              } else {
#line 173
                if (__s2_len___0 >= 4U) {
#line 173
                  tmp___88 = 1;
                } else {
#line 173
                  tmp___88 = 0;
                }
              }
            } else {
#line 173
              tmp___88 = 0;
            }
          }
#line 173
          if (tmp___88) {
#line 173
            tmp___84 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
          } else {
#line 173
            tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 173
            tmp___84 = tmp___87;
          }
        } else {
#line 173
          tmp___87 = __builtin_strcmp((char const   *)kbdintctxt->devices, (devices[i])->name);
#line 173
          tmp___84 = tmp___87;
        }
#line 173
        tmp___78 = tmp___84;
      } else {
#line 173
        tmp___78 = strncmp((char const   *)kbdintctxt->devices, (devices[i])->name,
                           len);
      }
#line 173
      if (tmp___78 == 0) {
#line 174
        kbdintctxt->device = devices[i];
      }
#line 172
      i ++;
    }
#line 175
    t = kbdintctxt->devices;
#line 176
    if (*(t + len)) {
#line 176
      kbdintctxt->devices = xstrdup((char const   *)((t + len) + 1));
    } else {
#line 176
      kbdintctxt->devices = (char *)((void *)0);
    }
#line 177
    xfree((void *)t);
#line 178
    if (kbdintctxt->devices) {
#line 178
      tmp___92 = (char const   *)kbdintctxt->devices;
    } else {
#line 178
      tmp___92 = "<empty>";
    }
#line 178
    debug2("kbdint_next_device: devices %s", tmp___92);
#line 166
    if (kbdintctxt->devices) {
#line 166
      if (! (! kbdintctxt->device)) {
#line 166
        break;
      }
    } else {
#line 166
      break;
    }
  }
#line 182
  if (kbdintctxt->device) {
#line 182
    tmp___93 = 1;
  } else {
#line 182
    tmp___93 = 0;
  }
#line 182
  return (tmp___93);
}
}
#line 189 "auth2-chall.c"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  KbdintAuthctxt *tmp___1 ;
  int tmp___2 ;

  {
#line 192
  if (devs) {
#line 192
    tmp = (char const   *)devs;
  } else {
#line 192
    tmp = "<no devs>";
  }
#line 192
  if (authctxt___0->user) {
#line 192
    tmp___0 = (char const   *)authctxt___0->user;
  } else {
#line 192
    tmp___0 = "<nouser>";
  }
#line 192
  debug("auth2_challenge: user=%s devs=%s", tmp___0, tmp);
#line 196
  if ((unsigned int )authctxt___0->user == (unsigned int )((void *)0)) {
#line 197
    return (0);
  } else {
#line 196
    if (! devs) {
#line 197
      return (0);
    }
  }
#line 198
  if ((unsigned int )authctxt___0->kbdintctxt == (unsigned int )((void *)0)) {
#line 199
    tmp___1 = kbdint_alloc((char const   *)devs);
#line 199
    authctxt___0->kbdintctxt = (void *)tmp___1;
  }
#line 200
  tmp___2 = auth2_challenge_start(authctxt___0);
#line 200
  return (tmp___2);
}
}
#line 204 "auth2-chall.c"
void auth2_challenge_stop(Authctxt *authctxt___0 ) 
{ 

  {
#line 208
  dispatch_set(61, (dispatch_fn *)((void *)0));
#line 209
  if ((unsigned int )authctxt___0->kbdintctxt != (unsigned int )((void *)0)) {
#line 210
    kbdint_free((KbdintAuthctxt *)authctxt___0->kbdintctxt);
#line 211
    authctxt___0->kbdintctxt = (void *)0;
  }
#line 213
  return;
}
}
#line 216 "auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 219
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 221
  if (kbdintctxt->devices) {
#line 221
    tmp = (char const   *)kbdintctxt->devices;
  } else {
#line 221
    tmp = "<empty>";
  }
#line 221
  debug2("auth2_challenge_start: devices %s", tmp);
#line 224
  tmp___0 = kbdint_next_device(kbdintctxt);
#line 224
  if (tmp___0 == 0) {
#line 225
    auth2_challenge_stop(authctxt___0);
#line 226
    return (0);
  }
#line 228
  debug("auth2_challenge_start: trying authentication method \'%s\'", (kbdintctxt->device)->name);
#line 231
  kbdintctxt->ctxt = (*((kbdintctxt->device)->init_ctx))(authctxt___0);
#line 231
  if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 232
    auth2_challenge_stop(authctxt___0);
#line 233
    return (0);
  }
#line 235
  tmp___1 = send_userauth_info_request(authctxt___0);
#line 235
  if (tmp___1 == 0) {
#line 236
    auth2_challenge_stop(authctxt___0);
#line 237
    return (0);
  }
#line 239
  dispatch_set(61, & input_userauth_info_response);
#line 242
  authctxt___0->postponed = 1;
#line 243
  return (0);
}
}
#line 246 "auth2-chall.c"
static int send_userauth_info_request(Authctxt *authctxt___0 ) 
{ KbdintAuthctxt *kbdintctxt ;
  char *name ;
  char *instr ;
  char **prompts ;
  u_int i ;
  u_int *echo_on ;
  int tmp ;

  {
#line 253
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 254
  tmp = (*((kbdintctxt->device)->query))(kbdintctxt->ctxt, & name, & instr, & kbdintctxt->nreq,
                                         & prompts, & echo_on);
#line 254
  if (tmp) {
#line 256
    return (0);
  }
#line 258
  packet_start((unsigned char)60);
#line 259
  packet_put_cstring((char const   *)name);
#line 260
  packet_put_cstring((char const   *)instr);
#line 261
  packet_put_cstring("");
#line 262
  packet_put_int(kbdintctxt->nreq);
#line 263
  i = 0U;
#line 263
  while (i < kbdintctxt->nreq) {
#line 264
    packet_put_cstring((char const   *)*(prompts + i));
#line 265
    packet_put_char((int )*(echo_on + i));
#line 263
    i ++;
  }
#line 267
  packet_send();
#line 268
  packet_write_wait();
#line 270
  i = 0U;
#line 270
  while (i < kbdintctxt->nreq) {
#line 271
    xfree((void *)*(prompts + i));
#line 270
    i ++;
  }
#line 272
  xfree((void *)prompts);
#line 273
  xfree((void *)echo_on);
#line 274
  xfree((void *)name);
#line 275
  xfree((void *)instr);
#line 276
  return (1);
}
}
#line 279 "auth2-chall.c"
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) 
{ Authctxt *authctxt___0 ;
  KbdintAuthctxt *kbdintctxt ;
  int authenticated ;
  int res ;
  int len ;
  u_int i ;
  u_int nresp ;
  char **response ;
  char *method ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;

  {
#line 282
  authctxt___0 = (Authctxt *)ctxt;
#line 284
  authenticated = 0;
#line 286
  response = (char **)((void *)0);
#line 288
  if ((unsigned int )authctxt___0 == (unsigned int )((void *)0)) {
#line 289
    fatal("input_userauth_info_response: no authctxt");
  }
#line 290
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 291
  if ((unsigned int )kbdintctxt == (unsigned int )((void *)0)) {
#line 292
    fatal("input_userauth_info_response: no kbdintctxt");
  } else {
#line 291
    if ((unsigned int )kbdintctxt->ctxt == (unsigned int )((void *)0)) {
#line 292
      fatal("input_userauth_info_response: no kbdintctxt");
    }
  }
#line 293
  if ((unsigned int )kbdintctxt->device == (unsigned int )((void *)0)) {
#line 294
    fatal("input_userauth_info_response: no device");
  }
#line 296
  authctxt___0->postponed = 0;
#line 297
  nresp = packet_get_int();
#line 298
  if (nresp != kbdintctxt->nreq) {
#line 299
    fatal("input_userauth_info_response: wrong number of replies");
  }
#line 300
  if (nresp > 100U) {
#line 301
    fatal("input_userauth_info_response: too many replies");
  }
#line 302
  if (nresp > 0U) {
#line 303
    tmp = xcalloc(nresp, sizeof(char *));
#line 303
    response = (char **)tmp;
#line 304
    i = 0U;
#line 304
    while (i < nresp) {
#line 305
      tmp___0 = packet_get_string((u_int *)((void *)0));
#line 305
      *(response + i) = (char *)tmp___0;
#line 304
      i ++;
    }
  }
#line 307
  while (1) {
#line 307
    tmp___1 = packet_remaining();
#line 307
    _len = tmp___1;
#line 307
    if (_len > 0) {
#line 307
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-chall.c",
            307);
#line 307
      packet_disconnect("Packet integrity error.");
    }
#line 307
    break;
  }
#line 309
  res = (*((kbdintctxt->device)->respond))(kbdintctxt->ctxt, nresp, response);
#line 311
  i = 0U;
#line 311
  while (i < nresp) {
#line 312
    tmp___2 = strlen((char const   *)*(response + i));
#line 312
    memset((void *)*(response + i), 'r', tmp___2);
#line 313
    xfree((void *)*(response + i));
#line 311
    i ++;
  }
#line 315
  if (response) {
#line 316
    xfree((void *)response);
  }
#line 318
  switch (res) {
  case 0: 
#line 321
  if (authctxt___0->valid) {
#line 321
    authenticated = 1;
  } else {
#line 321
    authenticated = 0;
  }
#line 322
  break;
  case 1: 
#line 325
  tmp___3 = send_userauth_info_request(authctxt___0);
#line 325
  if (tmp___3 == 1) {
#line 326
    authctxt___0->postponed = 1;
  }
#line 327
  break;
  default: ;
#line 330
  break;
  }
#line 333
  tmp___4 = strlen("keyboard-interactive");
#line 333
  tmp___5 = strlen((kbdintctxt->device)->name);
#line 333
  len = (int )((tmp___4 + 2U) + tmp___5);
#line 335
  tmp___6 = xmalloc((unsigned int )len);
#line 335
  method = (char *)tmp___6;
#line 336
  snprintf((char * __restrict  )method, (unsigned int )len, (char const   * __restrict  )"keyboard-interactive/%s",
           (kbdintctxt->device)->name);
#line 339
  if (! authctxt___0->postponed) {
#line 340
    if (authenticated) {
#line 341
      auth2_challenge_stop(authctxt___0);
    } else {
#line 345
      auth2_challenge_start(authctxt___0);
    }
  }
#line 348
  userauth_finish(authctxt___0, authenticated, method);
#line 349
  xfree((void *)method);
#line 350
  return;
}
}
#line 352 "auth2-chall.c"
void privsep_challenge_enable(void) 
{ 

  {
#line 378
  return;
}
}
#line 1 "groupaccess.o"
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 40 "groupaccess.c"
static int ngroups  ;
#line 41 "groupaccess.c"
static char **groups_byname  ;
#line 47 "groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ gid_t *groups_bygid ;
  int i ;
  int j ;
  struct group *gr ;
  long tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 54
  if (ngroups > 0) {
#line 55
    ga_free();
  }
#line 57
  ngroups = 65536;
#line 59
  tmp___2 = sysconf(3);
#line 59
  if (65536L > tmp___2) {
#line 59
    ngroups = 65536;
  } else {
#line 59
    tmp___1 = sysconf(3);
#line 59
    ngroups = (int )tmp___1;
  }
#line 62
  tmp___3 = xcalloc((unsigned int )ngroups, sizeof(*groups_bygid));
#line 62
  groups_bygid = (gid_t *)tmp___3;
#line 63
  tmp___4 = xcalloc((unsigned int )ngroups, sizeof(*groups_byname));
#line 63
  groups_byname = (char **)tmp___4;
#line 65
  tmp___5 = getgrouplist(user, base, groups_bygid, & ngroups);
#line 65
  if (tmp___5 == -1) {
#line 66
    logit("getgrouplist: groups list too small");
  }
#line 67
  i = 0;
#line 67
  j = 0;
#line 67
  while (i < ngroups) {
#line 68
    gr = getgrgid(*(groups_bygid + i));
#line 68
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 69
      tmp___6 = j;
#line 69
      j ++;
#line 69
      *(groups_byname + tmp___6) = xstrdup((char const   *)gr->gr_name);
    }
#line 67
    i ++;
  }
#line 70
  xfree((void *)groups_bygid);
#line 71
  ngroups = j;
#line 71
  return (ngroups);
}
}
#line 78 "groupaccess.c"
int ga_match(char * const  *groups , int n___0 ) 
{ int i ;
  int j ;
  int tmp ;

  {
#line 83
  i = 0;
#line 83
  while (i < ngroups) {
#line 84
    j = 0;
#line 84
    while (j < n___0) {
#line 85
      tmp = match_pattern((char const   *)*(groups_byname + i), (char const   *)*(groups + j));
#line 85
      if (tmp) {
#line 86
        return (1);
      }
#line 84
      j ++;
    }
#line 83
    i ++;
  }
#line 87
  return (0);
}
}
#line 93 "groupaccess.c"
void ga_free(void) 
{ int i ;

  {
#line 98
  if (ngroups > 0) {
#line 99
    i = 0;
#line 99
    while (i < ngroups) {
#line 100
      xfree((void *)*(groups_byname + i));
#line 99
      i ++;
    }
#line 101
    ngroups = 0;
#line 102
    xfree((void *)groups_byname);
  }
#line 104
  return;
}
}
#line 1 "auth-skey.o"
#line 1 "auth-bsdauth.o"
#line 1 "auth2-hostbased.o"
#line 118 "auth.h"
int hostbased_key_allowed(struct passwd *pw___0 , char const   *cuser , char *chost ,
                          Key *key ) ;
#line 49 "monitor_wrap.h"
int mm_hostbased_key_allowed(struct passwd *pw___0 , char *user , char *host , Key *key ) ;
#line 51
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) ;
#line 56 "auth2-hostbased.c"
static int userauth_hostbased(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___6 ;
  int tmp___13 ;
  u_int tmp___14 ;
  void *tmp___15 ;
  u_int tmp___16 ;
  void *tmp___17 ;

  {
#line 60
  key = (Key *)((void *)0);
#line 65
  authenticated = 0;
#line 67
  if (! authctxt___0->valid) {
#line 68
    debug2("userauth_hostbased: disabled because of invalid user");
#line 69
    return (0);
  }
#line 71
  tmp = packet_get_string(& alen);
#line 71
  pkalg = (char *)tmp;
#line 72
  tmp___0 = packet_get_string(& blen);
#line 72
  pkblob = (u_char *)tmp___0;
#line 73
  tmp___1 = packet_get_string((u_int *)((void *)0));
#line 73
  chost = (char *)tmp___1;
#line 74
  tmp___2 = packet_get_string((u_int *)((void *)0));
#line 74
  cuser = (char *)tmp___2;
#line 75
  tmp___3 = packet_get_string(& slen);
#line 75
  sig = (u_char *)tmp___3;
#line 77
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
#line 86
  pktype = key_type_from_name(pkalg);
#line 87
  if (pktype == 3) {
#line 89
    logit("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 93
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 94
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 95
    error("userauth_hostbased: cannot decode key: %s", pkalg);
    goto done;
  }
#line 98
  if (key->type != pktype) {
#line 99
    error("userauth_hostbased: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 103
  if (datafellows & 65536) {
#line 103
    service = (char *)"ssh-userauth";
  } else {
#line 103
    service = authctxt___0->service;
  }
#line 105
  buffer_init(& b);
#line 106
  buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
#line 108
  buffer_put_char(& b, 50);
#line 109
  buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 110
  buffer_put_cstring(& b, (char const   *)service);
#line 111
  buffer_put_cstring(& b, "hostbased");
#line 112
  buffer_put_string(& b, (void const   *)pkalg, alen);
#line 113
  buffer_put_string(& b, (void const   *)pkblob, blen);
#line 114
  buffer_put_cstring(& b, (char const   *)chost);
#line 115
  buffer_put_cstring(& b, (char const   *)cuser);
#line 120
  authenticated = 0;
#line 121
  if (use_privsep) {
#line 121
    tmp___6 = mm_hostbased_key_allowed(authctxt___0->pw, cuser, chost, key);
  } else {
#line 121
    tmp___6 = hostbased_key_allowed(authctxt___0->pw, (char const   *)cuser, chost,
                                    key);
  }
#line 121
  if (tmp___6) {
#line 121
    if (use_privsep) {
#line 121
      tmp___14 = buffer_len(& b);
#line 121
      tmp___15 = buffer_ptr(& b);
#line 121
      tmp___13 = mm_key_verify(key, sig, slen, (u_char *)tmp___15, tmp___14);
    } else {
#line 121
      tmp___16 = buffer_len(& b);
#line 121
      tmp___17 = buffer_ptr(& b);
#line 121
      tmp___13 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___17,
                            tmp___16);
    }
#line 121
    if (tmp___13 == 1) {
#line 124
      authenticated = 1;
    }
  }
#line 126
  buffer_free(& b);
  done: 
#line 128
  debug2("userauth_hostbased: authenticated %d", authenticated);
#line 129
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 130
    key_free(key);
  }
#line 131
  xfree((void *)pkalg);
#line 132
  xfree((void *)pkblob);
#line 133
  xfree((void *)cuser);
#line 134
  xfree((void *)chost);
#line 135
  xfree((void *)sig);
#line 136
  return (authenticated);
}
}
#line 140 "auth2-hostbased.c"
int hostbased_key_allowed(struct passwd *pw___0 , char const   *cuser , char *chost ,
                          Key *key ) 
{ char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  HostStatus host_status ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 148
  resolvedname = get_canonical_hostname(options.use_dns);
#line 149
  ipaddr = get_remote_ipaddr();
#line 151
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
#line 154
  if (options.hostbased_uses_name_from_packet_only) {
#line 155
    tmp = auth_rhosts2(pw___0, cuser, (char const   *)chost, (char const   *)chost);
#line 155
    if (tmp == 0) {
#line 156
      return (0);
    }
#line 157
    lookup = (char const   *)chost;
  } else {
#line 159
    tmp___0 = strlen((char const   *)chost);
#line 159
    len = (int )tmp___0;
#line 159
    if (len > 0) {
#line 159
      if ((int )*(chost + (len - 1)) == 46) {
#line 160
        debug2("stripping trailing dot from chost %s", chost);
#line 161
        *(chost + (len - 1)) = (char )'\000';
      }
    }
#line 163
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
#line 163
    if (tmp___1 != 0) {
#line 164
      logit("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
            chost, ipaddr, resolvedname);
    }
#line 167
    tmp___2 = auth_rhosts2(pw___0, cuser, resolvedname, ipaddr);
#line 167
    if (tmp___2 == 0) {
#line 168
      return (0);
    }
#line 169
    lookup = resolvedname;
  }
#line 171
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
#line 173
  if (options.ignore_user_known_hosts) {
#line 173
    tmp___3 = (char const   *)((void *)0);
  } else {
#line 173
    tmp___3 = "~/.ssh/known_hosts";
  }
#line 173
  host_status = check_key_in_hostfiles(pw___0, key, lookup, "/usr/local/etc/ssh_known_hosts",
                                       tmp___3);
#line 178
  if ((int )host_status == 1) {
#line 179
    if (options.ignore_user_known_hosts) {
#line 179
      tmp___4 = (char const   *)((void *)0);
    } else {
#line 179
      tmp___4 = "~/.ssh/known_hosts2";
    }
#line 179
    host_status = check_key_in_hostfiles(pw___0, key, lookup, "/usr/local/etc/ssh_known_hosts2",
                                         tmp___4);
  }
#line 184
  return ((int )host_status == 0);
}
}
#line 187 "auth2-hostbased.c"
Authmethod method_hostbased  =    {(char *)"hostbased", & userauth_hostbased, & options.hostbased_authentication};
#line 1 "auth2-kbdint.o"
#line 44 "auth2-kbdint.c"
static int userauth_kbdint(Authctxt *authctxt___0 ) 
{ int authenticated ;
  char *lang ;
  char *devs ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;

  {
#line 47
  authenticated = 0;
#line 50
  tmp = packet_get_string((u_int *)((void *)0));
#line 50
  lang = (char *)tmp;
#line 51
  tmp___0 = packet_get_string((u_int *)((void *)0));
#line 51
  devs = (char *)tmp___0;
#line 52
  while (1) {
#line 52
    tmp___1 = packet_remaining();
#line 52
    _len = tmp___1;
#line 52
    if (_len > 0) {
#line 52
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-kbdint.c",
            52);
#line 52
      packet_disconnect("Packet integrity error.");
    }
#line 52
    break;
  }
#line 54
  debug("keyboard-interactive devs %s", devs);
#line 56
  if (options.challenge_response_authentication) {
#line 57
    authenticated = auth2_challenge(authctxt___0, devs);
  }
#line 59
  xfree((void *)devs);
#line 60
  xfree((void *)lang);
#line 65
  return (authenticated);
}
}
#line 68 "auth2-kbdint.c"
Authmethod method_kbdint  =    {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication};
#line 1 "auth2-none.o"
#line 218 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 145 "auth.h"
void userauth_send_banner(char const   *msg ) ;
#line 148
char *auth2_read_banner(void) ;
#line 45 "monitor_wrap.h"
char *mm_auth2_read_banner(void) ;
#line 57 "auth2-none.c"
static int none_enabled  =    1;
#line 59 "auth2-none.c"
char *auth2_read_banner(void) 
{ struct stat st ;
  char *banner ;
  size_t len ;
  size_t n___0 ;
  int fd ;
  int tmp ;
  void *tmp___0 ;

  {
#line 63
  banner = (char *)((void *)0);
#line 67
  fd = open((char const   *)options.banner, 0);
#line 67
  if (fd == -1) {
#line 68
    return ((char *)((void *)0));
  }
#line 69
  tmp = fstat(fd, & st);
#line 69
  if (tmp == -1) {
#line 70
    close(fd);
#line 71
    return ((char *)((void *)0));
  }
#line 73
  if (st.st_size > 1048576LL) {
#line 74
    close(fd);
#line 75
    return ((char *)((void *)0));
  }
#line 78
  len = (unsigned int )st.st_size;
#line 79
  tmp___0 = xmalloc(len + 1U);
#line 79
  banner = (char *)tmp___0;
#line 80
  n___0 = atomicio(& read, fd, (void *)banner, len);
#line 81
  close(fd);
#line 83
  if (n___0 != len) {
#line 84
    xfree((void *)banner);
#line 85
    return ((char *)((void *)0));
  }
#line 87
  *(banner + n___0) = (char )'\000';
#line 89
  return (banner);
}
}
#line 92 "auth2-none.c"
void userauth_send_banner(char const   *msg ) 
{ 

  {
#line 95
  if (datafellows & 128) {
#line 96
    return;
  }
#line 98
  packet_start((unsigned char)53);
#line 99
  packet_put_cstring(msg);
#line 100
  packet_put_cstring("");
#line 101
  packet_send();
#line 102
  debug("%s: sent", "userauth_send_banner");
#line 103
  return;
}
}
#line 105 "auth2-none.c"
static void userauth_banner(void) 
{ char *banner ;
  int tmp ;

  {
#line 108
  banner = (char *)((void *)0);
#line 110
  if ((unsigned int )options.banner == (unsigned int )((void *)0)) {
#line 113
    return;
  } else {
#line 110
    tmp = strcasecmp((char const   *)options.banner, "none");
#line 110
    if (tmp == 0) {
#line 113
      return;
    } else {
#line 110
      if ((datafellows & 128) != 0) {
#line 113
        return;
      }
    }
  }
#line 115
  if (use_privsep) {
#line 115
    banner = mm_auth2_read_banner();
  } else {
#line 115
    banner = auth2_read_banner();
  }
#line 115
  if ((unsigned int )banner == (unsigned int )((void *)0)) {
    goto done;
  }
#line 117
  userauth_send_banner((char const   *)banner);
  done: 
#line 120
  if (banner) {
#line 121
    xfree((void *)banner);
  }
#line 122
  return;
}
}
#line 124 "auth2-none.c"
static int userauth_none(Authctxt *authctxt___0 ) 
{ int _len ;
  int tmp ;
  int tmp___2 ;

  {
#line 127
  none_enabled = 0;
#line 128
  while (1) {
#line 128
    tmp = packet_remaining();
#line 128
    _len = tmp;
#line 128
    if (_len > 0) {
#line 128
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-none.c",
            128);
#line 128
      packet_disconnect("Packet integrity error.");
    }
#line 128
    break;
  }
#line 129
  userauth_banner();
#line 134
  if (options.password_authentication) {
#line 135
    if (use_privsep) {
#line 135
      tmp___2 = mm_auth_password(authctxt___0, (char *)"");
    } else {
#line 135
      tmp___2 = auth_password(authctxt___0, "");
    }
#line 135
    return (tmp___2);
  }
#line 136
  return (0);
}
}
#line 139 "auth2-none.c"
Authmethod method_none  =    {(char *)"none", & userauth_none, & none_enabled};
#line 1 "auth2-passwd.o"
#line 49 "auth2-passwd.c"
static int userauth_passwd(Authctxt *authctxt___0 ) 
{ char *password ;
  char *newpass ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int newlen ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___5 ;

  {
#line 53
  authenticated = 0;
#line 57
  tmp = packet_get_char();
#line 57
  change = (int )tmp;
#line 58
  tmp___0 = packet_get_string(& len);
#line 58
  password = (char *)tmp___0;
#line 59
  if (change) {
#line 61
    tmp___1 = packet_get_string(& newlen);
#line 61
    newpass = (char *)tmp___1;
#line 62
    memset((void *)newpass, 0, newlen);
#line 63
    xfree((void *)newpass);
  }
#line 65
  while (1) {
#line 65
    tmp___2 = packet_remaining();
#line 65
    _len = tmp___2;
#line 65
    if (_len > 0) {
#line 65
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-passwd.c",
            65);
#line 65
      packet_disconnect("Packet integrity error.");
    }
#line 65
    break;
  }
#line 67
  if (change) {
#line 68
    logit("password change not supported");
  } else {
#line 69
    if (use_privsep) {
#line 69
      tmp___5 = mm_auth_password(authctxt___0, password);
    } else {
#line 69
      tmp___5 = auth_password(authctxt___0, (char const   *)password);
    }
#line 69
    if (tmp___5 == 1) {
#line 70
      authenticated = 1;
    }
  }
#line 75
  memset((void *)password, 0, len);
#line 76
  xfree((void *)password);
#line 77
  return (authenticated);
}
}
#line 80 "auth2-passwd.c"
Authmethod method_passwd  =    {(char *)"password", & userauth_passwd, & options.password_authentication};
#line 1 "auth2-pubkey.o"
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 119 "auth.h"
int user_key_allowed(struct passwd *pw___0 , Key *key ) ;
#line 48 "monitor_wrap.h"
int mm_user_key_allowed(struct passwd *pw___0 , Key *key ) ;
#line 61 "auth2-pubkey.c"
static int userauth_pubkey(Authctxt *authctxt___0 ) 
{ Buffer b ;
  Key *key ;
  char *pkalg ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int _len ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___9 ;
  int tmp___16 ;
  u_int tmp___17 ;
  void *tmp___18 ;
  u_int tmp___19 ;
  void *tmp___20 ;
  int _len___0 ;
  int tmp___21 ;
  int tmp___24 ;

  {
#line 65
  key = (Key *)((void *)0);
#line 70
  authenticated = 0;
#line 72
  if (! authctxt___0->valid) {
#line 73
    debug2("userauth_pubkey: disabled because of invalid user");
#line 74
    return (0);
  }
#line 76
  tmp = packet_get_char();
#line 76
  have_sig = (int )tmp;
#line 77
  if (datafellows & 32) {
#line 78
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
#line 80
    tmp___0 = packet_get_string(& blen);
#line 80
    pkblob = (u_char *)tmp___0;
#line 81
    buffer_init(& b);
#line 82
    buffer_append(& b, (void const   *)pkblob, blen);
#line 84
    tmp___1 = buffer_get_string(& b, & alen);
#line 84
    pkalg = (char *)tmp___1;
#line 85
    buffer_free(& b);
  } else {
#line 87
    tmp___2 = packet_get_string(& alen);
#line 87
    pkalg = (char *)tmp___2;
#line 88
    tmp___3 = packet_get_string(& blen);
#line 88
    pkblob = (u_char *)tmp___3;
  }
#line 90
  pktype = key_type_from_name(pkalg);
#line 91
  if (pktype == 3) {
#line 93
    logit("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
    goto done;
  }
#line 97
  key = key_from_blob((u_char const   *)pkblob, blen);
#line 98
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 99
    error("userauth_pubkey: cannot decode key: %s", pkalg);
    goto done;
  }
#line 102
  if (key->type != pktype) {
#line 103
    error("userauth_pubkey: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    goto done;
  }
#line 107
  if (have_sig) {
#line 108
    tmp___4 = packet_get_string(& slen);
#line 108
    sig = (u_char *)tmp___4;
#line 109
    while (1) {
#line 109
      tmp___5 = packet_remaining();
#line 109
      _len = tmp___5;
#line 109
      if (_len > 0) {
#line 109
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "auth2-pubkey.c",
              109);
#line 109
        packet_disconnect("Packet integrity error.");
      }
#line 109
      break;
    }
#line 110
    buffer_init(& b);
#line 111
    if (datafellows & 16) {
#line 112
      buffer_append(& b, (void const   *)session_id2, session_id2_len);
    } else {
#line 114
      buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
    }
#line 117
    buffer_put_char(& b, 50);
#line 118
    buffer_put_cstring(& b, (char const   *)authctxt___0->user);
#line 119
    if (datafellows & 2) {
#line 119
      tmp___6 = "ssh-userauth";
    } else {
#line 119
      tmp___6 = (char const   *)authctxt___0->service;
    }
#line 119
    buffer_put_cstring(& b, tmp___6);
#line 123
    if (datafellows & 32) {
#line 124
      buffer_put_char(& b, have_sig);
    } else {
#line 126
      buffer_put_cstring(& b, "publickey");
#line 127
      buffer_put_char(& b, have_sig);
#line 128
      buffer_put_cstring(& b, (char const   *)pkalg);
    }
#line 130
    buffer_put_string(& b, (void const   *)pkblob, blen);
#line 135
    authenticated = 0;
#line 136
    if (use_privsep) {
#line 136
      tmp___9 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 136
      tmp___9 = user_key_allowed(authctxt___0->pw, key);
    }
#line 136
    if (tmp___9) {
#line 136
      if (use_privsep) {
#line 136
        tmp___17 = buffer_len(& b);
#line 136
        tmp___18 = buffer_ptr(& b);
#line 136
        tmp___16 = mm_key_verify(key, sig, slen, (u_char *)tmp___18, tmp___17);
      } else {
#line 136
        tmp___19 = buffer_len(& b);
#line 136
        tmp___20 = buffer_ptr(& b);
#line 136
        tmp___16 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___20,
                              tmp___19);
      }
#line 136
      if (tmp___16 == 1) {
#line 139
        authenticated = 1;
      }
    }
#line 140
    buffer_free(& b);
#line 141
    xfree((void *)sig);
  } else {
#line 143
    debug("test whether pkalg/pkblob are acceptable");
#line 144
    while (1) {
#line 144
      tmp___21 = packet_remaining();
#line 144
      _len___0 = tmp___21;
#line 144
      if (_len___0 > 0) {
#line 144
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "auth2-pubkey.c",
              144);
#line 144
        packet_disconnect("Packet integrity error.");
      }
#line 144
      break;
    }
#line 154
    if (use_privsep) {
#line 154
      tmp___24 = mm_user_key_allowed(authctxt___0->pw, key);
    } else {
#line 154
      tmp___24 = user_key_allowed(authctxt___0->pw, key);
    }
#line 154
    if (tmp___24) {
#line 155
      packet_start((unsigned char)60);
#line 156
      packet_put_string((void const   *)pkalg, alen);
#line 157
      packet_put_string((void const   *)pkblob, blen);
#line 158
      packet_send();
#line 159
      packet_write_wait();
#line 160
      authctxt___0->postponed = 1;
    }
  }
#line 163
  if (authenticated != 1) {
#line 164
    auth_clear_options();
  }
  done: 
#line 166
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
#line 167
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 168
    key_free(key);
  }
#line 169
  xfree((void *)pkalg);
#line 170
  xfree((void *)pkblob);
#line 175
  return (authenticated);
}
}
#line 179 "auth2-pubkey.c"
static int user_key_allowed2(struct passwd *pw___0 , Key *key , char *file___0 ) 
{ char line[8192] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  char *fp ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *key_options ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 183
  found_key = 0;
#line 185
  linenum = (u_long )0;
#line 191
  temporarily_use_uid(pw___0);
#line 193
  debug("trying public key file %s", file___0);
#line 196
  tmp = stat((char const   * __restrict  )file___0, (struct stat * __restrict  )(& st));
#line 196
  if (tmp < 0) {
#line 198
    restore_uid();
#line 199
    return (0);
  }
#line 202
  f = fopen((char const   * __restrict  )file___0, (char const   * __restrict  )"r");
#line 203
  if (! f) {
#line 205
    restore_uid();
#line 206
    return (0);
  }
#line 208
  if (options.strict_modes) {
#line 208
    tmp___0 = secure_filename(f, (char const   *)file___0, pw___0, line, sizeof(line));
#line 208
    if (tmp___0 != 0) {
#line 210
      fclose(f);
#line 211
      logit("Authentication refused: %s", line);
#line 212
      restore_uid();
#line 213
      return (0);
    }
  }
#line 216
  found_key = 0;
#line 217
  found = key_new(key->type);
#line 219
  while (1) {
#line 219
    tmp___6 = read_keyfile_line(f, (char const   *)file___0, line, sizeof(line), & linenum);
#line 219
    if (! (tmp___6 != -1)) {
#line 219
      break;
    }
#line 220
    key_options = (char *)((void *)0);
#line 223
    cp = line;
#line 223
    while (1) {
#line 223
      if (! ((int )*cp == 32)) {
#line 223
        if (! ((int )*cp == 9)) {
#line 223
          break;
        }
      }
#line 223
      cp ++;
    }
#line 225
    if (! *cp) {
#line 226
      continue;
    } else {
#line 225
      if ((int )*cp == 10) {
#line 226
        continue;
      } else {
#line 225
        if ((int )*cp == 35) {
#line 226
          continue;
        }
      }
    }
#line 228
    tmp___2 = key_read(found, & cp);
#line 228
    if (tmp___2 != 1) {
#line 230
      quoted = 0;
#line 231
      debug2("user_key_allowed: check options: \'%s\'", cp);
#line 232
      key_options = cp;
#line 233
      while (1) {
#line 233
        if (*cp) {
#line 233
          if (! quoted) {
#line 233
            if ((int )*cp != 32) {
#line 233
              if (! ((int )*cp != 9)) {
#line 233
                break;
              }
            } else {
#line 233
              break;
            }
          }
        } else {
#line 233
          break;
        }
#line 234
        if ((int )*cp == 92) {
#line 234
          if ((int )*(cp + 1) == 34) {
#line 235
            cp ++;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 236
          if ((int )*cp == 34) {
#line 237
            quoted = ! quoted;
          }
        }
#line 233
        cp ++;
      }
#line 240
      while (1) {
#line 240
        if (! ((int )*cp == 32)) {
#line 240
          if (! ((int )*cp == 9)) {
#line 240
            break;
          }
        }
#line 240
        cp ++;
      }
#line 242
      tmp___1 = key_read(found, & cp);
#line 242
      if (tmp___1 != 1) {
#line 243
        debug2("user_key_allowed: advance: \'%s\'", cp);
#line 245
        continue;
      }
    }
#line 248
    tmp___4 = key_equal((Key const   *)found, (Key const   *)key);
#line 248
    if (tmp___4) {
#line 248
      tmp___5 = auth_parse_options(pw___0, key_options, file___0, linenum);
#line 248
      if (tmp___5 == 1) {
#line 250
        found_key = 1;
#line 251
        debug("matching key found: file %s, line %lu", file___0, linenum);
#line 253
        fp = key_fingerprint((Key const   *)found, 1, 0);
#line 254
        tmp___3 = key_type((Key const   *)found);
#line 254
        verbose("Found matching %s key: %s", tmp___3, fp);
#line 256
        xfree((void *)fp);
#line 257
        break;
      }
    }
  }
#line 260
  restore_uid();
#line 261
  fclose(f);
#line 262
  key_free(found);
#line 263
  if (! found_key) {
#line 264
    debug2("key not found");
  }
#line 265
  return (found_key);
}
}
#line 269 "auth2-pubkey.c"
int user_key_allowed(struct passwd *pw___0 , Key *key ) 
{ int success ;
  char *file___0 ;

  {
#line 275
  file___0 = authorized_keys_file(pw___0);
#line 276
  success = user_key_allowed2(pw___0, key, file___0);
#line 277
  xfree((void *)file___0);
#line 278
  if (success) {
#line 279
    return (success);
  }
#line 282
  file___0 = authorized_keys_file2(pw___0);
#line 283
  success = user_key_allowed2(pw___0, key, file___0);
#line 284
  xfree((void *)file___0);
#line 285
  return (success);
}
}
#line 288 "auth2-pubkey.c"
Authmethod method_pubkey  =    {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication};
#line 1 "monitor_mm.o"
#line 77 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 49 "monitor_mm.h"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) ;
#line 49
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) ;
#line 49
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) ;
#line 49
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) ;
#line 49
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) ;
#line 49
struct mm_share *mmtree_RB_NEXT(struct mm_share *elm ) ;
#line 49
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) ;
#line 55
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) ;
#line 56
void mm_destroy(struct mm_master *mm ) ;
#line 58
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) ;
#line 60
void *mm_malloc(struct mm_master *mm , size_t size ) ;
#line 61
void *mm_xmalloc(struct mm_master *mm , size_t size ) ;
#line 62
void mm_free(struct mm_master *mm , void *address ) ;
#line 64
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) ;
#line 45 "monitor_mm.c"
static int mm_compare(struct mm_share *a___0 , struct mm_share *b ) 
{ long diff ;

  {
#line 48
  diff = (long )((char *)a___0->address - (char *)b->address);
#line 50
  if (diff == 0L) {
#line 51
    return (0);
  } else {
#line 52
    if (diff < 0L) {
#line 53
      return (-1);
    } else {
#line 55
      return (1);
    }
  }
}
}
#line 58 "monitor_mm.c"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *parent ;
  struct mm_share *gparent ;
  struct mm_share *tmp ;

  {
#line 58
  while (1) {
#line 58
    parent = elm->next.rbe_parent;
#line 58
    if (parent) {
#line 58
      if (! (parent->next.rbe_color == 1)) {
#line 58
        break;
      }
    } else {
#line 58
      break;
    }
#line 58
    gparent = parent->next.rbe_parent;
#line 58
    if ((unsigned int )parent == (unsigned int )gparent->next.rbe_left) {
#line 58
      tmp = gparent->next.rbe_right;
#line 58
      if (tmp) {
#line 58
        if (tmp->next.rbe_color == 1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          while (1) {
#line 58
            parent->next.rbe_color = 0;
#line 58
            gparent->next.rbe_color = 1;
#line 58
            break;
          }
#line 58
          elm = gparent;
#line 58
          continue;
        }
      }
#line 58
      if ((unsigned int )parent->next.rbe_right == (unsigned int )elm) {
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_right;
#line 58
          parent->next.rbe_right = tmp->next.rbe_left;
#line 58
          if (parent->next.rbe_right) {
#line 58
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_left = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent;
#line 58
        parent = elm;
#line 58
        elm = tmp;
      }
#line 58
      while (1) {
#line 58
        parent->next.rbe_color = 0;
#line 58
        gparent->next.rbe_color = 1;
#line 58
        break;
      }
#line 58
      while (1) {
#line 58
        tmp = gparent->next.rbe_left;
#line 58
        gparent->next.rbe_left = tmp->next.rbe_right;
#line 58
        if (gparent->next.rbe_left) {
#line 58
          (tmp->next.rbe_right)->next.rbe_parent = gparent;
        }
#line 58
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 58
        if (tmp->next.rbe_parent) {
#line 58
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 58
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 58
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 58
          head->rbh_root = tmp;
        }
#line 58
        tmp->next.rbe_right = gparent;
#line 58
        gparent->next.rbe_parent = tmp;
#line 58
        if (tmp->next.rbe_parent) {

        }
#line 58
        break;
      }
    } else {
#line 58
      tmp = gparent->next.rbe_left;
#line 58
      if (tmp) {
#line 58
        if (tmp->next.rbe_color == 1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          while (1) {
#line 58
            parent->next.rbe_color = 0;
#line 58
            gparent->next.rbe_color = 1;
#line 58
            break;
          }
#line 58
          elm = gparent;
#line 58
          continue;
        }
      }
#line 58
      if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_left;
#line 58
          parent->next.rbe_left = tmp->next.rbe_right;
#line 58
          if (parent->next.rbe_left) {
#line 58
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_right = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent;
#line 58
        parent = elm;
#line 58
        elm = tmp;
      }
#line 58
      while (1) {
#line 58
        parent->next.rbe_color = 0;
#line 58
        gparent->next.rbe_color = 1;
#line 58
        break;
      }
#line 58
      while (1) {
#line 58
        tmp = gparent->next.rbe_right;
#line 58
        gparent->next.rbe_right = tmp->next.rbe_left;
#line 58
        if (gparent->next.rbe_right) {
#line 58
          (tmp->next.rbe_left)->next.rbe_parent = gparent;
        }
#line 58
        tmp->next.rbe_parent = gparent->next.rbe_parent;
#line 58
        if (tmp->next.rbe_parent) {
#line 58
          if ((unsigned int )gparent == (unsigned int )(gparent->next.rbe_parent)->next.rbe_left) {
#line 58
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 58
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 58
          head->rbh_root = tmp;
        }
#line 58
        tmp->next.rbe_left = gparent;
#line 58
        gparent->next.rbe_parent = tmp;
#line 58
        if (tmp->next.rbe_parent) {

        }
#line 58
        break;
      }
    }
  }
#line 58
  (head->rbh_root)->next.rbe_color = 0;
#line 58
  return;
}
}
#line 58 "monitor_mm.c"
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *oleft ;
  struct mm_share *oright ;

  {
#line 58
  while (1) {
#line 58
    if ((unsigned int )elm == (unsigned int )((void *)0)) {
      goto _L___5;
    } else {
#line 58
      if (elm->next.rbe_color == 0) {
        _L___5: /* CIL Label */ 
#line 58
        if (! ((unsigned int )elm != (unsigned int )head->rbh_root)) {
#line 58
          break;
        }
      } else {
#line 58
        break;
      }
    }
#line 58
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
      tmp = parent->next.rbe_right;
#line 58
      if (tmp->next.rbe_color == 1) {
#line 58
        while (1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          parent->next.rbe_color = 1;
#line 58
          break;
        }
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_right;
#line 58
          parent->next.rbe_right = tmp->next.rbe_left;
#line 58
          if (parent->next.rbe_right) {
#line 58
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_left = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent->next.rbe_right;
      }
#line 58
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___1;
      } else {
#line 58
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___1: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 58
            tmp->next.rbe_color = 1;
#line 58
            elm = parent;
#line 58
            parent = elm->next.rbe_parent;
          } else {
#line 58
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 58
              tmp->next.rbe_color = 1;
#line 58
              elm = parent;
#line 58
              parent = elm->next.rbe_parent;
            } else {
              goto _L___0;
            }
          }
        } else {
          _L___0: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
            goto _L;
          } else {
#line 58
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
              _L: /* CIL Label */ 
#line 58
              oleft = tmp->next.rbe_left;
#line 58
              if (oleft) {
#line 58
                oleft->next.rbe_color = 0;
              }
#line 58
              tmp->next.rbe_color = 1;
#line 58
              while (1) {
#line 58
                oleft = tmp->next.rbe_left;
#line 58
                tmp->next.rbe_left = oleft->next.rbe_right;
#line 58
                if (tmp->next.rbe_left) {
#line 58
                  (oleft->next.rbe_right)->next.rbe_parent = tmp;
                }
#line 58
                oleft->next.rbe_parent = tmp->next.rbe_parent;
#line 58
                if (oleft->next.rbe_parent) {
#line 58
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_left = oleft;
                  } else {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_right = oleft;
                  }
                } else {
#line 58
                  head->rbh_root = oleft;
                }
#line 58
                oleft->next.rbe_right = tmp;
#line 58
                tmp->next.rbe_parent = oleft;
#line 58
                if (oleft->next.rbe_parent) {

                }
#line 58
                break;
              }
#line 58
              tmp = parent->next.rbe_right;
            }
          }
#line 58
          tmp->next.rbe_color = parent->next.rbe_color;
#line 58
          parent->next.rbe_color = 0;
#line 58
          if (tmp->next.rbe_right) {
#line 58
            (tmp->next.rbe_right)->next.rbe_color = 0;
          }
#line 58
          while (1) {
#line 58
            tmp = parent->next.rbe_right;
#line 58
            parent->next.rbe_right = tmp->next.rbe_left;
#line 58
            if (parent->next.rbe_right) {
#line 58
              (tmp->next.rbe_left)->next.rbe_parent = parent;
            }
#line 58
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
            if (tmp->next.rbe_parent) {
#line 58
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 58
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 58
              head->rbh_root = tmp;
            }
#line 58
            tmp->next.rbe_left = parent;
#line 58
            parent->next.rbe_parent = tmp;
#line 58
            if (tmp->next.rbe_parent) {

            }
#line 58
            break;
          }
#line 58
          elm = head->rbh_root;
#line 58
          break;
        }
      }
    } else {
#line 58
      tmp = parent->next.rbe_left;
#line 58
      if (tmp->next.rbe_color == 1) {
#line 58
        while (1) {
#line 58
          tmp->next.rbe_color = 0;
#line 58
          parent->next.rbe_color = 1;
#line 58
          break;
        }
#line 58
        while (1) {
#line 58
          tmp = parent->next.rbe_left;
#line 58
          parent->next.rbe_left = tmp->next.rbe_right;
#line 58
          if (parent->next.rbe_left) {
#line 58
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 58
          tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
          if (tmp->next.rbe_parent) {
#line 58
            if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 58
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 58
            head->rbh_root = tmp;
          }
#line 58
          tmp->next.rbe_right = parent;
#line 58
          parent->next.rbe_parent = tmp;
#line 58
          if (tmp->next.rbe_parent) {

          }
#line 58
          break;
        }
#line 58
        tmp = parent->next.rbe_left;
      }
#line 58
      if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
        goto _L___4;
      } else {
#line 58
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___4: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_right == (unsigned int )((void *)0)) {
#line 58
            tmp->next.rbe_color = 1;
#line 58
            elm = parent;
#line 58
            parent = elm->next.rbe_parent;
          } else {
#line 58
            if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 58
              tmp->next.rbe_color = 1;
#line 58
              elm = parent;
#line 58
              parent = elm->next.rbe_parent;
            } else {
              goto _L___3;
            }
          }
        } else {
          _L___3: /* CIL Label */ 
#line 58
          if ((unsigned int )tmp->next.rbe_left == (unsigned int )((void *)0)) {
            goto _L___2;
          } else {
#line 58
            if ((tmp->next.rbe_left)->next.rbe_color == 0) {
              _L___2: /* CIL Label */ 
#line 58
              oright = tmp->next.rbe_right;
#line 58
              if (oright) {
#line 58
                oright->next.rbe_color = 0;
              }
#line 58
              tmp->next.rbe_color = 1;
#line 58
              while (1) {
#line 58
                oright = tmp->next.rbe_right;
#line 58
                tmp->next.rbe_right = oright->next.rbe_left;
#line 58
                if (tmp->next.rbe_right) {
#line 58
                  (oright->next.rbe_left)->next.rbe_parent = tmp;
                }
#line 58
                oright->next.rbe_parent = tmp->next.rbe_parent;
#line 58
                if (oright->next.rbe_parent) {
#line 58
                  if ((unsigned int )tmp == (unsigned int )(tmp->next.rbe_parent)->next.rbe_left) {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_left = oright;
                  } else {
#line 58
                    (tmp->next.rbe_parent)->next.rbe_right = oright;
                  }
                } else {
#line 58
                  head->rbh_root = oright;
                }
#line 58
                oright->next.rbe_left = tmp;
#line 58
                tmp->next.rbe_parent = oright;
#line 58
                if (oright->next.rbe_parent) {

                }
#line 58
                break;
              }
#line 58
              tmp = parent->next.rbe_left;
            }
          }
#line 58
          tmp->next.rbe_color = parent->next.rbe_color;
#line 58
          parent->next.rbe_color = 0;
#line 58
          if (tmp->next.rbe_left) {
#line 58
            (tmp->next.rbe_left)->next.rbe_color = 0;
          }
#line 58
          while (1) {
#line 58
            tmp = parent->next.rbe_left;
#line 58
            parent->next.rbe_left = tmp->next.rbe_right;
#line 58
            if (parent->next.rbe_left) {
#line 58
              (tmp->next.rbe_right)->next.rbe_parent = parent;
            }
#line 58
            tmp->next.rbe_parent = parent->next.rbe_parent;
#line 58
            if (tmp->next.rbe_parent) {
#line 58
              if ((unsigned int )parent == (unsigned int )(parent->next.rbe_parent)->next.rbe_left) {
#line 58
                (parent->next.rbe_parent)->next.rbe_left = tmp;
              } else {
#line 58
                (parent->next.rbe_parent)->next.rbe_right = tmp;
              }
            } else {
#line 58
              head->rbh_root = tmp;
            }
#line 58
            tmp->next.rbe_right = parent;
#line 58
            parent->next.rbe_parent = tmp;
#line 58
            if (tmp->next.rbe_parent) {

            }
#line 58
            break;
          }
#line 58
          elm = head->rbh_root;
#line 58
          break;
        }
      }
    }
  }
#line 58
  if (elm) {
#line 58
    elm->next.rbe_color = 0;
  }
#line 58
  return;
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *child ;
  struct mm_share *parent ;
  struct mm_share *old ;
  int color ;
  struct mm_share *left ;

  {
#line 58
  old = elm;
#line 58
  if ((unsigned int )elm->next.rbe_left == (unsigned int )((void *)0)) {
#line 58
    child = elm->next.rbe_right;
  } else {
#line 58
    if ((unsigned int )elm->next.rbe_right == (unsigned int )((void *)0)) {
#line 58
      child = elm->next.rbe_left;
    } else {
#line 58
      elm = elm->next.rbe_right;
#line 58
      while (1) {
#line 58
        left = elm->next.rbe_left;
#line 58
        if (! left) {
#line 58
          break;
        }
#line 58
        elm = left;
      }
#line 58
      child = elm->next.rbe_right;
#line 58
      parent = elm->next.rbe_parent;
#line 58
      color = elm->next.rbe_color;
#line 58
      if (child) {
#line 58
        child->next.rbe_parent = parent;
      }
#line 58
      if (parent) {
#line 58
        if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
          parent->next.rbe_left = child;
        } else {
#line 58
          parent->next.rbe_right = child;
        }
      } else {
#line 58
        head->rbh_root = child;
      }
#line 58
      if ((unsigned int )elm->next.rbe_parent == (unsigned int )old) {
#line 58
        parent = elm;
      }
#line 58
      elm->next = old->next;
#line 58
      if (old->next.rbe_parent) {
#line 58
        if ((unsigned int )(old->next.rbe_parent)->next.rbe_left == (unsigned int )old) {
#line 58
          (old->next.rbe_parent)->next.rbe_left = elm;
        } else {
#line 58
          (old->next.rbe_parent)->next.rbe_right = elm;
        }
      } else {
#line 58
        head->rbh_root = elm;
      }
#line 58
      (old->next.rbe_left)->next.rbe_parent = elm;
#line 58
      if (old->next.rbe_right) {
#line 58
        (old->next.rbe_right)->next.rbe_parent = elm;
      }
#line 58
      if (parent) {
#line 58
        left = parent;
#line 58
        while (1) {
#line 58
          left = left->next.rbe_parent;
#line 58
          if (! left) {
#line 58
            break;
          }
        }
      }
      goto color;
    }
  }
#line 58
  parent = elm->next.rbe_parent;
#line 58
  color = elm->next.rbe_color;
#line 58
  if (child) {
#line 58
    child->next.rbe_parent = parent;
  }
#line 58
  if (parent) {
#line 58
    if ((unsigned int )parent->next.rbe_left == (unsigned int )elm) {
#line 58
      parent->next.rbe_left = child;
    } else {
#line 58
      parent->next.rbe_right = child;
    }
  } else {
#line 58
    head->rbh_root = child;
  }
  color: 
#line 58
  if (color == 0) {
#line 58
    mmtree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 58
  return (old);
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;
  int comp ;

  {
#line 58
  parent = (struct mm_share *)((void *)0);
#line 58
  comp = 0;
#line 58
  tmp = head->rbh_root;
#line 58
  while (tmp) {
#line 58
    parent = tmp;
#line 58
    comp = mm_compare(elm, parent);
#line 58
    if (comp < 0) {
#line 58
      tmp = tmp->next.rbe_left;
    } else {
#line 58
      if (comp > 0) {
#line 58
        tmp = tmp->next.rbe_right;
      } else {
#line 58
        return (tmp);
      }
    }
  }
#line 58
  while (1) {
#line 58
    elm->next.rbe_parent = parent;
#line 58
    elm->next.rbe_right = (struct mm_share *)((void *)0);
#line 58
    elm->next.rbe_left = elm->next.rbe_right;
#line 58
    elm->next.rbe_color = 1;
#line 58
    break;
  }
#line 58
  if ((unsigned int )parent != (unsigned int )((void *)0)) {
#line 58
    if (comp < 0) {
#line 58
      parent->next.rbe_left = elm;
    } else {
#line 58
      parent->next.rbe_right = elm;
    }
  } else {
#line 58
    head->rbh_root = elm;
  }
#line 58
  mmtree_RB_INSERT_COLOR(head, elm);
#line 58
  return ((struct mm_share *)((void *)0));
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) 
{ struct mm_share *tmp ;
  int comp ;

  {
#line 58
  tmp = head->rbh_root;
#line 58
  while (tmp) {
#line 58
    comp = mm_compare(elm, tmp);
#line 58
    if (comp < 0) {
#line 58
      tmp = tmp->next.rbe_left;
    } else {
#line 58
      if (comp > 0) {
#line 58
        tmp = tmp->next.rbe_right;
      } else {
#line 58
        return (tmp);
      }
    }
  }
#line 58
  return ((struct mm_share *)((void *)0));
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_NEXT(struct mm_share *elm ) 
{ 

  {
#line 58
  if (elm->next.rbe_right) {
#line 58
    elm = elm->next.rbe_right;
#line 58
    while (elm->next.rbe_left) {
#line 58
      elm = elm->next.rbe_left;
    }
  } else {
#line 58
    if (elm->next.rbe_parent) {
#line 58
      if ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_left) {
#line 58
        elm = elm->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 58
      while (1) {
#line 58
        if (elm->next.rbe_parent) {
#line 58
          if (! ((unsigned int )elm == (unsigned int )(elm->next.rbe_parent)->next.rbe_right)) {
#line 58
            break;
          }
        } else {
#line 58
          break;
        }
#line 58
        elm = elm->next.rbe_parent;
      }
#line 58
      elm = elm->next.rbe_parent;
    }
  }
#line 58
  return (elm);
}
}
#line 58 "monitor_mm.c"
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) 
{ struct mm_share *tmp ;
  struct mm_share *parent ;

  {
#line 58
  tmp = head->rbh_root;
#line 58
  parent = (struct mm_share *)((void *)0);
#line 58
  while (tmp) {
#line 58
    parent = tmp;
#line 58
    if (val < 0) {
#line 58
      tmp = tmp->next.rbe_left;
    } else {
#line 58
      tmp = tmp->next.rbe_right;
    }
  }
#line 58
  return (parent);
}
}
#line 60 "monitor_mm.c"
static struct mm_share *mm_make_entry(struct mm_master *mm , struct mmtree *head ,
                                      void *address , size_t size ) 
{ struct mm_share *tmp ;
  struct mm_share *tmp2 ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 66
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 67
    tmp___0 = xmalloc(sizeof(struct mm_share ));
#line 67
    tmp = (struct mm_share *)tmp___0;
  } else {
#line 69
    tmp___1 = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share ));
#line 69
    tmp = (struct mm_share *)tmp___1;
  }
#line 70
  tmp->address = address;
#line 71
  tmp->size = size;
#line 73
  tmp2 = mmtree_RB_INSERT(head, tmp);
#line 74
  if ((unsigned int )tmp2 != (unsigned int )((void *)0)) {
#line 75
    fatal("mm_make_entry(%p): double address %p->%p(%lu)", mm, tmp2, address, (unsigned long )size);
  }
#line 78
  return (tmp);
}
}
#line 83 "monitor_mm.c"
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) 
{ void *address ;
  struct mm_master *mm ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 89
  if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 90
    tmp = xmalloc(sizeof(struct mm_master ));
#line 90
    mm = (struct mm_master *)tmp;
  } else {
#line 92
    tmp___0 = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 92
    mm = (struct mm_master *)tmp___0;
  }
#line 99
  mm->mmalloc = mmalloc;
#line 101
  address = xmmap(size);
#line 102
  if ((unsigned int )address == (unsigned int )((void *)-1)) {
#line 103
    tmp___1 = __errno_location();
#line 103
    tmp___2 = strerror(*tmp___1);
#line 103
    fatal("mmap(%lu): %s", (unsigned long )size, tmp___2);
  }
#line 105
  mm->address = address;
#line 106
  mm->size = size;
#line 108
  while (1) {
#line 108
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 108
    break;
  }
#line 109
  while (1) {
#line 109
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 109
    break;
  }
#line 111
  mm_make_entry(mm, & mm->rb_free, address, size);
#line 113
  return (mm);
}
}
#line 118 "monitor_mm.c"
static void mm_freelist(struct mm_master *mmalloc , struct mmtree *head ) 
{ struct mm_share *mms ;
  struct mm_share *next ;

  {
#line 123
  mms = head->rbh_root;
#line 123
  while (mms) {
#line 124
    next = mmtree_RB_NEXT(mms);
#line 125
    mmtree_RB_REMOVE(head, mms);
#line 126
    if ((unsigned int )mmalloc == (unsigned int )((void *)0)) {
#line 127
      xfree((void *)mms);
    } else {
#line 129
      mm_free(mmalloc, (void *)mms);
    }
#line 123
    mms = next;
  }
#line 131
  return;
}
}
#line 135 "monitor_mm.c"
void mm_destroy(struct mm_master *mm ) 
{ int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 138
  mm_freelist(mm->mmalloc, & mm->rb_free);
#line 139
  mm_freelist(mm->mmalloc, & mm->rb_allocated);
#line 142
  tmp___1 = munmap(mm->address, mm->size);
#line 142
  if (tmp___1 == -1) {
#line 143
    tmp = __errno_location();
#line 143
    tmp___0 = strerror(*tmp);
#line 143
    fatal("munmap(%p, %lu): %s", mm->address, (unsigned long )mm->size, tmp___0);
  }
#line 149
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 150
    xfree((void *)mm);
  } else {
#line 152
    mm_free(mm->mmalloc, (void *)mm);
  }
#line 153
  return;
}
}
#line 155 "monitor_mm.c"
void *mm_xmalloc(struct mm_master *mm , size_t size ) 
{ void *address ;

  {
#line 160
  address = mm_malloc(mm, size);
#line 161
  if ((unsigned int )address == (unsigned int )((void *)0)) {
#line 162
    fatal("%s: mm_malloc(%lu)", "mm_xmalloc", (unsigned long )size);
  }
#line 163
  return (address);
}
}
#line 169 "monitor_mm.c"
void *mm_malloc(struct mm_master *mm , size_t size ) 
{ struct mm_share *mms ;
  struct mm_share *tmp ;

  {
#line 174
  if (size == 0U) {
#line 175
    fatal("mm_malloc: try to allocate 0 space");
  }
#line 176
  if ((unsigned long )size > 4294967168UL) {
#line 177
    fatal("mm_malloc: size too big");
  }
#line 179
  size = ((size + 127U) / 128U) * 128U;
#line 181
  mms = mmtree_RB_MINMAX(& mm->rb_free, -1);
#line 181
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 182
    if (mms->size >= size) {
#line 183
      break;
    }
#line 181
    mms = mmtree_RB_NEXT(mms);
  }
#line 186
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 187
    return ((void *)0);
  }
#line 190
  memset(mms->address, 208, size);
#line 192
  tmp = mm_make_entry(mm, & mm->rb_allocated, mms->address, size);
#line 195
  mms->size -= size;
#line 196
  mms->address = (void *)((u_char *)mms->address + size);
#line 198
  if (mms->size == 0U) {
#line 199
    mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 200
    if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 201
      xfree((void *)mms);
    } else {
#line 203
      mm_free(mm->mmalloc, (void *)mms);
    }
  }
#line 206
  return (tmp->address);
}
}
#line 211 "monitor_mm.c"
void mm_free(struct mm_master *mm , void *address ) 
{ struct mm_share *mms ;
  struct mm_share *prev ;
  struct mm_share tmp ;
  struct mm_share *tmp___0 ;

  {
#line 216
  tmp.address = address;
#line 217
  mms = mmtree_RB_FIND(& mm->rb_allocated, & tmp);
#line 218
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 219
    fatal("mm_free(%p): can not find %p", mm, address);
  }
#line 222
  memset(mms->address, 208, mms->size);
#line 225
  mmtree_RB_REMOVE(& mm->rb_allocated, mms);
#line 226
  tmp___0 = mmtree_RB_INSERT(& mm->rb_free, mms);
#line 226
  if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 227
    fatal("mm_free(%p): double address %p", mm, address);
  }
#line 230
  prev = mms;
#line 231
  if (prev->next.rbe_left) {
#line 232
    prev = prev->next.rbe_left;
#line 233
    while (prev->next.rbe_right) {
#line 234
      prev = prev->next.rbe_right;
    }
  } else {
#line 236
    if (prev->next.rbe_parent) {
#line 236
      if ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_right) {
#line 238
        prev = prev->next.rbe_parent;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 240
      while (1) {
#line 240
        if (prev->next.rbe_parent) {
#line 240
          if (! ((unsigned int )prev == (unsigned int )(prev->next.rbe_parent)->next.rbe_left)) {
#line 240
            break;
          }
        } else {
#line 240
          break;
        }
#line 242
        prev = prev->next.rbe_parent;
      }
#line 243
      prev = prev->next.rbe_parent;
    }
  }
#line 248
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 248
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )address) {
#line 249
      fatal("mm_free: memory corruption: %p(%lu) > %p", prev->address, (unsigned long )prev->size,
            address);
    }
  }
#line 253
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 253
    if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) == (unsigned int )address) {
#line 254
      prev->size += mms->size;
#line 255
      mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 256
      if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 257
        xfree((void *)mms);
      } else {
#line 259
        mm_free(mm->mmalloc, (void *)mms);
      }
    } else {
#line 261
      prev = mms;
    }
  } else {
#line 261
    prev = mms;
  }
#line 263
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 264
    return;
  }
#line 267
  mms = mmtree_RB_NEXT(prev);
#line 268
  if ((unsigned int )mms == (unsigned int )((void *)0)) {
#line 269
    return;
  }
#line 271
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) > (unsigned int )mms->address) {
#line 272
    fatal("mm_free: memory corruption: %p < %p(%lu)", mms->address, prev->address,
          (unsigned long )prev->size);
  }
#line 274
  if ((unsigned int )((void *)((u_char *)prev->address + prev->size)) != (unsigned int )mms->address) {
#line 275
    return;
  }
#line 277
  prev->size += mms->size;
#line 278
  mmtree_RB_REMOVE(& mm->rb_free, mms);
#line 280
  if ((unsigned int )mm->mmalloc == (unsigned int )((void *)0)) {
#line 281
    xfree((void *)mms);
  } else {
#line 283
    mm_free(mm->mmalloc, (void *)mms);
  }
#line 284
  return;
}
}
#line 286 "monitor_mm.c"
static void mm_sync_list(struct mmtree *oldtree , struct mmtree *newtree , struct mm_master *mm ,
                         struct mm_master *mmold ) 
{ struct mm_master *mmalloc ;
  struct mm_share *mms ;
  struct mm_share *new ;
  void *tmp ;

  {
#line 290
  mmalloc = mm->mmalloc;
#line 294
  mms = mmtree_RB_MINMAX(oldtree, -1);
#line 294
  while ((unsigned int )mms != (unsigned int )((void *)0)) {
#line 296
    mm_memvalid(mmold, (void *)mms, sizeof(struct mm_share ));
#line 297
    mm_memvalid(mm, mms->address, mms->size);
#line 299
    tmp = mm_xmalloc(mmalloc, sizeof(struct mm_share ));
#line 299
    new = (struct mm_share *)tmp;
#line 300
    memcpy((void * __restrict  )new, (void const   * __restrict  )mms, sizeof(struct mm_share ));
#line 301
    mmtree_RB_INSERT(newtree, new);
#line 294
    mms = mmtree_RB_NEXT(mms);
  }
#line 303
  return;
}
}
#line 305 "monitor_mm.c"
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) 
{ struct mm_master *mm ;
  struct mm_master *mmalloc ;
  struct mm_master *mmold ;
  struct mmtree rb_free ;
  struct mmtree rb_allocated ;
  void *tmp ;

  {
#line 313
  debug3("%s: Share sync", "mm_share_sync");
#line 315
  mm = *pmm;
#line 316
  mmold = mm->mmalloc;
#line 317
  mm_memvalid(mmold, (void *)mm, sizeof(*mm));
#line 319
  mmalloc = mm_create((struct mm_master *)((void *)0), mm->size);
#line 320
  tmp = mm_xmalloc(mmalloc, sizeof(struct mm_master ));
#line 320
  mm = (struct mm_master *)tmp;
#line 321
  memcpy((void * __restrict  )mm, (void const   * __restrict  )*pmm, sizeof(struct mm_master ));
#line 322
  mm->mmalloc = mmalloc;
#line 324
  rb_free = mm->rb_free;
#line 325
  rb_allocated = mm->rb_allocated;
#line 327
  while (1) {
#line 327
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 327
    break;
  }
#line 328
  while (1) {
#line 328
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 328
    break;
  }
#line 330
  mm_sync_list(& rb_free, & mm->rb_free, mm, mmold);
#line 331
  mm_sync_list(& rb_allocated, & mm->rb_allocated, mm, mmold);
#line 333
  mm_destroy(mmold);
#line 335
  *pmm = mm;
#line 336
  *pmmalloc = mmalloc;
#line 338
  debug3("%s: Share sync end", "mm_share_sync");
#line 339
  return;
}
}
#line 341 "monitor_mm.c"
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) 
{ void *end ;

  {
#line 344
  end = (void *)((u_char *)address + size);
#line 346
  if ((unsigned int )address < (unsigned int )mm->address) {
#line 347
    fatal("mm_memvalid: address too small: %p", address);
  }
#line 348
  if ((unsigned int )end < (unsigned int )address) {
#line 349
    fatal("mm_memvalid: end < address: %p < %p", end, address);
  }
#line 350
  if ((unsigned int )end > (unsigned int )((void *)((u_char *)mm->address + mm->size))) {
#line 351
    fatal("mm_memvalid: address too large: %p", address);
  }
#line 352
  return;
}
}
#line 1 "monitor.o"
#line 85 "monitor.h"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) ;
#line 88
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 89
void mm_request_receive(int sock , Buffer *m___0 ) ;
#line 90
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m___0 ) ;
#line 89 "monitor_wrap.h"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) ;
#line 93
void mm_get_keystate(struct monitor *pmonitor___0 ) ;
#line 106
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) ;
#line 107
void mm_zfree(struct mm_master *mm , void *address ) ;
#line 108
void mm_init_compression(struct mm_master *mm ) ;
#line 108 "monitor.c"
struct __anonstruct_child_state_82 child_state  ;
#line 131
int mm_answer_moduli(int sock , Buffer *m___0 ) ;
#line 132
int mm_answer_sign(int sock , Buffer *m___0 ) ;
#line 133
int mm_answer_pwnamallow(int sock , Buffer *m___0 ) ;
#line 134
int mm_answer_auth2_read_banner(int sock , Buffer *m___0 ) ;
#line 135
int mm_answer_authserv(int sock , Buffer *m___0 ) ;
#line 136
int mm_answer_authpassword(int sock , Buffer *m___0 ) ;
#line 141
int mm_answer_keyallowed(int sock , Buffer *m___0 ) ;
#line 142
int mm_answer_keyverify(int sock , Buffer *m___0 ) ;
#line 143
int mm_answer_pty(int sock , Buffer *m___0 ) ;
#line 144
int mm_answer_pty_cleanup(int sock , Buffer *m___0 ) ;
#line 145
int mm_answer_term(int sock , Buffer *req ) ;
#line 146
int mm_answer_rsa_keyallowed(int sock , Buffer *m___0 ) ;
#line 147
int mm_answer_rsa_challenge(int sock , Buffer *m___0 ) ;
#line 148
int mm_answer_rsa_response(int sock , Buffer *m___0 ) ;
#line 149
int mm_answer_sesskey(int sock , Buffer *m___0 ) ;
#line 150
int mm_answer_sessid(int sock , Buffer *m___0 ) ;
#line 173 "monitor.c"
static Authctxt *authctxt  ;
#line 174 "monitor.c"
static BIGNUM *ssh1_challenge  =    (BIGNUM *)((void *)0);
#line 177 "monitor.c"
static u_char *key_blob  =    (u_char *)((void *)0);
#line 178 "monitor.c"
static u_int key_bloblen  =    (u_int )0;
#line 179 "monitor.c"
static int key_blobtype  =    0;
#line 180 "monitor.c"
static char *hostbased_cuser  =    (char *)((void *)0);
#line 181 "monitor.c"
static char *hostbased_chost  =    (char *)((void *)0);
#line 182 "monitor.c"
static char *auth_method  =    (char *)"unknown";
#line 183 "monitor.c"
static u_int session_id2_len___0  =    (u_int )0;
#line 184 "monitor.c"
static u_char *session_id2___0  =    (u_char *)((void *)0);
#line 185 "monitor.c"
static pid_t monitor_child_pid  ;
#line 202 "monitor.c"
struct mon_table mon_dispatch_proto20[9]  = 
#line 202
  {      {0, 16, & mm_answer_moduli}, 
        {4, 16, & mm_answer_sign}, 
        {6, 16, & mm_answer_pwnamallow}, 
        {3, 16, & mm_answer_authserv}, 
        {8, 16, & mm_answer_auth2_read_banner}, 
        {10, 12, & mm_answer_authpassword}, 
        {20, 4, & mm_answer_keyallowed}, 
        {22, 12, & mm_answer_keyverify}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 239 "monitor.c"
struct mon_table mon_dispatch_postauth20[6]  = {      {0, 0, & mm_answer_moduli}, 
        {4, 0, & mm_answer_sign}, 
        {25, 0, & mm_answer_pty}, 
        {27, 0, & mm_answer_pty_cleanup}, 
        {58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 252 "monitor.c"
struct mon_table mon_dispatch_proto15[9]  = 
#line 252
  {      {6, 16, & mm_answer_pwnamallow}, 
        {28, 16, & mm_answer_sesskey}, 
        {30, 16, & mm_answer_sessid}, 
        {10, 12, & mm_answer_authpassword}, 
        {31, 36, & mm_answer_rsa_keyallowed}, 
        {20, 36, & mm_answer_keyallowed}, 
        {33, 16, & mm_answer_rsa_challenge}, 
        {35, 24, & mm_answer_rsa_response}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 283 "monitor.c"
struct mon_table mon_dispatch_postauth15[4]  = {      {25, 16, & mm_answer_pty}, 
        {27, 16, & mm_answer_pty_cleanup}, 
        {58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 294 "monitor.c"
struct mon_table *mon_dispatch  ;
#line 298 "monitor.c"
static void monitor_permit(struct mon_table *ent , enum monitor_reqtype type , int permit ) 
{ int tmp ;

  {
#line 301
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 302
    if ((int )ent->type == (int )type) {
#line 303
      ent->flags &= -4097;
#line 304
      if (permit) {
#line 304
        tmp = 4096;
      } else {
#line 304
        tmp = 0;
      }
#line 304
      ent->flags |= tmp;
#line 305
      return;
    }
#line 307
    ent ++;
  }
#line 309
  return;
}
}
#line 311 "monitor.c"
static void monitor_permit_authentications(int permit ) 
{ struct mon_table *ent ;
  int tmp ;

  {
#line 314
  ent = mon_dispatch;
#line 316
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 317
    if (ent->flags & 12) {
#line 318
      ent->flags &= -4097;
#line 319
      if (permit) {
#line 319
        tmp = 4096;
      } else {
#line 319
        tmp = 0;
      }
#line 319
      ent->flags |= tmp;
    }
#line 321
    ent ++;
  }
#line 323
  return;
}
}
#line 325 "monitor.c"
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) 
{ struct mon_table *ent ;
  int authenticated ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 329
  authenticated = 0;
#line 331
  debug3("preauth child monitor started");
#line 333
  authctxt = _authctxt;
#line 334
  memset((void *)authctxt, 0, sizeof(*authctxt));
#line 336
  authctxt->loginmsg = & loginmsg;
#line 338
  if (compat20) {
#line 339
    mon_dispatch = mon_dispatch_proto20;
#line 342
    monitor_permit(mon_dispatch, 0, 1);
#line 343
    monitor_permit(mon_dispatch, 4, 1);
  } else {
#line 345
    mon_dispatch = mon_dispatch_proto15;
#line 347
    monitor_permit(mon_dispatch, 28, 1);
  }
#line 351
  while (! authenticated) {
#line 352
    auth_method = (char *)"unknown";
#line 353
    tmp = monitor_read(pmonitor___0, mon_dispatch, & ent);
#line 353
    authenticated = tmp == 1;
#line 354
    if (authenticated) {
#line 355
      if (! (ent->flags & 8)) {
#line 356
        fatal("%s: unexpected authentication from %d", "monitor_child_preauth", ent->type);
      }
#line 358
      if ((authctxt->pw)->pw_uid == 0U) {
#line 358
        tmp___0 = auth_root_allowed(auth_method);
#line 358
        if (! tmp___0) {
#line 360
          authenticated = 0;
        }
      }
    }
#line 375
    if (ent->flags & 40) {
#line 376
      if (compat20) {
#line 376
        tmp___1 = " ssh2";
      } else {
#line 376
        tmp___1 = "";
      }
#line 376
      auth_log(authctxt, authenticated, auth_method, (char *)tmp___1);
#line 378
      if (! authenticated) {
#line 379
        (authctxt->failures) ++;
      }
    }
  }
#line 383
  if (! authctxt->valid) {
#line 384
    fatal("%s: authenticated invalid user", "monitor_child_preauth");
  }
#line 385
  if (0) {
#line 385
    __s1_len = strlen((char const   *)auth_method);
#line 385
    __s2_len = strlen("unknown");
#line 385
    if (! ((unsigned int )((void const   *)(auth_method + 1)) - (unsigned int )((void const   *)auth_method) == 1U)) {
      goto _L___0;
    } else {
#line 385
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 385
        if (! ((unsigned int )((void const   *)("unknown" + 1)) - (unsigned int )((void const   *)"unknown") == 1U)) {
#line 385
          tmp___11 = 1;
        } else {
#line 385
          if (__s2_len >= 4U) {
#line 385
            tmp___11 = 1;
          } else {
#line 385
            tmp___11 = 0;
          }
        }
      } else {
#line 385
        tmp___11 = 0;
      }
    }
#line 385
    if (tmp___11) {
#line 385
      tmp___7 = __builtin_strcmp((char const   *)auth_method, "unknown");
    } else {
#line 385
      tmp___10 = __builtin_strcmp((char const   *)auth_method, "unknown");
#line 385
      tmp___7 = tmp___10;
    }
  } else {
#line 385
    tmp___10 = __builtin_strcmp((char const   *)auth_method, "unknown");
#line 385
    tmp___7 = tmp___10;
  }
#line 385
  if (tmp___7 == 0) {
#line 386
    fatal("%s: authentication method name unknown", "monitor_child_preauth");
  }
#line 388
  debug("%s: %s has been authenticated by privileged process", "monitor_child_preauth",
        authctxt->user);
#line 391
  mm_get_keystate(pmonitor___0);
#line 392
  return;
}
}
#line 394 "monitor.c"
static void monitor_set_child_handler(pid_t pid ) 
{ 

  {
#line 397
  monitor_child_pid = pid;
#line 398
  return;
}
}
#line 400 "monitor.c"
static void monitor_child_handler(int sig ) 
{ 

  {
#line 403
  kill(monitor_child_pid, sig);
#line 404
  return;
}
}
#line 406 "monitor.c"
void monitor_child_postauth(struct monitor *pmonitor___0 ) 
{ 

  {
#line 409
  monitor_set_child_handler(pmonitor___0->m_pid);
#line 410
  mysignal(1, & monitor_child_handler);
#line 411
  mysignal(15, & monitor_child_handler);
#line 412
  mysignal(2, & monitor_child_handler);
#line 414
  if (compat20) {
#line 415
    mon_dispatch = mon_dispatch_postauth20;
#line 418
    monitor_permit(mon_dispatch, 0, 1);
#line 419
    monitor_permit(mon_dispatch, 4, 1);
#line 420
    monitor_permit(mon_dispatch, 58, 1);
  } else {
#line 422
    mon_dispatch = mon_dispatch_postauth15;
#line 423
    monitor_permit(mon_dispatch, 58, 1);
  }
#line 425
  if (! no_pty_flag) {
#line 426
    monitor_permit(mon_dispatch, 25, 1);
#line 427
    monitor_permit(mon_dispatch, 27, 1);
  }
#line 430
  while (1) {
#line 431
    monitor_read(pmonitor___0, mon_dispatch, (struct mon_table **)((void *)0));
  }
}
}
#line 434 "monitor.c"
void monitor_sync(struct monitor *pmonitor___0 ) 
{ 

  {
#line 437
  if (options.compression) {
#line 439
    mm_share_sync(& pmonitor___0->m_zlib, & pmonitor___0->m_zback);
  }
#line 441
  return;
}
}
#line 443 "monitor.c"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) 
{ Buffer m___0 ;
  int ret___0 ;
  u_char type ;
  int tmp ;

  {
#line 451
  buffer_init(& m___0);
#line 453
  mm_request_receive(pmonitor___0->m_sendfd, & m___0);
#line 454
  tmp = buffer_get_char(& m___0);
#line 454
  type = (unsigned char )tmp;
#line 456
  debug3("%s: checking request %d", "monitor_read", type);
#line 458
  while ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 459
    if ((int )ent->type == (int )type) {
#line 460
      break;
    }
#line 461
    ent ++;
  }
#line 464
  if ((unsigned int )ent->f != (unsigned int )((void *)0)) {
#line 465
    if (! (ent->flags & 4096)) {
#line 466
      fatal("%s: unpermitted request %d", "monitor_read", type);
    }
#line 468
    ret___0 = (*(ent->f))(pmonitor___0->m_sendfd, & m___0);
#line 469
    buffer_free(& m___0);
#line 472
    if (ent->flags & 16) {
#line 473
      debug2("%s: %d used once, disabling now", "monitor_read", type);
#line 475
      ent->flags &= -4097;
    }
#line 478
    if ((unsigned int )pent != (unsigned int )((void *)0)) {
#line 479
      *pent = ent;
    }
#line 481
    return (ret___0);
  }
#line 484
  fatal("%s: unsupported request: %d", "monitor_read", type);
#line 487
  return (-1);
}
}
#line 491 "monitor.c"
static int monitor_allowed_key(u_char *blob , u_int bloblen ) 
{ int tmp ;

  {
#line 495
  if ((unsigned int )key_blob == (unsigned int )((void *)0)) {
#line 497
    return (0);
  } else {
#line 495
    if (key_bloblen != bloblen) {
#line 497
      return (0);
    } else {
#line 495
      tmp = memcmp((void const   *)key_blob, (void const   *)blob, key_bloblen);
#line 495
      if (tmp) {
#line 497
        return (0);
      }
    }
  }
#line 498
  return (1);
}
}
#line 501 "monitor.c"
static void monitor_reset_key_state(void) 
{ 

  {
#line 505
  if ((unsigned int )key_blob != (unsigned int )((void *)0)) {
#line 506
    xfree((void *)key_blob);
  }
#line 507
  if ((unsigned int )hostbased_cuser != (unsigned int )((void *)0)) {
#line 508
    xfree((void *)hostbased_cuser);
  }
#line 509
  if ((unsigned int )hostbased_chost != (unsigned int )((void *)0)) {
#line 510
    xfree((void *)hostbased_chost);
  }
#line 511
  key_blob = (u_char *)((void *)0);
#line 512
  key_bloblen = 0U;
#line 513
  key_blobtype = 0;
#line 514
  hostbased_cuser = (char *)((void *)0);
#line 515
  hostbased_chost = (char *)((void *)0);
#line 516
  return;
}
}
#line 518 "monitor.c"
int mm_answer_moduli(int sock , Buffer *m___0 ) 
{ DH *dh ;
  int min ;
  int want ;
  int max ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;

  {
#line 524
  tmp = buffer_get_int(m___0);
#line 524
  min = (int )tmp;
#line 525
  tmp___0 = buffer_get_int(m___0);
#line 525
  want = (int )tmp___0;
#line 526
  tmp___1 = buffer_get_int(m___0);
#line 526
  max = (int )tmp___1;
#line 528
  debug3("%s: got parameters: %d %d %d", "mm_answer_moduli", min, want, max);
#line 531
  if (max < min) {
#line 532
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
  } else {
#line 531
    if (want < min) {
#line 532
      fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    } else {
#line 531
      if (max < want) {
#line 532
        fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
      }
    }
  }
#line 535
  buffer_clear(m___0);
#line 537
  dh = choose_dh(min, want, max);
#line 538
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 539
    buffer_put_char(m___0, 0);
#line 540
    return (0);
  } else {
#line 543
    buffer_put_char(m___0, 1);
#line 544
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->p);
#line 545
    buffer_put_bignum2(m___0, (BIGNUM const   *)dh->g);
#line 547
    DH_free(dh);
  }
#line 549
  mm_request_send(sock, 1, m___0);
#line 550
  return (0);
}
}
#line 553 "monitor.c"
int mm_answer_sign(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *p ;
  u_char *signature ;
  u_int siglen ;
  u_int datlen ;
  int keyid ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 562
  debug3("%s", "mm_answer_sign");
#line 564
  tmp = buffer_get_int(m___0);
#line 564
  keyid = (int )tmp;
#line 565
  tmp___0 = buffer_get_string(m___0, & datlen);
#line 565
  p = (u_char *)tmp___0;
#line 571
  if (datlen != 20U) {
#line 571
    if (datlen != 32U) {
#line 572
      fatal("%s: data length incorrect: %u", "mm_answer_sign", datlen);
    }
  }
#line 575
  if (session_id2_len___0 == 0U) {
#line 576
    session_id2_len___0 = datlen;
#line 577
    tmp___1 = xmalloc(session_id2_len___0);
#line 577
    session_id2___0 = (u_char *)tmp___1;
#line 578
    memcpy((void * __restrict  )session_id2___0, (void const   * __restrict  )p, session_id2_len___0);
  }
#line 581
  key = get_hostkey_by_index(keyid);
#line 581
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 582
    fatal("%s: no hostkey from index %d", "mm_answer_sign", keyid);
  }
#line 583
  tmp___2 = key_sign((Key const   *)key, & signature, & siglen, (u_char const   *)p,
                     datlen);
#line 583
  if (tmp___2 < 0) {
#line 584
    fatal("%s: key_sign failed", "mm_answer_sign");
  }
#line 586
  debug3("%s: signature %p(%u)", "mm_answer_sign", signature, siglen);
#line 588
  buffer_clear(m___0);
#line 589
  buffer_put_string(m___0, (void const   *)signature, siglen);
#line 591
  xfree((void *)p);
#line 592
  xfree((void *)signature);
#line 594
  mm_request_send(sock, 5, m___0);
#line 597
  monitor_permit(mon_dispatch, 6, 1);
#line 599
  return (0);
}
}
#line 604 "monitor.c"
int mm_answer_pwnamallow(int sock , Buffer *m___0 ) 
{ char *username ;
  struct passwd *pwent ;
  int allowed ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 609
  allowed = 0;
#line 611
  debug3("%s", "mm_answer_pwnamallow");
#line 613
  tmp = authctxt->attempt;
#line 613
  (authctxt->attempt) ++;
#line 613
  if (tmp != 0) {
#line 614
    fatal("%s: multiple attempts for getpwnam", "mm_answer_pwnamallow");
  }
#line 616
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 616
  username = (char *)tmp___0;
#line 618
  pwent = getpwnamallow((char const   *)username);
#line 620
  authctxt->user = xstrdup((char const   *)username);
#line 621
  if (pwent) {
#line 621
    tmp___1 = (char const   *)username;
  } else {
#line 621
    tmp___1 = "unknown";
  }
#line 621
  setproctitle("%s [priv]", tmp___1);
#line 622
  xfree((void *)username);
#line 624
  buffer_clear(m___0);
#line 626
  if ((unsigned int )pwent == (unsigned int )((void *)0)) {
#line 627
    buffer_put_char(m___0, 0);
#line 628
    authctxt->pw = fakepw();
    goto out;
  }
#line 632
  allowed = 1;
#line 633
  authctxt->pw = pwent;
#line 634
  authctxt->valid = 1;
#line 636
  buffer_put_char(m___0, 1);
#line 637
  buffer_put_string(m___0, (void const   *)pwent, sizeof(struct passwd ));
#line 638
  buffer_put_cstring(m___0, (char const   *)pwent->pw_name);
#line 639
  buffer_put_cstring(m___0, "*");
#line 640
  buffer_put_cstring(m___0, (char const   *)pwent->pw_gecos);
#line 644
  buffer_put_cstring(m___0, (char const   *)pwent->pw_dir);
#line 645
  buffer_put_cstring(m___0, (char const   *)pwent->pw_shell);
  out: 
#line 648
  buffer_put_string(m___0, (void const   *)(& options), sizeof(options));
#line 649
  if ((unsigned int )options.banner != (unsigned int )((void *)0)) {
#line 650
    buffer_put_cstring(m___0, (char const   *)options.banner);
  }
#line 651
  debug3("%s: sending MONITOR_ANS_PWNAM: %d", "mm_answer_pwnamallow", allowed);
#line 652
  mm_request_send(sock, 7, m___0);
#line 655
  if (! compat20) {
#line 656
    monitor_permit_authentications(1);
  } else {
#line 659
    monitor_permit(mon_dispatch, 3, 1);
#line 660
    monitor_permit(mon_dispatch, 8, 1);
  }
#line 668
  return (0);
}
}
#line 671 "monitor.c"
int mm_answer_auth2_read_banner(int sock , Buffer *m___0 ) 
{ char *banner ;
  char const   *tmp ;

  {
#line 675
  buffer_clear(m___0);
#line 676
  banner = auth2_read_banner();
#line 677
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 677
    tmp = (char const   *)banner;
  } else {
#line 677
    tmp = "";
  }
#line 677
  buffer_put_cstring(m___0, tmp);
#line 678
  mm_request_send(sock, 9, m___0);
#line 680
  if ((unsigned int )banner != (unsigned int )((void *)0)) {
#line 681
    xfree((void *)banner);
  }
#line 683
  return (0);
}
}
#line 686 "monitor.c"
int mm_answer_authserv(int sock , Buffer *m___0 ) 
{ void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 689
  monitor_permit_authentications(1);
#line 691
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 691
  authctxt->service = (char *)tmp;
#line 692
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 692
  authctxt->style = (char *)tmp___0;
#line 693
  debug3("%s: service=%s, style=%s", "mm_answer_authserv", authctxt->service, authctxt->style);
#line 696
  tmp___1 = strlen((char const   *)authctxt->style);
#line 696
  if (tmp___1 == 0U) {
#line 697
    xfree((void *)authctxt->style);
#line 698
    authctxt->style = (char *)((void *)0);
  }
#line 701
  return (0);
}
}
#line 707 "monitor.c"
static int call_count  ;
#line 704 "monitor.c"
int mm_answer_authpassword(int sock , Buffer *m___0 ) 
{ char *passwd ;
  int authenticated ;
  u_int plen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 712
  tmp = buffer_get_string(m___0, & plen);
#line 712
  passwd = (char *)tmp;
#line 714
  if (options.password_authentication) {
#line 714
    tmp___0 = auth_password(authctxt, (char const   *)passwd);
#line 714
    if (tmp___0) {
#line 714
      tmp___1 = 1;
    } else {
#line 714
      tmp___1 = 0;
    }
  } else {
#line 714
    tmp___1 = 0;
  }
#line 714
  authenticated = tmp___1;
#line 716
  tmp___2 = strlen((char const   *)passwd);
#line 716
  memset((void *)passwd, 0, tmp___2);
#line 717
  xfree((void *)passwd);
#line 719
  buffer_clear(m___0);
#line 720
  buffer_put_int(m___0, (unsigned int )authenticated);
#line 722
  debug3("%s: sending result %d", "mm_answer_authpassword", authenticated);
#line 723
  mm_request_send(sock, 11, m___0);
#line 725
  call_count ++;
#line 726
  if (plen == 0U) {
#line 726
    if (call_count == 1) {
#line 727
      auth_method = (char *)"none";
    } else {
#line 729
      auth_method = (char *)"password";
    }
  } else {
#line 729
    auth_method = (char *)"password";
  }
#line 732
  return (authenticated);
}
}
#line 975 "monitor.c"
static void mm_append_debug(Buffer *m___0 ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;

  {
#line 978
  if (auth_debug_init) {
#line 978
    tmp___1 = buffer_len(& auth_debug);
#line 978
    if (tmp___1) {
#line 979
      debug3("%s: Appending debug messages for child", "mm_append_debug");
#line 980
      tmp = buffer_len(& auth_debug);
#line 980
      tmp___0 = buffer_ptr(& auth_debug);
#line 980
      buffer_append(m___0, (void const   *)tmp___0, tmp);
#line 982
      buffer_clear(& auth_debug);
    }
  }
#line 984
  return;
}
}
#line 986 "monitor.c"
int mm_answer_keyallowed(int sock , Buffer *m___0 ) 
{ Key *key ;
  char *cuser ;
  char *chost ;
  u_char *blob ;
  u_int bloblen ;
  enum mm_keytype type ;
  int allowed ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 993
  type = (enum mm_keytype )0;
#line 994
  allowed = 0;
#line 996
  debug3("%s entering", "mm_answer_keyallowed");
#line 998
  tmp = buffer_get_int(m___0);
#line 998
  type = (enum mm_keytype )tmp;
#line 999
  tmp___0 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 999
  cuser = (char *)tmp___0;
#line 1000
  tmp___1 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1000
  chost = (char *)tmp___1;
#line 1001
  tmp___2 = buffer_get_string(m___0, & bloblen);
#line 1001
  blob = (u_char *)tmp___2;
#line 1003
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 1005
  if (compat20) {
#line 1005
    if ((int )type == 3) {
#line 1007
      fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1005
    if (! compat20) {
#line 1005
      if ((int )type != 3) {
#line 1007
        fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
      }
    }
  }
#line 1009
  debug3("%s: key_from_blob: %p", "mm_answer_keyallowed", key);
#line 1011
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1011
    if (authctxt->valid) {
#line 1012
      switch ((int )type) {
      case 2: 
#line 1014
      if (options.pubkey_authentication) {
#line 1014
        tmp___3 = user_key_allowed(authctxt->pw, key);
#line 1014
        if (tmp___3) {
#line 1014
          tmp___4 = 1;
        } else {
#line 1014
          tmp___4 = 0;
        }
      } else {
#line 1014
        tmp___4 = 0;
      }
#line 1014
      allowed = tmp___4;
#line 1016
      auth_method = (char *)"publickey";
#line 1017
      break;
      case 1: 
#line 1019
      if (options.hostbased_authentication) {
#line 1019
        tmp___5 = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, chost,
                                        key);
#line 1019
        if (tmp___5) {
#line 1019
          tmp___6 = 1;
        } else {
#line 1019
          tmp___6 = 0;
        }
      } else {
#line 1019
        tmp___6 = 0;
      }
#line 1019
      allowed = tmp___6;
#line 1022
      auth_method = (char *)"hostbased";
#line 1023
      break;
      case 3: 
#line 1025
      key->type = 0;
#line 1026
      if (options.rhosts_rsa_authentication) {
#line 1026
        tmp___7 = auth_rhosts_rsa_key_allowed(authctxt->pw, cuser, chost, key);
#line 1026
        if (tmp___7) {
#line 1026
          tmp___8 = 1;
        } else {
#line 1026
          tmp___8 = 0;
        }
      } else {
#line 1026
        tmp___8 = 0;
      }
#line 1026
      allowed = tmp___8;
#line 1029
      auth_method = (char *)"rsa";
#line 1030
      break;
      default: 
#line 1032
      fatal("%s: unknown key type %d", "mm_answer_keyallowed", type);
#line 1033
      break;
      }
    }
  }
#line 1036
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1037
    key_free(key);
  }
#line 1040
  monitor_reset_key_state();
#line 1042
  if (allowed) {
#line 1044
    key_blob = blob;
#line 1045
    key_bloblen = bloblen;
#line 1046
    key_blobtype = (int )type;
#line 1047
    hostbased_cuser = cuser;
#line 1048
    hostbased_chost = chost;
  } else {
#line 1051
    if (compat20) {
#line 1051
      tmp___9 = " ssh2";
    } else {
#line 1051
      tmp___9 = "";
    }
#line 1051
    auth_log(authctxt, 0, auth_method, (char *)tmp___9);
#line 1052
    xfree((void *)blob);
#line 1053
    xfree((void *)cuser);
#line 1054
    xfree((void *)chost);
  }
#line 1057
  if (allowed) {
#line 1057
    tmp___10 = "allowed";
  } else {
#line 1057
    tmp___10 = "disallowed";
  }
#line 1057
  debug3("%s: key %p is %s", "mm_answer_keyallowed", key, tmp___10);
#line 1060
  buffer_clear(m___0);
#line 1061
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1062
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 1064
  mm_append_debug(m___0);
#line 1066
  mm_request_send(sock, 21, m___0);
#line 1068
  if ((int )type == 3) {
#line 1069
    monitor_permit(mon_dispatch, 33, allowed);
  }
#line 1071
  return (0);
}
}
#line 1074 "monitor.c"
static int monitor_valid_userblob(u_char *data , u_int datalen ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  u_int l ;
  u_int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  u_int l___0 ;
  u_int tmp___29 ;
  u_int l___1 ;
  u_int tmp___30 ;
  u_int tmp___31 ;

  {
#line 1080
  fail = 0;
#line 1082
  buffer_init(& b);
#line 1083
  buffer_append(& b, (void const   *)data, datalen);
#line 1085
  if (datafellows & 16) {
#line 1086
    tmp = buffer_ptr(& b);
#line 1086
    p = (char *)tmp;
#line 1087
    len = buffer_len(& b);
#line 1088
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1091
      fail ++;
    } else {
#line 1088
      if (len < session_id2_len___0) {
#line 1091
        fail ++;
      } else {
#line 1088
        tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1088
        if (tmp___0 != 0) {
#line 1091
          fail ++;
        }
      }
    }
#line 1092
    buffer_consume(& b, session_id2_len___0);
  } else {
#line 1094
    tmp___1 = buffer_get_string(& b, & len);
#line 1094
    p = (char *)tmp___1;
#line 1095
    if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1098
      fail ++;
    } else {
#line 1095
      if (len != session_id2_len___0) {
#line 1098
        fail ++;
      } else {
#line 1095
        tmp___2 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1095
        if (tmp___2 != 0) {
#line 1098
          fail ++;
        }
      }
    }
#line 1099
    xfree((void *)p);
  }
#line 1101
  tmp___3 = buffer_get_char(& b);
#line 1101
  if (tmp___3 != 50) {
#line 1102
    fail ++;
  }
#line 1103
  tmp___4 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1103
  p = (char *)tmp___4;
#line 1104
  if (0) {
#line 1104
    __s1_len = strlen((char const   *)authctxt->user);
#line 1104
    __s2_len = strlen((char const   *)p);
#line 1104
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1104
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1104
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1104
          tmp___14 = 1;
        } else {
#line 1104
          if (__s2_len >= 4U) {
#line 1104
            tmp___14 = 1;
          } else {
#line 1104
            tmp___14 = 0;
          }
        }
      } else {
#line 1104
        tmp___14 = 0;
      }
    }
#line 1104
    if (tmp___14) {
#line 1104
      tmp___10 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1104
      tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1104
      tmp___10 = tmp___13;
    }
  } else {
#line 1104
    tmp___13 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1104
    tmp___10 = tmp___13;
  }
#line 1104
  if (tmp___10 != 0) {
#line 1105
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1107
    fail ++;
  }
#line 1109
  xfree((void *)p);
#line 1110
  while (1) {
#line 1110
    tmp___15 = buffer_get_int(& b);
#line 1110
    l = tmp___15;
#line 1110
    buffer_consume(& b, l);
#line 1110
    break;
  }
#line 1111
  if (datafellows & 32) {
#line 1112
    tmp___16 = buffer_get_char(& b);
#line 1112
    if (! tmp___16) {
#line 1113
      fail ++;
    }
  } else {
#line 1115
    tmp___17 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1115
    p = (char *)tmp___17;
#line 1116
    if (0) {
#line 1116
      __s1_len___0 = strlen("publickey");
#line 1116
      __s2_len___0 = strlen((char const   *)p);
#line 1116
      if (! ((unsigned int )((void const   *)("publickey" + 1)) - (unsigned int )((void const   *)"publickey") == 1U)) {
        goto _L___2;
      } else {
#line 1116
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 1116
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1116
            tmp___27 = 1;
          } else {
#line 1116
            if (__s2_len___0 >= 4U) {
#line 1116
              tmp___27 = 1;
            } else {
#line 1116
              tmp___27 = 0;
            }
          }
        } else {
#line 1116
          tmp___27 = 0;
        }
      }
#line 1116
      if (tmp___27) {
#line 1116
        tmp___23 = __builtin_strcmp("publickey", (char const   *)p);
      } else {
#line 1116
        tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1116
        tmp___23 = tmp___26;
      }
    } else {
#line 1116
      tmp___26 = __builtin_strcmp("publickey", (char const   *)p);
#line 1116
      tmp___23 = tmp___26;
    }
#line 1116
    if (tmp___23 != 0) {
#line 1117
      fail ++;
    }
#line 1118
    xfree((void *)p);
#line 1119
    tmp___28 = buffer_get_char(& b);
#line 1119
    if (! tmp___28) {
#line 1120
      fail ++;
    }
#line 1121
    while (1) {
#line 1121
      tmp___29 = buffer_get_int(& b);
#line 1121
      l___0 = tmp___29;
#line 1121
      buffer_consume(& b, l___0);
#line 1121
      break;
    }
  }
#line 1123
  while (1) {
#line 1123
    tmp___30 = buffer_get_int(& b);
#line 1123
    l___1 = tmp___30;
#line 1123
    buffer_consume(& b, l___1);
#line 1123
    break;
  }
#line 1124
  tmp___31 = buffer_len(& b);
#line 1124
  if (tmp___31 != 0U) {
#line 1125
    fail ++;
  }
#line 1126
  buffer_free(& b);
#line 1127
  return (fail == 0);
}
}
#line 1130 "monitor.c"
static int monitor_valid_hostbasedblob(u_char *data , u_int datalen , char *cuser ,
                                       char *chost ) 
{ Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  u_int l ;
  u_int tmp___13 ;
  void *tmp___14 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  u_int l___0 ;
  u_int tmp___25 ;
  u_int l___1 ;
  u_int tmp___26 ;
  void *tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  u_int tmp___49 ;

  {
#line 1137
  fail = 0;
#line 1139
  buffer_init(& b);
#line 1140
  buffer_append(& b, (void const   *)data, datalen);
#line 1142
  tmp = buffer_get_string(& b, & len);
#line 1142
  p = (char *)tmp;
#line 1143
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1146
    fail ++;
  } else {
#line 1143
    if (len != session_id2_len___0) {
#line 1146
      fail ++;
    } else {
#line 1143
      tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
#line 1143
      if (tmp___0 != 0) {
#line 1146
        fail ++;
      }
    }
  }
#line 1147
  xfree((void *)p);
#line 1149
  tmp___1 = buffer_get_char(& b);
#line 1149
  if (tmp___1 != 50) {
#line 1150
    fail ++;
  }
#line 1151
  tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1151
  p = (char *)tmp___2;
#line 1152
  if (0) {
#line 1152
    __s1_len = strlen((char const   *)authctxt->user);
#line 1152
    __s2_len = strlen((char const   *)p);
#line 1152
    if (! ((unsigned int )((void const   *)(authctxt->user + 1)) - (unsigned int )((void const   *)authctxt->user) == 1U)) {
      goto _L___0;
    } else {
#line 1152
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1152
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
#line 1152
          tmp___12 = 1;
        } else {
#line 1152
          if (__s2_len >= 4U) {
#line 1152
            tmp___12 = 1;
          } else {
#line 1152
            tmp___12 = 0;
          }
        }
      } else {
#line 1152
        tmp___12 = 0;
      }
    }
#line 1152
    if (tmp___12) {
#line 1152
      tmp___8 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
    } else {
#line 1152
      tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1152
      tmp___8 = tmp___11;
    }
  } else {
#line 1152
    tmp___11 = __builtin_strcmp((char const   *)authctxt->user, (char const   *)p);
#line 1152
    tmp___8 = tmp___11;
  }
#line 1152
  if (tmp___8 != 0) {
#line 1153
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
#line 1155
    fail ++;
  }
#line 1157
  xfree((void *)p);
#line 1158
  while (1) {
#line 1158
    tmp___13 = buffer_get_int(& b);
#line 1158
    l = tmp___13;
#line 1158
    buffer_consume(& b, l);
#line 1158
    break;
  }
#line 1159
  tmp___14 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1159
  p = (char *)tmp___14;
#line 1160
  if (0) {
#line 1160
    __s1_len___0 = strlen((char const   *)p);
#line 1160
    __s2_len___0 = strlen("hostbased");
#line 1160
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___2;
    } else {
#line 1160
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 1160
        if (! ((unsigned int )((void const   *)("hostbased" + 1)) - (unsigned int )((void const   *)"hostbased") == 1U)) {
#line 1160
          tmp___24 = 1;
        } else {
#line 1160
          if (__s2_len___0 >= 4U) {
#line 1160
            tmp___24 = 1;
          } else {
#line 1160
            tmp___24 = 0;
          }
        }
      } else {
#line 1160
        tmp___24 = 0;
      }
    }
#line 1160
    if (tmp___24) {
#line 1160
      tmp___20 = __builtin_strcmp((char const   *)p, "hostbased");
    } else {
#line 1160
      tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1160
      tmp___20 = tmp___23;
    }
  } else {
#line 1160
    tmp___23 = __builtin_strcmp((char const   *)p, "hostbased");
#line 1160
    tmp___20 = tmp___23;
  }
#line 1160
  if (tmp___20 != 0) {
#line 1161
    fail ++;
  }
#line 1162
  xfree((void *)p);
#line 1163
  while (1) {
#line 1163
    tmp___25 = buffer_get_int(& b);
#line 1163
    l___0 = tmp___25;
#line 1163
    buffer_consume(& b, l___0);
#line 1163
    break;
  }
#line 1164
  while (1) {
#line 1164
    tmp___26 = buffer_get_int(& b);
#line 1164
    l___1 = tmp___26;
#line 1164
    buffer_consume(& b, l___1);
#line 1164
    break;
  }
#line 1167
  tmp___27 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1167
  p = (char *)tmp___27;
#line 1168
  len = strlen((char const   *)p);
#line 1168
  if (len > 0U) {
#line 1168
    if ((int )*(p + (len - 1U)) == 46) {
#line 1169
      *(p + (len - 1U)) = (char )'\000';
    }
  }
#line 1170
  if (0) {
#line 1170
    __s1_len___1 = strlen((char const   *)p);
#line 1170
    __s2_len___1 = strlen((char const   *)chost);
#line 1170
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___4;
    } else {
#line 1170
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 1170
        if (! ((unsigned int )((void const   *)(chost + 1)) - (unsigned int )((void const   *)chost) == 1U)) {
#line 1170
          tmp___37 = 1;
        } else {
#line 1170
          if (__s2_len___1 >= 4U) {
#line 1170
            tmp___37 = 1;
          } else {
#line 1170
            tmp___37 = 0;
          }
        }
      } else {
#line 1170
        tmp___37 = 0;
      }
    }
#line 1170
    if (tmp___37) {
#line 1170
      tmp___33 = __builtin_strcmp((char const   *)p, (char const   *)chost);
    } else {
#line 1170
      tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1170
      tmp___33 = tmp___36;
    }
  } else {
#line 1170
    tmp___36 = __builtin_strcmp((char const   *)p, (char const   *)chost);
#line 1170
    tmp___33 = tmp___36;
  }
#line 1170
  if (tmp___33 != 0) {
#line 1171
    fail ++;
  }
#line 1172
  xfree((void *)p);
#line 1175
  tmp___38 = buffer_get_string(& b, (u_int *)((void *)0));
#line 1175
  p = (char *)tmp___38;
#line 1176
  if (0) {
#line 1176
    __s1_len___2 = strlen((char const   *)p);
#line 1176
    __s2_len___2 = strlen((char const   *)cuser);
#line 1176
    if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
      goto _L___6;
    } else {
#line 1176
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 1176
        if (! ((unsigned int )((void const   *)(cuser + 1)) - (unsigned int )((void const   *)cuser) == 1U)) {
#line 1176
          tmp___48 = 1;
        } else {
#line 1176
          if (__s2_len___2 >= 4U) {
#line 1176
            tmp___48 = 1;
          } else {
#line 1176
            tmp___48 = 0;
          }
        }
      } else {
#line 1176
        tmp___48 = 0;
      }
    }
#line 1176
    if (tmp___48) {
#line 1176
      tmp___44 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
    } else {
#line 1176
      tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1176
      tmp___44 = tmp___47;
    }
  } else {
#line 1176
    tmp___47 = __builtin_strcmp((char const   *)p, (char const   *)cuser);
#line 1176
    tmp___44 = tmp___47;
  }
#line 1176
  if (tmp___44 != 0) {
#line 1177
    fail ++;
  }
#line 1178
  xfree((void *)p);
#line 1180
  tmp___49 = buffer_len(& b);
#line 1180
  if (tmp___49 != 0U) {
#line 1181
    fail ++;
  }
#line 1182
  buffer_free(& b);
#line 1183
  return (fail == 0);
}
}
#line 1186 "monitor.c"
int mm_answer_keyverify(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *signature ;
  u_char *data ;
  u_char *blob ;
  u_int signaturelen ;
  u_int datalen ;
  u_int bloblen ;
  int verified ;
  int valid_data ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1192
  verified = 0;
#line 1193
  valid_data = 0;
#line 1195
  tmp = buffer_get_string(m___0, & bloblen);
#line 1195
  blob = (u_char *)tmp;
#line 1196
  tmp___0 = buffer_get_string(m___0, & signaturelen);
#line 1196
  signature = (u_char *)tmp___0;
#line 1197
  tmp___1 = buffer_get_string(m___0, & datalen);
#line 1197
  data = (u_char *)tmp___1;
#line 1199
  if ((unsigned int )hostbased_cuser == (unsigned int )((void *)0)) {
#line 1201
    fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
  } else {
#line 1199
    if ((unsigned int )hostbased_chost == (unsigned int )((void *)0)) {
#line 1201
      fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
    } else {
#line 1199
      tmp___2 = monitor_allowed_key(blob, bloblen);
#line 1199
      if (! tmp___2) {
#line 1201
        fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
      }
    }
  }
#line 1203
  key = key_from_blob((u_char const   *)blob, bloblen);
#line 1204
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1205
    fatal("%s: bad public key blob", "mm_answer_keyverify");
  }
#line 1207
  switch (key_blobtype) {
  case 2: 
#line 1209
  valid_data = monitor_valid_userblob(data, datalen);
#line 1210
  break;
  case 1: 
#line 1212
  valid_data = monitor_valid_hostbasedblob(data, datalen, hostbased_cuser, hostbased_chost);
#line 1214
  break;
  default: 
#line 1216
  valid_data = 0;
#line 1217
  break;
  }
#line 1219
  if (! valid_data) {
#line 1220
    fatal("%s: bad signature data blob", "mm_answer_keyverify");
  }
#line 1222
  verified = key_verify((Key const   *)key, (u_char const   *)signature, signaturelen,
                        (u_char const   *)data, datalen);
#line 1223
  if (verified == 1) {
#line 1223
    tmp___3 = "verified";
  } else {
#line 1223
    tmp___3 = "unverified";
  }
#line 1223
  debug3("%s: key %p signature %s", "mm_answer_keyverify", key, tmp___3);
#line 1226
  key_free(key);
#line 1227
  xfree((void *)blob);
#line 1228
  xfree((void *)signature);
#line 1229
  xfree((void *)data);
#line 1231
  if (key_blobtype == 2) {
#line 1231
    auth_method = (char *)"publickey";
  } else {
#line 1231
    auth_method = (char *)"hostbased";
  }
#line 1233
  monitor_reset_key_state();
#line 1235
  buffer_clear(m___0);
#line 1236
  buffer_put_int(m___0, (unsigned int )verified);
#line 1237
  mm_request_send(sock, 23, m___0);
#line 1239
  return (verified == 1);
}
}
#line 1242 "monitor.c"
static void mm_record_login(Session *s , struct passwd *pw___0 ) 
{ socklen_t fromlen ;
  struct sockaddr_storage from ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1252
  memset((void *)(& from), 0, sizeof(from));
#line 1253
  fromlen = sizeof(from);
#line 1254
  tmp___3 = packet_connection_is_on_socket();
#line 1254
  if (tmp___3) {
#line 1255
    tmp___1 = packet_get_connection_in();
#line 1255
    tmp___2 = getpeername(tmp___1, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1255
    if (tmp___2 < 0) {
#line 1257
      tmp = __errno_location();
#line 1257
      tmp___0 = strerror(*tmp);
#line 1257
      debug("getpeername: %.100s", tmp___0);
#line 1258
      cleanup_exit(255);
    }
  }
#line 1262
  tmp___4 = get_remote_name_or_ip(utmp_len, options.use_dns);
#line 1262
  record_login(s->pid, (char const   *)(s->tty), (char const   *)pw___0->pw_name,
               pw___0->pw_uid, tmp___4, (struct sockaddr *)(& from), fromlen);
#line 1265
  return;
}
}
#line 1267 "monitor.c"
static void mm_session_close(Session *s ) 
{ 

  {
#line 1270
  debug3("%s: session %d pid %ld", "mm_session_close", s->self, (long )s->pid);
#line 1271
  if (s->ttyfd != -1) {
#line 1272
    debug3("%s: tty %s ptyfd %d", "mm_session_close", s->tty, s->ptyfd);
#line 1273
    session_pty_cleanup2(s);
  }
#line 1275
  s->used = 0;
#line 1276
  return;
}
}
#line 1278 "monitor.c"
int mm_answer_pty(int sock , Buffer *m___0 ) 
{ Session *s ;
  int res ;
  int fd0 ;
  int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 1285
  debug3("%s entering", "mm_answer_pty");
#line 1287
  buffer_clear(m___0);
#line 1288
  s = session_new();
#line 1289
  if ((unsigned int )s == (unsigned int )((void *)0)) {
    goto error;
  }
#line 1291
  s->authctxt = authctxt;
#line 1292
  s->pw = authctxt->pw;
#line 1293
  s->pid = pmonitor->m_pid;
#line 1294
  res = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, sizeof(s->tty));
#line 1295
  if (res == 0) {
    goto error;
  }
#line 1297
  pty_setowner(authctxt->pw, (char const   *)(s->tty));
#line 1299
  buffer_put_int(m___0, 1U);
#line 1300
  buffer_put_cstring(m___0, (char const   *)(s->tty));
#line 1303
  tmp = dup2(s->ttyfd, 0);
#line 1303
  if (tmp == -1) {
#line 1304
    fatal("%s: dup2", "mm_answer_pty");
  }
#line 1306
  mm_record_login(s, authctxt->pw);
#line 1309
  close(0);
#line 1312
  tmp___0 = buffer_len(& loginmsg);
#line 1312
  tmp___1 = buffer_ptr(& loginmsg);
#line 1312
  buffer_put_string(m___0, (void const   *)tmp___1, tmp___0);
#line 1313
  buffer_clear(& loginmsg);
#line 1315
  mm_request_send(sock, 26, m___0);
#line 1317
  tmp___2 = mm_send_fd(sock, s->ptyfd);
#line 1317
  if (tmp___2 == -1) {
#line 1319
    fatal("%s: send fds failed", "mm_answer_pty");
  } else {
#line 1317
    tmp___3 = mm_send_fd(sock, s->ttyfd);
#line 1317
    if (tmp___3 == -1) {
#line 1319
      fatal("%s: send fds failed", "mm_answer_pty");
    }
  }
#line 1322
  fd0 = open("/dev/null", 0);
#line 1322
  if (fd0 < 0) {
#line 1323
    tmp___4 = __errno_location();
#line 1323
    tmp___5 = strerror(*tmp___4);
#line 1323
    fatal("%s: open(/dev/null): %s", "mm_answer_pty", tmp___5);
  }
#line 1324
  if (fd0 != 0) {
#line 1325
    error("%s: fd0 %d != 0", "mm_answer_pty", fd0);
  }
#line 1328
  close(s->ttyfd);
#line 1329
  s->ttyfd = s->ptyfd;
#line 1331
  s->ptymaster = s->ptyfd;
#line 1333
  debug3("%s: tty %s ptyfd %d", "mm_answer_pty", s->tty, s->ttyfd);
#line 1335
  return (0);
  error: 
#line 1338
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1339
    mm_session_close(s);
  }
#line 1340
  buffer_put_int(m___0, 0U);
#line 1341
  mm_request_send(sock, 26, m___0);
#line 1342
  return (0);
}
}
#line 1345 "monitor.c"
int mm_answer_pty_cleanup(int sock , Buffer *m___0 ) 
{ Session *s ;
  char *tty ;
  void *tmp ;

  {
#line 1351
  debug3("%s entering", "mm_answer_pty_cleanup");
#line 1353
  tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1353
  tty = (char *)tmp;
#line 1354
  s = session_by_tty(tty);
#line 1354
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 1355
    mm_session_close(s);
  }
#line 1356
  buffer_clear(m___0);
#line 1357
  xfree((void *)tty);
#line 1358
  return (0);
}
}
#line 1361 "monitor.c"
int mm_answer_sesskey(int sock , Buffer *m___0 ) 
{ BIGNUM *p ;
  int rsafail ;

  {
#line 1368
  monitor_permit(mon_dispatch, 28, 0);
#line 1370
  p = BN_new();
#line 1370
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1371
    fatal("%s: BN_new", "mm_answer_sesskey");
  }
#line 1373
  buffer_get_bignum2(m___0, p);
#line 1375
  rsafail = ssh1_session_key(p);
#line 1377
  buffer_clear(m___0);
#line 1378
  buffer_put_int(m___0, (unsigned int )rsafail);
#line 1379
  buffer_put_bignum2(m___0, (BIGNUM const   *)p);
#line 1381
  BN_clear_free(p);
#line 1383
  mm_request_send(sock, 29, m___0);
#line 1386
  monitor_permit(mon_dispatch, 30, 1);
#line 1388
  return (0);
}
}
#line 1391 "monitor.c"
int mm_answer_sessid(int sock , Buffer *m___0 ) 
{ int i ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 1396
  debug3("%s entering", "mm_answer_sessid");
#line 1398
  tmp = buffer_len(m___0);
#line 1398
  if (tmp != 16U) {
#line 1399
    fatal("%s: bad ssh1 session id", "mm_answer_sessid");
  }
#line 1400
  i = 0;
#line 1400
  while (i < 16) {
#line 1401
    tmp___0 = buffer_get_char(m___0);
#line 1401
    session_id[i] = (unsigned char )tmp___0;
#line 1400
    i ++;
  }
#line 1404
  monitor_permit(mon_dispatch, 6, 1);
#line 1406
  return (0);
}
}
#line 1409 "monitor.c"
int mm_answer_rsa_keyallowed(int sock , Buffer *m___0 ) 
{ BIGNUM *client_n ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int tmp ;

  {
#line 1413
  key = (Key *)((void *)0);
#line 1414
  blob = (u_char *)((void *)0);
#line 1415
  blen = (u_int )0;
#line 1416
  allowed = 0;
#line 1418
  debug3("%s entering", "mm_answer_rsa_keyallowed");
#line 1420
  auth_method = (char *)"rsa";
#line 1421
  if (options.rsa_authentication) {
#line 1421
    if (authctxt->valid) {
#line 1422
      client_n = BN_new();
#line 1422
      if ((unsigned int )client_n == (unsigned int )((void *)0)) {
#line 1423
        fatal("%s: BN_new", "mm_answer_rsa_keyallowed");
      }
#line 1424
      buffer_get_bignum2(m___0, client_n);
#line 1425
      allowed = auth_rsa_key_allowed(authctxt->pw, client_n, & key);
#line 1426
      BN_clear_free(client_n);
    }
  }
#line 1428
  buffer_clear(m___0);
#line 1429
  buffer_put_int(m___0, (unsigned int )allowed);
#line 1430
  buffer_put_int(m___0, (unsigned int )((unsigned int )forced_command != (unsigned int )((void *)0)));
#line 1433
  monitor_reset_key_state();
#line 1435
  if (allowed) {
#line 1435
    if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1436
      key->type = 1;
#line 1437
      tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1437
      if (tmp == 0) {
#line 1438
        fatal("%s: key_to_blob failed", "mm_answer_rsa_keyallowed");
      }
#line 1439
      buffer_put_string(m___0, (void const   *)blob, blen);
#line 1442
      key_blob = blob;
#line 1443
      key_bloblen = blen;
#line 1444
      key_blobtype = 4;
    }
  }
#line 1446
  if ((unsigned int )key != (unsigned int )((void *)0)) {
#line 1447
    key_free(key);
  }
#line 1449
  mm_append_debug(m___0);
#line 1451
  mm_request_send(sock, 32, m___0);
#line 1453
  monitor_permit(mon_dispatch, 33, allowed);
#line 1454
  monitor_permit(mon_dispatch, 35, 0);
#line 1455
  return (0);
}
}
#line 1458 "monitor.c"
int mm_answer_rsa_challenge(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_int blen ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1461
  key = (Key *)((void *)0);
#line 1465
  debug3("%s entering", "mm_answer_rsa_challenge");
#line 1467
  if (! authctxt->valid) {
#line 1468
    fatal("%s: authctxt not valid", "mm_answer_rsa_challenge");
  }
#line 1469
  tmp = buffer_get_string(m___0, & blen);
#line 1469
  blob = (u_char *)tmp;
#line 1470
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1470
  if (! tmp___0) {
#line 1471
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_challenge");
  }
#line 1472
  if (key_blobtype != 4) {
#line 1472
    if (key_blobtype != 3) {
#line 1473
      fatal("%s: key type mismatch", "mm_answer_rsa_challenge");
    }
  }
#line 1474
  key = key_from_blob((u_char const   *)blob, blen);
#line 1474
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1475
    fatal("%s: received bad key", "mm_answer_rsa_challenge");
  }
#line 1477
  if (ssh1_challenge) {
#line 1478
    BN_clear_free(ssh1_challenge);
  }
#line 1479
  ssh1_challenge = auth_rsa_generate_challenge(key);
#line 1481
  buffer_clear(m___0);
#line 1482
  buffer_put_bignum2(m___0, (BIGNUM const   *)ssh1_challenge);
#line 1484
  debug3("%s sending reply", "mm_answer_rsa_challenge");
#line 1485
  mm_request_send(sock, 34, m___0);
#line 1487
  monitor_permit(mon_dispatch, 35, 1);
#line 1489
  xfree((void *)blob);
#line 1490
  key_free(key);
#line 1491
  return (0);
}
}
#line 1494 "monitor.c"
int mm_answer_rsa_response(int sock , Buffer *m___0 ) 
{ Key *key ;
  u_char *blob ;
  u_char *response ;
  u_int blen ;
  u_int len ;
  int success ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1497
  key = (Key *)((void *)0);
#line 1502
  debug3("%s entering", "mm_answer_rsa_response");
#line 1504
  if (! authctxt->valid) {
#line 1505
    fatal("%s: authctxt not valid", "mm_answer_rsa_response");
  }
#line 1506
  if ((unsigned int )ssh1_challenge == (unsigned int )((void *)0)) {
#line 1507
    fatal("%s: no ssh1_challenge", "mm_answer_rsa_response");
  }
#line 1509
  tmp = buffer_get_string(m___0, & blen);
#line 1509
  blob = (u_char *)tmp;
#line 1510
  tmp___0 = monitor_allowed_key(blob, blen);
#line 1510
  if (! tmp___0) {
#line 1511
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_response");
  }
#line 1512
  if (key_blobtype != 4) {
#line 1512
    if (key_blobtype != 3) {
#line 1513
      fatal("%s: key type mismatch: %d", "mm_answer_rsa_response", key_blobtype);
    }
  }
#line 1514
  key = key_from_blob((u_char const   *)blob, blen);
#line 1514
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1515
    fatal("%s: received bad key", "mm_answer_rsa_response");
  }
#line 1516
  tmp___1 = buffer_get_string(m___0, & len);
#line 1516
  response = (u_char *)tmp___1;
#line 1517
  if (len != 16U) {
#line 1518
    fatal("%s: received bad response to challenge", "mm_answer_rsa_response");
  }
#line 1519
  success = auth_rsa_verify_response(key, ssh1_challenge, response);
#line 1521
  xfree((void *)blob);
#line 1522
  key_free(key);
#line 1523
  xfree((void *)response);
#line 1525
  if (key_blobtype == 4) {
#line 1525
    auth_method = (char *)"rsa";
  } else {
#line 1525
    auth_method = (char *)"rhosts-rsa";
  }
#line 1528
  BN_clear_free(ssh1_challenge);
#line 1529
  ssh1_challenge = (BIGNUM *)((void *)0);
#line 1530
  monitor_reset_key_state();
#line 1532
  buffer_clear(m___0);
#line 1533
  buffer_put_int(m___0, (unsigned int )success);
#line 1534
  mm_request_send(sock, 36, m___0);
#line 1536
  return (success);
}
}
#line 1539 "monitor.c"
int mm_answer_term(int sock , Buffer *req ) 
{ int res ;
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  union __anonunion___u_85___1 __u___1 ;
  union __anonunion___u_86___1 __u___2 ;

  {
#line 1545
  debug3("%s: tearing down sessions", "mm_answer_term");
#line 1548
  session_destroy_all(& mm_session_close);
#line 1555
  while (1) {
#line 1555
    tmp___0 = waitpid(pmonitor->m_pid, & status, 0);
#line 1555
    if (! (tmp___0 == -1)) {
#line 1555
      break;
    }
#line 1556
    tmp = __errno_location();
#line 1556
    if (*tmp != 4) {
#line 1557
      exit(1);
    }
  }
#line 1559
  __u___2.__in = status;
#line 1559
  if ((__u___2.__i & 127) == 0) {
#line 1559
    __u___1.__in = status;
#line 1559
    res = (__u___1.__i & 65280) >> 8;
  } else {
#line 1559
    res = 1;
  }
#line 1562
  exit(res);
}
}
#line 1607 "monitor.c"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) 
{ 

  {
#line 1610
  if (compat20) {
#line 1611
    set_newkeys(0);
#line 1612
    set_newkeys(1);
  } else {
#line 1614
    packet_set_protocol_flags((unsigned int )child_state.ssh1protoflags);
#line 1615
    packet_set_encryption_key((u_char const   *)child_state.ssh1key, child_state.ssh1keylen,
                              child_state.ssh1cipher);
#line 1617
    xfree((void *)child_state.ssh1key);
  }
#line 1621
  packet_set_keycontext(1, child_state.keyout);
#line 1622
  xfree((void *)child_state.keyout);
#line 1623
  packet_set_keycontext(0, child_state.keyin);
#line 1624
  xfree((void *)child_state.keyin);
#line 1626
  if (! compat20) {
#line 1627
    packet_set_iv(1, child_state.ivout);
#line 1628
    xfree((void *)child_state.ivout);
#line 1629
    packet_set_iv(0, child_state.ivin);
#line 1630
    xfree((void *)child_state.ivin);
  }
#line 1633
  memcpy((void * __restrict  )(& incoming_stream), (void const   * __restrict  )(& child_state.incoming),
         sizeof(incoming_stream));
#line 1635
  memcpy((void * __restrict  )(& outgoing_stream), (void const   * __restrict  )(& child_state.outgoing),
         sizeof(outgoing_stream));
#line 1639
  if (options.compression) {
#line 1640
    mm_init_compression(pmonitor___0->m_zlib);
  }
#line 1644
  buffer_clear(& input);
#line 1645
  buffer_append(& input, (void const   *)child_state.input, child_state.ilen);
#line 1646
  memset((void *)child_state.input, 0, child_state.ilen);
#line 1647
  xfree((void *)child_state.input);
#line 1649
  buffer_clear(& output);
#line 1650
  buffer_append(& output, (void const   *)child_state.output, child_state.olen);
#line 1651
  memset((void *)child_state.output, 0, child_state.olen);
#line 1652
  xfree((void *)child_state.output);
#line 1653
  return;
}
}
#line 1655 "monitor.c"
static Kex *mm_get_kex(Buffer *m___0 ) 
{ Kex *kex ;
  void *blob ;
  u_int bloblen ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 1662
  tmp = xcalloc(1U, sizeof(*kex));
#line 1662
  kex = (Kex *)tmp;
#line 1663
  tmp___0 = buffer_get_string(m___0, & kex->session_id_len);
#line 1663
  kex->session_id = (u_char *)tmp___0;
#line 1664
  if ((unsigned int )session_id2___0 == (unsigned int )((void *)0)) {
#line 1667
    fatal("mm_get_get: internal error: bad session id");
  } else {
#line 1664
    if (kex->session_id_len != session_id2_len___0) {
#line 1667
      fatal("mm_get_get: internal error: bad session id");
    } else {
#line 1664
      tmp___1 = memcmp((void const   *)kex->session_id, (void const   *)session_id2___0,
                       session_id2_len___0);
#line 1664
      if (tmp___1 != 0) {
#line 1667
        fatal("mm_get_get: internal error: bad session id");
      }
    }
  }
#line 1668
  kex->we_need = buffer_get_int(m___0);
#line 1669
  kex->kex[0] = & kexdh_server;
#line 1670
  kex->kex[1] = & kexdh_server;
#line 1671
  kex->kex[2] = & kexgex_server;
#line 1672
  kex->kex[3] = & kexgex_server;
#line 1673
  kex->server = 1;
#line 1674
  tmp___2 = buffer_get_int(m___0);
#line 1674
  kex->hostkey_type = (int )tmp___2;
#line 1675
  tmp___3 = buffer_get_int(m___0);
#line 1675
  kex->kex_type = (int )tmp___3;
#line 1676
  blob = buffer_get_string(m___0, & bloblen);
#line 1677
  buffer_init(& kex->my);
#line 1678
  buffer_append(& kex->my, (void const   *)blob, bloblen);
#line 1679
  xfree(blob);
#line 1680
  blob = buffer_get_string(m___0, & bloblen);
#line 1681
  buffer_init(& kex->peer);
#line 1682
  buffer_append(& kex->peer, (void const   *)blob, bloblen);
#line 1683
  xfree(blob);
#line 1684
  kex->done = 1;
#line 1685
  tmp___4 = buffer_get_int(m___0);
#line 1685
  kex->flags = (int )tmp___4;
#line 1686
  tmp___5 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1686
  kex->client_version_string = (char *)tmp___5;
#line 1687
  tmp___6 = buffer_get_string(m___0, (u_int *)((void *)0));
#line 1687
  kex->server_version_string = (char *)tmp___6;
#line 1688
  kex->load_host_key = & get_hostkey_by_type;
#line 1689
  kex->host_key_index = & get_hostkey_index;
#line 1691
  return (kex);
}
}
#line 1696 "monitor.c"
void mm_get_keystate(struct monitor *pmonitor___0 ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 1705
  debug3("%s: Waiting for new keys", "mm_get_keystate");
#line 1707
  buffer_init(& m___0);
#line 1708
  mm_request_receive_expect(pmonitor___0->m_sendfd, 24, & m___0);
#line 1709
  if (! compat20) {
#line 1710
    tmp = buffer_get_int(& m___0);
#line 1710
    child_state.ssh1protoflags = (int )tmp;
#line 1711
    tmp___0 = buffer_get_int(& m___0);
#line 1711
    child_state.ssh1cipher = (int )tmp___0;
#line 1712
    tmp___1 = buffer_get_string(& m___0, & child_state.ssh1keylen);
#line 1712
    child_state.ssh1key = (u_char *)tmp___1;
#line 1714
    tmp___2 = buffer_get_string(& m___0, & child_state.ivoutlen);
#line 1714
    child_state.ivout = (u_char *)tmp___2;
#line 1716
    tmp___3 = buffer_get_string(& m___0, & child_state.ivinlen);
#line 1716
    child_state.ivin = (u_char *)tmp___3;
    goto skip;
  } else {
#line 1720
    *(pmonitor___0->m_pkex) = mm_get_kex(& m___0);
  }
#line 1723
  tmp___4 = buffer_get_string(& m___0, & bloblen);
#line 1723
  blob = (u_char *)tmp___4;
#line 1724
  current_keys[1] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1725
  xfree((void *)blob);
#line 1727
  debug3("%s: Waiting for second key", "mm_get_keystate");
#line 1728
  tmp___5 = buffer_get_string(& m___0, & bloblen);
#line 1728
  blob = (u_char *)tmp___5;
#line 1729
  current_keys[0] = mm_newkeys_from_blob(blob, (int )bloblen);
#line 1730
  xfree((void *)blob);
#line 1733
  seqnr = buffer_get_int(& m___0);
#line 1734
  blocks = buffer_get_int64(& m___0);
#line 1735
  packets = buffer_get_int(& m___0);
#line 1736
  packet_set_state(1, seqnr, blocks, packets);
#line 1737
  seqnr = buffer_get_int(& m___0);
#line 1738
  blocks = buffer_get_int64(& m___0);
#line 1739
  packets = buffer_get_int(& m___0);
#line 1740
  packet_set_state(0, seqnr, blocks, packets);
  skip: 
#line 1744
  tmp___6 = buffer_get_string(& m___0, & child_state.keyoutlen);
#line 1744
  child_state.keyout = (u_char *)tmp___6;
#line 1745
  tmp___7 = buffer_get_string(& m___0, & child_state.keyinlen);
#line 1745
  child_state.keyin = (u_char *)tmp___7;
#line 1747
  debug3("%s: Getting compression state", "mm_get_keystate");
#line 1749
  tmp___8 = buffer_get_string(& m___0, & plen);
#line 1749
  p = (u_char *)tmp___8;
#line 1750
  if (plen != sizeof(child_state.outgoing)) {
#line 1751
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1752
  memcpy((void * __restrict  )(& child_state.outgoing), (void const   * __restrict  )p,
         sizeof(child_state.outgoing));
#line 1753
  xfree((void *)p);
#line 1755
  tmp___9 = buffer_get_string(& m___0, & plen);
#line 1755
  p = (u_char *)tmp___9;
#line 1756
  if (plen != sizeof(child_state.incoming)) {
#line 1757
    fatal("%s: bad request size", "mm_get_keystate");
  }
#line 1758
  memcpy((void * __restrict  )(& child_state.incoming), (void const   * __restrict  )p,
         sizeof(child_state.incoming));
#line 1759
  xfree((void *)p);
#line 1762
  debug3("%s: Getting Network I/O buffers", "mm_get_keystate");
#line 1763
  tmp___10 = buffer_get_string(& m___0, & child_state.ilen);
#line 1763
  child_state.input = (u_char *)tmp___10;
#line 1764
  tmp___11 = buffer_get_string(& m___0, & child_state.olen);
#line 1764
  child_state.output = (u_char *)tmp___11;
#line 1766
  buffer_free(& m___0);
#line 1767
  return;
}
}
#line 1771 "monitor.c"
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) 
{ size_t len ;
  void *address ;

  {
#line 1774
  len = size * ncount;
#line 1777
  if (len == 0U) {
#line 1778
    fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
  } else {
#line 1777
    if ((unsigned long )ncount > 4294967295UL / (unsigned long )size) {
#line 1778
      fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
    }
  }
#line 1780
  address = mm_malloc(mm, len);
#line 1782
  return (address);
}
}
#line 1785 "monitor.c"
void mm_zfree(struct mm_master *mm , void *address ) 
{ 

  {
#line 1788
  mm_free(mm, address);
#line 1789
  return;
}
}
#line 1791 "monitor.c"
void mm_init_compression(struct mm_master *mm ) 
{ 

  {
#line 1794
  outgoing_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1795
  outgoing_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1796
  outgoing_stream.opaque = (void *)mm;
#line 1798
  incoming_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1799
  incoming_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1800
  incoming_stream.opaque = (void *)mm;
#line 1801
  return;
}
}
#line 1810 "monitor.c"
static void monitor_socketpair(int *pair ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1814
  tmp = socketpair(1, 1, 0, (int *)pair);
#line 1814
  if (tmp == -1) {
#line 1815
    fatal("%s: socketpair", "monitor_socketpair");
  }
#line 1820
  while (1) {
#line 1820
    tmp___0 = fcntl(*(pair + 0), 2, 1);
#line 1820
    if (tmp___0 == -1) {
#line 1820
      fatal("fcntl(%d, F_SETFD)", *(pair + 0));
    }
#line 1820
    break;
  }
#line 1821
  while (1) {
#line 1821
    tmp___1 = fcntl(*(pair + 1), 2, 1);
#line 1821
    if (tmp___1 == -1) {
#line 1821
      fatal("fcntl(%d, F_SETFD)", *(pair + 1));
    }
#line 1821
    break;
  }
#line 1822
  return;
}
}
#line 1826 "monitor.c"
struct monitor *monitor_init(void) 
{ struct monitor *mon ;
  int pair[2] ;
  void *tmp ;

  {
#line 1832
  tmp = xcalloc(1U, sizeof(*mon));
#line 1832
  mon = (struct monitor *)tmp;
#line 1834
  monitor_socketpair(pair);
#line 1836
  mon->m_recvfd = pair[0];
#line 1837
  mon->m_sendfd = pair[1];
#line 1840
  if (options.compression) {
#line 1841
    mon->m_zback = mm_create((struct mm_master *)((void *)0), 65536U);
#line 1842
    mon->m_zlib = mm_create(mon->m_zback, 1310720U);
#line 1845
    mm_init_compression(mon->m_zlib);
  }
#line 1848
  return (mon);
}
}
#line 1851 "monitor.c"
void monitor_reinit(struct monitor *mon ) 
{ int pair[2] ;

  {
#line 1856
  monitor_socketpair(pair);
#line 1858
  mon->m_recvfd = pair[0];
#line 1859
  mon->m_sendfd = pair[1];
#line 1860
  return;
}
}
#line 1 "monitor_wrap.o"
#line 41 "monitor_wrap.h"
DH *mm_choose_dh(int min , int nbits , int max ) ;
#line 42
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 47
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) ;
#line 90
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) ;
#line 97
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) ;
#line 98
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 88 "monitor_wrap.c"
int mm_is_monitor(void) 
{ int tmp ;

  {
#line 95
  if (pmonitor) {
#line 95
    if (pmonitor->m_pid > 0) {
#line 95
      tmp = 1;
    } else {
#line 95
      tmp = 0;
    }
  } else {
#line 95
    tmp = 0;
  }
#line 95
  return (tmp);
}
}
#line 98 "monitor_wrap.c"
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_int mlen ;
  u_int tmp ;
  u_char buf___1[5] ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 101
  tmp = buffer_len(m___0);
#line 101
  mlen = tmp;
#line 104
  debug3("%s entering: type %d", "mm_request_send", type);
#line 106
  put_u32((void *)(buf___1), mlen + 1U);
#line 107
  buf___1[4] = (unsigned char )type;
#line 108
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, (void *)(buf___1),
                     sizeof(buf___1));
#line 108
  if (tmp___2 != sizeof(buf___1)) {
#line 109
    tmp___0 = __errno_location();
#line 109
    tmp___1 = strerror(*tmp___0);
#line 109
    fatal("%s: write: %s", "mm_request_send", tmp___1);
  }
#line 110
  tmp___5 = buffer_ptr(m___0);
#line 110
  tmp___6 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, tmp___5,
                     mlen);
#line 110
  if (tmp___6 != mlen) {
#line 111
    tmp___3 = __errno_location();
#line 111
    tmp___4 = strerror(*tmp___3);
#line 111
    fatal("%s: write: %s", "mm_request_send", tmp___4);
  }
#line 112
  return;
}
}
#line 114 "monitor_wrap.c"
void mm_request_receive(int sock , Buffer *m___0 ) 
{ u_char buf___1[4] ;
  u_int msg_len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;

  {
#line 120
  debug3("%s entering", "mm_request_receive");
#line 122
  tmp___2 = atomicio(& read, sock, (void *)(buf___1), sizeof(buf___1));
#line 122
  if (tmp___2 != sizeof(buf___1)) {
#line 123
    tmp = __errno_location();
#line 123
    if (*tmp == 32) {
#line 124
      cleanup_exit(255);
    }
#line 125
    tmp___0 = __errno_location();
#line 125
    tmp___1 = strerror(*tmp___0);
#line 125
    fatal("%s: read: %s", "mm_request_receive", tmp___1);
  }
#line 127
  msg_len = get_u32((void const   *)(buf___1));
#line 128
  if (msg_len > 262144U) {
#line 129
    fatal("%s: read: bad msg_len %d", "mm_request_receive", msg_len);
  }
#line 130
  buffer_clear(m___0);
#line 131
  buffer_append_space(m___0, msg_len);
#line 132
  tmp___5 = buffer_ptr(m___0);
#line 132
  tmp___6 = atomicio(& read, sock, tmp___5, msg_len);
#line 132
  if (tmp___6 != msg_len) {
#line 133
    tmp___3 = __errno_location();
#line 133
    tmp___4 = strerror(*tmp___3);
#line 133
    fatal("%s: read: %s", "mm_request_receive", tmp___4);
  }
#line 134
  return;
}
}
#line 136 "monitor_wrap.c"
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m___0 ) 
{ u_char rtype ;
  int tmp ;

  {
#line 141
  debug3("%s entering: type %d", "mm_request_receive_expect", type);
#line 143
  mm_request_receive(sock, m___0);
#line 144
  tmp = buffer_get_char(m___0);
#line 144
  rtype = (unsigned char )tmp;
#line 145
  if ((int )rtype != (int )type) {
#line 146
    fatal("%s: read: rtype %d != type %d", "mm_request_receive_expect", rtype, type);
  }
#line 148
  return;
}
}
#line 150 "monitor_wrap.c"
DH *mm_choose_dh(int min , int nbits , int max ) 
{ BIGNUM *p ;
  BIGNUM *g ;
  int success ;
  Buffer m___0 ;
  u_int tmp ;
  DH *tmp___0 ;

  {
#line 154
  success = 0;
#line 157
  buffer_init(& m___0);
#line 158
  buffer_put_int(& m___0, (unsigned int )min);
#line 159
  buffer_put_int(& m___0, (unsigned int )nbits);
#line 160
  buffer_put_int(& m___0, (unsigned int )max);
#line 162
  mm_request_send(pmonitor->m_recvfd, 0, & m___0);
#line 164
  debug3("%s: waiting for MONITOR_ANS_MODULI", "mm_choose_dh");
#line 165
  mm_request_receive_expect(pmonitor->m_recvfd, 1, & m___0);
#line 167
  success = buffer_get_char(& m___0);
#line 168
  if (success == 0) {
#line 169
    fatal("%s: MONITOR_ANS_MODULI failed", "mm_choose_dh");
  }
#line 171
  p = BN_new();
#line 171
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 172
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 173
  g = BN_new();
#line 173
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 174
    fatal("%s: BN_new failed", "mm_choose_dh");
  }
#line 175
  buffer_get_bignum2(& m___0, p);
#line 176
  buffer_get_bignum2(& m___0, g);
#line 178
  tmp = buffer_len(& m___0);
#line 178
  debug3("%s: remaining %d", "mm_choose_dh", tmp);
#line 179
  buffer_free(& m___0);
#line 181
  tmp___0 = dh_new_group(g, p);
#line 181
  return (tmp___0);
}
}
#line 184 "monitor_wrap.c"
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ Kex *kex ;
  Buffer m___0 ;
  int tmp ;
  void *tmp___0 ;

  {
#line 187
  kex = *(pmonitor->m_pkex);
#line 190
  debug3("%s entering", "mm_key_sign");
#line 192
  buffer_init(& m___0);
#line 193
  tmp = (*(kex->host_key_index))(key);
#line 193
  buffer_put_int(& m___0, (unsigned int )tmp);
#line 194
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 196
  mm_request_send(pmonitor->m_recvfd, 4, & m___0);
#line 198
  debug3("%s: waiting for MONITOR_ANS_SIGN", "mm_key_sign");
#line 199
  mm_request_receive_expect(pmonitor->m_recvfd, 5, & m___0);
#line 200
  tmp___0 = buffer_get_string(& m___0, lenp);
#line 200
  *sigp = (u_char *)tmp___0;
#line 201
  buffer_free(& m___0);
#line 203
  return (0);
}
}
#line 206 "monitor_wrap.c"
struct passwd *mm_getpwnamallow(char const   *username ) 
{ Buffer m___0 ;
  struct passwd *pw___0 ;
  u_int len ;
  ServerOptions *newopts ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 214
  debug3("%s entering", "mm_getpwnamallow");
#line 216
  buffer_init(& m___0);
#line 217
  buffer_put_cstring(& m___0, username);
#line 219
  mm_request_send(pmonitor->m_recvfd, 6, & m___0);
#line 221
  debug3("%s: waiting for MONITOR_ANS_PWNAM", "mm_getpwnamallow");
#line 222
  mm_request_receive_expect(pmonitor->m_recvfd, 7, & m___0);
#line 224
  tmp = buffer_get_char(& m___0);
#line 224
  if (tmp == 0) {
#line 225
    pw___0 = (struct passwd *)((void *)0);
    goto out;
  }
#line 228
  tmp___0 = buffer_get_string(& m___0, & len);
#line 228
  pw___0 = (struct passwd *)tmp___0;
#line 229
  if (len != sizeof(struct passwd )) {
#line 230
    fatal("%s: struct passwd size mismatch", "mm_getpwnamallow");
  }
#line 231
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 231
  pw___0->pw_name = (char *)tmp___1;
#line 232
  tmp___2 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 232
  pw___0->pw_passwd = (char *)tmp___2;
#line 233
  tmp___3 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 233
  pw___0->pw_gecos = (char *)tmp___3;
#line 237
  tmp___4 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 237
  pw___0->pw_dir = (char *)tmp___4;
#line 238
  tmp___5 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 238
  pw___0->pw_shell = (char *)tmp___5;
  out: 
#line 242
  tmp___6 = buffer_get_string(& m___0, & len);
#line 242
  newopts = (ServerOptions *)tmp___6;
#line 243
  if (len != sizeof(*newopts)) {
#line 244
    fatal("%s: option block size mismatch", "mm_getpwnamallow");
  }
#line 245
  if ((unsigned int )newopts->banner != (unsigned int )((void *)0)) {
#line 246
    tmp___7 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 246
    newopts->banner = (char *)tmp___7;
  }
#line 247
  copy_set_server_options(& options, newopts, 1);
#line 248
  xfree((void *)newopts);
#line 250
  buffer_free(& m___0);
#line 252
  return (pw___0);
}
}
#line 255 "monitor_wrap.c"
char *mm_auth2_read_banner(void) 
{ Buffer m___0 ;
  char *banner ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 261
  debug3("%s entering", "mm_auth2_read_banner");
#line 263
  buffer_init(& m___0);
#line 264
  mm_request_send(pmonitor->m_recvfd, 8, & m___0);
#line 265
  buffer_clear(& m___0);
#line 267
  mm_request_receive_expect(pmonitor->m_recvfd, 9, & m___0);
#line 269
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 269
  banner = (char *)tmp;
#line 270
  buffer_free(& m___0);
#line 273
  tmp___0 = strlen((char const   *)banner);
#line 273
  if (tmp___0 == 0U) {
#line 274
    xfree((void *)banner);
#line 275
    banner = (char *)((void *)0);
  }
#line 277
  return (banner);
}
}
#line 282 "monitor_wrap.c"
void mm_inform_authserv(char *service , char *style ) 
{ Buffer m___0 ;
  char const   *tmp ;

  {
#line 287
  debug3("%s entering", "mm_inform_authserv");
#line 289
  buffer_init(& m___0);
#line 290
  buffer_put_cstring(& m___0, (char const   *)service);
#line 291
  if (style) {
#line 291
    tmp = (char const   *)style;
  } else {
#line 291
    tmp = "";
  }
#line 291
  buffer_put_cstring(& m___0, tmp);
#line 293
  mm_request_send(pmonitor->m_recvfd, 3, & m___0);
#line 295
  buffer_free(& m___0);
#line 296
  return;
}
}
#line 299 "monitor_wrap.c"
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) 
{ Buffer m___0 ;
  int authenticated ;
  u_int tmp ;
  char const   *tmp___0 ;

  {
#line 303
  authenticated = 0;
#line 305
  debug3("%s entering", "mm_auth_password");
#line 307
  buffer_init(& m___0);
#line 308
  buffer_put_cstring(& m___0, (char const   *)password);
#line 309
  mm_request_send(pmonitor->m_recvfd, 10, & m___0);
#line 311
  debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", "mm_auth_password");
#line 312
  mm_request_receive_expect(pmonitor->m_recvfd, 11, & m___0);
#line 314
  tmp = buffer_get_int(& m___0);
#line 314
  authenticated = (int )tmp;
#line 316
  buffer_free(& m___0);
#line 318
  if (authenticated) {
#line 318
    tmp___0 = "";
  } else {
#line 318
    tmp___0 = "not ";
  }
#line 318
  debug3("%s: user %sauthenticated", "mm_auth_password", tmp___0);
#line 320
  return (authenticated);
}
}
#line 323 "monitor_wrap.c"
int mm_user_key_allowed(struct passwd *pw___0 , Key *key ) 
{ int tmp ;

  {
#line 326
  tmp = mm_key_allowed(2, (char *)((void *)0), (char *)((void *)0), key);
#line 326
  return (tmp);
}
}
#line 329 "monitor_wrap.c"
int mm_hostbased_key_allowed(struct passwd *pw___0 , char *user , char *host , Key *key ) 
{ int tmp ;

  {
#line 333
  tmp = mm_key_allowed(1, user, host, key);
#line 333
  return (tmp);
}
}
#line 336 "monitor_wrap.c"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw___0 , char *user , char *host ,
                                   Key *key ) 
{ int ret___0 ;

  {
#line 342
  key->type = 1;
#line 343
  ret___0 = mm_key_allowed(3, user, host, key);
#line 344
  key->type = 0;
#line 345
  return (ret___0);
}
}
#line 348 "monitor_wrap.c"
static void mm_send_debug(Buffer *m___0 ) 
{ char *msg ;
  void *tmp ;
  u_int tmp___0 ;

  {
#line 353
  while (1) {
#line 353
    tmp___0 = buffer_len(m___0);
#line 353
    if (! tmp___0) {
#line 353
      break;
    }
#line 354
    tmp = buffer_get_string(m___0, (u_int *)((void *)0));
#line 354
    msg = (char *)tmp;
#line 355
    debug3("%s: Sending debug: %s", "mm_send_debug", msg);
#line 356
    packet_send_debug("%s", msg);
#line 357
    xfree((void *)msg);
  }
#line 359
  return;
}
}
#line 361 "monitor_wrap.c"
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int allowed ;
  int have_forced ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;

  {
#line 367
  allowed = 0;
#line 367
  have_forced = 0;
#line 369
  debug3("%s entering", "mm_key_allowed");
#line 372
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 372
  if (! tmp) {
#line 373
    return (0);
  }
#line 375
  buffer_init(& m___0);
#line 376
  buffer_put_int(& m___0, (unsigned int )type);
#line 377
  if (user) {
#line 377
    tmp___0 = (char const   *)user;
  } else {
#line 377
    tmp___0 = "";
  }
#line 377
  buffer_put_cstring(& m___0, tmp___0);
#line 378
  if (host) {
#line 378
    tmp___1 = (char const   *)host;
  } else {
#line 378
    tmp___1 = "";
  }
#line 378
  buffer_put_cstring(& m___0, tmp___1);
#line 379
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 380
  xfree((void *)blob);
#line 382
  mm_request_send(pmonitor->m_recvfd, 20, & m___0);
#line 384
  debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", "mm_key_allowed");
#line 385
  mm_request_receive_expect(pmonitor->m_recvfd, 21, & m___0);
#line 387
  tmp___2 = buffer_get_int(& m___0);
#line 387
  allowed = (int )tmp___2;
#line 390
  auth_clear_options();
#line 391
  tmp___3 = buffer_get_int(& m___0);
#line 391
  have_forced = (int )tmp___3;
#line 392
  if (have_forced) {
#line 392
    forced_command = xstrdup("true");
  } else {
#line 392
    forced_command = (char *)((void *)0);
  }
#line 395
  mm_send_debug(& m___0);
#line 397
  buffer_free(& m___0);
#line 399
  return (allowed);
}
}
#line 408 "monitor_wrap.c"
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int len ;
  int verified ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 414
  verified = 0;
#line 416
  debug3("%s entering", "mm_key_verify");
#line 419
  tmp = key_to_blob((Key const   *)key, & blob, & len);
#line 419
  if (! tmp) {
#line 420
    return (0);
  }
#line 422
  buffer_init(& m___0);
#line 423
  buffer_put_string(& m___0, (void const   *)blob, len);
#line 424
  buffer_put_string(& m___0, (void const   *)sig, siglen);
#line 425
  buffer_put_string(& m___0, (void const   *)data, datalen);
#line 426
  xfree((void *)blob);
#line 428
  mm_request_send(pmonitor->m_recvfd, 22, & m___0);
#line 430
  debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", "mm_key_verify");
#line 431
  mm_request_receive_expect(pmonitor->m_recvfd, 23, & m___0);
#line 433
  tmp___0 = buffer_get_int(& m___0);
#line 433
  verified = (int )tmp___0;
#line 435
  buffer_free(& m___0);
#line 437
  return (verified);
}
}
#line 441 "monitor_wrap.c"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) 
{ Buffer b ;
  u_int len ;
  Newkeys *newkey ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  void *tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Cipher *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;

  {
#line 446
  newkey = (Newkeys *)((void *)0);
#line 451
  debug3("%s: %p(%d)", "mm_newkeys_from_blob", blob, blen);
#line 455
  buffer_init(& b);
#line 456
  buffer_append(& b, (void const   *)blob, (unsigned int )blen);
#line 458
  tmp = xmalloc(sizeof(*newkey));
#line 458
  newkey = (Newkeys *)tmp;
#line 459
  enc = & newkey->enc;
#line 460
  mac = & newkey->mac;
#line 461
  comp = & newkey->comp;
#line 464
  tmp___0 = buffer_get_string(& b, (u_int *)((void *)0));
#line 464
  enc->name = (char *)tmp___0;
#line 465
  buffer_get(& b, (void *)(& enc->cipher), sizeof(enc->cipher));
#line 466
  tmp___1 = buffer_get_int(& b);
#line 466
  enc->enabled = (int )tmp___1;
#line 467
  enc->block_size = buffer_get_int(& b);
#line 468
  tmp___2 = buffer_get_string(& b, & enc->key_len);
#line 468
  enc->key = (u_char *)tmp___2;
#line 469
  tmp___3 = buffer_get_string(& b, & len);
#line 469
  enc->iv = (u_char *)tmp___3;
#line 470
  if (len != enc->block_size) {
#line 471
    fatal("%s: bad ivlen: expected %u != %u", "mm_newkeys_from_blob", enc->block_size,
          len);
  }
#line 474
  if ((unsigned int )enc->name == (unsigned int )((void *)0)) {
#line 475
    fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
          enc->cipher);
  } else {
#line 474
    tmp___4 = cipher_by_name((char const   *)enc->name);
#line 474
    if ((unsigned int )tmp___4 != (unsigned int )enc->cipher) {
#line 475
      fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
            enc->cipher);
    }
  }
#line 479
  tmp___5 = buffer_get_string(& b, (u_int *)((void *)0));
#line 479
  mac->name = (char *)tmp___5;
#line 480
  if ((unsigned int )mac->name == (unsigned int )((void *)0)) {
#line 481
    fatal("%s: can not setup mac %s", "mm_newkeys_from_blob", mac->name);
  } else {
#line 480
    tmp___6 = mac_setup(mac, mac->name);
#line 480
    if (tmp___6 == -1) {
#line 481
      fatal("%s: can not setup mac %s", "mm_newkeys_from_blob", mac->name);
    }
  }
#line 482
  tmp___7 = buffer_get_int(& b);
#line 482
  mac->enabled = (int )tmp___7;
#line 483
  tmp___8 = buffer_get_string(& b, & len);
#line 483
  mac->key = (u_char *)tmp___8;
#line 484
  if (len > mac->key_len) {
#line 485
    fatal("%s: bad mac key length: %u > %d", "mm_newkeys_from_blob", len, mac->key_len);
  }
#line 487
  mac->key_len = len;
#line 490
  tmp___9 = buffer_get_int(& b);
#line 490
  comp->type = (int )tmp___9;
#line 491
  tmp___10 = buffer_get_int(& b);
#line 491
  comp->enabled = (int )tmp___10;
#line 492
  tmp___11 = buffer_get_string(& b, (u_int *)((void *)0));
#line 492
  comp->name = (char *)tmp___11;
#line 494
  len = buffer_len(& b);
#line 495
  if (len != 0U) {
#line 496
    error("newkeys_from_blob: remaining bytes in blob %u", len);
  }
#line 497
  buffer_free(& b);
#line 498
  return (newkey);
}
}
#line 501 "monitor_wrap.c"
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) 
{ Buffer b ;
  int len ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  Newkeys *newkey ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 509
  newkey = newkeys[mode];
#line 511
  debug3("%s: converting %p", "mm_newkeys_to_blob", newkey);
#line 513
  if ((unsigned int )newkey == (unsigned int )((void *)0)) {
#line 514
    error("%s: newkey == NULL", "mm_newkeys_to_blob");
#line 515
    return (0);
  }
#line 517
  enc = & newkey->enc;
#line 518
  mac = & newkey->mac;
#line 519
  comp = & newkey->comp;
#line 521
  buffer_init(& b);
#line 523
  buffer_put_cstring(& b, (char const   *)enc->name);
#line 525
  buffer_append(& b, (void const   *)(& enc->cipher), sizeof(enc->cipher));
#line 526
  buffer_put_int(& b, (unsigned int )enc->enabled);
#line 527
  buffer_put_int(& b, enc->block_size);
#line 528
  buffer_put_string(& b, (void const   *)enc->key, enc->key_len);
#line 529
  packet_get_keyiv(mode, enc->iv, enc->block_size);
#line 530
  buffer_put_string(& b, (void const   *)enc->iv, enc->block_size);
#line 533
  buffer_put_cstring(& b, (char const   *)mac->name);
#line 534
  buffer_put_int(& b, (unsigned int )mac->enabled);
#line 535
  buffer_put_string(& b, (void const   *)mac->key, mac->key_len);
#line 538
  buffer_put_int(& b, (unsigned int )comp->type);
#line 539
  buffer_put_int(& b, (unsigned int )comp->enabled);
#line 540
  buffer_put_cstring(& b, (char const   *)comp->name);
#line 542
  tmp = buffer_len(& b);
#line 542
  len = (int )tmp;
#line 543
  if ((unsigned int )lenp != (unsigned int )((void *)0)) {
#line 544
    *lenp = (unsigned int )len;
  }
#line 545
  if ((unsigned int )blobp != (unsigned int )((void *)0)) {
#line 546
    tmp___0 = xmalloc((unsigned int )len);
#line 546
    *blobp = (u_char *)tmp___0;
#line 547
    tmp___1 = buffer_ptr(& b);
#line 547
    memcpy((void * __restrict  )*blobp, (void const   * __restrict  )tmp___1, (unsigned int )len);
  }
#line 549
  tmp___2 = buffer_ptr(& b);
#line 549
  memset(tmp___2, 0, (unsigned int )len);
#line 550
  buffer_free(& b);
#line 551
  return (len);
}
}
#line 554 "monitor_wrap.c"
static void mm_send_kex(Buffer *m___0 , Kex *kex ) 
{ u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
#line 557
  buffer_put_string(m___0, (void const   *)kex->session_id, kex->session_id_len);
#line 558
  buffer_put_int(m___0, kex->we_need);
#line 559
  buffer_put_int(m___0, (unsigned int )kex->hostkey_type);
#line 560
  buffer_put_int(m___0, (unsigned int )kex->kex_type);
#line 561
  tmp = buffer_len(& kex->my);
#line 561
  tmp___0 = buffer_ptr(& kex->my);
#line 561
  buffer_put_string(m___0, (void const   *)tmp___0, tmp);
#line 562
  tmp___1 = buffer_len(& kex->peer);
#line 562
  tmp___2 = buffer_ptr(& kex->peer);
#line 562
  buffer_put_string(m___0, (void const   *)tmp___2, tmp___1);
#line 563
  buffer_put_int(m___0, (unsigned int )kex->flags);
#line 564
  buffer_put_cstring(m___0, (char const   *)kex->client_version_string);
#line 565
  buffer_put_cstring(m___0, (char const   *)kex->server_version_string);
#line 566
  return;
}
}
#line 568 "monitor_wrap.c"
void mm_send_keystate(struct monitor *monitor ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_char iv[24] ;
  u_char *key ;
  u_int ivlen ;
  u_int keylen ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  u_int tmp___12 ;
  void *tmp___13 ;

  {
#line 577
  buffer_init(& m___0);
#line 579
  if (! compat20) {
#line 584
    tmp = packet_get_protocol_flags();
#line 584
    buffer_put_int(& m___0, tmp);
#line 586
    tmp___0 = packet_get_ssh1_cipher();
#line 586
    buffer_put_int(& m___0, (unsigned int )tmp___0);
#line 588
    debug3("%s: Sending ssh1 KEY+IV", "mm_send_keystate");
#line 589
    keylen = packet_get_encryption_key((u_char *)((void *)0));
#line 590
    tmp___1 = xmalloc(keylen + 1U);
#line 590
    key = (u_char *)tmp___1;
#line 591
    keylen = packet_get_encryption_key(key);
#line 592
    buffer_put_string(& m___0, (void const   *)key, keylen);
#line 593
    memset((void *)key, 0, keylen);
#line 594
    xfree((void *)key);
#line 596
    tmp___2 = packet_get_keyiv_len(1);
#line 596
    ivlen = (unsigned int )tmp___2;
#line 597
    packet_get_keyiv(1, iv, ivlen);
#line 598
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
#line 599
    tmp___3 = packet_get_keyiv_len(1);
#line 599
    ivlen = (unsigned int )tmp___3;
#line 600
    packet_get_keyiv(0, iv, ivlen);
#line 601
    buffer_put_string(& m___0, (void const   *)(iv), ivlen);
    goto skip;
  } else {
#line 605
    mm_send_kex(& m___0, *(monitor->m_pkex));
  }
#line 608
  debug3("%s: Sending new keys: %p %p", "mm_send_keystate", newkeys[1], newkeys[0]);
#line 612
  tmp___4 = mm_newkeys_to_blob(1, & blob, & bloblen);
#line 612
  if (! tmp___4) {
#line 613
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 615
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 616
  xfree((void *)blob);
#line 618
  tmp___5 = mm_newkeys_to_blob(0, & blob, & bloblen);
#line 618
  if (! tmp___5) {
#line 619
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
  }
#line 621
  buffer_put_string(& m___0, (void const   *)blob, bloblen);
#line 622
  xfree((void *)blob);
#line 624
  packet_get_state(1, & seqnr, & blocks, & packets);
#line 625
  buffer_put_int(& m___0, seqnr);
#line 626
  buffer_put_int64(& m___0, blocks);
#line 627
  buffer_put_int(& m___0, packets);
#line 628
  packet_get_state(0, & seqnr, & blocks, & packets);
#line 629
  buffer_put_int(& m___0, seqnr);
#line 630
  buffer_put_int64(& m___0, blocks);
#line 631
  buffer_put_int(& m___0, packets);
#line 633
  debug3("%s: New keys have been sent", "mm_send_keystate");
  skip: 
#line 636
  tmp___6 = packet_get_keycontext(1, (u_char *)((void *)0));
#line 636
  plen = (unsigned int )tmp___6;
#line 637
  tmp___7 = xmalloc(plen + 1U);
#line 637
  p = (u_char *)tmp___7;
#line 638
  packet_get_keycontext(1, p);
#line 639
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 640
  xfree((void *)p);
#line 642
  tmp___8 = packet_get_keycontext(0, (u_char *)((void *)0));
#line 642
  plen = (unsigned int )tmp___8;
#line 643
  tmp___9 = xmalloc(plen + 1U);
#line 643
  p = (u_char *)tmp___9;
#line 644
  packet_get_keycontext(0, p);
#line 645
  buffer_put_string(& m___0, (void const   *)p, plen);
#line 646
  xfree((void *)p);
#line 649
  debug3("%s: Sending compression state", "mm_send_keystate");
#line 650
  buffer_put_string(& m___0, (void const   *)(& outgoing_stream), sizeof(outgoing_stream));
#line 651
  buffer_put_string(& m___0, (void const   *)(& incoming_stream), sizeof(incoming_stream));
#line 654
  tmp___10 = buffer_len(& input);
#line 654
  tmp___11 = buffer_ptr(& input);
#line 654
  buffer_put_string(& m___0, (void const   *)tmp___11, tmp___10);
#line 655
  tmp___12 = buffer_len(& output);
#line 655
  tmp___13 = buffer_ptr(& output);
#line 655
  buffer_put_string(& m___0, (void const   *)tmp___13, tmp___12);
#line 657
  mm_request_send(monitor->m_recvfd, 24, & m___0);
#line 658
  debug3("%s: Finished sending state", "mm_send_keystate");
#line 660
  buffer_free(& m___0);
#line 661
  return;
}
}
#line 663 "monitor_wrap.c"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , size_t namebuflen ) 
{ Buffer m___0 ;
  char *p ;
  char *msg ;
  int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 668
  success = 0;
#line 670
  buffer_init(& m___0);
#line 671
  mm_request_send(pmonitor->m_recvfd, 25, & m___0);
#line 673
  debug3("%s: waiting for MONITOR_ANS_PTY", "mm_pty_allocate");
#line 674
  mm_request_receive_expect(pmonitor->m_recvfd, 26, & m___0);
#line 676
  tmp = buffer_get_int(& m___0);
#line 676
  success = (int )tmp;
#line 677
  if (success == 0) {
#line 678
    debug3("%s: pty alloc failed", "mm_pty_allocate");
#line 679
    buffer_free(& m___0);
#line 680
    return (0);
  }
#line 682
  tmp___0 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 682
  p = (char *)tmp___0;
#line 683
  tmp___1 = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 683
  msg = (char *)tmp___1;
#line 684
  buffer_free(& m___0);
#line 686
  strlcpy(namebuf, (char const   *)p, namebuflen);
#line 687
  xfree((void *)p);
#line 689
  tmp___2 = strlen((char const   *)msg);
#line 689
  buffer_append(& loginmsg, (void const   *)msg, tmp___2);
#line 690
  xfree((void *)msg);
#line 692
  *ptyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 692
  if (*ptyfd == -1) {
#line 694
    fatal("%s: receive fds failed", "mm_pty_allocate");
  } else {
#line 692
    *ttyfd = mm_receive_fd(pmonitor->m_recvfd);
#line 692
    if (*ttyfd == -1) {
#line 694
      fatal("%s: receive fds failed", "mm_pty_allocate");
    }
  }
#line 697
  return (1);
}
}
#line 700 "monitor_wrap.c"
void mm_session_pty_cleanup2(struct Session *s ) 
{ Buffer m___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 705
  if (s->ttyfd == -1) {
#line 706
    return;
  }
#line 707
  buffer_init(& m___0);
#line 708
  buffer_put_cstring(& m___0, (char const   *)(s->tty));
#line 709
  mm_request_send(pmonitor->m_recvfd, 27, & m___0);
#line 710
  buffer_free(& m___0);
#line 713
  tmp___1 = close(s->ptymaster);
#line 713
  if (tmp___1 < 0) {
#line 714
    tmp = __errno_location();
#line 714
    tmp___0 = strerror(*tmp);
#line 714
    error("close(s->ptymaster): %s", tmp___0);
  }
#line 717
  s->ttyfd = -1;
#line 718
  return;
}
}
#line 854 "monitor_wrap.c"
void mm_terminate(void) 
{ Buffer m___0 ;

  {
#line 859
  buffer_init(& m___0);
#line 860
  mm_request_send(pmonitor->m_recvfd, 58, & m___0);
#line 861
  buffer_free(& m___0);
#line 862
  return;
}
}
#line 864 "monitor_wrap.c"
int mm_ssh1_session_key(BIGNUM *num ) 
{ int rsafail ;
  Buffer m___0 ;
  u_int tmp ;

  {
#line 870
  buffer_init(& m___0);
#line 871
  buffer_put_bignum2(& m___0, (BIGNUM const   *)num);
#line 872
  mm_request_send(pmonitor->m_recvfd, 28, & m___0);
#line 874
  mm_request_receive_expect(pmonitor->m_recvfd, 29, & m___0);
#line 876
  tmp = buffer_get_int(& m___0);
#line 876
  rsafail = (int )tmp;
#line 877
  buffer_get_bignum2(& m___0, num);
#line 879
  buffer_free(& m___0);
#line 881
  return (rsafail);
}
}
#line 884 "monitor_wrap.c"
static void mm_chall_setup(char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                           u_int **echo_on ) 
{ void *tmp ;
  void *tmp___0 ;

  {
#line 888
  *name = xstrdup("");
#line 889
  *infotxt = xstrdup("");
#line 890
  *numprompts = 1U;
#line 891
  tmp = xcalloc(*numprompts, sizeof(char *));
#line 891
  *prompts = (char **)tmp;
#line 892
  tmp___0 = xcalloc(*numprompts, sizeof(u_int ));
#line 892
  *echo_on = (u_int *)tmp___0;
#line 893
  *(*echo_on + 0) = 0U;
#line 894
  return;
}
}
#line 896 "monitor_wrap.c"
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) 
{ Buffer m___0 ;
  u_int success ;
  char *challenge ;
  void *tmp ;

  {
#line 904
  debug3("%s: entering", "mm_bsdauth_query");
#line 906
  buffer_init(& m___0);
#line 907
  mm_request_send(pmonitor->m_recvfd, 12, & m___0);
#line 909
  mm_request_receive_expect(pmonitor->m_recvfd, 13, & m___0);
#line 911
  success = buffer_get_int(& m___0);
#line 912
  if (success == 0U) {
#line 913
    debug3("%s: no challenge", "mm_bsdauth_query");
#line 914
    buffer_free(& m___0);
#line 915
    return (-1);
  }
#line 919
  tmp = buffer_get_string(& m___0, (u_int *)((void *)0));
#line 919
  challenge = (char *)tmp;
#line 920
  buffer_free(& m___0);
#line 922
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
#line 923
  *(*prompts + 0) = challenge;
#line 925
  debug3("%s: received challenge: %s", "mm_bsdauth_query", challenge);
#line 927
  return (0);
}
}
#line 930 "monitor_wrap.c"
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) 
{ Buffer m___0 ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;

  {
#line 936
  debug3("%s: entering", "mm_bsdauth_respond");
#line 937
  if (numresponses != 1U) {
#line 938
    return (-1);
  }
#line 940
  buffer_init(& m___0);
#line 941
  buffer_put_cstring(& m___0, (char const   *)*(responses + 0));
#line 942
  mm_request_send(pmonitor->m_recvfd, 14, & m___0);
#line 944
  mm_request_receive_expect(pmonitor->m_recvfd, 15, & m___0);
#line 947
  tmp = buffer_get_int(& m___0);
#line 947
  authok = (int )tmp;
#line 948
  buffer_free(& m___0);
#line 950
  if (authok == 0) {
#line 950
    tmp___0 = -1;
  } else {
#line 950
    tmp___0 = 0;
  }
#line 950
  return (tmp___0);
}
}
#line 1014 "monitor_wrap.c"
void mm_ssh1_session_id(u_char *session_id___0 ) 
{ Buffer m___0 ;
  int i ;

  {
#line 1020
  debug3("%s entering", "mm_ssh1_session_id");
#line 1022
  buffer_init(& m___0);
#line 1023
  i = 0;
#line 1023
  while (i < 16) {
#line 1024
    buffer_put_char(& m___0, (int )*(session_id___0 + i));
#line 1023
    i ++;
  }
#line 1026
  mm_request_send(pmonitor->m_recvfd, 30, & m___0);
#line 1027
  buffer_free(& m___0);
#line 1028
  return;
}
}
#line 1030 "monitor_wrap.c"
int mm_auth_rsa_key_allowed(struct passwd *pw___0 , BIGNUM *client_n , Key **rkey ) 
{ Buffer m___0 ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int have_forced ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___2 ;

  {
#line 1037
  allowed = 0;
#line 1037
  have_forced = 0;
#line 1039
  debug3("%s entering", "mm_auth_rsa_key_allowed");
#line 1041
  buffer_init(& m___0);
#line 1042
  buffer_put_bignum2(& m___0, (BIGNUM const   *)client_n);
#line 1044
  mm_request_send(pmonitor->m_recvfd, 31, & m___0);
#line 1045
  mm_request_receive_expect(pmonitor->m_recvfd, 32, & m___0);
#line 1047
  tmp = buffer_get_int(& m___0);
#line 1047
  allowed = (int )tmp;
#line 1050
  auth_clear_options();
#line 1051
  tmp___0 = buffer_get_int(& m___0);
#line 1051
  have_forced = (int )tmp___0;
#line 1052
  if (have_forced) {
#line 1052
    forced_command = xstrdup("true");
  } else {
#line 1052
    forced_command = (char *)((void *)0);
  }
#line 1054
  if (allowed) {
#line 1054
    if ((unsigned int )rkey != (unsigned int )((void *)0)) {
#line 1055
      tmp___2 = buffer_get_string(& m___0, & blen);
#line 1055
      blob = (u_char *)tmp___2;
#line 1056
      key = key_from_blob((u_char const   *)blob, blen);
#line 1056
      if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 1057
        fatal("%s: key_from_blob failed", "mm_auth_rsa_key_allowed");
      }
#line 1058
      *rkey = key;
#line 1059
      xfree((void *)blob);
    }
  }
#line 1061
  mm_send_debug(& m___0);
#line 1062
  buffer_free(& m___0);
#line 1064
  return (allowed);
}
}
#line 1067 "monitor_wrap.c"
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) 
{ Buffer m___0 ;
  BIGNUM *challenge ;
  u_char *blob ;
  u_int blen ;
  int tmp ;

  {
#line 1075
  debug3("%s entering", "mm_auth_rsa_generate_challenge");
#line 1077
  challenge = BN_new();
#line 1077
  if ((unsigned int )challenge == (unsigned int )((void *)0)) {
#line 1078
    fatal("%s: BN_new failed", "mm_auth_rsa_generate_challenge");
  }
#line 1080
  key->type = 1;
#line 1081
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1081
  if (tmp == 0) {
#line 1082
    fatal("%s: key_to_blob failed", "mm_auth_rsa_generate_challenge");
  }
#line 1083
  key->type = 0;
#line 1085
  buffer_init(& m___0);
#line 1086
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1087
  xfree((void *)blob);
#line 1089
  mm_request_send(pmonitor->m_recvfd, 33, & m___0);
#line 1090
  mm_request_receive_expect(pmonitor->m_recvfd, 34, & m___0);
#line 1092
  buffer_get_bignum2(& m___0, challenge);
#line 1093
  buffer_free(& m___0);
#line 1095
  return (challenge);
}
}
#line 1098 "monitor_wrap.c"
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) 
{ Buffer m___0 ;
  u_char *blob ;
  u_int blen ;
  int success ;
  int tmp ;
  u_int tmp___0 ;

  {
#line 1104
  success = 0;
#line 1106
  debug3("%s entering", "mm_auth_rsa_verify_response");
#line 1108
  key->type = 1;
#line 1109
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
#line 1109
  if (tmp == 0) {
#line 1110
    fatal("%s: key_to_blob failed", "mm_auth_rsa_verify_response");
  }
#line 1111
  key->type = 0;
#line 1113
  buffer_init(& m___0);
#line 1114
  buffer_put_string(& m___0, (void const   *)blob, blen);
#line 1115
  buffer_put_string(& m___0, (void const   *)response, 16U);
#line 1116
  xfree((void *)blob);
#line 1118
  mm_request_send(pmonitor->m_recvfd, 35, & m___0);
#line 1119
  mm_request_receive_expect(pmonitor->m_recvfd, 36, & m___0);
#line 1121
  tmp___0 = buffer_get_int(& m___0);
#line 1121
  success = (int )tmp___0;
#line 1122
  buffer_free(& m___0);
#line 1124
  return (success);
}
}
#line 1 "kexdhs.o"
#line 48 "kexdhs.c"
void kexdh_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int hashlen ;
  u_int slen ;
  int kout ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  BIGNUM *tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
#line 51
  shared_secret = (BIGNUM *)((void *)0);
#line 51
  dh_client_pub = (BIGNUM *)((void *)0);
#line 54
  signature = (u_char *)((void *)0);
#line 54
  server_host_key_blob = (u_char *)((void *)0);
#line 59
  switch (kex->kex_type) {
  case 0: 
#line 61
  dh = dh_new_group1();
#line 62
  break;
  case 1: 
#line 64
  dh = dh_new_group14();
#line 65
  break;
  default: 
#line 67
  fatal("%s: Unexpected KEX type %d", "kexdh_server", kex->kex_type);
  }
#line 69
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 71
  debug("expecting SSH2_MSG_KEXDH_INIT");
#line 72
  packet_read_expect(30);
#line 74
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 75
    fatal("Cannot load hostkey");
  }
#line 76
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 77
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 78
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 81
  dh_client_pub = BN_new();
#line 81
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 82
    fatal("dh_client_pub == NULL");
  }
#line 83
  packet_get_bignum2(dh_client_pub);
#line 84
  while (1) {
#line 84
    tmp = packet_remaining();
#line 84
    _len = tmp;
#line 84
    if (_len > 0) {
#line 84
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexdhs.c",
            84);
#line 84
      packet_disconnect("Packet integrity error.");
    }
#line 84
    break;
  }
#line 99
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
#line 99
  if (! tmp___0) {
#line 100
    packet_disconnect("bad client public DH value");
  }
#line 102
  tmp___1 = DH_size((DH const   *)dh);
#line 102
  klen = (unsigned int )tmp___1;
#line 103
  tmp___2 = xmalloc(klen);
#line 103
  kbuf = (u_char *)tmp___2;
#line 104
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 104
  if (kout < 0) {
#line 105
    fatal("DH_compute_key: failed");
  }
#line 109
  shared_secret = BN_new();
#line 109
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 110
    fatal("kexdh_server: BN_new failed");
  }
#line 111
  tmp___3 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 111
  if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
#line 112
    fatal("kexdh_server: BN_bin2bn failed");
  }
#line 113
  memset((void *)kbuf, 0, klen);
#line 114
  xfree((void *)kbuf);
#line 116
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 119
  tmp___4 = buffer_len(& kex->my);
#line 119
  tmp___5 = buffer_ptr(& kex->my);
#line 119
  tmp___6 = buffer_len(& kex->peer);
#line 119
  tmp___7 = buffer_ptr(& kex->peer);
#line 119
  kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___7,
              (int )tmp___6, (char *)tmp___5, (int )tmp___4, server_host_key_blob,
              (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
#line 130
  BN_clear_free(dh_client_pub);
#line 133
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 134
    kex->session_id_len = hashlen;
#line 135
    tmp___8 = xmalloc(kex->session_id_len);
#line 135
    kex->session_id = (u_char *)tmp___8;
#line 136
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 140
  if (use_privsep) {
#line 140
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
  } else {
#line 140
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
  }
#line 145
  packet_start((unsigned char)31);
#line 146
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 147
  packet_put_bignum2(dh->pub_key);
#line 148
  packet_put_string((void const   *)signature, slen);
#line 149
  packet_send();
#line 151
  xfree((void *)signature);
#line 152
  xfree((void *)server_host_key_blob);
#line 154
  DH_free(dh);
#line 156
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 157
  BN_clear_free(shared_secret);
#line 158
  kex_finish(kex);
#line 159
  return;
}
}
#line 1 "kexgexs.o"
#line 51 "kexgexs.c"
void kexgex_server(Kex *kex ) 
{ BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int slen ;
  u_int hashlen ;
  int min ;
  int max ;
  int nbits ;
  int type ;
  int kout ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  BIGNUM *tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
#line 54
  shared_secret = (BIGNUM *)((void *)0);
#line 54
  dh_client_pub = (BIGNUM *)((void *)0);
#line 57
  signature = (u_char *)((void *)0);
#line 57
  server_host_key_blob = (u_char *)((void *)0);
#line 59
  min = -1;
#line 59
  max = -1;
#line 59
  nbits = -1;
#line 61
  if ((unsigned int )kex->load_host_key == (unsigned int )((void *)0)) {
#line 62
    fatal("Cannot load hostkey");
  }
#line 63
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
#line 64
  if ((unsigned int )server_host_key == (unsigned int )((void *)0)) {
#line 65
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
  }
#line 67
  type = packet_read();
#line 68
  switch (type) {
  case 34: 
#line 70
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
#line 71
  tmp = packet_get_int();
#line 71
  min = (int )tmp;
#line 72
  tmp___0 = packet_get_int();
#line 72
  nbits = (int )tmp___0;
#line 73
  tmp___1 = packet_get_int();
#line 73
  max = (int )tmp___1;
#line 74
  if (1024 > min) {
#line 74
    min = 1024;
  } else {
#line 74
    min = min;
  }
#line 75
  if (8192 < max) {
#line 75
    max = 8192;
  } else {
#line 75
    max = max;
  }
#line 76
  break;
  case 30: 
#line 78
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
#line 79
  tmp___2 = packet_get_int();
#line 79
  nbits = (int )tmp___2;
#line 80
  min = 1024;
#line 81
  max = 8192;
#line 83
  break;
  default: 
#line 85
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
#line 87
  while (1) {
#line 87
    tmp___3 = packet_remaining();
#line 87
    _len = tmp___3;
#line 87
    if (_len > 0) {
#line 87
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "kexgexs.c",
            87);
#line 87
      packet_disconnect("Packet integrity error.");
    }
#line 87
    break;
  }
#line 89
  if (max < min) {
#line 90
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
  } else {
#line 89
    if (nbits < min) {
#line 90
      fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    } else {
#line 89
      if (max < nbits) {
#line 90
        fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
      }
    }
  }
#line 94
  if (use_privsep) {
#line 94
    dh = mm_choose_dh(min, nbits, max);
  } else {
#line 94
    dh = choose_dh(min, nbits, max);
  }
#line 95
  if ((unsigned int )dh == (unsigned int )((void *)0)) {
#line 96
    packet_disconnect("Protocol error: no matching DH grp found");
  }
#line 98
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
#line 99
  packet_start((unsigned char)31);
#line 100
  packet_put_bignum2(dh->p);
#line 101
  packet_put_bignum2(dh->g);
#line 102
  packet_send();
#line 105
  packet_write_wait();
#line 108
  dh_gen_key(dh, (int )(kex->we_need * 8U));
#line 110
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
#line 111
  packet_read_expect(32);
#line 114
  dh_client_pub = BN_new();
#line 114
  if ((unsigned int )dh_client_pub == (unsigned int )((void *)0)) {
#line 115
    fatal("dh_client_pub == NULL");
  }
#line 116
  packet_get_bignum2(dh_client_pub);
#line 117
  while (1) {
#line 117
    tmp___6 = packet_remaining();
#line 117
    _len___0 = tmp___6;
#line 117
    if (_len___0 > 0) {
#line 117
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "kexgexs.c",
            117);
#line 117
      packet_disconnect("Packet integrity error.");
    }
#line 117
    break;
  }
#line 132
  tmp___7 = dh_pub_is_valid(dh, dh_client_pub);
#line 132
  if (! tmp___7) {
#line 133
    packet_disconnect("bad client public DH value");
  }
#line 135
  tmp___8 = DH_size((DH const   *)dh);
#line 135
  klen = (unsigned int )tmp___8;
#line 136
  tmp___9 = xmalloc(klen);
#line 136
  kbuf = (u_char *)tmp___9;
#line 137
  kout = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
#line 137
  if (kout < 0) {
#line 138
    fatal("DH_compute_key: failed");
  }
#line 142
  shared_secret = BN_new();
#line 142
  if ((unsigned int )shared_secret == (unsigned int )((void *)0)) {
#line 143
    fatal("kexgex_server: BN_new failed");
  }
#line 144
  tmp___10 = BN_bin2bn((unsigned char const   *)kbuf, kout, shared_secret);
#line 144
  if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
#line 145
    fatal("kexgex_server: BN_bin2bn failed");
  }
#line 146
  memset((void *)kbuf, 0, klen);
#line 147
  xfree((void *)kbuf);
#line 149
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
#line 151
  if (type == 30) {
#line 152
    max = -1;
#line 152
    min = max;
  }
#line 155
  tmp___11 = buffer_len(& kex->my);
#line 155
  tmp___12 = buffer_ptr(& kex->my);
#line 155
  tmp___13 = buffer_len(& kex->peer);
#line 155
  tmp___14 = buffer_ptr(& kex->peer);
#line 155
  kexgex_hash(kex->evp_md, kex->client_version_string, kex->server_version_string,
              (char *)tmp___14, (int )tmp___13, (char *)tmp___12, (int )tmp___11,
              server_host_key_blob, (int )sbloblen, min, nbits, max, dh->p, dh->g,
              dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
#line 169
  BN_clear_free(dh_client_pub);
#line 172
  if ((unsigned int )kex->session_id == (unsigned int )((void *)0)) {
#line 173
    kex->session_id_len = hashlen;
#line 174
    tmp___15 = xmalloc(kex->session_id_len);
#line 174
    kex->session_id = (u_char *)tmp___15;
#line 175
    memcpy((void * __restrict  )kex->session_id, (void const   * __restrict  )hash,
           kex->session_id_len);
  }
#line 179
  if (use_privsep) {
#line 179
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
  } else {
#line 179
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
  }
#line 184
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
#line 185
  packet_start((unsigned char)33);
#line 186
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
#line 187
  packet_put_bignum2(dh->pub_key);
#line 188
  packet_put_string((void const   *)signature, slen);
#line 189
  packet_send();
#line 191
  xfree((void *)signature);
#line 192
  xfree((void *)server_host_key_blob);
#line 194
  DH_free(dh);
#line 196
  kex_derive_keys(kex, hash, hashlen, shared_secret);
#line 197
  BN_clear_free(shared_secret);
#line 199
  kex_finish(kex);
#line 200
  return;
}
}
#line 1 "auth-krb5.o"
#line 1 "auth2-gss.o"
#line 1 "gss-serv.o"
#line 1 "gss-serv-krb5.o"
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "loginrec.o"
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 94 "loginrec.h"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 97
void login_set_current_time(struct logininfo *li ) ;
#line 109
int login_write(struct logininfo *li ) ;
#line 122
unsigned int login_get_lastlog_time(int uid ) ;
#line 125
char *line_fullname(char *dst , char const   *src , u_int dstsize ) ;
#line 126
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 127
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 192 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 193
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 205
int lastlog_write_entry(struct logininfo *li ) ;
#line 206
int syslogin_write_entry(struct logininfo *li ) ;
#line 208
int getlast_entry(struct logininfo *li ) ;
#line 209
int lastlog_get_entry(struct logininfo *li ) ;
#line 232 "loginrec.c"
int login_login(struct logininfo *li ) 
{ int tmp ;

  {
#line 235
  li->type = (short)7;
#line 236
  tmp = login_write(li);
#line 236
  return (tmp);
}
}
#line 249 "loginrec.c"
int login_logout(struct logininfo *li ) 
{ int tmp ;

  {
#line 252
  li->type = (short)8;
#line 253
  tmp = login_write(li);
#line 253
  return (tmp);
}
}
#line 274 "loginrec.c"
unsigned int login_get_lastlog_time(int uid ) 
{ struct logininfo li ;
  struct logininfo *tmp ;

  {
#line 279
  tmp = login_get_lastlog(& li, uid);
#line 279
  if (tmp) {
#line 280
    return (li.tv_sec);
  } else {
#line 282
    return (0U);
  }
}
}
#line 298 "loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int uid ) 
{ struct passwd *pw___0 ;
  int tmp ;

  {
#line 303
  memset((void *)li, '\000', sizeof(*li));
#line 304
  li->uid = uid;
#line 311
  pw___0 = getpwuid((unsigned int )uid);
#line 312
  if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 313
    fatal("%s: Cannot find account for uid %i", "login_get_lastlog", uid);
  }
#line 317
  strlcpy(li->username, (char const   *)pw___0->pw_name, sizeof(li->username));
#line 319
  tmp = getlast_entry(li);
#line 319
  if (tmp) {
#line 320
    return (li);
  } else {
#line 322
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 336 "loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ struct logininfo *newli ;
  void *tmp ;

  {
#line 342
  tmp = xmalloc(sizeof(*newli));
#line 342
  newli = (struct logininfo *)tmp;
#line 343
  login_init_entry(newli, pid, username, hostname, line);
#line 344
  return (newli);
}
}
#line 349 "loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 

  {
#line 352
  xfree((void *)li);
#line 353
  return;
}
}
#line 364 "loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ struct passwd *pw___0 ;

  {
#line 370
  memset((void *)li, 0, sizeof(*li));
#line 372
  li->pid = pid;
#line 375
  if (line) {
#line 376
    line_fullname(li->line, line, sizeof(li->line));
  }
#line 378
  if (username) {
#line 379
    strlcpy(li->username, username, sizeof(li->username));
#line 380
    pw___0 = getpwnam((char const   *)(li->username));
#line 381
    if ((unsigned int )pw___0 == (unsigned int )((void *)0)) {
#line 382
      fatal("%s: Cannot find user \"%s\"", "login_init_entry", li->username);
    }
#line 385
    li->uid = (int )pw___0->pw_uid;
  }
#line 388
  if (hostname) {
#line 389
    strlcpy(li->hostname, hostname, sizeof(li->hostname));
  }
#line 391
  return (1);
}
}
#line 401 "loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ struct timeval tv___0 ;

  {
#line 406
  gettimeofday((struct timeval * __restrict  )(& tv___0), (struct timezone * __restrict  )((void *)0));
#line 408
  li->tv_sec = (unsigned int )tv___0.tv_sec;
#line 409
  li->tv_usec = (unsigned int )tv___0.tv_usec;
#line 410
  return;
}
}
#line 413 "loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int sa_size ) 
{ unsigned int bufsize ;

  {
#line 417
  bufsize = sa_size;
#line 420
  if (sizeof(li->hostaddr) < sa_size) {
#line 421
    bufsize = sizeof(li->hostaddr);
  }
#line 423
  memcpy((void * __restrict  )(& li->hostaddr.sa), (void const   * __restrict  )sa,
         bufsize);
#line 424
  return;
}
}
#line 431 "loginrec.c"
int login_write(struct logininfo *li ) 
{ __uid_t tmp ;

  {
#line 435
  tmp = geteuid();
#line 435
  if (tmp != 0U) {
#line 436
    logit("Attempt to write login records by non-root user (aborting)");
#line 437
    return (1);
  }
#line 442
  login_set_current_time(li);
#line 444
  syslogin_write_entry(li);
#line 447
  if ((int )li->type == 7) {
#line 448
    lastlog_write_entry(li);
  }
#line 474
  return (0);
}
}
#line 505 "loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 509
  tmp = lastlog_get_entry(li);
#line 509
  return (tmp);
}
}
#line 554 "loginrec.c"
char *line_fullname(char *dst , char const   *src , u_int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;

  {
#line 557
  memset((void *)dst, '\000', dstsize);
#line 558
  if (0) {
#line 558
    if (0) {
#line 558
      __s1_len___0 = strlen(src);
#line 558
      __s2_len___0 = strlen("/dev/");
#line 558
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 558
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 558
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 558
            tmp___22 = 1;
          } else {
#line 558
            if (__s2_len___0 >= 4U) {
#line 558
              tmp___22 = 1;
            } else {
#line 558
              tmp___22 = 0;
            }
          }
        } else {
#line 558
          tmp___22 = 0;
        }
      }
#line 558
      if (tmp___22) {
#line 558
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 558
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 558
        tmp___18 = tmp___21;
      }
    } else {
#line 558
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 558
      tmp___18 = tmp___21;
    }
#line 558
    tmp___12 = tmp___18;
  } else {
#line 558
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 558
  if (tmp___12 == 0) {
#line 559
    strlcpy(dst, src, dstsize);
  } else {
#line 558
    tmp___25 = strlen(src);
#line 558
    if (dstsize < tmp___25 + 5U) {
#line 559
      strlcpy(dst, src, dstsize);
    } else {
#line 561
      strlcpy(dst, "/dev/", dstsize);
#line 562
      strlcat(dst, src, dstsize);
    }
  }
#line 564
  return (dst);
}
}
#line 568 "loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 571
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 572
  if (0) {
#line 572
    if (0) {
#line 572
      __s1_len___0 = strlen(src);
#line 572
      __s2_len___0 = strlen("/dev/");
#line 572
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 572
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 572
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 572
            tmp___22 = 1;
          } else {
#line 572
            if (__s2_len___0 >= 4U) {
#line 572
              tmp___22 = 1;
            } else {
#line 572
              tmp___22 = 0;
            }
          }
        } else {
#line 572
          tmp___22 = 0;
        }
      }
#line 572
      if (tmp___22) {
#line 572
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 572
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 572
        tmp___18 = tmp___21;
      }
    } else {
#line 572
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 572
      tmp___18 = tmp___21;
    }
#line 572
    tmp___12 = tmp___18;
  } else {
#line 572
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 572
  if (tmp___12 == 0) {
#line 573
    strlcpy(dst, src + 5, (unsigned int )dstsize);
  } else {
#line 575
    strlcpy(dst, src, (unsigned int )dstsize);
  }
#line 576
  return (dst);
}
}
#line 587 "loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ size_t len ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 592
  memset((void *)dst, '\000', (unsigned int )dstsize);
#line 595
  if (0) {
#line 595
    if (0) {
#line 595
      __s1_len___0 = strlen(src);
#line 595
      __s2_len___0 = strlen("/dev/");
#line 595
      if (! ((unsigned int )((void const   *)(src + 1)) - (unsigned int )((void const   *)src) == 1U)) {
        goto _L___2;
      } else {
#line 595
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 595
          if (! ((unsigned int )((void const   *)("/dev/" + 1)) - (unsigned int )((void const   *)"/dev/") == 1U)) {
#line 595
            tmp___22 = 1;
          } else {
#line 595
            if (__s2_len___0 >= 4U) {
#line 595
              tmp___22 = 1;
            } else {
#line 595
              tmp___22 = 0;
            }
          }
        } else {
#line 595
          tmp___22 = 0;
        }
      }
#line 595
      if (tmp___22) {
#line 595
        tmp___18 = __builtin_strcmp(src, "/dev/");
      } else {
#line 595
        tmp___21 = __builtin_strcmp(src, "/dev/");
#line 595
        tmp___18 = tmp___21;
      }
    } else {
#line 595
      tmp___21 = __builtin_strcmp(src, "/dev/");
#line 595
      tmp___18 = tmp___21;
    }
#line 595
    tmp___12 = tmp___18;
  } else {
#line 595
    tmp___12 = strncmp(src, "/dev/", 5U);
  }
#line 595
  if (tmp___12 == 0) {
#line 596
    src += 5;
  }
#line 603
  len = strlen(src);
#line 605
  if (len > 0U) {
#line 606
    if ((int )len - dstsize > 0) {
#line 607
      src += (int )len - dstsize;
    }
#line 610
    __builtin_strncpy(dst, src, (unsigned int )dstsize);
  }
#line 613
  return (dst);
}
}
#line 626 "loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 

  {
#line 630
  ut->ut_tv.tv_sec = (long )li->tv_sec;
#line 631
  ut->ut_tv.tv_usec = (long )li->tv_usec;
#line 635
  return;
}
}
#line 637 "loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ struct sockaddr_in6 *sa6 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  register unsigned int __v ;
  register unsigned int __x ;

  {
#line 645
  memset((void *)ut, '\000', sizeof(*ut));
#line 650
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
#line 655
  switch ((int )li->type) {
  case 7: 
#line 657
  ut->ut_type = (short)7;
#line 661
  break;
  case 8: 
#line 663
  ut->ut_type = (short)8;
#line 667
  break;
  }
#line 670
  set_utmp_time(li, ut);
#line 672
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
#line 675
  ut->ut_pid = li->pid;
#line 679
  if ((int )li->type == 8) {
#line 680
    return;
  }
#line 688
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 688
    tmp = sizeof(ut->ut_user);
  } else {
#line 688
    tmp = sizeof(li->username);
  }
#line 688
  __builtin_strncpy(ut->ut_user, (char const   *)(li->username), tmp);
#line 691
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 691
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 691
    tmp___0 = sizeof(li->hostname);
  }
#line 691
  __builtin_strncpy(ut->ut_host, (char const   *)(li->hostname), tmp___0);
#line 696
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 697
    ut->ut_addr_v6[0] = (int )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 701
  if ((int )li->hostaddr.sa.sa_family == 10) {
#line 702
    sa6 = (struct sockaddr_in6 *)(& li->hostaddr.sa);
#line 703
    memcpy((void * __restrict  )(ut->ut_addr_v6), (void const   * __restrict  )(sa6->sin6_addr.in6_u.u6_addr8),
           16U);
#line 704
    if (*((uint32_t const   *)(& sa6->sin6_addr) + 0) == 0U) {
#line 704
      if (*((uint32_t const   *)(& sa6->sin6_addr) + 1) == 0U) {
#line 704
        __x = 65535U;
#line 704
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 704
        if (*((uint32_t const   *)(& sa6->sin6_addr) + 2) == (uint32_t const   )__v) {
#line 705
          ut->ut_addr_v6[0] = ut->ut_addr_v6[3];
#line 706
          ut->ut_addr_v6[1] = 0;
#line 707
          ut->ut_addr_v6[2] = 0;
#line 708
          ut->ut_addr_v6[3] = 0;
        }
      }
    }
  }
#line 712
  return;
}
}
#line 1402 "loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ struct utmp *ut ;
  void *tmp ;

  {
#line 1407
  tmp = xmalloc(sizeof(*ut));
#line 1407
  ut = (struct utmp *)tmp;
#line 1408
  construct_utmp(li, ut);
#line 1409
  login((struct utmp  const  *)ut);
#line 1410
  free((void *)ut);
#line 1412
  return (1);
}
}
#line 1415 "loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ char line[32] ;
  int tmp ;

  {
#line 1421
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
#line 1423
  tmp = logout((char const   *)(line));
#line 1423
  if (tmp) {
#line 1427
    logwtmp((char const   *)(line), "", "");
  } else {
#line 1424
    logit("%s: logout() returned an error", "syslogin_perform_logout");
  }
#line 1434
  return (1);
}
}
#line 1437 "loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1440
  switch ((int )li->type) {
  case 7: 
#line 1442
  tmp = syslogin_perform_login(li);
#line 1442
  return (tmp);
  case 8: 
#line 1444
  tmp___0 = syslogin_perform_logout(li);
#line 1444
  return (tmp___0);
  default: 
#line 1446
  logit("%s: Invalid type field", "syslogin_write_entry");
#line 1447
  return (0);
  }
}
}
#line 1463 "loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1467
  memset((void *)last, '\000', sizeof(*last));
#line 1469
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
#line 1470
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1470
    tmp = sizeof(last->ll_host);
  } else {
#line 1470
    tmp = sizeof(li->hostname);
  }
#line 1470
  strlcpy(last->ll_host, (char const   *)(li->hostname), tmp);
#line 1472
  last->ll_time = (long )li->tv_sec;
#line 1473
  return;
}
}
#line 1475 "loginrec.c"
static int lastlog_filetype(char *filename ) 
{ struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1480
  tmp___1 = stat((char const   * __restrict  )"/var/log/lastlog", (struct stat * __restrict  )(& st));
#line 1480
  if (tmp___1 != 0) {
#line 1481
    tmp = __errno_location();
#line 1481
    tmp___0 = strerror(*tmp);
#line 1481
    logit("%s: Couldn\'t stat %s: %s", "lastlog_filetype", "/var/log/lastlog", tmp___0);
#line 1483
    return (0);
  }
#line 1485
  if ((st.st_mode & 61440U) == 16384U) {
#line 1486
    return (2);
  } else {
#line 1487
    if ((st.st_mode & 61440U) == 32768U) {
#line 1488
      return (1);
    } else {
#line 1490
      return (3);
    }
  }
}
}
#line 1495 "loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off64_t tmp___3 ;

  {
#line 1502
  type = lastlog_filetype((char *)"/var/log/lastlog");
#line 1503
  switch (type) {
  case 1: 
#line 1505
  strlcpy(lastlog_file, "/var/log/lastlog", sizeof(lastlog_file));
#line 1507
  break;
  case 2: 
#line 1509
  snprintf((char * __restrict  )(lastlog_file), sizeof(lastlog_file), (char const   * __restrict  )"%s/%s",
           "/var/log/lastlog", li->username);
#line 1511
  break;
  default: 
#line 1513
  logit("%s: %.100s is not a file or directory!", "lastlog_openseek", "/var/log/lastlog");
#line 1515
  return (0);
  }
#line 1518
  *fd = open((char const   *)(lastlog_file), filemode, 384);
#line 1519
  if (*fd < 0) {
#line 1520
    tmp = __errno_location();
#line 1520
    tmp___0 = strerror(*tmp);
#line 1520
    debug("%s: Couldn\'t open %s: %s", "lastlog_openseek", lastlog_file, tmp___0);
#line 1522
    return (0);
  }
#line 1525
  if (type == 1) {
#line 1527
    offset = (long long )((unsigned long )((long )li->uid) * (unsigned long )sizeof(struct lastlog ));
#line 1529
    tmp___3 = lseek(*fd, offset, 0);
#line 1529
    if (tmp___3 != offset) {
#line 1530
      tmp___1 = __errno_location();
#line 1530
      tmp___2 = strerror(*tmp___1);
#line 1530
      logit("%s: %s->lseek(): %s", "lastlog_openseek", lastlog_file, tmp___2);
#line 1532
      return (0);
    }
  }
#line 1536
  return (1);
}
}
#line 1539 "loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 1546
  lastlog_construct(li, & last);
#line 1548
  tmp = lastlog_openseek(li, & fd, 66);
#line 1548
  if (! tmp) {
#line 1549
    return (0);
  }
#line 1552
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& last),
                     sizeof(last));
#line 1552
  if (tmp___2 != sizeof(last)) {
#line 1553
    close(fd);
#line 1554
    tmp___0 = __errno_location();
#line 1554
    tmp___1 = strerror(*tmp___0);
#line 1554
    logit("%s: Error writing to %s: %s", "lastlog_perform_login", "/var/log/lastlog",
          tmp___1);
#line 1556
    return (0);
  }
#line 1559
  close(fd);
#line 1560
  return (1);
}
}
#line 1563 "loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ int tmp ;

  {
#line 1566
  switch ((int )li->type) {
  case 7: 
#line 1568
  tmp = lastlog_perform_login(li);
#line 1568
  return (tmp);
  default: 
#line 1570
  logit("%s: Invalid type field", "lastlog_write_entry");
#line 1571
  return (0);
  }
}
}
#line 1575 "loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ unsigned int tmp ;

  {
#line 1578
  line_fullname(li->line, (char const   *)(last->ll_line), sizeof(li->line));
#line 1579
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1579
    tmp = sizeof(li->hostname);
  } else {
#line 1579
    tmp = sizeof(last->ll_host);
  }
#line 1579
  strlcpy(li->hostname, (char const   *)(last->ll_host), tmp);
#line 1581
  li->tv_sec = (unsigned int )last->ll_time;
#line 1582
  return;
}
}
#line 1584 "loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ struct lastlog last ;
  int fd ;
  int ret___0 ;
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 1590
  tmp = lastlog_openseek(li, & fd, 0);
#line 1590
  if (! tmp) {
#line 1591
    return (0);
  }
#line 1593
  tmp___0 = atomicio(& read, fd, (void *)(& last), sizeof(last));
#line 1593
  ret___0 = (int )tmp___0;
#line 1594
  close(fd);
#line 1596
  switch (ret___0) {
  case 0: 
#line 1598
  memset((void *)(& last), '\000', sizeof(last));
  case sizeof(last): 
#line 1601
  lastlog_populate_entry(li, & last);
#line 1602
  return (1);
  case -1: 
#line 1604
  tmp___1 = __errno_location();
#line 1604
  tmp___2 = strerror(*tmp___1);
#line 1604
  error("%s: Error reading from %s: %s", "lastlog_get_entry", "/var/log/lastlog",
        tmp___2);
#line 1606
  return (0);
  default: 
#line 1608
  error("%s: Error reading from %s: Expecting %d, got %d", "lastlog_get_entry", "/var/log/lastlog",
        (int )sizeof(last), ret___0);
#line 1610
  return (0);
  }
#line 1614
  return (0);
}
}
#line 1626 "loginrec.c"
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) 
{ int fd ;
  struct utmp ut ;
  struct sockaddr_storage from ;
  socklen_t fromlen ;
  struct sockaddr_in *a4 ;
  struct sockaddr_in6 *a6 ;
  time_t t ;
  struct stat fst ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;

  {
#line 1633
  fromlen = sizeof(from);
#line 1639
  tmp = geteuid();
#line 1639
  if (tmp != 0U) {
#line 1640
    return;
  }
#line 1641
  fd = open("/var/log/btmp", 1025);
#line 1641
  if (fd < 0) {
#line 1642
    tmp___0 = __errno_location();
#line 1642
    tmp___1 = strerror(*tmp___0);
#line 1642
    debug("Unable to open the btmp file %s: %s", "/var/log/btmp", tmp___1);
#line 1644
    return;
  }
#line 1646
  tmp___4 = fstat(fd, & fst);
#line 1646
  if (tmp___4 < 0) {
#line 1647
    tmp___2 = __errno_location();
#line 1647
    tmp___3 = strerror(*tmp___2);
#line 1647
    logit("%s: fstat of %s failed: %s", "record_failed_login", "/var/log/btmp", tmp___3);
    goto out;
  }
#line 1651
  if (fst.st_mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3))) {
#line 1652
    logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
    goto out;
  } else {
#line 1651
    if (fst.st_uid != 0U) {
#line 1652
      logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
      goto out;
    }
  }
#line 1657
  memset((void *)(& ut), 0, sizeof(ut));
#line 1659
  __builtin_strncpy(ut.ut_user, username, sizeof(ut.ut_user));
#line 1660
  strlcpy(ut.ut_line, "ssh:notty", sizeof(ut.ut_line));
#line 1662
  time(& t);
#line 1663
  ut.ut_tv.tv_sec = t;
#line 1664
  ut.ut_type = (short)6;
#line 1665
  ut.ut_pid = getpid();
#line 1668
  __builtin_strncpy(ut.ut_host, hostname, sizeof(ut.ut_host));
#line 1670
  tmp___7 = packet_connection_is_on_socket();
#line 1670
  if (tmp___7) {
#line 1670
    tmp___8 = packet_get_connection_in();
#line 1670
    tmp___9 = getpeername(tmp___8, (struct sockaddr * __restrict  )((struct sockaddr *)(& from)),
                          (socklen_t * __restrict  )(& fromlen));
#line 1670
    if (tmp___9 == 0) {
#line 1673
      ipv64_normalise_mapped(& from, & fromlen);
#line 1674
      if ((int )from.ss_family == 2) {
#line 1675
        a4 = (struct sockaddr_in *)(& from);
#line 1676
        if (sizeof(ut.ut_addr_v6[0]) < sizeof(a4->sin_addr)) {
#line 1676
          tmp___5 = sizeof(ut.ut_addr_v6[0]);
        } else {
#line 1676
          tmp___5 = sizeof(a4->sin_addr);
        }
#line 1676
        memcpy((void * __restrict  )(& ut.ut_addr_v6[0]), (void const   * __restrict  )(& a4->sin_addr),
               tmp___5);
      }
#line 1680
      if ((int )from.ss_family == 10) {
#line 1681
        a6 = (struct sockaddr_in6 *)(& from);
#line 1682
        if (sizeof(ut.ut_addr_v6) < sizeof(a6->sin6_addr)) {
#line 1682
          tmp___6 = sizeof(ut.ut_addr_v6);
        } else {
#line 1682
          tmp___6 = sizeof(a6->sin6_addr);
        }
#line 1682
        memcpy((void * __restrict  )(& ut.ut_addr_v6), (void const   * __restrict  )(& a6->sin6_addr),
               tmp___6);
      }
    }
  }
#line 1688
  tmp___12 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& ut),
                      sizeof(ut));
#line 1688
  if (tmp___12 != sizeof(ut)) {
#line 1689
    tmp___10 = __errno_location();
#line 1689
    tmp___11 = strerror(*tmp___10);
#line 1689
    error("Failed to write to %s: %s", "/var/log/btmp", tmp___11);
  }
  out: 
#line 1693
  close(fd);
#line 1694
  return;
}
}
#line 1 "auth-pam.o"
#line 1 "auth-shadow.o"
#line 55 "auth-shadow.c"
int auth_shadow_acctexpired(struct spwd *spw ) 
{ time_t today ;
  int daysleft ;
  char buf___1[256] ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 62
  tmp = time((time_t *)((void *)0));
#line 62
  today = tmp / 86400L;
#line 63
  daysleft = (int )(spw->sp_expire - today);
#line 64
  debug3("%s: today %d sp_expire %d days left %d", "auth_shadow_acctexpired", (int )today,
         (int )spw->sp_expire, daysleft);
#line 67
  if (spw->sp_expire == -1L) {
#line 68
    debug3("account expiration disabled");
  } else {
#line 69
    if (daysleft < 0) {
#line 70
      logit("Account %.100s has expired", spw->sp_namp);
#line 71
      return (1);
    } else {
#line 72
      if ((long )daysleft <= spw->sp_warn) {
#line 73
        debug3("account will expire in %d days", daysleft);
#line 74
        if (daysleft == 1) {
#line 74
          tmp___0 = "";
        } else {
#line 74
          tmp___0 = "s";
        }
#line 74
        snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your account will expire in %d day%s.\n",
                 daysleft, tmp___0);
#line 77
        tmp___1 = strlen((char const   *)(buf___1));
#line 77
        buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
      }
    }
  }
#line 80
  return (0);
}
}
#line 87 "auth-shadow.c"
int auth_shadow_pwexpired(Authctxt *ctxt ) 
{ struct spwd *spw ;
  char const   *user ;
  char buf___1[256] ;
  time_t today ;
  int daysleft ;
  int disabled ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 90
  spw = (struct spwd *)((void *)0);
#line 91
  user = (char const   *)(ctxt->pw)->pw_name;
#line 94
  disabled = 0;
#line 96
  spw = getspnam((char const   *)((char *)user));
#line 96
  if ((unsigned int )spw == (unsigned int )((void *)0)) {
#line 97
    error("Could not get shadow information for %.100s", user);
#line 98
    return (0);
  }
#line 101
  tmp = time((time_t *)((void *)0));
#line 101
  today = tmp / 86400L;
#line 102
  debug3("%s: today %d sp_lstchg %d sp_max %d", "auth_shadow_pwexpired", (int )today,
         (int )spw->sp_lstchg, (int )spw->sp_max);
#line 121
  daysleft = (int )((spw->sp_lstchg + spw->sp_max) - today);
#line 122
  if (disabled) {
#line 123
    debug3("password expiration disabled");
  } else {
#line 124
    if (spw->sp_lstchg == 0L) {
#line 125
      logit("User %.100s password has expired (root forced)", user);
#line 126
      return (1);
    } else {
#line 127
      if (spw->sp_max == -1L) {
#line 128
        debug3("password expiration disabled");
      } else {
#line 129
        if (daysleft < 0) {
#line 130
          logit("User %.100s password has expired (password aged)", user);
#line 131
          return (1);
        } else {
#line 132
          if ((long )daysleft <= spw->sp_warn) {
#line 133
            debug3("password will expire in %d days", daysleft);
#line 134
            if (daysleft == 1) {
#line 134
              tmp___0 = "";
            } else {
#line 134
              tmp___0 = "s";
            }
#line 134
            snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"Your password will expire in %d day%s.\n",
                     daysleft, tmp___0);
#line 137
            tmp___1 = strlen((char const   *)(buf___1));
#line 137
            buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
          }
        }
      }
    }
  }
#line 140
  return (0);
}
}
#line 1 "auth-sia.o"
#line 1 "md5crypt.o"
#line 1 "audit.o"
#line 1 "audit-bsm.o"
#line 1 "platform.o"
#line 24 "platform.c"
void platform_pre_fork(void) 
{ 

  {
#line 30
  return;
}
}
#line 32 "platform.c"
void platform_post_fork_parent(pid_t child_pid ) 
{ 

  {
#line 38
  return;
}
}
#line 40 "platform.c"
void platform_post_fork_child(void) 
{ 

  {
#line 46
  return;
}
}
#line 1 "sftp-server.o"
#line 140 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval  const  *__tvp )  __attribute__((__nonnull__(1))) ;
#line 149
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval  const  *__tvp ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 293
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 156 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 200 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 236
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 438 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 756
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
#line 769
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
#line 775
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   * __restrict  __path ,
                                                      char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 952
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off64_t __length )  __asm__("truncate64") __attribute__((__nonnull__(1))) ;
#line 97 "sftp.h"
 __attribute__((__noreturn__)) void sftp_server_cleanup_exit(int i ) ;
#line 44 "sftp-common.h"
void attrib_clear(Attrib *a___0 ) ;
#line 45
void stat_to_attrib(struct stat  const  *st , Attrib *a___0 ) ;
#line 47
Attrib *decode_attrib(Buffer *b ) ;
#line 48
void encode_attrib(Buffer *b , Attrib const   *a___0 ) ;
#line 49
char *ls_file(char const   *name , struct stat  const  *st , int remote___0 ) ;
#line 54 "sftp-server.c"
LogLevel log_level  =    2;
#line 57 "sftp-server.c"
struct passwd *pw  =    (struct passwd *)((void *)0);
#line 58 "sftp-server.c"
char *client_addr  =    (char *)((void *)0);
#line 61 "sftp-server.c"
Buffer iqueue  ;
#line 62 "sftp-server.c"
Buffer oqueue  ;
#line 65 "sftp-server.c"
int version  ;
#line 77 "sftp-server.c"
static int errno_to_portable(int unixerrno ) 
{ int ret___0 ;

  {
#line 80
  ret___0 = 0;
#line 82
  switch (unixerrno) {
  case 0: 
#line 84
  ret___0 = 0;
#line 85
  break;
  case 2: 
  case 20: 
  case 9: 
  case 40: 
#line 90
  ret___0 = 2;
#line 91
  break;
  case 1: 
  case 13: 
  case 14: 
#line 95
  ret___0 = 3;
#line 96
  break;
  case 36: 
  case 22: 
#line 99
  ret___0 = 5;
#line 100
  break;
  default: 
#line 102
  ret___0 = 4;
#line 103
  break;
  }
#line 105
  return (ret___0);
}
}
#line 108 "sftp-server.c"
static int flags_from_portable(int pflags ) 
{ int flags ;

  {
#line 111
  flags = 0;
#line 113
  if (pflags & 1) {
#line 113
    if (pflags & 2) {
#line 115
      flags = 2;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 116
    if (pflags & 1) {
#line 117
      flags = 0;
    } else {
#line 118
      if (pflags & 2) {
#line 119
        flags = 1;
      }
    }
  }
#line 121
  if (pflags & 8) {
#line 122
    flags |= 64;
  }
#line 123
  if (pflags & 16) {
#line 124
    flags |= 512;
  }
#line 125
  if (pflags & 32) {
#line 126
    flags |= 128;
  }
#line 127
  return (flags);
}
}
#line 133 "sftp-server.c"
static char ret[128]  ;
#line 130 "sftp-server.c"
static char const   *string_from_portable(int pflags ) 
{ 

  {
#line 135
  ret[0] = (char )'\000';
#line 143
  if (pflags & 1) {
#line 144
    if ((int )ret[0] != 0) {
#line 144
      strlcat(ret, ",", sizeof(ret));
    }
#line 144
    strlcat(ret, "READ", sizeof(ret));
  }
#line 145
  if (pflags & 2) {
#line 146
    if ((int )ret[0] != 0) {
#line 146
      strlcat(ret, ",", sizeof(ret));
    }
#line 146
    strlcat(ret, "WRITE", sizeof(ret));
  }
#line 147
  if (pflags & 8) {
#line 148
    if ((int )ret[0] != 0) {
#line 148
      strlcat(ret, ",", sizeof(ret));
    }
#line 148
    strlcat(ret, "CREATE", sizeof(ret));
  }
#line 149
  if (pflags & 16) {
#line 150
    if ((int )ret[0] != 0) {
#line 150
      strlcat(ret, ",", sizeof(ret));
    }
#line 150
    strlcat(ret, "TRUNCATE", sizeof(ret));
  }
#line 151
  if (pflags & 32) {
#line 152
    if ((int )ret[0] != 0) {
#line 152
      strlcat(ret, ",", sizeof(ret));
    }
#line 152
    strlcat(ret, "EXCL", sizeof(ret));
  }
#line 154
  return ((char const   *)(ret));
}
}
#line 157 "sftp-server.c"
static Attrib *get_attrib(void) 
{ Attrib *tmp ;

  {
#line 160
  tmp = decode_attrib(& iqueue);
#line 160
  return (tmp);
}
}
#line 181 "sftp-server.c"
Handle *handles  =    (Handle *)((void *)0);
#line 182 "sftp-server.c"
u_int num_handles  =    (u_int )0;
#line 183 "sftp-server.c"
int first_unused_handle  =    -1;
#line 185 "sftp-server.c"
static void handle_unused(int i ) 
{ 

  {
#line 187
  (handles + i)->use = 0;
#line 188
  (handles + i)->next_unused = first_unused_handle;
#line 189
  first_unused_handle = i;
#line 190
  return;
}
}
#line 192 "sftp-server.c"
static int handle_new(int use , char const   *name , int fd , DIR *dirp ) 
{ int i ;
  void *tmp ;

  {
#line 197
  if (first_unused_handle == -1) {
#line 198
    if (num_handles + 1U <= num_handles) {
#line 199
      return (-1);
    }
#line 200
    num_handles ++;
#line 201
    tmp = xrealloc((void *)handles, num_handles, sizeof(Handle ));
#line 201
    handles = (Handle *)tmp;
#line 202
    handle_unused((int )(num_handles - 1U));
  }
#line 205
  i = first_unused_handle;
#line 206
  first_unused_handle = (handles + i)->next_unused;
#line 208
  (handles + i)->use = use;
#line 209
  (handles + i)->dirp = dirp;
#line 210
  (handles + i)->fd = fd;
#line 211
  (handles + i)->name = xstrdup(name);
#line 212
  (handles + i)->bytes_write = 0ULL;
#line 212
  (handles + i)->bytes_read = (handles + i)->bytes_write;
#line 214
  return (i);
}
}
#line 217 "sftp-server.c"
static int handle_is_ok(int i , int type ) 
{ int tmp ;

  {
#line 220
  if (i >= 0) {
#line 220
    if ((unsigned int )i < num_handles) {
#line 220
      if ((handles + i)->use == type) {
#line 220
        tmp = 1;
      } else {
#line 220
        tmp = 0;
      }
    } else {
#line 220
      tmp = 0;
    }
  } else {
#line 220
    tmp = 0;
  }
#line 220
  return (tmp);
}
}
#line 223 "sftp-server.c"
static int handle_to_string(int handle , char **stringp , int *hlenp ) 
{ void *tmp ;

  {
#line 226
  if ((unsigned int )stringp == (unsigned int )((void *)0)) {
#line 227
    return (-1);
  } else {
#line 226
    if ((unsigned int )hlenp == (unsigned int )((void *)0)) {
#line 227
      return (-1);
    }
  }
#line 228
  tmp = xmalloc(sizeof(int32_t ));
#line 228
  *stringp = (char *)tmp;
#line 229
  put_u32((void *)*stringp, (unsigned int )handle);
#line 230
  *hlenp = (int )sizeof(int32_t );
#line 231
  return (0);
}
}
#line 234 "sftp-server.c"
static int handle_from_string(char const   *handle , u_int hlen ) 
{ int val ;
  u_int32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 239
  if (hlen != sizeof(int32_t )) {
#line 240
    return (-1);
  }
#line 241
  tmp = get_u32((void const   *)handle);
#line 241
  val = (int )tmp;
#line 242
  tmp___0 = handle_is_ok(val, 2);
#line 242
  if (tmp___0) {
#line 244
    return (val);
  } else {
#line 242
    tmp___1 = handle_is_ok(val, 1);
#line 242
    if (tmp___1) {
#line 244
      return (val);
    }
  }
#line 245
  return (-1);
}
}
#line 248 "sftp-server.c"
static char *handle_to_name(int handle ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 251
  tmp = handle_is_ok(handle, 1);
#line 251
  if (tmp) {
#line 253
    return ((handles + handle)->name);
  } else {
#line 251
    tmp___0 = handle_is_ok(handle, 2);
#line 251
    if (tmp___0) {
#line 253
      return ((handles + handle)->name);
    }
  }
#line 254
  return ((char *)((void *)0));
}
}
#line 257 "sftp-server.c"
static DIR *handle_to_dir(int handle ) 
{ int tmp ;

  {
#line 260
  tmp = handle_is_ok(handle, 1);
#line 260
  if (tmp) {
#line 261
    return ((handles + handle)->dirp);
  }
#line 262
  return ((DIR *)((void *)0));
}
}
#line 265 "sftp-server.c"
static int handle_to_fd(int handle ) 
{ int tmp ;

  {
#line 268
  tmp = handle_is_ok(handle, 2);
#line 268
  if (tmp) {
#line 269
    return ((handles + handle)->fd);
  }
#line 270
  return (-1);
}
}
#line 273 "sftp-server.c"
static void handle_update_read(int handle , ssize_t bytes ) 
{ int tmp ;

  {
#line 276
  tmp = handle_is_ok(handle, 2);
#line 276
  if (tmp) {
#line 276
    if (bytes > 0) {
#line 277
      (handles + handle)->bytes_read += (u_int64_t )bytes;
    }
  }
#line 278
  return;
}
}
#line 280 "sftp-server.c"
static void handle_update_write(int handle , ssize_t bytes ) 
{ int tmp ;

  {
#line 283
  tmp = handle_is_ok(handle, 2);
#line 283
  if (tmp) {
#line 283
    if (bytes > 0) {
#line 284
      (handles + handle)->bytes_write += (u_int64_t )bytes;
    }
  }
#line 285
  return;
}
}
#line 287 "sftp-server.c"
static u_int64_t handle_bytes_read(int handle ) 
{ int tmp ;

  {
#line 290
  tmp = handle_is_ok(handle, 2);
#line 290
  if (tmp) {
#line 291
    return ((handles + handle)->bytes_read);
  }
#line 292
  return (0ULL);
}
}
#line 295 "sftp-server.c"
static u_int64_t handle_bytes_write(int handle ) 
{ int tmp ;

  {
#line 298
  tmp = handle_is_ok(handle, 2);
#line 298
  if (tmp) {
#line 299
    return ((handles + handle)->bytes_write);
  }
#line 300
  return (0ULL);
}
}
#line 303 "sftp-server.c"
static int handle_close(int handle ) 
{ int ret___0 ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 306
  ret___0 = -1;
#line 308
  tmp___1 = handle_is_ok(handle, 2);
#line 308
  if (tmp___1) {
#line 309
    ret___0 = close((handles + handle)->fd);
#line 310
    xfree((void *)(handles + handle)->name);
#line 311
    handle_unused(handle);
  } else {
#line 312
    tmp___0 = handle_is_ok(handle, 1);
#line 312
    if (tmp___0) {
#line 313
      ret___0 = closedir((handles + handle)->dirp);
#line 314
      xfree((void *)(handles + handle)->name);
#line 315
      handle_unused(handle);
    } else {
#line 317
      tmp = __errno_location();
#line 317
      *tmp = 2;
    }
  }
#line 319
  return (ret___0);
}
}
#line 322 "sftp-server.c"
static void handle_log_close(int handle , char *emsg ) 
{ u_int64_t tmp ;
  u_int64_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;

  {
#line 325
  tmp___7 = handle_is_ok(handle, 2);
#line 325
  if (tmp___7) {
#line 326
    tmp = handle_bytes_write(handle);
#line 326
    tmp___0 = handle_bytes_read(handle);
#line 326
    tmp___1 = handle_to_name(handle);
#line 326
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 326
      tmp___2 = "";
    } else {
#line 326
      tmp___2 = " ";
    }
#line 326
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 326
      tmp___3 = "";
    } else {
#line 326
      tmp___3 = (char const   *)emsg;
    }
#line 326
    logit("%s%sclose \"%s\" bytes read %llu written %llu", tmp___3, tmp___2, tmp___1,
          tmp___0, tmp);
  } else {
#line 332
    tmp___4 = handle_to_name(handle);
#line 332
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 332
      tmp___5 = "";
    } else {
#line 332
      tmp___5 = " ";
    }
#line 332
    if ((unsigned int )emsg == (unsigned int )((void *)0)) {
#line 332
      tmp___6 = "";
    } else {
#line 332
      tmp___6 = (char const   *)emsg;
    }
#line 332
    logit("%s%sclosedir \"%s\"", tmp___6, tmp___5, tmp___4);
  }
#line 336
  return;
}
}
#line 338 "sftp-server.c"
static void handle_log_exit(void) 
{ u_int i ;

  {
#line 343
  i = 0U;
#line 343
  while (i < num_handles) {
#line 344
    if ((handles + i)->use != 0) {
#line 345
      handle_log_close((int )i, (char *)"forced");
    }
#line 343
    i ++;
  }
#line 346
  return;
}
}
#line 348 "sftp-server.c"
static int get_handle(void) 
{ char *handle ;
  int val ;
  u_int hlen ;
  void *tmp ;

  {
#line 352
  val = -1;
#line 355
  tmp = buffer_get_string(& iqueue, & hlen);
#line 355
  handle = (char *)tmp;
#line 356
  if (hlen < 256U) {
#line 357
    val = handle_from_string((char const   *)handle, hlen);
  }
#line 358
  xfree((void *)handle);
#line 359
  return (val);
}
}
#line 364 "sftp-server.c"
static void send_msg(Buffer *m___0 ) 
{ int mlen ;
  u_int tmp ;
  void *tmp___0 ;

  {
#line 367
  tmp = buffer_len(m___0);
#line 367
  mlen = (int )tmp;
#line 369
  buffer_put_int(& oqueue, (unsigned int )mlen);
#line 370
  tmp___0 = buffer_ptr(m___0);
#line 370
  buffer_append(& oqueue, (void const   *)tmp___0, (unsigned int )mlen);
#line 371
  buffer_consume(m___0, (unsigned int )mlen);
#line 372
  return;
}
}
#line 374 "sftp-server.c"
static char const   *status_to_message(u_int32_t status ) 
{ char const   *status_messages[10] ;
  u_int32_t tmp ;

  {
#line 377
  status_messages[0] = "Success";
#line 377
  status_messages[1] = "End of file";
#line 377
  status_messages[2] = "No such file";
#line 377
  status_messages[3] = "Permission denied";
#line 377
  status_messages[4] = "Failure";
#line 377
  status_messages[5] = "Bad message";
#line 377
  status_messages[6] = "No connection";
#line 377
  status_messages[7] = "Connection lost";
#line 377
  status_messages[8] = "Operation unsupported";
#line 377
  status_messages[9] = "Unknown error";
#line 389
  if (status < 8U) {
#line 389
    tmp = status;
  } else {
#line 389
    tmp = 8U;
  }
#line 389
  return (status_messages[tmp]);
}
}
#line 392 "sftp-server.c"
static void send_status(u_int32_t id , u_int32_t status ) 
{ Buffer msg ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 397
  debug3("request %u: sent status %u", id, status);
#line 398
  if ((int )log_level > 4) {
#line 400
    tmp = status_to_message(status);
#line 400
    logit("sent status %s", tmp);
  } else {
#line 398
    if (status != 0U) {
#line 398
      if (status != 1U) {
#line 400
        tmp = status_to_message(status);
#line 400
        logit("sent status %s", tmp);
      }
    }
  }
#line 401
  buffer_init(& msg);
#line 402
  buffer_put_char(& msg, 101);
#line 403
  buffer_put_int(& msg, id);
#line 404
  buffer_put_int(& msg, status);
#line 405
  if (version >= 3) {
#line 406
    tmp___0 = status_to_message(status);
#line 406
    buffer_put_cstring(& msg, tmp___0);
#line 407
    buffer_put_cstring(& msg, "");
  }
#line 409
  send_msg(& msg);
#line 410
  buffer_free(& msg);
#line 411
  return;
}
}
#line 412 "sftp-server.c"
static void send_data_or_handle(char type , u_int32_t id , char const   *data , int dlen ) 
{ Buffer msg ;

  {
#line 417
  buffer_init(& msg);
#line 418
  buffer_put_char(& msg, (int )type);
#line 419
  buffer_put_int(& msg, id);
#line 420
  buffer_put_string(& msg, (void const   *)data, (unsigned int )dlen);
#line 421
  send_msg(& msg);
#line 422
  buffer_free(& msg);
#line 423
  return;
}
}
#line 425 "sftp-server.c"
static void send_data(u_int32_t id , char const   *data , int dlen ) 
{ 

  {
#line 428
  debug("request %u: sent data len %d", id, dlen);
#line 429
  send_data_or_handle((char)103, id, data, dlen);
#line 430
  return;
}
}
#line 432 "sftp-server.c"
static void send_handle(u_int32_t id , int handle ) 
{ char *string ;
  int hlen ;

  {
#line 438
  handle_to_string(handle, & string, & hlen);
#line 439
  debug("request %u: sent handle handle %d", id, handle);
#line 440
  send_data_or_handle((char)102, id, (char const   *)string, hlen);
#line 441
  xfree((void *)string);
#line 442
  return;
}
}
#line 444 "sftp-server.c"
static void send_names(u_int32_t id , int count , Stat const   *stats ) 
{ Buffer msg ;
  int i ;

  {
#line 450
  buffer_init(& msg);
#line 451
  buffer_put_char(& msg, 104);
#line 452
  buffer_put_int(& msg, id);
#line 453
  buffer_put_int(& msg, (unsigned int )count);
#line 454
  debug("request %u: sent names count %d", id, count);
#line 455
  i = 0;
#line 455
  while (i < count) {
#line 456
    buffer_put_cstring(& msg, (char const   *)(stats + i)->name);
#line 457
    buffer_put_cstring(& msg, (char const   *)(stats + i)->long_name);
#line 458
    encode_attrib(& msg, & (stats + i)->attrib);
#line 455
    i ++;
  }
#line 460
  send_msg(& msg);
#line 461
  buffer_free(& msg);
#line 462
  return;
}
}
#line 464 "sftp-server.c"
static void send_attrib(u_int32_t id , Attrib const   *a___0 ) 
{ Buffer msg ;

  {
#line 469
  debug("request %u: sent attrib have 0x%x", id, a___0->flags);
#line 470
  buffer_init(& msg);
#line 471
  buffer_put_char(& msg, 105);
#line 472
  buffer_put_int(& msg, id);
#line 473
  encode_attrib(& msg, a___0);
#line 474
  send_msg(& msg);
#line 475
  buffer_free(& msg);
#line 476
  return;
}
}
#line 480 "sftp-server.c"
static void process_init(void) 
{ Buffer msg ;
  u_int tmp ;

  {
#line 485
  tmp = buffer_get_int(& iqueue);
#line 485
  version = (int )tmp;
#line 486
  verbose("received client version %d", version);
#line 487
  buffer_init(& msg);
#line 488
  buffer_put_char(& msg, 2);
#line 489
  buffer_put_int(& msg, 3U);
#line 491
  buffer_put_cstring(& msg, "posix-rename@openssh.com");
#line 492
  buffer_put_cstring(& msg, "1");
#line 493
  send_msg(& msg);
#line 494
  buffer_free(& msg);
#line 495
  return;
}
}
#line 497 "sftp-server.c"
static void process_open(void) 
{ u_int32_t id ;
  u_int32_t pflags ;
  Attrib *a___0 ;
  char *name ;
  int handle ;
  int fd ;
  int flags ;
  int mode ;
  int status ;
  void *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;

  {
#line 503
  status = 4;
#line 505
  id = buffer_get_int(& iqueue);
#line 506
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 506
  name = (char *)tmp;
#line 507
  pflags = buffer_get_int(& iqueue);
#line 508
  debug3("request %u: open flags %d", id, pflags);
#line 509
  a___0 = get_attrib();
#line 510
  flags = flags_from_portable((int )pflags);
#line 511
  if (a___0->flags & 4U) {
#line 511
    mode = (int )a___0->perm;
  } else {
#line 511
    mode = 438;
  }
#line 512
  tmp___0 = string_from_portable((int )pflags);
#line 512
  logit("open \"%s\" flags %s mode 0%o", name, tmp___0, mode);
#line 514
  fd = open((char const   *)name, flags, mode);
#line 515
  if (fd < 0) {
#line 516
    tmp___1 = __errno_location();
#line 516
    status = errno_to_portable(*tmp___1);
  } else {
#line 518
    handle = handle_new(2, (char const   *)name, fd, (DIR *)((void *)0));
#line 519
    if (handle < 0) {
#line 520
      close(fd);
    } else {
#line 522
      send_handle(id, handle);
#line 523
      status = 0;
    }
  }
#line 526
  if (status != 0) {
#line 527
    send_status(id, (unsigned int )status);
  }
#line 528
  xfree((void *)name);
#line 529
  return;
}
}
#line 531 "sftp-server.c"
static void process_close(void) 
{ u_int32_t id ;
  int handle ;
  int ret___0 ;
  int status ;
  int *tmp___1 ;

  {
#line 535
  status = 4;
#line 537
  id = buffer_get_int(& iqueue);
#line 538
  handle = get_handle();
#line 539
  debug3("request %u: close handle %u", id, handle);
#line 540
  handle_log_close(handle, (char *)((void *)0));
#line 541
  ret___0 = handle_close(handle);
#line 542
  if (ret___0 == -1) {
#line 542
    tmp___1 = __errno_location();
#line 542
    status = errno_to_portable(*tmp___1);
  } else {
#line 542
    status = 0;
  }
#line 543
  send_status(id, (unsigned int )status);
#line 544
  return;
}
}
#line 546 "sftp-server.c"
static void process_read(void) 
{ char buf___1[65536] ;
  u_int32_t id ;
  u_int32_t len ;
  int handle ;
  int fd ;
  int ret___0 ;
  int status ;
  u_int64_t off ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  __off64_t tmp___2 ;

  {
#line 551
  status = 4;
#line 554
  id = buffer_get_int(& iqueue);
#line 555
  handle = get_handle();
#line 556
  off = buffer_get_int64(& iqueue);
#line 557
  len = buffer_get_int(& iqueue);
#line 559
  tmp = handle_to_name(handle);
#line 559
  debug("request %u: read \"%s\" (handle %d) off %llu len %d", id, tmp, handle, off,
        len);
#line 561
  if (len > sizeof(buf___1)) {
#line 562
    len = sizeof(buf___1);
#line 563
    debug2("read change len %d", len);
  }
#line 565
  fd = handle_to_fd(handle);
#line 566
  if (fd >= 0) {
#line 567
    tmp___2 = lseek(fd, (long long )off, 0);
#line 567
    if (tmp___2 < 0LL) {
#line 568
      error("process_read: seek failed");
#line 569
      tmp___0 = __errno_location();
#line 569
      status = errno_to_portable(*tmp___0);
    } else {
#line 571
      ret___0 = read(fd, (void *)(buf___1), len);
#line 572
      if (ret___0 < 0) {
#line 573
        tmp___1 = __errno_location();
#line 573
        status = errno_to_portable(*tmp___1);
      } else {
#line 574
        if (ret___0 == 0) {
#line 575
          status = 1;
        } else {
#line 577
          send_data(id, (char const   *)(buf___1), ret___0);
#line 578
          status = 0;
#line 579
          handle_update_read(handle, ret___0);
        }
      }
    }
  }
#line 583
  if (status != 0) {
#line 584
    send_status(id, (unsigned int )status);
  }
#line 585
  return;
}
}
#line 587 "sftp-server.c"
static void process_write(void) 
{ u_int32_t id ;
  u_int64_t off ;
  u_int len ;
  int handle ;
  int fd ;
  int ret___0 ;
  int status ;
  char *data ;
  void *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  __off64_t tmp___3 ;

  {
#line 593
  status = 4;
#line 596
  id = buffer_get_int(& iqueue);
#line 597
  handle = get_handle();
#line 598
  off = buffer_get_int64(& iqueue);
#line 599
  tmp = buffer_get_string(& iqueue, & len);
#line 599
  data = (char *)tmp;
#line 601
  tmp___0 = handle_to_name(handle);
#line 601
  debug("request %u: write \"%s\" (handle %d) off %llu len %d", id, tmp___0, handle,
        off, len);
#line 603
  fd = handle_to_fd(handle);
#line 604
  if (fd >= 0) {
#line 605
    tmp___3 = lseek(fd, (long long )off, 0);
#line 605
    if (tmp___3 < 0LL) {
#line 606
      tmp___1 = __errno_location();
#line 606
      status = errno_to_portable(*tmp___1);
#line 607
      error("process_write: seek failed");
    } else {
#line 610
      ret___0 = write(fd, (void const   *)data, len);
#line 611
      if (ret___0 < 0) {
#line 612
        error("process_write: write failed");
#line 613
        tmp___2 = __errno_location();
#line 613
        status = errno_to_portable(*tmp___2);
      } else {
#line 614
        if ((unsigned int )ret___0 == len) {
#line 615
          status = 0;
#line 616
          handle_update_write(handle, ret___0);
        } else {
#line 618
          debug2("nothing at all written");
        }
      }
    }
  }
#line 622
  send_status(id, (unsigned int )status);
#line 623
  xfree((void *)data);
#line 624
  return;
}
}
#line 626 "sftp-server.c"
static void process_do_stat(int do_lstat ) 
{ Attrib a___0 ;
  struct stat st ;
  u_int32_t id ;
  char *name ;
  int ret___0 ;
  int status ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___4 ;

  {
#line 633
  status = 4;
#line 635
  id = buffer_get_int(& iqueue);
#line 636
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 636
  name = (char *)tmp;
#line 637
  if (do_lstat) {
#line 637
    tmp___0 = "l";
  } else {
#line 637
    tmp___0 = "";
  }
#line 637
  debug3("request %u: %sstat", id, tmp___0);
#line 638
  if (do_lstat) {
#line 638
    tmp___1 = "l";
  } else {
#line 638
    tmp___1 = "";
  }
#line 638
  verbose("%sstat name \"%s\"", tmp___1, name);
#line 639
  if (do_lstat) {
#line 639
    ret___0 = lstat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
  } else {
#line 639
    ret___0 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& st));
  }
#line 640
  if (ret___0 < 0) {
#line 641
    tmp___4 = __errno_location();
#line 641
    status = errno_to_portable(*tmp___4);
  } else {
#line 643
    stat_to_attrib((struct stat  const  *)(& st), & a___0);
#line 644
    send_attrib(id, (Attrib const   *)(& a___0));
#line 645
    status = 0;
  }
#line 647
  if (status != 0) {
#line 648
    send_status(id, (unsigned int )status);
  }
#line 649
  xfree((void *)name);
#line 650
  return;
}
}
#line 652 "sftp-server.c"
static void process_stat(void) 
{ 

  {
#line 655
  process_do_stat(0);
#line 656
  return;
}
}
#line 658 "sftp-server.c"
static void process_lstat(void) 
{ 

  {
#line 661
  process_do_stat(1);
#line 662
  return;
}
}
#line 664 "sftp-server.c"
static void process_fstat(void) 
{ Attrib a___0 ;
  struct stat st ;
  u_int32_t id ;
  int fd ;
  int ret___0 ;
  int handle ;
  int status ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 670
  status = 4;
#line 672
  id = buffer_get_int(& iqueue);
#line 673
  handle = get_handle();
#line 674
  tmp = handle_to_name(handle);
#line 674
  debug("request %u: fstat \"%s\" (handle %u)", id, tmp, handle);
#line 676
  fd = handle_to_fd(handle);
#line 677
  if (fd >= 0) {
#line 678
    ret___0 = fstat(fd, & st);
#line 679
    if (ret___0 < 0) {
#line 680
      tmp___0 = __errno_location();
#line 680
      status = errno_to_portable(*tmp___0);
    } else {
#line 682
      stat_to_attrib((struct stat  const  *)(& st), & a___0);
#line 683
      send_attrib(id, (Attrib const   *)(& a___0));
#line 684
      status = 0;
    }
  }
#line 687
  if (status != 0) {
#line 688
    send_status(id, (unsigned int )status);
  }
#line 689
  return;
}
}
#line 694 "sftp-server.c"
static struct timeval tv[2]  ;
#line 691 "sftp-server.c"
static struct timeval *attrib_to_tv(Attrib const   *a___0 ) 
{ 

  {
#line 696
  tv[0].tv_sec = (long )a___0->atime;
#line 697
  tv[0].tv_usec = 0L;
#line 698
  tv[1].tv_sec = (long )a___0->mtime;
#line 699
  tv[1].tv_usec = 0L;
#line 700
  return (tv);
}
}
#line 703 "sftp-server.c"
static void process_setstat(void) 
{ Attrib *a___0 ;
  u_int32_t id ;
  char *name ;
  int status ;
  int ret___0 ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char buf___1[64] ;
  time_t t ;
  struct tm *tmp___2 ;
  struct timeval *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 709
  status = 0;
#line 711
  id = buffer_get_int(& iqueue);
#line 712
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 712
  name = (char *)tmp;
#line 713
  a___0 = get_attrib();
#line 714
  debug("request %u: setstat name \"%s\"", id, name);
#line 715
  if (a___0->flags & 1U) {
#line 716
    logit("set \"%s\" size %llu", name, a___0->size);
#line 718
    ret___0 = truncate((char const   *)name, (long long )a___0->size);
#line 719
    if (ret___0 == -1) {
#line 720
      tmp___0 = __errno_location();
#line 720
      status = errno_to_portable(*tmp___0);
    }
  }
#line 722
  if (a___0->flags & 4U) {
#line 723
    logit("set \"%s\" mode %04o", name, a___0->perm);
#line 724
    ret___0 = chmod((char const   *)name, a___0->perm & 511U);
#line 725
    if (ret___0 == -1) {
#line 726
      tmp___1 = __errno_location();
#line 726
      status = errno_to_portable(*tmp___1);
    }
  }
#line 728
  if (a___0->flags & 8U) {
#line 730
    t = (time_t )a___0->mtime;
#line 732
    tmp___2 = localtime((time_t const   *)(& t));
#line 732
    strftime((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%Y%m%d-%H:%M:%S",
             (struct tm  const  * __restrict  )tmp___2);
#line 734
    logit("set \"%s\" modtime %s", name, buf___1);
#line 735
    tmp___3 = attrib_to_tv((Attrib const   *)a___0);
#line 735
    ret___0 = utimes((char const   *)name, (struct timeval  const  *)tmp___3);
#line 736
    if (ret___0 == -1) {
#line 737
      tmp___4 = __errno_location();
#line 737
      status = errno_to_portable(*tmp___4);
    }
  }
#line 739
  if (a___0->flags & 2U) {
#line 740
    logit("set \"%s\" owner %lu group %lu", name, (unsigned long )a___0->uid, (unsigned long )a___0->gid);
#line 742
    ret___0 = chown((char const   *)name, a___0->uid, a___0->gid);
#line 743
    if (ret___0 == -1) {
#line 744
      tmp___5 = __errno_location();
#line 744
      status = errno_to_portable(*tmp___5);
    }
  }
#line 746
  send_status(id, (unsigned int )status);
#line 747
  xfree((void *)name);
#line 748
  return;
}
}
#line 750 "sftp-server.c"
static void process_fsetstat(void) 
{ Attrib *a___0 ;
  u_int32_t id ;
  int handle ;
  int fd ;
  int ret___0 ;
  int status ;
  char *name ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char buf___1[64] ;
  time_t t ;
  struct tm *tmp___2 ;
  struct timeval *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 756
  status = 0;
#line 758
  id = buffer_get_int(& iqueue);
#line 759
  handle = get_handle();
#line 760
  a___0 = get_attrib();
#line 761
  debug("request %u: fsetstat handle %d", id, handle);
#line 762
  fd = handle_to_fd(handle);
#line 763
  if (fd < 0) {
#line 764
    status = 4;
  } else {
#line 766
    tmp = handle_to_name(handle);
#line 766
    name = tmp;
#line 768
    if (a___0->flags & 1U) {
#line 769
      logit("set \"%s\" size %llu", name, a___0->size);
#line 771
      ret___0 = ftruncate(fd, (long long )a___0->size);
#line 772
      if (ret___0 == -1) {
#line 773
        tmp___0 = __errno_location();
#line 773
        status = errno_to_portable(*tmp___0);
      }
    }
#line 775
    if (a___0->flags & 4U) {
#line 776
      logit("set \"%s\" mode %04o", name, a___0->perm);
#line 778
      ret___0 = fchmod(fd, a___0->perm & 511U);
#line 782
      if (ret___0 == -1) {
#line 783
        tmp___1 = __errno_location();
#line 783
        status = errno_to_portable(*tmp___1);
      }
    }
#line 785
    if (a___0->flags & 8U) {
#line 787
      t = (time_t )a___0->mtime;
#line 789
      tmp___2 = localtime((time_t const   *)(& t));
#line 789
      strftime((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%Y%m%d-%H:%M:%S",
               (struct tm  const  * __restrict  )tmp___2);
#line 791
      logit("set \"%s\" modtime %s", name, buf___1);
#line 793
      tmp___3 = attrib_to_tv((Attrib const   *)a___0);
#line 793
      ret___0 = futimes(fd, (struct timeval  const  *)tmp___3);
#line 797
      if (ret___0 == -1) {
#line 798
        tmp___4 = __errno_location();
#line 798
        status = errno_to_portable(*tmp___4);
      }
    }
#line 800
    if (a___0->flags & 2U) {
#line 801
      logit("set \"%s\" owner %lu group %lu", name, (unsigned long )a___0->uid, (unsigned long )a___0->gid);
#line 804
      ret___0 = fchown(fd, a___0->uid, a___0->gid);
#line 808
      if (ret___0 == -1) {
#line 809
        tmp___5 = __errno_location();
#line 809
        status = errno_to_portable(*tmp___5);
      }
    }
  }
#line 812
  send_status(id, (unsigned int )status);
#line 813
  return;
}
}
#line 815 "sftp-server.c"
static void process_opendir(void) 
{ DIR *dirp ;
  char *path ;
  int handle ;
  int status ;
  u_int32_t id ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 818
  dirp = (DIR *)((void *)0);
#line 820
  status = 4;
#line 823
  id = buffer_get_int(& iqueue);
#line 824
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 824
  path = (char *)tmp;
#line 825
  debug3("request %u: opendir", id);
#line 826
  logit("opendir \"%s\"", path);
#line 827
  dirp = opendir((char const   *)path);
#line 828
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 829
    tmp___0 = __errno_location();
#line 829
    status = errno_to_portable(*tmp___0);
  } else {
#line 831
    handle = handle_new(1, (char const   *)path, 0, dirp);
#line 832
    if (handle < 0) {
#line 833
      closedir(dirp);
    } else {
#line 835
      send_handle(id, handle);
#line 836
      status = 0;
    }
  }
#line 840
  if (status != 0) {
#line 841
    send_status(id, (unsigned int )status);
  }
#line 842
  xfree((void *)path);
#line 843
  return;
}
}
#line 845 "sftp-server.c"
static void process_readdir(void) 
{ DIR *dirp ;
  struct dirent *dp ;
  char *path ;
  int handle ;
  u_int32_t id ;
  char *tmp ;
  struct stat st ;
  char pathname[4096] ;
  Stat *stats ;
  int nstats ;
  int count ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 854
  id = buffer_get_int(& iqueue);
#line 855
  handle = get_handle();
#line 856
  tmp = handle_to_name(handle);
#line 856
  debug("request %u: readdir \"%s\" (handle %d)", id, tmp, handle);
#line 858
  dirp = handle_to_dir(handle);
#line 859
  path = handle_to_name(handle);
#line 860
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 861
    send_status(id, 4U);
  } else {
#line 860
    if ((unsigned int )path == (unsigned int )((void *)0)) {
#line 861
      send_status(id, 4U);
    } else {
#line 866
      nstats = 10;
#line 866
      count = 0;
#line 868
      tmp___0 = xcalloc((unsigned int )nstats, sizeof(Stat ));
#line 868
      stats = (Stat *)tmp___0;
#line 869
      while (1) {
#line 869
        dp = readdir(dirp);
#line 869
        if (! ((unsigned int )dp != (unsigned int )((void *)0))) {
#line 869
          break;
        }
#line 870
        if (count >= nstats) {
#line 871
          nstats *= 2;
#line 872
          tmp___1 = xrealloc((void *)stats, (unsigned int )nstats, sizeof(Stat ));
#line 872
          stats = (Stat *)tmp___1;
        }
#line 876
        if (0) {
#line 876
          __s1_len___0 = strlen((char const   *)path);
#line 876
          __s2_len___0 = strlen("/");
#line 876
          if (! ((unsigned int )((void const   *)(path + 1)) - (unsigned int )((void const   *)path) == 1U)) {
            goto _L___2;
          } else {
#line 876
            if (__s1_len___0 >= 4U) {
              _L___2: /* CIL Label */ 
#line 876
              if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 876
                tmp___22 = 1;
              } else {
#line 876
                if (__s2_len___0 >= 4U) {
#line 876
                  tmp___22 = 1;
                } else {
#line 876
                  tmp___22 = 0;
                }
              }
            } else {
#line 876
              tmp___22 = 0;
            }
          }
#line 876
          if (tmp___22) {
#line 876
            tmp___18 = __builtin_strcmp((char const   *)path, "/");
          } else {
#line 876
            tmp___21 = __builtin_strcmp((char const   *)path, "/");
#line 876
            tmp___18 = tmp___21;
          }
        } else {
#line 876
          tmp___21 = __builtin_strcmp((char const   *)path, "/");
#line 876
          tmp___18 = tmp___21;
        }
#line 876
        if (tmp___18) {
#line 876
          tmp___12 = "/";
        } else {
#line 876
          tmp___12 = "";
        }
#line 876
        snprintf((char * __restrict  )(pathname), sizeof(pathname), (char const   * __restrict  )"%s%s%s",
                 path, tmp___12, dp->d_name);
#line 877
        tmp___23 = lstat((char const   * __restrict  )(pathname), (struct stat * __restrict  )(& st));
#line 877
        if (tmp___23 < 0) {
#line 878
          continue;
        }
#line 879
        stat_to_attrib((struct stat  const  *)(& st), & (stats + count)->attrib);
#line 880
        (stats + count)->name = xstrdup((char const   *)(dp->d_name));
#line 881
        (stats + count)->long_name = ls_file((char const   *)(dp->d_name), (struct stat  const  *)(& st),
                                             0);
#line 882
        count ++;
#line 885
        if (count == 100) {
#line 886
          break;
        }
      }
#line 888
      if (count > 0) {
#line 889
        send_names(id, count, (Stat const   *)stats);
#line 890
        i = 0;
#line 890
        while (i < count) {
#line 891
          xfree((void *)(stats + i)->name);
#line 892
          xfree((void *)(stats + i)->long_name);
#line 890
          i ++;
        }
      } else {
#line 895
        send_status(id, 1U);
      }
#line 897
      xfree((void *)stats);
    }
  }
#line 899
  return;
}
}
#line 901 "sftp-server.c"
static void process_remove(void) 
{ char *name ;
  u_int32_t id ;
  int status ;
  int ret___0 ;
  void *tmp ;
  int *tmp___2 ;

  {
#line 906
  status = 4;
#line 909
  id = buffer_get_int(& iqueue);
#line 910
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 910
  name = (char *)tmp;
#line 911
  debug3("request %u: remove", id);
#line 912
  logit("remove name \"%s\"", name);
#line 913
  ret___0 = unlink((char const   *)name);
#line 914
  if (ret___0 == -1) {
#line 914
    tmp___2 = __errno_location();
#line 914
    status = errno_to_portable(*tmp___2);
  } else {
#line 914
    status = 0;
  }
#line 915
  send_status(id, (unsigned int )status);
#line 916
  xfree((void *)name);
#line 917
  return;
}
}
#line 919 "sftp-server.c"
static void process_mkdir(void) 
{ Attrib *a___0 ;
  u_int32_t id ;
  char *name ;
  int ret___0 ;
  int mode ;
  int status ;
  void *tmp ;
  int *tmp___2 ;

  {
#line 925
  status = 4;
#line 927
  id = buffer_get_int(& iqueue);
#line 928
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 928
  name = (char *)tmp;
#line 929
  a___0 = get_attrib();
#line 930
  if (a___0->flags & 4U) {
#line 930
    mode = (int )(a___0->perm & 511U);
  } else {
#line 930
    mode = 511;
  }
#line 932
  debug3("request %u: mkdir", id);
#line 933
  logit("mkdir name \"%s\" mode 0%o", name, mode);
#line 934
  ret___0 = mkdir((char const   *)name, (unsigned int )mode);
#line 935
  if (ret___0 == -1) {
#line 935
    tmp___2 = __errno_location();
#line 935
    status = errno_to_portable(*tmp___2);
  } else {
#line 935
    status = 0;
  }
#line 936
  send_status(id, (unsigned int )status);
#line 937
  xfree((void *)name);
#line 938
  return;
}
}
#line 940 "sftp-server.c"
static void process_rmdir(void) 
{ u_int32_t id ;
  char *name ;
  int ret___0 ;
  int status ;
  void *tmp ;
  int *tmp___2 ;

  {
#line 947
  id = buffer_get_int(& iqueue);
#line 948
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 948
  name = (char *)tmp;
#line 949
  debug3("request %u: rmdir", id);
#line 950
  logit("rmdir name \"%s\"", name);
#line 951
  ret___0 = rmdir((char const   *)name);
#line 952
  if (ret___0 == -1) {
#line 952
    tmp___2 = __errno_location();
#line 952
    status = errno_to_portable(*tmp___2);
  } else {
#line 952
    status = 0;
  }
#line 953
  send_status(id, (unsigned int )status);
#line 954
  xfree((void *)name);
#line 955
  return;
}
}
#line 957 "sftp-server.c"
static void process_realpath(void) 
{ char resolvedname[4096] ;
  u_int32_t id ;
  char *path ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  Stat s ;
  char *tmp___2 ;

  {
#line 964
  id = buffer_get_int(& iqueue);
#line 965
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 965
  path = (char *)tmp;
#line 966
  if ((int )*(path + 0) == 0) {
#line 967
    xfree((void *)path);
#line 968
    path = xstrdup(".");
  }
#line 970
  debug3("request %u: realpath", id);
#line 971
  verbose("realpath \"%s\"", path);
#line 972
  tmp___2 = realpath((char const   * __restrict  )path, (char * __restrict  )(resolvedname));
#line 972
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
#line 973
    tmp___0 = __errno_location();
#line 973
    tmp___1 = errno_to_portable(*tmp___0);
#line 973
    send_status(id, (unsigned int )tmp___1);
  } else {
#line 976
    attrib_clear(& s.attrib);
#line 977
    s.long_name = resolvedname;
#line 977
    s.name = s.long_name;
#line 978
    send_names(id, 1, (Stat const   *)(& s));
  }
#line 980
  xfree((void *)path);
#line 981
  return;
}
}
#line 983 "sftp-server.c"
static void process_rename(void) 
{ u_int32_t id ;
  char *oldpath ;
  char *newpath ;
  int status ;
  struct stat sb ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  struct stat st ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 991
  id = buffer_get_int(& iqueue);
#line 992
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 992
  oldpath = (char *)tmp;
#line 993
  tmp___0 = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 993
  newpath = (char *)tmp___0;
#line 994
  debug3("request %u: rename", id);
#line 995
  logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
#line 996
  status = 4;
#line 997
  tmp___14 = lstat((char const   * __restrict  )oldpath, (struct stat * __restrict  )(& sb));
#line 997
  if (tmp___14 == -1) {
#line 998
    tmp___1 = __errno_location();
#line 998
    status = errno_to_portable(*tmp___1);
  } else {
#line 999
    if ((sb.st_mode & 61440U) == 32768U) {
#line 1001
      tmp___10 = link((char const   *)oldpath, (char const   *)newpath);
#line 1001
      if (tmp___10 == -1) {
#line 1002
        tmp___6 = __errno_location();
#line 1002
        if (*tmp___6 == 95) {
          goto _L;
        } else {
#line 1002
          tmp___7 = __errno_location();
#line 1002
          if (*tmp___7 == 1) {
            _L: /* CIL Label */ 
#line 1013
            tmp___4 = stat((char const   * __restrict  )newpath, (struct stat * __restrict  )(& st));
#line 1013
            if (tmp___4 == -1) {
#line 1014
              tmp___3 = rename((char const   *)oldpath, (char const   *)newpath);
#line 1014
              if (tmp___3 == -1) {
#line 1015
                tmp___2 = __errno_location();
#line 1015
                status = errno_to_portable(*tmp___2);
              } else {
#line 1018
                status = 0;
              }
            }
          } else {
#line 1021
            tmp___5 = __errno_location();
#line 1021
            status = errno_to_portable(*tmp___5);
          }
        }
      } else {
#line 1023
        tmp___9 = unlink((char const   *)oldpath);
#line 1023
        if (tmp___9 == -1) {
#line 1024
          tmp___8 = __errno_location();
#line 1024
          status = errno_to_portable(*tmp___8);
#line 1026
          unlink((char const   *)newpath);
        } else {
#line 1028
          status = 0;
        }
      }
    } else {
#line 1029
      tmp___13 = stat((char const   * __restrict  )newpath, (struct stat * __restrict  )(& sb));
#line 1029
      if (tmp___13 == -1) {
#line 1030
        tmp___12 = rename((char const   *)oldpath, (char const   *)newpath);
#line 1030
        if (tmp___12 == -1) {
#line 1031
          tmp___11 = __errno_location();
#line 1031
          status = errno_to_portable(*tmp___11);
        } else {
#line 1033
          status = 0;
        }
      }
    }
  }
#line 1035
  send_status(id, (unsigned int )status);
#line 1036
  xfree((void *)oldpath);
#line 1037
  xfree((void *)newpath);
#line 1038
  return;
}
}
#line 1040 "sftp-server.c"
static void process_readlink(void) 
{ u_int32_t id ;
  int len ;
  char buf___1[4096] ;
  char *path ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  Stat s ;

  {
#line 1048
  id = buffer_get_int(& iqueue);
#line 1049
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1049
  path = (char *)tmp;
#line 1050
  debug3("request %u: readlink", id);
#line 1051
  verbose("readlink \"%s\"", path);
#line 1052
  len = readlink((char const   * __restrict  )path, (char * __restrict  )(buf___1),
                 sizeof(buf___1) - 1U);
#line 1052
  if (len == -1) {
#line 1053
    tmp___0 = __errno_location();
#line 1053
    tmp___1 = errno_to_portable(*tmp___0);
#line 1053
    send_status(id, (unsigned int )tmp___1);
  } else {
#line 1057
    buf___1[len] = (char )'\000';
#line 1058
    attrib_clear(& s.attrib);
#line 1059
    s.long_name = buf___1;
#line 1059
    s.name = s.long_name;
#line 1060
    send_names(id, 1, (Stat const   *)(& s));
  }
#line 1062
  xfree((void *)path);
#line 1063
  return;
}
}
#line 1065 "sftp-server.c"
static void process_symlink(void) 
{ u_int32_t id ;
  char *oldpath ;
  char *newpath ;
  int ret___0 ;
  int status ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___3 ;

  {
#line 1072
  id = buffer_get_int(& iqueue);
#line 1073
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1073
  oldpath = (char *)tmp;
#line 1074
  tmp___0 = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1074
  newpath = (char *)tmp___0;
#line 1075
  debug3("request %u: symlink", id);
#line 1076
  logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
#line 1078
  ret___0 = symlink((char const   *)oldpath, (char const   *)newpath);
#line 1079
  if (ret___0 == -1) {
#line 1079
    tmp___3 = __errno_location();
#line 1079
    status = errno_to_portable(*tmp___3);
  } else {
#line 1079
    status = 0;
  }
#line 1080
  send_status(id, (unsigned int )status);
#line 1081
  xfree((void *)oldpath);
#line 1082
  xfree((void *)newpath);
#line 1083
  return;
}
}
#line 1085 "sftp-server.c"
static void process_extended_posix_rename(u_int32_t id ) 
{ char *oldpath ;
  char *newpath ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1090
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1090
  oldpath = (char *)tmp;
#line 1091
  tmp___0 = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1091
  newpath = (char *)tmp___0;
#line 1092
  debug3("request %u: posix-rename", id);
#line 1093
  logit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
#line 1094
  tmp___3 = rename((char const   *)oldpath, (char const   *)newpath);
#line 1094
  if (tmp___3 == -1) {
#line 1095
    tmp___1 = __errno_location();
#line 1095
    tmp___2 = errno_to_portable(*tmp___1);
#line 1095
    send_status(id, (unsigned int )tmp___2);
  } else {
#line 1097
    send_status(id, 0U);
  }
#line 1098
  xfree((void *)oldpath);
#line 1099
  xfree((void *)newpath);
#line 1100
  return;
}
}
#line 1102 "sftp-server.c"
static void process_extended(void) 
{ u_int32_t id ;
  char *request ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1108
  id = buffer_get_int(& iqueue);
#line 1109
  tmp = buffer_get_string(& iqueue, (u_int *)((void *)0));
#line 1109
  request = (char *)tmp;
#line 1110
  if (0) {
#line 1110
    __s1_len = strlen((char const   *)request);
#line 1110
    __s2_len = strlen("posix-rename@openssh.com");
#line 1110
    if (! ((unsigned int )((void const   *)(request + 1)) - (unsigned int )((void const   *)request) == 1U)) {
      goto _L___0;
    } else {
#line 1110
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1110
        if (! ((unsigned int )((void const   *)("posix-rename@openssh.com" + 1)) - (unsigned int )((void const   *)"posix-rename@openssh.com") == 1U)) {
#line 1110
          tmp___9 = 1;
        } else {
#line 1110
          if (__s2_len >= 4U) {
#line 1110
            tmp___9 = 1;
          } else {
#line 1110
            tmp___9 = 0;
          }
        }
      } else {
#line 1110
        tmp___9 = 0;
      }
    }
#line 1110
    if (tmp___9) {
#line 1110
      tmp___5 = __builtin_strcmp((char const   *)request, "posix-rename@openssh.com");
    } else {
#line 1110
      tmp___8 = __builtin_strcmp((char const   *)request, "posix-rename@openssh.com");
#line 1110
      tmp___5 = tmp___8;
    }
  } else {
#line 1110
    tmp___8 = __builtin_strcmp((char const   *)request, "posix-rename@openssh.com");
#line 1110
    tmp___5 = tmp___8;
  }
#line 1110
  if (tmp___5 == 0) {
#line 1111
    process_extended_posix_rename(id);
  } else {
#line 1113
    send_status(id, 8U);
  }
#line 1114
  xfree((void *)request);
#line 1115
  return;
}
}
#line 1119 "sftp-server.c"
static void process(void) 
{ u_int msg_len ;
  u_int buf_len ;
  u_int consumed ;
  u_int type ;
  u_char *cp ;
  void *tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 1128
  buf_len = buffer_len(& iqueue);
#line 1129
  if (buf_len < 5U) {
#line 1130
    return;
  }
#line 1131
  tmp = buffer_ptr(& iqueue);
#line 1131
  cp = (u_char *)tmp;
#line 1132
  msg_len = get_u32((void const   *)cp);
#line 1133
  if (msg_len > 262144U) {
#line 1134
    error("bad message from %s local user %s", client_addr, pw->pw_name);
#line 1136
    sftp_server_cleanup_exit(11);
  }
#line 1138
  if (buf_len < msg_len + 4U) {
#line 1139
    return;
  }
#line 1140
  buffer_consume(& iqueue, 4U);
#line 1141
  buf_len -= 4U;
#line 1142
  tmp___0 = buffer_get_char(& iqueue);
#line 1142
  type = (unsigned int )tmp___0;
#line 1143
  switch ((int )type) {
  case 1: 
#line 1145
  process_init();
#line 1146
  break;
  case 3: 
#line 1148
  process_open();
#line 1149
  break;
  case 4: 
#line 1151
  process_close();
#line 1152
  break;
  case 5: 
#line 1154
  process_read();
#line 1155
  break;
  case 6: 
#line 1157
  process_write();
#line 1158
  break;
  case 7: 
#line 1160
  process_lstat();
#line 1161
  break;
  case 8: 
#line 1163
  process_fstat();
#line 1164
  break;
  case 9: 
#line 1166
  process_setstat();
#line 1167
  break;
  case 10: 
#line 1169
  process_fsetstat();
#line 1170
  break;
  case 11: 
#line 1172
  process_opendir();
#line 1173
  break;
  case 12: 
#line 1175
  process_readdir();
#line 1176
  break;
  case 13: 
#line 1178
  process_remove();
#line 1179
  break;
  case 14: 
#line 1181
  process_mkdir();
#line 1182
  break;
  case 15: 
#line 1184
  process_rmdir();
#line 1185
  break;
  case 16: 
#line 1187
  process_realpath();
#line 1188
  break;
  case 17: 
#line 1190
  process_stat();
#line 1191
  break;
  case 18: 
#line 1193
  process_rename();
#line 1194
  break;
  case 19: 
#line 1196
  process_readlink();
#line 1197
  break;
  case 20: 
#line 1199
  process_symlink();
#line 1200
  break;
  case 200: 
#line 1202
  process_extended();
#line 1203
  break;
  default: 
#line 1205
  error("Unknown message %d", type);
#line 1206
  break;
  }
#line 1209
  tmp___1 = buffer_len(& iqueue);
#line 1209
  if (buf_len < tmp___1) {
#line 1210
    error("iqueue grew unexpectedly");
#line 1211
    sftp_server_cleanup_exit(255);
  }
#line 1213
  tmp___2 = buffer_len(& iqueue);
#line 1213
  consumed = buf_len - tmp___2;
#line 1214
  if (msg_len < consumed) {
#line 1215
    error("msg_len %d < consumed %d", msg_len, consumed);
#line 1216
    sftp_server_cleanup_exit(255);
  }
#line 1218
  if (msg_len > consumed) {
#line 1219
    buffer_consume(& iqueue, msg_len - consumed);
  }
#line 1220
  return;
}
}
#line 1223
 __attribute__((__noreturn__)) void sftp_server_cleanup_exit(int i ) ;
#line 1223 "sftp-server.c"
void sftp_server_cleanup_exit(int i ) 
{ 

  {
#line 1226
  if ((unsigned int )pw != (unsigned int )((void *)0)) {
#line 1226
    if ((unsigned int )client_addr != (unsigned int )((void *)0)) {
#line 1227
      handle_log_exit();
#line 1228
      logit("session closed for local user %s from [%s]", pw->pw_name, client_addr);
    }
  }
#line 1231
  _exit(i);
}
}
#line 1234 "sftp-server.c"
static void sftp_server_usage(void) 
{ 

  {
#line 1239
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: %s [-he] [-l log_level] [-f log_facility]\n",
          __progname);
#line 1241
  exit(1);
}
}
#line 1244 "sftp-server.c"
int sftp_server_main(int argc , char **argv , struct passwd *user_pw ) 
{ fd_set *rset ;
  fd_set *wset ;
  int in ;
  int out ;
  int max ;
  int ch ;
  int skipargs ;
  int log_stderr___0 ;
  ssize_t len ;
  ssize_t olen ;
  ssize_t set_size ;
  SyslogFacility log_facility___0 ;
  char *cp ;
  char buf___1[16384] ;
  char *tmp ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  register char __result ;
  void *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  register char __result___0 ;
  int tmp___16 ;

  {
#line 1248
  skipargs = 0;
#line 1248
  log_stderr___0 = 0;
#line 1250
  log_facility___0 = 2;
#line 1256
  __progname = ssh_get_progname(*(argv + 0));
#line 1257
  log_init(__progname, log_level, log_facility___0, log_stderr___0);
#line 1259
  while (1) {
#line 1259
    if (! skipargs) {
#line 1259
      ch = BSDgetopt(argc, (char * const  *)argv, "C:f:l:che");
#line 1259
      if (! (ch != -1)) {
#line 1259
        break;
      }
    } else {
#line 1259
      break;
    }
#line 1260
    switch (ch) {
    case 99: 
#line 1266
    skipargs = 1;
#line 1267
    break;
    case 101: 
#line 1269
    log_stderr___0 = 1;
#line 1270
    break;
    case 108: 
#line 1272
    log_level = log_level_number(BSDoptarg);
#line 1273
    if ((int )log_level == -1) {
#line 1274
      error("Invalid log level \"%s\"", BSDoptarg);
    }
#line 1275
    break;
    case 102: 
#line 1277
    log_facility___0 = log_facility_number(BSDoptarg);
#line 1278
    if ((int )log_facility___0 == -1) {
#line 1279
      error("Invalid log facility \"%s\"", BSDoptarg);
    }
#line 1280
    break;
    case 104: 
    default: 
#line 1283
    sftp_server_usage();
    }
  }
#line 1287
  log_init(__progname, log_level, log_facility___0, log_stderr___0);
#line 1289
  cp = getenv("SSH_CONNECTION");
#line 1289
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1290
    client_addr = xstrdup((char const   *)cp);
#line 1291
    tmp___1 = __builtin_strchr(client_addr, ' ');
#line 1291
    cp = tmp___1;
#line 1291
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1292
      tmp = getenv("SSH_CONNECTION");
#line 1292
      error("Malformed SSH_CONNECTION variable: \"%s\"", tmp);
#line 1294
      sftp_server_cleanup_exit(255);
    }
#line 1296
    *cp = (char )'\000';
  } else {
#line 1298
    client_addr = xstrdup("UNKNOWN");
  }
#line 1300
  pw = pwcopy(user_pw);
#line 1302
  logit("session opened for local user %s from [%s]", pw->pw_name, client_addr);
#line 1305
  in = dup(0);
#line 1306
  out = dup(1);
#line 1313
  max = 0;
#line 1314
  if (in > max) {
#line 1315
    max = in;
  }
#line 1316
  if (out > max) {
#line 1317
    max = out;
  }
#line 1319
  buffer_init(& iqueue);
#line 1320
  buffer_init(& oqueue);
#line 1322
  set_size = (int )((((unsigned int )(max + 1) + (8U * sizeof(__fd_mask ) - 1U)) / (8U * sizeof(__fd_mask ))) * sizeof(fd_mask ));
#line 1323
  tmp___2 = xmalloc((unsigned int )set_size);
#line 1323
  rset = (fd_set *)tmp___2;
#line 1324
  tmp___3 = xmalloc((unsigned int )set_size);
#line 1324
  wset = (fd_set *)tmp___3;
#line 1326
  while (1) {
#line 1327
    memset((void *)rset, 0, (unsigned int )set_size);
#line 1328
    memset((void *)wset, 0, (unsigned int )set_size);
#line 1335
    tmp___4 = buffer_check_alloc(& iqueue, sizeof(buf___1));
#line 1335
    if (tmp___4) {
#line 1335
      tmp___5 = buffer_check_alloc(& oqueue, 262144U);
#line 1335
      if (tmp___5) {
#line 1337
        __asm__  volatile   ("btsl %1,%0": "=m" (rset->fds_bits[(unsigned int )in / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )in % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
      }
    }
#line 1339
    tmp___6 = buffer_len(& oqueue);
#line 1339
    olen = (int )tmp___6;
#line 1340
    if (olen > 0) {
#line 1341
      __asm__  volatile   ("btsl %1,%0": "=m" (wset->fds_bits[(unsigned int )out / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )out % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
    }
#line 1343
    tmp___10 = select(max + 1, (fd_set * __restrict  )rset, (fd_set * __restrict  )wset,
                      (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 1343
    if (tmp___10 < 0) {
#line 1344
      tmp___7 = __errno_location();
#line 1344
      if (*tmp___7 == 4) {
        goto __Cont;
      }
#line 1346
      tmp___8 = __errno_location();
#line 1346
      tmp___9 = strerror(*tmp___8);
#line 1346
      error("select: %s", tmp___9);
#line 1347
      sftp_server_cleanup_exit(2);
    }
#line 1351
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result): "r" ((unsigned int )in % (8U * sizeof(__fd_mask ))),
                         "m" (rset->fds_bits[(unsigned int )in / (8U * sizeof(__fd_mask ))]): "cc");
#line 1351
    if (__result) {
#line 1352
      len = read(in, (void *)(buf___1), sizeof(buf___1));
#line 1353
      if (len == 0) {
#line 1354
        debug("read eof");
#line 1355
        sftp_server_cleanup_exit(0);
      } else {
#line 1356
        if (len < 0) {
#line 1357
          tmp___11 = __errno_location();
#line 1357
          tmp___12 = strerror(*tmp___11);
#line 1357
          error("read: %s", tmp___12);
#line 1358
          sftp_server_cleanup_exit(1);
        } else {
#line 1360
          buffer_append(& iqueue, (void const   *)(buf___1), (unsigned int )len);
        }
      }
    }
#line 1364
    __asm__  volatile   ("btl %1,%2 ; setcb %b0": "=q" (__result___0): "r" ((unsigned int )out % (8U * sizeof(__fd_mask ))),
                         "m" (wset->fds_bits[(unsigned int )out / (8U * sizeof(__fd_mask ))]): "cc");
#line 1364
    if (__result___0) {
#line 1365
      tmp___13 = buffer_ptr(& oqueue);
#line 1365
      len = write(out, (void const   *)tmp___13, (unsigned int )olen);
#line 1366
      if (len < 0) {
#line 1367
        tmp___14 = __errno_location();
#line 1367
        tmp___15 = strerror(*tmp___14);
#line 1367
        error("write: %s", tmp___15);
#line 1368
        sftp_server_cleanup_exit(1);
      } else {
#line 1370
        buffer_consume(& oqueue, (unsigned int )len);
      }
    }
#line 1379
    tmp___16 = buffer_check_alloc(& oqueue, 262144U);
#line 1379
    if (tmp___16) {
#line 1380
      process();
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 1 "sftp-common.o"
#line 46 "sftp-common.h"
void attrib_to_stat(Attrib const   *a___0 , struct stat *st ) ;
#line 51
char const   *fx2txt(int status ) ;
#line 48 "sftp-common.c"
void attrib_clear(Attrib *a___0 ) 
{ 

  {
#line 51
  a___0->flags = 0U;
#line 52
  a___0->size = 0ULL;
#line 53
  a___0->uid = 0U;
#line 54
  a___0->gid = 0U;
#line 55
  a___0->perm = 0U;
#line 56
  a___0->atime = 0U;
#line 57
  a___0->mtime = 0U;
#line 58
  return;
}
}
#line 61 "sftp-common.c"
void stat_to_attrib(struct stat  const  *st , Attrib *a___0 ) 
{ 

  {
#line 64
  attrib_clear(a___0);
#line 65
  a___0->flags = 0U;
#line 66
  a___0->flags |= 1U;
#line 67
  a___0->size = (unsigned long long )st->st_size;
#line 68
  a___0->flags |= 2U;
#line 69
  a___0->uid = (unsigned int )st->st_uid;
#line 70
  a___0->gid = (unsigned int )st->st_gid;
#line 71
  a___0->flags |= 4U;
#line 72
  a___0->perm = (unsigned int )st->st_mode;
#line 73
  a___0->flags |= 8U;
#line 74
  a___0->atime = (unsigned int )st->st_atim.tv_sec;
#line 75
  a___0->mtime = (unsigned int )st->st_mtim.tv_sec;
#line 76
  return;
}
}
#line 79 "sftp-common.c"
void attrib_to_stat(Attrib const   *a___0 , struct stat *st ) 
{ 

  {
#line 82
  memset((void *)st, 0, sizeof(*st));
#line 84
  if (a___0->flags & 1U) {
#line 85
    st->st_size = (long long )a___0->size;
  }
#line 86
  if (a___0->flags & 2U) {
#line 87
    st->st_uid = (unsigned int )a___0->uid;
#line 88
    st->st_gid = (unsigned int )a___0->gid;
  }
#line 90
  if (a___0->flags & 4U) {
#line 91
    st->st_mode = (unsigned int )a___0->perm;
  }
#line 92
  if (a___0->flags & 8U) {
#line 93
    st->st_atim.tv_sec = (long )a___0->atime;
#line 94
    st->st_mtim.tv_sec = (long )a___0->mtime;
  }
#line 96
  return;
}
}
#line 102 "sftp-common.c"
static Attrib a  ;
#line 99 "sftp-common.c"
Attrib *decode_attrib(Buffer *b ) 
{ char *type ;
  char *data ;
  int i ;
  int count ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 104
  attrib_clear(& a);
#line 105
  a.flags = buffer_get_int(b);
#line 106
  if (a.flags & 1U) {
#line 107
    a.size = buffer_get_int64(b);
  }
#line 108
  if (a.flags & 2U) {
#line 109
    a.uid = buffer_get_int(b);
#line 110
    a.gid = buffer_get_int(b);
  }
#line 112
  if (a.flags & 4U) {
#line 113
    a.perm = buffer_get_int(b);
  }
#line 114
  if (a.flags & 8U) {
#line 115
    a.atime = buffer_get_int(b);
#line 116
    a.mtime = buffer_get_int(b);
  }
#line 119
  if (a.flags & 2147483648U) {
#line 123
    tmp = buffer_get_int(b);
#line 123
    count = (int )tmp;
#line 124
    i = 0;
#line 124
    while (i < count) {
#line 125
      tmp___0 = buffer_get_string(b, (u_int *)((void *)0));
#line 125
      type = (char *)tmp___0;
#line 126
      tmp___1 = buffer_get_string(b, (u_int *)((void *)0));
#line 126
      data = (char *)tmp___1;
#line 127
      debug3("Got file attribute \"%s\"", type);
#line 128
      xfree((void *)type);
#line 129
      xfree((void *)data);
#line 124
      i ++;
    }
  }
#line 132
  return (& a);
}
}
#line 136 "sftp-common.c"
void encode_attrib(Buffer *b , Attrib const   *a___0 ) 
{ 

  {
#line 139
  buffer_put_int(b, (unsigned int )a___0->flags);
#line 140
  if (a___0->flags & 1U) {
#line 141
    buffer_put_int64(b, (unsigned long long )a___0->size);
  }
#line 142
  if (a___0->flags & 2U) {
#line 143
    buffer_put_int(b, (unsigned int )a___0->uid);
#line 144
    buffer_put_int(b, (unsigned int )a___0->gid);
  }
#line 146
  if (a___0->flags & 4U) {
#line 147
    buffer_put_int(b, (unsigned int )a___0->perm);
  }
#line 148
  if (a___0->flags & 8U) {
#line 149
    buffer_put_int(b, (unsigned int )a___0->atime);
#line 150
    buffer_put_int(b, (unsigned int )a___0->mtime);
  }
#line 152
  return;
}
}
#line 155 "sftp-common.c"
char const   *fx2txt(int status ) 
{ 

  {
#line 158
  switch (status) {
  case 0: 
#line 160
  return ("No error");
  case 1: 
#line 162
  return ("End of file");
  case 2: 
#line 164
  return ("No such file or directory");
  case 3: 
#line 166
  return ("Permission denied");
  case 4: 
#line 168
  return ("Failure");
  case 5: 
#line 170
  return ("Bad message");
  case 6: 
#line 172
  return ("No connection");
  case 7: 
#line 174
  return ("Connection lost");
  case 8: 
#line 176
  return ("Operation unsupported");
  default: ;
#line 178
  return ("Unknown status");
  }
}
}
#line 186 "sftp-common.c"
char *ls_file(char const   *name , struct stat  const  *st , int remote___0 ) 
{ int ulen ;
  int glen ;
  int sz ;
  struct passwd *pw___0 ;
  struct group *gr ;
  struct tm *ltime ;
  struct tm *tmp ;
  char *user ;
  char *group ;
  char buf___1[1024] ;
  char mode[12] ;
  char tbuf[13] ;
  char ubuf[12] ;
  char gbuf[12] ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  time_t tmp___2 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;

  {
#line 189
  sz = 0;
#line 192
  tmp = localtime(& st->st_mtim.tv_sec);
#line 192
  ltime = tmp;
#line 196
  strmode((int )st->st_mode, mode);
#line 197
  if (! remote___0) {
#line 197
    pw___0 = getpwuid((unsigned int )st->st_uid);
#line 197
    if ((unsigned int )pw___0 != (unsigned int )((void *)0)) {
#line 198
      user = pw___0->pw_name;
    } else {
#line 200
      snprintf((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )"%u",
               (unsigned int )st->st_uid);
#line 201
      user = ubuf;
    }
  } else {
#line 200
    snprintf((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )"%u",
             (unsigned int )st->st_uid);
#line 201
    user = ubuf;
  }
#line 203
  if (! remote___0) {
#line 203
    gr = getgrgid((unsigned int )st->st_gid);
#line 203
    if ((unsigned int )gr != (unsigned int )((void *)0)) {
#line 204
      group = gr->gr_name;
    } else {
#line 206
      snprintf((char * __restrict  )(gbuf), sizeof(gbuf), (char const   * __restrict  )"%u",
               (unsigned int )st->st_gid);
#line 207
      group = gbuf;
    }
  } else {
#line 206
    snprintf((char * __restrict  )(gbuf), sizeof(gbuf), (char const   * __restrict  )"%u",
             (unsigned int )st->st_gid);
#line 207
    group = gbuf;
  }
#line 209
  if ((unsigned int )ltime != (unsigned int )((void *)0)) {
#line 210
    tmp___2 = time((time_t *)((void *)0));
#line 210
    if (tmp___2 - (time_t )st->st_mtim.tv_sec < 15768000L) {
#line 211
      tmp___0 = strftime((char * __restrict  )(tbuf), sizeof(tbuf), (char const   * __restrict  )"%b %e %H:%M",
                         (struct tm  const  * __restrict  )ltime);
#line 211
      sz = (int )tmp___0;
    } else {
#line 213
      tmp___1 = strftime((char * __restrict  )(tbuf), sizeof(tbuf), (char const   * __restrict  )"%b %e  %Y",
                         (struct tm  const  * __restrict  )ltime);
#line 213
      sz = (int )tmp___1;
    }
  }
#line 215
  if (sz == 0) {
#line 216
    tbuf[0] = (char )'\000';
  }
#line 217
  tmp___6 = strlen((char const   *)user);
#line 217
  if (tmp___6 > 8U) {
#line 217
    tmp___5 = strlen((char const   *)user);
#line 217
    ulen = (int )tmp___5;
  } else {
#line 217
    ulen = 8;
  }
#line 218
  tmp___10 = strlen((char const   *)group);
#line 218
  if (tmp___10 > 8U) {
#line 218
    tmp___9 = strlen((char const   *)group);
#line 218
    glen = (int )tmp___9;
  } else {
#line 218
    glen = 8;
  }
#line 219
  snprintf((char * __restrict  )(buf___1), sizeof(buf___1), (char const   * __restrict  )"%s %3u %-*s %-*s %8llu %s %s",
           mode, (unsigned int )st->st_nlink, ulen, user, glen, group, (unsigned long long )st->st_size,
           tbuf, name);
#line 222
  tmp___11 = xstrdup((char const   *)(buf___1));
#line 222
  return (tmp___11);
}
}
